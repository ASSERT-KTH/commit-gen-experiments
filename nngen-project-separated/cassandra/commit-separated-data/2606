BLEU SCORE: 3.817663819004394E-5

TEST MSG: cleanup
GENERATED MSG: brute - force replacement of throwing maps around with encapsulated TokenMetadata

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 17bd514 . . 042e2bc 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 183 , 9 + 183 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private static final AtomicInteger nextRepairCommand = new AtomicInteger ( ) ; <nl> <nl> - private static ScheduledRangeTransferExecutorService rangeXferExecutor = new ScheduledRangeTransferExecutorService ( ) ; <nl> + private static final ScheduledRangeTransferExecutorService rangeXferExecutor = new ScheduledRangeTransferExecutorService ( ) ; <nl> <nl> - private final List < IEndpointLifecycleSubscriber > lifecycleSubscribers = new CopyOnWriteArrayList < IEndpointLifecycleSubscriber > ( ) ; <nl> + private final List < IEndpointLifecycleSubscriber > lifecycleSubscribers = new CopyOnWriteArrayList < > ( ) ; <nl> <nl> private static final BackgroundActivityMonitor bgMonitor = new BackgroundActivityMonitor ( ) ; <nl> <nl> @ @ - 564 , 7 + 564 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> Thread drainOnShutdown = new Thread ( new WrappedRunnable ( ) <nl> { <nl> @ Override <nl> - public void runMayThrow ( ) throws ExecutionException , InterruptedException , IOException <nl> + public void runMayThrow ( ) throws InterruptedException <nl> { <nl> ExecutorService counterMutationStage = StageManager . getStage ( Stage . COUNTER _ MUTATION ) ; <nl> ExecutorService mutationStage = StageManager . getStage ( Stage . MUTATION ) ; <nl> @ @ - 584 , 7 + 584 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> mutationStage . awaitTermination ( 3600 , TimeUnit . SECONDS ) ; <nl> StorageProxy . instance . verifyNoHintsInProgress ( ) ; <nl> <nl> - List < Future < ? > > flushes = new ArrayList < Future < ? > > ( ) ; <nl> + List < Future < ? > > flushes = new ArrayList < > ( ) ; <nl> for ( Keyspace keyspace : Keyspace . all ( ) ) <nl> { <nl> KSMetaData ksm = Schema . instance . getKSMetaData ( keyspace . getName ( ) ) ; <nl> @ @ - 634 , 7 + 634 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> joined = true ; <nl> <nl> Collection < Token > tokens = null ; <nl> - Map < ApplicationState , VersionedValue > appStates = new HashMap < ApplicationState , VersionedValue > ( ) ; <nl> + Map < ApplicationState , VersionedValue > appStates = new HashMap < > ( ) ; <nl> <nl> if ( DatabaseDescriptor . getReplaceTokens ( ) . size ( ) > 0 | | DatabaseDescriptor . getReplaceNode ( ) ! = null ) <nl> throw new RuntimeException ( " Replace method removed ; use cassandra . replace _ address instead " ) ; <nl> @ @ - 684 , 7 + 684 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> / / <nl> / / We attempted to replace this with a schema - presence check , but you need a meaningful sleep <nl> / / to get schema info from gossip which defeats the purpose . See CASSANDRA - 4427 for the gory details . <nl> - Set < InetAddress > current = new HashSet < InetAddress > ( ) ; <nl> + Set < InetAddress > current = new HashSet < > ( ) ; <nl> logger . debug ( " Bootstrap variables : { } { } { } { } " , <nl> DatabaseDescriptor . isAutoBootstrap ( ) , <nl> SystemKeyspace . bootstrapInProgress ( ) , <nl> @ @ - 800 , 7 + 800 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> else <nl> { <nl> - tokens = new ArrayList < Token > ( initialTokens . size ( ) ) ; <nl> + tokens = new ArrayList < > ( initialTokens . size ( ) ) ; <nl> for ( String token : initialTokens ) <nl> tokens . add ( getPartitioner ( ) . getTokenFactory ( ) . fromString ( token ) ) ; <nl> logger . info ( " Saved tokens not found . Using configuration value : { } " , tokens ) ; <nl> @ @ - 1054 , 7 + 1054 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> public Map < List < String > , List < String > > getRangeToEndpointMap ( String keyspace ) <nl> { <nl> / * All the ranges for the tokens * / <nl> - Map < List < String > , List < String > > map = new HashMap < List < String > , List < String > > ( ) ; <nl> + Map < List < String > , List < String > > map = new HashMap < > ( ) ; <nl> for ( Map . Entry < Range < Token > , List < InetAddress > > entry : getRangeToAddressMap ( keyspace ) . entrySet ( ) ) <nl> { <nl> map . put ( entry . getKey ( ) . asList ( ) , stringify ( entry . getValue ( ) ) ) ; <nl> @ @ - 1085 , 10 + 1085 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> public Map < List < String > , List < String > > getRangeToRpcaddressMap ( String keyspace ) <nl> { <nl> / * All the ranges for the tokens * / <nl> - Map < List < String > , List < String > > map = new HashMap < List < String > , List < String > > ( ) ; <nl> + Map < List < String > , List < String > > map = new HashMap < > ( ) ; <nl> for ( Map . Entry < Range < Token > , List < InetAddress > > entry : getRangeToAddressMap ( keyspace ) . entrySet ( ) ) <nl> { <nl> - List < String > rpcaddrs = new ArrayList < String > ( entry . getValue ( ) . size ( ) ) ; <nl> + List < String > rpcaddrs = new ArrayList < > ( entry . getValue ( ) . size ( ) ) ; <nl> for ( InetAddress endpoint : entry . getValue ( ) ) <nl> { <nl> rpcaddrs . add ( getRpcaddress ( endpoint ) ) ; <nl> @ @ - 1105 , 10 + 1105 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( keyspace = = null ) <nl> keyspace = Schema . instance . getNonSystemKeyspaces ( ) . get ( 0 ) ; <nl> <nl> - Map < List < String > , List < String > > map = new HashMap < List < String > , List < String > > ( ) ; <nl> + Map < List < String > , List < String > > map = new HashMap < > ( ) ; <nl> for ( Map . Entry < Range < Token > , Collection < InetAddress > > entry : tokenMetadata . getPendingRanges ( keyspace ) . entrySet ( ) ) <nl> { <nl> - List < InetAddress > l = new ArrayList < InetAddress > ( entry . getValue ( ) ) ; <nl> + List < InetAddress > l = new ArrayList < > ( entry . getValue ( ) ) ; <nl> map . put ( entry . getKey ( ) . asList ( ) , stringify ( l ) ) ; <nl> } <nl> return map ; <nl> @ @ - 1189 , 7 + 1189 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> throw new IOException ( e . getMessage ( ) ) ; <nl> } <nl> - List < String > result = new ArrayList < String > ( tokenRanges . size ( ) ) ; <nl> + List < String > result = new ArrayList < > ( tokenRanges . size ( ) ) ; <nl> <nl> for ( TokenRange tokenRange : tokenRanges ) <nl> result . add ( tokenRange . toString ( ) ) ; <nl> @ @ - 1227 , 7 + 1227 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( keyspace = = null | | Keyspace . open ( keyspace ) . getReplicationStrategy ( ) instanceof LocalStrategy ) <nl> throw new InvalidRequestException ( " There is no ring for the keyspace : " + keyspace ) ; <nl> <nl> - List < TokenRange > ranges = new ArrayList < TokenRange > ( ) ; <nl> + List < TokenRange > ranges = new ArrayList < > ( ) ; <nl> Token . TokenFactory tf = getPartitioner ( ) . getTokenFactory ( ) ; <nl> <nl> Map < Range < Token > , List < InetAddress > > rangeToAddressMap = <nl> @ @ - 1239 , 9 + 1239 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> Range range = entry . getKey ( ) ; <nl> List < InetAddress > addresses = entry . getValue ( ) ; <nl> - List < String > endpoints = new ArrayList < String > ( addresses . size ( ) ) ; <nl> - List < String > rpc _ endpoints = new ArrayList < String > ( addresses . size ( ) ) ; <nl> - List < EndpointDetails > epDetails = new ArrayList < EndpointDetails > ( addresses . size ( ) ) ; <nl> + List < String > endpoints = new ArrayList < > ( addresses . size ( ) ) ; <nl> + List < String > rpc _ endpoints = new ArrayList < > ( addresses . size ( ) ) ; <nl> + List < EndpointDetails > epDetails = new ArrayList < > ( addresses . size ( ) ) ; <nl> <nl> for ( InetAddress endpoint : addresses ) <nl> { <nl> @ @ - 1270 , 8 + 1270 , 8 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> Map < Token , InetAddress > mapInetAddress = tokenMetadata . getNormalAndBootstrappingTokenToEndpointMap ( ) ; <nl> / / in order to preserve tokens in ascending order , we use LinkedHashMap here <nl> - Map < String , String > mapString = new LinkedHashMap < String , String > ( mapInetAddress . size ( ) ) ; <nl> - List < Token > tokens = new ArrayList < Token > ( mapInetAddress . keySet ( ) ) ; <nl> + Map < String , String > mapString = new LinkedHashMap < > ( mapInetAddress . size ( ) ) ; <nl> + List < Token > tokens = new ArrayList < > ( mapInetAddress . keySet ( ) ) ; <nl> Collections . sort ( tokens ) ; <nl> for ( Token token : tokens ) <nl> { <nl> @ @ - 1287 , 7 + 1287 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public Map < String , String > getHostIdMap ( ) <nl> { <nl> - Map < String , String > mapOut = new HashMap < String , String > ( ) ; <nl> + Map < String , String > mapOut = new HashMap < > ( ) ; <nl> for ( Map . Entry < InetAddress , UUID > entry : getTokenMetadata ( ) . getEndpointToHostIdMapForReading ( ) . entrySet ( ) ) <nl> mapOut . put ( entry . getKey ( ) . getHostAddress ( ) , entry . getValue ( ) . toString ( ) ) ; <nl> return mapOut ; <nl> @ @ - 1301 , 7 + 1301 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * / <nl> private Map < Range < Token > , List < InetAddress > > constructRangeToEndpointMap ( String keyspace , List < Range < Token > > ranges ) <nl> { <nl> - Map < Range < Token > , List < InetAddress > > rangeToEndpointMap = new HashMap < Range < Token > , List < InetAddress > > ( ) ; <nl> + Map < Range < Token > , List < InetAddress > > rangeToEndpointMap = new HashMap < > ( ) ; <nl> for ( Range < Token > range : ranges ) <nl> { <nl> rangeToEndpointMap . put ( range , Keyspace . open ( keyspace ) . getReplicationStrategy ( ) . getNaturalEndpoints ( range . right ) ) ; <nl> @ @ - 1358 , 20 + 1358 , 31 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> String moveName = pieces [ 0 ] ; <nl> <nl> - if ( moveName . equals ( VersionedValue . STATUS _ BOOTSTRAPPING ) ) <nl> - handleStateBootstrap ( endpoint ) ; <nl> - else if ( moveName . equals ( VersionedValue . STATUS _ NORMAL ) ) <nl> - handleStateNormal ( endpoint ) ; <nl> - else if ( moveName . equals ( VersionedValue . REMOVING _ TOKEN ) | | moveName . equals ( VersionedValue . REMOVED _ TOKEN ) ) <nl> - handleStateRemoving ( endpoint , pieces ) ; <nl> - else if ( moveName . equals ( VersionedValue . STATUS _ LEAVING ) ) <nl> - handleStateLeaving ( endpoint ) ; <nl> - else if ( moveName . equals ( VersionedValue . STATUS _ LEFT ) ) <nl> - handleStateLeft ( endpoint , pieces ) ; <nl> - else if ( moveName . equals ( VersionedValue . STATUS _ MOVING ) ) <nl> - handleStateMoving ( endpoint , pieces ) ; <nl> - else if ( moveName . equals ( VersionedValue . STATUS _ RELOCATING ) ) <nl> - handleStateRelocating ( endpoint , pieces ) ; <nl> + switch ( moveName ) <nl> + { <nl> + case VersionedValue . STATUS _ BOOTSTRAPPING : <nl> + handleStateBootstrap ( endpoint ) ; <nl> + break ; <nl> + case VersionedValue . STATUS _ NORMAL : <nl> + handleStateNormal ( endpoint ) ; <nl> + break ; <nl> + case VersionedValue . REMOVING _ TOKEN : <nl> + case VersionedValue . REMOVED _ TOKEN : <nl> + handleStateRemoving ( endpoint , pieces ) ; <nl> + break ; <nl> + case VersionedValue . STATUS _ LEAVING : <nl> + handleStateLeaving ( endpoint ) ; <nl> + break ; <nl> + case VersionedValue . STATUS _ LEFT : <nl> + handleStateLeft ( endpoint , pieces ) ; <nl> + break ; <nl> + case VersionedValue . STATUS _ MOVING : <nl> + handleStateMoving ( endpoint , pieces ) ; <nl> + break ; <nl> + case VersionedValue . STATUS _ RELOCATING : <nl> + handleStateRelocating ( endpoint , pieces ) ; <nl> + break ; <nl> + } <nl> } <nl> else <nl> { <nl> @ @ - 1477 , 10 + 1488 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> tokens = getTokensFor ( endpoint ) ; <nl> <nl> - Set < Token > tokensToUpdateInMetadata = new HashSet < Token > ( ) ; <nl> - Set < Token > tokensToUpdateInSystemKeyspace = new HashSet < Token > ( ) ; <nl> - Set < Token > localTokensToRemove = new HashSet < Token > ( ) ; <nl> - Set < InetAddress > endpointsToRemove = new HashSet < InetAddress > ( ) ; <nl> + Set < Token > tokensToUpdateInMetadata = new HashSet < > ( ) ; <nl> + Set < Token > tokensToUpdateInSystemKeyspace = new HashSet < > ( ) ; <nl> + Set < Token > localTokensToRemove = new HashSet < > ( ) ; <nl> + Set < InetAddress > endpointsToRemove = new HashSet < > ( ) ; <nl> <nl> <nl> if ( logger . isDebugEnabled ( ) ) <nl> @ @ - 1704 , 7 + 1715 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> assert pieces . length > = 2 ; <nl> <nl> - List < Token > tokens = new ArrayList < Token > ( pieces . length - 1 ) ; <nl> + List < Token > tokens = new ArrayList < > ( pieces . length - 1 ) ; <nl> for ( String tStr : Arrays . copyOfRange ( pieces , 1 , pieces . length ) ) <nl> tokens . add ( getPartitioner ( ) . getTokenFactory ( ) . fromString ( tStr ) ) ; <nl> <nl> @ @ - 1889 , 12 + 1900 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> Multimap < String , Map . Entry < InetAddress , Collection < Range < Token > > > > rangesToFetch = HashMultimap . create ( ) ; <nl> <nl> - final InetAddress myAddress = FBUtilities . getBroadcastAddress ( ) ; <nl> + InetAddress myAddress = FBUtilities . getBroadcastAddress ( ) ; <nl> <nl> for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) <nl> { <nl> Multimap < Range < Token > , InetAddress > changedRanges = getChangedRangesForLeaving ( keyspaceName , endpoint ) ; <nl> - Set < Range < Token > > myNewRanges = new HashSet < Range < Token > > ( ) ; <nl> + Set < Range < Token > > myNewRanges = new HashSet < > ( ) ; <nl> for ( Map . Entry < Range < Token > , InetAddress > entry : changedRanges . entries ( ) ) <nl> { <nl> if ( entry . getValue ( ) . equals ( myAddress ) ) <nl> @ @ - 1908 , 11 + 1919 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> <nl> StreamPlan stream = new StreamPlan ( " Restore replica count " ) ; <nl> - for ( final String keyspaceName : rangesToFetch . keySet ( ) ) <nl> + for ( String keyspaceName : rangesToFetch . keySet ( ) ) <nl> { <nl> for ( Map . Entry < InetAddress , Collection < Range < Token > > > entry : rangesToFetch . get ( keyspaceName ) ) <nl> { <nl> - final InetAddress source = entry . getKey ( ) ; <nl> + InetAddress source = entry . getKey ( ) ; <nl> Collection < Range < Token > > ranges = entry . getValue ( ) ; <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Requesting from { } ranges { } " , source , StringUtils . join ( ranges , " , " ) ) ; <nl> @ @ - 1945 , 7 + 1956 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Node { } ranges [ { } ] " , endpoint , StringUtils . join ( ranges , " , " ) ) ; <nl> <nl> - Map < Range < Token > , List < InetAddress > > currentReplicaEndpoints = new HashMap < Range < Token > , List < InetAddress > > ( ) ; <nl> + Map < Range < Token > , List < InetAddress > > currentReplicaEndpoints = new HashMap < > ( ) ; <nl> <nl> / / Find ( for each range ) all nodes that store replicas for these ranges as well <nl> for ( Range < Token > range : ranges ) <nl> @ @ - 2051 , 7 + 2062 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public Map < String , String > getLoadMap ( ) <nl> { <nl> - Map < String , String > map = new HashMap < String , String > ( ) ; <nl> + Map < String , String > map = new HashMap < > ( ) ; <nl> for ( Map . Entry < InetAddress , Double > entry : LoadBroadcaster . instance . getLoadInfo ( ) . entrySet ( ) ) <nl> { <nl> map . put ( entry . getKey ( ) . getHostAddress ( ) , FileUtils . stringifyFileSize ( entry . getValue ( ) ) ) ; <nl> @ @ - 2087 , 7 + 2098 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private List < String > getTokens ( InetAddress endpoint ) <nl> { <nl> - List < String > strTokens = new ArrayList < String > ( ) ; <nl> + List < String > strTokens = new ArrayList < > ( ) ; <nl> for ( Token tok : getTokenMetadata ( ) . getTokens ( endpoint ) ) <nl> strTokens . add ( tok . toString ( ) ) ; <nl> return strTokens ; <nl> @ @ - 2110 , 7 + 2121 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public List < String > getMovingNodes ( ) <nl> { <nl> - List < String > endpoints = new ArrayList < String > ( ) ; <nl> + List < String > endpoints = new ArrayList < > ( ) ; <nl> <nl> for ( Pair < Token , InetAddress > node : tokenMetadata . getMovingEndpoints ( ) ) <nl> { <nl> @ @ - 2155 , 7 + 2166 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private List < String > stringify ( Iterable < InetAddress > endpoints ) <nl> { <nl> - List < String > stringEndpoints = new ArrayList < String > ( ) ; <nl> + List < String > stringEndpoints = new ArrayList < > ( ) ; <nl> for ( InetAddress ep : endpoints ) <nl> { <nl> stringEndpoints . add ( ep . getHostAddress ( ) ) ; <nl> @ @ - 2235 , 7 + 2246 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> else <nl> { <nl> - ArrayList < Keyspace > t = new ArrayList < Keyspace > ( keyspaceNames . length ) ; <nl> + ArrayList < Keyspace > t = new ArrayList < > ( keyspaceNames . length ) ; <nl> for ( String keyspaceName : keyspaceNames ) <nl> t . add ( getValidKeyspace ( keyspaceName ) ) ; <nl> keyspaces = t ; <nl> @ @ - 2319 , 15 + 2330 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public Map < String , TabularData > getSnapshotDetails ( ) <nl> { <nl> - final Map < String , TabularData > snapshotMap = new HashMap < > ( ) ; <nl> - for ( final Keyspace keyspace : Keyspace . all ( ) ) <nl> + Map < String , TabularData > snapshotMap = new HashMap < > ( ) ; <nl> + for ( Keyspace keyspace : Keyspace . all ( ) ) <nl> { <nl> if ( Keyspace . SYSTEM _ KS . equals ( keyspace . getName ( ) ) ) <nl> continue ; <nl> <nl> - for ( final ColumnFamilyStore cfStore : keyspace . getColumnFamilyStores ( ) ) <nl> + for ( ColumnFamilyStore cfStore : keyspace . getColumnFamilyStores ( ) ) <nl> { <nl> - for ( final Map . Entry < String , Pair < Long , Long > > snapshotDetail : cfStore . getSnapshotDetails ( ) . entrySet ( ) ) <nl> + for ( Map . Entry < String , Pair < Long , Long > > snapshotDetail : cfStore . getSnapshotDetails ( ) . entrySet ( ) ) <nl> { <nl> TabularDataSupport data = ( TabularDataSupport ) snapshotMap . get ( snapshotDetail . getKey ( ) ) ; <nl> if ( data = = null ) <nl> @ @ - 2346 , 12 + 2357 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> public long trueSnapshotsSize ( ) <nl> { <nl> long total = 0 ; <nl> - for ( final Keyspace keyspace : Keyspace . all ( ) ) <nl> + for ( Keyspace keyspace : Keyspace . all ( ) ) <nl> { <nl> if ( Keyspace . SYSTEM _ KS . equals ( keyspace . getName ( ) ) ) <nl> continue ; <nl> <nl> - for ( final ColumnFamilyStore cfStore : keyspace . getColumnFamilyStores ( ) ) <nl> + for ( ColumnFamilyStore cfStore : keyspace . getColumnFamilyStores ( ) ) <nl> { <nl> total + = cfStore . trueSnapshotsSize ( ) ; <nl> } <nl> @ @ - 2419 , 7 + 2430 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> if ( idxName ! = null ) <nl> { <nl> - Collection < SecondaryIndex > indexes = cfStore . indexManager . getIndexesByNames ( new HashSet < String > ( Arrays . asList ( cfName ) ) ) ; <nl> + Collection < SecondaryIndex > indexes = cfStore . indexManager . getIndexesByNames ( new HashSet < > ( Arrays . asList ( cfName ) ) ) ; <nl> if ( indexes . isEmpty ( ) ) <nl> logger . warn ( String . format ( " Invalid column family index specified : % s / % s . Proceeding with others . " , baseCfName , idxName ) ) ; <nl> else <nl> @ @ - 2449 , 7 + 2460 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * @ param columnFamilies <nl> * @ throws IOException <nl> * / <nl> - public void forceKeyspaceFlush ( final String keyspaceName , final String . . . columnFamilies ) throws IOException <nl> + public void forceKeyspaceFlush ( String keyspaceName , String . . . columnFamilies ) throws IOException <nl> { <nl> for ( ColumnFamilyStore cfStore : getValidColumnFamilies ( true , false , keyspaceName , columnFamilies ) ) <nl> { <nl> @ @ - 2472 , 19 + 2483 , 19 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> sendNotification ( jmxNotification ) ; <nl> } <nl> <nl> - public int forceRepairAsync ( final String keyspace , final boolean isSequential , final Collection < String > dataCenters , Collection < String > hosts , final boolean primaryRange , final boolean fullRepair , final String . . . columnFamilies ) throws IOException <nl> + public int forceRepairAsync ( String keyspace , boolean isSequential , Collection < String > dataCenters , Collection < String > hosts , boolean primaryRange , boolean fullRepair , String . . . columnFamilies ) throws IOException <nl> { <nl> - final Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; <nl> + Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; <nl> <nl> return forceRepairAsync ( keyspace , isSequential , dataCenters , hosts , ranges , fullRepair , columnFamilies ) ; <nl> } <nl> <nl> - public int forceRepairAsync ( final String keyspace , final boolean isSequential , final Collection < String > dataCenters , Collection < String > hosts , final Collection < Range < Token > > ranges , final boolean fullRepair , final String . . . columnFamilies ) throws IOException <nl> + public int forceRepairAsync ( String keyspace , boolean isSequential , Collection < String > dataCenters , Collection < String > hosts , Collection < Range < Token > > ranges , boolean fullRepair , String . . . columnFamilies ) <nl> { <nl> if ( Keyspace . SYSTEM _ KS . equals ( keyspace ) | | ranges . isEmpty ( ) ) <nl> return 0 ; <nl> <nl> - final int cmd = nextRepairCommand . incrementAndGet ( ) ; <nl> + int cmd = nextRepairCommand . incrementAndGet ( ) ; <nl> if ( ranges . size ( ) > 0 ) <nl> { <nl> new Thread ( createRepairTask ( cmd , keyspace , ranges , isSequential , dataCenters , hosts , fullRepair , columnFamilies ) ) . start ( ) ; <nl> @ @ - 2492 , 9 + 2503 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return cmd ; <nl> } <nl> <nl> - public int forceRepairAsync ( final String keyspace , final boolean isSequential , final boolean isLocal , final boolean primaryRange , final boolean fullRepair , final String . . . columnFamilies ) <nl> + public int forceRepairAsync ( String keyspace , boolean isSequential , boolean isLocal , boolean primaryRange , boolean fullRepair , String . . . columnFamilies ) <nl> { <nl> - final Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; <nl> + Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; <nl> return forceRepairAsync ( keyspace , isSequential , isLocal , ranges , fullRepair , columnFamilies ) ; <nl> } <nl> <nl> @ @ - 2503 , 7 + 2514 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( Keyspace . SYSTEM _ KS . equals ( keyspace ) | | ranges . isEmpty ( ) ) <nl> return 0 ; <nl> <nl> - final int cmd = nextRepairCommand . incrementAndGet ( ) ; <nl> + int cmd = nextRepairCommand . incrementAndGet ( ) ; <nl> if ( ! FBUtilities . isUnix ( ) & & isSequential ) <nl> { <nl> logger . warn ( " Snapshot - based repair is not yet supported on Windows . Reverting to parallel repair . " ) ; <nl> @ @ - 2513 , 33 + 2524 , 33 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return cmd ; <nl> } <nl> <nl> - public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , Collection < String > hosts , boolean fullRepair , final String . . . columnFamilies ) throws IOException <nl> + public int forceRepairRangeAsync ( String beginToken , String endToken , String keyspaceName , boolean isSequential , Collection < String > dataCenters , Collection < String > hosts , boolean fullRepair , String . . . columnFamilies ) throws IOException <nl> { <nl> Token parsedBeginToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( beginToken ) ; <nl> Token parsedEndToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( endToken ) ; <nl> <nl> logger . info ( " starting user - requested repair of range ( { } , { } ] for keyspace { } and column families { } " , <nl> parsedBeginToken , parsedEndToken , keyspaceName , columnFamilies ) ; <nl> - return forceRepairAsync ( keyspaceName , isSequential , dataCenters , hosts , Collections . singleton ( new Range < Token > ( parsedBeginToken , parsedEndToken ) ) , fullRepair , columnFamilies ) ; <nl> + return forceRepairAsync ( keyspaceName , isSequential , dataCenters , hosts , Collections . singleton ( new Range < > ( parsedBeginToken , parsedEndToken ) ) , fullRepair , columnFamilies ) ; <nl> } <nl> <nl> - public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , boolean isLocal , boolean fullRepair , final String . . . columnFamilies ) <nl> + public int forceRepairRangeAsync ( String beginToken , String endToken , String keyspaceName , boolean isSequential , boolean isLocal , boolean fullRepair , String . . . columnFamilies ) <nl> { <nl> Token parsedBeginToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( beginToken ) ; <nl> Token parsedEndToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( endToken ) ; <nl> <nl> logger . info ( " starting user - requested repair of range ( { } , { } ] for keyspace { } and column families { } " , <nl> parsedBeginToken , parsedEndToken , keyspaceName , columnFamilies ) ; <nl> - return forceRepairAsync ( keyspaceName , isSequential , isLocal , Collections . singleton ( new Range < Token > ( parsedBeginToken , parsedEndToken ) ) , fullRepair , columnFamilies ) ; <nl> + return forceRepairAsync ( keyspaceName , isSequential , isLocal , Collections . singleton ( new Range < > ( parsedBeginToken , parsedEndToken ) ) , fullRepair , columnFamilies ) ; <nl> } <nl> <nl> - private FutureTask < Object > createRepairTask ( final int cmd , <nl> - final String keyspace , <nl> - final Collection < Range < Token > > ranges , <nl> - final boolean isSequential , <nl> - final boolean isLocal , <nl> - final boolean fullRepair , <nl> - final String . . . columnFamilies ) <nl> + private FutureTask < Object > createRepairTask ( int cmd , <nl> + String keyspace , <nl> + Collection < Range < Token > > ranges , <nl> + boolean isSequential , <nl> + boolean isLocal , <nl> + boolean fullRepair , <nl> + String . . . columnFamilies ) <nl> { <nl> Set < String > dataCenters = null ; <nl> if ( isLocal ) <nl> @ @ - 2657 , 9 + 2668 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> <nl> <nl> - public RepairFuture forceKeyspaceRepair ( final UUID parentRepairSession , <nl> - final Range < Token > range , <nl> - final String keyspaceName , <nl> + public RepairFuture forceKeyspaceRepair ( UUID parentRepairSession , <nl> + Range < Token > range , <nl> + String keyspaceName , <nl> boolean isSequential , <nl> Set < InetAddress > endpoints , <nl> String . . . columnFamilies ) throws IOException <nl> @ @ - 2698 , 13 + 2709 , 13 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> public Collection < Range < Token > > getPrimaryRangesForEndpoint ( String keyspace , InetAddress ep ) <nl> { <nl> AbstractReplicationStrategy strategy = Keyspace . open ( keyspace ) . getReplicationStrategy ( ) ; <nl> - Collection < Range < Token > > primaryRanges = new HashSet < Range < Token > > ( ) ; <nl> + Collection < Range < Token > > primaryRanges = new HashSet < > ( ) ; <nl> TokenMetadata metadata = tokenMetadata . cloneOnlyTokenMap ( ) ; <nl> for ( Token token : metadata . sortedTokens ( ) ) <nl> { <nl> List < InetAddress > endpoints = strategy . calculateNaturalEndpoints ( token , metadata ) ; <nl> if ( endpoints . size ( ) > 0 & & endpoints . get ( 0 ) . equals ( ep ) ) <nl> - primaryRanges . add ( new Range < Token > ( metadata . getPredecessor ( token ) , token ) ) ; <nl> + primaryRanges . add ( new Range < > ( metadata . getPredecessor ( token ) , token ) ) ; <nl> } <nl> return primaryRanges ; <nl> } <nl> @ @ - 2750 , 13 + 2761 , 13 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( sortedTokens . isEmpty ( ) ) <nl> return Collections . emptyList ( ) ; <nl> int size = sortedTokens . size ( ) ; <nl> - List < Range < Token > > ranges = new ArrayList < Range < Token > > ( size + 1 ) ; <nl> + List < Range < Token > > ranges = new ArrayList < > ( size + 1 ) ; <nl> for ( int i = 1 ; i < size ; + + i ) <nl> { <nl> - Range < Token > range = new Range < Token > ( sortedTokens . get ( i - 1 ) , sortedTokens . get ( i ) ) ; <nl> + Range < Token > range = new Range < > ( sortedTokens . get ( i - 1 ) , sortedTokens . get ( i ) ) ; <nl> ranges . add ( range ) ; <nl> } <nl> - Range < Token > range = new Range < Token > ( sortedTokens . get ( size - 1 ) , sortedTokens . get ( 0 ) ) ; <nl> + Range < Token > range = new Range < > ( sortedTokens . get ( size - 1 ) , sortedTokens . get ( 0 ) ) ; <nl> ranges . add ( range ) ; <nl> <nl> return ranges ; <nl> @ @ - 2811 , 7 + 2822 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> public List < InetAddress > getLiveNaturalEndpoints ( Keyspace keyspace , RingPosition pos ) <nl> { <nl> List < InetAddress > endpoints = keyspace . getReplicationStrategy ( ) . getNaturalEndpoints ( pos ) ; <nl> - List < InetAddress > liveEps = new ArrayList < InetAddress > ( endpoints . size ( ) ) ; <nl> + List < InetAddress > liveEps = new ArrayList < > ( endpoints . size ( ) ) ; <nl> <nl> for ( InetAddress endpoint : endpoints ) <nl> { <nl> @ @ - 2843 , 9 + 2854 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> long totalRowCountEstimate = cfs . estimatedKeysForRange ( range ) ; <nl> <nl> / / splitCount should be much smaller than number of key samples , to avoid huge sampling error <nl> - final int minSamplesPerSplit = 4 ; <nl> - final int maxSplitCount = keys . size ( ) / minSamplesPerSplit + 1 ; <nl> - final int splitCount = Math . max ( 1 , Math . min ( maxSplitCount , ( int ) ( totalRowCountEstimate / keysPerSplit ) ) ) ; <nl> + int minSamplesPerSplit = 4 ; <nl> + int maxSplitCount = keys . size ( ) / minSamplesPerSplit + 1 ; <nl> + int splitCount = Math . max ( 1 , Math . min ( maxSplitCount , ( int ) ( totalRowCountEstimate / keysPerSplit ) ) ) ; <nl> <nl> List < Token > tokens = keysToTokens ( range , keys ) ; <nl> return getSplits ( tokens , splitCount , cfs ) ; <nl> @ @ - 2853 , 7 + 2864 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private List < Pair < Range < Token > , Long > > getSplits ( List < Token > tokens , int splitCount , ColumnFamilyStore cfs ) <nl> { <nl> - final double step = ( double ) ( tokens . size ( ) - 1 ) / splitCount ; <nl> + double step = ( double ) ( tokens . size ( ) - 1 ) / splitCount ; <nl> Token prevToken = tokens . get ( 0 ) ; <nl> List < Pair < Range < Token > , Long > > splits = Lists . newArrayListWithExpectedSize ( splitCount ) ; <nl> for ( int i = 1 ; i < = splitCount ; i + + ) <nl> @ @ - 2879 , 7 + 2890 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private List < DecoratedKey > keySamples ( Iterable < ColumnFamilyStore > cfses , Range < Token > range ) <nl> { <nl> - List < DecoratedKey > keys = new ArrayList < DecoratedKey > ( ) ; <nl> + List < DecoratedKey > keys = new ArrayList < > ( ) ; <nl> for ( ColumnFamilyStore cfs : cfses ) <nl> Iterables . addAll ( keys , cfs . keySamples ( range ) ) ; <nl> FBUtilities . sortSampledKeys ( keys , range ) ; <nl> @ @ - 2943 , 11 + 2954 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> Uninterruptibles . sleepUninterruptibly ( delay , TimeUnit . MILLISECONDS ) ; <nl> } <nl> <nl> - private void unbootstrap ( final Runnable onFinish ) <nl> + private void unbootstrap ( Runnable onFinish ) <nl> { <nl> - Map < String , Multimap < Range < Token > , InetAddress > > rangesToStream = new HashMap < String , Multimap < Range < Token > , InetAddress > > ( ) ; <nl> + Map < String , Multimap < Range < Token > , InetAddress > > rangesToStream = new HashMap < > ( ) ; <nl> <nl> - for ( final String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) <nl> + for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) <nl> { <nl> Multimap < Range < Token > , InetAddress > rangesMM = getChangedRangesForLeaving ( keyspaceName , FBUtilities . getBroadcastAddress ( ) ) ; <nl> <nl> @ @ - 2984 , 7 + 2995 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return Futures . immediateFuture ( null ) ; <nl> <nl> / / gather all live nodes in the cluster that aren ' t also leaving <nl> - List < InetAddress > candidates = new ArrayList < InetAddress > ( StorageService . instance . getTokenMetadata ( ) . cloneAfterAllLeft ( ) . getAllEndpoints ( ) ) ; <nl> + List < InetAddress > candidates = new ArrayList < > ( StorageService . instance . getTokenMetadata ( ) . cloneAfterAllLeft ( ) . getAllEndpoints ( ) ) ; <nl> candidates . remove ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> for ( Iterator < InetAddress > iter = candidates . iterator ( ) ; iter . hasNext ( ) ; ) <nl> { <nl> @ @ - 3006 , 7 + 3017 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> / / stream all hints - - range list will be a singleton of " the entire ring " <nl> Token token = StorageService . getPartitioner ( ) . getMinimumToken ( ) ; <nl> - List < Range < Token > > ranges = Collections . singletonList ( new Range < Token > ( token , token ) ) ; <nl> + List < Range < Token > > ranges = Collections . singletonList ( new Range < > ( token , token ) ) ; <nl> <nl> return new StreamPlan ( " Hints " ) . transferRanges ( hintsDestinationHost , <nl> Keyspace . SYSTEM _ KS , <nl> @ @ - 3097 , 7 + 3108 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private class RangeRelocator <nl> { <nl> - private StreamPlan streamPlan = new StreamPlan ( " Bootstrap " ) ; <nl> + private final StreamPlan streamPlan = new StreamPlan ( " Bootstrap " ) ; <nl> <nl> private RangeRelocator ( Collection < Token > tokens , List < String > keyspaceNames ) <nl> { <nl> @ @ - 3189 , 7 + 3200 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public void relocate ( Collection < String > srcTokens ) throws IOException <nl> { <nl> - List < Token > tokens = new ArrayList < Token > ( srcTokens . size ( ) ) ; <nl> + List < Token > tokens = new ArrayList < > ( srcTokens . size ( ) ) ; <nl> try <nl> { <nl> for ( String srcT : srcTokens ) <nl> @ @ - 3213 , 7 + 3224 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> assert srcTokens ! = null ; <nl> InetAddress localAddress = FBUtilities . getBroadcastAddress ( ) ; <nl> Collection < Token > localTokens = getTokenMetadata ( ) . getTokens ( localAddress ) ; <nl> - Set < Token > tokens = new HashSet < Token > ( srcTokens ) ; <nl> + Set < Token > tokens = new HashSet < > ( srcTokens ) ; <nl> <nl> Iterator < Token > it = tokens . iterator ( ) ; <nl> while ( it . hasNext ( ) ) <nl> @ @ - 3469 , 7 + 3480 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> totalCFs + = keyspace . getColumnFamilyStores ( ) . size ( ) ; <nl> remainingCFs = totalCFs ; <nl> / / flush <nl> - List < Future < ? > > flushes = new ArrayList < Future < ? > > ( ) ; <nl> + List < Future < ? > > flushes = new ArrayList < > ( ) ; <nl> for ( Keyspace keyspace : Keyspace . nonSystem ( ) ) <nl> { <nl> for ( ColumnFamilyStore cfs : keyspace . getColumnFamilyStores ( ) ) <nl> @ @ - 3543 , 7 + 3554 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> List < Token > sortedTokens = tokenMetadata . sortedTokens ( ) ; <nl> / / describeOwnership returns tokens in an unspecified order , let ' s re - order them <nl> Map < Token , Float > tokenMap = new TreeMap < Token , Float > ( getPartitioner ( ) . describeOwnership ( sortedTokens ) ) ; <nl> - Map < InetAddress , Float > nodeMap = new LinkedHashMap < InetAddress , Float > ( ) ; <nl> + Map < InetAddress , Float > nodeMap = new LinkedHashMap < > ( ) ; <nl> for ( Map . Entry < Token , Float > entry : tokenMap . entrySet ( ) ) <nl> { <nl> InetAddress endpoint = tokenMetadata . getEndpoint ( entry . getKey ( ) ) ; <nl> @ @ - 3577 , 9 + 3588 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( keyspace = = null ) <nl> keyspace = Schema . instance . getNonSystemKeyspaces ( ) . get ( 0 ) ; <nl> <nl> - Collection < Collection < InetAddress > > endpointsGroupedByDc = new ArrayList < Collection < InetAddress > > ( ) ; <nl> + Collection < Collection < InetAddress > > endpointsGroupedByDc = new ArrayList < > ( ) ; <nl> / / mapping of dc ' s to nodes , use sorted map so that we get dcs sorted <nl> - SortedMap < String , Collection < InetAddress > > sortedDcsToEndpoints = new TreeMap < String , Collection < InetAddress > > ( ) ; <nl> + SortedMap < String , Collection < InetAddress > > sortedDcsToEndpoints = new TreeMap < > ( ) ; <nl> sortedDcsToEndpoints . putAll ( metadata . getTopology ( ) . getDatacenterEndpoints ( ) . asMap ( ) ) ; <nl> for ( Collection < InetAddress > endpoints : sortedDcsToEndpoints . values ( ) ) <nl> endpointsGroupedByDc . add ( endpoints ) ; <nl> @ @ - 3625 , 7 + 3636 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public List < String > getKeyspaces ( ) <nl> { <nl> - List < String > keyspaceNamesList = new ArrayList < String > ( Schema . instance . getKeyspaces ( ) ) ; <nl> + List < String > keyspaceNamesList = new ArrayList < > ( Schema . instance . getKeyspaces ( ) ) ; <nl> return Collections . unmodifiableList ( keyspaceNamesList ) ; <nl> } <nl> <nl> @ @ - 3668 , 10 + 3679 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * @ param rangesToStreamByKeyspace keyspaces and data ranges with endpoints included for each <nl> * @ return async Future for whether stream was success <nl> * / <nl> - private Future < StreamState > streamRanges ( final Map < String , Multimap < Range < Token > , InetAddress > > rangesToStreamByKeyspace ) <nl> + private Future < StreamState > streamRanges ( Map < String , Multimap < Range < Token > , InetAddress > > rangesToStreamByKeyspace ) <nl> { <nl> / / First , we build a list of ranges to stream to each host , per table <nl> - final Map < String , Map < InetAddress , List < Range < Token > > > > sessionsToStreamByKeyspace = new HashMap < String , Map < InetAddress , List < Range < Token > > > > ( ) ; <nl> + Map < String , Map < InetAddress , List < Range < Token > > > > sessionsToStreamByKeyspace = new HashMap < > ( ) ; <nl> for ( Map . Entry < String , Multimap < Range < Token > , InetAddress > > entry : rangesToStreamByKeyspace . entrySet ( ) ) <nl> { <nl> String keyspace = entry . getKey ( ) ; <nl> @ @ - 3680 , 16 + 3691 , 16 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( rangesWithEndpoints . isEmpty ( ) ) <nl> continue ; <nl> <nl> - Map < InetAddress , List < Range < Token > > > rangesPerEndpoint = new HashMap < InetAddress , List < Range < Token > > > ( ) ; <nl> - for ( final Map . Entry < Range < Token > , InetAddress > endPointEntry : rangesWithEndpoints . entries ( ) ) <nl> + Map < InetAddress , List < Range < Token > > > rangesPerEndpoint = new HashMap < > ( ) ; <nl> + for ( Map . Entry < Range < Token > , InetAddress > endPointEntry : rangesWithEndpoints . entries ( ) ) <nl> { <nl> - final Range < Token > range = endPointEntry . getKey ( ) ; <nl> - final InetAddress endpoint = endPointEntry . getValue ( ) ; <nl> + Range < Token > range = endPointEntry . getKey ( ) ; <nl> + InetAddress endpoint = endPointEntry . getValue ( ) ; <nl> <nl> List < Range < Token > > curRanges = rangesPerEndpoint . get ( endpoint ) ; <nl> if ( curRanges = = null ) <nl> { <nl> - curRanges = new LinkedList < Range < Token > > ( ) ; <nl> + curRanges = new LinkedList < > ( ) ; <nl> rangesPerEndpoint . put ( endpoint , curRanges ) ; <nl> } <nl> curRanges . add ( range ) ; <nl> @ @ - 3701 , 13 + 3712 , 13 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> StreamPlan streamPlan = new StreamPlan ( " Unbootstrap " ) ; <nl> for ( Map . Entry < String , Map < InetAddress , List < Range < Token > > > > entry : sessionsToStreamByKeyspace . entrySet ( ) ) <nl> { <nl> - final String keyspaceName = entry . getKey ( ) ; <nl> - final Map < InetAddress , List < Range < Token > > > rangesPerEndpoint = entry . getValue ( ) ; <nl> + String keyspaceName = entry . getKey ( ) ; <nl> + Map < InetAddress , List < Range < Token > > > rangesPerEndpoint = entry . getValue ( ) ; <nl> <nl> - for ( final Map . Entry < InetAddress , List < Range < Token > > > rangesEntry : rangesPerEndpoint . entrySet ( ) ) <nl> + for ( Map . Entry < InetAddress , List < Range < Token > > > rangesEntry : rangesPerEndpoint . entrySet ( ) ) <nl> { <nl> - final List < Range < Token > > ranges = rangesEntry . getValue ( ) ; <nl> - final InetAddress newEndpoint = rangesEntry . getKey ( ) ; <nl> + List < Range < Token > > ranges = rangesEntry . getValue ( ) ; <nl> + InetAddress newEndpoint = rangesEntry . getKey ( ) ; <nl> <nl> / / TODO each call to transferRanges re - flushes , this is potentially a lot of waste <nl> streamPlan . transferRanges ( newEndpoint , keyspaceName , ranges ) ; <nl> @ @ - 3726 , 8 + 3737 , 8 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * / <nl> public Pair < Set < Range < Token > > , Set < Range < Token > > > calculateStreamAndFetchRanges ( Collection < Range < Token > > current , Collection < Range < Token > > updated ) <nl> { <nl> - Set < Range < Token > > toStream = new HashSet < Range < Token > > ( ) ; <nl> - Set < Range < Token > > toFetch = new HashSet < Range < Token > > ( ) ; <nl> + Set < Range < Token > > toStream = new HashSet < > ( ) ; <nl> + Set < Range < Token > > toFetch = new HashSet < > ( ) ; <nl> <nl> <nl> for ( Range r1 : current ) <nl> @ @ - 3846 , 14 + 3857 , 14 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * / <nl> public List < String > sampleKeyRange ( ) / / do not rename to getter - see CASSANDRA - 4452 for details <nl> { <nl> - List < DecoratedKey > keys = new ArrayList < DecoratedKey > ( ) ; <nl> + List < DecoratedKey > keys = new ArrayList < > ( ) ; <nl> for ( Keyspace keyspace : Keyspace . nonSystem ( ) ) <nl> { <nl> for ( Range < Token > range : getPrimaryRangesForEndpoint ( keyspace . getName ( ) , FBUtilities . getBroadcastAddress ( ) ) ) <nl> keys . addAll ( keySamples ( keyspace . getColumnFamilyStores ( ) , range ) ) ; <nl> } <nl> <nl> - List < String > sampledKeys = new ArrayList < String > ( keys . size ( ) ) ; <nl> + List < String > sampledKeys = new ArrayList < > ( keys . size ( ) ) ; <nl> for ( DecoratedKey key : keys ) <nl> sampledKeys . add ( key . getToken ( ) . toString ( ) ) ; <nl> return sampledKeys ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> index 3792128 . . da7bff1 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> @ @ - 146 , 14 + 146 , 13 @ @ public class BootStrapper <nl> <nl> Multimap < Range , InetAddress > getRangesWithSources ( ) <nl> { <nl> - Map < Token , InetAddress > map = tokenMetadata . cloneTokenEndPointMap ( ) ; <nl> - assert map . size ( ) > 0 ; <nl> - map . put ( token , address ) ; <nl> - Collection < Range > myRanges = replicationStrategy . getAddressRanges ( map ) . get ( address ) ; <nl> - map . remove ( token ) ; <nl> + TokenMetadata temp = tokenMetadata . cloneMe ( ) ; <nl> + assert temp . sortedTokens ( ) . size ( ) > 0 ; <nl> + temp . update ( token , address ) ; <nl> + Collection < Range > myRanges = replicationStrategy . getAddressRanges ( temp ) . get ( address ) ; <nl> <nl> Multimap < Range , InetAddress > myRangeAddresses = HashMultimap . create ( ) ; <nl> - Multimap < Range , InetAddress > rangeAddresses = replicationStrategy . getRangeAddresses ( map ) ; <nl> + Multimap < Range , InetAddress > rangeAddresses = replicationStrategy . getRangeAddresses ( tokenMetadata ) ; <nl> for ( Range range : rangeAddresses . keySet ( ) ) <nl> { <nl> for ( Range myRange : myRanges ) <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> index 2b6b261 . . e7722de 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> @ @ - 56 , 7 + 56 , 7 @ @ public abstract class AbstractReplicationStrategy <nl> storagePort _ = storagePort ; <nl> } <nl> <nl> - public abstract ArrayList < InetAddress > getNaturalEndpoints ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) ; <nl> + public abstract ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) ; <nl> <nl> public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) throws InvalidRequestException <nl> { <nl> @ @ - 65 , 7 + 65 , 7 @ @ public abstract class AbstractReplicationStrategy <nl> <nl> public ArrayList < InetAddress > getNaturalEndpoints ( Token token ) <nl> { <nl> - return getNaturalEndpoints ( token , tokenMetadata _ . cloneTokenEndPointMap ( ) ) ; <nl> + return getNaturalEndpoints ( token , tokenMetadata _ ) ; <nl> } <nl> <nl> / * <nl> @ @ - 88 , 29 + 88 , 21 @ @ public abstract class AbstractReplicationStrategy <nl> * / <nl> public ArrayList < InetAddress > getWriteEndpoints ( Token token , Collection < InetAddress > naturalEndpoints ) <nl> { <nl> - Map < Token , InetAddress > tokenToEndPointMap = tokenMetadata _ . cloneTokenEndPointMap ( ) ; <nl> - Map < Token , InetAddress > bootstrapTokensToEndpointMap = tokenMetadata _ . cloneBootstrapNodes ( ) ; <nl> ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( naturalEndpoints ) ; <nl> <nl> - for ( Token t : bootstrapTokensToEndpointMap . keySet ( ) ) <nl> + for ( Token t : tokenMetadata _ . bootstrapTokens ( ) ) <nl> { <nl> - InetAddress ep = bootstrapTokensToEndpointMap . get ( t ) ; <nl> - tokenToEndPointMap . put ( t , ep ) ; <nl> - try <nl> + TokenMetadata temp = tokenMetadata _ . cloneMe ( ) ; <nl> + InetAddress ep = tokenMetadata _ . getBootstrapEndpoint ( t ) ; <nl> + temp . update ( t , ep ) ; <nl> + for ( Range r : getAddressRanges ( temp ) . get ( ep ) ) <nl> { <nl> - for ( Range r : getAddressRanges ( tokenToEndPointMap ) . get ( ep ) ) <nl> + if ( r . contains ( token ) ) <nl> { <nl> - if ( r . contains ( token ) ) <nl> - { <nl> - endpoints . add ( ep ) ; <nl> - break ; <nl> - } <nl> + endpoints . add ( ep ) ; <nl> + break ; <nl> } <nl> } <nl> - finally <nl> - { <nl> - tokenToEndPointMap . remove ( t ) ; <nl> - } <nl> } <nl> <nl> return endpoints ; <nl> @ @ - 139 , 9 + 131 , 7 @ @ public abstract class AbstractReplicationStrategy <nl> { <nl> / / find another endpoint to store a hint on . prefer endpoints that aren ' t already in use <nl> InetAddress hintLocation = null ; <nl> - Map < Token , InetAddress > tokenToEndPointMap = tokenMetadata _ . cloneTokenEndPointMap ( ) ; <nl> - List tokens = new ArrayList ( tokenToEndPointMap . keySet ( ) ) ; <nl> - Collections . sort ( tokens ) ; <nl> + List tokens = tokenMetadata _ . sortedTokens ( ) ; <nl> Token token = tokenMetadata _ . getToken ( ep ) ; <nl> int index = Collections . binarySearch ( tokens , token ) ; <nl> if ( index < 0 ) <nl> @ @ - 154 , 7 + 144 , 7 @ @ public abstract class AbstractReplicationStrategy <nl> int startIndex = ( index + 1 ) % totalNodes ; <nl> for ( int i = startIndex , count = 1 ; count < totalNodes ; + + count , i = ( i + 1 ) % totalNodes ) <nl> { <nl> - InetAddress tmpEndPoint = tokenToEndPointMap . get ( tokens . get ( i ) ) ; <nl> + InetAddress tmpEndPoint = tokenMetadata _ . getEndPoint ( ( Token ) tokens . get ( i ) ) ; <nl> if ( FailureDetector . instance ( ) . isAlive ( tmpEndPoint ) & & ! targets . contains ( tmpEndPoint ) & & ! usedEndpoints . contains ( tmpEndPoint ) ) <nl> { <nl> hintLocation = tmpEndPoint ; <nl> @ @ - 176 , 13 + 166 , 13 @ @ public abstract class AbstractReplicationStrategy <nl> <nl> / / TODO this is pretty inefficient . also the inverse ( getRangeAddresses ) below . <nl> / / fixing this probably requires merging tokenmetadata into replicationstrategy , so we can cache / invalidate cleanly <nl> - public Multimap < InetAddress , Range > getAddressRanges ( Map < Token , InetAddress > metadata ) <nl> + public Multimap < InetAddress , Range > getAddressRanges ( TokenMetadata metadata ) <nl> { <nl> Multimap < InetAddress , Range > map = HashMultimap . create ( ) ; <nl> <nl> - for ( Token token : metadata . keySet ( ) ) <nl> + for ( Token token : metadata . sortedTokens ( ) ) <nl> { <nl> - Range range = getPrimaryRangeFor ( token , metadata ) ; <nl> + Range range = metadata . getPrimaryRangeFor ( token ) ; <nl> for ( InetAddress ep : getNaturalEndpoints ( token , metadata ) ) <nl> { <nl> map . put ( ep , range ) ; <nl> @ @ - 192 , 13 + 182 , 13 @ @ public abstract class AbstractReplicationStrategy <nl> return map ; <nl> } <nl> <nl> - public Multimap < Range , InetAddress > getRangeAddresses ( Map < Token , InetAddress > metadata ) <nl> + public Multimap < Range , InetAddress > getRangeAddresses ( TokenMetadata metadata ) <nl> { <nl> Multimap < Range , InetAddress > map = HashMultimap . create ( ) ; <nl> <nl> - for ( Token token : metadata . keySet ( ) ) <nl> + for ( Token token : metadata . sortedTokens ( ) ) <nl> { <nl> - Range range = getPrimaryRangeFor ( token , metadata ) ; <nl> + Range range = metadata . getPrimaryRangeFor ( token ) ; <nl> for ( InetAddress ep : getNaturalEndpoints ( token , metadata ) ) <nl> { <nl> map . put ( range , ep ) ; <nl> @ @ - 210 , 27 + 200 , 6 @ @ public abstract class AbstractReplicationStrategy <nl> <nl> public Multimap < InetAddress , Range > getAddressRanges ( ) <nl> { <nl> - return getAddressRanges ( tokenMetadata _ . cloneTokenEndPointMap ( ) ) ; <nl> - } <nl> - <nl> - public Range getPrimaryRangeFor ( Token right , Map < Token , InetAddress > tokenToEndPointMap ) <nl> - { <nl> - return new Range ( getPredecessor ( right , tokenToEndPointMap ) , right ) ; <nl> - } <nl> - <nl> - public Token getPredecessor ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) <nl> - { <nl> - List tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; <nl> - Collections . sort ( tokens ) ; <nl> - int index = Collections . binarySearch ( tokens , token ) ; <nl> - return ( Token ) ( index = = 0 ? tokens . get ( tokens . size ( ) - 1 ) : tokens . get ( - - index ) ) ; <nl> - } <nl> - <nl> - public Token getSuccessor ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) <nl> - { <nl> - List tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; <nl> - Collections . sort ( tokens ) ; <nl> - int index = Collections . binarySearch ( tokens , token ) ; <nl> - return ( Token ) ( ( index = = ( tokens . size ( ) - 1 ) ) ? tokens . get ( 0 ) : tokens . get ( + + index ) ) ; <nl> + return getAddressRanges ( tokenMetadata _ ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> index e8b30e2 . . 20100b7 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> @ @ - 45 , 10 + 45 , 8 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> / * * <nl> * This Method will get the required information of the EndPoint from the <nl> * DataCenterEndPointSnitch and poopulates this singleton class . <nl> - * <nl> - * @ param tokenToEndPointMap - Provided the endpoint map which will be mapped with the DC ' s <nl> * / <nl> - private synchronized void loadEndPoints ( Map < Token , InetAddress > tokenToEndPointMap , Collection < Token > tokens ) throws IOException <nl> + private synchronized void loadEndPoints ( TokenMetadata metadata ) throws IOException <nl> { <nl> endPointSnitch = ( DatacenterEndPointSnitch ) StorageService . instance ( ) . getEndPointSnitch ( ) ; <nl> this . tokens = new ArrayList < Token > ( tokens ) ; <nl> @ @ - 56 , 7 + 54 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> dcMap = new HashMap < String , List < Token > > ( ) ; <nl> for ( Token token : this . tokens ) <nl> { <nl> - InetAddress endPoint = tokenToEndPointMap . get ( token ) ; <nl> + InetAddress endPoint = metadata . getEndPoint ( token ) ; <nl> String dataCenter = endPointSnitch . getLocation ( endPoint ) ; <nl> if ( dataCenter . equals ( localDC ) ) <nl> { <nl> @ @ - 96 , 25 + 94 , 24 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> assert ( DatabaseDescriptor . getEndPointSnitch ( ) instanceof DatacenterEndPointSnitch ) ; <nl> } <nl> <nl> - @ Override <nl> - public ArrayList < InetAddress > getNaturalEndpoints ( Token searchToken , Map < Token , InetAddress > tokenToEndPointMap ) <nl> + public ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) <nl> { <nl> try <nl> { <nl> - return getNaturalEndpointsInternal ( searchToken , tokenToEndPointMap ) ; <nl> + return getNaturalEndpointsInternal ( token , metadata ) ; <nl> } <nl> catch ( IOException e ) <nl> { <nl> - throw new IOError ( e ) ; <nl> + throw new IOError ( e ) ; <nl> } <nl> } <nl> <nl> - private ArrayList < InetAddress > getNaturalEndpointsInternal ( Token searchToken , Map < Token , InetAddress > tokenToEndPointMap ) throws IOException <nl> + private ArrayList < InetAddress > getNaturalEndpointsInternal ( Token searchToken , TokenMetadata metadata ) throws IOException <nl> { <nl> ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( ) ; <nl> - if ( null = = tokens | | this . tokens . size ( ) ! = tokenToEndPointMap . keySet ( ) . size ( ) ) <nl> + if ( null = = tokens | | tokens . size ( ) ! = metadata . sortedTokens ( ) . size ( ) ) <nl> { <nl> - loadEndPoints ( tokenToEndPointMap , tokenToEndPointMap . keySet ( ) ) ; <nl> + loadEndPoints ( metadata ) ; <nl> } <nl> <nl> for ( String dc : dcMap . keySet ( ) ) <nl> @ @ - 136 , 7 + 133 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> } <nl> int totalNodes = tokens . size ( ) ; <nl> / / Add the node at the index by default <nl> - InetAddress primaryHost = tokenToEndPointMap . get ( tokens . get ( index ) ) ; <nl> + InetAddress primaryHost = metadata . getEndPoint ( ( Token ) tokens . get ( index ) ) ; <nl> forloopReturn . add ( primaryHost ) ; <nl> foundCount + + ; <nl> if ( replicas _ = = 1 ) <nl> @ @ - 147 , 7 + 144 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> int startIndex = ( index + 1 ) % totalNodes ; <nl> for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) <nl> { <nl> - InetAddress endPointOfIntrest = tokenToEndPointMap . get ( tokens . get ( i ) ) ; <nl> + InetAddress endPointOfIntrest = metadata . getEndPoint ( ( Token ) tokens . get ( i ) ) ; <nl> if ( ( replicas _ - 1 ) > foundCount ) <nl> { <nl> forloopReturn . add ( endPointOfIntrest ) ; <nl> @ @ - 163 , 7 + 160 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> { <nl> if ( ! endPointSnitch . isOnSameRack ( primaryHost , endPointOfIntrest ) ) <nl> { <nl> - forloopReturn . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; <nl> + forloopReturn . add ( metadata . getEndPoint ( ( Token ) tokens . get ( i ) ) ) ; <nl> bOtherRack = true ; <nl> foundCount + + ; <nl> } <nl> @ @ - 182 , 9 + 179 , 10 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> * / <nl> for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) <nl> { <nl> - if ( ! forloopReturn . contains ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ) <nl> + Token t = ( Token ) tokens . get ( i ) ; <nl> + if ( ! forloopReturn . contains ( metadata . getEndPoint ( t ) ) ) <nl> { <nl> - forloopReturn . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; <nl> + forloopReturn . add ( metadata . getEndPoint ( t ) ) ; <nl> foundCount + + ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / RackAwareStrategy . java b / src / java / org / apache / cassandra / locator / RackAwareStrategy . java <nl> index 6b1101e . . 62c79b6 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / RackAwareStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / RackAwareStrategy . java <nl> @ @ - 44 , 15 + 44 , 14 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy <nl> super ( tokenMetadata , partitioner , replicas , storagePort ) ; <nl> } <nl> <nl> - public ArrayList < InetAddress > getNaturalEndpoints ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) <nl> + public ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) <nl> { <nl> int startIndex ; <nl> ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( ) ; <nl> boolean bDataCenter = false ; <nl> boolean bOtherRack = false ; <nl> int foundCount = 0 ; <nl> - List tokens = new ArrayList ( tokenToEndPointMap . keySet ( ) ) ; <nl> - Collections . sort ( tokens ) ; <nl> + List tokens = metadata . sortedTokens ( ) ; <nl> int index = Collections . binarySearch ( tokens , token ) ; <nl> if ( index < 0 ) <nl> { <nl> @ @ - 62 , 7 + 61 , 8 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy <nl> } <nl> int totalNodes = tokens . size ( ) ; <nl> / / Add the node at the index by default <nl> - endpoints . add ( tokenToEndPointMap . get ( tokens . get ( index ) ) ) ; <nl> + Token primaryToken = ( Token ) tokens . get ( index ) ; <nl> + endpoints . add ( metadata . getEndPoint ( primaryToken ) ) ; <nl> foundCount + + ; <nl> if ( replicas _ = = 1 ) <nl> { <nl> @ @ - 70 , 31 + 70 , 32 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy <nl> } <nl> startIndex = ( index + 1 ) % totalNodes ; <nl> IEndPointSnitch endPointSnitch = StorageService . instance ( ) . getEndPointSnitch ( ) ; <nl> - <nl> - for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) <nl> + <nl> + for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) <nl> { <nl> try <nl> { <nl> / / First try to find one in a different data center <nl> - if ( ! endPointSnitch . isInSameDataCenter ( tokenToEndPointMap . get ( tokens . get ( index ) ) , tokenToEndPointMap . get ( tokens . get ( i ) ) ) ) <nl> + Token t = ( Token ) tokens . get ( i ) ; <nl> + if ( ! endPointSnitch . isInSameDataCenter ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) <nl> { <nl> / / If we have already found something in a diff datacenter no need to find another <nl> - if ( ! bDataCenter ) <nl> + if ( ! bDataCenter ) <nl> { <nl> - endpoints . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; <nl> + endpoints . add ( metadata . getEndPoint ( t ) ) ; <nl> bDataCenter = true ; <nl> foundCount + + ; <nl> } <nl> continue ; <nl> } <nl> / / Now try to find one on a different rack <nl> - if ( ! endPointSnitch . isOnSameRack ( tokenToEndPointMap . get ( tokens . get ( index ) ) , tokenToEndPointMap . get ( tokens . get ( i ) ) ) & & <nl> - endPointSnitch . isInSameDataCenter ( tokenToEndPointMap . get ( tokens . get ( index ) ) , tokenToEndPointMap . get ( tokens . get ( i ) ) ) ) <nl> + if ( ! endPointSnitch . isOnSameRack ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) & & <nl> + endPointSnitch . isInSameDataCenter ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) <nl> { <nl> / / If we have already found something in a diff rack no need to find another <nl> - if ( ! bOtherRack ) <nl> + if ( ! bOtherRack ) <nl> { <nl> - endpoints . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; <nl> + endpoints . add ( metadata . getEndPoint ( t ) ) ; <nl> bOtherRack = true ; <nl> foundCount + + ; <nl> } <nl> @ @ - 103 , 7 + 104 , 7 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy <nl> catch ( UnknownHostException e ) <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( LogUtil . throwableToString ( e ) ) ; <nl> + logger _ . debug ( LogUtil . throwableToString ( e ) ) ; <nl> } <nl> <nl> } <nl> @ @ - 111 , 9 + 112 , 10 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy <nl> / / loop through the list and add until we have N nodes . <nl> for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) <nl> { <nl> - if ( ! endpoints . contains ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ) <nl> + Token t = ( Token ) tokens . get ( i ) ; <nl> + if ( ! endpoints . contains ( metadata . getEndPoint ( t ) ) ) <nl> { <nl> - endpoints . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; <nl> + endpoints . add ( metadata . getEndPoint ( t ) ) ; <nl> foundCount + + ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / RackUnawareStrategy . java b / src / java / org / apache / cassandra / locator / RackUnawareStrategy . java <nl> index 10b6fd3 . . 9bc9c90 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / RackUnawareStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / RackUnawareStrategy . java <nl> @ @ - 40 , 15 + 40 , 15 @ @ public class RackUnawareStrategy extends AbstractReplicationStrategy <nl> super ( tokenMetadata , partitioner , replicas , storagePort ) ; <nl> } <nl> <nl> - public ArrayList < InetAddress > getNaturalEndpoints ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) <nl> + / / TODO this doesn ' t need to worry about bootstrap tokens being in the normal tokens map <nl> + public ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) <nl> { <nl> int startIndex ; <nl> List < Token > tokenList = new ArrayList < Token > ( ) ; <nl> int foundCount = 0 ; <nl> - List tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; <nl> + List tokens = new ArrayList < Token > ( metadata . sortedTokens ( ) ) ; <nl> List < Token > bsTokens = null ; <nl> <nl> - Collections . sort ( tokens ) ; <nl> int index = Collections . binarySearch ( tokens , token ) ; <nl> if ( index < 0 ) <nl> { <nl> @ @ - 75 , 8 + 75 , 8 @ @ public class RackUnawareStrategy extends AbstractReplicationStrategy <nl> } <nl> } <nl> ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( tokenList . size ( ) ) ; <nl> - for ( Token t : tokenList ) <nl> - endpoints . add ( tokenToEndPointMap . get ( t ) ) ; <nl> + for ( Token t : tokenList ) <nl> + endpoints . add ( metadata . getEndPoint ( t ) ) ; <nl> return endpoints ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> index 5cd788d . . 2fdf0b1 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> @ @ - 23 , 6 + 23 , 8 @ @ import java . util . concurrent . locks . ReadWriteLock ; <nl> import java . util . concurrent . locks . ReentrantReadWriteLock ; <nl> <nl> import org . apache . cassandra . dht . Token ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + <nl> import java . net . InetAddress ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . gms . FailureDetector ; <nl> @ @ - 185 , 85 + 187 , 105 @ @ public class TokenMetadata <nl> lock . readLock ( ) . unlock ( ) ; <nl> } <nl> } <nl> - <nl> - public Map < Token , InetAddress > cloneBootstrapNodes ( ) <nl> + <nl> + public TokenMetadata cloneMe ( ) <nl> { <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> - { <nl> - return new HashMap < Token , InetAddress > ( bootstrapTokenMap ) ; <nl> + { <nl> + return new TokenMetadata ( HashBiMap . create ( tokenToEndPointMap ) , HashBiMap . create ( bootstrapTokenMap ) ) ; <nl> } <nl> finally <nl> { <nl> lock . readLock ( ) . unlock ( ) ; <nl> } <nl> - <nl> } <nl> <nl> - / * <nl> - * Returns a safe clone of tokenToEndPointMap _ . <nl> - * / <nl> - public Map < Token , InetAddress > cloneTokenEndPointMap ( ) <nl> + public String toString ( ) <nl> { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> - { <nl> - return new HashMap < Token , InetAddress > ( tokenToEndPointMap ) ; <nl> + { <nl> + Set < InetAddress > eps = tokenToEndPointMap . inverse ( ) . keySet ( ) ; <nl> + <nl> + for ( InetAddress ep : eps ) <nl> + { <nl> + sb . append ( ep ) ; <nl> + sb . append ( " : " ) ; <nl> + sb . append ( tokenToEndPointMap . inverse ( ) . get ( ep ) ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> } <nl> finally <nl> { <nl> lock . readLock ( ) . unlock ( ) ; <nl> } <nl> + <nl> + return sb . toString ( ) ; <nl> } <nl> - <nl> - / * <nl> - * Returns a safe clone of endPointTokenMap _ . <nl> - * / <nl> - public Map < InetAddress , Token > cloneEndPointTokenMap ( ) <nl> + <nl> + public InetAddress getEndPoint ( Token token ) <nl> { <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> - { <nl> - return new HashMap < InetAddress , Token > ( tokenToEndPointMap . inverse ( ) ) ; <nl> + { <nl> + return tokenToEndPointMap . get ( token ) ; <nl> } <nl> finally <nl> { <nl> lock . readLock ( ) . unlock ( ) ; <nl> } <nl> } <nl> - <nl> - public String toString ( ) <nl> + <nl> + public void clearUnsafe ( ) <nl> { <nl> - StringBuilder sb = new StringBuilder ( ) ; <nl> - Set < InetAddress > eps = tokenToEndPointMap . inverse ( ) . keySet ( ) ; <nl> + tokenToEndPointMap . clear ( ) ; <nl> + bootstrapTokenMap . clear ( ) ; <nl> + } <nl> <nl> - for ( InetAddress ep : eps ) <nl> - { <nl> - sb . append ( ep ) ; <nl> - sb . append ( " : " ) ; <nl> - sb . append ( tokenToEndPointMap . inverse ( ) . get ( ep ) ) ; <nl> - sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> - } <nl> - <nl> - return sb . toString ( ) ; <nl> + public Range getPrimaryRangeFor ( Token right ) <nl> + { <nl> + return new Range ( getPredecessor ( right ) , right ) ; <nl> } <nl> <nl> - public InetAddress getEndPoint ( Token token ) <nl> + public List < Token > sortedTokens ( ) <nl> { <nl> + List < Token > tokens ; <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - return tokenToEndPointMap . get ( token ) ; <nl> + tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; <nl> } <nl> finally <nl> { <nl> lock . readLock ( ) . unlock ( ) ; <nl> } <nl> + Collections . sort ( tokens ) ; <nl> + return tokens ; <nl> } <nl> <nl> - public void clearUnsafe ( ) <nl> + public Token getPredecessor ( Token token ) <nl> { <nl> - tokenToEndPointMap . clear ( ) ; <nl> - bootstrapTokenMap . clear ( ) ; <nl> + List tokens = sortedTokens ( ) ; <nl> + int index = Collections . binarySearch ( tokens , token ) ; <nl> + return ( Token ) ( index = = 0 ? tokens . get ( tokens . size ( ) - 1 ) : tokens . get ( - - index ) ) ; <nl> + } <nl> + <nl> + public Token getSuccessor ( Token token ) <nl> + { <nl> + List tokens = sortedTokens ( ) ; <nl> + int index = Collections . binarySearch ( tokens , token ) ; <nl> + return ( Token ) ( ( index = = ( tokens . size ( ) - 1 ) ) ? tokens . get ( 0 ) : tokens . get ( + + index ) ) ; <nl> + } <nl> + <nl> + public Iterable < ? extends Token > bootstrapTokens ( ) <nl> + { <nl> + return bootstrapTokenMap . keySet ( ) ; <nl> + } <nl> + <nl> + public InetAddress getBootstrapEndpoint ( Token token ) <nl> + { <nl> + return bootstrapTokenMap . get ( token ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraServer . java b / src / java / org / apache / cassandra / service / CassandraServer . java <nl> index 235ff9b . . bbb4c98 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraServer . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraServer . java <nl> @ @ - 508 , 11 + 508 , 7 @ @ public class CassandraServer implements Cassandra . Iface <nl> } <nl> else if ( propertyName . equals ( TOKEN _ MAP ) ) <nl> { <nl> - HashMap < String , String > tokenToHostMap = new HashMap < String , String > ( ) ; <nl> - Map < Token , InetAddress > endpointMap = storageService . getLiveEndPointMap ( ) ; <nl> - for ( Map . Entry < Token , InetAddress > e : endpointMap . entrySet ( ) ) <nl> - tokenToHostMap . put ( e . getKey ( ) . toString ( ) , e . getValue ( ) . getHostAddress ( ) ) ; <nl> - return new JSONSerializer ( ) . serialize ( tokenToHostMap ) ; <nl> + return new JSONSerializer ( ) . serialize ( storageService . getStringEndpointMap ( ) ) ; <nl> } <nl> else if ( propertyName . equals ( " version " ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 7c49711 . . 3c84091 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 281 , 7 + 281 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> } <nl> setAndBroadcastToken ( storageMetadata _ . getToken ( ) ) ; <nl> <nl> - assert tokenMetadata _ . cloneTokenEndPointMap ( ) . size ( ) > 0 ; <nl> + assert tokenMetadata _ . sortedTokens ( ) . size ( ) > 0 ; <nl> } <nl> <nl> public boolean isBootstrapMode ( ) <nl> @ @ - 322 , 10 + 322 , 8 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> <nl> public Map < Range , List < String > > getRangeToEndPointMap ( ) <nl> { <nl> - / * Get the token to endpoint map . * / <nl> - Map < Token , InetAddress > tokenToEndPointMap = tokenMetadata _ . cloneTokenEndPointMap ( ) ; <nl> / * All the ranges for the tokens * / <nl> - Range [ ] ranges = getAllRanges ( tokenToEndPointMap . keySet ( ) ) ; <nl> + List < Range > ranges = getAllRanges ( tokenMetadata _ . sortedTokens ( ) ) ; <nl> Map < Range , List < String > > map = new HashMap < Range , List < String > > ( ) ; <nl> for ( Map . Entry < Range , List < InetAddress > > entry : constructRangeToEndPointMap ( ranges ) . entrySet ( ) ) <nl> { <nl> @ @ - 340 , 7 + 338 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> * @ param ranges <nl> * @ return mapping of ranges to the replicas responsible for them . <nl> * / <nl> - public Map < Range , List < InetAddress > > constructRangeToEndPointMap ( Range [ ] ranges ) <nl> + public Map < Range , List < InetAddress > > constructRangeToEndPointMap ( List < Range > ranges ) <nl> { <nl> Map < Range , List < InetAddress > > rangeToEndPointMap = new HashMap < Range , List < InetAddress > > ( ) ; <nl> for ( Range range : ranges ) <nl> @ @ - 349 , 27 + 347 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> } <nl> return rangeToEndPointMap ; <nl> } <nl> - <nl> - / * * <nl> - * Construct the range to endpoint mapping based on the view as dictated <nl> - * by the mapping of token to endpoints passed in . <nl> - * @ param ranges <nl> - * @ param tokenToEndPointMap mapping of token to endpoints . <nl> - * @ return mapping of ranges to the replicas responsible for them . <nl> - * / <nl> - public Map < Range , List < InetAddress > > constructRangeToEndPointMap ( Range [ ] ranges , Map < Token , InetAddress > tokenToEndPointMap ) <nl> - { <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " Constructing range to endpoint map . . . " ) ; <nl> - Map < Range , List < InetAddress > > rangeToEndPointMap = new HashMap < Range , List < InetAddress > > ( ) ; <nl> - for ( Range range : ranges ) <nl> - { <nl> - rangeToEndPointMap . put ( range , replicationStrategy _ . getNaturalEndpoints ( range . right ( ) , tokenToEndPointMap ) ) ; <nl> - } <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " Done constructing range to endpoint map . . . " ) ; <nl> - return rangeToEndPointMap ; <nl> - } <nl> <nl> / * * <nl> * Called when there is a change in application state . In particular <nl> @ @ - 643 , 7 + 620 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> InetAddress getPredecessor ( InetAddress ep ) <nl> { <nl> Token token = tokenMetadata _ . getToken ( ep ) ; <nl> - return tokenMetadata _ . getEndPoint ( replicationStrategy _ . getPredecessor ( token , tokenMetadata _ . cloneTokenEndPointMap ( ) ) ) ; <nl> + return tokenMetadata _ . getEndPoint ( tokenMetadata _ . getPredecessor ( token ) ) ; <nl> } <nl> <nl> / * <nl> @ @ - 653 , 7 + 630 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> public InetAddress getSuccessor ( InetAddress ep ) <nl> { <nl> Token token = tokenMetadata _ . getToken ( ep ) ; <nl> - return tokenMetadata _ . getEndPoint ( replicationStrategy _ . getSuccessor ( token , tokenMetadata _ . cloneTokenEndPointMap ( ) ) ) ; <nl> + return tokenMetadata _ . getEndPoint ( tokenMetadata _ . getSuccessor ( token ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 663 , 8 + 640 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> * / <nl> public Range getPrimaryRangeForEndPoint ( InetAddress ep ) <nl> { <nl> - Token right = tokenMetadata _ . getToken ( ep ) ; <nl> - return replicationStrategy _ . getPrimaryRangeFor ( right , tokenMetadata _ . cloneTokenEndPointMap ( ) ) ; <nl> + return tokenMetadata _ . getPrimaryRangeFor ( tokenMetadata _ . getToken ( ep ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 683 , 22 + 659 , 23 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> * ranges . <nl> * @ return ranges in sorted order <nl> * / <nl> - public Range [ ] getAllRanges ( Set < Token > tokens ) <nl> + public List < Range > getAllRanges ( List < Token > sortedTokens ) <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " computing ranges for " + StringUtils . join ( tokens , " , " ) ) ; <nl> + logger _ . debug ( " computing ranges for " + StringUtils . join ( sortedTokens , " , " ) ) ; <nl> + <nl> List < Range > ranges = new ArrayList < Range > ( ) ; <nl> - List < Token > allTokens = new ArrayList < Token > ( tokens ) ; <nl> - Collections . sort ( allTokens ) ; <nl> - int size = allTokens . size ( ) ; <nl> - for ( int i = 1 ; i < size ; + + i ) <nl> + Collections . sort ( sortedTokens ) ; <nl> + int size = sortedTokens . size ( ) ; <nl> + for ( int i = 1 ; i < size ; + + i ) <nl> { <nl> - Range range = new Range ( allTokens . get ( i - 1 ) , allTokens . get ( i ) ) ; <nl> + Range range = new Range ( sortedTokens . get ( i - 1 ) , sortedTokens . get ( i ) ) ; <nl> ranges . add ( range ) ; <nl> } <nl> - Range range = new Range ( allTokens . get ( size - 1 ) , allTokens . get ( 0 ) ) ; <nl> + Range range = new Range ( sortedTokens . get ( size - 1 ) , sortedTokens . get ( 0 ) ) ; <nl> ranges . add ( range ) ; <nl> - return ranges . toArray ( new Range [ 0 ] ) ; <nl> + <nl> + return ranges ; <nl> } <nl> <nl> / * * <nl> @ @ - 712 , 11 + 689 , 9 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> { <nl> InetAddress endpoint = FBUtilities . getLocalAddress ( ) ; <nl> Token token = partitioner _ . getToken ( key ) ; <nl> - Map < Token , InetAddress > tokenToEndPointMap = tokenMetadata _ . cloneTokenEndPointMap ( ) ; <nl> - List tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; <nl> + List tokens = new ArrayList < Token > ( tokenMetadata _ . sortedTokens ( ) ) ; <nl> if ( tokens . size ( ) > 0 ) <nl> { <nl> - Collections . sort ( tokens ) ; <nl> int index = Collections . binarySearch ( tokens , token ) ; <nl> if ( index > = 0 ) <nl> { <nl> @ @ - 724 , 15 + 699 , 15 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> * retrieve the endpoint based on the token at this index in the <nl> * tokens list <nl> * / <nl> - endpoint = tokenToEndPointMap . get ( tokens . get ( index ) ) ; <nl> + endpoint = tokenMetadata _ . getEndPoint ( ( Token ) tokens . get ( index ) ) ; <nl> } <nl> else <nl> { <nl> index = ( index + 1 ) * ( - 1 ) ; <nl> if ( index < tokens . size ( ) ) <nl> - endpoint = tokenToEndPointMap . get ( tokens . get ( index ) ) ; <nl> + endpoint = tokenMetadata _ . getEndPoint ( ( Token ) tokens . get ( index ) ) ; <nl> else <nl> - endpoint = tokenToEndPointMap . get ( tokens . get ( 0 ) ) ; <nl> + endpoint = tokenMetadata _ . getEndPoint ( ( Token ) tokens . get ( 0 ) ) ; <nl> } <nl> } <nl> return endpoint ; <nl> @ @ - 834 , 9 + 809 , 14 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> throw new UnavailableException ( ) ; / / no nodes that could contain key are alive <nl> } <nl> <nl> - Map < Token , InetAddress > getLiveEndPointMap ( ) <nl> + Map < String , String > getStringEndpointMap ( ) <nl> { <nl> - return tokenMetadata _ . cloneTokenEndPointMap ( ) ; <nl> + HashMap < String , String > map = new HashMap < String , String > ( ) ; <nl> + for ( Token t : tokenMetadata _ . sortedTokens ( ) ) <nl> + { <nl> + map . put ( t . toString ( ) , tokenMetadata _ . getEndPoint ( t ) . getHostAddress ( ) ) ; <nl> + } <nl> + return map ; <nl> } <nl> <nl> public void setLog4jLevel ( String classQualifier , String rawLevel ) <nl> diff - - git a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> index d8d67a0 . . ad6c5d5 100644 <nl> - - - a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> + + + b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> @ @ - 54 , 7 + 54 , 7 @ @ public class BootStrapperTest { <nl> InetAddress myEndpoint = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; <nl> <nl> TokenMetadata tmd = ss . getTokenMetadata ( ) ; <nl> - assertEquals ( numOldNodes , tmd . cloneTokenEndPointMap ( ) . size ( ) ) ; <nl> + assertEquals ( numOldNodes , tmd . sortedTokens ( ) . size ( ) ) ; <nl> BootStrapper b = new BootStrapper ( ss . getReplicationStrategy ( ) , myEndpoint , myToken , tmd ) ; <nl> Multimap < Range , InetAddress > res = b . getRangesWithSources ( ) ; <nl>

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 17bd514 . . 042e2bc 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 183 , 9 + 183 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private static final AtomicInteger nextRepairCommand = new AtomicInteger ( ) ; 
 
 - private static ScheduledRangeTransferExecutorService rangeXferExecutor = new ScheduledRangeTransferExecutorService ( ) ; 
 + private static final ScheduledRangeTransferExecutorService rangeXferExecutor = new ScheduledRangeTransferExecutorService ( ) ; 
 
 - private final List < IEndpointLifecycleSubscriber > lifecycleSubscribers = new CopyOnWriteArrayList < IEndpointLifecycleSubscriber > ( ) ; 
 + private final List < IEndpointLifecycleSubscriber > lifecycleSubscribers = new CopyOnWriteArrayList < > ( ) ; 
 
 private static final BackgroundActivityMonitor bgMonitor = new BackgroundActivityMonitor ( ) ; 
 
 @ @ - 564 , 7 + 564 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 Thread drainOnShutdown = new Thread ( new WrappedRunnable ( ) 
 { 
 @ Override 
 - public void runMayThrow ( ) throws ExecutionException , InterruptedException , IOException 
 + public void runMayThrow ( ) throws InterruptedException 
 { 
 ExecutorService counterMutationStage = StageManager . getStage ( Stage . COUNTER _ MUTATION ) ; 
 ExecutorService mutationStage = StageManager . getStage ( Stage . MUTATION ) ; 
 @ @ - 584 , 7 + 584 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 mutationStage . awaitTermination ( 3600 , TimeUnit . SECONDS ) ; 
 StorageProxy . instance . verifyNoHintsInProgress ( ) ; 
 
 - List < Future < ? > > flushes = new ArrayList < Future < ? > > ( ) ; 
 + List < Future < ? > > flushes = new ArrayList < > ( ) ; 
 for ( Keyspace keyspace : Keyspace . all ( ) ) 
 { 
 KSMetaData ksm = Schema . instance . getKSMetaData ( keyspace . getName ( ) ) ; 
 @ @ - 634 , 7 + 634 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 joined = true ; 
 
 Collection < Token > tokens = null ; 
 - Map < ApplicationState , VersionedValue > appStates = new HashMap < ApplicationState , VersionedValue > ( ) ; 
 + Map < ApplicationState , VersionedValue > appStates = new HashMap < > ( ) ; 
 
 if ( DatabaseDescriptor . getReplaceTokens ( ) . size ( ) > 0 | | DatabaseDescriptor . getReplaceNode ( ) ! = null ) 
 throw new RuntimeException ( " Replace method removed ; use cassandra . replace _ address instead " ) ; 
 @ @ - 684 , 7 + 684 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 / / 
 / / We attempted to replace this with a schema - presence check , but you need a meaningful sleep 
 / / to get schema info from gossip which defeats the purpose . See CASSANDRA - 4427 for the gory details . 
 - Set < InetAddress > current = new HashSet < InetAddress > ( ) ; 
 + Set < InetAddress > current = new HashSet < > ( ) ; 
 logger . debug ( " Bootstrap variables : { } { } { } { } " , 
 DatabaseDescriptor . isAutoBootstrap ( ) , 
 SystemKeyspace . bootstrapInProgress ( ) , 
 @ @ - 800 , 7 + 800 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 else 
 { 
 - tokens = new ArrayList < Token > ( initialTokens . size ( ) ) ; 
 + tokens = new ArrayList < > ( initialTokens . size ( ) ) ; 
 for ( String token : initialTokens ) 
 tokens . add ( getPartitioner ( ) . getTokenFactory ( ) . fromString ( token ) ) ; 
 logger . info ( " Saved tokens not found . Using configuration value : { } " , tokens ) ; 
 @ @ - 1054 , 7 + 1054 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 public Map < List < String > , List < String > > getRangeToEndpointMap ( String keyspace ) 
 { 
 / * All the ranges for the tokens * / 
 - Map < List < String > , List < String > > map = new HashMap < List < String > , List < String > > ( ) ; 
 + Map < List < String > , List < String > > map = new HashMap < > ( ) ; 
 for ( Map . Entry < Range < Token > , List < InetAddress > > entry : getRangeToAddressMap ( keyspace ) . entrySet ( ) ) 
 { 
 map . put ( entry . getKey ( ) . asList ( ) , stringify ( entry . getValue ( ) ) ) ; 
 @ @ - 1085 , 10 + 1085 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 public Map < List < String > , List < String > > getRangeToRpcaddressMap ( String keyspace ) 
 { 
 / * All the ranges for the tokens * / 
 - Map < List < String > , List < String > > map = new HashMap < List < String > , List < String > > ( ) ; 
 + Map < List < String > , List < String > > map = new HashMap < > ( ) ; 
 for ( Map . Entry < Range < Token > , List < InetAddress > > entry : getRangeToAddressMap ( keyspace ) . entrySet ( ) ) 
 { 
 - List < String > rpcaddrs = new ArrayList < String > ( entry . getValue ( ) . size ( ) ) ; 
 + List < String > rpcaddrs = new ArrayList < > ( entry . getValue ( ) . size ( ) ) ; 
 for ( InetAddress endpoint : entry . getValue ( ) ) 
 { 
 rpcaddrs . add ( getRpcaddress ( endpoint ) ) ; 
 @ @ - 1105 , 10 + 1105 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( keyspace = = null ) 
 keyspace = Schema . instance . getNonSystemKeyspaces ( ) . get ( 0 ) ; 
 
 - Map < List < String > , List < String > > map = new HashMap < List < String > , List < String > > ( ) ; 
 + Map < List < String > , List < String > > map = new HashMap < > ( ) ; 
 for ( Map . Entry < Range < Token > , Collection < InetAddress > > entry : tokenMetadata . getPendingRanges ( keyspace ) . entrySet ( ) ) 
 { 
 - List < InetAddress > l = new ArrayList < InetAddress > ( entry . getValue ( ) ) ; 
 + List < InetAddress > l = new ArrayList < > ( entry . getValue ( ) ) ; 
 map . put ( entry . getKey ( ) . asList ( ) , stringify ( l ) ) ; 
 } 
 return map ; 
 @ @ - 1189 , 7 + 1189 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 throw new IOException ( e . getMessage ( ) ) ; 
 } 
 - List < String > result = new ArrayList < String > ( tokenRanges . size ( ) ) ; 
 + List < String > result = new ArrayList < > ( tokenRanges . size ( ) ) ; 
 
 for ( TokenRange tokenRange : tokenRanges ) 
 result . add ( tokenRange . toString ( ) ) ; 
 @ @ - 1227 , 7 + 1227 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( keyspace = = null | | Keyspace . open ( keyspace ) . getReplicationStrategy ( ) instanceof LocalStrategy ) 
 throw new InvalidRequestException ( " There is no ring for the keyspace : " + keyspace ) ; 
 
 - List < TokenRange > ranges = new ArrayList < TokenRange > ( ) ; 
 + List < TokenRange > ranges = new ArrayList < > ( ) ; 
 Token . TokenFactory tf = getPartitioner ( ) . getTokenFactory ( ) ; 
 
 Map < Range < Token > , List < InetAddress > > rangeToAddressMap = 
 @ @ - 1239 , 9 + 1239 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 Range range = entry . getKey ( ) ; 
 List < InetAddress > addresses = entry . getValue ( ) ; 
 - List < String > endpoints = new ArrayList < String > ( addresses . size ( ) ) ; 
 - List < String > rpc _ endpoints = new ArrayList < String > ( addresses . size ( ) ) ; 
 - List < EndpointDetails > epDetails = new ArrayList < EndpointDetails > ( addresses . size ( ) ) ; 
 + List < String > endpoints = new ArrayList < > ( addresses . size ( ) ) ; 
 + List < String > rpc _ endpoints = new ArrayList < > ( addresses . size ( ) ) ; 
 + List < EndpointDetails > epDetails = new ArrayList < > ( addresses . size ( ) ) ; 
 
 for ( InetAddress endpoint : addresses ) 
 { 
 @ @ - 1270 , 8 + 1270 , 8 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 Map < Token , InetAddress > mapInetAddress = tokenMetadata . getNormalAndBootstrappingTokenToEndpointMap ( ) ; 
 / / in order to preserve tokens in ascending order , we use LinkedHashMap here 
 - Map < String , String > mapString = new LinkedHashMap < String , String > ( mapInetAddress . size ( ) ) ; 
 - List < Token > tokens = new ArrayList < Token > ( mapInetAddress . keySet ( ) ) ; 
 + Map < String , String > mapString = new LinkedHashMap < > ( mapInetAddress . size ( ) ) ; 
 + List < Token > tokens = new ArrayList < > ( mapInetAddress . keySet ( ) ) ; 
 Collections . sort ( tokens ) ; 
 for ( Token token : tokens ) 
 { 
 @ @ - 1287 , 7 + 1287 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public Map < String , String > getHostIdMap ( ) 
 { 
 - Map < String , String > mapOut = new HashMap < String , String > ( ) ; 
 + Map < String , String > mapOut = new HashMap < > ( ) ; 
 for ( Map . Entry < InetAddress , UUID > entry : getTokenMetadata ( ) . getEndpointToHostIdMapForReading ( ) . entrySet ( ) ) 
 mapOut . put ( entry . getKey ( ) . getHostAddress ( ) , entry . getValue ( ) . toString ( ) ) ; 
 return mapOut ; 
 @ @ - 1301 , 7 + 1301 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * / 
 private Map < Range < Token > , List < InetAddress > > constructRangeToEndpointMap ( String keyspace , List < Range < Token > > ranges ) 
 { 
 - Map < Range < Token > , List < InetAddress > > rangeToEndpointMap = new HashMap < Range < Token > , List < InetAddress > > ( ) ; 
 + Map < Range < Token > , List < InetAddress > > rangeToEndpointMap = new HashMap < > ( ) ; 
 for ( Range < Token > range : ranges ) 
 { 
 rangeToEndpointMap . put ( range , Keyspace . open ( keyspace ) . getReplicationStrategy ( ) . getNaturalEndpoints ( range . right ) ) ; 
 @ @ - 1358 , 20 + 1358 , 31 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 String moveName = pieces [ 0 ] ; 
 
 - if ( moveName . equals ( VersionedValue . STATUS _ BOOTSTRAPPING ) ) 
 - handleStateBootstrap ( endpoint ) ; 
 - else if ( moveName . equals ( VersionedValue . STATUS _ NORMAL ) ) 
 - handleStateNormal ( endpoint ) ; 
 - else if ( moveName . equals ( VersionedValue . REMOVING _ TOKEN ) | | moveName . equals ( VersionedValue . REMOVED _ TOKEN ) ) 
 - handleStateRemoving ( endpoint , pieces ) ; 
 - else if ( moveName . equals ( VersionedValue . STATUS _ LEAVING ) ) 
 - handleStateLeaving ( endpoint ) ; 
 - else if ( moveName . equals ( VersionedValue . STATUS _ LEFT ) ) 
 - handleStateLeft ( endpoint , pieces ) ; 
 - else if ( moveName . equals ( VersionedValue . STATUS _ MOVING ) ) 
 - handleStateMoving ( endpoint , pieces ) ; 
 - else if ( moveName . equals ( VersionedValue . STATUS _ RELOCATING ) ) 
 - handleStateRelocating ( endpoint , pieces ) ; 
 + switch ( moveName ) 
 + { 
 + case VersionedValue . STATUS _ BOOTSTRAPPING : 
 + handleStateBootstrap ( endpoint ) ; 
 + break ; 
 + case VersionedValue . STATUS _ NORMAL : 
 + handleStateNormal ( endpoint ) ; 
 + break ; 
 + case VersionedValue . REMOVING _ TOKEN : 
 + case VersionedValue . REMOVED _ TOKEN : 
 + handleStateRemoving ( endpoint , pieces ) ; 
 + break ; 
 + case VersionedValue . STATUS _ LEAVING : 
 + handleStateLeaving ( endpoint ) ; 
 + break ; 
 + case VersionedValue . STATUS _ LEFT : 
 + handleStateLeft ( endpoint , pieces ) ; 
 + break ; 
 + case VersionedValue . STATUS _ MOVING : 
 + handleStateMoving ( endpoint , pieces ) ; 
 + break ; 
 + case VersionedValue . STATUS _ RELOCATING : 
 + handleStateRelocating ( endpoint , pieces ) ; 
 + break ; 
 + } 
 } 
 else 
 { 
 @ @ - 1477 , 10 + 1488 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 tokens = getTokensFor ( endpoint ) ; 
 
 - Set < Token > tokensToUpdateInMetadata = new HashSet < Token > ( ) ; 
 - Set < Token > tokensToUpdateInSystemKeyspace = new HashSet < Token > ( ) ; 
 - Set < Token > localTokensToRemove = new HashSet < Token > ( ) ; 
 - Set < InetAddress > endpointsToRemove = new HashSet < InetAddress > ( ) ; 
 + Set < Token > tokensToUpdateInMetadata = new HashSet < > ( ) ; 
 + Set < Token > tokensToUpdateInSystemKeyspace = new HashSet < > ( ) ; 
 + Set < Token > localTokensToRemove = new HashSet < > ( ) ; 
 + Set < InetAddress > endpointsToRemove = new HashSet < > ( ) ; 
 
 
 if ( logger . isDebugEnabled ( ) ) 
 @ @ - 1704 , 7 + 1715 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 assert pieces . length > = 2 ; 
 
 - List < Token > tokens = new ArrayList < Token > ( pieces . length - 1 ) ; 
 + List < Token > tokens = new ArrayList < > ( pieces . length - 1 ) ; 
 for ( String tStr : Arrays . copyOfRange ( pieces , 1 , pieces . length ) ) 
 tokens . add ( getPartitioner ( ) . getTokenFactory ( ) . fromString ( tStr ) ) ; 
 
 @ @ - 1889 , 12 + 1900 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 Multimap < String , Map . Entry < InetAddress , Collection < Range < Token > > > > rangesToFetch = HashMultimap . create ( ) ; 
 
 - final InetAddress myAddress = FBUtilities . getBroadcastAddress ( ) ; 
 + InetAddress myAddress = FBUtilities . getBroadcastAddress ( ) ; 
 
 for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) 
 { 
 Multimap < Range < Token > , InetAddress > changedRanges = getChangedRangesForLeaving ( keyspaceName , endpoint ) ; 
 - Set < Range < Token > > myNewRanges = new HashSet < Range < Token > > ( ) ; 
 + Set < Range < Token > > myNewRanges = new HashSet < > ( ) ; 
 for ( Map . Entry < Range < Token > , InetAddress > entry : changedRanges . entries ( ) ) 
 { 
 if ( entry . getValue ( ) . equals ( myAddress ) ) 
 @ @ - 1908 , 11 + 1919 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 
 StreamPlan stream = new StreamPlan ( " Restore replica count " ) ; 
 - for ( final String keyspaceName : rangesToFetch . keySet ( ) ) 
 + for ( String keyspaceName : rangesToFetch . keySet ( ) ) 
 { 
 for ( Map . Entry < InetAddress , Collection < Range < Token > > > entry : rangesToFetch . get ( keyspaceName ) ) 
 { 
 - final InetAddress source = entry . getKey ( ) ; 
 + InetAddress source = entry . getKey ( ) ; 
 Collection < Range < Token > > ranges = entry . getValue ( ) ; 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Requesting from { } ranges { } " , source , StringUtils . join ( ranges , " , " ) ) ; 
 @ @ - 1945 , 7 + 1956 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Node { } ranges [ { } ] " , endpoint , StringUtils . join ( ranges , " , " ) ) ; 
 
 - Map < Range < Token > , List < InetAddress > > currentReplicaEndpoints = new HashMap < Range < Token > , List < InetAddress > > ( ) ; 
 + Map < Range < Token > , List < InetAddress > > currentReplicaEndpoints = new HashMap < > ( ) ; 
 
 / / Find ( for each range ) all nodes that store replicas for these ranges as well 
 for ( Range < Token > range : ranges ) 
 @ @ - 2051 , 7 + 2062 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public Map < String , String > getLoadMap ( ) 
 { 
 - Map < String , String > map = new HashMap < String , String > ( ) ; 
 + Map < String , String > map = new HashMap < > ( ) ; 
 for ( Map . Entry < InetAddress , Double > entry : LoadBroadcaster . instance . getLoadInfo ( ) . entrySet ( ) ) 
 { 
 map . put ( entry . getKey ( ) . getHostAddress ( ) , FileUtils . stringifyFileSize ( entry . getValue ( ) ) ) ; 
 @ @ - 2087 , 7 + 2098 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private List < String > getTokens ( InetAddress endpoint ) 
 { 
 - List < String > strTokens = new ArrayList < String > ( ) ; 
 + List < String > strTokens = new ArrayList < > ( ) ; 
 for ( Token tok : getTokenMetadata ( ) . getTokens ( endpoint ) ) 
 strTokens . add ( tok . toString ( ) ) ; 
 return strTokens ; 
 @ @ - 2110 , 7 + 2121 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public List < String > getMovingNodes ( ) 
 { 
 - List < String > endpoints = new ArrayList < String > ( ) ; 
 + List < String > endpoints = new ArrayList < > ( ) ; 
 
 for ( Pair < Token , InetAddress > node : tokenMetadata . getMovingEndpoints ( ) ) 
 { 
 @ @ - 2155 , 7 + 2166 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private List < String > stringify ( Iterable < InetAddress > endpoints ) 
 { 
 - List < String > stringEndpoints = new ArrayList < String > ( ) ; 
 + List < String > stringEndpoints = new ArrayList < > ( ) ; 
 for ( InetAddress ep : endpoints ) 
 { 
 stringEndpoints . add ( ep . getHostAddress ( ) ) ; 
 @ @ - 2235 , 7 + 2246 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 else 
 { 
 - ArrayList < Keyspace > t = new ArrayList < Keyspace > ( keyspaceNames . length ) ; 
 + ArrayList < Keyspace > t = new ArrayList < > ( keyspaceNames . length ) ; 
 for ( String keyspaceName : keyspaceNames ) 
 t . add ( getValidKeyspace ( keyspaceName ) ) ; 
 keyspaces = t ; 
 @ @ - 2319 , 15 + 2330 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public Map < String , TabularData > getSnapshotDetails ( ) 
 { 
 - final Map < String , TabularData > snapshotMap = new HashMap < > ( ) ; 
 - for ( final Keyspace keyspace : Keyspace . all ( ) ) 
 + Map < String , TabularData > snapshotMap = new HashMap < > ( ) ; 
 + for ( Keyspace keyspace : Keyspace . all ( ) ) 
 { 
 if ( Keyspace . SYSTEM _ KS . equals ( keyspace . getName ( ) ) ) 
 continue ; 
 
 - for ( final ColumnFamilyStore cfStore : keyspace . getColumnFamilyStores ( ) ) 
 + for ( ColumnFamilyStore cfStore : keyspace . getColumnFamilyStores ( ) ) 
 { 
 - for ( final Map . Entry < String , Pair < Long , Long > > snapshotDetail : cfStore . getSnapshotDetails ( ) . entrySet ( ) ) 
 + for ( Map . Entry < String , Pair < Long , Long > > snapshotDetail : cfStore . getSnapshotDetails ( ) . entrySet ( ) ) 
 { 
 TabularDataSupport data = ( TabularDataSupport ) snapshotMap . get ( snapshotDetail . getKey ( ) ) ; 
 if ( data = = null ) 
 @ @ - 2346 , 12 + 2357 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 public long trueSnapshotsSize ( ) 
 { 
 long total = 0 ; 
 - for ( final Keyspace keyspace : Keyspace . all ( ) ) 
 + for ( Keyspace keyspace : Keyspace . all ( ) ) 
 { 
 if ( Keyspace . SYSTEM _ KS . equals ( keyspace . getName ( ) ) ) 
 continue ; 
 
 - for ( final ColumnFamilyStore cfStore : keyspace . getColumnFamilyStores ( ) ) 
 + for ( ColumnFamilyStore cfStore : keyspace . getColumnFamilyStores ( ) ) 
 { 
 total + = cfStore . trueSnapshotsSize ( ) ; 
 } 
 @ @ - 2419 , 7 + 2430 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 if ( idxName ! = null ) 
 { 
 - Collection < SecondaryIndex > indexes = cfStore . indexManager . getIndexesByNames ( new HashSet < String > ( Arrays . asList ( cfName ) ) ) ; 
 + Collection < SecondaryIndex > indexes = cfStore . indexManager . getIndexesByNames ( new HashSet < > ( Arrays . asList ( cfName ) ) ) ; 
 if ( indexes . isEmpty ( ) ) 
 logger . warn ( String . format ( " Invalid column family index specified : % s / % s . Proceeding with others . " , baseCfName , idxName ) ) ; 
 else 
 @ @ - 2449 , 7 + 2460 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * @ param columnFamilies 
 * @ throws IOException 
 * / 
 - public void forceKeyspaceFlush ( final String keyspaceName , final String . . . columnFamilies ) throws IOException 
 + public void forceKeyspaceFlush ( String keyspaceName , String . . . columnFamilies ) throws IOException 
 { 
 for ( ColumnFamilyStore cfStore : getValidColumnFamilies ( true , false , keyspaceName , columnFamilies ) ) 
 { 
 @ @ - 2472 , 19 + 2483 , 19 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 sendNotification ( jmxNotification ) ; 
 } 
 
 - public int forceRepairAsync ( final String keyspace , final boolean isSequential , final Collection < String > dataCenters , Collection < String > hosts , final boolean primaryRange , final boolean fullRepair , final String . . . columnFamilies ) throws IOException 
 + public int forceRepairAsync ( String keyspace , boolean isSequential , Collection < String > dataCenters , Collection < String > hosts , boolean primaryRange , boolean fullRepair , String . . . columnFamilies ) throws IOException 
 { 
 - final Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; 
 + Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; 
 
 return forceRepairAsync ( keyspace , isSequential , dataCenters , hosts , ranges , fullRepair , columnFamilies ) ; 
 } 
 
 - public int forceRepairAsync ( final String keyspace , final boolean isSequential , final Collection < String > dataCenters , Collection < String > hosts , final Collection < Range < Token > > ranges , final boolean fullRepair , final String . . . columnFamilies ) throws IOException 
 + public int forceRepairAsync ( String keyspace , boolean isSequential , Collection < String > dataCenters , Collection < String > hosts , Collection < Range < Token > > ranges , boolean fullRepair , String . . . columnFamilies ) 
 { 
 if ( Keyspace . SYSTEM _ KS . equals ( keyspace ) | | ranges . isEmpty ( ) ) 
 return 0 ; 
 
 - final int cmd = nextRepairCommand . incrementAndGet ( ) ; 
 + int cmd = nextRepairCommand . incrementAndGet ( ) ; 
 if ( ranges . size ( ) > 0 ) 
 { 
 new Thread ( createRepairTask ( cmd , keyspace , ranges , isSequential , dataCenters , hosts , fullRepair , columnFamilies ) ) . start ( ) ; 
 @ @ - 2492 , 9 + 2503 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return cmd ; 
 } 
 
 - public int forceRepairAsync ( final String keyspace , final boolean isSequential , final boolean isLocal , final boolean primaryRange , final boolean fullRepair , final String . . . columnFamilies ) 
 + public int forceRepairAsync ( String keyspace , boolean isSequential , boolean isLocal , boolean primaryRange , boolean fullRepair , String . . . columnFamilies ) 
 { 
 - final Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; 
 + Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; 
 return forceRepairAsync ( keyspace , isSequential , isLocal , ranges , fullRepair , columnFamilies ) ; 
 } 
 
 @ @ - 2503 , 7 + 2514 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( Keyspace . SYSTEM _ KS . equals ( keyspace ) | | ranges . isEmpty ( ) ) 
 return 0 ; 
 
 - final int cmd = nextRepairCommand . incrementAndGet ( ) ; 
 + int cmd = nextRepairCommand . incrementAndGet ( ) ; 
 if ( ! FBUtilities . isUnix ( ) & & isSequential ) 
 { 
 logger . warn ( " Snapshot - based repair is not yet supported on Windows . Reverting to parallel repair . " ) ; 
 @ @ - 2513 , 33 + 2524 , 33 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return cmd ; 
 } 
 
 - public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , Collection < String > hosts , boolean fullRepair , final String . . . columnFamilies ) throws IOException 
 + public int forceRepairRangeAsync ( String beginToken , String endToken , String keyspaceName , boolean isSequential , Collection < String > dataCenters , Collection < String > hosts , boolean fullRepair , String . . . columnFamilies ) throws IOException 
 { 
 Token parsedBeginToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( beginToken ) ; 
 Token parsedEndToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( endToken ) ; 
 
 logger . info ( " starting user - requested repair of range ( { } , { } ] for keyspace { } and column families { } " , 
 parsedBeginToken , parsedEndToken , keyspaceName , columnFamilies ) ; 
 - return forceRepairAsync ( keyspaceName , isSequential , dataCenters , hosts , Collections . singleton ( new Range < Token > ( parsedBeginToken , parsedEndToken ) ) , fullRepair , columnFamilies ) ; 
 + return forceRepairAsync ( keyspaceName , isSequential , dataCenters , hosts , Collections . singleton ( new Range < > ( parsedBeginToken , parsedEndToken ) ) , fullRepair , columnFamilies ) ; 
 } 
 
 - public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , boolean isLocal , boolean fullRepair , final String . . . columnFamilies ) 
 + public int forceRepairRangeAsync ( String beginToken , String endToken , String keyspaceName , boolean isSequential , boolean isLocal , boolean fullRepair , String . . . columnFamilies ) 
 { 
 Token parsedBeginToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( beginToken ) ; 
 Token parsedEndToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( endToken ) ; 
 
 logger . info ( " starting user - requested repair of range ( { } , { } ] for keyspace { } and column families { } " , 
 parsedBeginToken , parsedEndToken , keyspaceName , columnFamilies ) ; 
 - return forceRepairAsync ( keyspaceName , isSequential , isLocal , Collections . singleton ( new Range < Token > ( parsedBeginToken , parsedEndToken ) ) , fullRepair , columnFamilies ) ; 
 + return forceRepairAsync ( keyspaceName , isSequential , isLocal , Collections . singleton ( new Range < > ( parsedBeginToken , parsedEndToken ) ) , fullRepair , columnFamilies ) ; 
 } 
 
 - private FutureTask < Object > createRepairTask ( final int cmd , 
 - final String keyspace , 
 - final Collection < Range < Token > > ranges , 
 - final boolean isSequential , 
 - final boolean isLocal , 
 - final boolean fullRepair , 
 - final String . . . columnFamilies ) 
 + private FutureTask < Object > createRepairTask ( int cmd , 
 + String keyspace , 
 + Collection < Range < Token > > ranges , 
 + boolean isSequential , 
 + boolean isLocal , 
 + boolean fullRepair , 
 + String . . . columnFamilies ) 
 { 
 Set < String > dataCenters = null ; 
 if ( isLocal ) 
 @ @ - 2657 , 9 + 2668 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 
 
 - public RepairFuture forceKeyspaceRepair ( final UUID parentRepairSession , 
 - final Range < Token > range , 
 - final String keyspaceName , 
 + public RepairFuture forceKeyspaceRepair ( UUID parentRepairSession , 
 + Range < Token > range , 
 + String keyspaceName , 
 boolean isSequential , 
 Set < InetAddress > endpoints , 
 String . . . columnFamilies ) throws IOException 
 @ @ - 2698 , 13 + 2709 , 13 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 public Collection < Range < Token > > getPrimaryRangesForEndpoint ( String keyspace , InetAddress ep ) 
 { 
 AbstractReplicationStrategy strategy = Keyspace . open ( keyspace ) . getReplicationStrategy ( ) ; 
 - Collection < Range < Token > > primaryRanges = new HashSet < Range < Token > > ( ) ; 
 + Collection < Range < Token > > primaryRanges = new HashSet < > ( ) ; 
 TokenMetadata metadata = tokenMetadata . cloneOnlyTokenMap ( ) ; 
 for ( Token token : metadata . sortedTokens ( ) ) 
 { 
 List < InetAddress > endpoints = strategy . calculateNaturalEndpoints ( token , metadata ) ; 
 if ( endpoints . size ( ) > 0 & & endpoints . get ( 0 ) . equals ( ep ) ) 
 - primaryRanges . add ( new Range < Token > ( metadata . getPredecessor ( token ) , token ) ) ; 
 + primaryRanges . add ( new Range < > ( metadata . getPredecessor ( token ) , token ) ) ; 
 } 
 return primaryRanges ; 
 } 
 @ @ - 2750 , 13 + 2761 , 13 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( sortedTokens . isEmpty ( ) ) 
 return Collections . emptyList ( ) ; 
 int size = sortedTokens . size ( ) ; 
 - List < Range < Token > > ranges = new ArrayList < Range < Token > > ( size + 1 ) ; 
 + List < Range < Token > > ranges = new ArrayList < > ( size + 1 ) ; 
 for ( int i = 1 ; i < size ; + + i ) 
 { 
 - Range < Token > range = new Range < Token > ( sortedTokens . get ( i - 1 ) , sortedTokens . get ( i ) ) ; 
 + Range < Token > range = new Range < > ( sortedTokens . get ( i - 1 ) , sortedTokens . get ( i ) ) ; 
 ranges . add ( range ) ; 
 } 
 - Range < Token > range = new Range < Token > ( sortedTokens . get ( size - 1 ) , sortedTokens . get ( 0 ) ) ; 
 + Range < Token > range = new Range < > ( sortedTokens . get ( size - 1 ) , sortedTokens . get ( 0 ) ) ; 
 ranges . add ( range ) ; 
 
 return ranges ; 
 @ @ - 2811 , 7 + 2822 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 public List < InetAddress > getLiveNaturalEndpoints ( Keyspace keyspace , RingPosition pos ) 
 { 
 List < InetAddress > endpoints = keyspace . getReplicationStrategy ( ) . getNaturalEndpoints ( pos ) ; 
 - List < InetAddress > liveEps = new ArrayList < InetAddress > ( endpoints . size ( ) ) ; 
 + List < InetAddress > liveEps = new ArrayList < > ( endpoints . size ( ) ) ; 
 
 for ( InetAddress endpoint : endpoints ) 
 { 
 @ @ - 2843 , 9 + 2854 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 long totalRowCountEstimate = cfs . estimatedKeysForRange ( range ) ; 
 
 / / splitCount should be much smaller than number of key samples , to avoid huge sampling error 
 - final int minSamplesPerSplit = 4 ; 
 - final int maxSplitCount = keys . size ( ) / minSamplesPerSplit + 1 ; 
 - final int splitCount = Math . max ( 1 , Math . min ( maxSplitCount , ( int ) ( totalRowCountEstimate / keysPerSplit ) ) ) ; 
 + int minSamplesPerSplit = 4 ; 
 + int maxSplitCount = keys . size ( ) / minSamplesPerSplit + 1 ; 
 + int splitCount = Math . max ( 1 , Math . min ( maxSplitCount , ( int ) ( totalRowCountEstimate / keysPerSplit ) ) ) ; 
 
 List < Token > tokens = keysToTokens ( range , keys ) ; 
 return getSplits ( tokens , splitCount , cfs ) ; 
 @ @ - 2853 , 7 + 2864 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private List < Pair < Range < Token > , Long > > getSplits ( List < Token > tokens , int splitCount , ColumnFamilyStore cfs ) 
 { 
 - final double step = ( double ) ( tokens . size ( ) - 1 ) / splitCount ; 
 + double step = ( double ) ( tokens . size ( ) - 1 ) / splitCount ; 
 Token prevToken = tokens . get ( 0 ) ; 
 List < Pair < Range < Token > , Long > > splits = Lists . newArrayListWithExpectedSize ( splitCount ) ; 
 for ( int i = 1 ; i < = splitCount ; i + + ) 
 @ @ - 2879 , 7 + 2890 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private List < DecoratedKey > keySamples ( Iterable < ColumnFamilyStore > cfses , Range < Token > range ) 
 { 
 - List < DecoratedKey > keys = new ArrayList < DecoratedKey > ( ) ; 
 + List < DecoratedKey > keys = new ArrayList < > ( ) ; 
 for ( ColumnFamilyStore cfs : cfses ) 
 Iterables . addAll ( keys , cfs . keySamples ( range ) ) ; 
 FBUtilities . sortSampledKeys ( keys , range ) ; 
 @ @ - 2943 , 11 + 2954 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 Uninterruptibles . sleepUninterruptibly ( delay , TimeUnit . MILLISECONDS ) ; 
 } 
 
 - private void unbootstrap ( final Runnable onFinish ) 
 + private void unbootstrap ( Runnable onFinish ) 
 { 
 - Map < String , Multimap < Range < Token > , InetAddress > > rangesToStream = new HashMap < String , Multimap < Range < Token > , InetAddress > > ( ) ; 
 + Map < String , Multimap < Range < Token > , InetAddress > > rangesToStream = new HashMap < > ( ) ; 
 
 - for ( final String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) 
 + for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) 
 { 
 Multimap < Range < Token > , InetAddress > rangesMM = getChangedRangesForLeaving ( keyspaceName , FBUtilities . getBroadcastAddress ( ) ) ; 
 
 @ @ - 2984 , 7 + 2995 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return Futures . immediateFuture ( null ) ; 
 
 / / gather all live nodes in the cluster that aren ' t also leaving 
 - List < InetAddress > candidates = new ArrayList < InetAddress > ( StorageService . instance . getTokenMetadata ( ) . cloneAfterAllLeft ( ) . getAllEndpoints ( ) ) ; 
 + List < InetAddress > candidates = new ArrayList < > ( StorageService . instance . getTokenMetadata ( ) . cloneAfterAllLeft ( ) . getAllEndpoints ( ) ) ; 
 candidates . remove ( FBUtilities . getBroadcastAddress ( ) ) ; 
 for ( Iterator < InetAddress > iter = candidates . iterator ( ) ; iter . hasNext ( ) ; ) 
 { 
 @ @ - 3006 , 7 + 3017 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 / / stream all hints - - range list will be a singleton of " the entire ring " 
 Token token = StorageService . getPartitioner ( ) . getMinimumToken ( ) ; 
 - List < Range < Token > > ranges = Collections . singletonList ( new Range < Token > ( token , token ) ) ; 
 + List < Range < Token > > ranges = Collections . singletonList ( new Range < > ( token , token ) ) ; 
 
 return new StreamPlan ( " Hints " ) . transferRanges ( hintsDestinationHost , 
 Keyspace . SYSTEM _ KS , 
 @ @ - 3097 , 7 + 3108 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private class RangeRelocator 
 { 
 - private StreamPlan streamPlan = new StreamPlan ( " Bootstrap " ) ; 
 + private final StreamPlan streamPlan = new StreamPlan ( " Bootstrap " ) ; 
 
 private RangeRelocator ( Collection < Token > tokens , List < String > keyspaceNames ) 
 { 
 @ @ - 3189 , 7 + 3200 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public void relocate ( Collection < String > srcTokens ) throws IOException 
 { 
 - List < Token > tokens = new ArrayList < Token > ( srcTokens . size ( ) ) ; 
 + List < Token > tokens = new ArrayList < > ( srcTokens . size ( ) ) ; 
 try 
 { 
 for ( String srcT : srcTokens ) 
 @ @ - 3213 , 7 + 3224 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 assert srcTokens ! = null ; 
 InetAddress localAddress = FBUtilities . getBroadcastAddress ( ) ; 
 Collection < Token > localTokens = getTokenMetadata ( ) . getTokens ( localAddress ) ; 
 - Set < Token > tokens = new HashSet < Token > ( srcTokens ) ; 
 + Set < Token > tokens = new HashSet < > ( srcTokens ) ; 
 
 Iterator < Token > it = tokens . iterator ( ) ; 
 while ( it . hasNext ( ) ) 
 @ @ - 3469 , 7 + 3480 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 totalCFs + = keyspace . getColumnFamilyStores ( ) . size ( ) ; 
 remainingCFs = totalCFs ; 
 / / flush 
 - List < Future < ? > > flushes = new ArrayList < Future < ? > > ( ) ; 
 + List < Future < ? > > flushes = new ArrayList < > ( ) ; 
 for ( Keyspace keyspace : Keyspace . nonSystem ( ) ) 
 { 
 for ( ColumnFamilyStore cfs : keyspace . getColumnFamilyStores ( ) ) 
 @ @ - 3543 , 7 + 3554 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 List < Token > sortedTokens = tokenMetadata . sortedTokens ( ) ; 
 / / describeOwnership returns tokens in an unspecified order , let ' s re - order them 
 Map < Token , Float > tokenMap = new TreeMap < Token , Float > ( getPartitioner ( ) . describeOwnership ( sortedTokens ) ) ; 
 - Map < InetAddress , Float > nodeMap = new LinkedHashMap < InetAddress , Float > ( ) ; 
 + Map < InetAddress , Float > nodeMap = new LinkedHashMap < > ( ) ; 
 for ( Map . Entry < Token , Float > entry : tokenMap . entrySet ( ) ) 
 { 
 InetAddress endpoint = tokenMetadata . getEndpoint ( entry . getKey ( ) ) ; 
 @ @ - 3577 , 9 + 3588 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( keyspace = = null ) 
 keyspace = Schema . instance . getNonSystemKeyspaces ( ) . get ( 0 ) ; 
 
 - Collection < Collection < InetAddress > > endpointsGroupedByDc = new ArrayList < Collection < InetAddress > > ( ) ; 
 + Collection < Collection < InetAddress > > endpointsGroupedByDc = new ArrayList < > ( ) ; 
 / / mapping of dc ' s to nodes , use sorted map so that we get dcs sorted 
 - SortedMap < String , Collection < InetAddress > > sortedDcsToEndpoints = new TreeMap < String , Collection < InetAddress > > ( ) ; 
 + SortedMap < String , Collection < InetAddress > > sortedDcsToEndpoints = new TreeMap < > ( ) ; 
 sortedDcsToEndpoints . putAll ( metadata . getTopology ( ) . getDatacenterEndpoints ( ) . asMap ( ) ) ; 
 for ( Collection < InetAddress > endpoints : sortedDcsToEndpoints . values ( ) ) 
 endpointsGroupedByDc . add ( endpoints ) ; 
 @ @ - 3625 , 7 + 3636 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public List < String > getKeyspaces ( ) 
 { 
 - List < String > keyspaceNamesList = new ArrayList < String > ( Schema . instance . getKeyspaces ( ) ) ; 
 + List < String > keyspaceNamesList = new ArrayList < > ( Schema . instance . getKeyspaces ( ) ) ; 
 return Collections . unmodifiableList ( keyspaceNamesList ) ; 
 } 
 
 @ @ - 3668 , 10 + 3679 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * @ param rangesToStreamByKeyspace keyspaces and data ranges with endpoints included for each 
 * @ return async Future for whether stream was success 
 * / 
 - private Future < StreamState > streamRanges ( final Map < String , Multimap < Range < Token > , InetAddress > > rangesToStreamByKeyspace ) 
 + private Future < StreamState > streamRanges ( Map < String , Multimap < Range < Token > , InetAddress > > rangesToStreamByKeyspace ) 
 { 
 / / First , we build a list of ranges to stream to each host , per table 
 - final Map < String , Map < InetAddress , List < Range < Token > > > > sessionsToStreamByKeyspace = new HashMap < String , Map < InetAddress , List < Range < Token > > > > ( ) ; 
 + Map < String , Map < InetAddress , List < Range < Token > > > > sessionsToStreamByKeyspace = new HashMap < > ( ) ; 
 for ( Map . Entry < String , Multimap < Range < Token > , InetAddress > > entry : rangesToStreamByKeyspace . entrySet ( ) ) 
 { 
 String keyspace = entry . getKey ( ) ; 
 @ @ - 3680 , 16 + 3691 , 16 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( rangesWithEndpoints . isEmpty ( ) ) 
 continue ; 
 
 - Map < InetAddress , List < Range < Token > > > rangesPerEndpoint = new HashMap < InetAddress , List < Range < Token > > > ( ) ; 
 - for ( final Map . Entry < Range < Token > , InetAddress > endPointEntry : rangesWithEndpoints . entries ( ) ) 
 + Map < InetAddress , List < Range < Token > > > rangesPerEndpoint = new HashMap < > ( ) ; 
 + for ( Map . Entry < Range < Token > , InetAddress > endPointEntry : rangesWithEndpoints . entries ( ) ) 
 { 
 - final Range < Token > range = endPointEntry . getKey ( ) ; 
 - final InetAddress endpoint = endPointEntry . getValue ( ) ; 
 + Range < Token > range = endPointEntry . getKey ( ) ; 
 + InetAddress endpoint = endPointEntry . getValue ( ) ; 
 
 List < Range < Token > > curRanges = rangesPerEndpoint . get ( endpoint ) ; 
 if ( curRanges = = null ) 
 { 
 - curRanges = new LinkedList < Range < Token > > ( ) ; 
 + curRanges = new LinkedList < > ( ) ; 
 rangesPerEndpoint . put ( endpoint , curRanges ) ; 
 } 
 curRanges . add ( range ) ; 
 @ @ - 3701 , 13 + 3712 , 13 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 StreamPlan streamPlan = new StreamPlan ( " Unbootstrap " ) ; 
 for ( Map . Entry < String , Map < InetAddress , List < Range < Token > > > > entry : sessionsToStreamByKeyspace . entrySet ( ) ) 
 { 
 - final String keyspaceName = entry . getKey ( ) ; 
 - final Map < InetAddress , List < Range < Token > > > rangesPerEndpoint = entry . getValue ( ) ; 
 + String keyspaceName = entry . getKey ( ) ; 
 + Map < InetAddress , List < Range < Token > > > rangesPerEndpoint = entry . getValue ( ) ; 
 
 - for ( final Map . Entry < InetAddress , List < Range < Token > > > rangesEntry : rangesPerEndpoint . entrySet ( ) ) 
 + for ( Map . Entry < InetAddress , List < Range < Token > > > rangesEntry : rangesPerEndpoint . entrySet ( ) ) 
 { 
 - final List < Range < Token > > ranges = rangesEntry . getValue ( ) ; 
 - final InetAddress newEndpoint = rangesEntry . getKey ( ) ; 
 + List < Range < Token > > ranges = rangesEntry . getValue ( ) ; 
 + InetAddress newEndpoint = rangesEntry . getKey ( ) ; 
 
 / / TODO each call to transferRanges re - flushes , this is potentially a lot of waste 
 streamPlan . transferRanges ( newEndpoint , keyspaceName , ranges ) ; 
 @ @ - 3726 , 8 + 3737 , 8 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * / 
 public Pair < Set < Range < Token > > , Set < Range < Token > > > calculateStreamAndFetchRanges ( Collection < Range < Token > > current , Collection < Range < Token > > updated ) 
 { 
 - Set < Range < Token > > toStream = new HashSet < Range < Token > > ( ) ; 
 - Set < Range < Token > > toFetch = new HashSet < Range < Token > > ( ) ; 
 + Set < Range < Token > > toStream = new HashSet < > ( ) ; 
 + Set < Range < Token > > toFetch = new HashSet < > ( ) ; 
 
 
 for ( Range r1 : current ) 
 @ @ - 3846 , 14 + 3857 , 14 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * / 
 public List < String > sampleKeyRange ( ) / / do not rename to getter - see CASSANDRA - 4452 for details 
 { 
 - List < DecoratedKey > keys = new ArrayList < DecoratedKey > ( ) ; 
 + List < DecoratedKey > keys = new ArrayList < > ( ) ; 
 for ( Keyspace keyspace : Keyspace . nonSystem ( ) ) 
 { 
 for ( Range < Token > range : getPrimaryRangesForEndpoint ( keyspace . getName ( ) , FBUtilities . getBroadcastAddress ( ) ) ) 
 keys . addAll ( keySamples ( keyspace . getColumnFamilyStores ( ) , range ) ) ; 
 } 
 
 - List < String > sampledKeys = new ArrayList < String > ( keys . size ( ) ) ; 
 + List < String > sampledKeys = new ArrayList < > ( keys . size ( ) ) ; 
 for ( DecoratedKey key : keys ) 
 sampledKeys . add ( key . getToken ( ) . toString ( ) ) ; 
 return sampledKeys ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 index 3792128 . . da7bff1 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java 
 + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 @ @ - 146 , 14 + 146 , 13 @ @ public class BootStrapper 
 
 Multimap < Range , InetAddress > getRangesWithSources ( ) 
 { 
 - Map < Token , InetAddress > map = tokenMetadata . cloneTokenEndPointMap ( ) ; 
 - assert map . size ( ) > 0 ; 
 - map . put ( token , address ) ; 
 - Collection < Range > myRanges = replicationStrategy . getAddressRanges ( map ) . get ( address ) ; 
 - map . remove ( token ) ; 
 + TokenMetadata temp = tokenMetadata . cloneMe ( ) ; 
 + assert temp . sortedTokens ( ) . size ( ) > 0 ; 
 + temp . update ( token , address ) ; 
 + Collection < Range > myRanges = replicationStrategy . getAddressRanges ( temp ) . get ( address ) ; 
 
 Multimap < Range , InetAddress > myRangeAddresses = HashMultimap . create ( ) ; 
 - Multimap < Range , InetAddress > rangeAddresses = replicationStrategy . getRangeAddresses ( map ) ; 
 + Multimap < Range , InetAddress > rangeAddresses = replicationStrategy . getRangeAddresses ( tokenMetadata ) ; 
 for ( Range range : rangeAddresses . keySet ( ) ) 
 { 
 for ( Range myRange : myRanges ) 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 index 2b6b261 . . e7722de 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 @ @ - 56 , 7 + 56 , 7 @ @ public abstract class AbstractReplicationStrategy 
 storagePort _ = storagePort ; 
 } 
 
 - public abstract ArrayList < InetAddress > getNaturalEndpoints ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) ; 
 + public abstract ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) ; 
 
 public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) throws InvalidRequestException 
 { 
 @ @ - 65 , 7 + 65 , 7 @ @ public abstract class AbstractReplicationStrategy 
 
 public ArrayList < InetAddress > getNaturalEndpoints ( Token token ) 
 { 
 - return getNaturalEndpoints ( token , tokenMetadata _ . cloneTokenEndPointMap ( ) ) ; 
 + return getNaturalEndpoints ( token , tokenMetadata _ ) ; 
 } 
 
 / * 
 @ @ - 88 , 29 + 88 , 21 @ @ public abstract class AbstractReplicationStrategy 
 * / 
 public ArrayList < InetAddress > getWriteEndpoints ( Token token , Collection < InetAddress > naturalEndpoints ) 
 { 
 - Map < Token , InetAddress > tokenToEndPointMap = tokenMetadata _ . cloneTokenEndPointMap ( ) ; 
 - Map < Token , InetAddress > bootstrapTokensToEndpointMap = tokenMetadata _ . cloneBootstrapNodes ( ) ; 
 ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( naturalEndpoints ) ; 
 
 - for ( Token t : bootstrapTokensToEndpointMap . keySet ( ) ) 
 + for ( Token t : tokenMetadata _ . bootstrapTokens ( ) ) 
 { 
 - InetAddress ep = bootstrapTokensToEndpointMap . get ( t ) ; 
 - tokenToEndPointMap . put ( t , ep ) ; 
 - try 
 + TokenMetadata temp = tokenMetadata _ . cloneMe ( ) ; 
 + InetAddress ep = tokenMetadata _ . getBootstrapEndpoint ( t ) ; 
 + temp . update ( t , ep ) ; 
 + for ( Range r : getAddressRanges ( temp ) . get ( ep ) ) 
 { 
 - for ( Range r : getAddressRanges ( tokenToEndPointMap ) . get ( ep ) ) 
 + if ( r . contains ( token ) ) 
 { 
 - if ( r . contains ( token ) ) 
 - { 
 - endpoints . add ( ep ) ; 
 - break ; 
 - } 
 + endpoints . add ( ep ) ; 
 + break ; 
 } 
 } 
 - finally 
 - { 
 - tokenToEndPointMap . remove ( t ) ; 
 - } 
 } 
 
 return endpoints ; 
 @ @ - 139 , 9 + 131 , 7 @ @ public abstract class AbstractReplicationStrategy 
 { 
 / / find another endpoint to store a hint on . prefer endpoints that aren ' t already in use 
 InetAddress hintLocation = null ; 
 - Map < Token , InetAddress > tokenToEndPointMap = tokenMetadata _ . cloneTokenEndPointMap ( ) ; 
 - List tokens = new ArrayList ( tokenToEndPointMap . keySet ( ) ) ; 
 - Collections . sort ( tokens ) ; 
 + List tokens = tokenMetadata _ . sortedTokens ( ) ; 
 Token token = tokenMetadata _ . getToken ( ep ) ; 
 int index = Collections . binarySearch ( tokens , token ) ; 
 if ( index < 0 ) 
 @ @ - 154 , 7 + 144 , 7 @ @ public abstract class AbstractReplicationStrategy 
 int startIndex = ( index + 1 ) % totalNodes ; 
 for ( int i = startIndex , count = 1 ; count < totalNodes ; + + count , i = ( i + 1 ) % totalNodes ) 
 { 
 - InetAddress tmpEndPoint = tokenToEndPointMap . get ( tokens . get ( i ) ) ; 
 + InetAddress tmpEndPoint = tokenMetadata _ . getEndPoint ( ( Token ) tokens . get ( i ) ) ; 
 if ( FailureDetector . instance ( ) . isAlive ( tmpEndPoint ) & & ! targets . contains ( tmpEndPoint ) & & ! usedEndpoints . contains ( tmpEndPoint ) ) 
 { 
 hintLocation = tmpEndPoint ; 
 @ @ - 176 , 13 + 166 , 13 @ @ public abstract class AbstractReplicationStrategy 
 
 / / TODO this is pretty inefficient . also the inverse ( getRangeAddresses ) below . 
 / / fixing this probably requires merging tokenmetadata into replicationstrategy , so we can cache / invalidate cleanly 
 - public Multimap < InetAddress , Range > getAddressRanges ( Map < Token , InetAddress > metadata ) 
 + public Multimap < InetAddress , Range > getAddressRanges ( TokenMetadata metadata ) 
 { 
 Multimap < InetAddress , Range > map = HashMultimap . create ( ) ; 
 
 - for ( Token token : metadata . keySet ( ) ) 
 + for ( Token token : metadata . sortedTokens ( ) ) 
 { 
 - Range range = getPrimaryRangeFor ( token , metadata ) ; 
 + Range range = metadata . getPrimaryRangeFor ( token ) ; 
 for ( InetAddress ep : getNaturalEndpoints ( token , metadata ) ) 
 { 
 map . put ( ep , range ) ; 
 @ @ - 192 , 13 + 182 , 13 @ @ public abstract class AbstractReplicationStrategy 
 return map ; 
 } 
 
 - public Multimap < Range , InetAddress > getRangeAddresses ( Map < Token , InetAddress > metadata ) 
 + public Multimap < Range , InetAddress > getRangeAddresses ( TokenMetadata metadata ) 
 { 
 Multimap < Range , InetAddress > map = HashMultimap . create ( ) ; 
 
 - for ( Token token : metadata . keySet ( ) ) 
 + for ( Token token : metadata . sortedTokens ( ) ) 
 { 
 - Range range = getPrimaryRangeFor ( token , metadata ) ; 
 + Range range = metadata . getPrimaryRangeFor ( token ) ; 
 for ( InetAddress ep : getNaturalEndpoints ( token , metadata ) ) 
 { 
 map . put ( range , ep ) ; 
 @ @ - 210 , 27 + 200 , 6 @ @ public abstract class AbstractReplicationStrategy 
 
 public Multimap < InetAddress , Range > getAddressRanges ( ) 
 { 
 - return getAddressRanges ( tokenMetadata _ . cloneTokenEndPointMap ( ) ) ; 
 - } 
 - 
 - public Range getPrimaryRangeFor ( Token right , Map < Token , InetAddress > tokenToEndPointMap ) 
 - { 
 - return new Range ( getPredecessor ( right , tokenToEndPointMap ) , right ) ; 
 - } 
 - 
 - public Token getPredecessor ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) 
 - { 
 - List tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; 
 - Collections . sort ( tokens ) ; 
 - int index = Collections . binarySearch ( tokens , token ) ; 
 - return ( Token ) ( index = = 0 ? tokens . get ( tokens . size ( ) - 1 ) : tokens . get ( - - index ) ) ; 
 - } 
 - 
 - public Token getSuccessor ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) 
 - { 
 - List tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; 
 - Collections . sort ( tokens ) ; 
 - int index = Collections . binarySearch ( tokens , token ) ; 
 - return ( Token ) ( ( index = = ( tokens . size ( ) - 1 ) ) ? tokens . get ( 0 ) : tokens . get ( + + index ) ) ; 
 + return getAddressRanges ( tokenMetadata _ ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 index e8b30e2 . . 20100b7 100644 
 - - - a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 + + + b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 @ @ - 45 , 10 + 45 , 8 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 / * * 
 * This Method will get the required information of the EndPoint from the 
 * DataCenterEndPointSnitch and poopulates this singleton class . 
 - * 
 - * @ param tokenToEndPointMap - Provided the endpoint map which will be mapped with the DC ' s 
 * / 
 - private synchronized void loadEndPoints ( Map < Token , InetAddress > tokenToEndPointMap , Collection < Token > tokens ) throws IOException 
 + private synchronized void loadEndPoints ( TokenMetadata metadata ) throws IOException 
 { 
 endPointSnitch = ( DatacenterEndPointSnitch ) StorageService . instance ( ) . getEndPointSnitch ( ) ; 
 this . tokens = new ArrayList < Token > ( tokens ) ; 
 @ @ - 56 , 7 + 54 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 dcMap = new HashMap < String , List < Token > > ( ) ; 
 for ( Token token : this . tokens ) 
 { 
 - InetAddress endPoint = tokenToEndPointMap . get ( token ) ; 
 + InetAddress endPoint = metadata . getEndPoint ( token ) ; 
 String dataCenter = endPointSnitch . getLocation ( endPoint ) ; 
 if ( dataCenter . equals ( localDC ) ) 
 { 
 @ @ - 96 , 25 + 94 , 24 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 assert ( DatabaseDescriptor . getEndPointSnitch ( ) instanceof DatacenterEndPointSnitch ) ; 
 } 
 
 - @ Override 
 - public ArrayList < InetAddress > getNaturalEndpoints ( Token searchToken , Map < Token , InetAddress > tokenToEndPointMap ) 
 + public ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) 
 { 
 try 
 { 
 - return getNaturalEndpointsInternal ( searchToken , tokenToEndPointMap ) ; 
 + return getNaturalEndpointsInternal ( token , metadata ) ; 
 } 
 catch ( IOException e ) 
 { 
 - throw new IOError ( e ) ; 
 + throw new IOError ( e ) ; 
 } 
 } 
 
 - private ArrayList < InetAddress > getNaturalEndpointsInternal ( Token searchToken , Map < Token , InetAddress > tokenToEndPointMap ) throws IOException 
 + private ArrayList < InetAddress > getNaturalEndpointsInternal ( Token searchToken , TokenMetadata metadata ) throws IOException 
 { 
 ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( ) ; 
 - if ( null = = tokens | | this . tokens . size ( ) ! = tokenToEndPointMap . keySet ( ) . size ( ) ) 
 + if ( null = = tokens | | tokens . size ( ) ! = metadata . sortedTokens ( ) . size ( ) ) 
 { 
 - loadEndPoints ( tokenToEndPointMap , tokenToEndPointMap . keySet ( ) ) ; 
 + loadEndPoints ( metadata ) ; 
 } 
 
 for ( String dc : dcMap . keySet ( ) ) 
 @ @ - 136 , 7 + 133 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 } 
 int totalNodes = tokens . size ( ) ; 
 / / Add the node at the index by default 
 - InetAddress primaryHost = tokenToEndPointMap . get ( tokens . get ( index ) ) ; 
 + InetAddress primaryHost = metadata . getEndPoint ( ( Token ) tokens . get ( index ) ) ; 
 forloopReturn . add ( primaryHost ) ; 
 foundCount + + ; 
 if ( replicas _ = = 1 ) 
 @ @ - 147 , 7 + 144 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 int startIndex = ( index + 1 ) % totalNodes ; 
 for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) 
 { 
 - InetAddress endPointOfIntrest = tokenToEndPointMap . get ( tokens . get ( i ) ) ; 
 + InetAddress endPointOfIntrest = metadata . getEndPoint ( ( Token ) tokens . get ( i ) ) ; 
 if ( ( replicas _ - 1 ) > foundCount ) 
 { 
 forloopReturn . add ( endPointOfIntrest ) ; 
 @ @ - 163 , 7 + 160 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 { 
 if ( ! endPointSnitch . isOnSameRack ( primaryHost , endPointOfIntrest ) ) 
 { 
 - forloopReturn . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; 
 + forloopReturn . add ( metadata . getEndPoint ( ( Token ) tokens . get ( i ) ) ) ; 
 bOtherRack = true ; 
 foundCount + + ; 
 } 
 @ @ - 182 , 9 + 179 , 10 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 * / 
 for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) 
 { 
 - if ( ! forloopReturn . contains ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ) 
 + Token t = ( Token ) tokens . get ( i ) ; 
 + if ( ! forloopReturn . contains ( metadata . getEndPoint ( t ) ) ) 
 { 
 - forloopReturn . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; 
 + forloopReturn . add ( metadata . getEndPoint ( t ) ) ; 
 foundCount + + ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / RackAwareStrategy . java b / src / java / org / apache / cassandra / locator / RackAwareStrategy . java 
 index 6b1101e . . 62c79b6 100644 
 - - - a / src / java / org / apache / cassandra / locator / RackAwareStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / RackAwareStrategy . java 
 @ @ - 44 , 15 + 44 , 14 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy 
 super ( tokenMetadata , partitioner , replicas , storagePort ) ; 
 } 
 
 - public ArrayList < InetAddress > getNaturalEndpoints ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) 
 + public ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) 
 { 
 int startIndex ; 
 ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( ) ; 
 boolean bDataCenter = false ; 
 boolean bOtherRack = false ; 
 int foundCount = 0 ; 
 - List tokens = new ArrayList ( tokenToEndPointMap . keySet ( ) ) ; 
 - Collections . sort ( tokens ) ; 
 + List tokens = metadata . sortedTokens ( ) ; 
 int index = Collections . binarySearch ( tokens , token ) ; 
 if ( index < 0 ) 
 { 
 @ @ - 62 , 7 + 61 , 8 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy 
 } 
 int totalNodes = tokens . size ( ) ; 
 / / Add the node at the index by default 
 - endpoints . add ( tokenToEndPointMap . get ( tokens . get ( index ) ) ) ; 
 + Token primaryToken = ( Token ) tokens . get ( index ) ; 
 + endpoints . add ( metadata . getEndPoint ( primaryToken ) ) ; 
 foundCount + + ; 
 if ( replicas _ = = 1 ) 
 { 
 @ @ - 70 , 31 + 70 , 32 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy 
 } 
 startIndex = ( index + 1 ) % totalNodes ; 
 IEndPointSnitch endPointSnitch = StorageService . instance ( ) . getEndPointSnitch ( ) ; 
 - 
 - for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) 
 + 
 + for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) 
 { 
 try 
 { 
 / / First try to find one in a different data center 
 - if ( ! endPointSnitch . isInSameDataCenter ( tokenToEndPointMap . get ( tokens . get ( index ) ) , tokenToEndPointMap . get ( tokens . get ( i ) ) ) ) 
 + Token t = ( Token ) tokens . get ( i ) ; 
 + if ( ! endPointSnitch . isInSameDataCenter ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) 
 { 
 / / If we have already found something in a diff datacenter no need to find another 
 - if ( ! bDataCenter ) 
 + if ( ! bDataCenter ) 
 { 
 - endpoints . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; 
 + endpoints . add ( metadata . getEndPoint ( t ) ) ; 
 bDataCenter = true ; 
 foundCount + + ; 
 } 
 continue ; 
 } 
 / / Now try to find one on a different rack 
 - if ( ! endPointSnitch . isOnSameRack ( tokenToEndPointMap . get ( tokens . get ( index ) ) , tokenToEndPointMap . get ( tokens . get ( i ) ) ) & & 
 - endPointSnitch . isInSameDataCenter ( tokenToEndPointMap . get ( tokens . get ( index ) ) , tokenToEndPointMap . get ( tokens . get ( i ) ) ) ) 
 + if ( ! endPointSnitch . isOnSameRack ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) & & 
 + endPointSnitch . isInSameDataCenter ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) 
 { 
 / / If we have already found something in a diff rack no need to find another 
 - if ( ! bOtherRack ) 
 + if ( ! bOtherRack ) 
 { 
 - endpoints . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; 
 + endpoints . add ( metadata . getEndPoint ( t ) ) ; 
 bOtherRack = true ; 
 foundCount + + ; 
 } 
 @ @ - 103 , 7 + 104 , 7 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy 
 catch ( UnknownHostException e ) 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( LogUtil . throwableToString ( e ) ) ; 
 + logger _ . debug ( LogUtil . throwableToString ( e ) ) ; 
 } 
 
 } 
 @ @ - 111 , 9 + 112 , 10 @ @ public class RackAwareStrategy extends AbstractReplicationStrategy 
 / / loop through the list and add until we have N nodes . 
 for ( int i = startIndex , count = 1 ; count < totalNodes & & foundCount < replicas _ ; + + count , i = ( i + 1 ) % totalNodes ) 
 { 
 - if ( ! endpoints . contains ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ) 
 + Token t = ( Token ) tokens . get ( i ) ; 
 + if ( ! endpoints . contains ( metadata . getEndPoint ( t ) ) ) 
 { 
 - endpoints . add ( tokenToEndPointMap . get ( tokens . get ( i ) ) ) ; 
 + endpoints . add ( metadata . getEndPoint ( t ) ) ; 
 foundCount + + ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / RackUnawareStrategy . java b / src / java / org / apache / cassandra / locator / RackUnawareStrategy . java 
 index 10b6fd3 . . 9bc9c90 100644 
 - - - a / src / java / org / apache / cassandra / locator / RackUnawareStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / RackUnawareStrategy . java 
 @ @ - 40 , 15 + 40 , 15 @ @ public class RackUnawareStrategy extends AbstractReplicationStrategy 
 super ( tokenMetadata , partitioner , replicas , storagePort ) ; 
 } 
 
 - public ArrayList < InetAddress > getNaturalEndpoints ( Token token , Map < Token , InetAddress > tokenToEndPointMap ) 
 + / / TODO this doesn ' t need to worry about bootstrap tokens being in the normal tokens map 
 + public ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) 
 { 
 int startIndex ; 
 List < Token > tokenList = new ArrayList < Token > ( ) ; 
 int foundCount = 0 ; 
 - List tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; 
 + List tokens = new ArrayList < Token > ( metadata . sortedTokens ( ) ) ; 
 List < Token > bsTokens = null ; 
 
 - Collections . sort ( tokens ) ; 
 int index = Collections . binarySearch ( tokens , token ) ; 
 if ( index < 0 ) 
 { 
 @ @ - 75 , 8 + 75 , 8 @ @ public class RackUnawareStrategy extends AbstractReplicationStrategy 
 } 
 } 
 ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( tokenList . size ( ) ) ; 
 - for ( Token t : tokenList ) 
 - endpoints . add ( tokenToEndPointMap . get ( t ) ) ; 
 + for ( Token t : tokenList ) 
 + endpoints . add ( metadata . getEndPoint ( t ) ) ; 
 return endpoints ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 index 5cd788d . . 2fdf0b1 100644 
 - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 @ @ - 23 , 6 + 23 , 8 @ @ import java . util . concurrent . locks . ReadWriteLock ; 
 import java . util . concurrent . locks . ReentrantReadWriteLock ; 
 
 import org . apache . cassandra . dht . Token ; 
 + import org . apache . cassandra . dht . Range ; 
 + 
 import java . net . InetAddress ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . gms . FailureDetector ; 
 @ @ - 185 , 85 + 187 , 105 @ @ public class TokenMetadata 
 lock . readLock ( ) . unlock ( ) ; 
 } 
 } 
 - 
 - public Map < Token , InetAddress > cloneBootstrapNodes ( ) 
 + 
 + public TokenMetadata cloneMe ( ) 
 { 
 lock . readLock ( ) . lock ( ) ; 
 try 
 - { 
 - return new HashMap < Token , InetAddress > ( bootstrapTokenMap ) ; 
 + { 
 + return new TokenMetadata ( HashBiMap . create ( tokenToEndPointMap ) , HashBiMap . create ( bootstrapTokenMap ) ) ; 
 } 
 finally 
 { 
 lock . readLock ( ) . unlock ( ) ; 
 } 
 - 
 } 
 
 - / * 
 - * Returns a safe clone of tokenToEndPointMap _ . 
 - * / 
 - public Map < Token , InetAddress > cloneTokenEndPointMap ( ) 
 + public String toString ( ) 
 { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 lock . readLock ( ) . lock ( ) ; 
 try 
 - { 
 - return new HashMap < Token , InetAddress > ( tokenToEndPointMap ) ; 
 + { 
 + Set < InetAddress > eps = tokenToEndPointMap . inverse ( ) . keySet ( ) ; 
 + 
 + for ( InetAddress ep : eps ) 
 + { 
 + sb . append ( ep ) ; 
 + sb . append ( " : " ) ; 
 + sb . append ( tokenToEndPointMap . inverse ( ) . get ( ep ) ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + } 
 } 
 finally 
 { 
 lock . readLock ( ) . unlock ( ) ; 
 } 
 + 
 + return sb . toString ( ) ; 
 } 
 - 
 - / * 
 - * Returns a safe clone of endPointTokenMap _ . 
 - * / 
 - public Map < InetAddress , Token > cloneEndPointTokenMap ( ) 
 + 
 + public InetAddress getEndPoint ( Token token ) 
 { 
 lock . readLock ( ) . lock ( ) ; 
 try 
 - { 
 - return new HashMap < InetAddress , Token > ( tokenToEndPointMap . inverse ( ) ) ; 
 + { 
 + return tokenToEndPointMap . get ( token ) ; 
 } 
 finally 
 { 
 lock . readLock ( ) . unlock ( ) ; 
 } 
 } 
 - 
 - public String toString ( ) 
 + 
 + public void clearUnsafe ( ) 
 { 
 - StringBuilder sb = new StringBuilder ( ) ; 
 - Set < InetAddress > eps = tokenToEndPointMap . inverse ( ) . keySet ( ) ; 
 + tokenToEndPointMap . clear ( ) ; 
 + bootstrapTokenMap . clear ( ) ; 
 + } 
 
 - for ( InetAddress ep : eps ) 
 - { 
 - sb . append ( ep ) ; 
 - sb . append ( " : " ) ; 
 - sb . append ( tokenToEndPointMap . inverse ( ) . get ( ep ) ) ; 
 - sb . append ( System . getProperty ( " line . separator " ) ) ; 
 - } 
 - 
 - return sb . toString ( ) ; 
 + public Range getPrimaryRangeFor ( Token right ) 
 + { 
 + return new Range ( getPredecessor ( right ) , right ) ; 
 } 
 
 - public InetAddress getEndPoint ( Token token ) 
 + public List < Token > sortedTokens ( ) 
 { 
 + List < Token > tokens ; 
 lock . readLock ( ) . lock ( ) ; 
 try 
 { 
 - return tokenToEndPointMap . get ( token ) ; 
 + tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; 
 } 
 finally 
 { 
 lock . readLock ( ) . unlock ( ) ; 
 } 
 + Collections . sort ( tokens ) ; 
 + return tokens ; 
 } 
 
 - public void clearUnsafe ( ) 
 + public Token getPredecessor ( Token token ) 
 { 
 - tokenToEndPointMap . clear ( ) ; 
 - bootstrapTokenMap . clear ( ) ; 
 + List tokens = sortedTokens ( ) ; 
 + int index = Collections . binarySearch ( tokens , token ) ; 
 + return ( Token ) ( index = = 0 ? tokens . get ( tokens . size ( ) - 1 ) : tokens . get ( - - index ) ) ; 
 + } 
 + 
 + public Token getSuccessor ( Token token ) 
 + { 
 + List tokens = sortedTokens ( ) ; 
 + int index = Collections . binarySearch ( tokens , token ) ; 
 + return ( Token ) ( ( index = = ( tokens . size ( ) - 1 ) ) ? tokens . get ( 0 ) : tokens . get ( + + index ) ) ; 
 + } 
 + 
 + public Iterable < ? extends Token > bootstrapTokens ( ) 
 + { 
 + return bootstrapTokenMap . keySet ( ) ; 
 + } 
 + 
 + public InetAddress getBootstrapEndpoint ( Token token ) 
 + { 
 + return bootstrapTokenMap . get ( token ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraServer . java b / src / java / org / apache / cassandra / service / CassandraServer . java 
 index 235ff9b . . bbb4c98 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraServer . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraServer . java 
 @ @ - 508 , 11 + 508 , 7 @ @ public class CassandraServer implements Cassandra . Iface 
 } 
 else if ( propertyName . equals ( TOKEN _ MAP ) ) 
 { 
 - HashMap < String , String > tokenToHostMap = new HashMap < String , String > ( ) ; 
 - Map < Token , InetAddress > endpointMap = storageService . getLiveEndPointMap ( ) ; 
 - for ( Map . Entry < Token , InetAddress > e : endpointMap . entrySet ( ) ) 
 - tokenToHostMap . put ( e . getKey ( ) . toString ( ) , e . getValue ( ) . getHostAddress ( ) ) ; 
 - return new JSONSerializer ( ) . serialize ( tokenToHostMap ) ; 
 + return new JSONSerializer ( ) . serialize ( storageService . getStringEndpointMap ( ) ) ; 
 } 
 else if ( propertyName . equals ( " version " ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 7c49711 . . 3c84091 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 281 , 7 + 281 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 } 
 setAndBroadcastToken ( storageMetadata _ . getToken ( ) ) ; 
 
 - assert tokenMetadata _ . cloneTokenEndPointMap ( ) . size ( ) > 0 ; 
 + assert tokenMetadata _ . sortedTokens ( ) . size ( ) > 0 ; 
 } 
 
 public boolean isBootstrapMode ( ) 
 @ @ - 322 , 10 + 322 , 8 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 
 public Map < Range , List < String > > getRangeToEndPointMap ( ) 
 { 
 - / * Get the token to endpoint map . * / 
 - Map < Token , InetAddress > tokenToEndPointMap = tokenMetadata _ . cloneTokenEndPointMap ( ) ; 
 / * All the ranges for the tokens * / 
 - Range [ ] ranges = getAllRanges ( tokenToEndPointMap . keySet ( ) ) ; 
 + List < Range > ranges = getAllRanges ( tokenMetadata _ . sortedTokens ( ) ) ; 
 Map < Range , List < String > > map = new HashMap < Range , List < String > > ( ) ; 
 for ( Map . Entry < Range , List < InetAddress > > entry : constructRangeToEndPointMap ( ranges ) . entrySet ( ) ) 
 { 
 @ @ - 340 , 7 + 338 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 * @ param ranges 
 * @ return mapping of ranges to the replicas responsible for them . 
 * / 
 - public Map < Range , List < InetAddress > > constructRangeToEndPointMap ( Range [ ] ranges ) 
 + public Map < Range , List < InetAddress > > constructRangeToEndPointMap ( List < Range > ranges ) 
 { 
 Map < Range , List < InetAddress > > rangeToEndPointMap = new HashMap < Range , List < InetAddress > > ( ) ; 
 for ( Range range : ranges ) 
 @ @ - 349 , 27 + 347 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 } 
 return rangeToEndPointMap ; 
 } 
 - 
 - / * * 
 - * Construct the range to endpoint mapping based on the view as dictated 
 - * by the mapping of token to endpoints passed in . 
 - * @ param ranges 
 - * @ param tokenToEndPointMap mapping of token to endpoints . 
 - * @ return mapping of ranges to the replicas responsible for them . 
 - * / 
 - public Map < Range , List < InetAddress > > constructRangeToEndPointMap ( Range [ ] ranges , Map < Token , InetAddress > tokenToEndPointMap ) 
 - { 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " Constructing range to endpoint map . . . " ) ; 
 - Map < Range , List < InetAddress > > rangeToEndPointMap = new HashMap < Range , List < InetAddress > > ( ) ; 
 - for ( Range range : ranges ) 
 - { 
 - rangeToEndPointMap . put ( range , replicationStrategy _ . getNaturalEndpoints ( range . right ( ) , tokenToEndPointMap ) ) ; 
 - } 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " Done constructing range to endpoint map . . . " ) ; 
 - return rangeToEndPointMap ; 
 - } 
 
 / * * 
 * Called when there is a change in application state . In particular 
 @ @ - 643 , 7 + 620 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 InetAddress getPredecessor ( InetAddress ep ) 
 { 
 Token token = tokenMetadata _ . getToken ( ep ) ; 
 - return tokenMetadata _ . getEndPoint ( replicationStrategy _ . getPredecessor ( token , tokenMetadata _ . cloneTokenEndPointMap ( ) ) ) ; 
 + return tokenMetadata _ . getEndPoint ( tokenMetadata _ . getPredecessor ( token ) ) ; 
 } 
 
 / * 
 @ @ - 653 , 7 + 630 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 public InetAddress getSuccessor ( InetAddress ep ) 
 { 
 Token token = tokenMetadata _ . getToken ( ep ) ; 
 - return tokenMetadata _ . getEndPoint ( replicationStrategy _ . getSuccessor ( token , tokenMetadata _ . cloneTokenEndPointMap ( ) ) ) ; 
 + return tokenMetadata _ . getEndPoint ( tokenMetadata _ . getSuccessor ( token ) ) ; 
 } 
 
 / * * 
 @ @ - 663 , 8 + 640 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 * / 
 public Range getPrimaryRangeForEndPoint ( InetAddress ep ) 
 { 
 - Token right = tokenMetadata _ . getToken ( ep ) ; 
 - return replicationStrategy _ . getPrimaryRangeFor ( right , tokenMetadata _ . cloneTokenEndPointMap ( ) ) ; 
 + return tokenMetadata _ . getPrimaryRangeFor ( tokenMetadata _ . getToken ( ep ) ) ; 
 } 
 
 / * * 
 @ @ - 683 , 22 + 659 , 23 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 * ranges . 
 * @ return ranges in sorted order 
 * / 
 - public Range [ ] getAllRanges ( Set < Token > tokens ) 
 + public List < Range > getAllRanges ( List < Token > sortedTokens ) 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " computing ranges for " + StringUtils . join ( tokens , " , " ) ) ; 
 + logger _ . debug ( " computing ranges for " + StringUtils . join ( sortedTokens , " , " ) ) ; 
 + 
 List < Range > ranges = new ArrayList < Range > ( ) ; 
 - List < Token > allTokens = new ArrayList < Token > ( tokens ) ; 
 - Collections . sort ( allTokens ) ; 
 - int size = allTokens . size ( ) ; 
 - for ( int i = 1 ; i < size ; + + i ) 
 + Collections . sort ( sortedTokens ) ; 
 + int size = sortedTokens . size ( ) ; 
 + for ( int i = 1 ; i < size ; + + i ) 
 { 
 - Range range = new Range ( allTokens . get ( i - 1 ) , allTokens . get ( i ) ) ; 
 + Range range = new Range ( sortedTokens . get ( i - 1 ) , sortedTokens . get ( i ) ) ; 
 ranges . add ( range ) ; 
 } 
 - Range range = new Range ( allTokens . get ( size - 1 ) , allTokens . get ( 0 ) ) ; 
 + Range range = new Range ( sortedTokens . get ( size - 1 ) , sortedTokens . get ( 0 ) ) ; 
 ranges . add ( range ) ; 
 - return ranges . toArray ( new Range [ 0 ] ) ; 
 + 
 + return ranges ; 
 } 
 
 / * * 
 @ @ - 712 , 11 + 689 , 9 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 { 
 InetAddress endpoint = FBUtilities . getLocalAddress ( ) ; 
 Token token = partitioner _ . getToken ( key ) ; 
 - Map < Token , InetAddress > tokenToEndPointMap = tokenMetadata _ . cloneTokenEndPointMap ( ) ; 
 - List tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; 
 + List tokens = new ArrayList < Token > ( tokenMetadata _ . sortedTokens ( ) ) ; 
 if ( tokens . size ( ) > 0 ) 
 { 
 - Collections . sort ( tokens ) ; 
 int index = Collections . binarySearch ( tokens , token ) ; 
 if ( index > = 0 ) 
 { 
 @ @ - 724 , 15 + 699 , 15 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 * retrieve the endpoint based on the token at this index in the 
 * tokens list 
 * / 
 - endpoint = tokenToEndPointMap . get ( tokens . get ( index ) ) ; 
 + endpoint = tokenMetadata _ . getEndPoint ( ( Token ) tokens . get ( index ) ) ; 
 } 
 else 
 { 
 index = ( index + 1 ) * ( - 1 ) ; 
 if ( index < tokens . size ( ) ) 
 - endpoint = tokenToEndPointMap . get ( tokens . get ( index ) ) ; 
 + endpoint = tokenMetadata _ . getEndPoint ( ( Token ) tokens . get ( index ) ) ; 
 else 
 - endpoint = tokenToEndPointMap . get ( tokens . get ( 0 ) ) ; 
 + endpoint = tokenMetadata _ . getEndPoint ( ( Token ) tokens . get ( 0 ) ) ; 
 } 
 } 
 return endpoint ; 
 @ @ - 834 , 9 + 809 , 14 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 throw new UnavailableException ( ) ; / / no nodes that could contain key are alive 
 } 
 
 - Map < Token , InetAddress > getLiveEndPointMap ( ) 
 + Map < String , String > getStringEndpointMap ( ) 
 { 
 - return tokenMetadata _ . cloneTokenEndPointMap ( ) ; 
 + HashMap < String , String > map = new HashMap < String , String > ( ) ; 
 + for ( Token t : tokenMetadata _ . sortedTokens ( ) ) 
 + { 
 + map . put ( t . toString ( ) , tokenMetadata _ . getEndPoint ( t ) . getHostAddress ( ) ) ; 
 + } 
 + return map ; 
 } 
 
 public void setLog4jLevel ( String classQualifier , String rawLevel ) 
 diff - - git a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 index d8d67a0 . . ad6c5d5 100644 
 - - - a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 + + + b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 @ @ - 54 , 7 + 54 , 7 @ @ public class BootStrapperTest { 
 InetAddress myEndpoint = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; 
 
 TokenMetadata tmd = ss . getTokenMetadata ( ) ; 
 - assertEquals ( numOldNodes , tmd . cloneTokenEndPointMap ( ) . size ( ) ) ; 
 + assertEquals ( numOldNodes , tmd . sortedTokens ( ) . size ( ) ) ; 
 BootStrapper b = new BootStrapper ( ss . getReplicationStrategy ( ) , myEndpoint , myToken , tmd ) ; 
 Multimap < Range , InetAddress > res = b . getRangesWithSources ( ) ; 

