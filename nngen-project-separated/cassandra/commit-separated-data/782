BLEU SCORE: 0.02383853510228548

TEST MSG: Fix filtering on clustering columns when 2i is used
GENERATED MSG: Allow only DISTINCT queries with partition keys restrictions

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3aa5ea9 . . 0967ce4 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 16 <nl> + * Fix filtering on clustering columns when 2i is used ( CASSANDRA - 11907 ) <nl> * Reduce contention getting instances of CompositeType ( CASSANDRA - 10433 ) <nl> <nl> 2 . 1 . 15 <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 6351bb5 . . 245e64e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 1582 , 6 + 1582 , 7 @ @ public class SelectStatement implements CQLStatement <nl> <nl> int numberOfRestrictionsEvaluatedWithSlices = 0 ; <nl> <nl> + Restriction lastSliceRestriction = null ; <nl> for ( ColumnDefinition def : cfm . clusteringColumns ( ) ) <nl> { <nl> / / Remove clustering column restrictions that can be handled by slices ; the remainder will be <nl> @ @ - 1589 , 10 + 1590 , 17 @ @ public class SelectStatement implements CQLStatement <nl> Boolean indexed = stmt . restrictedColumns . get ( def ) ; <nl> if ( indexed = = null ) <nl> break ; <nl> - if ( ! ( indexed & & stmt . usesSecondaryIndexing ) & & stmt . columnRestrictions [ def . position ( ) ] . canEvaluateWithSlices ( ) ) <nl> + <nl> + Restriction restriction = stmt . columnRestrictions [ def . position ( ) ] ; <nl> + if ( lastSliceRestriction ! = null & & ! restriction . equals ( lastSliceRestriction ) ) <nl> + break ; <nl> + <nl> + if ( ! ( indexed & & stmt . usesSecondaryIndexing ) & & restriction . canEvaluateWithSlices ( ) ) <nl> { <nl> stmt . restrictedColumns . remove ( def ) ; <nl> numberOfRestrictionsEvaluatedWithSlices + + ; <nl> + if ( restriction . isSlice ( ) ) <nl> + lastSliceRestriction = restriction ; <nl> } <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> index 6acab6f . . 68cf6f8 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> @ @ - 1264 , 4 + 1264 , 68 @ @ public class SelectTest extends CQLTester <nl> " SELECT * FROM % s WHERE a = ' foo ' AND b = ' bar ' AND c IN ( ? , ? ) " , <nl> new String ( TOO _ BIG . array ( ) ) , new String ( TOO _ BIG . array ( ) ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testFilteringWithSecondaryIndex ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( pk int , " + <nl> + " c1 int , " + <nl> + " c2 int , " + <nl> + " c3 int , " + <nl> + " v int , " + <nl> + " PRIMARY KEY ( pk , c1 , c2 , c3 ) ) " ) ; <nl> + createIndex ( " CREATE INDEX v _ idx _ 1 ON % s ( v ) ; " ) ; <nl> + <nl> + for ( int i = 1 ; i < = 5 ; i + + ) <nl> + { <nl> + execute ( " INSERT INTO % s ( pk , c1 , c2 , c3 , v ) VALUES ( ? , ? , ? , ? , ? ) " , 1 , 1 , 1 , 1 , i ) ; <nl> + execute ( " INSERT INTO % s ( pk , c1 , c2 , c3 , v ) VALUES ( ? , ? , ? , ? , ? ) " , 1 , 1 , 1 , i , i ) ; <nl> + execute ( " INSERT INTO % s ( pk , c1 , c2 , c3 , v ) VALUES ( ? , ? , ? , ? , ? ) " , 1 , 1 , i , i , i ) ; <nl> + execute ( " INSERT INTO % s ( pk , c1 , c2 , c3 , v ) VALUES ( ? , ? , ? , ? , ? ) " , 1 , i , i , i , i ) ; <nl> + } <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 AND c1 > 0 AND c1 < 5 AND c2 = 1 AND v = 3 ALLOW FILTERING ; " ) , <nl> + row ( 1 , 1 , 1 , 3 , 3 ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE pk = 1 AND c1 > 1 AND c1 < 5 AND c2 = 1 AND v = 3 ALLOW FILTERING ; " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 AND c1 > 1 AND c2 > 2 AND c3 > 2 AND v = 3 ALLOW FILTERING ; " ) , <nl> + row ( 1 , 3 , 3 , 3 , 3 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 AND c1 > 1 AND c2 > 2 AND c3 = 3 AND v = 3 ALLOW FILTERING ; " ) , <nl> + row ( 1 , 3 , 3 , 3 , 3 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 AND ( c1 , c2 ) > ( 1 , 3 ) AND c3 = 3 AND v = 3 ALLOW FILTERING ; " ) , <nl> + row ( 1 , 3 , 3 , 3 , 3 ) ) ; <nl> + <nl> + assertInvalidMessage ( " Clustering column \ " c1 \ " cannot be restricted by an IN relation " , <nl> + " SELECT * FROM % s WHERE pk = 1 AND c1 IN ( 0 , 1 , 2 ) AND c2 = 1 AND v = 3 ALLOW FILTERING ; " ) ; <nl> + <nl> + assertInvalidMessage ( " Clustering column \ " c1 \ " cannot be restricted by an IN relation " , <nl> + " SELECT * FROM % s WHERE pk = 1 AND c1 IN ( 0 , 1 , 2 ) AND c2 = 1 AND v = 3 " ) ; <nl> + <nl> + assertInvalidMessage ( " PRIMARY KEY column \ " c2 \ " cannot be restricted ( preceding column \ " c1 \ " is restricted by a non - EQ relation ) " , <nl> + " SELECT * FROM % s WHERE pk = 1 AND c1 > 0 AND c1 < 5 AND c2 = 1 ALLOW FILTERING ; " ) ; <nl> + <nl> + assertInvalidMessage ( " PRIMARY KEY column \ " c2 \ " cannot be restricted ( preceding column \ " c1 \ " is not restricted ) " , <nl> + " SELECT * FROM % s WHERE pk = 1 AND c2 = 1 ALLOW FILTERING ; " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testIndexQueryWithCompositePartitionKey ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( p1 int , p2 int , v int , PRIMARY KEY ( ( p1 , p2 ) ) ) " ) ; <nl> + assertInvalidMessage ( " Partition key part p2 must be restricted since preceding part is " , <nl> + " SELECT * FROM % s WHERE p1 = 1 AND v = 3 ALLOW FILTERING " ) ; <nl> + <nl> + createIndex ( " CREATE INDEX ON % s ( v ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( p1 , p2 , v ) values ( ? , ? , ? ) " , 1 , 1 , 3 ) ; <nl> + execute ( " INSERT INTO % s ( p1 , p2 , v ) values ( ? , ? , ? ) " , 1 , 2 , 3 ) ; <nl> + execute ( " INSERT INTO % s ( p1 , p2 , v ) values ( ? , ? , ? ) " , 2 , 1 , 3 ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE p1 = 1 AND v = 3 ALLOW FILTERING " ) , <nl> + row ( 1 , 2 , 3 ) , <nl> + row ( 1 , 1 , 3 ) ) ; <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3aa5ea9 . . 0967ce4 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 16 
 + * Fix filtering on clustering columns when 2i is used ( CASSANDRA - 11907 ) 
 * Reduce contention getting instances of CompositeType ( CASSANDRA - 10433 ) 
 
 2 . 1 . 15 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 6351bb5 . . 245e64e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 1582 , 6 + 1582 , 7 @ @ public class SelectStatement implements CQLStatement 
 
 int numberOfRestrictionsEvaluatedWithSlices = 0 ; 
 
 + Restriction lastSliceRestriction = null ; 
 for ( ColumnDefinition def : cfm . clusteringColumns ( ) ) 
 { 
 / / Remove clustering column restrictions that can be handled by slices ; the remainder will be 
 @ @ - 1589 , 10 + 1590 , 17 @ @ public class SelectStatement implements CQLStatement 
 Boolean indexed = stmt . restrictedColumns . get ( def ) ; 
 if ( indexed = = null ) 
 break ; 
 - if ( ! ( indexed & & stmt . usesSecondaryIndexing ) & & stmt . columnRestrictions [ def . position ( ) ] . canEvaluateWithSlices ( ) ) 
 + 
 + Restriction restriction = stmt . columnRestrictions [ def . position ( ) ] ; 
 + if ( lastSliceRestriction ! = null & & ! restriction . equals ( lastSliceRestriction ) ) 
 + break ; 
 + 
 + if ( ! ( indexed & & stmt . usesSecondaryIndexing ) & & restriction . canEvaluateWithSlices ( ) ) 
 { 
 stmt . restrictedColumns . remove ( def ) ; 
 numberOfRestrictionsEvaluatedWithSlices + + ; 
 + if ( restriction . isSlice ( ) ) 
 + lastSliceRestriction = restriction ; 
 } 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 index 6acab6f . . 68cf6f8 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 @ @ - 1264 , 4 + 1264 , 68 @ @ public class SelectTest extends CQLTester 
 " SELECT * FROM % s WHERE a = ' foo ' AND b = ' bar ' AND c IN ( ? , ? ) " , 
 new String ( TOO _ BIG . array ( ) ) , new String ( TOO _ BIG . array ( ) ) ) ; 
 } 
 + 
 + @ Test 
 + public void testFilteringWithSecondaryIndex ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( pk int , " + 
 + " c1 int , " + 
 + " c2 int , " + 
 + " c3 int , " + 
 + " v int , " + 
 + " PRIMARY KEY ( pk , c1 , c2 , c3 ) ) " ) ; 
 + createIndex ( " CREATE INDEX v _ idx _ 1 ON % s ( v ) ; " ) ; 
 + 
 + for ( int i = 1 ; i < = 5 ; i + + ) 
 + { 
 + execute ( " INSERT INTO % s ( pk , c1 , c2 , c3 , v ) VALUES ( ? , ? , ? , ? , ? ) " , 1 , 1 , 1 , 1 , i ) ; 
 + execute ( " INSERT INTO % s ( pk , c1 , c2 , c3 , v ) VALUES ( ? , ? , ? , ? , ? ) " , 1 , 1 , 1 , i , i ) ; 
 + execute ( " INSERT INTO % s ( pk , c1 , c2 , c3 , v ) VALUES ( ? , ? , ? , ? , ? ) " , 1 , 1 , i , i , i ) ; 
 + execute ( " INSERT INTO % s ( pk , c1 , c2 , c3 , v ) VALUES ( ? , ? , ? , ? , ? ) " , 1 , i , i , i , i ) ; 
 + } 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 AND c1 > 0 AND c1 < 5 AND c2 = 1 AND v = 3 ALLOW FILTERING ; " ) , 
 + row ( 1 , 1 , 1 , 3 , 3 ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE pk = 1 AND c1 > 1 AND c1 < 5 AND c2 = 1 AND v = 3 ALLOW FILTERING ; " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 AND c1 > 1 AND c2 > 2 AND c3 > 2 AND v = 3 ALLOW FILTERING ; " ) , 
 + row ( 1 , 3 , 3 , 3 , 3 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 AND c1 > 1 AND c2 > 2 AND c3 = 3 AND v = 3 ALLOW FILTERING ; " ) , 
 + row ( 1 , 3 , 3 , 3 , 3 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 AND ( c1 , c2 ) > ( 1 , 3 ) AND c3 = 3 AND v = 3 ALLOW FILTERING ; " ) , 
 + row ( 1 , 3 , 3 , 3 , 3 ) ) ; 
 + 
 + assertInvalidMessage ( " Clustering column \ " c1 \ " cannot be restricted by an IN relation " , 
 + " SELECT * FROM % s WHERE pk = 1 AND c1 IN ( 0 , 1 , 2 ) AND c2 = 1 AND v = 3 ALLOW FILTERING ; " ) ; 
 + 
 + assertInvalidMessage ( " Clustering column \ " c1 \ " cannot be restricted by an IN relation " , 
 + " SELECT * FROM % s WHERE pk = 1 AND c1 IN ( 0 , 1 , 2 ) AND c2 = 1 AND v = 3 " ) ; 
 + 
 + assertInvalidMessage ( " PRIMARY KEY column \ " c2 \ " cannot be restricted ( preceding column \ " c1 \ " is restricted by a non - EQ relation ) " , 
 + " SELECT * FROM % s WHERE pk = 1 AND c1 > 0 AND c1 < 5 AND c2 = 1 ALLOW FILTERING ; " ) ; 
 + 
 + assertInvalidMessage ( " PRIMARY KEY column \ " c2 \ " cannot be restricted ( preceding column \ " c1 \ " is not restricted ) " , 
 + " SELECT * FROM % s WHERE pk = 1 AND c2 = 1 ALLOW FILTERING ; " ) ; 
 + } 
 + 
 + @ Test 
 + public void testIndexQueryWithCompositePartitionKey ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( p1 int , p2 int , v int , PRIMARY KEY ( ( p1 , p2 ) ) ) " ) ; 
 + assertInvalidMessage ( " Partition key part p2 must be restricted since preceding part is " , 
 + " SELECT * FROM % s WHERE p1 = 1 AND v = 3 ALLOW FILTERING " ) ; 
 + 
 + createIndex ( " CREATE INDEX ON % s ( v ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( p1 , p2 , v ) values ( ? , ? , ? ) " , 1 , 1 , 3 ) ; 
 + execute ( " INSERT INTO % s ( p1 , p2 , v ) values ( ? , ? , ? ) " , 1 , 2 , 3 ) ; 
 + execute ( " INSERT INTO % s ( p1 , p2 , v ) values ( ? , ? , ? ) " , 2 , 1 , 3 ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE p1 = 1 AND v = 3 ALLOW FILTERING " ) , 
 + row ( 1 , 2 , 3 ) , 
 + row ( 1 , 1 , 3 ) ) ; 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
