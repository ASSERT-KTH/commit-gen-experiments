BLEU SCORE: 0.06220117374063391

TEST MSG: Fix News . txt
GENERATED MSG: upgradesstables recommended for # 4436

TEST DIFF (one line): diff - - git a / NEWS . txt b / NEWS . txt <nl> index de535ef . . 61ce546 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 21 , 6 + 21 , 14 @ @ Upgrading <nl> - Nothing specific to this release , but please see 2 . 1 if you are upgrading <nl> from a previous version . <nl> <nl> + 2 . 1 . 1 <nl> + = = = = = <nl> + <nl> + Upgrading <nl> + - - - - - - - - - <nl> + - Nothing specific to this release , but please see 2 . 1 if you are upgrading <nl> + from a previous version . <nl> + <nl> New features <nl> - - - - - - - - - - - - <nl> - Netty support for epoll on linux is now enabled . If for some
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 426ac7d . . 8fe1770 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 38 , 6 + 38 , 7 @ @ <nl> * ( cql3 ) Add support for 2ndary indexes ( CASSANDRA - 3680 ) <nl> * ( cql3 ) fix defining more than one PK to be invalid ( CASSANDRA - 4477 ) <nl> * remove schema agreement checking from all external APIs ( Thrift , CQL and CQL3 ) ( CASSANDRA - 4487 ) <nl> + * add Murmur3Partitioner and make it default for new installations ( CASSANDRA - 3772 ) <nl> <nl> <nl> 1 . 1 . 5 <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 1b89b2e . . 5e45961 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 70 , 6 + 70 , 8 @ @ authority : org . apache . cassandra . auth . AllowAllAuthority <nl> # <nl> # - RandomPartitioner distributes rows across the cluster evenly by md5 . <nl> # When in doubt , this is the best option . <nl> + # - Murmur3Partitioner is similar to RandomPartioner but uses Murmur3 _ 128 <nl> + # Hash Function instead of md5 <nl> # - ByteOrderedPartitioner orders rows lexically by key bytes . BOP allows <nl> # scanning rows in key order , but the ordering can generate hot spots <nl> # for sequential insertion workloads . <nl> @ @ - 81 , 7 + 83 , 7 @ @ authority : org . apache . cassandra . auth . AllowAllAuthority <nl> # <nl> # See http : / / wiki . apache . org / cassandra / Operations for more on <nl> # partitioners and token selection . <nl> - partitioner : org . apache . cassandra . dht . RandomPartitioner <nl> + partitioner : org . apache . cassandra . dht . Murmur3Partitioner <nl> <nl> # directories where Cassandra should store data on disk . <nl> data _ file _ directories : <nl> diff - - git a / src / java / org / apache / cassandra / dht / AbstractHashedPartitioner . java b / src / java / org / apache / cassandra / dht / AbstractHashedPartitioner . java <nl> new file mode 100644 <nl> index 0000000 . . 55dfb97 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / dht / AbstractHashedPartitioner . java <nl> @ @ - 0 , 0 + 1 , 194 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . dht ; <nl> + <nl> + import java . math . BigDecimal ; <nl> + import java . math . BigInteger ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . nio . charset . CharacterCodingException ; <nl> + import java . util . * ; <nl> + <nl> + import org . apache . cassandra . config . ConfigurationException ; <nl> + import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . GuidGenerator ; <nl> + import org . apache . cassandra . utils . Pair ; <nl> + <nl> + / * * <nl> + * This class is the super class of classes that generate a BigIntegerToken using hash function . <nl> + * / <nl> + public abstract class AbstractHashedPartitioner extends AbstractPartitioner < BigIntegerToken > <nl> + { <nl> + public static final BigInteger ZERO = new BigInteger ( " 0 " ) ; <nl> + public static final BigIntegerToken MINIMUM = new BigIntegerToken ( " - 1 " ) ; <nl> + public static final BigInteger MAXIMUM = new BigInteger ( " 2 " ) . pow ( 127 ) ; <nl> + <nl> + private static final byte DELIMITER _ BYTE = " : " . getBytes ( ) [ 0 ] ; <nl> + <nl> + / * * <nl> + * returns a hash of the byte buffer in the range of 0 - 2 * * 127 as a BigInteger <nl> + * <nl> + * @ param buffer the buffer to hash <nl> + * @ return the BigInteger hash value <nl> + * / <nl> + protected abstract BigInteger hash ( ByteBuffer buffer ) ; <nl> + <nl> + public DecoratedKey decorateKey ( ByteBuffer key ) <nl> + { <nl> + return new DecoratedKey ( getToken ( key ) , key ) ; <nl> + } <nl> + <nl> + public DecoratedKey convertFromDiskFormat ( ByteBuffer fromdisk ) <nl> + { <nl> + / / find the delimiter position <nl> + int splitPoint = - 1 ; <nl> + for ( int i = fromdisk . position ( ) ; i < fromdisk . limit ( ) ; i + + ) <nl> + { <nl> + if ( fromdisk . get ( i ) = = DELIMITER _ BYTE ) <nl> + { <nl> + splitPoint = i ; <nl> + break ; <nl> + } <nl> + } <nl> + assert splitPoint ! = - 1 ; <nl> + <nl> + / / and decode the token and key <nl> + String token = null ; <nl> + try <nl> + { <nl> + token = ByteBufferUtil . string ( fromdisk , fromdisk . position ( ) , splitPoint - fromdisk . position ( ) ) ; <nl> + } <nl> + catch ( CharacterCodingException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + ByteBuffer key = fromdisk . duplicate ( ) ; <nl> + key . position ( splitPoint + 1 ) ; <nl> + return new DecoratedKey ( new BigIntegerToken ( token ) , key ) ; <nl> + } <nl> + <nl> + public Token midpoint ( Token ltoken , Token rtoken ) <nl> + { <nl> + / / the symbolic MINIMUM token should act as ZERO : the empty bit array <nl> + BigInteger left = ltoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) ltoken ) . token ; <nl> + BigInteger right = rtoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) rtoken ) . token ; <nl> + Pair < BigInteger , Boolean > midpair = FBUtilities . midpoint ( left , right , 127 ) ; <nl> + / / discard the remainder <nl> + return new BigIntegerToken ( midpair . left ) ; <nl> + } <nl> + <nl> + public BigIntegerToken getMinimumToken ( ) <nl> + { <nl> + return MINIMUM ; <nl> + } <nl> + <nl> + public BigIntegerToken getRandomToken ( ) <nl> + { <nl> + BigInteger token = hash ( GuidGenerator . guidAsBytes ( ) ) ; <nl> + if ( token . signum ( ) = = - 1 ) <nl> + token = token . multiply ( BigInteger . valueOf ( - 1L ) ) ; <nl> + return new BigIntegerToken ( token ) ; <nl> + } <nl> + <nl> + private final Token . TokenFactory < BigInteger > tokenFactory = new Token . TokenFactory < BigInteger > ( ) { <nl> + public ByteBuffer toByteArray ( Token < BigInteger > bigIntegerToken ) <nl> + { <nl> + return ByteBuffer . wrap ( bigIntegerToken . token . toByteArray ( ) ) ; <nl> + } <nl> + <nl> + public Token < BigInteger > fromByteArray ( ByteBuffer bytes ) <nl> + { <nl> + return new BigIntegerToken ( new BigInteger ( ByteBufferUtil . getArray ( bytes ) ) ) ; <nl> + } <nl> + <nl> + public String toString ( Token < BigInteger > bigIntegerToken ) <nl> + { <nl> + return bigIntegerToken . token . toString ( ) ; <nl> + } <nl> + <nl> + public void validate ( String token ) throws ConfigurationException <nl> + { <nl> + try <nl> + { <nl> + BigInteger i = new BigInteger ( token ) ; <nl> + if ( i . compareTo ( ZERO ) < 0 ) <nl> + throw new ConfigurationException ( " Token must be > = 0 " ) ; <nl> + if ( i . compareTo ( MAXIMUM ) > 0 ) <nl> + throw new ConfigurationException ( " Token must be < = 2 * * 127 " ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new ConfigurationException ( e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + public Token < BigInteger > fromString ( String string ) <nl> + { <nl> + return new BigIntegerToken ( new BigInteger ( string ) ) ; <nl> + } <nl> + } ; <nl> + <nl> + public Token . TokenFactory < BigInteger > getTokenFactory ( ) <nl> + { <nl> + return tokenFactory ; <nl> + } <nl> + <nl> + public boolean preservesOrder ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + public BigIntegerToken getToken ( ByteBuffer key ) <nl> + { <nl> + if ( key . remaining ( ) = = 0 ) <nl> + return MINIMUM ; <nl> + return new BigIntegerToken ( hash ( key ) ) ; <nl> + } <nl> + <nl> + public Map < Token , Float > describeOwnership ( List < Token > sortedTokens ) <nl> + { <nl> + Map < Token , Float > ownerships = new HashMap < Token , Float > ( ) ; <nl> + Iterator i = sortedTokens . iterator ( ) ; <nl> + <nl> + / / 0 - case <nl> + if ( ! i . hasNext ( ) ) { throw new RuntimeException ( " No nodes present in the cluster . How did you call this ? " ) ; } <nl> + / / 1 - case <nl> + if ( sortedTokens . size ( ) = = 1 ) { <nl> + ownerships . put ( ( Token ) i . next ( ) , new Float ( 1 . 0 ) ) ; <nl> + } <nl> + / / n - case <nl> + else { <nl> + / / NOTE : All divisions must take place in BigDecimals , and all modulo operators must take place in BigIntegers . <nl> + final BigInteger ri = MAXIMUM ; / / ( used for addition later ) <nl> + final BigDecimal r = new BigDecimal ( ri ) ; / / The entire range , 2 * * 127 <nl> + Token start = ( Token ) i . next ( ) ; BigInteger ti = ( ( BigIntegerToken ) start ) . token ; / / The first token and its value <nl> + Token t ; BigInteger tim1 = ti ; / / The last token and its value ( after loop ) <nl> + while ( i . hasNext ( ) ) { <nl> + t = ( Token ) i . next ( ) ; ti = ( ( BigIntegerToken ) t ) . token ; / / The next token and its value <nl> + float x = new BigDecimal ( ti . subtract ( tim1 ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; / / % age = ( ( T ( i ) - T ( i - 1 ) + R ) % R ) / R <nl> + ownerships . put ( t , x ) ; / / save ( T ( i ) - > % age ) <nl> + tim1 = ti ; / / - > advance loop <nl> + } <nl> + / / The start token ' s range extends backward to the last token , which is why both were saved above . <nl> + float x = new BigDecimal ( ( ( BigIntegerToken ) start ) . token . subtract ( ti ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; <nl> + ownerships . put ( start , x ) ; <nl> + } <nl> + return ownerships ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / dht / Murmur3Partitioner . java b / src / java / org / apache / cassandra / dht / Murmur3Partitioner . java <nl> new file mode 100644 <nl> index 0000000 . . 775cef9 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / dht / Murmur3Partitioner . java <nl> @ @ - 0 , 0 + 1 , 53 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . dht ; <nl> + <nl> + import java . math . BigInteger ; <nl> + import java . nio . ByteBuffer ; <nl> + <nl> + import org . apache . cassandra . utils . MurmurHash ; <nl> + <nl> + / * * <nl> + * This class generates a BigIntegerToken using a Murmur3 hash . <nl> + * / <nl> + public class Murmur3Partitioner extends AbstractHashedPartitioner <nl> + { <nl> + protected BigInteger hash ( ByteBuffer buffer ) <nl> + { <nl> + long [ ] bufferHash = MurmurHash . hash3 _ x64 _ 128 ( buffer , buffer . position ( ) , buffer . remaining ( ) , 0 ) ; <nl> + byte [ ] hashBytes = new byte [ 16 ] ; <nl> + <nl> + writeLong ( bufferHash [ 0 ] , hashBytes , 0 ) ; <nl> + writeLong ( bufferHash [ 1 ] , hashBytes , 8 ) ; <nl> + / / make sure it ' s positive , this isn ' t the same as abs ( ) but doesn ' t effect distribution <nl> + hashBytes [ 0 ] = ( byte ) ( hashBytes [ 0 ] & 0x7F ) ; <nl> + return new BigInteger ( hashBytes ) ; <nl> + } <nl> + <nl> + public static void writeLong ( long src , byte [ ] dest , int offset ) <nl> + { <nl> + dest [ offset ] = ( byte ) ( src > > 56 ) ; <nl> + dest [ offset + 1 ] = ( byte ) ( src > > 48 ) ; <nl> + dest [ offset + 2 ] = ( byte ) ( src > > 40 ) ; <nl> + dest [ offset + 3 ] = ( byte ) ( src > > 32 ) ; <nl> + dest [ offset + 4 ] = ( byte ) ( src > > 24 ) ; <nl> + dest [ offset + 5 ] = ( byte ) ( src > > 16 ) ; <nl> + dest [ offset + 6 ] = ( byte ) ( src > > 8 ) ; <nl> + dest [ offset + 7 ] = ( byte ) ( src ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / dht / RandomPartitioner . java b / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> index cf3855b . . 5b95454 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> + + + b / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> @ @ - 17 , 170 + 17 , 18 @ @ <nl> * / <nl> package org . apache . cassandra . dht ; <nl> <nl> - import java . math . BigDecimal ; <nl> import java . math . BigInteger ; <nl> import java . nio . ByteBuffer ; <nl> - import java . nio . charset . CharacterCodingException ; <nl> - import java . util . * ; <nl> <nl> - import org . apache . cassandra . config . ConfigurationException ; <nl> - import org . apache . cassandra . db . DecoratedKey ; <nl> - import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> - import org . apache . cassandra . utils . GuidGenerator ; <nl> - import org . apache . cassandra . utils . Pair ; <nl> <nl> / * * <nl> - * This class generates a BigIntegerToken using MD5 hash . <nl> + * This class generates a BigIntegerToken using a MD5 hash . <nl> * / <nl> - public class RandomPartitioner extends AbstractPartitioner < BigIntegerToken > <nl> + public class RandomPartitioner extends AbstractHashedPartitioner <nl> { <nl> - public static final BigInteger ZERO = new BigInteger ( " 0 " ) ; <nl> - public static final BigIntegerToken MINIMUM = new BigIntegerToken ( " - 1 " ) ; <nl> - public static final BigInteger MAXIMUM = new BigInteger ( " 2 " ) . pow ( 127 ) ; <nl> - <nl> - private static final byte DELIMITER _ BYTE = " : " . getBytes ( ) [ 0 ] ; <nl> - <nl> - public DecoratedKey decorateKey ( ByteBuffer key ) <nl> - { <nl> - return new DecoratedKey ( getToken ( key ) , key ) ; <nl> - } <nl> - <nl> - public DecoratedKey convertFromDiskFormat ( ByteBuffer fromdisk ) <nl> - { <nl> - / / find the delimiter position <nl> - int splitPoint = - 1 ; <nl> - for ( int i = fromdisk . position ( ) ; i < fromdisk . limit ( ) ; i + + ) <nl> - { <nl> - if ( fromdisk . get ( i ) = = DELIMITER _ BYTE ) <nl> - { <nl> - splitPoint = i ; <nl> - break ; <nl> - } <nl> - } <nl> - assert splitPoint ! = - 1 ; <nl> - <nl> - / / and decode the token and key <nl> - String token = null ; <nl> - try <nl> - { <nl> - token = ByteBufferUtil . string ( fromdisk , fromdisk . position ( ) , splitPoint - fromdisk . position ( ) ) ; <nl> - } <nl> - catch ( CharacterCodingException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - ByteBuffer key = fromdisk . duplicate ( ) ; <nl> - key . position ( splitPoint + 1 ) ; <nl> - return new DecoratedKey ( new BigIntegerToken ( token ) , key ) ; <nl> - } <nl> - <nl> - public Token midpoint ( Token ltoken , Token rtoken ) <nl> + protected BigInteger hash ( ByteBuffer buffer ) <nl> { <nl> - / / the symbolic MINIMUM token should act as ZERO : the empty bit array <nl> - BigInteger left = ltoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) ltoken ) . token ; <nl> - BigInteger right = rtoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) rtoken ) . token ; <nl> - Pair < BigInteger , Boolean > midpair = FBUtilities . midpoint ( left , right , 127 ) ; <nl> - / / discard the remainder <nl> - return new BigIntegerToken ( midpair . left ) ; <nl> - } <nl> - <nl> - public BigIntegerToken getMinimumToken ( ) <nl> - { <nl> - return MINIMUM ; <nl> - } <nl> - <nl> - public BigIntegerToken getRandomToken ( ) <nl> - { <nl> - BigInteger token = FBUtilities . hashToBigInteger ( GuidGenerator . guidAsBytes ( ) ) ; <nl> - if ( token . signum ( ) = = - 1 ) <nl> - token = token . multiply ( BigInteger . valueOf ( - 1L ) ) ; <nl> - return new BigIntegerToken ( token ) ; <nl> - } <nl> - <nl> - private final Token . TokenFactory < BigInteger > tokenFactory = new Token . TokenFactory < BigInteger > ( ) { <nl> - public ByteBuffer toByteArray ( Token < BigInteger > bigIntegerToken ) <nl> - { <nl> - return ByteBuffer . wrap ( bigIntegerToken . token . toByteArray ( ) ) ; <nl> - } <nl> - <nl> - public Token < BigInteger > fromByteArray ( ByteBuffer bytes ) <nl> - { <nl> - return new BigIntegerToken ( new BigInteger ( ByteBufferUtil . getArray ( bytes ) ) ) ; <nl> - } <nl> - <nl> - public String toString ( Token < BigInteger > bigIntegerToken ) <nl> - { <nl> - return bigIntegerToken . token . toString ( ) ; <nl> - } <nl> - <nl> - public void validate ( String token ) throws ConfigurationException <nl> - { <nl> - try <nl> - { <nl> - BigInteger i = new BigInteger ( token ) ; <nl> - if ( i . compareTo ( ZERO ) < 0 ) <nl> - throw new ConfigurationException ( " Token must be > = 0 " ) ; <nl> - if ( i . compareTo ( MAXIMUM ) > 0 ) <nl> - throw new ConfigurationException ( " Token must be < = 2 * * 127 " ) ; <nl> - } <nl> - catch ( NumberFormatException e ) <nl> - { <nl> - throw new ConfigurationException ( e . getMessage ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - public Token < BigInteger > fromString ( String string ) <nl> - { <nl> - return new BigIntegerToken ( new BigInteger ( string ) ) ; <nl> - } <nl> - } ; <nl> - <nl> - public Token . TokenFactory < BigInteger > getTokenFactory ( ) <nl> - { <nl> - return tokenFactory ; <nl> - } <nl> - <nl> - public boolean preservesOrder ( ) <nl> - { <nl> - return false ; <nl> - } <nl> - <nl> - public BigIntegerToken getToken ( ByteBuffer key ) <nl> - { <nl> - if ( key . remaining ( ) = = 0 ) <nl> - return MINIMUM ; <nl> - return new BigIntegerToken ( FBUtilities . hashToBigInteger ( key ) ) ; <nl> - } <nl> - <nl> - public Map < Token , Float > describeOwnership ( List < Token > sortedTokens ) <nl> - { <nl> - Map < Token , Float > ownerships = new HashMap < Token , Float > ( ) ; <nl> - Iterator i = sortedTokens . iterator ( ) ; <nl> - <nl> - / / 0 - case <nl> - if ( ! i . hasNext ( ) ) { throw new RuntimeException ( " No nodes present in the cluster . How did you call this ? " ) ; } <nl> - / / 1 - case <nl> - if ( sortedTokens . size ( ) = = 1 ) { <nl> - ownerships . put ( ( Token ) i . next ( ) , new Float ( 1 . 0 ) ) ; <nl> - } <nl> - / / n - case <nl> - else { <nl> - / / NOTE : All divisions must take place in BigDecimals , and all modulo operators must take place in BigIntegers . <nl> - final BigInteger ri = MAXIMUM ; / / ( used for addition later ) <nl> - final BigDecimal r = new BigDecimal ( ri ) ; / / The entire range , 2 * * 127 <nl> - Token start = ( Token ) i . next ( ) ; BigInteger ti = ( ( BigIntegerToken ) start ) . token ; / / The first token and its value <nl> - Token t ; BigInteger tim1 = ti ; / / The last token and its value ( after loop ) <nl> - while ( i . hasNext ( ) ) { <nl> - t = ( Token ) i . next ( ) ; ti = ( ( BigIntegerToken ) t ) . token ; / / The next token and its value <nl> - float x = new BigDecimal ( ti . subtract ( tim1 ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; / / % age = ( ( T ( i ) - T ( i - 1 ) + R ) % R ) / R <nl> - ownerships . put ( t , x ) ; / / save ( T ( i ) - > % age ) <nl> - tim1 = ti ; / / - > advance loop <nl> - } <nl> - / / The start token ' s range extends backward to the last token , which is why both were saved above . <nl> - float x = new BigDecimal ( ( ( BigIntegerToken ) start ) . token . subtract ( ti ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; <nl> - ownerships . put ( start , x ) ; <nl> - } <nl> - return ownerships ; <nl> + return FBUtilities . hashToBigInteger ( buffer ) ; <nl> } <nl> }

TEST DIFF:
diff - - git a / NEWS . txt b / NEWS . txt 
 index de535ef . . 61ce546 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 21 , 6 + 21 , 14 @ @ Upgrading 
 - Nothing specific to this release , but please see 2 . 1 if you are upgrading 
 from a previous version . 
 
 + 2 . 1 . 1 
 + = = = = = 
 + 
 + Upgrading 
 + - - - - - - - - - 
 + - Nothing specific to this release , but please see 2 . 1 if you are upgrading 
 + from a previous version . 
 + 
 New features 
 - - - - - - - - - - - - 
 - Netty support for epoll on linux is now enabled . If for some

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 426ac7d . . 8fe1770 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 38 , 6 + 38 , 7 @ @ 
 * ( cql3 ) Add support for 2ndary indexes ( CASSANDRA - 3680 ) 
 * ( cql3 ) fix defining more than one PK to be invalid ( CASSANDRA - 4477 ) 
 * remove schema agreement checking from all external APIs ( Thrift , CQL and CQL3 ) ( CASSANDRA - 4487 ) 
 + * add Murmur3Partitioner and make it default for new installations ( CASSANDRA - 3772 ) 
 
 
 1 . 1 . 5 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 1b89b2e . . 5e45961 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 70 , 6 + 70 , 8 @ @ authority : org . apache . cassandra . auth . AllowAllAuthority 
 # 
 # - RandomPartitioner distributes rows across the cluster evenly by md5 . 
 # When in doubt , this is the best option . 
 + # - Murmur3Partitioner is similar to RandomPartioner but uses Murmur3 _ 128 
 + # Hash Function instead of md5 
 # - ByteOrderedPartitioner orders rows lexically by key bytes . BOP allows 
 # scanning rows in key order , but the ordering can generate hot spots 
 # for sequential insertion workloads . 
 @ @ - 81 , 7 + 83 , 7 @ @ authority : org . apache . cassandra . auth . AllowAllAuthority 
 # 
 # See http : / / wiki . apache . org / cassandra / Operations for more on 
 # partitioners and token selection . 
 - partitioner : org . apache . cassandra . dht . RandomPartitioner 
 + partitioner : org . apache . cassandra . dht . Murmur3Partitioner 
 
 # directories where Cassandra should store data on disk . 
 data _ file _ directories : 
 diff - - git a / src / java / org / apache / cassandra / dht / AbstractHashedPartitioner . java b / src / java / org / apache / cassandra / dht / AbstractHashedPartitioner . java 
 new file mode 100644 
 index 0000000 . . 55dfb97 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / dht / AbstractHashedPartitioner . java 
 @ @ - 0 , 0 + 1 , 194 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . dht ; 
 + 
 + import java . math . BigDecimal ; 
 + import java . math . BigInteger ; 
 + import java . nio . ByteBuffer ; 
 + import java . nio . charset . CharacterCodingException ; 
 + import java . util . * ; 
 + 
 + import org . apache . cassandra . config . ConfigurationException ; 
 + import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . GuidGenerator ; 
 + import org . apache . cassandra . utils . Pair ; 
 + 
 + / * * 
 + * This class is the super class of classes that generate a BigIntegerToken using hash function . 
 + * / 
 + public abstract class AbstractHashedPartitioner extends AbstractPartitioner < BigIntegerToken > 
 + { 
 + public static final BigInteger ZERO = new BigInteger ( " 0 " ) ; 
 + public static final BigIntegerToken MINIMUM = new BigIntegerToken ( " - 1 " ) ; 
 + public static final BigInteger MAXIMUM = new BigInteger ( " 2 " ) . pow ( 127 ) ; 
 + 
 + private static final byte DELIMITER _ BYTE = " : " . getBytes ( ) [ 0 ] ; 
 + 
 + / * * 
 + * returns a hash of the byte buffer in the range of 0 - 2 * * 127 as a BigInteger 
 + * 
 + * @ param buffer the buffer to hash 
 + * @ return the BigInteger hash value 
 + * / 
 + protected abstract BigInteger hash ( ByteBuffer buffer ) ; 
 + 
 + public DecoratedKey decorateKey ( ByteBuffer key ) 
 + { 
 + return new DecoratedKey ( getToken ( key ) , key ) ; 
 + } 
 + 
 + public DecoratedKey convertFromDiskFormat ( ByteBuffer fromdisk ) 
 + { 
 + / / find the delimiter position 
 + int splitPoint = - 1 ; 
 + for ( int i = fromdisk . position ( ) ; i < fromdisk . limit ( ) ; i + + ) 
 + { 
 + if ( fromdisk . get ( i ) = = DELIMITER _ BYTE ) 
 + { 
 + splitPoint = i ; 
 + break ; 
 + } 
 + } 
 + assert splitPoint ! = - 1 ; 
 + 
 + / / and decode the token and key 
 + String token = null ; 
 + try 
 + { 
 + token = ByteBufferUtil . string ( fromdisk , fromdisk . position ( ) , splitPoint - fromdisk . position ( ) ) ; 
 + } 
 + catch ( CharacterCodingException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + ByteBuffer key = fromdisk . duplicate ( ) ; 
 + key . position ( splitPoint + 1 ) ; 
 + return new DecoratedKey ( new BigIntegerToken ( token ) , key ) ; 
 + } 
 + 
 + public Token midpoint ( Token ltoken , Token rtoken ) 
 + { 
 + / / the symbolic MINIMUM token should act as ZERO : the empty bit array 
 + BigInteger left = ltoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) ltoken ) . token ; 
 + BigInteger right = rtoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) rtoken ) . token ; 
 + Pair < BigInteger , Boolean > midpair = FBUtilities . midpoint ( left , right , 127 ) ; 
 + / / discard the remainder 
 + return new BigIntegerToken ( midpair . left ) ; 
 + } 
 + 
 + public BigIntegerToken getMinimumToken ( ) 
 + { 
 + return MINIMUM ; 
 + } 
 + 
 + public BigIntegerToken getRandomToken ( ) 
 + { 
 + BigInteger token = hash ( GuidGenerator . guidAsBytes ( ) ) ; 
 + if ( token . signum ( ) = = - 1 ) 
 + token = token . multiply ( BigInteger . valueOf ( - 1L ) ) ; 
 + return new BigIntegerToken ( token ) ; 
 + } 
 + 
 + private final Token . TokenFactory < BigInteger > tokenFactory = new Token . TokenFactory < BigInteger > ( ) { 
 + public ByteBuffer toByteArray ( Token < BigInteger > bigIntegerToken ) 
 + { 
 + return ByteBuffer . wrap ( bigIntegerToken . token . toByteArray ( ) ) ; 
 + } 
 + 
 + public Token < BigInteger > fromByteArray ( ByteBuffer bytes ) 
 + { 
 + return new BigIntegerToken ( new BigInteger ( ByteBufferUtil . getArray ( bytes ) ) ) ; 
 + } 
 + 
 + public String toString ( Token < BigInteger > bigIntegerToken ) 
 + { 
 + return bigIntegerToken . token . toString ( ) ; 
 + } 
 + 
 + public void validate ( String token ) throws ConfigurationException 
 + { 
 + try 
 + { 
 + BigInteger i = new BigInteger ( token ) ; 
 + if ( i . compareTo ( ZERO ) < 0 ) 
 + throw new ConfigurationException ( " Token must be > = 0 " ) ; 
 + if ( i . compareTo ( MAXIMUM ) > 0 ) 
 + throw new ConfigurationException ( " Token must be < = 2 * * 127 " ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new ConfigurationException ( e . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + public Token < BigInteger > fromString ( String string ) 
 + { 
 + return new BigIntegerToken ( new BigInteger ( string ) ) ; 
 + } 
 + } ; 
 + 
 + public Token . TokenFactory < BigInteger > getTokenFactory ( ) 
 + { 
 + return tokenFactory ; 
 + } 
 + 
 + public boolean preservesOrder ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + public BigIntegerToken getToken ( ByteBuffer key ) 
 + { 
 + if ( key . remaining ( ) = = 0 ) 
 + return MINIMUM ; 
 + return new BigIntegerToken ( hash ( key ) ) ; 
 + } 
 + 
 + public Map < Token , Float > describeOwnership ( List < Token > sortedTokens ) 
 + { 
 + Map < Token , Float > ownerships = new HashMap < Token , Float > ( ) ; 
 + Iterator i = sortedTokens . iterator ( ) ; 
 + 
 + / / 0 - case 
 + if ( ! i . hasNext ( ) ) { throw new RuntimeException ( " No nodes present in the cluster . How did you call this ? " ) ; } 
 + / / 1 - case 
 + if ( sortedTokens . size ( ) = = 1 ) { 
 + ownerships . put ( ( Token ) i . next ( ) , new Float ( 1 . 0 ) ) ; 
 + } 
 + / / n - case 
 + else { 
 + / / NOTE : All divisions must take place in BigDecimals , and all modulo operators must take place in BigIntegers . 
 + final BigInteger ri = MAXIMUM ; / / ( used for addition later ) 
 + final BigDecimal r = new BigDecimal ( ri ) ; / / The entire range , 2 * * 127 
 + Token start = ( Token ) i . next ( ) ; BigInteger ti = ( ( BigIntegerToken ) start ) . token ; / / The first token and its value 
 + Token t ; BigInteger tim1 = ti ; / / The last token and its value ( after loop ) 
 + while ( i . hasNext ( ) ) { 
 + t = ( Token ) i . next ( ) ; ti = ( ( BigIntegerToken ) t ) . token ; / / The next token and its value 
 + float x = new BigDecimal ( ti . subtract ( tim1 ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; / / % age = ( ( T ( i ) - T ( i - 1 ) + R ) % R ) / R 
 + ownerships . put ( t , x ) ; / / save ( T ( i ) - > % age ) 
 + tim1 = ti ; / / - > advance loop 
 + } 
 + / / The start token ' s range extends backward to the last token , which is why both were saved above . 
 + float x = new BigDecimal ( ( ( BigIntegerToken ) start ) . token . subtract ( ti ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; 
 + ownerships . put ( start , x ) ; 
 + } 
 + return ownerships ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / dht / Murmur3Partitioner . java b / src / java / org / apache / cassandra / dht / Murmur3Partitioner . java 
 new file mode 100644 
 index 0000000 . . 775cef9 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / dht / Murmur3Partitioner . java 
 @ @ - 0 , 0 + 1 , 53 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . dht ; 
 + 
 + import java . math . BigInteger ; 
 + import java . nio . ByteBuffer ; 
 + 
 + import org . apache . cassandra . utils . MurmurHash ; 
 + 
 + / * * 
 + * This class generates a BigIntegerToken using a Murmur3 hash . 
 + * / 
 + public class Murmur3Partitioner extends AbstractHashedPartitioner 
 + { 
 + protected BigInteger hash ( ByteBuffer buffer ) 
 + { 
 + long [ ] bufferHash = MurmurHash . hash3 _ x64 _ 128 ( buffer , buffer . position ( ) , buffer . remaining ( ) , 0 ) ; 
 + byte [ ] hashBytes = new byte [ 16 ] ; 
 + 
 + writeLong ( bufferHash [ 0 ] , hashBytes , 0 ) ; 
 + writeLong ( bufferHash [ 1 ] , hashBytes , 8 ) ; 
 + / / make sure it ' s positive , this isn ' t the same as abs ( ) but doesn ' t effect distribution 
 + hashBytes [ 0 ] = ( byte ) ( hashBytes [ 0 ] & 0x7F ) ; 
 + return new BigInteger ( hashBytes ) ; 
 + } 
 + 
 + public static void writeLong ( long src , byte [ ] dest , int offset ) 
 + { 
 + dest [ offset ] = ( byte ) ( src > > 56 ) ; 
 + dest [ offset + 1 ] = ( byte ) ( src > > 48 ) ; 
 + dest [ offset + 2 ] = ( byte ) ( src > > 40 ) ; 
 + dest [ offset + 3 ] = ( byte ) ( src > > 32 ) ; 
 + dest [ offset + 4 ] = ( byte ) ( src > > 24 ) ; 
 + dest [ offset + 5 ] = ( byte ) ( src > > 16 ) ; 
 + dest [ offset + 6 ] = ( byte ) ( src > > 8 ) ; 
 + dest [ offset + 7 ] = ( byte ) ( src ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / dht / RandomPartitioner . java b / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 index cf3855b . . 5b95454 100644 
 - - - a / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 + + + b / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 @ @ - 17 , 170 + 17 , 18 @ @ 
 * / 
 package org . apache . cassandra . dht ; 
 
 - import java . math . BigDecimal ; 
 import java . math . BigInteger ; 
 import java . nio . ByteBuffer ; 
 - import java . nio . charset . CharacterCodingException ; 
 - import java . util . * ; 
 
 - import org . apache . cassandra . config . ConfigurationException ; 
 - import org . apache . cassandra . db . DecoratedKey ; 
 - import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 - import org . apache . cassandra . utils . GuidGenerator ; 
 - import org . apache . cassandra . utils . Pair ; 
 
 / * * 
 - * This class generates a BigIntegerToken using MD5 hash . 
 + * This class generates a BigIntegerToken using a MD5 hash . 
 * / 
 - public class RandomPartitioner extends AbstractPartitioner < BigIntegerToken > 
 + public class RandomPartitioner extends AbstractHashedPartitioner 
 { 
 - public static final BigInteger ZERO = new BigInteger ( " 0 " ) ; 
 - public static final BigIntegerToken MINIMUM = new BigIntegerToken ( " - 1 " ) ; 
 - public static final BigInteger MAXIMUM = new BigInteger ( " 2 " ) . pow ( 127 ) ; 
 - 
 - private static final byte DELIMITER _ BYTE = " : " . getBytes ( ) [ 0 ] ; 
 - 
 - public DecoratedKey decorateKey ( ByteBuffer key ) 
 - { 
 - return new DecoratedKey ( getToken ( key ) , key ) ; 
 - } 
 - 
 - public DecoratedKey convertFromDiskFormat ( ByteBuffer fromdisk ) 
 - { 
 - / / find the delimiter position 
 - int splitPoint = - 1 ; 
 - for ( int i = fromdisk . position ( ) ; i < fromdisk . limit ( ) ; i + + ) 
 - { 
 - if ( fromdisk . get ( i ) = = DELIMITER _ BYTE ) 
 - { 
 - splitPoint = i ; 
 - break ; 
 - } 
 - } 
 - assert splitPoint ! = - 1 ; 
 - 
 - / / and decode the token and key 
 - String token = null ; 
 - try 
 - { 
 - token = ByteBufferUtil . string ( fromdisk , fromdisk . position ( ) , splitPoint - fromdisk . position ( ) ) ; 
 - } 
 - catch ( CharacterCodingException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - ByteBuffer key = fromdisk . duplicate ( ) ; 
 - key . position ( splitPoint + 1 ) ; 
 - return new DecoratedKey ( new BigIntegerToken ( token ) , key ) ; 
 - } 
 - 
 - public Token midpoint ( Token ltoken , Token rtoken ) 
 + protected BigInteger hash ( ByteBuffer buffer ) 
 { 
 - / / the symbolic MINIMUM token should act as ZERO : the empty bit array 
 - BigInteger left = ltoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) ltoken ) . token ; 
 - BigInteger right = rtoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) rtoken ) . token ; 
 - Pair < BigInteger , Boolean > midpair = FBUtilities . midpoint ( left , right , 127 ) ; 
 - / / discard the remainder 
 - return new BigIntegerToken ( midpair . left ) ; 
 - } 
 - 
 - public BigIntegerToken getMinimumToken ( ) 
 - { 
 - return MINIMUM ; 
 - } 
 - 
 - public BigIntegerToken getRandomToken ( ) 
 - { 
 - BigInteger token = FBUtilities . hashToBigInteger ( GuidGenerator . guidAsBytes ( ) ) ; 
 - if ( token . signum ( ) = = - 1 ) 
 - token = token . multiply ( BigInteger . valueOf ( - 1L ) ) ; 
 - return new BigIntegerToken ( token ) ; 
 - } 
 - 
 - private final Token . TokenFactory < BigInteger > tokenFactory = new Token . TokenFactory < BigInteger > ( ) { 
 - public ByteBuffer toByteArray ( Token < BigInteger > bigIntegerToken ) 
 - { 
 - return ByteBuffer . wrap ( bigIntegerToken . token . toByteArray ( ) ) ; 
 - } 
 - 
 - public Token < BigInteger > fromByteArray ( ByteBuffer bytes ) 
 - { 
 - return new BigIntegerToken ( new BigInteger ( ByteBufferUtil . getArray ( bytes ) ) ) ; 
 - } 
 - 
 - public String toString ( Token < BigInteger > bigIntegerToken ) 
 - { 
 - return bigIntegerToken . token . toString ( ) ; 
 - } 
 - 
 - public void validate ( String token ) throws ConfigurationException 
 - { 
 - try 
 - { 
 - BigInteger i = new BigInteger ( token ) ; 
 - if ( i . compareTo ( ZERO ) < 0 ) 
 - throw new ConfigurationException ( " Token must be > = 0 " ) ; 
 - if ( i . compareTo ( MAXIMUM ) > 0 ) 
 - throw new ConfigurationException ( " Token must be < = 2 * * 127 " ) ; 
 - } 
 - catch ( NumberFormatException e ) 
 - { 
 - throw new ConfigurationException ( e . getMessage ( ) ) ; 
 - } 
 - } 
 - 
 - public Token < BigInteger > fromString ( String string ) 
 - { 
 - return new BigIntegerToken ( new BigInteger ( string ) ) ; 
 - } 
 - } ; 
 - 
 - public Token . TokenFactory < BigInteger > getTokenFactory ( ) 
 - { 
 - return tokenFactory ; 
 - } 
 - 
 - public boolean preservesOrder ( ) 
 - { 
 - return false ; 
 - } 
 - 
 - public BigIntegerToken getToken ( ByteBuffer key ) 
 - { 
 - if ( key . remaining ( ) = = 0 ) 
 - return MINIMUM ; 
 - return new BigIntegerToken ( FBUtilities . hashToBigInteger ( key ) ) ; 
 - } 
 - 
 - public Map < Token , Float > describeOwnership ( List < Token > sortedTokens ) 
 - { 
 - Map < Token , Float > ownerships = new HashMap < Token , Float > ( ) ; 
 - Iterator i = sortedTokens . iterator ( ) ; 
 - 
 - / / 0 - case 
 - if ( ! i . hasNext ( ) ) { throw new RuntimeException ( " No nodes present in the cluster . How did you call this ? " ) ; } 
 - / / 1 - case 
 - if ( sortedTokens . size ( ) = = 1 ) { 
 - ownerships . put ( ( Token ) i . next ( ) , new Float ( 1 . 0 ) ) ; 
 - } 
 - / / n - case 
 - else { 
 - / / NOTE : All divisions must take place in BigDecimals , and all modulo operators must take place in BigIntegers . 
 - final BigInteger ri = MAXIMUM ; / / ( used for addition later ) 
 - final BigDecimal r = new BigDecimal ( ri ) ; / / The entire range , 2 * * 127 
 - Token start = ( Token ) i . next ( ) ; BigInteger ti = ( ( BigIntegerToken ) start ) . token ; / / The first token and its value 
 - Token t ; BigInteger tim1 = ti ; / / The last token and its value ( after loop ) 
 - while ( i . hasNext ( ) ) { 
 - t = ( Token ) i . next ( ) ; ti = ( ( BigIntegerToken ) t ) . token ; / / The next token and its value 
 - float x = new BigDecimal ( ti . subtract ( tim1 ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; / / % age = ( ( T ( i ) - T ( i - 1 ) + R ) % R ) / R 
 - ownerships . put ( t , x ) ; / / save ( T ( i ) - > % age ) 
 - tim1 = ti ; / / - > advance loop 
 - } 
 - / / The start token ' s range extends backward to the last token , which is why both were saved above . 
 - float x = new BigDecimal ( ( ( BigIntegerToken ) start ) . token . subtract ( ti ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; 
 - ownerships . put ( start , x ) ; 
 - } 
 - return ownerships ; 
 + return FBUtilities . hashToBigInteger ( buffer ) ; 
 } 
 }
