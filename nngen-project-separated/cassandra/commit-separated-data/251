BLEU SCORE: 0.044568827606990644

TEST MSG: Round buffer size to powers of 2 for the chunk cache
GENERATED MSG: add file _ cache _ size _ in _ mb setting

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a729d35 . . 532c958 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 11 . 2 <nl> + * Round buffer size to powers of 2 for the chunk cache ( CASSANDRA - 13897 ) <nl> * Update jackson JSON jars ( CASSANDRA - 13949 ) <nl> * Avoid locks when checking LCS fanout and if we should defrag ( CASSANDRA - 13930 ) <nl> Merged from 3 . 0 : <nl> diff - - git a / src / java / org / apache / cassandra / cache / ChunkCache . java b / src / java / org / apache / cassandra / cache / ChunkCache . java <nl> index 15cf2ce . . 4e7f848 100644 <nl> - - - a / src / java / org / apache / cassandra / cache / ChunkCache . java <nl> + + + b / src / java / org / apache / cassandra / cache / ChunkCache . java <nl> @ @ - 41 , 6 + 41 , 7 @ @ public class ChunkCache <nl> { <nl> public static final int RESERVED _ POOL _ SPACE _ IN _ MB = 32 ; <nl> public static final long cacheSize = 1024L * 1024L * Math . max ( 0 , DatabaseDescriptor . getFileCacheSizeInMB ( ) - RESERVED _ POOL _ SPACE _ IN _ MB ) ; <nl> + public static final boolean roundUp = DatabaseDescriptor . getFileCacheRoundUp ( ) ; <nl> <nl> private static boolean enabled = cacheSize > 0 ; <nl> public static final ChunkCache instance = enabled ? new ChunkCache ( ) : null ; <nl> @ @ - 219 , 7 + 220 , 7 @ @ public class ChunkCache <nl> { <nl> source = file ; <nl> int chunkSize = file . chunkSize ( ) ; <nl> - assert Integer . bitCount ( chunkSize ) = = 1 ; / / Must be power of two <nl> + assert Integer . bitCount ( chunkSize ) = = 1 : String . format ( " % d must be a power of two " , chunkSize ) ; <nl> alignmentMask = - chunkSize ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 8fde816 . . 9489af9 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 265 , 6 + 265 , 17 @ @ public class Config <nl> <nl> public Integer file _ cache _ size _ in _ mb ; <nl> <nl> + / * * <nl> + * Because of the current { @ link org . apache . cassandra . utils . memory . BufferPool } slab sizes of 64 kb , we <nl> + * store in the file cache buffers that divide 64 kb , so we need to round the buffer sizes to powers of two . <nl> + * This boolean controls weather they are rounded up or down . Set it to true to round up to the <nl> + * next power of two , set it to false to round down to the previous power of two . Note that buffer sizes are <nl> + * already rounded to 4 kb and capped between 4 kb minimum and 64 kb maximum by the { @ link DiskOptimizationStrategy } . <nl> + * By default , this boolean is set to round down when { @ link # disk _ optimization _ strategy } is { @ code ssd } , <nl> + * and to round up when it is { @ code spinning } . <nl> + * / <nl> + public Boolean file _ cache _ round _ up ; <nl> + <nl> public boolean buffer _ pool _ use _ heap _ if _ exhausted = true ; <nl> <nl> public DiskOptimizationStrategy disk _ optimization _ strategy = DiskOptimizationStrategy . ssd ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 4ce2728 . . 27b8b95 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 409 , 6 + 409 , 10 @ @ public class DatabaseDescriptor <nl> if ( conf . file _ cache _ size _ in _ mb = = null ) <nl> conf . file _ cache _ size _ in _ mb = Math . min ( 512 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ) ; <nl> <nl> + / / round down for SSDs and round up for spinning disks <nl> + if ( conf . file _ cache _ round _ up = = null ) <nl> + conf . file _ cache _ round _ up = conf . disk _ optimization _ strategy = = Config . DiskOptimizationStrategy . spinning ; <nl> + <nl> if ( conf . memtable _ offheap _ space _ in _ mb = = null ) <nl> conf . memtable _ offheap _ space _ in _ mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ; <nl> if ( conf . memtable _ offheap _ space _ in _ mb < 0 ) <nl> @ @ - 2060 , 6 + 2064 , 18 @ @ public class DatabaseDescriptor <nl> return conf . file _ cache _ size _ in _ mb ; <nl> } <nl> <nl> + public static boolean getFileCacheRoundUp ( ) <nl> + { <nl> + if ( conf . file _ cache _ round _ up = = null ) <nl> + { <nl> + / / In client mode the value is not set . <nl> + assert DatabaseDescriptor . isClientInitialized ( ) ; <nl> + return false ; <nl> + } <nl> + <nl> + return conf . file _ cache _ round _ up ; <nl> + } <nl> + <nl> public static boolean getBufferPoolUseHeapIfExhausted ( ) <nl> { <nl> return conf . buffer _ pool _ use _ heap _ if _ exhausted ; <nl> diff - - git a / src / java / org / apache / cassandra / io / util / DiskOptimizationStrategy . java b / src / java / org / apache / cassandra / io / util / DiskOptimizationStrategy . java <nl> index e10342d . . 272291e 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / DiskOptimizationStrategy . java <nl> + + + b / src / java / org / apache / cassandra / io / util / DiskOptimizationStrategy . java <nl> @ @ - 20 , 6 + 20 , 9 @ @ package org . apache . cassandra . io . util ; <nl> <nl> public interface DiskOptimizationStrategy <nl> { <nl> + int MIN _ BUFFER _ SIZE = 1 < < 12 ; / / 4096 , the typical size of a page in the OS cache <nl> + int MIN _ BUFFER _ SIZE _ MASK = MIN _ BUFFER _ SIZE - 1 ; <nl> + <nl> / / The maximum buffer size , we will never buffer more than this size . Further , <nl> / / when the limiter is not null , i . e . when throttling is enabled , we read exactly <nl> / / this size , since when throttling the intention is to eventually read everything , <nl> @ @ - 40 , 9 + 43 , 32 @ @ public interface DiskOptimizationStrategy <nl> default int roundBufferSize ( long size ) <nl> { <nl> if ( size < = 0 ) <nl> - return 4096 ; <nl> + return MIN _ BUFFER _ SIZE ; <nl> <nl> - size = ( size + 4095 ) & ~ 4095 ; <nl> + size = ( size + MIN _ BUFFER _ SIZE _ MASK ) & ~ MIN _ BUFFER _ SIZE _ MASK ; <nl> return ( int ) Math . min ( size , MAX _ BUFFER _ SIZE ) ; <nl> } <nl> + <nl> + / * * <nl> + * Round either up or down to the next power of two , which is required by the <nl> + * { @ link org . apache . cassandra . cache . ChunkCache . CachingRebufferer } , but capping between { @ link # MIN _ BUFFER _ SIZE } <nl> + * and { @ link # MAX _ BUFFER _ SIZE } . <nl> + * <nl> + * @ param size - the size to round to a power of two , normally this is a buffer size that was previously <nl> + * returned by a { @ link # bufferSize ( long ) } . <nl> + * @ param roundUp - whether to round up or down <nl> + * <nl> + * @ return a value rounded to a power of two but never bigger than { @ link # MAX _ BUFFER _ SIZE } or smaller than { @ link # MIN _ BUFFER _ SIZE } . <nl> + * / <nl> + static int roundForCaching ( int size , boolean roundUp ) <nl> + { <nl> + if ( size < = MIN _ BUFFER _ SIZE ) <nl> + return MIN _ BUFFER _ SIZE ; <nl> + <nl> + int ret = roundUp <nl> + ? 1 < < ( 32 - Integer . numberOfLeadingZeros ( size - 1 ) ) <nl> + : Integer . highestOneBit ( size ) ; <nl> + <nl> + return Math . min ( MAX _ BUFFER _ SIZE , ret ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / util / FileHandle . java b / src / java / org / apache / cassandra / io / util / FileHandle . java <nl> index 9e03d3b . . a3afc2f 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / FileHandle . java <nl> + + + b / src / java / org / apache / cassandra / io / util / FileHandle . java <nl> @ @ - 378 , 7 + 378 , 8 @ @ public class FileHandle extends SharedCloseableImpl <nl> } <nl> else <nl> { <nl> - rebuffererFactory = maybeCached ( new SimpleChunkReader ( channelCopy , length , bufferType , bufferSize ) ) ; <nl> + int chunkSize = DiskOptimizationStrategy . roundForCaching ( bufferSize , ChunkCache . roundUp ) ; <nl> + rebuffererFactory = maybeCached ( new SimpleChunkReader ( channelCopy , length , bufferType , chunkSize ) ) ; <nl> } <nl> } <nl> Cleanup cleanup = new Cleanup ( channelCopy , rebuffererFactory , compressionMetadata , chunkCache ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / io / util / DiskOptimizationStrategyTest . java b / test / unit / org / apache / cassandra / io / util / DiskOptimizationStrategyTest . java <nl> index 986df96 . . ed1f948 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / util / DiskOptimizationStrategyTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / util / DiskOptimizationStrategyTest . java <nl> @ @ - 82 , 4 + 82 , 58 @ @ public class DiskOptimizationStrategyTest <nl> assertEquals ( 8192 , strategy . bufferSize ( 4096 ) ) ; <nl> assertEquals ( 12288 , strategy . bufferSize ( 4097 ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testRoundUpForCaching ( ) <nl> + { <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( - 1 , true ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 0 , true ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 1 , true ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4095 , true ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4096 , true ) ) ; <nl> + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 4097 , true ) ) ; <nl> + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 4098 , true ) ) ; <nl> + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 8192 , true ) ) ; <nl> + assertEquals ( 16384 , DiskOptimizationStrategy . roundForCaching ( 8193 , true ) ) ; <nl> + assertEquals ( 16384 , DiskOptimizationStrategy . roundForCaching ( 12288 , true ) ) ; <nl> + assertEquals ( 16384 , DiskOptimizationStrategy . roundForCaching ( 16384 , true ) ) ; <nl> + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 65536 , true ) ) ; <nl> + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 65537 , true ) ) ; <nl> + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 131072 , true ) ) ; <nl> + <nl> + for ( int cs = 4096 ; cs < 65536 ; cs < < = 1 ) / / 4096 , 8192 , 12288 , . . . , 65536 <nl> + { <nl> + for ( int i = ( cs - 4095 ) ; i < = cs ; i + + ) / / 1 - > 4096 , 4097 - > 8192 , . . . <nl> + { <nl> + assertEquals ( cs , DiskOptimizationStrategy . roundForCaching ( i , true ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testRoundDownForCaching ( ) <nl> + { <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( - 1 , false ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 0 , false ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 1 , false ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4095 , false ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4096 , false ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4097 , false ) ) ; <nl> + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4098 , false ) ) ; <nl> + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 8192 , false ) ) ; <nl> + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 8193 , false ) ) ; <nl> + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 12288 , false ) ) ; <nl> + assertEquals ( 16384 , DiskOptimizationStrategy . roundForCaching ( 16384 , false ) ) ; <nl> + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 65536 , false ) ) ; <nl> + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 65537 , false ) ) ; <nl> + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 131072 , false ) ) ; <nl> + <nl> + for ( int cs = 4096 ; cs < 65536 ; cs < < = 1 ) / / 4096 , 8192 , 12288 , . . . , 65536 <nl> + { <nl> + for ( int i = cs ; i < cs * 2 - 1 ; i + + ) / / 4096 - > 8191 , 8192 - > 12287 , . . . <nl> + { <nl> + assertEquals ( cs , DiskOptimizationStrategy . roundForCaching ( i , false ) ) ; <nl> + } <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2192fe9 . . c2a55df 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 20 , 6 + 20 , 7 @ @ <nl> * Fix potential AssertionError during tracing ( CASSANDRA - 6041 ) <nl> * Fix NPE in sstablesplit ( CASSANDRA - 6027 ) <nl> Merged from 1 . 2 : <nl> + * add file _ cache _ size _ in _ mb setting ( CASSANDRA - 5661 ) <nl> * Tuning knobs for dealing with large blobs and many CFs ( CASSANDRA - 5982 ) <nl> * ( Hadoop ) Fix CQLRW for thrift tables ( CASSANDRA - 6002 ) <nl> * Fix possible divide - by - zero in HHOM ( CASSANDRA - 5990 ) <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 4decf6c . . df4501e 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 238 , 6 + 238 , 10 @ @ seed _ provider : <nl> concurrent _ reads : 32 <nl> concurrent _ writes : 32 <nl> <nl> + # Total memory to use for sstable - reading buffers . Defaults to <nl> + # the smaller of 1 / 4 of heap or 512MB . <nl> + # file _ cache _ size _ in _ mb : 512 <nl> + <nl> # Total memory to use for memtables . Cassandra will flush the largest <nl> # memtable when this much memory is used . <nl> # If omitted , Cassandra will set it to 1 / 3 of the heap . <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index dd0728c . . 0414269 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 167 , 12 + 167 , 14 @ @ public class Config <nl> public String memory _ allocator = NativeAllocator . class . getSimpleName ( ) ; <nl> public boolean populate _ io _ cache _ on _ flush = false ; <nl> <nl> - public boolean inter _ dc _ tcp _ nodelay = false ; <nl> - <nl> private static boolean isClientMode = false ; <nl> <nl> public boolean preheat _ kernel _ page _ cache = false ; <nl> <nl> + public Integer file _ cache _ size _ in _ mb ; <nl> + <nl> + public boolean inter _ dc _ tcp _ nodelay = true ; <nl> + <nl> public String memtable _ allocator = " SlabAllocator " ; <nl> <nl> private static boolean outboundBindAny = false ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index c2f3fa6 . . b3eeca6 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 245 , 6 + 245 , 9 @ @ public class DatabaseDescriptor <nl> throw new ConfigurationException ( " concurrent _ replicates must be at least 2 " ) ; <nl> } <nl> <nl> + if ( conf . file _ cache _ size _ in _ mb = = null ) <nl> + conf . file _ cache _ size _ in _ mb = Math . min ( 512 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ) ; <nl> + <nl> if ( conf . memtable _ total _ space _ in _ mb = = null ) <nl> conf . memtable _ total _ space _ in _ mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 3 * 1048576 ) ) ; <nl> if ( conf . memtable _ total _ space _ in _ mb < = 0 ) <nl> @ @ - 1137 , 6 + 1140 , 11 @ @ public class DatabaseDescriptor <nl> return conf . memtable _ flush _ queue _ size ; <nl> } <nl> <nl> + public static int getFileCacheSizeInMB ( ) <nl> + { <nl> + return conf . file _ cache _ size _ in _ mb ; <nl> + } <nl> + <nl> public static int getTotalMemtableSpaceInMB ( ) <nl> { <nl> / / should only be called if estimatesRealMemtableSize ( ) is true <nl> diff - - git a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> index 4173d5a . . 892611c 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> + + + b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> @ @ - 17 , 13 + 17 , 10 @ @ <nl> * / <nl> package org . apache . cassandra . io . util ; <nl> <nl> - import java . util . Queue ; <nl> - import java . util . concurrent . ConcurrentLinkedQueue ; <nl> + import org . apache . cassandra . service . FileCacheService ; <nl> <nl> public abstract class PoolingSegmentedFile extends SegmentedFile <nl> { <nl> - public final Queue < RandomAccessReader > pool = new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; <nl> - <nl> protected PoolingSegmentedFile ( String path , long length ) <nl> { <nl> super ( path , length ) ; <nl> @ @ - 36 , 9 + 33 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile <nl> <nl> public FileDataInput getSegment ( long position ) <nl> { <nl> - RandomAccessReader reader = pool . poll ( ) ; <nl> + RandomAccessReader reader = FileCacheService . instance . get ( path ) ; <nl> + <nl> if ( reader = = null ) <nl> reader = createReader ( path ) ; <nl> + <nl> reader . seek ( position ) ; <nl> return reader ; <nl> } <nl> @ @ - 47 , 12 + 46 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile <nl> <nl> public void recycle ( RandomAccessReader reader ) <nl> { <nl> - pool . add ( reader ) ; <nl> + FileCacheService . instance . put ( reader ) ; <nl> } <nl> <nl> public void cleanup ( ) <nl> { <nl> - for ( RandomAccessReader reader : pool ) <nl> - reader . deallocate ( ) ; <nl> + FileCacheService . instance . invalidate ( path ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> index bcf6ae3 . . 4ceb3c4 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> + + + b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> @ @ - 152 , 6 + 152 , 11 @ @ public class RandomAccessReader extends RandomAccessFile implements FileDataInpu <nl> return filePath ; <nl> } <nl> <nl> + public int getBufferSize ( ) <nl> + { <nl> + return buffer . length ; <nl> + } <nl> + <nl> public void reset ( ) <nl> { <nl> seek ( markedPointer ) ; <nl> diff - - git a / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java <nl> new file mode 100644 <nl> index 0000000 . . 9b21de6 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java <nl> @ @ - 0 , 0 + 1 , 64 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . metrics ; <nl> + <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . yammer . metrics . Metrics ; <nl> + import com . yammer . metrics . core . Gauge ; <nl> + import com . yammer . metrics . core . Meter ; <nl> + import com . yammer . metrics . core . MetricName ; <nl> + import com . yammer . metrics . util . RatioGauge ; <nl> + import org . apache . cassandra . service . FileCacheService ; <nl> + <nl> + public class FileCacheMetrics <nl> + { <nl> + / * * Total number of hits * / <nl> + public final Meter hits ; <nl> + / * * Total number of requests * / <nl> + public final Meter requests ; <nl> + / * * hit rate * / <nl> + public final Gauge < Double > hitRate ; <nl> + / * * Total size of file cache , in bytes * / <nl> + public final Gauge < Long > size ; <nl> + <nl> + public FileCacheMetrics ( ) <nl> + { <nl> + hits = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Hits " ) , " hits " , TimeUnit . SECONDS ) ; <nl> + requests = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Requests " ) , " requests " , TimeUnit . SECONDS ) ; <nl> + hitRate = Metrics . newGauge ( new MetricName ( FileCacheService . class , " HitRate " ) , new RatioGauge ( ) <nl> + { <nl> + protected double getNumerator ( ) <nl> + { <nl> + return hits . count ( ) ; <nl> + } <nl> + <nl> + protected double getDenominator ( ) <nl> + { <nl> + return requests . count ( ) ; <nl> + } <nl> + } ) ; <nl> + size = Metrics . newGauge ( new MetricName ( FileCacheService . class , " Size " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + return FileCacheService . instance . sizeInBytes ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / service / FileCacheService . java b / src / java / org / apache / cassandra / service / FileCacheService . java <nl> new file mode 100644 <nl> index 0000000 . . 9dd1b15 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / service / FileCacheService . java <nl> @ @ - 0 , 0 + 1 , 139 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . service ; <nl> + <nl> + import java . util . Queue ; <nl> + import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . ConcurrentLinkedQueue ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . google . common . cache . Cache ; <nl> + import com . google . common . cache . CacheBuilder ; <nl> + import com . google . common . cache . RemovalListener ; <nl> + import com . google . common . cache . RemovalNotification ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . io . util . RandomAccessReader ; <nl> + import org . apache . cassandra . metrics . FileCacheMetrics ; <nl> + <nl> + public class FileCacheService <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( FileCacheService . class ) ; <nl> + <nl> + private static final long MEMORY _ USAGE _ THRESHOLD = DatabaseDescriptor . getFileCacheSizeInMB ( ) * 1024 * 1024 ; <nl> + private static final int AFTER _ ACCESS _ EXPIRATION = 512 ; / / in millis <nl> + <nl> + public static FileCacheService instance = new FileCacheService ( ) ; <nl> + <nl> + private final Cache < String , Queue < RandomAccessReader > > cache ; <nl> + private final FileCacheMetrics metrics = new FileCacheMetrics ( ) ; <nl> + public final Callable < Queue < RandomAccessReader > > cacheForPathCreator = new Callable < Queue < RandomAccessReader > > ( ) <nl> + { <nl> + @ Override <nl> + public Queue < RandomAccessReader > call ( ) throws Exception <nl> + { <nl> + return new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + protected FileCacheService ( ) <nl> + { <nl> + cache = CacheBuilder . < String , Queue < RandomAccessReader > > newBuilder ( ) <nl> + . expireAfterAccess ( AFTER _ ACCESS _ EXPIRATION , TimeUnit . MILLISECONDS ) <nl> + . concurrencyLevel ( DatabaseDescriptor . getConcurrentReaders ( ) ) <nl> + . removalListener ( new RemovalListener < String , Queue < RandomAccessReader > > ( ) <nl> + { <nl> + @ Override <nl> + public void onRemoval ( RemovalNotification < String , Queue < RandomAccessReader > > notification ) <nl> + { <nl> + Queue < RandomAccessReader > cachedInstances = notification . getValue ( ) ; <nl> + <nl> + if ( cachedInstances = = null ) <nl> + return ; <nl> + <nl> + for ( RandomAccessReader reader : cachedInstances ) <nl> + reader . deallocate ( ) ; <nl> + } <nl> + } ) <nl> + . build ( ) ; <nl> + } <nl> + <nl> + public RandomAccessReader get ( String path ) <nl> + { <nl> + metrics . requests . mark ( ) ; <nl> + <nl> + Queue < RandomAccessReader > instances = getCacheFor ( path ) ; <nl> + <nl> + if ( instances = = null ) <nl> + return null ; <nl> + <nl> + RandomAccessReader result = instances . poll ( ) ; <nl> + <nl> + if ( result ! = null ) <nl> + metrics . hits . mark ( ) ; <nl> + <nl> + return result ; <nl> + } <nl> + <nl> + private Queue < RandomAccessReader > getCacheFor ( String path ) <nl> + { <nl> + try <nl> + { <nl> + return cache . get ( path , cacheForPathCreator ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + / / if something bad happened , let ' s just carry on and return null <nl> + / / as dysfunctional queue should not interrupt normal operation <nl> + logger . debug ( " Exception fetching cache " , e ) ; <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> + <nl> + public void put ( RandomAccessReader instance ) <nl> + { <nl> + / / This wouldn ' t be precise sometimes when CRAR is used because <nl> + / / there is a way for users to dynamically change the size of the buffer , <nl> + / / but we don ' t expect that to happen frequently in production . <nl> + / / Doing accounting this way also allows us to avoid atomic CAS operation on read path . <nl> + long memoryUsage = ( cache . size ( ) + 1 ) * instance . getBufferSize ( ) ; <nl> + <nl> + if ( memoryUsage > = MEMORY _ USAGE _ THRESHOLD ) <nl> + instance . deallocate ( ) ; <nl> + else <nl> + getCacheFor ( instance . getPath ( ) ) . add ( instance ) ; <nl> + } <nl> + <nl> + public void invalidate ( String path ) <nl> + { <nl> + cache . invalidate ( path ) ; <nl> + } <nl> + <nl> + public long sizeInBytes ( ) <nl> + { <nl> + long n = 0 ; <nl> + for ( Queue < RandomAccessReader > queue : cache . asMap ( ) . values ( ) ) <nl> + for ( RandomAccessReader reader : queue ) <nl> + n + = reader . getBufferSize ( ) ; <nl> + return n ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a729d35 . . 532c958 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 11 . 2 
 + * Round buffer size to powers of 2 for the chunk cache ( CASSANDRA - 13897 ) 
 * Update jackson JSON jars ( CASSANDRA - 13949 ) 
 * Avoid locks when checking LCS fanout and if we should defrag ( CASSANDRA - 13930 ) 
 Merged from 3 . 0 : 
 diff - - git a / src / java / org / apache / cassandra / cache / ChunkCache . java b / src / java / org / apache / cassandra / cache / ChunkCache . java 
 index 15cf2ce . . 4e7f848 100644 
 - - - a / src / java / org / apache / cassandra / cache / ChunkCache . java 
 + + + b / src / java / org / apache / cassandra / cache / ChunkCache . java 
 @ @ - 41 , 6 + 41 , 7 @ @ public class ChunkCache 
 { 
 public static final int RESERVED _ POOL _ SPACE _ IN _ MB = 32 ; 
 public static final long cacheSize = 1024L * 1024L * Math . max ( 0 , DatabaseDescriptor . getFileCacheSizeInMB ( ) - RESERVED _ POOL _ SPACE _ IN _ MB ) ; 
 + public static final boolean roundUp = DatabaseDescriptor . getFileCacheRoundUp ( ) ; 
 
 private static boolean enabled = cacheSize > 0 ; 
 public static final ChunkCache instance = enabled ? new ChunkCache ( ) : null ; 
 @ @ - 219 , 7 + 220 , 7 @ @ public class ChunkCache 
 { 
 source = file ; 
 int chunkSize = file . chunkSize ( ) ; 
 - assert Integer . bitCount ( chunkSize ) = = 1 ; / / Must be power of two 
 + assert Integer . bitCount ( chunkSize ) = = 1 : String . format ( " % d must be a power of two " , chunkSize ) ; 
 alignmentMask = - chunkSize ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 8fde816 . . 9489af9 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 265 , 6 + 265 , 17 @ @ public class Config 
 
 public Integer file _ cache _ size _ in _ mb ; 
 
 + / * * 
 + * Because of the current { @ link org . apache . cassandra . utils . memory . BufferPool } slab sizes of 64 kb , we 
 + * store in the file cache buffers that divide 64 kb , so we need to round the buffer sizes to powers of two . 
 + * This boolean controls weather they are rounded up or down . Set it to true to round up to the 
 + * next power of two , set it to false to round down to the previous power of two . Note that buffer sizes are 
 + * already rounded to 4 kb and capped between 4 kb minimum and 64 kb maximum by the { @ link DiskOptimizationStrategy } . 
 + * By default , this boolean is set to round down when { @ link # disk _ optimization _ strategy } is { @ code ssd } , 
 + * and to round up when it is { @ code spinning } . 
 + * / 
 + public Boolean file _ cache _ round _ up ; 
 + 
 public boolean buffer _ pool _ use _ heap _ if _ exhausted = true ; 
 
 public DiskOptimizationStrategy disk _ optimization _ strategy = DiskOptimizationStrategy . ssd ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 4ce2728 . . 27b8b95 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 409 , 6 + 409 , 10 @ @ public class DatabaseDescriptor 
 if ( conf . file _ cache _ size _ in _ mb = = null ) 
 conf . file _ cache _ size _ in _ mb = Math . min ( 512 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ) ; 
 
 + / / round down for SSDs and round up for spinning disks 
 + if ( conf . file _ cache _ round _ up = = null ) 
 + conf . file _ cache _ round _ up = conf . disk _ optimization _ strategy = = Config . DiskOptimizationStrategy . spinning ; 
 + 
 if ( conf . memtable _ offheap _ space _ in _ mb = = null ) 
 conf . memtable _ offheap _ space _ in _ mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ; 
 if ( conf . memtable _ offheap _ space _ in _ mb < 0 ) 
 @ @ - 2060 , 6 + 2064 , 18 @ @ public class DatabaseDescriptor 
 return conf . file _ cache _ size _ in _ mb ; 
 } 
 
 + public static boolean getFileCacheRoundUp ( ) 
 + { 
 + if ( conf . file _ cache _ round _ up = = null ) 
 + { 
 + / / In client mode the value is not set . 
 + assert DatabaseDescriptor . isClientInitialized ( ) ; 
 + return false ; 
 + } 
 + 
 + return conf . file _ cache _ round _ up ; 
 + } 
 + 
 public static boolean getBufferPoolUseHeapIfExhausted ( ) 
 { 
 return conf . buffer _ pool _ use _ heap _ if _ exhausted ; 
 diff - - git a / src / java / org / apache / cassandra / io / util / DiskOptimizationStrategy . java b / src / java / org / apache / cassandra / io / util / DiskOptimizationStrategy . java 
 index e10342d . . 272291e 100644 
 - - - a / src / java / org / apache / cassandra / io / util / DiskOptimizationStrategy . java 
 + + + b / src / java / org / apache / cassandra / io / util / DiskOptimizationStrategy . java 
 @ @ - 20 , 6 + 20 , 9 @ @ package org . apache . cassandra . io . util ; 
 
 public interface DiskOptimizationStrategy 
 { 
 + int MIN _ BUFFER _ SIZE = 1 < < 12 ; / / 4096 , the typical size of a page in the OS cache 
 + int MIN _ BUFFER _ SIZE _ MASK = MIN _ BUFFER _ SIZE - 1 ; 
 + 
 / / The maximum buffer size , we will never buffer more than this size . Further , 
 / / when the limiter is not null , i . e . when throttling is enabled , we read exactly 
 / / this size , since when throttling the intention is to eventually read everything , 
 @ @ - 40 , 9 + 43 , 32 @ @ public interface DiskOptimizationStrategy 
 default int roundBufferSize ( long size ) 
 { 
 if ( size < = 0 ) 
 - return 4096 ; 
 + return MIN _ BUFFER _ SIZE ; 
 
 - size = ( size + 4095 ) & ~ 4095 ; 
 + size = ( size + MIN _ BUFFER _ SIZE _ MASK ) & ~ MIN _ BUFFER _ SIZE _ MASK ; 
 return ( int ) Math . min ( size , MAX _ BUFFER _ SIZE ) ; 
 } 
 + 
 + / * * 
 + * Round either up or down to the next power of two , which is required by the 
 + * { @ link org . apache . cassandra . cache . ChunkCache . CachingRebufferer } , but capping between { @ link # MIN _ BUFFER _ SIZE } 
 + * and { @ link # MAX _ BUFFER _ SIZE } . 
 + * 
 + * @ param size - the size to round to a power of two , normally this is a buffer size that was previously 
 + * returned by a { @ link # bufferSize ( long ) } . 
 + * @ param roundUp - whether to round up or down 
 + * 
 + * @ return a value rounded to a power of two but never bigger than { @ link # MAX _ BUFFER _ SIZE } or smaller than { @ link # MIN _ BUFFER _ SIZE } . 
 + * / 
 + static int roundForCaching ( int size , boolean roundUp ) 
 + { 
 + if ( size < = MIN _ BUFFER _ SIZE ) 
 + return MIN _ BUFFER _ SIZE ; 
 + 
 + int ret = roundUp 
 + ? 1 < < ( 32 - Integer . numberOfLeadingZeros ( size - 1 ) ) 
 + : Integer . highestOneBit ( size ) ; 
 + 
 + return Math . min ( MAX _ BUFFER _ SIZE , ret ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / util / FileHandle . java b / src / java / org / apache / cassandra / io / util / FileHandle . java 
 index 9e03d3b . . a3afc2f 100644 
 - - - a / src / java / org / apache / cassandra / io / util / FileHandle . java 
 + + + b / src / java / org / apache / cassandra / io / util / FileHandle . java 
 @ @ - 378 , 7 + 378 , 8 @ @ public class FileHandle extends SharedCloseableImpl 
 } 
 else 
 { 
 - rebuffererFactory = maybeCached ( new SimpleChunkReader ( channelCopy , length , bufferType , bufferSize ) ) ; 
 + int chunkSize = DiskOptimizationStrategy . roundForCaching ( bufferSize , ChunkCache . roundUp ) ; 
 + rebuffererFactory = maybeCached ( new SimpleChunkReader ( channelCopy , length , bufferType , chunkSize ) ) ; 
 } 
 } 
 Cleanup cleanup = new Cleanup ( channelCopy , rebuffererFactory , compressionMetadata , chunkCache ) ; 
 diff - - git a / test / unit / org / apache / cassandra / io / util / DiskOptimizationStrategyTest . java b / test / unit / org / apache / cassandra / io / util / DiskOptimizationStrategyTest . java 
 index 986df96 . . ed1f948 100644 
 - - - a / test / unit / org / apache / cassandra / io / util / DiskOptimizationStrategyTest . java 
 + + + b / test / unit / org / apache / cassandra / io / util / DiskOptimizationStrategyTest . java 
 @ @ - 82 , 4 + 82 , 58 @ @ public class DiskOptimizationStrategyTest 
 assertEquals ( 8192 , strategy . bufferSize ( 4096 ) ) ; 
 assertEquals ( 12288 , strategy . bufferSize ( 4097 ) ) ; 
 } 
 + 
 + @ Test 
 + public void testRoundUpForCaching ( ) 
 + { 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( - 1 , true ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 0 , true ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 1 , true ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4095 , true ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4096 , true ) ) ; 
 + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 4097 , true ) ) ; 
 + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 4098 , true ) ) ; 
 + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 8192 , true ) ) ; 
 + assertEquals ( 16384 , DiskOptimizationStrategy . roundForCaching ( 8193 , true ) ) ; 
 + assertEquals ( 16384 , DiskOptimizationStrategy . roundForCaching ( 12288 , true ) ) ; 
 + assertEquals ( 16384 , DiskOptimizationStrategy . roundForCaching ( 16384 , true ) ) ; 
 + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 65536 , true ) ) ; 
 + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 65537 , true ) ) ; 
 + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 131072 , true ) ) ; 
 + 
 + for ( int cs = 4096 ; cs < 65536 ; cs < < = 1 ) / / 4096 , 8192 , 12288 , . . . , 65536 
 + { 
 + for ( int i = ( cs - 4095 ) ; i < = cs ; i + + ) / / 1 - > 4096 , 4097 - > 8192 , . . . 
 + { 
 + assertEquals ( cs , DiskOptimizationStrategy . roundForCaching ( i , true ) ) ; 
 + } 
 + } 
 + } 
 + 
 + @ Test 
 + public void testRoundDownForCaching ( ) 
 + { 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( - 1 , false ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 0 , false ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 1 , false ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4095 , false ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4096 , false ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4097 , false ) ) ; 
 + assertEquals ( 4096 , DiskOptimizationStrategy . roundForCaching ( 4098 , false ) ) ; 
 + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 8192 , false ) ) ; 
 + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 8193 , false ) ) ; 
 + assertEquals ( 8192 , DiskOptimizationStrategy . roundForCaching ( 12288 , false ) ) ; 
 + assertEquals ( 16384 , DiskOptimizationStrategy . roundForCaching ( 16384 , false ) ) ; 
 + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 65536 , false ) ) ; 
 + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 65537 , false ) ) ; 
 + assertEquals ( 65536 , DiskOptimizationStrategy . roundForCaching ( 131072 , false ) ) ; 
 + 
 + for ( int cs = 4096 ; cs < 65536 ; cs < < = 1 ) / / 4096 , 8192 , 12288 , . . . , 65536 
 + { 
 + for ( int i = cs ; i < cs * 2 - 1 ; i + + ) / / 4096 - > 8191 , 8192 - > 12287 , . . . 
 + { 
 + assertEquals ( cs , DiskOptimizationStrategy . roundForCaching ( i , false ) ) ; 
 + } 
 + } 
 + } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2192fe9 . . c2a55df 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 20 , 6 + 20 , 7 @ @ 
 * Fix potential AssertionError during tracing ( CASSANDRA - 6041 ) 
 * Fix NPE in sstablesplit ( CASSANDRA - 6027 ) 
 Merged from 1 . 2 : 
 + * add file _ cache _ size _ in _ mb setting ( CASSANDRA - 5661 ) 
 * Tuning knobs for dealing with large blobs and many CFs ( CASSANDRA - 5982 ) 
 * ( Hadoop ) Fix CQLRW for thrift tables ( CASSANDRA - 6002 ) 
 * Fix possible divide - by - zero in HHOM ( CASSANDRA - 5990 ) 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 4decf6c . . df4501e 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 238 , 6 + 238 , 10 @ @ seed _ provider : 
 concurrent _ reads : 32 
 concurrent _ writes : 32 
 
 + # Total memory to use for sstable - reading buffers . Defaults to 
 + # the smaller of 1 / 4 of heap or 512MB . 
 + # file _ cache _ size _ in _ mb : 512 
 + 
 # Total memory to use for memtables . Cassandra will flush the largest 
 # memtable when this much memory is used . 
 # If omitted , Cassandra will set it to 1 / 3 of the heap . 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index dd0728c . . 0414269 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 167 , 12 + 167 , 14 @ @ public class Config 
 public String memory _ allocator = NativeAllocator . class . getSimpleName ( ) ; 
 public boolean populate _ io _ cache _ on _ flush = false ; 
 
 - public boolean inter _ dc _ tcp _ nodelay = false ; 
 - 
 private static boolean isClientMode = false ; 
 
 public boolean preheat _ kernel _ page _ cache = false ; 
 
 + public Integer file _ cache _ size _ in _ mb ; 
 + 
 + public boolean inter _ dc _ tcp _ nodelay = true ; 
 + 
 public String memtable _ allocator = " SlabAllocator " ; 
 
 private static boolean outboundBindAny = false ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index c2f3fa6 . . b3eeca6 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 245 , 6 + 245 , 9 @ @ public class DatabaseDescriptor 
 throw new ConfigurationException ( " concurrent _ replicates must be at least 2 " ) ; 
 } 
 
 + if ( conf . file _ cache _ size _ in _ mb = = null ) 
 + conf . file _ cache _ size _ in _ mb = Math . min ( 512 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ) ; 
 + 
 if ( conf . memtable _ total _ space _ in _ mb = = null ) 
 conf . memtable _ total _ space _ in _ mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 3 * 1048576 ) ) ; 
 if ( conf . memtable _ total _ space _ in _ mb < = 0 ) 
 @ @ - 1137 , 6 + 1140 , 11 @ @ public class DatabaseDescriptor 
 return conf . memtable _ flush _ queue _ size ; 
 } 
 
 + public static int getFileCacheSizeInMB ( ) 
 + { 
 + return conf . file _ cache _ size _ in _ mb ; 
 + } 
 + 
 public static int getTotalMemtableSpaceInMB ( ) 
 { 
 / / should only be called if estimatesRealMemtableSize ( ) is true 
 diff - - git a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 index 4173d5a . . 892611c 100644 
 - - - a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 + + + b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 @ @ - 17 , 13 + 17 , 10 @ @ 
 * / 
 package org . apache . cassandra . io . util ; 
 
 - import java . util . Queue ; 
 - import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import org . apache . cassandra . service . FileCacheService ; 
 
 public abstract class PoolingSegmentedFile extends SegmentedFile 
 { 
 - public final Queue < RandomAccessReader > pool = new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; 
 - 
 protected PoolingSegmentedFile ( String path , long length ) 
 { 
 super ( path , length ) ; 
 @ @ - 36 , 9 + 33 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile 
 
 public FileDataInput getSegment ( long position ) 
 { 
 - RandomAccessReader reader = pool . poll ( ) ; 
 + RandomAccessReader reader = FileCacheService . instance . get ( path ) ; 
 + 
 if ( reader = = null ) 
 reader = createReader ( path ) ; 
 + 
 reader . seek ( position ) ; 
 return reader ; 
 } 
 @ @ - 47 , 12 + 46 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile 
 
 public void recycle ( RandomAccessReader reader ) 
 { 
 - pool . add ( reader ) ; 
 + FileCacheService . instance . put ( reader ) ; 
 } 
 
 public void cleanup ( ) 
 { 
 - for ( RandomAccessReader reader : pool ) 
 - reader . deallocate ( ) ; 
 + FileCacheService . instance . invalidate ( path ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 index bcf6ae3 . . 4ceb3c4 100644 
 - - - a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 + + + b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 @ @ - 152 , 6 + 152 , 11 @ @ public class RandomAccessReader extends RandomAccessFile implements FileDataInpu 
 return filePath ; 
 } 
 
 + public int getBufferSize ( ) 
 + { 
 + return buffer . length ; 
 + } 
 + 
 public void reset ( ) 
 { 
 seek ( markedPointer ) ; 
 diff - - git a / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java 
 new file mode 100644 
 index 0000000 . . 9b21de6 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java 
 @ @ - 0 , 0 + 1 , 64 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . metrics ; 
 + 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . yammer . metrics . Metrics ; 
 + import com . yammer . metrics . core . Gauge ; 
 + import com . yammer . metrics . core . Meter ; 
 + import com . yammer . metrics . core . MetricName ; 
 + import com . yammer . metrics . util . RatioGauge ; 
 + import org . apache . cassandra . service . FileCacheService ; 
 + 
 + public class FileCacheMetrics 
 + { 
 + / * * Total number of hits * / 
 + public final Meter hits ; 
 + / * * Total number of requests * / 
 + public final Meter requests ; 
 + / * * hit rate * / 
 + public final Gauge < Double > hitRate ; 
 + / * * Total size of file cache , in bytes * / 
 + public final Gauge < Long > size ; 
 + 
 + public FileCacheMetrics ( ) 
 + { 
 + hits = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Hits " ) , " hits " , TimeUnit . SECONDS ) ; 
 + requests = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Requests " ) , " requests " , TimeUnit . SECONDS ) ; 
 + hitRate = Metrics . newGauge ( new MetricName ( FileCacheService . class , " HitRate " ) , new RatioGauge ( ) 
 + { 
 + protected double getNumerator ( ) 
 + { 
 + return hits . count ( ) ; 
 + } 
 + 
 + protected double getDenominator ( ) 
 + { 
 + return requests . count ( ) ; 
 + } 
 + } ) ; 
 + size = Metrics . newGauge ( new MetricName ( FileCacheService . class , " Size " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + return FileCacheService . instance . sizeInBytes ( ) ; 
 + } 
 + } ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / service / FileCacheService . java b / src / java / org / apache / cassandra / service / FileCacheService . java 
 new file mode 100644 
 index 0000000 . . 9dd1b15 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / service / FileCacheService . java 
 @ @ - 0 , 0 + 1 , 139 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . service ; 
 + 
 + import java . util . Queue ; 
 + import java . util . concurrent . Callable ; 
 + import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import java . util . concurrent . ExecutionException ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . google . common . cache . Cache ; 
 + import com . google . common . cache . CacheBuilder ; 
 + import com . google . common . cache . RemovalListener ; 
 + import com . google . common . cache . RemovalNotification ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . io . util . RandomAccessReader ; 
 + import org . apache . cassandra . metrics . FileCacheMetrics ; 
 + 
 + public class FileCacheService 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( FileCacheService . class ) ; 
 + 
 + private static final long MEMORY _ USAGE _ THRESHOLD = DatabaseDescriptor . getFileCacheSizeInMB ( ) * 1024 * 1024 ; 
 + private static final int AFTER _ ACCESS _ EXPIRATION = 512 ; / / in millis 
 + 
 + public static FileCacheService instance = new FileCacheService ( ) ; 
 + 
 + private final Cache < String , Queue < RandomAccessReader > > cache ; 
 + private final FileCacheMetrics metrics = new FileCacheMetrics ( ) ; 
 + public final Callable < Queue < RandomAccessReader > > cacheForPathCreator = new Callable < Queue < RandomAccessReader > > ( ) 
 + { 
 + @ Override 
 + public Queue < RandomAccessReader > call ( ) throws Exception 
 + { 
 + return new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; 
 + } 
 + } ; 
 + 
 + protected FileCacheService ( ) 
 + { 
 + cache = CacheBuilder . < String , Queue < RandomAccessReader > > newBuilder ( ) 
 + . expireAfterAccess ( AFTER _ ACCESS _ EXPIRATION , TimeUnit . MILLISECONDS ) 
 + . concurrencyLevel ( DatabaseDescriptor . getConcurrentReaders ( ) ) 
 + . removalListener ( new RemovalListener < String , Queue < RandomAccessReader > > ( ) 
 + { 
 + @ Override 
 + public void onRemoval ( RemovalNotification < String , Queue < RandomAccessReader > > notification ) 
 + { 
 + Queue < RandomAccessReader > cachedInstances = notification . getValue ( ) ; 
 + 
 + if ( cachedInstances = = null ) 
 + return ; 
 + 
 + for ( RandomAccessReader reader : cachedInstances ) 
 + reader . deallocate ( ) ; 
 + } 
 + } ) 
 + . build ( ) ; 
 + } 
 + 
 + public RandomAccessReader get ( String path ) 
 + { 
 + metrics . requests . mark ( ) ; 
 + 
 + Queue < RandomAccessReader > instances = getCacheFor ( path ) ; 
 + 
 + if ( instances = = null ) 
 + return null ; 
 + 
 + RandomAccessReader result = instances . poll ( ) ; 
 + 
 + if ( result ! = null ) 
 + metrics . hits . mark ( ) ; 
 + 
 + return result ; 
 + } 
 + 
 + private Queue < RandomAccessReader > getCacheFor ( String path ) 
 + { 
 + try 
 + { 
 + return cache . get ( path , cacheForPathCreator ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + / / if something bad happened , let ' s just carry on and return null 
 + / / as dysfunctional queue should not interrupt normal operation 
 + logger . debug ( " Exception fetching cache " , e ) ; 
 + } 
 + 
 + return null ; 
 + } 
 + 
 + public void put ( RandomAccessReader instance ) 
 + { 
 + / / This wouldn ' t be precise sometimes when CRAR is used because 
 + / / there is a way for users to dynamically change the size of the buffer , 
 + / / but we don ' t expect that to happen frequently in production . 
 + / / Doing accounting this way also allows us to avoid atomic CAS operation on read path . 
 + long memoryUsage = ( cache . size ( ) + 1 ) * instance . getBufferSize ( ) ; 
 + 
 + if ( memoryUsage > = MEMORY _ USAGE _ THRESHOLD ) 
 + instance . deallocate ( ) ; 
 + else 
 + getCacheFor ( instance . getPath ( ) ) . add ( instance ) ; 
 + } 
 + 
 + public void invalidate ( String path ) 
 + { 
 + cache . invalidate ( path ) ; 
 + } 
 + 
 + public long sizeInBytes ( ) 
 + { 
 + long n = 0 ; 
 + for ( Queue < RandomAccessReader > queue : cache . asMap ( ) . values ( ) ) 
 + for ( RandomAccessReader reader : queue ) 
 + n + = reader . getBufferSize ( ) ; 
 + return n ; 
 + } 
 + }
