BLEU SCORE: 0.003976388001785548

TEST MSG: Improve avg aggregate functions
GENERATED MSG: clean up more ad - hoc timing message and move to mbeans . add TimedStatsDeque to

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e82eedd . . d5419c6 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 10 <nl> + * Improve avg aggregate functions ( CASSANDRA - 12417 ) <nl> * Preserve quoted reserved keyword column names in MV creation ( CASSANDRA - 11803 ) <nl> * nodetool stopdaemon errors out ( CASSANDRA - 12646 ) <nl> * Split materialized view mutations on build to prevent OOM ( CASSANDRA - 12268 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java b / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java <nl> index b2cae50 . . 441fa58 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import java . util . List ; <nl> <nl> import org . apache . cassandra . cql3 . CQL3Type ; <nl> import org . apache . cassandra . db . marshal . * ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> <nl> / * * <nl> * Factory methods for aggregate functions . <nl> @ @ - 114 , 7 + 115 , 7 @ @ public abstract class AggregateFcts <nl> <nl> public ByteBuffer compute ( int protocolVersion ) <nl> { <nl> - return ( ( LongType ) returnType ( ) ) . decompose ( count ) ; <nl> + return LongType . instance . decompose ( count ) ; <nl> } <nl> <nl> public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> @ @ - 155 , 7 + 156 , 7 @ @ public abstract class AggregateFcts <nl> if ( value = = null ) <nl> return ; <nl> <nl> - BigDecimal number = ( ( BigDecimal ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> + BigDecimal number = DecimalType . instance . compose ( value ) ; <nl> sum = sum . add ( number ) ; <nl> } <nl> } ; <nl> @ @ - 172 , 22 + 173 , 19 @ @ public abstract class AggregateFcts <nl> { <nl> return new Aggregate ( ) <nl> { <nl> - private BigDecimal sum = BigDecimal . ZERO ; <nl> + private BigDecimal avg = BigDecimal . ZERO ; <nl> <nl> private int count ; <nl> <nl> public void reset ( ) <nl> { <nl> count = 0 ; <nl> - sum = BigDecimal . ZERO ; <nl> + avg = BigDecimal . ZERO ; <nl> } <nl> <nl> public ByteBuffer compute ( int protocolVersion ) <nl> { <nl> - if ( count = = 0 ) <nl> - return DecimalType . instance . decompose ( BigDecimal . ZERO ) ; <nl> - <nl> - return DecimalType . instance . decompose ( sum . divide ( BigDecimal . valueOf ( count ) , BigDecimal . ROUND _ HALF _ EVEN ) ) ; <nl> + return DecimalType . instance . decompose ( avg ) ; <nl> } <nl> <nl> public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> @ @ - 199 , 7 + 197 , 9 @ @ public abstract class AggregateFcts <nl> <nl> count + + ; <nl> BigDecimal number = DecimalType . instance . compose ( value ) ; <nl> - sum = sum . add ( number ) ; <nl> + <nl> + / / avg = avg + ( value - sum ) / count . <nl> + avg = avg . add ( number . subtract ( avg ) . divide ( BigDecimal . valueOf ( count ) , RoundingMode . HALF _ EVEN ) ) ; <nl> } <nl> } ; <nl> } <nl> @ @ - 235 , 7 + 235 , 7 @ @ public abstract class AggregateFcts <nl> if ( value = = null ) <nl> return ; <nl> <nl> - BigInteger number = ( ( BigInteger ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> + BigInteger number = IntegerType . instance . compose ( value ) ; <nl> sum = sum . add ( number ) ; <nl> } <nl> } ; <nl> @ @ - 265 , 9 + 265 , 9 @ @ public abstract class AggregateFcts <nl> public ByteBuffer compute ( int protocolVersion ) <nl> { <nl> if ( count = = 0 ) <nl> - return ( ( IntegerType ) returnType ( ) ) . decompose ( BigInteger . ZERO ) ; <nl> + return IntegerType . instance . decompose ( BigInteger . ZERO ) ; <nl> <nl> - return ( ( IntegerType ) returnType ( ) ) . decompose ( sum . divide ( BigInteger . valueOf ( count ) ) ) ; <nl> + return IntegerType . instance . decompose ( sum . divide ( BigInteger . valueOf ( count ) ) ) ; <nl> } <nl> <nl> public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> @ @ - 329 , 35 + 329 , 11 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new Aggregate ( ) <nl> + return new AvgAggregate ( ByteType . instance ) <nl> { <nl> - private byte sum ; <nl> - <nl> - private int count ; <nl> - <nl> - public void reset ( ) <nl> + public ByteBuffer compute ( int protocolVersion ) throws InvalidRequestException <nl> { <nl> - count = 0 ; <nl> - sum = 0 ; <nl> - } <nl> - <nl> - public ByteBuffer compute ( int protocolVersion ) <nl> - { <nl> - int avg = count = = 0 ? 0 : sum / count ; <nl> - <nl> - return ( ( ByteType ) returnType ( ) ) . decompose ( ( byte ) avg ) ; <nl> - } <nl> - <nl> - public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> - { <nl> - ByteBuffer value = values . get ( 0 ) ; <nl> - <nl> - if ( value = = null ) <nl> - return ; <nl> - <nl> - count + + ; <nl> - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> - sum + = number . byteValue ( ) ; <nl> + return ByteType . instance . decompose ( ( byte ) computeInternal ( ) ) ; <nl> } <nl> } ; <nl> } <nl> @ @ - 407 , 35 + 383 , 11 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new Aggregate ( ) <nl> + return new AvgAggregate ( ShortType . instance ) <nl> { <nl> - private short sum ; <nl> - <nl> - private int count ; <nl> - <nl> - public void reset ( ) <nl> - { <nl> - count = 0 ; <nl> - sum = 0 ; <nl> - } <nl> - <nl> public ByteBuffer compute ( int protocolVersion ) <nl> { <nl> - int avg = count = = 0 ? 0 : sum / count ; <nl> - <nl> - return ( ( ShortType ) returnType ( ) ) . decompose ( ( short ) avg ) ; <nl> - } <nl> - <nl> - public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> - { <nl> - ByteBuffer value = values . get ( 0 ) ; <nl> - <nl> - if ( value = = null ) <nl> - return ; <nl> - <nl> - count + + ; <nl> - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> - sum + = number . shortValue ( ) ; <nl> + return ShortType . instance . decompose ( ( short ) computeInternal ( ) ) ; <nl> } <nl> } ; <nl> } <nl> @ @ - 485 , 35 + 437 , 11 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new Aggregate ( ) <nl> + return new AvgAggregate ( Int32Type . instance ) <nl> { <nl> - private int sum ; <nl> - <nl> - private int count ; <nl> - <nl> - public void reset ( ) <nl> - { <nl> - count = 0 ; <nl> - sum = 0 ; <nl> - } <nl> - <nl> public ByteBuffer compute ( int protocolVersion ) <nl> { <nl> - int avg = count = = 0 ? 0 : sum / count ; <nl> - <nl> - return ( ( Int32Type ) returnType ( ) ) . decompose ( avg ) ; <nl> - } <nl> - <nl> - public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> - { <nl> - ByteBuffer value = values . get ( 0 ) ; <nl> - <nl> - if ( value = = null ) <nl> - return ; <nl> - <nl> - count + + ; <nl> - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> - sum + = number . intValue ( ) ; <nl> + return Int32Type . instance . decompose ( ( int ) computeInternal ( ) ) ; <nl> } <nl> } ; <nl> } <nl> @ @ - 539 , 7 + 467 , 13 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new LongAvgAggregate ( ) ; <nl> + return new AvgAggregate ( LongType . instance ) <nl> + { <nl> + public ByteBuffer compute ( int protocolVersion ) <nl> + { <nl> + return LongType . instance . decompose ( computeInternal ( ) ) ; <nl> + } <nl> + } ; <nl> } <nl> } ; <nl> <nl> @ @ - 587 , 35 + 521 , 11 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new Aggregate ( ) <nl> + return new FloatAvgAggregate ( FloatType . instance ) <nl> { <nl> - private float sum ; <nl> - <nl> - private int count ; <nl> - <nl> - public void reset ( ) <nl> + public ByteBuffer compute ( int protocolVersion ) throws InvalidRequestException <nl> { <nl> - count = 0 ; <nl> - sum = 0 ; <nl> - } <nl> - <nl> - public ByteBuffer compute ( int protocolVersion ) <nl> - { <nl> - float avg = count = = 0 ? 0 : sum / count ; <nl> - <nl> - return ( ( FloatType ) returnType ( ) ) . decompose ( avg ) ; <nl> - } <nl> - <nl> - public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> - { <nl> - ByteBuffer value = values . get ( 0 ) ; <nl> - <nl> - if ( value = = null ) <nl> - return ; <nl> - <nl> - count + + ; <nl> - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> - sum + = number . floatValue ( ) ; <nl> + return FloatType . instance . decompose ( ( float ) computeInternal ( ) ) ; <nl> } <nl> } ; <nl> } <nl> @ @ - 656 , 6 + 566 , 95 @ @ public abstract class AggregateFcts <nl> } ; <nl> } <nl> } ; <nl> + / * * <nl> + * Average aggregate for floating point umbers , using double arithmetics and Kahan ' s algorithm <nl> + * to calculate sum by default , switching to BigDecimal on sum overflow . Resulting number is <nl> + * converted to corresponding representation by concrete implementations . <nl> + * / <nl> + private static abstract class FloatAvgAggregate implements AggregateFunction . Aggregate <nl> + { <nl> + private double sum ; <nl> + private double compensation ; <nl> + private double simpleSum ; <nl> + <nl> + private int count ; <nl> + <nl> + private BigDecimal bigSum = null ; <nl> + private boolean overflow = false ; <nl> + <nl> + private final AbstractType numberType ; <nl> + <nl> + public FloatAvgAggregate ( AbstractType numberType ) <nl> + { <nl> + this . numberType = numberType ; <nl> + } <nl> + <nl> + public void reset ( ) <nl> + { <nl> + sum = 0 ; <nl> + compensation = 0 ; <nl> + simpleSum = 0 ; <nl> + <nl> + count = 0 ; <nl> + bigSum = null ; <nl> + overflow = false ; <nl> + } <nl> + <nl> + public double computeInternal ( ) <nl> + { <nl> + if ( count = = 0 ) <nl> + return 0d ; <nl> + <nl> + if ( overflow ) <nl> + { <nl> + return bigSum . divide ( BigDecimal . valueOf ( count ) , RoundingMode . HALF _ EVEN ) . doubleValue ( ) ; <nl> + } <nl> + else <nl> + { <nl> + / / correctly compute final sum if it ' s NaN from consequently <nl> + / / adding same - signed infinite values . <nl> + double tmp = sum + compensation ; <nl> + if ( Double . isNaN ( tmp ) & & Double . isInfinite ( simpleSum ) ) <nl> + sum = simpleSum ; <nl> + else <nl> + sum = tmp ; <nl> + <nl> + return sum / count ; <nl> + } <nl> + } <nl> + <nl> + public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> + { <nl> + ByteBuffer value = values . get ( 0 ) ; <nl> + <nl> + if ( value = = null ) <nl> + return ; <nl> + <nl> + count + + ; <nl> + <nl> + double number = ( ( Number ) numberType . compose ( value ) ) . doubleValue ( ) ; <nl> + <nl> + if ( overflow ) <nl> + { <nl> + bigSum = bigSum . add ( BigDecimal . valueOf ( number ) ) ; <nl> + } <nl> + else <nl> + { <nl> + simpleSum + = number ; <nl> + double prev = sum ; <nl> + double tmp = number - compensation ; <nl> + double rounded = sum + tmp ; <nl> + compensation = ( rounded - sum ) - tmp ; <nl> + sum = rounded ; <nl> + <nl> + if ( Double . isInfinite ( sum ) & & ! Double . isInfinite ( number ) ) <nl> + { <nl> + overflow = true ; <nl> + bigSum = BigDecimal . valueOf ( prev ) . add ( BigDecimal . valueOf ( number ) ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> <nl> / * * <nl> * AVG function for double values . <nl> @ @ - 665 , 35 + 664 , 11 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new Aggregate ( ) <nl> + return new FloatAvgAggregate ( DoubleType . instance ) <nl> { <nl> - private double sum ; <nl> - <nl> - private int count ; <nl> - <nl> - public void reset ( ) <nl> - { <nl> - count = 0 ; <nl> - sum = 0 ; <nl> - } <nl> - <nl> - public ByteBuffer compute ( int protocolVersion ) <nl> - { <nl> - double avg = count = = 0 ? 0 : sum / count ; <nl> - <nl> - return ( ( DoubleType ) returnType ( ) ) . decompose ( avg ) ; <nl> - } <nl> - <nl> - public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> + public ByteBuffer compute ( int protocolVersion ) throws InvalidRequestException <nl> { <nl> - ByteBuffer value = values . get ( 0 ) ; <nl> - <nl> - if ( value = = null ) <nl> - return ; <nl> - <nl> - count + + ; <nl> - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> - sum + = number . doubleValue ( ) ; <nl> + return DoubleType . instance . decompose ( computeInternal ( ) ) ; <nl> } <nl> } ; <nl> } <nl> @ @ - 719 , 7 + 694 , 13 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new LongAvgAggregate ( ) ; <nl> + return new AvgAggregate ( LongType . instance ) <nl> + { <nl> + public ByteBuffer compute ( int protocolVersion ) throws InvalidRequestException <nl> + { <nl> + return CounterColumnType . instance . decompose ( computeInternal ( ) ) ; <nl> + } <nl> + } ; <nl> } <nl> } ; <nl> <nl> @ @ - 947 , 23 + 928 , 43 @ @ public abstract class AggregateFcts <nl> } <nl> } <nl> <nl> - private static class LongAvgAggregate implements AggregateFunction . Aggregate <nl> + / * * <nl> + * Average aggregate class , collecting the sum using long arithmetics , falling back <nl> + * to BigInteger on long overflow . Resulting number is converted to corresponding <nl> + * representation by concrete implementations . <nl> + * / <nl> + private static abstract class AvgAggregate implements AggregateFunction . Aggregate <nl> { <nl> private long sum ; <nl> - <nl> private int count ; <nl> + private BigInteger bigSum = null ; <nl> + private boolean overflow = false ; <nl> + <nl> + private final AbstractType numberType ; <nl> + <nl> + public AvgAggregate ( AbstractType type ) <nl> + { <nl> + this . numberType = type ; <nl> + } <nl> <nl> public void reset ( ) <nl> { <nl> count = 0 ; <nl> - sum = 0 ; <nl> + sum = 0L ; <nl> + overflow = false ; <nl> + bigSum = null ; <nl> } <nl> <nl> - public ByteBuffer compute ( int protocolVersion ) <nl> + long computeInternal ( ) <nl> { <nl> - long avg = count = = 0 ? 0 : sum / count ; <nl> - <nl> - return LongType . instance . decompose ( avg ) ; <nl> + if ( overflow ) <nl> + { <nl> + return bigSum . divide ( BigInteger . valueOf ( count ) ) . longValue ( ) ; <nl> + } <nl> + else <nl> + { <nl> + return count = = 0 ? 0 : ( sum / count ) ; <nl> + } <nl> } <nl> <nl> public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> @ @ - 974 , 8 + 975 , 22 @ @ public abstract class AggregateFcts <nl> return ; <nl> <nl> count + + ; <nl> - Number number = LongType . instance . compose ( value ) ; <nl> - sum + = number . longValue ( ) ; <nl> + long number = ( ( Number ) numberType . compose ( value ) ) . longValue ( ) ; <nl> + if ( overflow ) <nl> + { <nl> + bigSum = bigSum . add ( BigInteger . valueOf ( number ) ) ; <nl> + } <nl> + else <nl> + { <nl> + long prev = sum ; <nl> + sum + = number ; <nl> + <nl> + if ( ( ( prev ^ sum ) & ( number ^ sum ) ) < 0 ) <nl> + { <nl> + overflow = true ; <nl> + bigSum = BigInteger . valueOf ( prev ) . add ( BigInteger . valueOf ( number ) ) ; <nl> + } <nl> + } <nl> } <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> index 411d5ee . . 2e7dc1a 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . cql3 . validation . operations ; <nl> <nl> import java . math . BigDecimal ; <nl> import java . math . MathContext ; <nl> + import java . math . BigInteger ; <nl> import java . math . RoundingMode ; <nl> import java . nio . ByteBuffer ; <nl> import java . text . SimpleDateFormat ; <nl> @ @ - 28 , 6 + 29 , 7 @ @ import java . util . Date ; <nl> import java . util . Locale ; <nl> import java . util . TimeZone ; <nl> import java . util . concurrent . ThreadLocalRandom ; <nl> + import java . util . stream . DoubleStream ; <nl> <nl> import org . apache . commons . lang3 . time . DateUtils ; <nl> <nl> @ @ - 1969 , 4 + 1971 , 112 @ @ public class AggregationTest extends CQLTester <nl> assertRows ( execute ( " select avg ( val ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , <nl> row ( a ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testAggregatesWithoutOverflow ( ) throws Throwable <nl> + { <nl> + createTable ( " create table % s ( bucket int primary key , v1 tinyint , v2 smallint , v3 int , v4 bigint , v5 varint ) " ) ; <nl> + for ( int i = 1 ; i < = 3 ; i + + ) <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 , v4 , v5 ) values ( ? , ? , ? , ? , ? , ? ) " , i , <nl> + ( byte ) ( ( Byte . MAX _ VALUE / 3 ) + i ) , ( short ) ( ( Short . MAX _ VALUE / 3 ) + i ) , ( Integer . MAX _ VALUE / 3 ) + i , ( Long . MAX _ VALUE / 3 ) + i , <nl> + BigInteger . valueOf ( Long . MAX _ VALUE ) . add ( BigInteger . valueOf ( i ) ) ) ; <nl> + <nl> + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) , avg ( v4 ) , avg ( v5 ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , <nl> + row ( ( byte ) ( ( Byte . MAX _ VALUE / 3 ) + 2 ) , ( short ) ( ( Short . MAX _ VALUE / 3 ) + 2 ) , ( Integer . MAX _ VALUE / 3 ) + 2 , ( Long . MAX _ VALUE / 3 ) + 2 , <nl> + BigInteger . valueOf ( Long . MAX _ VALUE ) . add ( BigInteger . valueOf ( 2 ) ) ) ) ; <nl> + <nl> + for ( int i = 1 ; i < = 3 ; i + + ) <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 , v4 , v5 ) values ( ? , ? , ? , ? , ? , ? ) " , i + 3 , <nl> + ( byte ) ( 100 + i ) , ( short ) ( 100 + i ) , 100 + i , 100L + i , BigInteger . valueOf ( 100 + i ) ) ; <nl> + <nl> + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) , avg ( v4 ) , avg ( v5 ) from % s where bucket in ( 4 , 5 , 6 ) ; " ) , <nl> + row ( ( byte ) 102 , ( short ) 102 , 102 , 102L , BigInteger . valueOf ( 102 ) ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAggregateOverflow ( ) throws Throwable <nl> + { <nl> + createTable ( " create table % s ( bucket int primary key , v1 tinyint , v2 smallint , v3 int , v4 bigint , v5 varint ) " ) ; <nl> + for ( int i = 1 ; i < = 3 ; i + + ) <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 , v4 , v5 ) values ( ? , ? , ? , ? , ? , ? ) " , i , <nl> + Byte . MAX _ VALUE , Short . MAX _ VALUE , Integer . MAX _ VALUE , Long . MAX _ VALUE , BigInteger . valueOf ( Long . MAX _ VALUE ) . multiply ( BigInteger . valueOf ( 2 ) ) ) ; <nl> + <nl> + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) , avg ( v4 ) , avg ( v5 ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , <nl> + row ( Byte . MAX _ VALUE , Short . MAX _ VALUE , Integer . MAX _ VALUE , Long . MAX _ VALUE , BigInteger . valueOf ( Long . MAX _ VALUE ) . multiply ( BigInteger . valueOf ( 2 ) ) ) ) ; <nl> + <nl> + execute ( " truncate % s " ) ; <nl> + <nl> + for ( int i = 1 ; i < = 3 ; i + + ) <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 , v4 , v5 ) values ( ? , ? , ? , ? , ? , ? ) " , i , <nl> + Byte . MIN _ VALUE , Short . MIN _ VALUE , Integer . MIN _ VALUE , Long . MIN _ VALUE , BigInteger . valueOf ( Long . MIN _ VALUE ) . multiply ( BigInteger . valueOf ( 2 ) ) ) ; <nl> + <nl> + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) , avg ( v4 ) , avg ( v5 ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , <nl> + row ( Byte . MIN _ VALUE , Short . MIN _ VALUE , Integer . MIN _ VALUE , Long . MIN _ VALUE , BigInteger . valueOf ( Long . MIN _ VALUE ) . multiply ( BigInteger . valueOf ( 2 ) ) ) ) ; <nl> + <nl> + } <nl> + <nl> + @ Test <nl> + public void testDoubleAggregatesPrecision ( ) throws Throwable <nl> + { <nl> + createTable ( " create table % s ( bucket int primary key , v1 float , v2 double , v3 decimal ) " ) ; <nl> + <nl> + for ( int i = 1 ; i < = 3 ; i + + ) <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , i , <nl> + Float . MAX _ VALUE , Double . MAX _ VALUE , BigDecimal . valueOf ( Double . MAX _ VALUE ) . add ( BigDecimal . valueOf ( 2 ) ) ) ; <nl> + <nl> + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , <nl> + row ( Float . MAX _ VALUE , Double . MAX _ VALUE , BigDecimal . valueOf ( Double . MAX _ VALUE ) . add ( BigDecimal . valueOf ( 2 ) ) ) ) ; <nl> + <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , 4 , ( float ) 100 . 10 , 100 . 10 , BigDecimal . valueOf ( 100 . 10 ) ) ; <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , 5 , ( float ) 110 . 11 , 110 . 11 , BigDecimal . valueOf ( 110 . 11 ) ) ; <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , 6 , ( float ) 120 . 12 , 120 . 12 , BigDecimal . valueOf ( 120 . 12 ) ) ; <nl> + <nl> + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) from % s where bucket in ( 4 , 5 , 6 ) ; " ) , <nl> + row ( ( float ) 110 . 11 , 110 . 11 , BigDecimal . valueOf ( 110 . 11 ) ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNan ( ) throws Throwable <nl> + { <nl> + createTable ( " create table % s ( bucket int primary key , v1 float , v2 double ) " ) ; <nl> + <nl> + for ( int i = 1 ; i < = 10 ; i + + ) <nl> + if ( i ! = 5 ) <nl> + execute ( " insert into % s ( bucket , v1 , v2 ) values ( ? , ? , ? ) " , i , ( float ) i , ( double ) i ) ; <nl> + <nl> + execute ( " insert into % s ( bucket , v1 , v2 ) values ( ? , ? , ? ) " , 5 , Float . NaN , Double . NaN ) ; <nl> + <nl> + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) from % s where bucket in ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; " ) , <nl> + row ( Float . NaN , Double . NaN ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testInfinity ( ) throws Throwable <nl> + { <nl> + createTable ( " create table % s ( bucket int primary key , v1 float , v2 double ) " ) ; <nl> + for ( boolean positive : new boolean [ ] { true , false } ) <nl> + { <nl> + final float FLOAT _ INFINITY = positive ? Float . POSITIVE _ INFINITY : Float . NEGATIVE _ INFINITY ; <nl> + final double DOUBLE _ INFINITY = positive ? Double . POSITIVE _ INFINITY : Double . NEGATIVE _ INFINITY ; <nl> + <nl> + for ( int i = 1 ; i < = 10 ; i + + ) <nl> + if ( i ! = 5 ) <nl> + execute ( " insert into % s ( bucket , v1 , v2 ) values ( ? , ? , ? ) " , i , ( float ) i , ( double ) i ) ; <nl> + <nl> + execute ( " insert into % s ( bucket , v1 , v2 ) values ( ? , ? , ? ) " , 5 , FLOAT _ INFINITY , DOUBLE _ INFINITY ) ; <nl> + <nl> + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) from % s where bucket in ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; " ) , <nl> + row ( FLOAT _ INFINITY , DOUBLE _ INFINITY ) ) ; <nl> + execute ( " truncate % s " ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testSumPrecision ( ) throws Throwable <nl> + { <nl> + createTable ( " create table % s ( bucket int primary key , v1 float , v2 double , v3 decimal ) " ) ; <nl> + <nl> + for ( int i = 1 ; i < = 17 ; i + + ) <nl> + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , i , ( float ) ( i / 10 . 0 ) , i / 10 . 0 , BigDecimal . valueOf ( i / 10 . 0 ) ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 920edbc . . d26b83a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 54 , 6 + 54 , 7 @ @ import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . BloomFilter ; <nl> import org . apache . cassandra . utils . FileUtils ; <nl> import org . apache . cassandra . utils . LogUtil ; <nl> + import org . apache . cassandra . utils . TimedStatsDeque ; <nl> <nl> / * * <nl> * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) <nl> @ @ - 88 , 6 + 89 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> / * Flag indicates if a compaction is in process * / <nl> private AtomicBoolean isCompacting _ = new AtomicBoolean ( false ) ; <nl> <nl> + private TimedStatsDeque readStats _ = new TimedStatsDeque ( 60000 ) ; <nl> + private TimedStatsDeque diskReadStats _ = new TimedStatsDeque ( 60000 ) ; <nl> + <nl> ColumnFamilyStore ( String table , String columnFamily , boolean isSuper , int indexValue ) throws IOException <nl> { <nl> table _ = table ; <nl> @ @ - 482 , 15 + 486 , 20 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> public ColumnFamily getColumnFamily ( String key , String columnFamilyColumn , IFilter filter ) throws IOException <nl> { <nl> + long start = System . currentTimeMillis ( ) ; <nl> List < ColumnFamily > columnFamilies = getColumnFamilies ( key , columnFamilyColumn , filter ) ; <nl> - return resolveAndRemoveDeleted ( columnFamilies ) ; <nl> + ColumnFamily cf = resolveAndRemoveDeleted ( columnFamilies ) ; <nl> + readStats _ . add ( System . currentTimeMillis ( ) - start ) ; <nl> + return cf ; <nl> } <nl> <nl> public ColumnFamily getColumnFamily ( String key , String columnFamilyColumn , IFilter filter , int gcBefore ) throws IOException <nl> { <nl> + long start = System . currentTimeMillis ( ) ; <nl> List < ColumnFamily > columnFamilies = getColumnFamilies ( key , columnFamilyColumn , filter ) ; <nl> - ColumnFamily cf = ColumnFamily . resolve ( columnFamilies ) ; <nl> - return removeDeleted ( cf , gcBefore ) ; <nl> + ColumnFamily cf = removeDeleted ( ColumnFamily . resolve ( columnFamilies ) , gcBefore ) ; <nl> + readStats _ . add ( System . currentTimeMillis ( ) - start ) ; <nl> + return cf ; <nl> } <nl> <nl> / * * <nl> @ @ - 513 , 7 + 522 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> long start = System . currentTimeMillis ( ) ; <nl> getColumnFamilyFromDisk ( key , columnFamilyColumn , columnFamilies , filter ) ; <nl> - logger _ . debug ( " DISK TIME : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; <nl> + diskReadStats _ . add ( System . currentTimeMillis ( ) - start ) ; <nl> } <nl> return columnFamilies ; <nl> } <nl> @ @ - 1457 , 4 + 1466 , 19 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> return Collections . unmodifiableSet ( ssTables _ ) ; <nl> } <nl> + <nl> + public int getReadCount ( ) <nl> + { <nl> + return readStats _ . size ( ) ; <nl> + } <nl> + <nl> + public int getReadDiskHits ( ) <nl> + { <nl> + return diskReadStats _ . size ( ) ; <nl> + } <nl> + <nl> + public double getReadLatency ( ) <nl> + { <nl> + return readStats _ . mean ( ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java b / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java <nl> index 94e91c3 . . b39ec502 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java <nl> @ @ - 53 , 4 + 53 , 19 @ @ public interface ColumnFamilyStoreMBean <nl> * Triggers an immediate memtable flush . <nl> * / <nl> public void forceFlush ( ) ; <nl> + <nl> + / * * <nl> + * @ return the number of read operations on this column family in the last minute <nl> + * / <nl> + public int getReadCount ( ) ; <nl> + <nl> + / * * <nl> + * @ return the number of read operations on this column family that hit the disk in the last minute <nl> + * / <nl> + public int getReadDiskHits ( ) ; <nl> + <nl> + / * * <nl> + * @ return average latency per read operation in the last minute <nl> + * / <nl> + public double getReadLatency ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadVerbHandler . java b / src / java / org / apache / cassandra / db / ReadVerbHandler . java <nl> index 1c09767 . . f551d69 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadVerbHandler . java <nl> @ @ - 75 , 10 + 75 , 7 @ @ public class ReadVerbHandler implements IVerbHandler <nl> ReadCommand readCommand = ReadCommand . serializer ( ) . deserialize ( readCtx . bufIn _ ) ; <nl> Table table = Table . open ( readCommand . table ) ; <nl> Row row = null ; <nl> - long start = System . currentTimeMillis ( ) ; <nl> row = readCommand . getRow ( table ) ; <nl> - logger _ . info ( " getRow ( ) TIME : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; <nl> - start = System . currentTimeMillis ( ) ; <nl> ReadResponse readResponse = null ; <nl> if ( readCommand . isDigestQuery ( ) ) <nl> { <nl> @ @ - 92 , 28 + 89 , 24 @ @ public class ReadVerbHandler implements IVerbHandler <nl> / * serialize the ReadResponseMessage . * / <nl> readCtx . bufOut _ . reset ( ) ; <nl> <nl> - start = System . currentTimeMillis ( ) ; <nl> ReadResponse . serializer ( ) . serialize ( readResponse , readCtx . bufOut _ ) ; <nl> - logger _ . info ( " serialize TIME : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; <nl> <nl> byte [ ] bytes = new byte [ readCtx . bufOut _ . getLength ( ) ] ; <nl> - start = System . currentTimeMillis ( ) ; <nl> System . arraycopy ( readCtx . bufOut _ . getData ( ) , 0 , bytes , 0 , bytes . length ) ; <nl> - logger _ . info ( " copy TIME : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; <nl> <nl> - Message response = message . getReply ( StorageService . getLocalStorageEndPoint ( ) , bytes ) ; <nl> + Message response = message . getReply ( StorageService . getLocalStorageEndPoint ( ) , bytes ) ; <nl> + logger _ . debug ( " Read key " + readCommand . key + " ; sending response to " + message . getFrom ( ) ) ; <nl> MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; <nl> - logger _ . info ( " ReadVerbHandler TIME 2 : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; <nl> - <nl> + <nl> / * Do read repair if header of the message says so * / <nl> if ( message . getHeader ( ReadCommand . DO _ REPAIR ) ! = null ) <nl> { <nl> doReadRepair ( row , readCommand ) ; <nl> } <nl> } <nl> - catch ( IOException ex ) <nl> + catch ( IOException ex ) <nl> { <nl> - logger _ . info ( LogUtil . throwableToString ( ex ) ) ; <nl> + throw new RuntimeException ( ex ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / gms / FailureDetector . java b / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> index cb54bba . . 01b3d05 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> + + + b / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> @ @ - 33 , 6 + 33 , 7 @ @ import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . net . EndPoint ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . LogUtil ; <nl> + import org . apache . cassandra . utils . BoundedStatsDeque ; <nl> import org . apache . log4j . Logger ; <nl> <nl> / * * <nl> @ @ - 236 , 22 + 237 , 17 @ @ class ArrivalWindow <nl> { <nl> private static Logger logger _ = Logger . getLogger ( ArrivalWindow . class ) ; <nl> private double tLast _ = 0L ; <nl> - private Deque < Double > arrivalIntervals _ ; <nl> + private BoundedStatsDeque arrivalIntervals _ ; <nl> private int size _ ; <nl> <nl> ArrivalWindow ( int size ) <nl> { <nl> size _ = size ; <nl> - arrivalIntervals _ = new ArrayDeque < Double > ( size ) ; <nl> + arrivalIntervals _ = new BoundedStatsDeque ( size ) ; <nl> } <nl> <nl> synchronized void add ( double value ) <nl> { <nl> - if ( arrivalIntervals _ . size ( ) = = size _ ) <nl> - { <nl> - arrivalIntervals _ . remove ( ) ; <nl> - } <nl> - <nl> double interArrivalTime ; <nl> if ( tLast _ > 0L ) <nl> { <nl> @ @ - 267 , 41 + 263 , 27 @ @ class ArrivalWindow <nl> <nl> synchronized double sum ( ) <nl> { <nl> - double sum = 0d ; <nl> - for ( Double interval : arrivalIntervals _ ) <nl> - { <nl> - sum + = interval ; <nl> - } <nl> - return sum ; <nl> + return arrivalIntervals _ . sum ( ) ; <nl> } <nl> <nl> synchronized double sumOfDeviations ( ) <nl> { <nl> - double sumOfDeviations = 0d ; <nl> - double mean = mean ( ) ; <nl> - <nl> - for ( Double interval : arrivalIntervals _ ) <nl> - { <nl> - double v = interval - mean ; <nl> - sumOfDeviations + = v * v ; <nl> - } <nl> - <nl> - return sumOfDeviations ; <nl> + return arrivalIntervals _ . sumOfDeviations ( ) ; <nl> } <nl> <nl> synchronized double mean ( ) <nl> { <nl> - return sum ( ) / arrivalIntervals _ . size ( ) ; <nl> + return arrivalIntervals _ . mean ( ) ; <nl> } <nl> <nl> synchronized double variance ( ) <nl> - { <nl> - return sumOfDeviations ( ) / ( arrivalIntervals _ . size ( ) ) ; <nl> + { <nl> + return arrivalIntervals _ . variance ( ) ; <nl> } <nl> <nl> - double deviation ( ) <nl> - { <nl> - return Math . sqrt ( variance ( ) ) ; <nl> + double stdev ( ) <nl> + { <nl> + return arrivalIntervals _ . stdev ( ) ; <nl> } <nl> <nl> void clear ( ) <nl> @ @ - 311 , 13 + 293 , 9 @ @ class ArrivalWindow <nl> <nl> double p ( double t ) <nl> { <nl> - / / Stat stat = new Stat ( ) ; <nl> - double mean = mean ( ) ; <nl> - double deviation = deviation ( ) ; <nl> - / * Exponential CDF = 1 - e ^ - lambda * x * / <nl> + double mean = mean ( ) ; <nl> double exponent = ( - 1 ) * ( t ) / mean ; <nl> return 1 - ( 1 - Math . pow ( Math . E , exponent ) ) ; <nl> - / / return stat . gaussianCDF ( mean , deviation , t , Double . POSITIVE _ INFINITY ) ; <nl> } <nl> <nl> double phi ( long tnow ) <nl> @ @ - 335 , 7 + 313 , 7 @ @ class ArrivalWindow <nl> <nl> public String toString ( ) <nl> { <nl> - return StringUtils . join ( arrivalIntervals _ , " " ) ; <nl> + return StringUtils . join ( arrivalIntervals _ . iterator ( ) , " " ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / net / MessageDeliveryTask . java b / src / java / org / apache / cassandra / net / MessageDeliveryTask . java <nl> index 45fcc70 . . b76ad64 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessageDeliveryTask . java <nl> + + + b / src / java / org / apache / cassandra / net / MessageDeliveryTask . java <nl> @ @ - 39 , 18 + 39 , 11 @ @ public class MessageDeliveryTask implements Runnable <nl> <nl> public void run ( ) <nl> { <nl> - try <nl> - { <nl> - String verb = message _ . getVerb ( ) ; <nl> - IVerbHandler verbHandler = MessagingService . getMessagingInstance ( ) . getVerbHandler ( verb ) ; <nl> - if ( verbHandler ! = null ) <nl> - { <nl> - verbHandler . doVerb ( message _ ) ; <nl> - } <nl> - } <nl> - catch ( Throwable th ) <nl> + String verb = message _ . getVerb ( ) ; <nl> + IVerbHandler verbHandler = MessagingService . getMessagingInstance ( ) . getVerbHandler ( verb ) ; <nl> + if ( verbHandler ! = null ) <nl> { <nl> - logger _ . warn ( LogUtil . throwableToString ( th ) ) ; <nl> + verbHandler . doVerb ( message _ ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index c0b546d . . 00cb7f3 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . net . EndPoint ; <nl> import org . apache . cassandra . net . IAsyncResult ; <nl> import org . apache . cassandra . net . Message ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . utils . TimedStatsDeque ; <nl> import org . apache . log4j . Logger ; <nl> <nl> import javax . management . MBeanServer ; <nl> @ @ - 48 , 12 + 49 , 9 @ @ public class StorageProxy implements StorageProxyMBean <nl> private static Logger logger = Logger . getLogger ( StorageProxy . class ) ; <nl> <nl> / / mbean stuff <nl> - private static volatile long readLatency ; <nl> - private static volatile int readOperations ; <nl> - private static volatile long rangeLatency ; <nl> - private static volatile int rangeOperations ; <nl> - private static volatile long writeLatency ; <nl> - private static volatile int writeOperations ; <nl> + private static TimedStatsDeque readStats = new TimedStatsDeque ( 60000 ) ; <nl> + private static TimedStatsDeque rangeStats = new TimedStatsDeque ( 60000 ) ; <nl> + private static TimedStatsDeque writeStats = new TimedStatsDeque ( 60000 ) ; <nl> private StorageProxy ( ) { } <nl> static <nl> { <nl> @ @ - 119 , 7 + 117 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> 	 	 	 Map < EndPoint , EndPoint > endpointMap = StorageService . instance ( ) . getNStorageEndPointMap ( rm . key ( ) ) ; <nl> 	 	 	 / / TODO : throw a thrift exception if we do not have N nodes <nl> 	 	 	 Map < EndPoint , Message > messageMap = createWriteMessages ( rm , endpointMap ) ; <nl> - logger . debug ( " insert writing to [ " + StringUtils . join ( messageMap . keySet ( ) , " , " ) + " ] " ) ; <nl> + logger . debug ( " insert writing key " + rm . key ( ) + " to [ " + StringUtils . join ( messageMap . keySet ( ) , " , " ) + " ] " ) ; <nl> 	 	 	 for ( Map . Entry < EndPoint , Message > entry : messageMap . entrySet ( ) ) <nl> 	 	 	 { <nl> 	 	 	 	 MessagingService . getMessagingInstance ( ) . sendOneWay ( entry . getValue ( ) , entry . getKey ( ) ) ; <nl> @ @ - 131 , 12 + 129 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> finally <nl> { <nl> - if ( writeOperations + + = = Integer . MAX _ VALUE ) <nl> - { <nl> - writeOperations = 1 ; <nl> - writeLatency = 0 ; <nl> - } <nl> - writeLatency + = System . currentTimeMillis ( ) - startTime ; <nl> + writeStats . add ( System . currentTimeMillis ( ) - startTime ) ; <nl> } <nl> } <nl> <nl> @ @ - 154 , 12 + 147 , 11 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> try <nl> { <nl> - IResponseResolver < Boolean > writeResponseResolver = new WriteResponseResolver ( ) ; <nl> QuorumResponseHandler < Boolean > quorumResponseHandler = new QuorumResponseHandler < Boolean > ( <nl> DatabaseDescriptor . getReplicationFactor ( ) , <nl> - writeResponseResolver ) ; <nl> + new WriteResponseResolver ( ) ) ; <nl> EndPoint [ ] endpoints = StorageService . instance ( ) . getNStorageEndPoint ( rm . key ( ) ) ; <nl> - logger . debug ( " insertBlocking writing to [ " + StringUtils . join ( endpoints , " , " ) + " ] " ) ; <nl> + logger . debug ( " insertBlocking writing key " + rm . key ( ) + " to [ " + StringUtils . join ( endpoints , " , " ) + " ] " ) ; <nl> / / TODO : throw a thrift exception if we do not have N nodes <nl> <nl> MessagingService . getMessagingInstance ( ) . sendRR ( message , endpoints , quorumResponseHandler ) ; <nl> @ @ - 173 , 12 + 165 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> finally <nl> { <nl> - if ( writeOperations + + = = Integer . MAX _ VALUE ) <nl> - { <nl> - writeOperations = 1 ; <nl> - writeLatency = 0 ; <nl> - } <nl> - writeLatency + = System . currentTimeMillis ( ) - startTime ; <nl> + writeStats . add ( System . currentTimeMillis ( ) - startTime ) ; <nl> } <nl> } <nl> <nl> @ @ - 346 , 12 + 333 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> finally <nl> { <nl> - if ( readOperations + + = = Integer . MAX _ VALUE ) <nl> - { <nl> - readOperations = 1 ; <nl> - readLatency = 0 ; <nl> - } <nl> - readLatency + = System . currentTimeMillis ( ) - startTime ; <nl> + readStats . add ( System . currentTimeMillis ( ) - startTime ) ; <nl> } <nl> } <nl> <nl> @ @ - 385 , 12 + 367 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> row = strongRead ( command ) ; <nl> } <nl> <nl> - if ( readOperations + + = = Integer . MAX _ VALUE ) <nl> - { <nl> - readOperations = 1 ; <nl> - readLatency = 0 ; <nl> - } <nl> - readLatency + = System . currentTimeMillis ( ) - startTime ; <nl> + readStats . add ( System . currentTimeMillis ( ) - startTime ) ; <nl> <nl> return row ; <nl> } <nl> @ @ - 702 , 42 + 679 , 37 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> finally <nl> { <nl> - if ( rangeOperations + + = = Integer . MAX _ VALUE ) <nl> - { <nl> - rangeOperations = 1 ; <nl> - rangeLatency = 0 ; <nl> - } <nl> - rangeLatency + = System . currentTimeMillis ( ) - startTime ; <nl> + rangeStats . add ( System . currentTimeMillis ( ) - startTime ) ; <nl> } <nl> } <nl> <nl> public double getReadLatency ( ) <nl> { <nl> - return ( ( double ) readLatency ) / readOperations ; <nl> + return readStats . mean ( ) ; <nl> } <nl> <nl> public double getRangeLatency ( ) <nl> { <nl> - return ( ( double ) rangeLatency ) / rangeOperations ; <nl> + return rangeStats . mean ( ) ; <nl> } <nl> <nl> public double getWriteLatency ( ) <nl> { <nl> - return ( ( double ) writeLatency ) / writeOperations ; <nl> + return writeStats . mean ( ) ; <nl> } <nl> <nl> public int getReadOperations ( ) <nl> { <nl> - return readOperations ; <nl> + return readStats . size ( ) ; <nl> } <nl> <nl> public int getRangeOperations ( ) <nl> { <nl> - return rangeOperations ; <nl> + return rangeStats . size ( ) ; <nl> } <nl> <nl> public int getWriteOperations ( ) <nl> { <nl> - return writeOperations ; <nl> + return writeStats . size ( ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / utils / AbstractStatsDeque . java b / src / java / org / apache / cassandra / utils / AbstractStatsDeque . java <nl> new file mode 100644 <nl> index 0000000 . . 16521c0 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / AbstractStatsDeque . java <nl> @ @ - 0 , 0 + 1 , 55 @ @ <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . Iterator ; <nl> + import java . util . ArrayDeque ; <nl> + <nl> + public abstract class AbstractStatsDeque implements Iterable < Double > <nl> + { <nl> + public abstract Iterator < Double > iterator ( ) ; <nl> + public abstract int size ( ) ; <nl> + public abstract void add ( double o ) ; <nl> + public abstract void clear ( ) ; <nl> + <nl> + / / <nl> + / / statistical methods <nl> + / / <nl> + <nl> + public double sum ( ) <nl> + { <nl> + double sum = 0d ; <nl> + for ( Double interval : this ) <nl> + { <nl> + sum + = interval ; <nl> + } <nl> + return sum ; <nl> + } <nl> + <nl> + public double sumOfDeviations ( ) <nl> + { <nl> + double sumOfDeviations = 0d ; <nl> + double mean = mean ( ) ; <nl> + <nl> + for ( Double interval : this ) <nl> + { <nl> + double v = interval - mean ; <nl> + sumOfDeviations + = v * v ; <nl> + } <nl> + <nl> + return sumOfDeviations ; <nl> + } <nl> + <nl> + public double mean ( ) <nl> + { <nl> + return sum ( ) / size ( ) ; <nl> + } <nl> + <nl> + public double variance ( ) <nl> + { <nl> + return sumOfDeviations ( ) / size ( ) ; <nl> + } <nl> + <nl> + public double stdev ( ) <nl> + { <nl> + return Math . sqrt ( variance ( ) ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / utils / BoundedStatsDeque . java b / src / java / org / apache / cassandra / utils / BoundedStatsDeque . java <nl> new file mode 100644 <nl> index 0000000 . . 80f8af1 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / BoundedStatsDeque . java <nl> @ @ - 0 , 0 + 1 , 40 @ @ <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . ArrayDeque ; <nl> + import java . util . Iterator ; <nl> + <nl> + public class BoundedStatsDeque extends AbstractStatsDeque <nl> + { <nl> + private final int size ; <nl> + protected final ArrayDeque < Double > deque ; <nl> + <nl> + public BoundedStatsDeque ( int size ) <nl> + { <nl> + this . size = size ; <nl> + deque = new ArrayDeque < Double > ( size ) ; <nl> + } <nl> + <nl> + public Iterator < Double > iterator ( ) <nl> + { <nl> + return deque . iterator ( ) ; <nl> + } <nl> + <nl> + public int size ( ) <nl> + { <nl> + return deque . size ( ) ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + deque . clear ( ) ; <nl> + } <nl> + <nl> + public void add ( double o ) <nl> + { <nl> + if ( size = = deque . size ( ) ) <nl> + { <nl> + deque . remove ( ) ; <nl> + } <nl> + deque . add ( o ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / utils / TimedStatsDeque . java b / src / java / org / apache / cassandra / utils / TimedStatsDeque . java <nl> new file mode 100644 <nl> index 0000000 . . 914c459 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / TimedStatsDeque . java <nl> @ @ - 0 , 0 + 1 , 68 @ @ <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . Iterator ; <nl> + import java . util . ArrayDeque ; <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + <nl> + public class TimedStatsDeque extends AbstractStatsDeque <nl> + { <nl> + private final ArrayDeque < Tuple > deque ; <nl> + private final long period ; <nl> + <nl> + public TimedStatsDeque ( long period ) <nl> + { <nl> + this . period = period ; <nl> + deque = new ArrayDeque < Tuple > ( ) ; <nl> + } <nl> + <nl> + private void purge ( ) <nl> + { <nl> + long now = System . currentTimeMillis ( ) ; <nl> + while ( ! deque . isEmpty ( ) & & deque . peek ( ) . timestamp < now - period ) <nl> + { <nl> + deque . remove ( ) ; <nl> + } <nl> + } <nl> + <nl> + public Iterator < Double > iterator ( ) <nl> + { <nl> + purge ( ) ; <nl> + / / I expect this method to be called relatively infrequently so inefficiency is ok . <nl> + List < Double > L = new ArrayList < Double > ( deque . size ( ) ) ; <nl> + for ( Tuple t : deque ) <nl> + { <nl> + L . add ( t . value ) ; <nl> + } <nl> + return L . iterator ( ) ; <nl> + } <nl> + <nl> + public int size ( ) <nl> + { <nl> + purge ( ) ; <nl> + return deque . size ( ) ; <nl> + } <nl> + <nl> + public void add ( double o ) <nl> + { <nl> + purge ( ) ; <nl> + deque . add ( new Tuple ( o , System . currentTimeMillis ( ) ) ) ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + deque . clear ( ) ; <nl> + } <nl> + } <nl> + <nl> + class Tuple <nl> + { <nl> + public final double value ; <nl> + public final long timestamp ; <nl> + <nl> + public Tuple ( double value , long timestamp ) <nl> + { <nl> + this . value = value ; <nl> + this . timestamp = timestamp ; <nl> + } <nl> + } <nl> \ No newline at end of file

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e82eedd . . d5419c6 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 10 
 + * Improve avg aggregate functions ( CASSANDRA - 12417 ) 
 * Preserve quoted reserved keyword column names in MV creation ( CASSANDRA - 11803 ) 
 * nodetool stopdaemon errors out ( CASSANDRA - 12646 ) 
 * Split materialized view mutations on build to prevent OOM ( CASSANDRA - 12268 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java b / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java 
 index b2cae50 . . 441fa58 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import java . util . List ; 
 
 import org . apache . cassandra . cql3 . CQL3Type ; 
 import org . apache . cassandra . db . marshal . * ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 
 / * * 
 * Factory methods for aggregate functions . 
 @ @ - 114 , 7 + 115 , 7 @ @ public abstract class AggregateFcts 
 
 public ByteBuffer compute ( int protocolVersion ) 
 { 
 - return ( ( LongType ) returnType ( ) ) . decompose ( count ) ; 
 + return LongType . instance . decompose ( count ) ; 
 } 
 
 public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 @ @ - 155 , 7 + 156 , 7 @ @ public abstract class AggregateFcts 
 if ( value = = null ) 
 return ; 
 
 - BigDecimal number = ( ( BigDecimal ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 + BigDecimal number = DecimalType . instance . compose ( value ) ; 
 sum = sum . add ( number ) ; 
 } 
 } ; 
 @ @ - 172 , 22 + 173 , 19 @ @ public abstract class AggregateFcts 
 { 
 return new Aggregate ( ) 
 { 
 - private BigDecimal sum = BigDecimal . ZERO ; 
 + private BigDecimal avg = BigDecimal . ZERO ; 
 
 private int count ; 
 
 public void reset ( ) 
 { 
 count = 0 ; 
 - sum = BigDecimal . ZERO ; 
 + avg = BigDecimal . ZERO ; 
 } 
 
 public ByteBuffer compute ( int protocolVersion ) 
 { 
 - if ( count = = 0 ) 
 - return DecimalType . instance . decompose ( BigDecimal . ZERO ) ; 
 - 
 - return DecimalType . instance . decompose ( sum . divide ( BigDecimal . valueOf ( count ) , BigDecimal . ROUND _ HALF _ EVEN ) ) ; 
 + return DecimalType . instance . decompose ( avg ) ; 
 } 
 
 public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 @ @ - 199 , 7 + 197 , 9 @ @ public abstract class AggregateFcts 
 
 count + + ; 
 BigDecimal number = DecimalType . instance . compose ( value ) ; 
 - sum = sum . add ( number ) ; 
 + 
 + / / avg = avg + ( value - sum ) / count . 
 + avg = avg . add ( number . subtract ( avg ) . divide ( BigDecimal . valueOf ( count ) , RoundingMode . HALF _ EVEN ) ) ; 
 } 
 } ; 
 } 
 @ @ - 235 , 7 + 235 , 7 @ @ public abstract class AggregateFcts 
 if ( value = = null ) 
 return ; 
 
 - BigInteger number = ( ( BigInteger ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 + BigInteger number = IntegerType . instance . compose ( value ) ; 
 sum = sum . add ( number ) ; 
 } 
 } ; 
 @ @ - 265 , 9 + 265 , 9 @ @ public abstract class AggregateFcts 
 public ByteBuffer compute ( int protocolVersion ) 
 { 
 if ( count = = 0 ) 
 - return ( ( IntegerType ) returnType ( ) ) . decompose ( BigInteger . ZERO ) ; 
 + return IntegerType . instance . decompose ( BigInteger . ZERO ) ; 
 
 - return ( ( IntegerType ) returnType ( ) ) . decompose ( sum . divide ( BigInteger . valueOf ( count ) ) ) ; 
 + return IntegerType . instance . decompose ( sum . divide ( BigInteger . valueOf ( count ) ) ) ; 
 } 
 
 public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 @ @ - 329 , 35 + 329 , 11 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new Aggregate ( ) 
 + return new AvgAggregate ( ByteType . instance ) 
 { 
 - private byte sum ; 
 - 
 - private int count ; 
 - 
 - public void reset ( ) 
 + public ByteBuffer compute ( int protocolVersion ) throws InvalidRequestException 
 { 
 - count = 0 ; 
 - sum = 0 ; 
 - } 
 - 
 - public ByteBuffer compute ( int protocolVersion ) 
 - { 
 - int avg = count = = 0 ? 0 : sum / count ; 
 - 
 - return ( ( ByteType ) returnType ( ) ) . decompose ( ( byte ) avg ) ; 
 - } 
 - 
 - public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 - { 
 - ByteBuffer value = values . get ( 0 ) ; 
 - 
 - if ( value = = null ) 
 - return ; 
 - 
 - count + + ; 
 - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 - sum + = number . byteValue ( ) ; 
 + return ByteType . instance . decompose ( ( byte ) computeInternal ( ) ) ; 
 } 
 } ; 
 } 
 @ @ - 407 , 35 + 383 , 11 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new Aggregate ( ) 
 + return new AvgAggregate ( ShortType . instance ) 
 { 
 - private short sum ; 
 - 
 - private int count ; 
 - 
 - public void reset ( ) 
 - { 
 - count = 0 ; 
 - sum = 0 ; 
 - } 
 - 
 public ByteBuffer compute ( int protocolVersion ) 
 { 
 - int avg = count = = 0 ? 0 : sum / count ; 
 - 
 - return ( ( ShortType ) returnType ( ) ) . decompose ( ( short ) avg ) ; 
 - } 
 - 
 - public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 - { 
 - ByteBuffer value = values . get ( 0 ) ; 
 - 
 - if ( value = = null ) 
 - return ; 
 - 
 - count + + ; 
 - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 - sum + = number . shortValue ( ) ; 
 + return ShortType . instance . decompose ( ( short ) computeInternal ( ) ) ; 
 } 
 } ; 
 } 
 @ @ - 485 , 35 + 437 , 11 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new Aggregate ( ) 
 + return new AvgAggregate ( Int32Type . instance ) 
 { 
 - private int sum ; 
 - 
 - private int count ; 
 - 
 - public void reset ( ) 
 - { 
 - count = 0 ; 
 - sum = 0 ; 
 - } 
 - 
 public ByteBuffer compute ( int protocolVersion ) 
 { 
 - int avg = count = = 0 ? 0 : sum / count ; 
 - 
 - return ( ( Int32Type ) returnType ( ) ) . decompose ( avg ) ; 
 - } 
 - 
 - public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 - { 
 - ByteBuffer value = values . get ( 0 ) ; 
 - 
 - if ( value = = null ) 
 - return ; 
 - 
 - count + + ; 
 - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 - sum + = number . intValue ( ) ; 
 + return Int32Type . instance . decompose ( ( int ) computeInternal ( ) ) ; 
 } 
 } ; 
 } 
 @ @ - 539 , 7 + 467 , 13 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new LongAvgAggregate ( ) ; 
 + return new AvgAggregate ( LongType . instance ) 
 + { 
 + public ByteBuffer compute ( int protocolVersion ) 
 + { 
 + return LongType . instance . decompose ( computeInternal ( ) ) ; 
 + } 
 + } ; 
 } 
 } ; 
 
 @ @ - 587 , 35 + 521 , 11 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new Aggregate ( ) 
 + return new FloatAvgAggregate ( FloatType . instance ) 
 { 
 - private float sum ; 
 - 
 - private int count ; 
 - 
 - public void reset ( ) 
 + public ByteBuffer compute ( int protocolVersion ) throws InvalidRequestException 
 { 
 - count = 0 ; 
 - sum = 0 ; 
 - } 
 - 
 - public ByteBuffer compute ( int protocolVersion ) 
 - { 
 - float avg = count = = 0 ? 0 : sum / count ; 
 - 
 - return ( ( FloatType ) returnType ( ) ) . decompose ( avg ) ; 
 - } 
 - 
 - public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 - { 
 - ByteBuffer value = values . get ( 0 ) ; 
 - 
 - if ( value = = null ) 
 - return ; 
 - 
 - count + + ; 
 - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 - sum + = number . floatValue ( ) ; 
 + return FloatType . instance . decompose ( ( float ) computeInternal ( ) ) ; 
 } 
 } ; 
 } 
 @ @ - 656 , 6 + 566 , 95 @ @ public abstract class AggregateFcts 
 } ; 
 } 
 } ; 
 + / * * 
 + * Average aggregate for floating point umbers , using double arithmetics and Kahan ' s algorithm 
 + * to calculate sum by default , switching to BigDecimal on sum overflow . Resulting number is 
 + * converted to corresponding representation by concrete implementations . 
 + * / 
 + private static abstract class FloatAvgAggregate implements AggregateFunction . Aggregate 
 + { 
 + private double sum ; 
 + private double compensation ; 
 + private double simpleSum ; 
 + 
 + private int count ; 
 + 
 + private BigDecimal bigSum = null ; 
 + private boolean overflow = false ; 
 + 
 + private final AbstractType numberType ; 
 + 
 + public FloatAvgAggregate ( AbstractType numberType ) 
 + { 
 + this . numberType = numberType ; 
 + } 
 + 
 + public void reset ( ) 
 + { 
 + sum = 0 ; 
 + compensation = 0 ; 
 + simpleSum = 0 ; 
 + 
 + count = 0 ; 
 + bigSum = null ; 
 + overflow = false ; 
 + } 
 + 
 + public double computeInternal ( ) 
 + { 
 + if ( count = = 0 ) 
 + return 0d ; 
 + 
 + if ( overflow ) 
 + { 
 + return bigSum . divide ( BigDecimal . valueOf ( count ) , RoundingMode . HALF _ EVEN ) . doubleValue ( ) ; 
 + } 
 + else 
 + { 
 + / / correctly compute final sum if it ' s NaN from consequently 
 + / / adding same - signed infinite values . 
 + double tmp = sum + compensation ; 
 + if ( Double . isNaN ( tmp ) & & Double . isInfinite ( simpleSum ) ) 
 + sum = simpleSum ; 
 + else 
 + sum = tmp ; 
 + 
 + return sum / count ; 
 + } 
 + } 
 + 
 + public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 + { 
 + ByteBuffer value = values . get ( 0 ) ; 
 + 
 + if ( value = = null ) 
 + return ; 
 + 
 + count + + ; 
 + 
 + double number = ( ( Number ) numberType . compose ( value ) ) . doubleValue ( ) ; 
 + 
 + if ( overflow ) 
 + { 
 + bigSum = bigSum . add ( BigDecimal . valueOf ( number ) ) ; 
 + } 
 + else 
 + { 
 + simpleSum + = number ; 
 + double prev = sum ; 
 + double tmp = number - compensation ; 
 + double rounded = sum + tmp ; 
 + compensation = ( rounded - sum ) - tmp ; 
 + sum = rounded ; 
 + 
 + if ( Double . isInfinite ( sum ) & & ! Double . isInfinite ( number ) ) 
 + { 
 + overflow = true ; 
 + bigSum = BigDecimal . valueOf ( prev ) . add ( BigDecimal . valueOf ( number ) ) ; 
 + } 
 + } 
 + } 
 + } 
 
 / * * 
 * AVG function for double values . 
 @ @ - 665 , 35 + 664 , 11 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new Aggregate ( ) 
 + return new FloatAvgAggregate ( DoubleType . instance ) 
 { 
 - private double sum ; 
 - 
 - private int count ; 
 - 
 - public void reset ( ) 
 - { 
 - count = 0 ; 
 - sum = 0 ; 
 - } 
 - 
 - public ByteBuffer compute ( int protocolVersion ) 
 - { 
 - double avg = count = = 0 ? 0 : sum / count ; 
 - 
 - return ( ( DoubleType ) returnType ( ) ) . decompose ( avg ) ; 
 - } 
 - 
 - public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 + public ByteBuffer compute ( int protocolVersion ) throws InvalidRequestException 
 { 
 - ByteBuffer value = values . get ( 0 ) ; 
 - 
 - if ( value = = null ) 
 - return ; 
 - 
 - count + + ; 
 - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 - sum + = number . doubleValue ( ) ; 
 + return DoubleType . instance . decompose ( computeInternal ( ) ) ; 
 } 
 } ; 
 } 
 @ @ - 719 , 7 + 694 , 13 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new LongAvgAggregate ( ) ; 
 + return new AvgAggregate ( LongType . instance ) 
 + { 
 + public ByteBuffer compute ( int protocolVersion ) throws InvalidRequestException 
 + { 
 + return CounterColumnType . instance . decompose ( computeInternal ( ) ) ; 
 + } 
 + } ; 
 } 
 } ; 
 
 @ @ - 947 , 23 + 928 , 43 @ @ public abstract class AggregateFcts 
 } 
 } 
 
 - private static class LongAvgAggregate implements AggregateFunction . Aggregate 
 + / * * 
 + * Average aggregate class , collecting the sum using long arithmetics , falling back 
 + * to BigInteger on long overflow . Resulting number is converted to corresponding 
 + * representation by concrete implementations . 
 + * / 
 + private static abstract class AvgAggregate implements AggregateFunction . Aggregate 
 { 
 private long sum ; 
 - 
 private int count ; 
 + private BigInteger bigSum = null ; 
 + private boolean overflow = false ; 
 + 
 + private final AbstractType numberType ; 
 + 
 + public AvgAggregate ( AbstractType type ) 
 + { 
 + this . numberType = type ; 
 + } 
 
 public void reset ( ) 
 { 
 count = 0 ; 
 - sum = 0 ; 
 + sum = 0L ; 
 + overflow = false ; 
 + bigSum = null ; 
 } 
 
 - public ByteBuffer compute ( int protocolVersion ) 
 + long computeInternal ( ) 
 { 
 - long avg = count = = 0 ? 0 : sum / count ; 
 - 
 - return LongType . instance . decompose ( avg ) ; 
 + if ( overflow ) 
 + { 
 + return bigSum . divide ( BigInteger . valueOf ( count ) ) . longValue ( ) ; 
 + } 
 + else 
 + { 
 + return count = = 0 ? 0 : ( sum / count ) ; 
 + } 
 } 
 
 public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 @ @ - 974 , 8 + 975 , 22 @ @ public abstract class AggregateFcts 
 return ; 
 
 count + + ; 
 - Number number = LongType . instance . compose ( value ) ; 
 - sum + = number . longValue ( ) ; 
 + long number = ( ( Number ) numberType . compose ( value ) ) . longValue ( ) ; 
 + if ( overflow ) 
 + { 
 + bigSum = bigSum . add ( BigInteger . valueOf ( number ) ) ; 
 + } 
 + else 
 + { 
 + long prev = sum ; 
 + sum + = number ; 
 + 
 + if ( ( ( prev ^ sum ) & ( number ^ sum ) ) < 0 ) 
 + { 
 + overflow = true ; 
 + bigSum = BigInteger . valueOf ( prev ) . add ( BigInteger . valueOf ( number ) ) ; 
 + } 
 + } 
 } 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 index 411d5ee . . 2e7dc1a 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . cql3 . validation . operations ; 
 
 import java . math . BigDecimal ; 
 import java . math . MathContext ; 
 + import java . math . BigInteger ; 
 import java . math . RoundingMode ; 
 import java . nio . ByteBuffer ; 
 import java . text . SimpleDateFormat ; 
 @ @ - 28 , 6 + 29 , 7 @ @ import java . util . Date ; 
 import java . util . Locale ; 
 import java . util . TimeZone ; 
 import java . util . concurrent . ThreadLocalRandom ; 
 + import java . util . stream . DoubleStream ; 
 
 import org . apache . commons . lang3 . time . DateUtils ; 
 
 @ @ - 1969 , 4 + 1971 , 112 @ @ public class AggregationTest extends CQLTester 
 assertRows ( execute ( " select avg ( val ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , 
 row ( a ) ) ; 
 } 
 + 
 + @ Test 
 + public void testAggregatesWithoutOverflow ( ) throws Throwable 
 + { 
 + createTable ( " create table % s ( bucket int primary key , v1 tinyint , v2 smallint , v3 int , v4 bigint , v5 varint ) " ) ; 
 + for ( int i = 1 ; i < = 3 ; i + + ) 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 , v4 , v5 ) values ( ? , ? , ? , ? , ? , ? ) " , i , 
 + ( byte ) ( ( Byte . MAX _ VALUE / 3 ) + i ) , ( short ) ( ( Short . MAX _ VALUE / 3 ) + i ) , ( Integer . MAX _ VALUE / 3 ) + i , ( Long . MAX _ VALUE / 3 ) + i , 
 + BigInteger . valueOf ( Long . MAX _ VALUE ) . add ( BigInteger . valueOf ( i ) ) ) ; 
 + 
 + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) , avg ( v4 ) , avg ( v5 ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , 
 + row ( ( byte ) ( ( Byte . MAX _ VALUE / 3 ) + 2 ) , ( short ) ( ( Short . MAX _ VALUE / 3 ) + 2 ) , ( Integer . MAX _ VALUE / 3 ) + 2 , ( Long . MAX _ VALUE / 3 ) + 2 , 
 + BigInteger . valueOf ( Long . MAX _ VALUE ) . add ( BigInteger . valueOf ( 2 ) ) ) ) ; 
 + 
 + for ( int i = 1 ; i < = 3 ; i + + ) 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 , v4 , v5 ) values ( ? , ? , ? , ? , ? , ? ) " , i + 3 , 
 + ( byte ) ( 100 + i ) , ( short ) ( 100 + i ) , 100 + i , 100L + i , BigInteger . valueOf ( 100 + i ) ) ; 
 + 
 + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) , avg ( v4 ) , avg ( v5 ) from % s where bucket in ( 4 , 5 , 6 ) ; " ) , 
 + row ( ( byte ) 102 , ( short ) 102 , 102 , 102L , BigInteger . valueOf ( 102 ) ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testAggregateOverflow ( ) throws Throwable 
 + { 
 + createTable ( " create table % s ( bucket int primary key , v1 tinyint , v2 smallint , v3 int , v4 bigint , v5 varint ) " ) ; 
 + for ( int i = 1 ; i < = 3 ; i + + ) 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 , v4 , v5 ) values ( ? , ? , ? , ? , ? , ? ) " , i , 
 + Byte . MAX _ VALUE , Short . MAX _ VALUE , Integer . MAX _ VALUE , Long . MAX _ VALUE , BigInteger . valueOf ( Long . MAX _ VALUE ) . multiply ( BigInteger . valueOf ( 2 ) ) ) ; 
 + 
 + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) , avg ( v4 ) , avg ( v5 ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , 
 + row ( Byte . MAX _ VALUE , Short . MAX _ VALUE , Integer . MAX _ VALUE , Long . MAX _ VALUE , BigInteger . valueOf ( Long . MAX _ VALUE ) . multiply ( BigInteger . valueOf ( 2 ) ) ) ) ; 
 + 
 + execute ( " truncate % s " ) ; 
 + 
 + for ( int i = 1 ; i < = 3 ; i + + ) 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 , v4 , v5 ) values ( ? , ? , ? , ? , ? , ? ) " , i , 
 + Byte . MIN _ VALUE , Short . MIN _ VALUE , Integer . MIN _ VALUE , Long . MIN _ VALUE , BigInteger . valueOf ( Long . MIN _ VALUE ) . multiply ( BigInteger . valueOf ( 2 ) ) ) ; 
 + 
 + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) , avg ( v4 ) , avg ( v5 ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , 
 + row ( Byte . MIN _ VALUE , Short . MIN _ VALUE , Integer . MIN _ VALUE , Long . MIN _ VALUE , BigInteger . valueOf ( Long . MIN _ VALUE ) . multiply ( BigInteger . valueOf ( 2 ) ) ) ) ; 
 + 
 + } 
 + 
 + @ Test 
 + public void testDoubleAggregatesPrecision ( ) throws Throwable 
 + { 
 + createTable ( " create table % s ( bucket int primary key , v1 float , v2 double , v3 decimal ) " ) ; 
 + 
 + for ( int i = 1 ; i < = 3 ; i + + ) 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , i , 
 + Float . MAX _ VALUE , Double . MAX _ VALUE , BigDecimal . valueOf ( Double . MAX _ VALUE ) . add ( BigDecimal . valueOf ( 2 ) ) ) ; 
 + 
 + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) from % s where bucket in ( 1 , 2 , 3 ) ; " ) , 
 + row ( Float . MAX _ VALUE , Double . MAX _ VALUE , BigDecimal . valueOf ( Double . MAX _ VALUE ) . add ( BigDecimal . valueOf ( 2 ) ) ) ) ; 
 + 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , 4 , ( float ) 100 . 10 , 100 . 10 , BigDecimal . valueOf ( 100 . 10 ) ) ; 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , 5 , ( float ) 110 . 11 , 110 . 11 , BigDecimal . valueOf ( 110 . 11 ) ) ; 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , 6 , ( float ) 120 . 12 , 120 . 12 , BigDecimal . valueOf ( 120 . 12 ) ) ; 
 + 
 + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) , avg ( v3 ) from % s where bucket in ( 4 , 5 , 6 ) ; " ) , 
 + row ( ( float ) 110 . 11 , 110 . 11 , BigDecimal . valueOf ( 110 . 11 ) ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testNan ( ) throws Throwable 
 + { 
 + createTable ( " create table % s ( bucket int primary key , v1 float , v2 double ) " ) ; 
 + 
 + for ( int i = 1 ; i < = 10 ; i + + ) 
 + if ( i ! = 5 ) 
 + execute ( " insert into % s ( bucket , v1 , v2 ) values ( ? , ? , ? ) " , i , ( float ) i , ( double ) i ) ; 
 + 
 + execute ( " insert into % s ( bucket , v1 , v2 ) values ( ? , ? , ? ) " , 5 , Float . NaN , Double . NaN ) ; 
 + 
 + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) from % s where bucket in ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; " ) , 
 + row ( Float . NaN , Double . NaN ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testInfinity ( ) throws Throwable 
 + { 
 + createTable ( " create table % s ( bucket int primary key , v1 float , v2 double ) " ) ; 
 + for ( boolean positive : new boolean [ ] { true , false } ) 
 + { 
 + final float FLOAT _ INFINITY = positive ? Float . POSITIVE _ INFINITY : Float . NEGATIVE _ INFINITY ; 
 + final double DOUBLE _ INFINITY = positive ? Double . POSITIVE _ INFINITY : Double . NEGATIVE _ INFINITY ; 
 + 
 + for ( int i = 1 ; i < = 10 ; i + + ) 
 + if ( i ! = 5 ) 
 + execute ( " insert into % s ( bucket , v1 , v2 ) values ( ? , ? , ? ) " , i , ( float ) i , ( double ) i ) ; 
 + 
 + execute ( " insert into % s ( bucket , v1 , v2 ) values ( ? , ? , ? ) " , 5 , FLOAT _ INFINITY , DOUBLE _ INFINITY ) ; 
 + 
 + assertRows ( execute ( " select avg ( v1 ) , avg ( v2 ) from % s where bucket in ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; " ) , 
 + row ( FLOAT _ INFINITY , DOUBLE _ INFINITY ) ) ; 
 + execute ( " truncate % s " ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testSumPrecision ( ) throws Throwable 
 + { 
 + createTable ( " create table % s ( bucket int primary key , v1 float , v2 double , v3 decimal ) " ) ; 
 + 
 + for ( int i = 1 ; i < = 17 ; i + + ) 
 + execute ( " insert into % s ( bucket , v1 , v2 , v3 ) values ( ? , ? , ? , ? ) " , i , ( float ) ( i / 10 . 0 ) , i / 10 . 0 , BigDecimal . valueOf ( i / 10 . 0 ) ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 920edbc . . d26b83a 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 54 , 6 + 54 , 7 @ @ import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . BloomFilter ; 
 import org . apache . cassandra . utils . FileUtils ; 
 import org . apache . cassandra . utils . LogUtil ; 
 + import org . apache . cassandra . utils . TimedStatsDeque ; 
 
 / * * 
 * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) 
 @ @ - 88 , 6 + 89 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 / * Flag indicates if a compaction is in process * / 
 private AtomicBoolean isCompacting _ = new AtomicBoolean ( false ) ; 
 
 + private TimedStatsDeque readStats _ = new TimedStatsDeque ( 60000 ) ; 
 + private TimedStatsDeque diskReadStats _ = new TimedStatsDeque ( 60000 ) ; 
 + 
 ColumnFamilyStore ( String table , String columnFamily , boolean isSuper , int indexValue ) throws IOException 
 { 
 table _ = table ; 
 @ @ - 482 , 15 + 486 , 20 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 public ColumnFamily getColumnFamily ( String key , String columnFamilyColumn , IFilter filter ) throws IOException 
 { 
 + long start = System . currentTimeMillis ( ) ; 
 List < ColumnFamily > columnFamilies = getColumnFamilies ( key , columnFamilyColumn , filter ) ; 
 - return resolveAndRemoveDeleted ( columnFamilies ) ; 
 + ColumnFamily cf = resolveAndRemoveDeleted ( columnFamilies ) ; 
 + readStats _ . add ( System . currentTimeMillis ( ) - start ) ; 
 + return cf ; 
 } 
 
 public ColumnFamily getColumnFamily ( String key , String columnFamilyColumn , IFilter filter , int gcBefore ) throws IOException 
 { 
 + long start = System . currentTimeMillis ( ) ; 
 List < ColumnFamily > columnFamilies = getColumnFamilies ( key , columnFamilyColumn , filter ) ; 
 - ColumnFamily cf = ColumnFamily . resolve ( columnFamilies ) ; 
 - return removeDeleted ( cf , gcBefore ) ; 
 + ColumnFamily cf = removeDeleted ( ColumnFamily . resolve ( columnFamilies ) , gcBefore ) ; 
 + readStats _ . add ( System . currentTimeMillis ( ) - start ) ; 
 + return cf ; 
 } 
 
 / * * 
 @ @ - 513 , 7 + 522 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 long start = System . currentTimeMillis ( ) ; 
 getColumnFamilyFromDisk ( key , columnFamilyColumn , columnFamilies , filter ) ; 
 - logger _ . debug ( " DISK TIME : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; 
 + diskReadStats _ . add ( System . currentTimeMillis ( ) - start ) ; 
 } 
 return columnFamilies ; 
 } 
 @ @ - 1457 , 4 + 1466 , 19 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 return Collections . unmodifiableSet ( ssTables _ ) ; 
 } 
 + 
 + public int getReadCount ( ) 
 + { 
 + return readStats _ . size ( ) ; 
 + } 
 + 
 + public int getReadDiskHits ( ) 
 + { 
 + return diskReadStats _ . size ( ) ; 
 + } 
 + 
 + public double getReadLatency ( ) 
 + { 
 + return readStats _ . mean ( ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java b / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java 
 index 94e91c3 . . b39ec502 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java 
 @ @ - 53 , 4 + 53 , 19 @ @ public interface ColumnFamilyStoreMBean 
 * Triggers an immediate memtable flush . 
 * / 
 public void forceFlush ( ) ; 
 + 
 + / * * 
 + * @ return the number of read operations on this column family in the last minute 
 + * / 
 + public int getReadCount ( ) ; 
 + 
 + / * * 
 + * @ return the number of read operations on this column family that hit the disk in the last minute 
 + * / 
 + public int getReadDiskHits ( ) ; 
 + 
 + / * * 
 + * @ return average latency per read operation in the last minute 
 + * / 
 + public double getReadLatency ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / ReadVerbHandler . java b / src / java / org / apache / cassandra / db / ReadVerbHandler . java 
 index 1c09767 . . f551d69 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / db / ReadVerbHandler . java 
 @ @ - 75 , 10 + 75 , 7 @ @ public class ReadVerbHandler implements IVerbHandler 
 ReadCommand readCommand = ReadCommand . serializer ( ) . deserialize ( readCtx . bufIn _ ) ; 
 Table table = Table . open ( readCommand . table ) ; 
 Row row = null ; 
 - long start = System . currentTimeMillis ( ) ; 
 row = readCommand . getRow ( table ) ; 
 - logger _ . info ( " getRow ( ) TIME : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; 
 - start = System . currentTimeMillis ( ) ; 
 ReadResponse readResponse = null ; 
 if ( readCommand . isDigestQuery ( ) ) 
 { 
 @ @ - 92 , 28 + 89 , 24 @ @ public class ReadVerbHandler implements IVerbHandler 
 / * serialize the ReadResponseMessage . * / 
 readCtx . bufOut _ . reset ( ) ; 
 
 - start = System . currentTimeMillis ( ) ; 
 ReadResponse . serializer ( ) . serialize ( readResponse , readCtx . bufOut _ ) ; 
 - logger _ . info ( " serialize TIME : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; 
 
 byte [ ] bytes = new byte [ readCtx . bufOut _ . getLength ( ) ] ; 
 - start = System . currentTimeMillis ( ) ; 
 System . arraycopy ( readCtx . bufOut _ . getData ( ) , 0 , bytes , 0 , bytes . length ) ; 
 - logger _ . info ( " copy TIME : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; 
 
 - Message response = message . getReply ( StorageService . getLocalStorageEndPoint ( ) , bytes ) ; 
 + Message response = message . getReply ( StorageService . getLocalStorageEndPoint ( ) , bytes ) ; 
 + logger _ . debug ( " Read key " + readCommand . key + " ; sending response to " + message . getFrom ( ) ) ; 
 MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; 
 - logger _ . info ( " ReadVerbHandler TIME 2 : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; 
 - 
 + 
 / * Do read repair if header of the message says so * / 
 if ( message . getHeader ( ReadCommand . DO _ REPAIR ) ! = null ) 
 { 
 doReadRepair ( row , readCommand ) ; 
 } 
 } 
 - catch ( IOException ex ) 
 + catch ( IOException ex ) 
 { 
 - logger _ . info ( LogUtil . throwableToString ( ex ) ) ; 
 + throw new RuntimeException ( ex ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / gms / FailureDetector . java b / src / java / org / apache / cassandra / gms / FailureDetector . java 
 index cb54bba . . 01b3d05 100644 
 - - - a / src / java / org / apache / cassandra / gms / FailureDetector . java 
 + + + b / src / java / org / apache / cassandra / gms / FailureDetector . java 
 @ @ - 33 , 6 + 33 , 7 @ @ import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . net . EndPoint ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . LogUtil ; 
 + import org . apache . cassandra . utils . BoundedStatsDeque ; 
 import org . apache . log4j . Logger ; 
 
 / * * 
 @ @ - 236 , 22 + 237 , 17 @ @ class ArrivalWindow 
 { 
 private static Logger logger _ = Logger . getLogger ( ArrivalWindow . class ) ; 
 private double tLast _ = 0L ; 
 - private Deque < Double > arrivalIntervals _ ; 
 + private BoundedStatsDeque arrivalIntervals _ ; 
 private int size _ ; 
 
 ArrivalWindow ( int size ) 
 { 
 size _ = size ; 
 - arrivalIntervals _ = new ArrayDeque < Double > ( size ) ; 
 + arrivalIntervals _ = new BoundedStatsDeque ( size ) ; 
 } 
 
 synchronized void add ( double value ) 
 { 
 - if ( arrivalIntervals _ . size ( ) = = size _ ) 
 - { 
 - arrivalIntervals _ . remove ( ) ; 
 - } 
 - 
 double interArrivalTime ; 
 if ( tLast _ > 0L ) 
 { 
 @ @ - 267 , 41 + 263 , 27 @ @ class ArrivalWindow 
 
 synchronized double sum ( ) 
 { 
 - double sum = 0d ; 
 - for ( Double interval : arrivalIntervals _ ) 
 - { 
 - sum + = interval ; 
 - } 
 - return sum ; 
 + return arrivalIntervals _ . sum ( ) ; 
 } 
 
 synchronized double sumOfDeviations ( ) 
 { 
 - double sumOfDeviations = 0d ; 
 - double mean = mean ( ) ; 
 - 
 - for ( Double interval : arrivalIntervals _ ) 
 - { 
 - double v = interval - mean ; 
 - sumOfDeviations + = v * v ; 
 - } 
 - 
 - return sumOfDeviations ; 
 + return arrivalIntervals _ . sumOfDeviations ( ) ; 
 } 
 
 synchronized double mean ( ) 
 { 
 - return sum ( ) / arrivalIntervals _ . size ( ) ; 
 + return arrivalIntervals _ . mean ( ) ; 
 } 
 
 synchronized double variance ( ) 
 - { 
 - return sumOfDeviations ( ) / ( arrivalIntervals _ . size ( ) ) ; 
 + { 
 + return arrivalIntervals _ . variance ( ) ; 
 } 
 
 - double deviation ( ) 
 - { 
 - return Math . sqrt ( variance ( ) ) ; 
 + double stdev ( ) 
 + { 
 + return arrivalIntervals _ . stdev ( ) ; 
 } 
 
 void clear ( ) 
 @ @ - 311 , 13 + 293 , 9 @ @ class ArrivalWindow 
 
 double p ( double t ) 
 { 
 - / / Stat stat = new Stat ( ) ; 
 - double mean = mean ( ) ; 
 - double deviation = deviation ( ) ; 
 - / * Exponential CDF = 1 - e ^ - lambda * x * / 
 + double mean = mean ( ) ; 
 double exponent = ( - 1 ) * ( t ) / mean ; 
 return 1 - ( 1 - Math . pow ( Math . E , exponent ) ) ; 
 - / / return stat . gaussianCDF ( mean , deviation , t , Double . POSITIVE _ INFINITY ) ; 
 } 
 
 double phi ( long tnow ) 
 @ @ - 335 , 7 + 313 , 7 @ @ class ArrivalWindow 
 
 public String toString ( ) 
 { 
 - return StringUtils . join ( arrivalIntervals _ , " " ) ; 
 + return StringUtils . join ( arrivalIntervals _ . iterator ( ) , " " ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / net / MessageDeliveryTask . java b / src / java / org / apache / cassandra / net / MessageDeliveryTask . java 
 index 45fcc70 . . b76ad64 100644 
 - - - a / src / java / org / apache / cassandra / net / MessageDeliveryTask . java 
 + + + b / src / java / org / apache / cassandra / net / MessageDeliveryTask . java 
 @ @ - 39 , 18 + 39 , 11 @ @ public class MessageDeliveryTask implements Runnable 
 
 public void run ( ) 
 { 
 - try 
 - { 
 - String verb = message _ . getVerb ( ) ; 
 - IVerbHandler verbHandler = MessagingService . getMessagingInstance ( ) . getVerbHandler ( verb ) ; 
 - if ( verbHandler ! = null ) 
 - { 
 - verbHandler . doVerb ( message _ ) ; 
 - } 
 - } 
 - catch ( Throwable th ) 
 + String verb = message _ . getVerb ( ) ; 
 + IVerbHandler verbHandler = MessagingService . getMessagingInstance ( ) . getVerbHandler ( verb ) ; 
 + if ( verbHandler ! = null ) 
 { 
 - logger _ . warn ( LogUtil . throwableToString ( th ) ) ; 
 + verbHandler . doVerb ( message _ ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index c0b546d . . 00cb7f3 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . net . EndPoint ; 
 import org . apache . cassandra . net . IAsyncResult ; 
 import org . apache . cassandra . net . Message ; 
 import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . utils . TimedStatsDeque ; 
 import org . apache . log4j . Logger ; 
 
 import javax . management . MBeanServer ; 
 @ @ - 48 , 12 + 49 , 9 @ @ public class StorageProxy implements StorageProxyMBean 
 private static Logger logger = Logger . getLogger ( StorageProxy . class ) ; 
 
 / / mbean stuff 
 - private static volatile long readLatency ; 
 - private static volatile int readOperations ; 
 - private static volatile long rangeLatency ; 
 - private static volatile int rangeOperations ; 
 - private static volatile long writeLatency ; 
 - private static volatile int writeOperations ; 
 + private static TimedStatsDeque readStats = new TimedStatsDeque ( 60000 ) ; 
 + private static TimedStatsDeque rangeStats = new TimedStatsDeque ( 60000 ) ; 
 + private static TimedStatsDeque writeStats = new TimedStatsDeque ( 60000 ) ; 
 private StorageProxy ( ) { } 
 static 
 { 
 @ @ - 119 , 7 + 117 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 	 	 	 Map < EndPoint , EndPoint > endpointMap = StorageService . instance ( ) . getNStorageEndPointMap ( rm . key ( ) ) ; 
 	 	 	 / / TODO : throw a thrift exception if we do not have N nodes 
 	 	 	 Map < EndPoint , Message > messageMap = createWriteMessages ( rm , endpointMap ) ; 
 - logger . debug ( " insert writing to [ " + StringUtils . join ( messageMap . keySet ( ) , " , " ) + " ] " ) ; 
 + logger . debug ( " insert writing key " + rm . key ( ) + " to [ " + StringUtils . join ( messageMap . keySet ( ) , " , " ) + " ] " ) ; 
 	 	 	 for ( Map . Entry < EndPoint , Message > entry : messageMap . entrySet ( ) ) 
 	 	 	 { 
 	 	 	 	 MessagingService . getMessagingInstance ( ) . sendOneWay ( entry . getValue ( ) , entry . getKey ( ) ) ; 
 @ @ - 131 , 12 + 129 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 finally 
 { 
 - if ( writeOperations + + = = Integer . MAX _ VALUE ) 
 - { 
 - writeOperations = 1 ; 
 - writeLatency = 0 ; 
 - } 
 - writeLatency + = System . currentTimeMillis ( ) - startTime ; 
 + writeStats . add ( System . currentTimeMillis ( ) - startTime ) ; 
 } 
 } 
 
 @ @ - 154 , 12 + 147 , 11 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 try 
 { 
 - IResponseResolver < Boolean > writeResponseResolver = new WriteResponseResolver ( ) ; 
 QuorumResponseHandler < Boolean > quorumResponseHandler = new QuorumResponseHandler < Boolean > ( 
 DatabaseDescriptor . getReplicationFactor ( ) , 
 - writeResponseResolver ) ; 
 + new WriteResponseResolver ( ) ) ; 
 EndPoint [ ] endpoints = StorageService . instance ( ) . getNStorageEndPoint ( rm . key ( ) ) ; 
 - logger . debug ( " insertBlocking writing to [ " + StringUtils . join ( endpoints , " , " ) + " ] " ) ; 
 + logger . debug ( " insertBlocking writing key " + rm . key ( ) + " to [ " + StringUtils . join ( endpoints , " , " ) + " ] " ) ; 
 / / TODO : throw a thrift exception if we do not have N nodes 
 
 MessagingService . getMessagingInstance ( ) . sendRR ( message , endpoints , quorumResponseHandler ) ; 
 @ @ - 173 , 12 + 165 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 finally 
 { 
 - if ( writeOperations + + = = Integer . MAX _ VALUE ) 
 - { 
 - writeOperations = 1 ; 
 - writeLatency = 0 ; 
 - } 
 - writeLatency + = System . currentTimeMillis ( ) - startTime ; 
 + writeStats . add ( System . currentTimeMillis ( ) - startTime ) ; 
 } 
 } 
 
 @ @ - 346 , 12 + 333 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 finally 
 { 
 - if ( readOperations + + = = Integer . MAX _ VALUE ) 
 - { 
 - readOperations = 1 ; 
 - readLatency = 0 ; 
 - } 
 - readLatency + = System . currentTimeMillis ( ) - startTime ; 
 + readStats . add ( System . currentTimeMillis ( ) - startTime ) ; 
 } 
 } 
 
 @ @ - 385 , 12 + 367 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 row = strongRead ( command ) ; 
 } 
 
 - if ( readOperations + + = = Integer . MAX _ VALUE ) 
 - { 
 - readOperations = 1 ; 
 - readLatency = 0 ; 
 - } 
 - readLatency + = System . currentTimeMillis ( ) - startTime ; 
 + readStats . add ( System . currentTimeMillis ( ) - startTime ) ; 
 
 return row ; 
 } 
 @ @ - 702 , 42 + 679 , 37 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 finally 
 { 
 - if ( rangeOperations + + = = Integer . MAX _ VALUE ) 
 - { 
 - rangeOperations = 1 ; 
 - rangeLatency = 0 ; 
 - } 
 - rangeLatency + = System . currentTimeMillis ( ) - startTime ; 
 + rangeStats . add ( System . currentTimeMillis ( ) - startTime ) ; 
 } 
 } 
 
 public double getReadLatency ( ) 
 { 
 - return ( ( double ) readLatency ) / readOperations ; 
 + return readStats . mean ( ) ; 
 } 
 
 public double getRangeLatency ( ) 
 { 
 - return ( ( double ) rangeLatency ) / rangeOperations ; 
 + return rangeStats . mean ( ) ; 
 } 
 
 public double getWriteLatency ( ) 
 { 
 - return ( ( double ) writeLatency ) / writeOperations ; 
 + return writeStats . mean ( ) ; 
 } 
 
 public int getReadOperations ( ) 
 { 
 - return readOperations ; 
 + return readStats . size ( ) ; 
 } 
 
 public int getRangeOperations ( ) 
 { 
 - return rangeOperations ; 
 + return rangeStats . size ( ) ; 
 } 
 
 public int getWriteOperations ( ) 
 { 
 - return writeOperations ; 
 + return writeStats . size ( ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / utils / AbstractStatsDeque . java b / src / java / org / apache / cassandra / utils / AbstractStatsDeque . java 
 new file mode 100644 
 index 0000000 . . 16521c0 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / AbstractStatsDeque . java 
 @ @ - 0 , 0 + 1 , 55 @ @ 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . Iterator ; 
 + import java . util . ArrayDeque ; 
 + 
 + public abstract class AbstractStatsDeque implements Iterable < Double > 
 + { 
 + public abstract Iterator < Double > iterator ( ) ; 
 + public abstract int size ( ) ; 
 + public abstract void add ( double o ) ; 
 + public abstract void clear ( ) ; 
 + 
 + / / 
 + / / statistical methods 
 + / / 
 + 
 + public double sum ( ) 
 + { 
 + double sum = 0d ; 
 + for ( Double interval : this ) 
 + { 
 + sum + = interval ; 
 + } 
 + return sum ; 
 + } 
 + 
 + public double sumOfDeviations ( ) 
 + { 
 + double sumOfDeviations = 0d ; 
 + double mean = mean ( ) ; 
 + 
 + for ( Double interval : this ) 
 + { 
 + double v = interval - mean ; 
 + sumOfDeviations + = v * v ; 
 + } 
 + 
 + return sumOfDeviations ; 
 + } 
 + 
 + public double mean ( ) 
 + { 
 + return sum ( ) / size ( ) ; 
 + } 
 + 
 + public double variance ( ) 
 + { 
 + return sumOfDeviations ( ) / size ( ) ; 
 + } 
 + 
 + public double stdev ( ) 
 + { 
 + return Math . sqrt ( variance ( ) ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / utils / BoundedStatsDeque . java b / src / java / org / apache / cassandra / utils / BoundedStatsDeque . java 
 new file mode 100644 
 index 0000000 . . 80f8af1 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / BoundedStatsDeque . java 
 @ @ - 0 , 0 + 1 , 40 @ @ 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . ArrayDeque ; 
 + import java . util . Iterator ; 
 + 
 + public class BoundedStatsDeque extends AbstractStatsDeque 
 + { 
 + private final int size ; 
 + protected final ArrayDeque < Double > deque ; 
 + 
 + public BoundedStatsDeque ( int size ) 
 + { 
 + this . size = size ; 
 + deque = new ArrayDeque < Double > ( size ) ; 
 + } 
 + 
 + public Iterator < Double > iterator ( ) 
 + { 
 + return deque . iterator ( ) ; 
 + } 
 + 
 + public int size ( ) 
 + { 
 + return deque . size ( ) ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + deque . clear ( ) ; 
 + } 
 + 
 + public void add ( double o ) 
 + { 
 + if ( size = = deque . size ( ) ) 
 + { 
 + deque . remove ( ) ; 
 + } 
 + deque . add ( o ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / utils / TimedStatsDeque . java b / src / java / org / apache / cassandra / utils / TimedStatsDeque . java 
 new file mode 100644 
 index 0000000 . . 914c459 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / TimedStatsDeque . java 
 @ @ - 0 , 0 + 1 , 68 @ @ 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . Iterator ; 
 + import java . util . ArrayDeque ; 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + 
 + public class TimedStatsDeque extends AbstractStatsDeque 
 + { 
 + private final ArrayDeque < Tuple > deque ; 
 + private final long period ; 
 + 
 + public TimedStatsDeque ( long period ) 
 + { 
 + this . period = period ; 
 + deque = new ArrayDeque < Tuple > ( ) ; 
 + } 
 + 
 + private void purge ( ) 
 + { 
 + long now = System . currentTimeMillis ( ) ; 
 + while ( ! deque . isEmpty ( ) & & deque . peek ( ) . timestamp < now - period ) 
 + { 
 + deque . remove ( ) ; 
 + } 
 + } 
 + 
 + public Iterator < Double > iterator ( ) 
 + { 
 + purge ( ) ; 
 + / / I expect this method to be called relatively infrequently so inefficiency is ok . 
 + List < Double > L = new ArrayList < Double > ( deque . size ( ) ) ; 
 + for ( Tuple t : deque ) 
 + { 
 + L . add ( t . value ) ; 
 + } 
 + return L . iterator ( ) ; 
 + } 
 + 
 + public int size ( ) 
 + { 
 + purge ( ) ; 
 + return deque . size ( ) ; 
 + } 
 + 
 + public void add ( double o ) 
 + { 
 + purge ( ) ; 
 + deque . add ( new Tuple ( o , System . currentTimeMillis ( ) ) ) ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + deque . clear ( ) ; 
 + } 
 + } 
 + 
 + class Tuple 
 + { 
 + public final double value ; 
 + public final long timestamp ; 
 + 
 + public Tuple ( double value , long timestamp ) 
 + { 
 + this . value = value ; 
 + this . timestamp = timestamp ; 
 + } 
 + } 
 \ No newline at end of file
