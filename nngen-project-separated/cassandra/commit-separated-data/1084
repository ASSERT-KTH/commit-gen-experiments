BLEU SCORE: 0.08051153633013375

TEST MSG: Add forgotten file for 9258 yet again
GENERATED MSG: Add mistakenly forgotten files for CASSANDRA - 9258

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / locator / PendingRangeMaps . java b / src / java / org / apache / cassandra / locator / PendingRangeMaps . java <nl> new file mode 100644 <nl> index 0000000 . . 1892cc3 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / PendingRangeMaps . java <nl> @ @ - 0 , 0 + 1 , 209 @ @ <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import com . google . common . collect . Iterators ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . dht . Token ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . * ; <nl> + <nl> + public class PendingRangeMaps implements Iterable < Map . Entry < Range < Token > , List < InetAddress > > > <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( PendingRangeMaps . class ) ; <nl> + <nl> + / * * <nl> + * We have for NavigableMap to be able to search for ranges containing a token efficiently . <nl> + * <nl> + * First two are for non - wrap - around ranges , and the last two are for wrap - around ranges . <nl> + * / <nl> + / / ascendingMap will sort the ranges by the ascending order of right token <nl> + final NavigableMap < Range < Token > , List < InetAddress > > ascendingMap ; <nl> + / * * <nl> + * sorting end ascending , if ends are same , sorting begin descending , so that token ( end , end ) will <nl> + * come before ( begin , end ] with the same end , and ( begin , end ) will be selected in the tailMap . <nl> + * / <nl> + static final Comparator < Range < Token > > ascendingComparator = new Comparator < Range < Token > > ( ) <nl> + { <nl> + @ Override <nl> + public int compare ( Range < Token > o1 , Range < Token > o2 ) <nl> + { <nl> + int res = o1 . right . compareTo ( o2 . right ) ; <nl> + if ( res ! = 0 ) <nl> + return res ; <nl> + <nl> + return o2 . left . compareTo ( o1 . left ) ; <nl> + } <nl> + } ; <nl> + <nl> + / / ascendingMap will sort the ranges by the descending order of left token <nl> + final NavigableMap < Range < Token > , List < InetAddress > > descendingMap ; <nl> + / * * <nl> + * sorting begin descending , if begins are same , sorting end descending , so that token ( begin , begin ) will <nl> + * come after ( begin , end ] with the same begin , and ( begin , end ) won ' t be selected in the tailMap . <nl> + * / <nl> + static final Comparator < Range < Token > > descendingComparator = new Comparator < Range < Token > > ( ) <nl> + { <nl> + @ Override <nl> + public int compare ( Range < Token > o1 , Range < Token > o2 ) <nl> + { <nl> + int res = o2 . left . compareTo ( o1 . left ) ; <nl> + if ( res ! = 0 ) <nl> + return res ; <nl> + <nl> + / / if left tokens are same , sort by the descending of the right tokens . <nl> + return o2 . right . compareTo ( o1 . right ) ; <nl> + } <nl> + } ; <nl> + <nl> + / / these two maps are for warp around ranges . <nl> + final NavigableMap < Range < Token > , List < InetAddress > > ascendingMapForWrapAround ; <nl> + / * * <nl> + * for wrap around range ( begin , end ] , which begin > end . <nl> + * Sorting end ascending , if ends are same , sorting begin ascending , <nl> + * so that token ( end , end ) will come before ( begin , end ] with the same end , and ( begin , end ] will be selected in <nl> + * the tailMap . <nl> + * / <nl> + static final Comparator < Range < Token > > ascendingComparatorForWrapAround = new Comparator < Range < Token > > ( ) <nl> + { <nl> + @ Override <nl> + public int compare ( Range < Token > o1 , Range < Token > o2 ) <nl> + { <nl> + int res = o1 . right . compareTo ( o2 . right ) ; <nl> + if ( res ! = 0 ) <nl> + return res ; <nl> + <nl> + return o1 . left . compareTo ( o2 . left ) ; <nl> + } <nl> + } ; <nl> + <nl> + final NavigableMap < Range < Token > , List < InetAddress > > descendingMapForWrapAround ; <nl> + / * * <nl> + * for wrap around ranges , which begin > end . <nl> + * Sorting end ascending , so that token ( begin , begin ) will come after ( begin , end ] with the same begin , <nl> + * and ( begin , end ) won ' t be selected in the tailMap . <nl> + * / <nl> + static final Comparator < Range < Token > > descendingComparatorForWrapAround = new Comparator < Range < Token > > ( ) <nl> + { <nl> + @ Override <nl> + public int compare ( Range < Token > o1 , Range < Token > o2 ) <nl> + { <nl> + int res = o2 . left . compareTo ( o1 . left ) ; <nl> + if ( res ! = 0 ) <nl> + return res ; <nl> + return o1 . right . compareTo ( o2 . right ) ; <nl> + } <nl> + } ; <nl> + <nl> + public PendingRangeMaps ( ) <nl> + { <nl> + this . ascendingMap = new TreeMap < Range < Token > , List < InetAddress > > ( ascendingComparator ) ; <nl> + this . descendingMap = new TreeMap < Range < Token > , List < InetAddress > > ( descendingComparator ) ; <nl> + this . ascendingMapForWrapAround = new TreeMap < Range < Token > , List < InetAddress > > ( ascendingComparatorForWrapAround ) ; <nl> + this . descendingMapForWrapAround = new TreeMap < Range < Token > , List < InetAddress > > ( descendingComparatorForWrapAround ) ; <nl> + } <nl> + <nl> + static final void addToMap ( Range < Token > range , <nl> + InetAddress address , <nl> + NavigableMap < Range < Token > , List < InetAddress > > ascendingMap , <nl> + NavigableMap < Range < Token > , List < InetAddress > > descendingMap ) <nl> + { <nl> + List < InetAddress > addresses = ascendingMap . get ( range ) ; <nl> + if ( addresses = = null ) <nl> + { <nl> + addresses = new ArrayList < InetAddress > ( 1 ) ; <nl> + ascendingMap . put ( range , addresses ) ; <nl> + descendingMap . put ( range , addresses ) ; <nl> + } <nl> + addresses . add ( address ) ; <nl> + } <nl> + <nl> + public void addPendingRange ( Range < Token > range , InetAddress address ) <nl> + { <nl> + if ( Range . isWrapAround ( range . left , range . right ) ) <nl> + { <nl> + addToMap ( range , address , ascendingMapForWrapAround , descendingMapForWrapAround ) ; <nl> + } <nl> + else <nl> + { <nl> + addToMap ( range , address , ascendingMap , descendingMap ) ; <nl> + } <nl> + } <nl> + <nl> + static final void addIntersections ( Set < InetAddress > endpointsToAdd , <nl> + NavigableMap < Range < Token > , List < InetAddress > > smallerMap , <nl> + NavigableMap < Range < Token > , List < InetAddress > > biggerMap ) <nl> + { <nl> + / / find the intersection of two sets <nl> + for ( Range < Token > range : smallerMap . keySet ( ) ) <nl> + { <nl> + List < InetAddress > addresses = biggerMap . get ( range ) ; <nl> + if ( addresses ! = null ) <nl> + { <nl> + endpointsToAdd . addAll ( addresses ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public Collection < InetAddress > pendingEndpointsFor ( Token token ) <nl> + { <nl> + Set < InetAddress > endpoints = new HashSet < > ( ) ; <nl> + <nl> + Range searchRange = new Range ( token , token ) ; <nl> + <nl> + / / search for non - wrap - around maps <nl> + NavigableMap < Range < Token > , List < InetAddress > > ascendingTailMap = ascendingMap . tailMap ( searchRange , true ) ; <nl> + NavigableMap < Range < Token > , List < InetAddress > > descendingTailMap = descendingMap . tailMap ( searchRange , false ) ; <nl> + <nl> + / / add intersections of two maps <nl> + if ( ascendingTailMap . size ( ) < descendingTailMap . size ( ) ) <nl> + { <nl> + addIntersections ( endpoints , ascendingTailMap , descendingTailMap ) ; <nl> + } <nl> + else <nl> + { <nl> + addIntersections ( endpoints , descendingTailMap , ascendingTailMap ) ; <nl> + } <nl> + <nl> + / / search for wrap - around sets <nl> + ascendingTailMap = ascendingMapForWrapAround . tailMap ( searchRange , true ) ; <nl> + descendingTailMap = descendingMapForWrapAround . tailMap ( searchRange , false ) ; <nl> + <nl> + / / add them since they are all necessary . <nl> + for ( Map . Entry < Range < Token > , List < InetAddress > > entry : ascendingTailMap . entrySet ( ) ) <nl> + { <nl> + endpoints . addAll ( entry . getValue ( ) ) ; <nl> + } <nl> + for ( Map . Entry < Range < Token > , List < InetAddress > > entry : descendingTailMap . entrySet ( ) ) <nl> + { <nl> + endpoints . addAll ( entry . getValue ( ) ) ; <nl> + } <nl> + <nl> + return endpoints ; <nl> + } <nl> + <nl> + public String printPendingRanges ( ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + <nl> + for ( Map . Entry < Range < Token > , List < InetAddress > > entry : this ) <nl> + { <nl> + Range < Token > range = entry . getKey ( ) ; <nl> + <nl> + for ( InetAddress address : entry . getValue ( ) ) <nl> + { <nl> + sb . append ( address ) . append ( ' : ' ) . append ( range ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + } <nl> + <nl> + return sb . toString ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Iterator < Map . Entry < Range < Token > , List < InetAddress > > > iterator ( ) <nl> + { <nl> + return Iterators . concat ( ascendingMap . entrySet ( ) . iterator ( ) , ascendingMapForWrapAround . entrySet ( ) . iterator ( ) ) ; <nl> + } <nl> + } <nl> diff - - git a / test / microbench / org / apache / cassandra / test / microbench / PendingRangesBench . java b / test / microbench / org / apache / cassandra / test / microbench / PendingRangesBench . java <nl> new file mode 100644 <nl> index 0000000 . . e50cbaf <nl> - - - / dev / null <nl> + + + b / test / microbench / org / apache / cassandra / test / microbench / PendingRangesBench . java <nl> @ @ - 0 , 0 + 1 , 89 @ @ <nl> + package org . apache . cassandra . test . microbench ; <nl> + <nl> + import com . google . common . collect . HashMultimap ; <nl> + import com . google . common . collect . Multimap ; <nl> + import org . apache . cassandra . dht . RandomPartitioner ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . dht . Token ; <nl> + import org . apache . cassandra . locator . PendingRangeMaps ; <nl> + import org . openjdk . jmh . annotations . * ; <nl> + import org . openjdk . jmh . infra . Blackhole ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . net . UnknownHostException ; <nl> + import java . util . Collection ; <nl> + import java . util . HashSet ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + import java . util . concurrent . ThreadLocalRandom ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + @ BenchmarkMode ( Mode . AverageTime ) <nl> + @ OutputTimeUnit ( TimeUnit . NANOSECONDS ) <nl> + @ Warmup ( iterations = 1 , time = 1 , timeUnit = TimeUnit . SECONDS ) <nl> + @ Measurement ( iterations = 50 , time = 1 , timeUnit = TimeUnit . SECONDS ) <nl> + @ Fork ( value = 3 , jvmArgsAppend = " - Xmx512M " ) <nl> + @ Threads ( 1 ) <nl> + @ State ( Scope . Benchmark ) <nl> + public class PendingRangesBench <nl> + { <nl> + PendingRangeMaps pendingRangeMaps ; <nl> + int maxToken = 256 * 100 ; <nl> + <nl> + Multimap < Range < Token > , InetAddress > oldPendingRanges ; <nl> + <nl> + private Range < Token > genRange ( String left , String right ) <nl> + { <nl> + return new Range < Token > ( new RandomPartitioner . BigIntegerToken ( left ) , new RandomPartitioner . BigIntegerToken ( right ) ) ; <nl> + } <nl> + <nl> + @ Setup <nl> + public void setUp ( ) throws UnknownHostException <nl> + { <nl> + pendingRangeMaps = new PendingRangeMaps ( ) ; <nl> + oldPendingRanges = HashMultimap . create ( ) ; <nl> + <nl> + InetAddress [ ] addresses = { InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) } ; <nl> + <nl> + for ( int i = 0 ; i < maxToken ; i + + ) <nl> + { <nl> + for ( int j = 0 ; j < ThreadLocalRandom . current ( ) . nextInt ( 2 ) ; j + + ) <nl> + { <nl> + Range < Token > range = genRange ( Integer . toString ( i * 10 + 5 ) , Integer . toString ( i * 10 + 15 ) ) ; <nl> + pendingRangeMaps . addPendingRange ( range , addresses [ j ] ) ; <nl> + oldPendingRanges . put ( range , addresses [ j ] ) ; <nl> + } <nl> + } <nl> + <nl> + / / add the wrap around range <nl> + for ( int j = 0 ; j < ThreadLocalRandom . current ( ) . nextInt ( 2 ) ; j + + ) <nl> + { <nl> + Range < Token > range = genRange ( Integer . toString ( maxToken * 10 + 5 ) , Integer . toString ( 5 ) ) ; <nl> + pendingRangeMaps . addPendingRange ( range , addresses [ j ] ) ; <nl> + oldPendingRanges . put ( range , addresses [ j ] ) ; <nl> + } <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void searchToken ( final Blackhole bh ) <nl> + { <nl> + int randomToken = ThreadLocalRandom . current ( ) . nextInt ( maxToken * 10 + 5 ) ; <nl> + Token searchToken = new RandomPartitioner . BigIntegerToken ( Integer . toString ( randomToken ) ) ; <nl> + bh . consume ( pendingRangeMaps . pendingEndpointsFor ( searchToken ) ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void searchTokenForOldPendingRanges ( final Blackhole bh ) <nl> + { <nl> + int randomToken = ThreadLocalRandom . current ( ) . nextInt ( maxToken * 10 + 5 ) ; <nl> + Token searchToken = new RandomPartitioner . BigIntegerToken ( Integer . toString ( randomToken ) ) ; <nl> + Set < InetAddress > endpoints = new HashSet < > ( ) ; <nl> + for ( Map . Entry < Range < Token > , Collection < InetAddress > > entry : oldPendingRanges . asMap ( ) . entrySet ( ) ) <nl> + { <nl> + if ( entry . getKey ( ) . contains ( searchToken ) ) <nl> + endpoints . addAll ( entry . getValue ( ) ) ; <nl> + } <nl> + bh . consume ( endpoints ) ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / locator / PendingRangeMapsTest . java b / test / unit / org / apache / cassandra / locator / PendingRangeMapsTest . java <nl> new file mode 100644 <nl> index 0000000 . . 6d24447 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / locator / PendingRangeMapsTest . java <nl> @ @ - 0 , 0 + 1 , 78 @ @ <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . dht . Token ; <nl> + import org . junit . Test ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . net . UnknownHostException ; <nl> + import java . util . Collection ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + public class PendingRangeMapsTest { <nl> + <nl> + private Range < Token > genRange ( String left , String right ) <nl> + { <nl> + return new Range < Token > ( new BigIntegerToken ( left ) , new BigIntegerToken ( right ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testPendingEndpoints ( ) throws UnknownHostException <nl> + { <nl> + PendingRangeMaps pendingRangeMaps = new PendingRangeMaps ( ) ; <nl> + <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 5 " , " 15 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 15 " , " 25 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 25 " , " 35 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 35 " , " 45 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 45 " , " 55 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 45 " , " 65 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ) ; <nl> + <nl> + assertEquals ( 0 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 0 " ) ) . size ( ) ) ; <nl> + assertEquals ( 0 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 5 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 10 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 15 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 20 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 25 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 35 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 45 " ) ) . size ( ) ) ; <nl> + assertEquals ( 2 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 55 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 65 " ) ) . size ( ) ) ; <nl> + <nl> + Collection < InetAddress > endpoints = pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 15 " ) ) ; <nl> + assertTrue ( endpoints . contains ( InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testWrapAroundRanges ( ) throws UnknownHostException <nl> + { <nl> + PendingRangeMaps pendingRangeMaps = new PendingRangeMaps ( ) ; <nl> + <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 5 " , " 15 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 15 " , " 25 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 25 " , " 35 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 35 " , " 45 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 45 " , " 55 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 45 " , " 65 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ) ; <nl> + pendingRangeMaps . addPendingRange ( genRange ( " 65 " , " 7 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ) ; <nl> + <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 0 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 5 " ) ) . size ( ) ) ; <nl> + assertEquals ( 2 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 7 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 10 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 15 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 20 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 25 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 35 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 45 " ) ) . size ( ) ) ; <nl> + assertEquals ( 2 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 55 " ) ) . size ( ) ) ; <nl> + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 65 " ) ) . size ( ) ) ; <nl> + <nl> + Collection < InetAddress > endpoints = pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 6 " ) ) ; <nl> + assertTrue ( endpoints . contains ( InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ) ; <nl> + assertTrue ( endpoints . contains ( InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ) ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / locator / PendingRangeMaps . java b / src / java / org / apache / cassandra / locator / PendingRangeMaps . java 
 new file mode 100644 
 index 0000000 . . 1892cc3 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / PendingRangeMaps . java 
 @ @ - 0 , 0 + 1 , 209 @ @ 
 + package org . apache . cassandra . locator ; 
 + 
 + import com . google . common . collect . Iterators ; 
 + import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . dht . Token ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . * ; 
 + 
 + public class PendingRangeMaps implements Iterable < Map . Entry < Range < Token > , List < InetAddress > > > 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( PendingRangeMaps . class ) ; 
 + 
 + / * * 
 + * We have for NavigableMap to be able to search for ranges containing a token efficiently . 
 + * 
 + * First two are for non - wrap - around ranges , and the last two are for wrap - around ranges . 
 + * / 
 + / / ascendingMap will sort the ranges by the ascending order of right token 
 + final NavigableMap < Range < Token > , List < InetAddress > > ascendingMap ; 
 + / * * 
 + * sorting end ascending , if ends are same , sorting begin descending , so that token ( end , end ) will 
 + * come before ( begin , end ] with the same end , and ( begin , end ) will be selected in the tailMap . 
 + * / 
 + static final Comparator < Range < Token > > ascendingComparator = new Comparator < Range < Token > > ( ) 
 + { 
 + @ Override 
 + public int compare ( Range < Token > o1 , Range < Token > o2 ) 
 + { 
 + int res = o1 . right . compareTo ( o2 . right ) ; 
 + if ( res ! = 0 ) 
 + return res ; 
 + 
 + return o2 . left . compareTo ( o1 . left ) ; 
 + } 
 + } ; 
 + 
 + / / ascendingMap will sort the ranges by the descending order of left token 
 + final NavigableMap < Range < Token > , List < InetAddress > > descendingMap ; 
 + / * * 
 + * sorting begin descending , if begins are same , sorting end descending , so that token ( begin , begin ) will 
 + * come after ( begin , end ] with the same begin , and ( begin , end ) won ' t be selected in the tailMap . 
 + * / 
 + static final Comparator < Range < Token > > descendingComparator = new Comparator < Range < Token > > ( ) 
 + { 
 + @ Override 
 + public int compare ( Range < Token > o1 , Range < Token > o2 ) 
 + { 
 + int res = o2 . left . compareTo ( o1 . left ) ; 
 + if ( res ! = 0 ) 
 + return res ; 
 + 
 + / / if left tokens are same , sort by the descending of the right tokens . 
 + return o2 . right . compareTo ( o1 . right ) ; 
 + } 
 + } ; 
 + 
 + / / these two maps are for warp around ranges . 
 + final NavigableMap < Range < Token > , List < InetAddress > > ascendingMapForWrapAround ; 
 + / * * 
 + * for wrap around range ( begin , end ] , which begin > end . 
 + * Sorting end ascending , if ends are same , sorting begin ascending , 
 + * so that token ( end , end ) will come before ( begin , end ] with the same end , and ( begin , end ] will be selected in 
 + * the tailMap . 
 + * / 
 + static final Comparator < Range < Token > > ascendingComparatorForWrapAround = new Comparator < Range < Token > > ( ) 
 + { 
 + @ Override 
 + public int compare ( Range < Token > o1 , Range < Token > o2 ) 
 + { 
 + int res = o1 . right . compareTo ( o2 . right ) ; 
 + if ( res ! = 0 ) 
 + return res ; 
 + 
 + return o1 . left . compareTo ( o2 . left ) ; 
 + } 
 + } ; 
 + 
 + final NavigableMap < Range < Token > , List < InetAddress > > descendingMapForWrapAround ; 
 + / * * 
 + * for wrap around ranges , which begin > end . 
 + * Sorting end ascending , so that token ( begin , begin ) will come after ( begin , end ] with the same begin , 
 + * and ( begin , end ) won ' t be selected in the tailMap . 
 + * / 
 + static final Comparator < Range < Token > > descendingComparatorForWrapAround = new Comparator < Range < Token > > ( ) 
 + { 
 + @ Override 
 + public int compare ( Range < Token > o1 , Range < Token > o2 ) 
 + { 
 + int res = o2 . left . compareTo ( o1 . left ) ; 
 + if ( res ! = 0 ) 
 + return res ; 
 + return o1 . right . compareTo ( o2 . right ) ; 
 + } 
 + } ; 
 + 
 + public PendingRangeMaps ( ) 
 + { 
 + this . ascendingMap = new TreeMap < Range < Token > , List < InetAddress > > ( ascendingComparator ) ; 
 + this . descendingMap = new TreeMap < Range < Token > , List < InetAddress > > ( descendingComparator ) ; 
 + this . ascendingMapForWrapAround = new TreeMap < Range < Token > , List < InetAddress > > ( ascendingComparatorForWrapAround ) ; 
 + this . descendingMapForWrapAround = new TreeMap < Range < Token > , List < InetAddress > > ( descendingComparatorForWrapAround ) ; 
 + } 
 + 
 + static final void addToMap ( Range < Token > range , 
 + InetAddress address , 
 + NavigableMap < Range < Token > , List < InetAddress > > ascendingMap , 
 + NavigableMap < Range < Token > , List < InetAddress > > descendingMap ) 
 + { 
 + List < InetAddress > addresses = ascendingMap . get ( range ) ; 
 + if ( addresses = = null ) 
 + { 
 + addresses = new ArrayList < InetAddress > ( 1 ) ; 
 + ascendingMap . put ( range , addresses ) ; 
 + descendingMap . put ( range , addresses ) ; 
 + } 
 + addresses . add ( address ) ; 
 + } 
 + 
 + public void addPendingRange ( Range < Token > range , InetAddress address ) 
 + { 
 + if ( Range . isWrapAround ( range . left , range . right ) ) 
 + { 
 + addToMap ( range , address , ascendingMapForWrapAround , descendingMapForWrapAround ) ; 
 + } 
 + else 
 + { 
 + addToMap ( range , address , ascendingMap , descendingMap ) ; 
 + } 
 + } 
 + 
 + static final void addIntersections ( Set < InetAddress > endpointsToAdd , 
 + NavigableMap < Range < Token > , List < InetAddress > > smallerMap , 
 + NavigableMap < Range < Token > , List < InetAddress > > biggerMap ) 
 + { 
 + / / find the intersection of two sets 
 + for ( Range < Token > range : smallerMap . keySet ( ) ) 
 + { 
 + List < InetAddress > addresses = biggerMap . get ( range ) ; 
 + if ( addresses ! = null ) 
 + { 
 + endpointsToAdd . addAll ( addresses ) ; 
 + } 
 + } 
 + } 
 + 
 + public Collection < InetAddress > pendingEndpointsFor ( Token token ) 
 + { 
 + Set < InetAddress > endpoints = new HashSet < > ( ) ; 
 + 
 + Range searchRange = new Range ( token , token ) ; 
 + 
 + / / search for non - wrap - around maps 
 + NavigableMap < Range < Token > , List < InetAddress > > ascendingTailMap = ascendingMap . tailMap ( searchRange , true ) ; 
 + NavigableMap < Range < Token > , List < InetAddress > > descendingTailMap = descendingMap . tailMap ( searchRange , false ) ; 
 + 
 + / / add intersections of two maps 
 + if ( ascendingTailMap . size ( ) < descendingTailMap . size ( ) ) 
 + { 
 + addIntersections ( endpoints , ascendingTailMap , descendingTailMap ) ; 
 + } 
 + else 
 + { 
 + addIntersections ( endpoints , descendingTailMap , ascendingTailMap ) ; 
 + } 
 + 
 + / / search for wrap - around sets 
 + ascendingTailMap = ascendingMapForWrapAround . tailMap ( searchRange , true ) ; 
 + descendingTailMap = descendingMapForWrapAround . tailMap ( searchRange , false ) ; 
 + 
 + / / add them since they are all necessary . 
 + for ( Map . Entry < Range < Token > , List < InetAddress > > entry : ascendingTailMap . entrySet ( ) ) 
 + { 
 + endpoints . addAll ( entry . getValue ( ) ) ; 
 + } 
 + for ( Map . Entry < Range < Token > , List < InetAddress > > entry : descendingTailMap . entrySet ( ) ) 
 + { 
 + endpoints . addAll ( entry . getValue ( ) ) ; 
 + } 
 + 
 + return endpoints ; 
 + } 
 + 
 + public String printPendingRanges ( ) 
 + { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + 
 + for ( Map . Entry < Range < Token > , List < InetAddress > > entry : this ) 
 + { 
 + Range < Token > range = entry . getKey ( ) ; 
 + 
 + for ( InetAddress address : entry . getValue ( ) ) 
 + { 
 + sb . append ( address ) . append ( ' : ' ) . append ( range ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + } 
 + } 
 + 
 + return sb . toString ( ) ; 
 + } 
 + 
 + @ Override 
 + public Iterator < Map . Entry < Range < Token > , List < InetAddress > > > iterator ( ) 
 + { 
 + return Iterators . concat ( ascendingMap . entrySet ( ) . iterator ( ) , ascendingMapForWrapAround . entrySet ( ) . iterator ( ) ) ; 
 + } 
 + } 
 diff - - git a / test / microbench / org / apache / cassandra / test / microbench / PendingRangesBench . java b / test / microbench / org / apache / cassandra / test / microbench / PendingRangesBench . java 
 new file mode 100644 
 index 0000000 . . e50cbaf 
 - - - / dev / null 
 + + + b / test / microbench / org / apache / cassandra / test / microbench / PendingRangesBench . java 
 @ @ - 0 , 0 + 1 , 89 @ @ 
 + package org . apache . cassandra . test . microbench ; 
 + 
 + import com . google . common . collect . HashMultimap ; 
 + import com . google . common . collect . Multimap ; 
 + import org . apache . cassandra . dht . RandomPartitioner ; 
 + import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . dht . Token ; 
 + import org . apache . cassandra . locator . PendingRangeMaps ; 
 + import org . openjdk . jmh . annotations . * ; 
 + import org . openjdk . jmh . infra . Blackhole ; 
 + 
 + import java . net . InetAddress ; 
 + import java . net . UnknownHostException ; 
 + import java . util . Collection ; 
 + import java . util . HashSet ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + import java . util . concurrent . ThreadLocalRandom ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + @ BenchmarkMode ( Mode . AverageTime ) 
 + @ OutputTimeUnit ( TimeUnit . NANOSECONDS ) 
 + @ Warmup ( iterations = 1 , time = 1 , timeUnit = TimeUnit . SECONDS ) 
 + @ Measurement ( iterations = 50 , time = 1 , timeUnit = TimeUnit . SECONDS ) 
 + @ Fork ( value = 3 , jvmArgsAppend = " - Xmx512M " ) 
 + @ Threads ( 1 ) 
 + @ State ( Scope . Benchmark ) 
 + public class PendingRangesBench 
 + { 
 + PendingRangeMaps pendingRangeMaps ; 
 + int maxToken = 256 * 100 ; 
 + 
 + Multimap < Range < Token > , InetAddress > oldPendingRanges ; 
 + 
 + private Range < Token > genRange ( String left , String right ) 
 + { 
 + return new Range < Token > ( new RandomPartitioner . BigIntegerToken ( left ) , new RandomPartitioner . BigIntegerToken ( right ) ) ; 
 + } 
 + 
 + @ Setup 
 + public void setUp ( ) throws UnknownHostException 
 + { 
 + pendingRangeMaps = new PendingRangeMaps ( ) ; 
 + oldPendingRanges = HashMultimap . create ( ) ; 
 + 
 + InetAddress [ ] addresses = { InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) } ; 
 + 
 + for ( int i = 0 ; i < maxToken ; i + + ) 
 + { 
 + for ( int j = 0 ; j < ThreadLocalRandom . current ( ) . nextInt ( 2 ) ; j + + ) 
 + { 
 + Range < Token > range = genRange ( Integer . toString ( i * 10 + 5 ) , Integer . toString ( i * 10 + 15 ) ) ; 
 + pendingRangeMaps . addPendingRange ( range , addresses [ j ] ) ; 
 + oldPendingRanges . put ( range , addresses [ j ] ) ; 
 + } 
 + } 
 + 
 + / / add the wrap around range 
 + for ( int j = 0 ; j < ThreadLocalRandom . current ( ) . nextInt ( 2 ) ; j + + ) 
 + { 
 + Range < Token > range = genRange ( Integer . toString ( maxToken * 10 + 5 ) , Integer . toString ( 5 ) ) ; 
 + pendingRangeMaps . addPendingRange ( range , addresses [ j ] ) ; 
 + oldPendingRanges . put ( range , addresses [ j ] ) ; 
 + } 
 + } 
 + 
 + @ Benchmark 
 + public void searchToken ( final Blackhole bh ) 
 + { 
 + int randomToken = ThreadLocalRandom . current ( ) . nextInt ( maxToken * 10 + 5 ) ; 
 + Token searchToken = new RandomPartitioner . BigIntegerToken ( Integer . toString ( randomToken ) ) ; 
 + bh . consume ( pendingRangeMaps . pendingEndpointsFor ( searchToken ) ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void searchTokenForOldPendingRanges ( final Blackhole bh ) 
 + { 
 + int randomToken = ThreadLocalRandom . current ( ) . nextInt ( maxToken * 10 + 5 ) ; 
 + Token searchToken = new RandomPartitioner . BigIntegerToken ( Integer . toString ( randomToken ) ) ; 
 + Set < InetAddress > endpoints = new HashSet < > ( ) ; 
 + for ( Map . Entry < Range < Token > , Collection < InetAddress > > entry : oldPendingRanges . asMap ( ) . entrySet ( ) ) 
 + { 
 + if ( entry . getKey ( ) . contains ( searchToken ) ) 
 + endpoints . addAll ( entry . getValue ( ) ) ; 
 + } 
 + bh . consume ( endpoints ) ; 
 + } 
 + 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / locator / PendingRangeMapsTest . java b / test / unit / org / apache / cassandra / locator / PendingRangeMapsTest . java 
 new file mode 100644 
 index 0000000 . . 6d24447 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / locator / PendingRangeMapsTest . java 
 @ @ - 0 , 0 + 1 , 78 @ @ 
 + package org . apache . cassandra . locator ; 
 + 
 + import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; 
 + import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . dht . Token ; 
 + import org . junit . Test ; 
 + 
 + import java . net . InetAddress ; 
 + import java . net . UnknownHostException ; 
 + import java . util . Collection ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + public class PendingRangeMapsTest { 
 + 
 + private Range < Token > genRange ( String left , String right ) 
 + { 
 + return new Range < Token > ( new BigIntegerToken ( left ) , new BigIntegerToken ( right ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testPendingEndpoints ( ) throws UnknownHostException 
 + { 
 + PendingRangeMaps pendingRangeMaps = new PendingRangeMaps ( ) ; 
 + 
 + pendingRangeMaps . addPendingRange ( genRange ( " 5 " , " 15 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 15 " , " 25 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 25 " , " 35 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 35 " , " 45 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 45 " , " 55 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 45 " , " 65 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ) ; 
 + 
 + assertEquals ( 0 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 0 " ) ) . size ( ) ) ; 
 + assertEquals ( 0 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 5 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 10 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 15 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 20 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 25 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 35 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 45 " ) ) . size ( ) ) ; 
 + assertEquals ( 2 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 55 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 65 " ) ) . size ( ) ) ; 
 + 
 + Collection < InetAddress > endpoints = pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 15 " ) ) ; 
 + assertTrue ( endpoints . contains ( InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testWrapAroundRanges ( ) throws UnknownHostException 
 + { 
 + PendingRangeMaps pendingRangeMaps = new PendingRangeMaps ( ) ; 
 + 
 + pendingRangeMaps . addPendingRange ( genRange ( " 5 " , " 15 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 15 " , " 25 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 25 " , " 35 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 35 " , " 45 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 45 " , " 55 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 45 " , " 65 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ) ; 
 + pendingRangeMaps . addPendingRange ( genRange ( " 65 " , " 7 " ) , InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ) ; 
 + 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 0 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 5 " ) ) . size ( ) ) ; 
 + assertEquals ( 2 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 7 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 10 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 15 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 20 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 25 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 35 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 45 " ) ) . size ( ) ) ; 
 + assertEquals ( 2 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 55 " ) ) . size ( ) ) ; 
 + assertEquals ( 1 , pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 65 " ) ) . size ( ) ) ; 
 + 
 + Collection < InetAddress > endpoints = pendingRangeMaps . pendingEndpointsFor ( new BigIntegerToken ( " 6 " ) ) ; 
 + assertTrue ( endpoints . contains ( InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ) ; 
 + assertTrue ( endpoints . contains ( InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ) ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
