BLEU SCORE: 0.05341087579952926

TEST MSG: Use murmur3 for validation compactions
GENERATED MSG: add uncommitted files

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f52aceb . . 9d0b483 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Use Murmur3 for validation compactions ( CASSANDRA - 14002 ) <nl> * Comma at the end of the seed list is interpretated as localhost ( CASSANDRA - 14285 ) <nl> * Refactor read executor and response resolver , abstract read repair ( CASSANDRA - 14058 ) <nl> * Add optional startup delay to wait until peers are ready ( CASSANDRA - 13993 ) <nl> diff - - git a / src / java / org / apache / cassandra / repair / Validator . java b / src / java / org / apache / cassandra / repair / Validator . java <nl> index 4c2856d . . 28c910b 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / Validator . java <nl> + + + b / src / java / org / apache / cassandra / repair / Validator . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import java . util . Random ; <nl> import com . google . common . annotations . VisibleForTesting ; <nl> import com . google . common . hash . Funnel ; <nl> import com . google . common . hash . HashCode ; <nl> + import com . google . common . hash . HashFunction ; <nl> import com . google . common . hash . Hasher ; <nl> import com . google . common . hash . Hashing ; <nl> <nl> @ @ - 192 , 80 + 193 , 127 @ @ public class Validator implements Runnable <nl> return range . contains ( t ) ; <nl> } <nl> <nl> + / * * <nl> + * Hasher that concatenates the hash code from 2 hash functions ( murmur3 _ 128 ) with different <nl> + * seeds and counts the number of bytes we hashed . <nl> + * <nl> + * Everything hashed by this class is hashed by both hash functions and the <nl> + * resulting hashcode is a concatenation of the output bytes from each . <nl> + * <nl> + * Idea from Guavas Hashing . ConcatenatedHashFunction , but that is package - private so we can ' t use it <nl> + * / <nl> + @ VisibleForTesting <nl> static class CountingHasher implements Hasher <nl> { <nl> + @ VisibleForTesting <nl> + static final HashFunction [ ] hashFunctions = new HashFunction [ 2 ] ; <nl> + <nl> + static <nl> + { <nl> + for ( int i = 0 ; i < hashFunctions . length ; i + + ) <nl> + hashFunctions [ i ] = Hashing . murmur3 _ 128 ( i * 1000 ) ; <nl> + } <nl> private long count ; <nl> - private final Hasher underlying ; <nl> + private final int bits ; <nl> + private final Hasher [ ] underlying = new Hasher [ 2 ] ; <nl> <nl> - CountingHasher ( Hasher underlying ) <nl> + CountingHasher ( ) <nl> { <nl> - this . underlying = underlying ; <nl> + int bits = 0 ; <nl> + for ( int i = 0 ; i < underlying . length ; i + + ) <nl> + { <nl> + this . underlying [ i ] = hashFunctions [ i ] . newHasher ( ) ; <nl> + bits + = hashFunctions [ i ] . bits ( ) ; <nl> + } <nl> + this . bits = bits ; <nl> } <nl> <nl> public Hasher putByte ( byte b ) <nl> { <nl> count + = 1 ; <nl> - return underlying . putByte ( b ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putByte ( b ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putBytes ( byte [ ] bytes ) <nl> { <nl> count + = bytes . length ; <nl> - return underlying . putBytes ( bytes ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putBytes ( bytes ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putBytes ( byte [ ] bytes , int offset , int length ) <nl> { <nl> count + = length ; <nl> - return underlying . putBytes ( bytes , offset , length ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putBytes ( bytes , offset , length ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putBytes ( ByteBuffer byteBuffer ) <nl> { <nl> count + = byteBuffer . remaining ( ) ; <nl> - return underlying . putBytes ( byteBuffer ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putBytes ( byteBuffer . duplicate ( ) ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putShort ( short i ) <nl> { <nl> count + = Short . BYTES ; <nl> - return underlying . putShort ( i ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putShort ( i ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putInt ( int i ) <nl> { <nl> count + = Integer . BYTES ; <nl> - return underlying . putInt ( i ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putInt ( i ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putLong ( long l ) <nl> { <nl> count + = Long . BYTES ; <nl> - return underlying . putLong ( l ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putLong ( l ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putFloat ( float v ) <nl> { <nl> count + = Float . BYTES ; <nl> - return underlying . putFloat ( v ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putFloat ( v ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putDouble ( double v ) <nl> { <nl> count + = Double . BYTES ; <nl> - return underlying . putDouble ( v ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putDouble ( v ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putBoolean ( boolean b ) <nl> { <nl> count + = Byte . BYTES ; <nl> - return underlying . putBoolean ( b ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putBoolean ( b ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putChar ( char c ) <nl> { <nl> count + = Character . BYTES ; <nl> - return underlying . putChar ( c ) ; <nl> + for ( Hasher h : underlying ) <nl> + h . putChar ( c ) ; <nl> + return this ; <nl> } <nl> <nl> public Hasher putUnencodedChars ( CharSequence charSequence ) <nl> @ @ - 285 , 7 + 333 , 19 @ @ public class Validator implements Runnable <nl> <nl> public HashCode hash ( ) <nl> { <nl> - return underlying . hash ( ) ; <nl> + byte [ ] res = new byte [ bits / 8 ] ; <nl> + int i = 0 ; <nl> + for ( Hasher hasher : underlying ) <nl> + { <nl> + HashCode newHash = hasher . hash ( ) ; <nl> + i + = newHash . writeBytesTo ( res , i , newHash . bits ( ) / 8 ) ; <nl> + } <nl> + return HashCode . fromBytes ( res ) ; <nl> + } <nl> + <nl> + public long getCount ( ) <nl> + { <nl> + return count ; <nl> } <nl> } <nl> <nl> @ @ - 293 , 7 + 353 , 7 @ @ public class Validator implements Runnable <nl> { <nl> validated + + ; <nl> / / MerkleTree uses XOR internally , so we want lots of output bits here <nl> - CountingHasher hasher = new CountingHasher ( Hashing . sha256 ( ) . newHasher ( ) ) ; <nl> + CountingHasher hasher = new CountingHasher ( ) ; <nl> UnfilteredRowIterators . digest ( partition , hasher , MessagingService . current _ version ) ; <nl> / / only return new hash for merkle tree in case digest was updated - see CASSANDRA - 8979 <nl> return hasher . count > 0 <nl> diff - - git a / test / unit / org / apache / cassandra / repair / ValidatorTest . java b / test / unit / org / apache / cassandra / repair / ValidatorTest . java <nl> index 322772a . . 7c3dd27 100644 <nl> - - - a / test / unit / org / apache / cassandra / repair / ValidatorTest . java <nl> + + + b / test / unit / org / apache / cassandra / repair / ValidatorTest . java <nl> @ @ - 17 , 6 + 17 , 8 @ @ <nl> * / <nl> package org . apache . cassandra . repair ; <nl> <nl> + import java . net . InetAddress ; <nl> + import java . nio . ByteBuffer ; <nl> import java . util . Arrays ; <nl> import java . util . Collections ; <nl> import java . util . Iterator ; <nl> @ @ - 25 , 6 + 27 , 8 @ @ import java . util . UUID ; <nl> import java . util . concurrent . CompletableFuture ; <nl> import java . util . concurrent . TimeUnit ; <nl> <nl> + import com . google . common . hash . Hasher ; <nl> + <nl> import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . compaction . CompactionsTest ; <nl> import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> @ @ - 213 , 6 + 217 , 45 @ @ public class ValidatorTest <nl> assertEquals ( trees . rowCount ( ) , n ) ; <nl> } <nl> <nl> + @ Test <nl> + public void testCountingHasher ( ) <nl> + { <nl> + Hasher [ ] hashers = new Hasher [ ] { new Validator . CountingHasher ( ) , Validator . CountingHasher . hashFunctions [ 0 ] . newHasher ( ) , Validator . CountingHasher . hashFunctions [ 1 ] . newHasher ( ) } ; <nl> + byte [ ] random = UUIDGen . getTimeUUIDBytes ( ) ; <nl> + <nl> + / / call all overloaded methods : <nl> + for ( Hasher hasher : hashers ) <nl> + { <nl> + hasher . putByte ( ( byte ) 33 ) <nl> + . putBytes ( random ) <nl> + . putBytes ( ByteBuffer . wrap ( random ) ) <nl> + . putBytes ( random , 0 , 3 ) <nl> + . putChar ( ' a ' ) <nl> + . putBoolean ( false ) <nl> + . putDouble ( 3 . 3 ) <nl> + . putInt ( 77 ) <nl> + . putFloat ( 99 ) <nl> + . putLong ( 101 ) <nl> + . putShort ( ( short ) 23 ) ; <nl> + } <nl> + <nl> + long len = Byte . BYTES <nl> + + random . length * 2 / / both the byte [ ] and the ByteBuffer <nl> + + 3 / / 3 bytes from the random byte [ ] <nl> + + Character . BYTES <nl> + + Byte . BYTES <nl> + + Double . BYTES <nl> + + Integer . BYTES <nl> + + Float . BYTES <nl> + + Long . BYTES <nl> + + Short . BYTES ; <nl> + <nl> + byte [ ] h = hashers [ 0 ] . hash ( ) . asBytes ( ) ; <nl> + assertTrue ( Arrays . equals ( hashers [ 1 ] . hash ( ) . asBytes ( ) , Arrays . copyOfRange ( h , 0 , 16 ) ) ) ; <nl> + assertTrue ( Arrays . equals ( hashers [ 2 ] . hash ( ) . asBytes ( ) , Arrays . copyOfRange ( h , 16 , 32 ) ) ) ; <nl> + assertEquals ( len , ( ( Validator . CountingHasher ) hashers [ 0 ] ) . getCount ( ) ) ; <nl> + } <nl> + <nl> private CompletableFuture < MessageOut > registerOutgoingMessageSink ( ) <nl> { <nl> final CompletableFuture < MessageOut > future = new CompletableFuture < > ( ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java <nl> index 28d116f . . 80c9f36 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Table . java <nl> + + + b / src / java / org / apache / cassandra / db / Table . java <nl> @ @ - 489 , 16 + 489 , 7 @ @ public class Table <nl> ByteBuffer name = iter . next ( ) ; <nl> IColumn newColumn = cf . getColumn ( name ) ; / / null = = row delete or it wouldn ' t be marked Mutated <nl> if ( newColumn ! = null & & cf . isMarkedForDelete ( ) ) <nl> - { <nl> - / / row is marked for delete , but column was also updated . if column is timestamped less than <nl> - / / the row tombstone , treat it as if it didn ' t exist . Otherwise we don ' t care about row <nl> - / / tombstone for the purpose of the index update and we can proceed as usual . <nl> - if ( newColumn . timestamp ( ) < = cf . getMarkedForDeleteAt ( ) ) <nl> - { <nl> - / / don ' t remove from the cf object ; that can race w / CommitLog write . Leaving it is harmless . <nl> - newColumn = null ; <nl> - } <nl> - } <nl> + throw new UnsupportedOperationException ( " Index manager cannot support deleting and inserting into a row in the same mutation " ) ; <nl> IColumn oldColumn = oldIndexedColumns . getColumn ( name ) ; <nl> <nl> / / deletions are irrelevant to the index unless we ' re changing state from live - > deleted , i . e . ,

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f52aceb . . 9d0b483 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Use Murmur3 for validation compactions ( CASSANDRA - 14002 ) 
 * Comma at the end of the seed list is interpretated as localhost ( CASSANDRA - 14285 ) 
 * Refactor read executor and response resolver , abstract read repair ( CASSANDRA - 14058 ) 
 * Add optional startup delay to wait until peers are ready ( CASSANDRA - 13993 ) 
 diff - - git a / src / java / org / apache / cassandra / repair / Validator . java b / src / java / org / apache / cassandra / repair / Validator . java 
 index 4c2856d . . 28c910b 100644 
 - - - a / src / java / org / apache / cassandra / repair / Validator . java 
 + + + b / src / java / org / apache / cassandra / repair / Validator . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import java . util . Random ; 
 import com . google . common . annotations . VisibleForTesting ; 
 import com . google . common . hash . Funnel ; 
 import com . google . common . hash . HashCode ; 
 + import com . google . common . hash . HashFunction ; 
 import com . google . common . hash . Hasher ; 
 import com . google . common . hash . Hashing ; 
 
 @ @ - 192 , 80 + 193 , 127 @ @ public class Validator implements Runnable 
 return range . contains ( t ) ; 
 } 
 
 + / * * 
 + * Hasher that concatenates the hash code from 2 hash functions ( murmur3 _ 128 ) with different 
 + * seeds and counts the number of bytes we hashed . 
 + * 
 + * Everything hashed by this class is hashed by both hash functions and the 
 + * resulting hashcode is a concatenation of the output bytes from each . 
 + * 
 + * Idea from Guavas Hashing . ConcatenatedHashFunction , but that is package - private so we can ' t use it 
 + * / 
 + @ VisibleForTesting 
 static class CountingHasher implements Hasher 
 { 
 + @ VisibleForTesting 
 + static final HashFunction [ ] hashFunctions = new HashFunction [ 2 ] ; 
 + 
 + static 
 + { 
 + for ( int i = 0 ; i < hashFunctions . length ; i + + ) 
 + hashFunctions [ i ] = Hashing . murmur3 _ 128 ( i * 1000 ) ; 
 + } 
 private long count ; 
 - private final Hasher underlying ; 
 + private final int bits ; 
 + private final Hasher [ ] underlying = new Hasher [ 2 ] ; 
 
 - CountingHasher ( Hasher underlying ) 
 + CountingHasher ( ) 
 { 
 - this . underlying = underlying ; 
 + int bits = 0 ; 
 + for ( int i = 0 ; i < underlying . length ; i + + ) 
 + { 
 + this . underlying [ i ] = hashFunctions [ i ] . newHasher ( ) ; 
 + bits + = hashFunctions [ i ] . bits ( ) ; 
 + } 
 + this . bits = bits ; 
 } 
 
 public Hasher putByte ( byte b ) 
 { 
 count + = 1 ; 
 - return underlying . putByte ( b ) ; 
 + for ( Hasher h : underlying ) 
 + h . putByte ( b ) ; 
 + return this ; 
 } 
 
 public Hasher putBytes ( byte [ ] bytes ) 
 { 
 count + = bytes . length ; 
 - return underlying . putBytes ( bytes ) ; 
 + for ( Hasher h : underlying ) 
 + h . putBytes ( bytes ) ; 
 + return this ; 
 } 
 
 public Hasher putBytes ( byte [ ] bytes , int offset , int length ) 
 { 
 count + = length ; 
 - return underlying . putBytes ( bytes , offset , length ) ; 
 + for ( Hasher h : underlying ) 
 + h . putBytes ( bytes , offset , length ) ; 
 + return this ; 
 } 
 
 public Hasher putBytes ( ByteBuffer byteBuffer ) 
 { 
 count + = byteBuffer . remaining ( ) ; 
 - return underlying . putBytes ( byteBuffer ) ; 
 + for ( Hasher h : underlying ) 
 + h . putBytes ( byteBuffer . duplicate ( ) ) ; 
 + return this ; 
 } 
 
 public Hasher putShort ( short i ) 
 { 
 count + = Short . BYTES ; 
 - return underlying . putShort ( i ) ; 
 + for ( Hasher h : underlying ) 
 + h . putShort ( i ) ; 
 + return this ; 
 } 
 
 public Hasher putInt ( int i ) 
 { 
 count + = Integer . BYTES ; 
 - return underlying . putInt ( i ) ; 
 + for ( Hasher h : underlying ) 
 + h . putInt ( i ) ; 
 + return this ; 
 } 
 
 public Hasher putLong ( long l ) 
 { 
 count + = Long . BYTES ; 
 - return underlying . putLong ( l ) ; 
 + for ( Hasher h : underlying ) 
 + h . putLong ( l ) ; 
 + return this ; 
 } 
 
 public Hasher putFloat ( float v ) 
 { 
 count + = Float . BYTES ; 
 - return underlying . putFloat ( v ) ; 
 + for ( Hasher h : underlying ) 
 + h . putFloat ( v ) ; 
 + return this ; 
 } 
 
 public Hasher putDouble ( double v ) 
 { 
 count + = Double . BYTES ; 
 - return underlying . putDouble ( v ) ; 
 + for ( Hasher h : underlying ) 
 + h . putDouble ( v ) ; 
 + return this ; 
 } 
 
 public Hasher putBoolean ( boolean b ) 
 { 
 count + = Byte . BYTES ; 
 - return underlying . putBoolean ( b ) ; 
 + for ( Hasher h : underlying ) 
 + h . putBoolean ( b ) ; 
 + return this ; 
 } 
 
 public Hasher putChar ( char c ) 
 { 
 count + = Character . BYTES ; 
 - return underlying . putChar ( c ) ; 
 + for ( Hasher h : underlying ) 
 + h . putChar ( c ) ; 
 + return this ; 
 } 
 
 public Hasher putUnencodedChars ( CharSequence charSequence ) 
 @ @ - 285 , 7 + 333 , 19 @ @ public class Validator implements Runnable 
 
 public HashCode hash ( ) 
 { 
 - return underlying . hash ( ) ; 
 + byte [ ] res = new byte [ bits / 8 ] ; 
 + int i = 0 ; 
 + for ( Hasher hasher : underlying ) 
 + { 
 + HashCode newHash = hasher . hash ( ) ; 
 + i + = newHash . writeBytesTo ( res , i , newHash . bits ( ) / 8 ) ; 
 + } 
 + return HashCode . fromBytes ( res ) ; 
 + } 
 + 
 + public long getCount ( ) 
 + { 
 + return count ; 
 } 
 } 
 
 @ @ - 293 , 7 + 353 , 7 @ @ public class Validator implements Runnable 
 { 
 validated + + ; 
 / / MerkleTree uses XOR internally , so we want lots of output bits here 
 - CountingHasher hasher = new CountingHasher ( Hashing . sha256 ( ) . newHasher ( ) ) ; 
 + CountingHasher hasher = new CountingHasher ( ) ; 
 UnfilteredRowIterators . digest ( partition , hasher , MessagingService . current _ version ) ; 
 / / only return new hash for merkle tree in case digest was updated - see CASSANDRA - 8979 
 return hasher . count > 0 
 diff - - git a / test / unit / org / apache / cassandra / repair / ValidatorTest . java b / test / unit / org / apache / cassandra / repair / ValidatorTest . java 
 index 322772a . . 7c3dd27 100644 
 - - - a / test / unit / org / apache / cassandra / repair / ValidatorTest . java 
 + + + b / test / unit / org / apache / cassandra / repair / ValidatorTest . java 
 @ @ - 17 , 6 + 17 , 8 @ @ 
 * / 
 package org . apache . cassandra . repair ; 
 
 + import java . net . InetAddress ; 
 + import java . nio . ByteBuffer ; 
 import java . util . Arrays ; 
 import java . util . Collections ; 
 import java . util . Iterator ; 
 @ @ - 25 , 6 + 27 , 8 @ @ import java . util . UUID ; 
 import java . util . concurrent . CompletableFuture ; 
 import java . util . concurrent . TimeUnit ; 
 
 + import com . google . common . hash . Hasher ; 
 + 
 import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . compaction . CompactionsTest ; 
 import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 @ @ - 213 , 6 + 217 , 45 @ @ public class ValidatorTest 
 assertEquals ( trees . rowCount ( ) , n ) ; 
 } 
 
 + @ Test 
 + public void testCountingHasher ( ) 
 + { 
 + Hasher [ ] hashers = new Hasher [ ] { new Validator . CountingHasher ( ) , Validator . CountingHasher . hashFunctions [ 0 ] . newHasher ( ) , Validator . CountingHasher . hashFunctions [ 1 ] . newHasher ( ) } ; 
 + byte [ ] random = UUIDGen . getTimeUUIDBytes ( ) ; 
 + 
 + / / call all overloaded methods : 
 + for ( Hasher hasher : hashers ) 
 + { 
 + hasher . putByte ( ( byte ) 33 ) 
 + . putBytes ( random ) 
 + . putBytes ( ByteBuffer . wrap ( random ) ) 
 + . putBytes ( random , 0 , 3 ) 
 + . putChar ( ' a ' ) 
 + . putBoolean ( false ) 
 + . putDouble ( 3 . 3 ) 
 + . putInt ( 77 ) 
 + . putFloat ( 99 ) 
 + . putLong ( 101 ) 
 + . putShort ( ( short ) 23 ) ; 
 + } 
 + 
 + long len = Byte . BYTES 
 + + random . length * 2 / / both the byte [ ] and the ByteBuffer 
 + + 3 / / 3 bytes from the random byte [ ] 
 + + Character . BYTES 
 + + Byte . BYTES 
 + + Double . BYTES 
 + + Integer . BYTES 
 + + Float . BYTES 
 + + Long . BYTES 
 + + Short . BYTES ; 
 + 
 + byte [ ] h = hashers [ 0 ] . hash ( ) . asBytes ( ) ; 
 + assertTrue ( Arrays . equals ( hashers [ 1 ] . hash ( ) . asBytes ( ) , Arrays . copyOfRange ( h , 0 , 16 ) ) ) ; 
 + assertTrue ( Arrays . equals ( hashers [ 2 ] . hash ( ) . asBytes ( ) , Arrays . copyOfRange ( h , 16 , 32 ) ) ) ; 
 + assertEquals ( len , ( ( Validator . CountingHasher ) hashers [ 0 ] ) . getCount ( ) ) ; 
 + } 
 + 
 private CompletableFuture < MessageOut > registerOutgoingMessageSink ( ) 
 { 
 final CompletableFuture < MessageOut > future = new CompletableFuture < > ( ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java 
 index 28d116f . . 80c9f36 100644 
 - - - a / src / java / org / apache / cassandra / db / Table . java 
 + + + b / src / java / org / apache / cassandra / db / Table . java 
 @ @ - 489 , 16 + 489 , 7 @ @ public class Table 
 ByteBuffer name = iter . next ( ) ; 
 IColumn newColumn = cf . getColumn ( name ) ; / / null = = row delete or it wouldn ' t be marked Mutated 
 if ( newColumn ! = null & & cf . isMarkedForDelete ( ) ) 
 - { 
 - / / row is marked for delete , but column was also updated . if column is timestamped less than 
 - / / the row tombstone , treat it as if it didn ' t exist . Otherwise we don ' t care about row 
 - / / tombstone for the purpose of the index update and we can proceed as usual . 
 - if ( newColumn . timestamp ( ) < = cf . getMarkedForDeleteAt ( ) ) 
 - { 
 - / / don ' t remove from the cf object ; that can race w / CommitLog write . Leaving it is harmless . 
 - newColumn = null ; 
 - } 
 - } 
 + throw new UnsupportedOperationException ( " Index manager cannot support deleting and inserting into a row in the same mutation " ) ; 
 IColumn oldColumn = oldIndexedColumns . getColumn ( name ) ; 
 
 / / deletions are irrelevant to the index unless we ' re changing state from live - > deleted , i . e . ,
