BLEU SCORE: 0.040583489434387374

TEST MSG: Avoid MV race during node decommission
GENERATED MSG: Removed token range bisection

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 8f3f182 . . b95aa76 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 1 <nl> + * Avoid MV race during node decommission ( CASSANDRA - 10674 ) <nl> * Disable reloading of GossipingPropertyFileSnitch ( CASSANDRA - 9474 ) <nl> * Handle single - column deletions correction in materialized views <nl> when the column is part of the view primary key ( CASSANDRA - 10796 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / view / ViewUtils . java b / src / java / org / apache / cassandra / db / view / ViewUtils . java <nl> index 089a3b7 . . 4d9517f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / view / ViewUtils . java <nl> + + + b / src / java / org / apache / cassandra / db / view / ViewUtils . java <nl> @ @ - 21 , 13 + 21 , 13 @ @ package org . apache . cassandra . db . view ; <nl> import java . net . InetAddress ; <nl> import java . util . ArrayList ; <nl> import java . util . List ; <nl> + import java . util . Optional ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . locator . NetworkTopologyStrategy ; <nl> - import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> public final class ViewUtils <nl> @ @ - 56 , 9 + 56 , 9 @ @ public final class ViewUtils <nl> * B writes to A ( B ' s cardinality is 2 for T1 , and A ' s cardinality is 2 for T3 ) <nl> * C writes to B ( C ' s cardinality is 3 for T1 , and B ' s cardinality is 3 for T3 ) <nl> * <nl> - * @ throws RuntimeException if this method is called using a base token which does not belong to this replica <nl> + * @ return Optional . empty ( ) if this method is called using a base token which does not belong to this replica <nl> * / <nl> - public static InetAddress getViewNaturalEndpoint ( String keyspaceName , Token baseToken , Token viewToken ) <nl> + public static Optional < InetAddress > getViewNaturalEndpoint ( String keyspaceName , Token baseToken , Token viewToken ) <nl> { <nl> AbstractReplicationStrategy replicationStrategy = Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) ; <nl> <nl> @ @ - 77 , 7 + 77 , 7 @ @ public final class ViewUtils <nl> { <nl> / / If we are a base endpoint which is also a view replica , we use ourselves as our view replica <nl> if ( viewEndpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> - return viewEndpoint ; <nl> + return Optional . of ( viewEndpoint ) ; <nl> <nl> / / We have to remove any endpoint which is shared between the base and the view , as it will select itself <nl> / / and throw off the counts otherwise . <nl> @ @ - 95 , 20 + 95 , 9 @ @ public final class ViewUtils <nl> int baseIdx = baseEndpoints . indexOf ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> <nl> if ( baseIdx < 0 ) <nl> - { <nl> - <nl> - if ( StorageService . instance . getTokenMetadata ( ) . pendingEndpointsFor ( viewToken , keyspaceName ) . size ( ) > 0 ) <nl> - { <nl> - / / Since there are pending endpoints we are going to write to the batchlog regardless . <nl> - / / So we can pretend we are the views endpoint . <nl> - <nl> - return FBUtilities . getBroadcastAddress ( ) ; <nl> - } <nl> - <nl> - throw new RuntimeException ( " Trying to get the view natural endpoint on a non - data replica " ) ; <nl> - } <nl> - <nl> + / / This node is not a base replica of this key , so we return empty <nl> + return Optional . empty ( ) ; <nl> <nl> - return viewEndpoints . get ( baseIdx ) ; <nl> + return Optional . of ( viewEndpoints . get ( baseIdx ) ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 15be7c6 . . 397b8b9 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 670 , 12 + 670 , 12 @ @ public class StorageProxy implements StorageProxyMBean <nl> if ( StorageService . instance . isStarting ( ) | | StorageService . instance . isJoining ( ) | | StorageService . instance . isMoving ( ) ) <nl> { <nl> BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , <nl> - mutations ) , <nl> - writeCommitLog ) ; <nl> + mutations ) , writeCommitLog ) ; <nl> } <nl> else <nl> { <nl> List < WriteResponseHandlerWrapper > wrappers = new ArrayList < > ( mutations . size ( ) ) ; <nl> + List < Mutation > nonPairedMutations = new LinkedList < > ( ) ; <nl> Token baseToken = StorageService . instance . getTokenMetadata ( ) . partitioner . getToken ( dataKey ) ; <nl> <nl> ConsistencyLevel consistencyLevel = ConsistencyLevel . ONE ; <nl> @ @ - 684 , 40 + 684 , 51 @ @ public class StorageProxy implements StorageProxyMBean <nl> final Collection < InetAddress > batchlogEndpoints = Collections . singleton ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> BatchlogResponseHandler . BatchlogCleanup cleanup = new BatchlogResponseHandler . BatchlogCleanup ( mutations . size ( ) , <nl> ( ) - > asyncRemoveFromBatchlog ( batchlogEndpoints , batchUUID ) ) ; <nl> - <nl> / / add a handler for each mutation - includes checking availability , but doesn ' t initiate any writes , yet <nl> for ( Mutation mutation : mutations ) <nl> { <nl> String keyspaceName = mutation . getKeyspaceName ( ) ; <nl> Token tk = mutation . key ( ) . getToken ( ) ; <nl> - InetAddress pairedEndpoint = ViewUtils . getViewNaturalEndpoint ( keyspaceName , baseToken , tk ) ; <nl> - List < InetAddress > naturalEndpoints = Lists . newArrayList ( pairedEndpoint ) ; <nl> - <nl> - WriteResponseHandlerWrapper wrapper = wrapViewBatchResponseHandler ( mutation , <nl> - consistencyLevel , <nl> - consistencyLevel , <nl> - naturalEndpoints , <nl> - baseComplete , <nl> - WriteType . BATCH , <nl> - cleanup ) ; <nl> - <nl> - / / When local node is the endpoint and there are no pending nodes we can <nl> - / / Just apply the mutation locally . <nl> - if ( pairedEndpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) & & wrapper . handler . pendingEndpoints . isEmpty ( ) & & StorageService . instance . isJoined ( ) ) <nl> + Optional < InetAddress > pairedEndpoint = ViewUtils . getViewNaturalEndpoint ( keyspaceName , baseToken , tk ) ; <nl> + Collection < InetAddress > pendingEndpoints = StorageService . instance . getTokenMetadata ( ) . pendingEndpointsFor ( tk , keyspaceName ) ; <nl> + <nl> + if ( pairedEndpoint . isPresent ( ) ) <nl> { <nl> - try <nl> - { <nl> - mutation . apply ( writeCommitLog ) ; <nl> - } <nl> - catch ( Exception exc ) <nl> + / / When local node is the endpoint and there are no pending nodes we can <nl> + / / Just apply the mutation locally . <nl> + if ( pairedEndpoint . get ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) <nl> + & & pendingEndpoints . isEmpty ( ) & & StorageService . instance . isJoined ( ) ) <nl> + try <nl> + { <nl> + mutation . apply ( writeCommitLog ) ; <nl> + } <nl> + catch ( Exception exc ) <nl> + { <nl> + logger . error ( " Error applying local view update to keyspace { } : { } " , mutation . getKeyspaceName ( ) , mutation ) ; <nl> + throw exc ; <nl> + } <nl> + else <nl> { <nl> - logger . error ( " Error applying local view update to keyspace { } : { } " , mutation . getKeyspaceName ( ) , mutation ) ; <nl> - throw exc ; <nl> + wrappers . add ( wrapViewBatchResponseHandler ( mutation , <nl> + consistencyLevel , <nl> + consistencyLevel , <nl> + Collections . singletonList ( pairedEndpoint . get ( ) ) , <nl> + baseComplete , <nl> + WriteType . BATCH , <nl> + cleanup ) ) ; <nl> } <nl> } <nl> else <nl> { <nl> - wrappers . add ( wrapper ) ; <nl> + / / if there are no paired endpoints there are probably range movements going on , <nl> + / / so we write to the local batchlog to replay later <nl> + if ( pendingEndpoints . isEmpty ( ) ) <nl> + logger . warn ( " Received base materialized view mutation for key % s that does not belong " + <nl> + " to this node . There is probably a range movement happening ( move or decommission ) , " + <nl> + " but this node hasn ' t updated its ring metadata yet . Adding mutation to " + <nl> + " local batchlog to be replayed later . " , <nl> + mutation . key ( ) ) ; <nl> + nonPairedMutations . add ( mutation ) ; <nl> } <nl> } <nl> <nl> @ @ - 730 , 6 + 741 , 12 @ @ public class StorageProxy implements StorageProxyMBean <nl> / / now actually perform the writes and wait for them to complete <nl> asyncWriteBatchedMutations ( wrappers , localDataCenter , Stage . VIEW _ MUTATION ) ; <nl> } <nl> + <nl> + if ( ! nonPairedMutations . isEmpty ( ) ) <nl> + { <nl> + BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , nonPairedMutations ) , <nl> + writeCommitLog ) ; <nl> + } <nl> } <nl> } <nl> finally <nl> diff - - git a / test / unit / org / apache / cassandra / db / view / ViewUtilsTest . java b / test / unit / org / apache / cassandra / db / view / ViewUtilsTest . java <nl> index 8fd0cfb . . c238f36 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / view / ViewUtilsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / view / ViewUtilsTest . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . db . view ; <nl> import java . net . InetAddress ; <nl> import java . util . HashMap ; <nl> import java . util . Map ; <nl> + import java . util . Optional ; <nl> <nl> import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> @ @ - 74 , 11 + 75 , 12 @ @ public class ViewUtilsTest <nl> KeyspaceMetadata meta = KeyspaceMetadata . create ( " Keyspace1 " , KeyspaceParams . create ( false , replicationMap ) ) ; <nl> Schema . instance . setKeyspaceMetadata ( meta ) ; <nl> <nl> - InetAddress naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , <nl> + Optional < InetAddress > naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , <nl> new StringToken ( " CA " ) , <nl> new StringToken ( " BB " ) ) ; <nl> <nl> - Assert . assertEquals ( InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) , naturalEndpoint ) ; <nl> + Assert . assertTrue ( naturalEndpoint . isPresent ( ) ) ; <nl> + Assert . assertEquals ( InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) , naturalEndpoint . get ( ) ) ; <nl> } <nl> <nl> <nl> @ @ - 106 , 10 + 108 , 42 @ @ public class ViewUtilsTest <nl> KeyspaceMetadata meta = KeyspaceMetadata . create ( " Keyspace1 " , KeyspaceParams . create ( false , replicationMap ) ) ; <nl> Schema . instance . setKeyspaceMetadata ( meta ) ; <nl> <nl> - InetAddress naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , <nl> + Optional < InetAddress > naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , <nl> new StringToken ( " CA " ) , <nl> new StringToken ( " BB " ) ) ; <nl> <nl> - Assert . assertEquals ( InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) , naturalEndpoint ) ; <nl> + Assert . assertTrue ( naturalEndpoint . isPresent ( ) ) ; <nl> + Assert . assertEquals ( InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) , naturalEndpoint . get ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testBaseTokenDoesNotBelongToLocalReplicaShouldReturnEmpty ( ) throws Exception <nl> + { <nl> + TokenMetadata metadata = StorageService . instance . getTokenMetadata ( ) ; <nl> + metadata . clearUnsafe ( ) ; <nl> + <nl> + / / DC1 <nl> + metadata . updateNormalToken ( new StringToken ( " A " ) , InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ; <nl> + metadata . updateNormalToken ( new StringToken ( " C " ) , InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ) ; <nl> + <nl> + / / DC2 <nl> + metadata . updateNormalToken ( new StringToken ( " B " ) , InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) ) ; <nl> + metadata . updateNormalToken ( new StringToken ( " D " ) , InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) ) ; <nl> + <nl> + Map < String , String > replicationMap = new HashMap < > ( ) ; <nl> + replicationMap . put ( ReplicationParams . CLASS , NetworkTopologyStrategy . class . getName ( ) ) ; <nl> + <nl> + replicationMap . put ( " DC1 " , " 1 " ) ; <nl> + replicationMap . put ( " DC2 " , " 1 " ) ; <nl> + <nl> + Keyspace . clear ( " Keyspace1 " ) ; <nl> + KeyspaceMetadata meta = KeyspaceMetadata . create ( " Keyspace1 " , KeyspaceParams . create ( false , replicationMap ) ) ; <nl> + Schema . instance . setKeyspaceMetadata ( meta ) ; <nl> + <nl> + Optional < InetAddress > naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , <nl> + new StringToken ( " AB " ) , <nl> + new StringToken ( " BB " ) ) ; <nl> + <nl> + Assert . assertFalse ( naturalEndpoint . isPresent ( ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / dht / RandomPartitioner . java b / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> index 15364d3 . . 7e29a7d 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> + + + b / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> @ @ - 160 , 7 + 160 , 7 @ @ public class RandomPartitioner extends AbstractPartitioner < BigIntegerToken > <nl> Iterator i = sortedTokens . iterator ( ) ; <nl> <nl> / / 0 - case <nl> - if ( ! i . hasNext ( ) ) { throw new RuntimeException ( " No nodes present in the cluster . How did you call this ? " ) ; } <nl> + if ( ! i . hasNext ( ) ) { throw new RuntimeException ( " No nodes present in the cluster . Has this node finished starting up ? " ) ; } <nl> / / 1 - case <nl> if ( sortedTokens . size ( ) = = 1 ) { <nl> ownerships . put ( ( Token ) i . next ( ) , new Float ( 1 . 0 ) ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 8f3f182 . . b95aa76 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 1 
 + * Avoid MV race during node decommission ( CASSANDRA - 10674 ) 
 * Disable reloading of GossipingPropertyFileSnitch ( CASSANDRA - 9474 ) 
 * Handle single - column deletions correction in materialized views 
 when the column is part of the view primary key ( CASSANDRA - 10796 ) 
 diff - - git a / src / java / org / apache / cassandra / db / view / ViewUtils . java b / src / java / org / apache / cassandra / db / view / ViewUtils . java 
 index 089a3b7 . . 4d9517f 100644 
 - - - a / src / java / org / apache / cassandra / db / view / ViewUtils . java 
 + + + b / src / java / org / apache / cassandra / db / view / ViewUtils . java 
 @ @ - 21 , 13 + 21 , 13 @ @ package org . apache . cassandra . db . view ; 
 import java . net . InetAddress ; 
 import java . util . ArrayList ; 
 import java . util . List ; 
 + import java . util . Optional ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . locator . NetworkTopologyStrategy ; 
 - import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 public final class ViewUtils 
 @ @ - 56 , 9 + 56 , 9 @ @ public final class ViewUtils 
 * B writes to A ( B ' s cardinality is 2 for T1 , and A ' s cardinality is 2 for T3 ) 
 * C writes to B ( C ' s cardinality is 3 for T1 , and B ' s cardinality is 3 for T3 ) 
 * 
 - * @ throws RuntimeException if this method is called using a base token which does not belong to this replica 
 + * @ return Optional . empty ( ) if this method is called using a base token which does not belong to this replica 
 * / 
 - public static InetAddress getViewNaturalEndpoint ( String keyspaceName , Token baseToken , Token viewToken ) 
 + public static Optional < InetAddress > getViewNaturalEndpoint ( String keyspaceName , Token baseToken , Token viewToken ) 
 { 
 AbstractReplicationStrategy replicationStrategy = Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) ; 
 
 @ @ - 77 , 7 + 77 , 7 @ @ public final class ViewUtils 
 { 
 / / If we are a base endpoint which is also a view replica , we use ourselves as our view replica 
 if ( viewEndpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 - return viewEndpoint ; 
 + return Optional . of ( viewEndpoint ) ; 
 
 / / We have to remove any endpoint which is shared between the base and the view , as it will select itself 
 / / and throw off the counts otherwise . 
 @ @ - 95 , 20 + 95 , 9 @ @ public final class ViewUtils 
 int baseIdx = baseEndpoints . indexOf ( FBUtilities . getBroadcastAddress ( ) ) ; 
 
 if ( baseIdx < 0 ) 
 - { 
 - 
 - if ( StorageService . instance . getTokenMetadata ( ) . pendingEndpointsFor ( viewToken , keyspaceName ) . size ( ) > 0 ) 
 - { 
 - / / Since there are pending endpoints we are going to write to the batchlog regardless . 
 - / / So we can pretend we are the views endpoint . 
 - 
 - return FBUtilities . getBroadcastAddress ( ) ; 
 - } 
 - 
 - throw new RuntimeException ( " Trying to get the view natural endpoint on a non - data replica " ) ; 
 - } 
 - 
 + / / This node is not a base replica of this key , so we return empty 
 + return Optional . empty ( ) ; 
 
 - return viewEndpoints . get ( baseIdx ) ; 
 + return Optional . of ( viewEndpoints . get ( baseIdx ) ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 15be7c6 . . 397b8b9 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 670 , 12 + 670 , 12 @ @ public class StorageProxy implements StorageProxyMBean 
 if ( StorageService . instance . isStarting ( ) | | StorageService . instance . isJoining ( ) | | StorageService . instance . isMoving ( ) ) 
 { 
 BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , 
 - mutations ) , 
 - writeCommitLog ) ; 
 + mutations ) , writeCommitLog ) ; 
 } 
 else 
 { 
 List < WriteResponseHandlerWrapper > wrappers = new ArrayList < > ( mutations . size ( ) ) ; 
 + List < Mutation > nonPairedMutations = new LinkedList < > ( ) ; 
 Token baseToken = StorageService . instance . getTokenMetadata ( ) . partitioner . getToken ( dataKey ) ; 
 
 ConsistencyLevel consistencyLevel = ConsistencyLevel . ONE ; 
 @ @ - 684 , 40 + 684 , 51 @ @ public class StorageProxy implements StorageProxyMBean 
 final Collection < InetAddress > batchlogEndpoints = Collections . singleton ( FBUtilities . getBroadcastAddress ( ) ) ; 
 BatchlogResponseHandler . BatchlogCleanup cleanup = new BatchlogResponseHandler . BatchlogCleanup ( mutations . size ( ) , 
 ( ) - > asyncRemoveFromBatchlog ( batchlogEndpoints , batchUUID ) ) ; 
 - 
 / / add a handler for each mutation - includes checking availability , but doesn ' t initiate any writes , yet 
 for ( Mutation mutation : mutations ) 
 { 
 String keyspaceName = mutation . getKeyspaceName ( ) ; 
 Token tk = mutation . key ( ) . getToken ( ) ; 
 - InetAddress pairedEndpoint = ViewUtils . getViewNaturalEndpoint ( keyspaceName , baseToken , tk ) ; 
 - List < InetAddress > naturalEndpoints = Lists . newArrayList ( pairedEndpoint ) ; 
 - 
 - WriteResponseHandlerWrapper wrapper = wrapViewBatchResponseHandler ( mutation , 
 - consistencyLevel , 
 - consistencyLevel , 
 - naturalEndpoints , 
 - baseComplete , 
 - WriteType . BATCH , 
 - cleanup ) ; 
 - 
 - / / When local node is the endpoint and there are no pending nodes we can 
 - / / Just apply the mutation locally . 
 - if ( pairedEndpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) & & wrapper . handler . pendingEndpoints . isEmpty ( ) & & StorageService . instance . isJoined ( ) ) 
 + Optional < InetAddress > pairedEndpoint = ViewUtils . getViewNaturalEndpoint ( keyspaceName , baseToken , tk ) ; 
 + Collection < InetAddress > pendingEndpoints = StorageService . instance . getTokenMetadata ( ) . pendingEndpointsFor ( tk , keyspaceName ) ; 
 + 
 + if ( pairedEndpoint . isPresent ( ) ) 
 { 
 - try 
 - { 
 - mutation . apply ( writeCommitLog ) ; 
 - } 
 - catch ( Exception exc ) 
 + / / When local node is the endpoint and there are no pending nodes we can 
 + / / Just apply the mutation locally . 
 + if ( pairedEndpoint . get ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) 
 + & & pendingEndpoints . isEmpty ( ) & & StorageService . instance . isJoined ( ) ) 
 + try 
 + { 
 + mutation . apply ( writeCommitLog ) ; 
 + } 
 + catch ( Exception exc ) 
 + { 
 + logger . error ( " Error applying local view update to keyspace { } : { } " , mutation . getKeyspaceName ( ) , mutation ) ; 
 + throw exc ; 
 + } 
 + else 
 { 
 - logger . error ( " Error applying local view update to keyspace { } : { } " , mutation . getKeyspaceName ( ) , mutation ) ; 
 - throw exc ; 
 + wrappers . add ( wrapViewBatchResponseHandler ( mutation , 
 + consistencyLevel , 
 + consistencyLevel , 
 + Collections . singletonList ( pairedEndpoint . get ( ) ) , 
 + baseComplete , 
 + WriteType . BATCH , 
 + cleanup ) ) ; 
 } 
 } 
 else 
 { 
 - wrappers . add ( wrapper ) ; 
 + / / if there are no paired endpoints there are probably range movements going on , 
 + / / so we write to the local batchlog to replay later 
 + if ( pendingEndpoints . isEmpty ( ) ) 
 + logger . warn ( " Received base materialized view mutation for key % s that does not belong " + 
 + " to this node . There is probably a range movement happening ( move or decommission ) , " + 
 + " but this node hasn ' t updated its ring metadata yet . Adding mutation to " + 
 + " local batchlog to be replayed later . " , 
 + mutation . key ( ) ) ; 
 + nonPairedMutations . add ( mutation ) ; 
 } 
 } 
 
 @ @ - 730 , 6 + 741 , 12 @ @ public class StorageProxy implements StorageProxyMBean 
 / / now actually perform the writes and wait for them to complete 
 asyncWriteBatchedMutations ( wrappers , localDataCenter , Stage . VIEW _ MUTATION ) ; 
 } 
 + 
 + if ( ! nonPairedMutations . isEmpty ( ) ) 
 + { 
 + BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , nonPairedMutations ) , 
 + writeCommitLog ) ; 
 + } 
 } 
 } 
 finally 
 diff - - git a / test / unit / org / apache / cassandra / db / view / ViewUtilsTest . java b / test / unit / org / apache / cassandra / db / view / ViewUtilsTest . java 
 index 8fd0cfb . . c238f36 100644 
 - - - a / test / unit / org / apache / cassandra / db / view / ViewUtilsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / view / ViewUtilsTest . java 
 @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . db . view ; 
 import java . net . InetAddress ; 
 import java . util . HashMap ; 
 import java . util . Map ; 
 + import java . util . Optional ; 
 
 import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 @ @ - 74 , 11 + 75 , 12 @ @ public class ViewUtilsTest 
 KeyspaceMetadata meta = KeyspaceMetadata . create ( " Keyspace1 " , KeyspaceParams . create ( false , replicationMap ) ) ; 
 Schema . instance . setKeyspaceMetadata ( meta ) ; 
 
 - InetAddress naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , 
 + Optional < InetAddress > naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , 
 new StringToken ( " CA " ) , 
 new StringToken ( " BB " ) ) ; 
 
 - Assert . assertEquals ( InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) , naturalEndpoint ) ; 
 + Assert . assertTrue ( naturalEndpoint . isPresent ( ) ) ; 
 + Assert . assertEquals ( InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) , naturalEndpoint . get ( ) ) ; 
 } 
 
 
 @ @ - 106 , 10 + 108 , 42 @ @ public class ViewUtilsTest 
 KeyspaceMetadata meta = KeyspaceMetadata . create ( " Keyspace1 " , KeyspaceParams . create ( false , replicationMap ) ) ; 
 Schema . instance . setKeyspaceMetadata ( meta ) ; 
 
 - InetAddress naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , 
 + Optional < InetAddress > naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , 
 new StringToken ( " CA " ) , 
 new StringToken ( " BB " ) ) ; 
 
 - Assert . assertEquals ( InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) , naturalEndpoint ) ; 
 + Assert . assertTrue ( naturalEndpoint . isPresent ( ) ) ; 
 + Assert . assertEquals ( InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) , naturalEndpoint . get ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testBaseTokenDoesNotBelongToLocalReplicaShouldReturnEmpty ( ) throws Exception 
 + { 
 + TokenMetadata metadata = StorageService . instance . getTokenMetadata ( ) ; 
 + metadata . clearUnsafe ( ) ; 
 + 
 + / / DC1 
 + metadata . updateNormalToken ( new StringToken ( " A " ) , InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ) ; 
 + metadata . updateNormalToken ( new StringToken ( " C " ) , InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ) ; 
 + 
 + / / DC2 
 + metadata . updateNormalToken ( new StringToken ( " B " ) , InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) ) ; 
 + metadata . updateNormalToken ( new StringToken ( " D " ) , InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) ) ; 
 + 
 + Map < String , String > replicationMap = new HashMap < > ( ) ; 
 + replicationMap . put ( ReplicationParams . CLASS , NetworkTopologyStrategy . class . getName ( ) ) ; 
 + 
 + replicationMap . put ( " DC1 " , " 1 " ) ; 
 + replicationMap . put ( " DC2 " , " 1 " ) ; 
 + 
 + Keyspace . clear ( " Keyspace1 " ) ; 
 + KeyspaceMetadata meta = KeyspaceMetadata . create ( " Keyspace1 " , KeyspaceParams . create ( false , replicationMap ) ) ; 
 + Schema . instance . setKeyspaceMetadata ( meta ) ; 
 + 
 + Optional < InetAddress > naturalEndpoint = ViewUtils . getViewNaturalEndpoint ( " Keyspace1 " , 
 + new StringToken ( " AB " ) , 
 + new StringToken ( " BB " ) ) ; 
 + 
 + Assert . assertFalse ( naturalEndpoint . isPresent ( ) ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / dht / RandomPartitioner . java b / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 index 15364d3 . . 7e29a7d 100644 
 - - - a / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 + + + b / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 @ @ - 160 , 7 + 160 , 7 @ @ public class RandomPartitioner extends AbstractPartitioner < BigIntegerToken > 
 Iterator i = sortedTokens . iterator ( ) ; 
 
 / / 0 - case 
 - if ( ! i . hasNext ( ) ) { throw new RuntimeException ( " No nodes present in the cluster . How did you call this ? " ) ; } 
 + if ( ! i . hasNext ( ) ) { throw new RuntimeException ( " No nodes present in the cluster . Has this node finished starting up ? " ) ; } 
 / / 1 - case 
 if ( sortedTokens . size ( ) = = 1 ) { 
 ownerships . put ( ( Token ) i . next ( ) , new Float ( 1 . 0 ) ) ;
