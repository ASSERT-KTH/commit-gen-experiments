BLEU SCORE: 0.03816485328625671

TEST MSG: Reduce cassandra - stress sampling memory requirements
GENERATED MSG: cassandra - stress : merge 7468 into 2 . 1 , and ninja - fix duration setting for user command

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 18efc7e . . fa42e85 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 3 <nl> + * Reduce cassandra - stress sampling memory requirements ( CASSANDRA - 7926 ) <nl> * Ensure memtable flush cannot expire commit log entries from its future ( CASSANDRA - 8383 ) <nl> * Make read " defrag " async to reclaim memtables ( CASSANDRA - 8459 ) <nl> * Remove tmplink files for offline compactions ( CASSANDRA - 8321 ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressAction . java b / tools / stress / src / org / apache / cassandra / stress / StressAction . java <nl> index b50637f . . 68e0004 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / StressAction . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / StressAction . java <nl> @ @ - 189 , 7 + 189 , 10 @ @ public class StressAction implements Runnable <nl> final CountDownLatch done = new CountDownLatch ( threadCount ) ; <nl> final Consumer [ ] consumers = new Consumer [ threadCount ] ; <nl> for ( int i = 0 ; i < threadCount ; i + + ) <nl> - consumers [ i ] = new Consumer ( operations , done , workManager , metrics , rateLimiter ) ; <nl> + { <nl> + Timer timer = metrics . getTiming ( ) . newTimer ( settings . samples . liveCount / threadCount ) ; <nl> + consumers [ i ] = new Consumer ( operations , done , workManager , timer , metrics , rateLimiter ) ; <nl> + } <nl> <nl> / / starting worker threadCount <nl> for ( int i = 0 ; i < threadCount ; i + + ) <nl> @ @ - 246 , 19 + 249 , 19 @ @ public class StressAction implements Runnable <nl> private final WorkManager workManager ; <nl> private final CountDownLatch done ; <nl> <nl> - public Consumer ( OpDistributionFactory operations , CountDownLatch done , WorkManager workManager , StressMetrics metrics , RateLimiter rateLimiter ) <nl> + public Consumer ( OpDistributionFactory operations , CountDownLatch done , WorkManager workManager , Timer timer , StressMetrics metrics , RateLimiter rateLimiter ) <nl> { <nl> this . done = done ; <nl> this . rateLimiter = rateLimiter ; <nl> this . workManager = workManager ; <nl> this . metrics = metrics ; <nl> - this . timer = metrics . getTiming ( ) . newTimer ( ) ; <nl> + this . timer = timer ; <nl> this . operations = operations . get ( timer ) ; <nl> } <nl> <nl> public void run ( ) <nl> { <nl> - <nl> + timer . init ( ) ; <nl> try <nl> { <nl> <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressMetrics . java b / tools / stress / src / org / apache / cassandra / stress / StressMetrics . java <nl> index 00f479e . . 3a4a4a3 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / StressMetrics . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / StressMetrics . java <nl> @ @ - 27 , 7 + 27 , 6 @ @ import java . util . List ; <nl> import java . util . concurrent . Callable ; <nl> import java . util . concurrent . CountDownLatch ; <nl> import java . util . concurrent . ThreadFactory ; <nl> - import java . util . concurrent . TimeUnit ; <nl> <nl> import org . apache . commons . lang3 . time . DurationFormatUtils ; <nl> <nl> @ @ - 50 , 7 + 49 , 7 @ @ public class StressMetrics <nl> private volatile boolean cancelled = false ; <nl> private final Uncertainty rowRateUncertainty = new Uncertainty ( ) ; <nl> private final CountDownLatch stopped = new CountDownLatch ( 1 ) ; <nl> - private final Timing timing = new Timing ( ) ; <nl> + private final Timing timing ; <nl> private final Callable < JmxCollector . GcStats > gcStatsCollector ; <nl> private volatile JmxCollector . GcStats totalGcStats ; <nl> <nl> @ @ - 80 , 6 + 79 , 7 @ @ public class StressMetrics <nl> } ; <nl> } <nl> this . gcStatsCollector = gcStatsCollector ; <nl> + this . timing = new Timing ( settings . samples . historyCount , settings . samples . reportCount ) ; <nl> <nl> printHeader ( " " , output ) ; <nl> thread = tf . newThread ( new Runnable ( ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / CliOption . java b / tools / stress / src / org / apache / cassandra / stress / settings / CliOption . java <nl> index 7fd10ff . . 5ec56dc 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / CliOption . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / CliOption . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ public enum CliOption <nl> RATE ( " Thread count , rate limit or automatic mode ( default is auto ) " , SettingsRate . helpPrinter ( ) ) , <nl> MODE ( " Thrift or CQL with options " , SettingsMode . helpPrinter ( ) ) , <nl> ERRORS ( " How to handle errors when encountered during stress " , SettingsErrors . helpPrinter ( ) ) , <nl> + SAMPLE ( " Specify the number of samples to collect for measuring latency " , SettingsSamples . helpPrinter ( ) ) , <nl> SCHEMA ( " Replication settings , compression , compaction , etc . " , SettingsSchema . helpPrinter ( ) ) , <nl> NODE ( " Nodes to connect to " , SettingsNode . helpPrinter ( ) ) , <nl> LOG ( " Where to log progress to , and the interval at which to do it " , SettingsLog . helpPrinter ( ) ) , <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommand . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommand . java <nl> index a1c89e1 . . 8850544 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommand . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommand . java <nl> @ @ - 63 , 7 + 63 , 7 @ @ public abstract class SettingsCommand implements Serializable <nl> this . noWarmup = options . noWarmup . setByUser ( ) ; <nl> if ( count ! = null ) <nl> { <nl> - this . count = Long . parseLong ( count . count . value ( ) ) ; <nl> + this . count = OptionDistribution . parseLong ( count . count . value ( ) ) ; <nl> this . duration = 0 ; <nl> this . durationUnits = null ; <nl> this . targetUncertainty = - 1 ; <nl> @ @ - 113 , 7 + 113 , 7 @ @ public abstract class SettingsCommand implements Serializable <nl> <nl> static class Count extends Options <nl> { <nl> - final OptionSimple count = new OptionSimple ( " n = " , " [ 0 - 9 ] + " , null , " Number of operations to perform " , true ) ; <nl> + final OptionSimple count = new OptionSimple ( " n = " , " [ 0 - 9 ] + [ bmk ] ? " , null , " Number of operations to perform " , true ) ; <nl> @ Override <nl> public List < ? extends Option > options ( ) <nl> { <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSamples . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSamples . java <nl> new file mode 100644 <nl> index 0000000 . . 7a9f484 <nl> - - - / dev / null <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSamples . java <nl> @ @ - 0 , 0 + 1 , 94 @ @ <nl> + package org . apache . cassandra . stress . settings ; <nl> + / * <nl> + * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * <nl> + * / <nl> + <nl> + <nl> + import java . io . Serializable ; <nl> + import java . util . Arrays ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + <nl> + public class SettingsSamples implements Serializable <nl> + { <nl> + <nl> + public final int liveCount ; <nl> + public final int historyCount ; <nl> + public final int reportCount ; <nl> + <nl> + public SettingsSamples ( SampleOptions options ) <nl> + { <nl> + liveCount = ( int ) OptionDistribution . parseLong ( options . liveCount . value ( ) ) ; <nl> + historyCount = ( int ) OptionDistribution . parseLong ( options . historyCount . value ( ) ) ; <nl> + reportCount = ( int ) OptionDistribution . parseLong ( options . reportCount . value ( ) ) ; <nl> + } <nl> + <nl> + / / Option Declarations <nl> + <nl> + private static final class SampleOptions extends GroupedOptions <nl> + { <nl> + final OptionSimple historyCount = new OptionSimple ( " history = " , " [ 0 - 9 ] + [ bmk ] ? " , " 50K " , " The number of samples to save across the whole run " , false ) ; <nl> + final OptionSimple liveCount = new OptionSimple ( " live = " , " [ 0 - 9 ] + [ bmk ] ? " , " 1M " , " The number of samples to save between reports " , false ) ; <nl> + final OptionSimple reportCount = new OptionSimple ( " report = " , " [ 0 - 9 ] + [ bmk ] ? " , " 100K " , " The maximum number of samples to use when building a report " , false ) ; <nl> + <nl> + @ Override <nl> + public List < ? extends Option > options ( ) <nl> + { <nl> + return Arrays . asList ( historyCount , liveCount , reportCount ) ; <nl> + } <nl> + } <nl> + <nl> + / / CLI Utility Methods <nl> + <nl> + public static SettingsSamples get ( Map < String , String [ ] > clArgs ) <nl> + { <nl> + String [ ] params = clArgs . remove ( " - sample " ) ; <nl> + if ( params = = null ) <nl> + { <nl> + return new SettingsSamples ( new SampleOptions ( ) ) ; <nl> + } <nl> + SampleOptions options = GroupedOptions . select ( params , new SampleOptions ( ) ) ; <nl> + if ( options = = null ) <nl> + { <nl> + printHelp ( ) ; <nl> + System . out . println ( " Invalid - sample options provided , see output for valid options " ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + return new SettingsSamples ( options ) ; <nl> + } <nl> + <nl> + public static void printHelp ( ) <nl> + { <nl> + GroupedOptions . printOptions ( System . out , " - sample " , new SampleOptions ( ) ) ; <nl> + } <nl> + <nl> + public static Runnable helpPrinter ( ) <nl> + { <nl> + return new Runnable ( ) <nl> + { <nl> + @ Override <nl> + public void run ( ) <nl> + { <nl> + printHelp ( ) ; <nl> + } <nl> + } ; <nl> + } <nl> + } <nl> + <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / StressSettings . java b / tools / stress / src / org / apache / cassandra / stress / settings / StressSettings . java <nl> index ba72821 . . 815fe9b 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / StressSettings . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / StressSettings . java <nl> @ @ - 46 , 6 + 46 , 7 @ @ public class StressSettings implements Serializable <nl> public final SettingsPopulation generate ; <nl> public final SettingsInsert insert ; <nl> public final SettingsColumn columns ; <nl> + public final SettingsSamples samples ; <nl> public final SettingsErrors errors ; <nl> public final SettingsLog log ; <nl> public final SettingsMode mode ; <nl> @ @ - 55 , 13 + 56 , 14 @ @ public class StressSettings implements Serializable <nl> public final SettingsPort port ; <nl> public final String sendToDaemon ; <nl> <nl> - public StressSettings ( SettingsCommand command , SettingsRate rate , SettingsPopulation generate , SettingsInsert insert , SettingsColumn columns , SettingsErrors errors , SettingsLog log , SettingsMode mode , SettingsNode node , SettingsSchema schema , SettingsTransport transport , SettingsPort port , String sendToDaemon ) <nl> + public StressSettings ( SettingsCommand command , SettingsRate rate , SettingsPopulation generate , SettingsInsert insert , SettingsColumn columns , SettingsSamples samples , SettingsErrors errors , SettingsLog log , SettingsMode mode , SettingsNode node , SettingsSchema schema , SettingsTransport transport , SettingsPort port , String sendToDaemon ) <nl> { <nl> this . command = command ; <nl> this . rate = rate ; <nl> this . insert = insert ; <nl> this . generate = generate ; <nl> this . columns = columns ; <nl> + this . samples = samples ; <nl> this . errors = errors ; <nl> this . log = log ; <nl> this . mode = mode ; <nl> @ @ - 232 , 6 + 234 , 7 @ @ public class StressSettings implements Serializable <nl> SettingsPopulation generate = SettingsPopulation . get ( clArgs , command ) ; <nl> SettingsInsert insert = SettingsInsert . get ( clArgs ) ; <nl> SettingsColumn columns = SettingsColumn . get ( clArgs ) ; <nl> + SettingsSamples samples = SettingsSamples . get ( clArgs ) ; <nl> SettingsErrors errors = SettingsErrors . get ( clArgs ) ; <nl> SettingsLog log = SettingsLog . get ( clArgs ) ; <nl> SettingsMode mode = SettingsMode . get ( clArgs ) ; <nl> @ @ - 254 , 7 + 257 , 7 @ @ public class StressSettings implements Serializable <nl> } <nl> System . exit ( 1 ) ; <nl> } <nl> - return new StressSettings ( command , rate , generate , insert , columns , errors , log , mode , node , schema , transport , port , sendToDaemon ) ; <nl> + return new StressSettings ( command , rate , generate , insert , columns , samples , errors , log , mode , node , schema , transport , port , sendToDaemon ) ; <nl> } <nl> <nl> private static Map < String , String [ ] > parseMap ( String [ ] args ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / SampleOfLongs . java b / tools / stress / src / org / apache / cassandra / stress / util / SampleOfLongs . java <nl> index 8be9f81 . . ed54ee0 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / util / SampleOfLongs . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / util / SampleOfLongs . java <nl> @ @ - 51 , 61 + 51 , 44 @ @ public final class SampleOfLongs <nl> <nl> static SampleOfLongs merge ( Random rnd , List < SampleOfLongs > merge , int maxSamples ) <nl> { <nl> - int maxLength = 0 ; <nl> + / / grab the lowest probability of selection , and normalise all samples to that <nl> double targetp = 1 ; <nl> for ( SampleOfLongs sampleOfLongs : merge ) <nl> - { <nl> - maxLength + = sampleOfLongs . sample . length ; <nl> targetp = Math . min ( targetp , sampleOfLongs . p ) ; <nl> + <nl> + / / calculate how many samples we should encounter <nl> + int maxLength = 0 ; <nl> + for ( SampleOfLongs sampleOfLongs : merge ) <nl> + maxLength + = sampleOfLongs . sample . length * ( targetp / sampleOfLongs . p ) ; <nl> + <nl> + if ( maxLength > maxSamples ) <nl> + { <nl> + targetp * = maxSamples / ( double ) maxLength ; <nl> + maxLength = maxSamples ; <nl> } <nl> + <nl> long [ ] sample = new long [ maxLength ] ; <nl> int count = 0 ; <nl> - for ( SampleOfLongs latencies : merge ) <nl> + out : for ( SampleOfLongs latencies : merge ) <nl> { <nl> long [ ] in = latencies . sample ; <nl> double p = targetp / latencies . p ; <nl> for ( int i = 0 ; i < in . length ; i + + ) <nl> + { <nl> if ( rnd . nextDouble ( ) < p ) <nl> + { <nl> sample [ count + + ] = in [ i ] ; <nl> + if ( count = = maxLength ) <nl> + break out ; <nl> + } <nl> + } <nl> } <nl> - if ( count > maxSamples ) <nl> - { <nl> - targetp = subsample ( rnd , maxSamples , sample , count , targetp ) ; <nl> - count = maxSamples ; <nl> - } <nl> - sample = Arrays . copyOf ( sample , count ) ; <nl> + if ( count ! = maxLength ) <nl> + sample = Arrays . copyOf ( sample , count ) ; <nl> Arrays . sort ( sample ) ; <nl> return new SampleOfLongs ( sample , targetp ) ; <nl> } <nl> <nl> - public SampleOfLongs subsample ( Random rnd , int maxSamples ) <nl> - { <nl> - if ( maxSamples > sample . length ) <nl> - return this ; <nl> - <nl> - long [ ] sample = this . sample . clone ( ) ; <nl> - double p = subsample ( rnd , maxSamples , sample , sample . length , this . p ) ; <nl> - sample = Arrays . copyOf ( sample , maxSamples ) ; <nl> - return new SampleOfLongs ( sample , p ) ; <nl> - } <nl> - <nl> - private static double subsample ( Random rnd , int maxSamples , long [ ] sample , int count , double p ) <nl> - { <nl> - / / want exactly maxSamples , so select random indexes up to maxSamples <nl> - for ( int i = 0 ; i < maxSamples ; i + + ) <nl> - { <nl> - int take = i + rnd . nextInt ( count - i ) ; <nl> - long tmp = sample [ i ] ; <nl> - sample [ i ] = sample [ take ] ; <nl> - sample [ take ] = tmp ; <nl> - } <nl> - <nl> - / / calculate new p ; have selected with probability maxSamples / count <nl> - / / so multiply p by this probability <nl> - p * = maxSamples / ( double ) sample . length ; <nl> - return p ; <nl> - } <nl> - <nl> public double medianLatency ( ) <nl> { <nl> if ( sample . length = = 0 ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / Timer . java b / tools / stress / src / org / apache / cassandra / stress / util / Timer . java <nl> index 4e2b0a3 . . 7449a00 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / util / Timer . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / util / Timer . java <nl> @ @ - 25 , 21 + 25 , 18 @ @ import java . util . Arrays ; <nl> import java . util . List ; <nl> import java . util . Random ; <nl> import java . util . concurrent . CountDownLatch ; <nl> + import java . util . concurrent . ThreadLocalRandom ; <nl> <nl> / / a timer - this timer must be used by a single thread , and co - ordinates with other timers by <nl> public final class Timer <nl> { <nl> - <nl> - private static final int SAMPLE _ SIZE _ SHIFT = 14 ; <nl> - private static final int SAMPLE _ SIZE _ MASK = ( 1 < < SAMPLE _ SIZE _ SHIFT ) - 1 ; <nl> - <nl> - private final Random rnd = new Random ( ) ; <nl> + private ThreadLocalRandom rnd ; <nl> <nl> / / in progress snap start <nl> private long sampleStartNanos ; <nl> <nl> / / each entry is present with probability 1 / p ( opCount ) or 1 / ( p ( opCount ) - 1 ) <nl> - private final long [ ] sample = new long [ 1 < < SAMPLE _ SIZE _ SHIFT ] ; <nl> + private final long [ ] sample ; <nl> private int opCount ; <nl> <nl> / / aggregate info <nl> @ @ - 56 , 14 + 53 , 25 @ @ public final class Timer <nl> volatile TimingInterval report ; <nl> private volatile TimingInterval finalReport ; <nl> <nl> + public Timer ( int sampleCount ) <nl> + { <nl> + int powerOf2 = 32 - Integer . numberOfLeadingZeros ( sampleCount - 1 ) ; <nl> + this . sample = new long [ 1 < < powerOf2 ] ; <nl> + } <nl> + <nl> + public void init ( ) <nl> + { <nl> + rnd = ThreadLocalRandom . current ( ) ; <nl> + } <nl> + <nl> public void start ( ) { <nl> / / decide if we ' re logging this event <nl> sampleStartNanos = System . nanoTime ( ) ; <nl> } <nl> <nl> - private static int p ( int index ) <nl> + private int p ( int index ) <nl> { <nl> - return 1 + ( index > > > SAMPLE _ SIZE _ SHIFT ) ; <nl> + return 1 + ( index / sample . length ) ; <nl> } <nl> <nl> public boolean running ( ) <nl> @ @ - 90 , 9 + 98 , 9 @ @ public final class Timer <nl> upToDateAsOf = now ; <nl> } <nl> <nl> - private static int index ( int count ) <nl> + private int index ( int count ) <nl> { <nl> - return count & SAMPLE _ SIZE _ MASK ; <nl> + return count & ( sample . length - 1 ) ; <nl> } <nl> <nl> private TimingInterval buildReport ( ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / Timing . java b / tools / stress / src / org / apache / cassandra / stress / util / Timing . java <nl> index 9eadf42 . . f48ce35 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / util / Timing . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / util / Timing . java <nl> @ @ - 40 , 9 + 40 , 16 @ @ public class Timing <nl> <nl> private final CopyOnWriteArrayList < Timer > timers = new CopyOnWriteArrayList < > ( ) ; <nl> private volatile TimingInterval history ; <nl> - private final Random rnd = new Random ( ) ; <nl> + private final int historySampleCount ; <nl> + private final int reportSampleCount ; <nl> private boolean done ; <nl> <nl> + public Timing ( int historySampleCount , int reportSampleCount ) <nl> + { <nl> + this . historySampleCount = historySampleCount ; <nl> + this . reportSampleCount = reportSampleCount ; <nl> + } <nl> + <nl> / / TIMING <nl> <nl> public static class TimingResult < E > <nl> @ @ - 56 , 7 + 63 , 7 @ @ public class Timing <nl> } <nl> } <nl> <nl> - private < E > TimingResult < E > snap ( Random rnd , Callable < E > call ) throws InterruptedException <nl> + public < E > TimingResult < E > snap ( Callable < E > call ) throws InterruptedException <nl> { <nl> final Timer [ ] timers = this . timers . toArray ( new Timer [ 0 ] ) ; <nl> final CountDownLatch ready = new CountDownLatch ( timers . length ) ; <nl> @ @ - 92 , 13 + 99 , 15 @ @ public class Timing <nl> } <nl> <nl> this . done = done ; <nl> - return new TimingResult < > ( extra , TimingInterval . merge ( rnd , intervals , Integer . MAX _ VALUE , history . endNanos ( ) ) ) ; <nl> + TimingResult < E > result = new TimingResult < > ( extra , TimingInterval . merge ( intervals , reportSampleCount , history . endNanos ( ) ) ) ; <nl> + history = TimingInterval . merge ( Arrays . asList ( result . timing , history ) , historySampleCount , history . startNanos ( ) ) ; <nl> + return result ; <nl> } <nl> <nl> / / build a new timer and add it to the set of running timers <nl> - public Timer newTimer ( ) <nl> + public Timer newTimer ( int sampleCount ) <nl> { <nl> - final Timer timer = new Timer ( ) ; <nl> + final Timer timer = new Timer ( sampleCount ) ; <nl> timers . add ( timer ) ; <nl> return timer ; <nl> } <nl> @ @ - 113 , 13 + 122 , 6 @ @ public class Timing <nl> return done ; <nl> } <nl> <nl> - public < E > TimingResult < E > snap ( Callable < E > call ) throws InterruptedException <nl> - { <nl> - final TimingResult < E > result = snap ( rnd , call ) ; <nl> - history = TimingInterval . merge ( rnd , Arrays . asList ( result . timing , history ) , 200000 , history . startNanos ( ) ) ; <nl> - return result ; <nl> - } <nl> - <nl> public TimingInterval getHistory ( ) <nl> { <nl> return history ; <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / TimingInterval . java b / tools / stress / src / org / apache / cassandra / stress / util / TimingInterval . java <nl> index 50ab608 . . 11d313f 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / util / TimingInterval . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / util / TimingInterval . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . List ; <nl> import java . util . Random ; <nl> + import java . util . concurrent . ThreadLocalRandom ; <nl> <nl> / / represents measurements taken over an interval of time <nl> / / used for both single timer results and merged timer results <nl> @ @ - 68 , 8 + 69 , 9 @ @ public final class TimingInterval <nl> } <nl> <nl> / / merge multiple timer intervals together <nl> - static TimingInterval merge ( Random rnd , List < TimingInterval > intervals , int maxSamples , long start ) <nl> + static TimingInterval merge ( List < TimingInterval > intervals , int maxSamples , long start ) <nl> { <nl> + ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; <nl> long operationCount = 0 , partitionCount = 0 , rowCount = 0 ; <nl> long maxLatency = 0 , totalLatency = 0 ; <nl> List < SampleOfLongs > latencies = new ArrayList < > ( ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 18efc7e . . fa42e85 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 3 
 + * Reduce cassandra - stress sampling memory requirements ( CASSANDRA - 7926 ) 
 * Ensure memtable flush cannot expire commit log entries from its future ( CASSANDRA - 8383 ) 
 * Make read " defrag " async to reclaim memtables ( CASSANDRA - 8459 ) 
 * Remove tmplink files for offline compactions ( CASSANDRA - 8321 ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressAction . java b / tools / stress / src / org / apache / cassandra / stress / StressAction . java 
 index b50637f . . 68e0004 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / StressAction . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / StressAction . java 
 @ @ - 189 , 7 + 189 , 10 @ @ public class StressAction implements Runnable 
 final CountDownLatch done = new CountDownLatch ( threadCount ) ; 
 final Consumer [ ] consumers = new Consumer [ threadCount ] ; 
 for ( int i = 0 ; i < threadCount ; i + + ) 
 - consumers [ i ] = new Consumer ( operations , done , workManager , metrics , rateLimiter ) ; 
 + { 
 + Timer timer = metrics . getTiming ( ) . newTimer ( settings . samples . liveCount / threadCount ) ; 
 + consumers [ i ] = new Consumer ( operations , done , workManager , timer , metrics , rateLimiter ) ; 
 + } 
 
 / / starting worker threadCount 
 for ( int i = 0 ; i < threadCount ; i + + ) 
 @ @ - 246 , 19 + 249 , 19 @ @ public class StressAction implements Runnable 
 private final WorkManager workManager ; 
 private final CountDownLatch done ; 
 
 - public Consumer ( OpDistributionFactory operations , CountDownLatch done , WorkManager workManager , StressMetrics metrics , RateLimiter rateLimiter ) 
 + public Consumer ( OpDistributionFactory operations , CountDownLatch done , WorkManager workManager , Timer timer , StressMetrics metrics , RateLimiter rateLimiter ) 
 { 
 this . done = done ; 
 this . rateLimiter = rateLimiter ; 
 this . workManager = workManager ; 
 this . metrics = metrics ; 
 - this . timer = metrics . getTiming ( ) . newTimer ( ) ; 
 + this . timer = timer ; 
 this . operations = operations . get ( timer ) ; 
 } 
 
 public void run ( ) 
 { 
 - 
 + timer . init ( ) ; 
 try 
 { 
 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressMetrics . java b / tools / stress / src / org / apache / cassandra / stress / StressMetrics . java 
 index 00f479e . . 3a4a4a3 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / StressMetrics . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / StressMetrics . java 
 @ @ - 27 , 7 + 27 , 6 @ @ import java . util . List ; 
 import java . util . concurrent . Callable ; 
 import java . util . concurrent . CountDownLatch ; 
 import java . util . concurrent . ThreadFactory ; 
 - import java . util . concurrent . TimeUnit ; 
 
 import org . apache . commons . lang3 . time . DurationFormatUtils ; 
 
 @ @ - 50 , 7 + 49 , 7 @ @ public class StressMetrics 
 private volatile boolean cancelled = false ; 
 private final Uncertainty rowRateUncertainty = new Uncertainty ( ) ; 
 private final CountDownLatch stopped = new CountDownLatch ( 1 ) ; 
 - private final Timing timing = new Timing ( ) ; 
 + private final Timing timing ; 
 private final Callable < JmxCollector . GcStats > gcStatsCollector ; 
 private volatile JmxCollector . GcStats totalGcStats ; 
 
 @ @ - 80 , 6 + 79 , 7 @ @ public class StressMetrics 
 } ; 
 } 
 this . gcStatsCollector = gcStatsCollector ; 
 + this . timing = new Timing ( settings . samples . historyCount , settings . samples . reportCount ) ; 
 
 printHeader ( " " , output ) ; 
 thread = tf . newThread ( new Runnable ( ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / CliOption . java b / tools / stress / src / org / apache / cassandra / stress / settings / CliOption . java 
 index 7fd10ff . . 5ec56dc 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / CliOption . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / CliOption . java 
 @ @ - 32 , 6 + 32 , 7 @ @ public enum CliOption 
 RATE ( " Thread count , rate limit or automatic mode ( default is auto ) " , SettingsRate . helpPrinter ( ) ) , 
 MODE ( " Thrift or CQL with options " , SettingsMode . helpPrinter ( ) ) , 
 ERRORS ( " How to handle errors when encountered during stress " , SettingsErrors . helpPrinter ( ) ) , 
 + SAMPLE ( " Specify the number of samples to collect for measuring latency " , SettingsSamples . helpPrinter ( ) ) , 
 SCHEMA ( " Replication settings , compression , compaction , etc . " , SettingsSchema . helpPrinter ( ) ) , 
 NODE ( " Nodes to connect to " , SettingsNode . helpPrinter ( ) ) , 
 LOG ( " Where to log progress to , and the interval at which to do it " , SettingsLog . helpPrinter ( ) ) , 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommand . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommand . java 
 index a1c89e1 . . 8850544 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommand . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommand . java 
 @ @ - 63 , 7 + 63 , 7 @ @ public abstract class SettingsCommand implements Serializable 
 this . noWarmup = options . noWarmup . setByUser ( ) ; 
 if ( count ! = null ) 
 { 
 - this . count = Long . parseLong ( count . count . value ( ) ) ; 
 + this . count = OptionDistribution . parseLong ( count . count . value ( ) ) ; 
 this . duration = 0 ; 
 this . durationUnits = null ; 
 this . targetUncertainty = - 1 ; 
 @ @ - 113 , 7 + 113 , 7 @ @ public abstract class SettingsCommand implements Serializable 
 
 static class Count extends Options 
 { 
 - final OptionSimple count = new OptionSimple ( " n = " , " [ 0 - 9 ] + " , null , " Number of operations to perform " , true ) ; 
 + final OptionSimple count = new OptionSimple ( " n = " , " [ 0 - 9 ] + [ bmk ] ? " , null , " Number of operations to perform " , true ) ; 
 @ Override 
 public List < ? extends Option > options ( ) 
 { 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSamples . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSamples . java 
 new file mode 100644 
 index 0000000 . . 7a9f484 
 - - - / dev / null 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSamples . java 
 @ @ - 0 , 0 + 1 , 94 @ @ 
 + package org . apache . cassandra . stress . settings ; 
 + / * 
 + * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * 
 + * / 
 + 
 + 
 + import java . io . Serializable ; 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + 
 + public class SettingsSamples implements Serializable 
 + { 
 + 
 + public final int liveCount ; 
 + public final int historyCount ; 
 + public final int reportCount ; 
 + 
 + public SettingsSamples ( SampleOptions options ) 
 + { 
 + liveCount = ( int ) OptionDistribution . parseLong ( options . liveCount . value ( ) ) ; 
 + historyCount = ( int ) OptionDistribution . parseLong ( options . historyCount . value ( ) ) ; 
 + reportCount = ( int ) OptionDistribution . parseLong ( options . reportCount . value ( ) ) ; 
 + } 
 + 
 + / / Option Declarations 
 + 
 + private static final class SampleOptions extends GroupedOptions 
 + { 
 + final OptionSimple historyCount = new OptionSimple ( " history = " , " [ 0 - 9 ] + [ bmk ] ? " , " 50K " , " The number of samples to save across the whole run " , false ) ; 
 + final OptionSimple liveCount = new OptionSimple ( " live = " , " [ 0 - 9 ] + [ bmk ] ? " , " 1M " , " The number of samples to save between reports " , false ) ; 
 + final OptionSimple reportCount = new OptionSimple ( " report = " , " [ 0 - 9 ] + [ bmk ] ? " , " 100K " , " The maximum number of samples to use when building a report " , false ) ; 
 + 
 + @ Override 
 + public List < ? extends Option > options ( ) 
 + { 
 + return Arrays . asList ( historyCount , liveCount , reportCount ) ; 
 + } 
 + } 
 + 
 + / / CLI Utility Methods 
 + 
 + public static SettingsSamples get ( Map < String , String [ ] > clArgs ) 
 + { 
 + String [ ] params = clArgs . remove ( " - sample " ) ; 
 + if ( params = = null ) 
 + { 
 + return new SettingsSamples ( new SampleOptions ( ) ) ; 
 + } 
 + SampleOptions options = GroupedOptions . select ( params , new SampleOptions ( ) ) ; 
 + if ( options = = null ) 
 + { 
 + printHelp ( ) ; 
 + System . out . println ( " Invalid - sample options provided , see output for valid options " ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + return new SettingsSamples ( options ) ; 
 + } 
 + 
 + public static void printHelp ( ) 
 + { 
 + GroupedOptions . printOptions ( System . out , " - sample " , new SampleOptions ( ) ) ; 
 + } 
 + 
 + public static Runnable helpPrinter ( ) 
 + { 
 + return new Runnable ( ) 
 + { 
 + @ Override 
 + public void run ( ) 
 + { 
 + printHelp ( ) ; 
 + } 
 + } ; 
 + } 
 + } 
 + 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / StressSettings . java b / tools / stress / src / org / apache / cassandra / stress / settings / StressSettings . java 
 index ba72821 . . 815fe9b 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / StressSettings . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / StressSettings . java 
 @ @ - 46 , 6 + 46 , 7 @ @ public class StressSettings implements Serializable 
 public final SettingsPopulation generate ; 
 public final SettingsInsert insert ; 
 public final SettingsColumn columns ; 
 + public final SettingsSamples samples ; 
 public final SettingsErrors errors ; 
 public final SettingsLog log ; 
 public final SettingsMode mode ; 
 @ @ - 55 , 13 + 56 , 14 @ @ public class StressSettings implements Serializable 
 public final SettingsPort port ; 
 public final String sendToDaemon ; 
 
 - public StressSettings ( SettingsCommand command , SettingsRate rate , SettingsPopulation generate , SettingsInsert insert , SettingsColumn columns , SettingsErrors errors , SettingsLog log , SettingsMode mode , SettingsNode node , SettingsSchema schema , SettingsTransport transport , SettingsPort port , String sendToDaemon ) 
 + public StressSettings ( SettingsCommand command , SettingsRate rate , SettingsPopulation generate , SettingsInsert insert , SettingsColumn columns , SettingsSamples samples , SettingsErrors errors , SettingsLog log , SettingsMode mode , SettingsNode node , SettingsSchema schema , SettingsTransport transport , SettingsPort port , String sendToDaemon ) 
 { 
 this . command = command ; 
 this . rate = rate ; 
 this . insert = insert ; 
 this . generate = generate ; 
 this . columns = columns ; 
 + this . samples = samples ; 
 this . errors = errors ; 
 this . log = log ; 
 this . mode = mode ; 
 @ @ - 232 , 6 + 234 , 7 @ @ public class StressSettings implements Serializable 
 SettingsPopulation generate = SettingsPopulation . get ( clArgs , command ) ; 
 SettingsInsert insert = SettingsInsert . get ( clArgs ) ; 
 SettingsColumn columns = SettingsColumn . get ( clArgs ) ; 
 + SettingsSamples samples = SettingsSamples . get ( clArgs ) ; 
 SettingsErrors errors = SettingsErrors . get ( clArgs ) ; 
 SettingsLog log = SettingsLog . get ( clArgs ) ; 
 SettingsMode mode = SettingsMode . get ( clArgs ) ; 
 @ @ - 254 , 7 + 257 , 7 @ @ public class StressSettings implements Serializable 
 } 
 System . exit ( 1 ) ; 
 } 
 - return new StressSettings ( command , rate , generate , insert , columns , errors , log , mode , node , schema , transport , port , sendToDaemon ) ; 
 + return new StressSettings ( command , rate , generate , insert , columns , samples , errors , log , mode , node , schema , transport , port , sendToDaemon ) ; 
 } 
 
 private static Map < String , String [ ] > parseMap ( String [ ] args ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / SampleOfLongs . java b / tools / stress / src / org / apache / cassandra / stress / util / SampleOfLongs . java 
 index 8be9f81 . . ed54ee0 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / util / SampleOfLongs . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / util / SampleOfLongs . java 
 @ @ - 51 , 61 + 51 , 44 @ @ public final class SampleOfLongs 
 
 static SampleOfLongs merge ( Random rnd , List < SampleOfLongs > merge , int maxSamples ) 
 { 
 - int maxLength = 0 ; 
 + / / grab the lowest probability of selection , and normalise all samples to that 
 double targetp = 1 ; 
 for ( SampleOfLongs sampleOfLongs : merge ) 
 - { 
 - maxLength + = sampleOfLongs . sample . length ; 
 targetp = Math . min ( targetp , sampleOfLongs . p ) ; 
 + 
 + / / calculate how many samples we should encounter 
 + int maxLength = 0 ; 
 + for ( SampleOfLongs sampleOfLongs : merge ) 
 + maxLength + = sampleOfLongs . sample . length * ( targetp / sampleOfLongs . p ) ; 
 + 
 + if ( maxLength > maxSamples ) 
 + { 
 + targetp * = maxSamples / ( double ) maxLength ; 
 + maxLength = maxSamples ; 
 } 
 + 
 long [ ] sample = new long [ maxLength ] ; 
 int count = 0 ; 
 - for ( SampleOfLongs latencies : merge ) 
 + out : for ( SampleOfLongs latencies : merge ) 
 { 
 long [ ] in = latencies . sample ; 
 double p = targetp / latencies . p ; 
 for ( int i = 0 ; i < in . length ; i + + ) 
 + { 
 if ( rnd . nextDouble ( ) < p ) 
 + { 
 sample [ count + + ] = in [ i ] ; 
 + if ( count = = maxLength ) 
 + break out ; 
 + } 
 + } 
 } 
 - if ( count > maxSamples ) 
 - { 
 - targetp = subsample ( rnd , maxSamples , sample , count , targetp ) ; 
 - count = maxSamples ; 
 - } 
 - sample = Arrays . copyOf ( sample , count ) ; 
 + if ( count ! = maxLength ) 
 + sample = Arrays . copyOf ( sample , count ) ; 
 Arrays . sort ( sample ) ; 
 return new SampleOfLongs ( sample , targetp ) ; 
 } 
 
 - public SampleOfLongs subsample ( Random rnd , int maxSamples ) 
 - { 
 - if ( maxSamples > sample . length ) 
 - return this ; 
 - 
 - long [ ] sample = this . sample . clone ( ) ; 
 - double p = subsample ( rnd , maxSamples , sample , sample . length , this . p ) ; 
 - sample = Arrays . copyOf ( sample , maxSamples ) ; 
 - return new SampleOfLongs ( sample , p ) ; 
 - } 
 - 
 - private static double subsample ( Random rnd , int maxSamples , long [ ] sample , int count , double p ) 
 - { 
 - / / want exactly maxSamples , so select random indexes up to maxSamples 
 - for ( int i = 0 ; i < maxSamples ; i + + ) 
 - { 
 - int take = i + rnd . nextInt ( count - i ) ; 
 - long tmp = sample [ i ] ; 
 - sample [ i ] = sample [ take ] ; 
 - sample [ take ] = tmp ; 
 - } 
 - 
 - / / calculate new p ; have selected with probability maxSamples / count 
 - / / so multiply p by this probability 
 - p * = maxSamples / ( double ) sample . length ; 
 - return p ; 
 - } 
 - 
 public double medianLatency ( ) 
 { 
 if ( sample . length = = 0 ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / Timer . java b / tools / stress / src / org / apache / cassandra / stress / util / Timer . java 
 index 4e2b0a3 . . 7449a00 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / util / Timer . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / util / Timer . java 
 @ @ - 25 , 21 + 25 , 18 @ @ import java . util . Arrays ; 
 import java . util . List ; 
 import java . util . Random ; 
 import java . util . concurrent . CountDownLatch ; 
 + import java . util . concurrent . ThreadLocalRandom ; 
 
 / / a timer - this timer must be used by a single thread , and co - ordinates with other timers by 
 public final class Timer 
 { 
 - 
 - private static final int SAMPLE _ SIZE _ SHIFT = 14 ; 
 - private static final int SAMPLE _ SIZE _ MASK = ( 1 < < SAMPLE _ SIZE _ SHIFT ) - 1 ; 
 - 
 - private final Random rnd = new Random ( ) ; 
 + private ThreadLocalRandom rnd ; 
 
 / / in progress snap start 
 private long sampleStartNanos ; 
 
 / / each entry is present with probability 1 / p ( opCount ) or 1 / ( p ( opCount ) - 1 ) 
 - private final long [ ] sample = new long [ 1 < < SAMPLE _ SIZE _ SHIFT ] ; 
 + private final long [ ] sample ; 
 private int opCount ; 
 
 / / aggregate info 
 @ @ - 56 , 14 + 53 , 25 @ @ public final class Timer 
 volatile TimingInterval report ; 
 private volatile TimingInterval finalReport ; 
 
 + public Timer ( int sampleCount ) 
 + { 
 + int powerOf2 = 32 - Integer . numberOfLeadingZeros ( sampleCount - 1 ) ; 
 + this . sample = new long [ 1 < < powerOf2 ] ; 
 + } 
 + 
 + public void init ( ) 
 + { 
 + rnd = ThreadLocalRandom . current ( ) ; 
 + } 
 + 
 public void start ( ) { 
 / / decide if we ' re logging this event 
 sampleStartNanos = System . nanoTime ( ) ; 
 } 
 
 - private static int p ( int index ) 
 + private int p ( int index ) 
 { 
 - return 1 + ( index > > > SAMPLE _ SIZE _ SHIFT ) ; 
 + return 1 + ( index / sample . length ) ; 
 } 
 
 public boolean running ( ) 
 @ @ - 90 , 9 + 98 , 9 @ @ public final class Timer 
 upToDateAsOf = now ; 
 } 
 
 - private static int index ( int count ) 
 + private int index ( int count ) 
 { 
 - return count & SAMPLE _ SIZE _ MASK ; 
 + return count & ( sample . length - 1 ) ; 
 } 
 
 private TimingInterval buildReport ( ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / Timing . java b / tools / stress / src / org / apache / cassandra / stress / util / Timing . java 
 index 9eadf42 . . f48ce35 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / util / Timing . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / util / Timing . java 
 @ @ - 40 , 9 + 40 , 16 @ @ public class Timing 
 
 private final CopyOnWriteArrayList < Timer > timers = new CopyOnWriteArrayList < > ( ) ; 
 private volatile TimingInterval history ; 
 - private final Random rnd = new Random ( ) ; 
 + private final int historySampleCount ; 
 + private final int reportSampleCount ; 
 private boolean done ; 
 
 + public Timing ( int historySampleCount , int reportSampleCount ) 
 + { 
 + this . historySampleCount = historySampleCount ; 
 + this . reportSampleCount = reportSampleCount ; 
 + } 
 + 
 / / TIMING 
 
 public static class TimingResult < E > 
 @ @ - 56 , 7 + 63 , 7 @ @ public class Timing 
 } 
 } 
 
 - private < E > TimingResult < E > snap ( Random rnd , Callable < E > call ) throws InterruptedException 
 + public < E > TimingResult < E > snap ( Callable < E > call ) throws InterruptedException 
 { 
 final Timer [ ] timers = this . timers . toArray ( new Timer [ 0 ] ) ; 
 final CountDownLatch ready = new CountDownLatch ( timers . length ) ; 
 @ @ - 92 , 13 + 99 , 15 @ @ public class Timing 
 } 
 
 this . done = done ; 
 - return new TimingResult < > ( extra , TimingInterval . merge ( rnd , intervals , Integer . MAX _ VALUE , history . endNanos ( ) ) ) ; 
 + TimingResult < E > result = new TimingResult < > ( extra , TimingInterval . merge ( intervals , reportSampleCount , history . endNanos ( ) ) ) ; 
 + history = TimingInterval . merge ( Arrays . asList ( result . timing , history ) , historySampleCount , history . startNanos ( ) ) ; 
 + return result ; 
 } 
 
 / / build a new timer and add it to the set of running timers 
 - public Timer newTimer ( ) 
 + public Timer newTimer ( int sampleCount ) 
 { 
 - final Timer timer = new Timer ( ) ; 
 + final Timer timer = new Timer ( sampleCount ) ; 
 timers . add ( timer ) ; 
 return timer ; 
 } 
 @ @ - 113 , 13 + 122 , 6 @ @ public class Timing 
 return done ; 
 } 
 
 - public < E > TimingResult < E > snap ( Callable < E > call ) throws InterruptedException 
 - { 
 - final TimingResult < E > result = snap ( rnd , call ) ; 
 - history = TimingInterval . merge ( rnd , Arrays . asList ( result . timing , history ) , 200000 , history . startNanos ( ) ) ; 
 - return result ; 
 - } 
 - 
 public TimingInterval getHistory ( ) 
 { 
 return history ; 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / TimingInterval . java b / tools / stress / src / org / apache / cassandra / stress / util / TimingInterval . java 
 index 50ab608 . . 11d313f 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / util / TimingInterval . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / util / TimingInterval . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . List ; 
 import java . util . Random ; 
 + import java . util . concurrent . ThreadLocalRandom ; 
 
 / / represents measurements taken over an interval of time 
 / / used for both single timer results and merged timer results 
 @ @ - 68 , 8 + 69 , 9 @ @ public final class TimingInterval 
 } 
 
 / / merge multiple timer intervals together 
 - static TimingInterval merge ( Random rnd , List < TimingInterval > intervals , int maxSamples , long start ) 
 + static TimingInterval merge ( List < TimingInterval > intervals , int maxSamples , long start ) 
 { 
 + ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; 
 long operationCount = 0 , partitionCount = 0 , rowCount = 0 ; 
 long maxLatency = 0 , totalLatency = 0 ; 
 List < SampleOfLongs > latencies = new ArrayList < > ( ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
