BLEU SCORE: 0.05522397783539471

TEST MSG: Don ' t do anticompaction after subrange repair
GENERATED MSG: Wait for all repair sessions to finish

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 489a76d . . f5d3416 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 4 <nl> + * Don ' t do anticompaction after subrange repair ( CASSANDRA - 10422 ) <nl> * Fix SimpleDateType type compatibility ( CASSANDRA - 10027 ) <nl> * ( Hadoop ) fix splits calculation ( CASSANDRA - 10640 ) <nl> * ( Hadoop ) ensure that Cluster instances are always closed ( CASSANDRA - 10058 ) <nl> diff - - git a / src / java / org / apache / cassandra / repair / messages / RepairOption . java b / src / java / org / apache / cassandra / repair / messages / RepairOption . java <nl> index 1780b6b . . d50a2ed 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / messages / RepairOption . java <nl> + + + b / src / java / org / apache / cassandra / repair / messages / RepairOption . java <nl> @ @ - 145 , 8 + 145 , 9 @ @ public class RepairOption <nl> if ( rangesStr ! = null ) <nl> { <nl> if ( incremental ) <nl> - throw new IllegalArgumentException ( " Incremental repair can ' t be requested with subrange repair " + <nl> - " because each subrange repair would generate an anti - compacted table " ) ; <nl> + logger . warn ( " Incremental repair can ' t be requested with subrange repair " + <nl> + " because each subrange repair would generate an anti - compacted table . " + <nl> + " The repair will occur but without anti - compaction . " ) ; <nl> StringTokenizer tokenizer = new StringTokenizer ( rangesStr , " , " ) ; <nl> while ( tokenizer . hasMoreTokens ( ) ) <nl> { <nl> @ @ - 161 , 7 + 162 , 7 @ @ public class RepairOption <nl> } <nl> } <nl> <nl> - RepairOption option = new RepairOption ( parallelism , primaryRange , incremental , trace , jobThreads , ranges ) ; <nl> + RepairOption option = new RepairOption ( parallelism , primaryRange , incremental , trace , jobThreads , ranges , ! ranges . isEmpty ( ) ) ; <nl> <nl> / / data centers <nl> String dataCentersStr = options . get ( DATACENTERS _ KEY ) ; <nl> @ @ - 220 , 13 + 221 , 14 @ @ public class RepairOption <nl> private final boolean incremental ; <nl> private final boolean trace ; <nl> private final int jobThreads ; <nl> + private final boolean isSubrangeRepair ; <nl> <nl> private final Collection < String > columnFamilies = new HashSet < > ( ) ; <nl> private final Collection < String > dataCenters = new HashSet < > ( ) ; <nl> private final Collection < String > hosts = new HashSet < > ( ) ; <nl> private final Collection < Range < Token > > ranges = new HashSet < > ( ) ; <nl> <nl> - public RepairOption ( RepairParallelism parallelism , boolean primaryRange , boolean incremental , boolean trace , int jobThreads , Collection < Range < Token > > ranges ) <nl> + public RepairOption ( RepairParallelism parallelism , boolean primaryRange , boolean incremental , boolean trace , int jobThreads , Collection < Range < Token > > ranges , boolean isSubrangeRepair ) <nl> { <nl> if ( FBUtilities . isWindows ( ) & & <nl> ( DatabaseDescriptor . getDiskAccessMode ( ) ! = Config . DiskAccessMode . standard | | DatabaseDescriptor . getIndexAccessMode ( ) ! = Config . DiskAccessMode . standard ) & & <nl> @ @ - 243 , 6 + 245 , 7 @ @ public class RepairOption <nl> this . trace = trace ; <nl> this . jobThreads = jobThreads ; <nl> this . ranges . addAll ( ranges ) ; <nl> + this . isSubrangeRepair = isSubrangeRepair ; <nl> } <nl> <nl> public RepairParallelism getParallelism ( ) <nl> @ @ - 292 , 8 + 295 , 14 @ @ public class RepairOption <nl> <nl> public boolean isGlobal ( ) <nl> { <nl> - return dataCenters . isEmpty ( ) & & hosts . isEmpty ( ) ; <nl> + return dataCenters . isEmpty ( ) & & hosts . isEmpty ( ) & & ! isSubrangeRepair ( ) ; <nl> } <nl> + <nl> + public boolean isSubrangeRepair ( ) <nl> + { <nl> + return isSubrangeRepair ; <nl> + } <nl> + <nl> @ Override <nl> public String toString ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> index a6389ea . . 0cb4252 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> @ @ - 353 , 6 + 353 , 8 @ @ public class ActiveRepairService <nl> { <nl> assert parentRepairSession ! = null ; <nl> ParentRepairSession prs = getParentRepairSession ( parentRepairSession ) ; <nl> + / / A repair will be marked as not global if it is a subrange repair to avoid many small anti - compactions <nl> + / / in addition to other scenarios such as repairs not involving all DCs or hosts <nl> if ( ! prs . isGlobal ) <nl> { <nl> logger . info ( " Not a global repair , will not do anticompaction " ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index b5ce38b . . 80672dd 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 2882 , 7 + 2882 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> parallelism = RepairParallelism . PARALLEL ; <nl> } <nl> <nl> - RepairOption options = new RepairOption ( parallelism , primaryRange , ! fullRepair , false , 1 , Collections . < Range < Token > > emptyList ( ) ) ; <nl> + RepairOption options = new RepairOption ( parallelism , primaryRange , ! fullRepair , false , 1 , Collections . < Range < Token > > emptyList ( ) , false ) ; <nl> if ( dataCenters ! = null ) <nl> { <nl> options . getDataCenters ( ) . addAll ( dataCenters ) ; <nl> @ @ - 2966 , 11 + 2966 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> <nl> if ( ! fullRepair ) <nl> - throw new IllegalArgumentException ( " Incremental repair can ' t be requested with subrange repair " + <nl> - " because each subrange repair would generate an anti - compacted table " ) ; <nl> + logger . warn ( " Incremental repair can ' t be requested with subrange repair " + <nl> + " because each subrange repair would generate an anti - compacted table . " + <nl> + " The repair will occur but without anti - compaction . " ) ; <nl> Collection < Range < Token > > repairingRange = createRepairRangeFrom ( beginToken , endToken ) ; <nl> <nl> - RepairOption options = new RepairOption ( parallelism , false , ! fullRepair , false , 1 , repairingRange ) ; <nl> + RepairOption options = new RepairOption ( parallelism , false , ! fullRepair , false , 1 , repairingRange , true ) ; <nl> options . getDataCenters ( ) . addAll ( dataCenters ) ; <nl> if ( hosts ! = null ) <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java b / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java <nl> index 3257a10 . . cc6f46a 100644 <nl> - - - a / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java <nl> + + + b / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java <nl> @ @ - 96 , 10 + 96 , 14 @ @ public class RepairOptionTest <nl> assertEquals ( expectedHosts , option . getHosts ( ) ) ; <nl> } <nl> <nl> - @ Test ( expected = IllegalArgumentException . class ) <nl> - public void testIncrementalRepairWithSubrangesThrows ( ) throws Exception <nl> + @ Test <nl> + public void testIncrementalRepairWithSubrangesIsNotGlobal ( ) throws Exception <nl> { <nl> - RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " " ) , <nl> + RepairOption ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " 42 : 42 " ) , <nl> Murmur3Partitioner . instance ) ; <nl> + assertFalse ( ro . isGlobal ( ) ) ; <nl> + ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " " ) , <nl> + Murmur3Partitioner . instance ) ; <nl> + assertTrue ( ro . isGlobal ( ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 489a76d . . f5d3416 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 4 
 + * Don ' t do anticompaction after subrange repair ( CASSANDRA - 10422 ) 
 * Fix SimpleDateType type compatibility ( CASSANDRA - 10027 ) 
 * ( Hadoop ) fix splits calculation ( CASSANDRA - 10640 ) 
 * ( Hadoop ) ensure that Cluster instances are always closed ( CASSANDRA - 10058 ) 
 diff - - git a / src / java / org / apache / cassandra / repair / messages / RepairOption . java b / src / java / org / apache / cassandra / repair / messages / RepairOption . java 
 index 1780b6b . . d50a2ed 100644 
 - - - a / src / java / org / apache / cassandra / repair / messages / RepairOption . java 
 + + + b / src / java / org / apache / cassandra / repair / messages / RepairOption . java 
 @ @ - 145 , 8 + 145 , 9 @ @ public class RepairOption 
 if ( rangesStr ! = null ) 
 { 
 if ( incremental ) 
 - throw new IllegalArgumentException ( " Incremental repair can ' t be requested with subrange repair " + 
 - " because each subrange repair would generate an anti - compacted table " ) ; 
 + logger . warn ( " Incremental repair can ' t be requested with subrange repair " + 
 + " because each subrange repair would generate an anti - compacted table . " + 
 + " The repair will occur but without anti - compaction . " ) ; 
 StringTokenizer tokenizer = new StringTokenizer ( rangesStr , " , " ) ; 
 while ( tokenizer . hasMoreTokens ( ) ) 
 { 
 @ @ - 161 , 7 + 162 , 7 @ @ public class RepairOption 
 } 
 } 
 
 - RepairOption option = new RepairOption ( parallelism , primaryRange , incremental , trace , jobThreads , ranges ) ; 
 + RepairOption option = new RepairOption ( parallelism , primaryRange , incremental , trace , jobThreads , ranges , ! ranges . isEmpty ( ) ) ; 
 
 / / data centers 
 String dataCentersStr = options . get ( DATACENTERS _ KEY ) ; 
 @ @ - 220 , 13 + 221 , 14 @ @ public class RepairOption 
 private final boolean incremental ; 
 private final boolean trace ; 
 private final int jobThreads ; 
 + private final boolean isSubrangeRepair ; 
 
 private final Collection < String > columnFamilies = new HashSet < > ( ) ; 
 private final Collection < String > dataCenters = new HashSet < > ( ) ; 
 private final Collection < String > hosts = new HashSet < > ( ) ; 
 private final Collection < Range < Token > > ranges = new HashSet < > ( ) ; 
 
 - public RepairOption ( RepairParallelism parallelism , boolean primaryRange , boolean incremental , boolean trace , int jobThreads , Collection < Range < Token > > ranges ) 
 + public RepairOption ( RepairParallelism parallelism , boolean primaryRange , boolean incremental , boolean trace , int jobThreads , Collection < Range < Token > > ranges , boolean isSubrangeRepair ) 
 { 
 if ( FBUtilities . isWindows ( ) & & 
 ( DatabaseDescriptor . getDiskAccessMode ( ) ! = Config . DiskAccessMode . standard | | DatabaseDescriptor . getIndexAccessMode ( ) ! = Config . DiskAccessMode . standard ) & & 
 @ @ - 243 , 6 + 245 , 7 @ @ public class RepairOption 
 this . trace = trace ; 
 this . jobThreads = jobThreads ; 
 this . ranges . addAll ( ranges ) ; 
 + this . isSubrangeRepair = isSubrangeRepair ; 
 } 
 
 public RepairParallelism getParallelism ( ) 
 @ @ - 292 , 8 + 295 , 14 @ @ public class RepairOption 
 
 public boolean isGlobal ( ) 
 { 
 - return dataCenters . isEmpty ( ) & & hosts . isEmpty ( ) ; 
 + return dataCenters . isEmpty ( ) & & hosts . isEmpty ( ) & & ! isSubrangeRepair ( ) ; 
 } 
 + 
 + public boolean isSubrangeRepair ( ) 
 + { 
 + return isSubrangeRepair ; 
 + } 
 + 
 @ Override 
 public String toString ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 index a6389ea . . 0cb4252 100644 
 - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 @ @ - 353 , 6 + 353 , 8 @ @ public class ActiveRepairService 
 { 
 assert parentRepairSession ! = null ; 
 ParentRepairSession prs = getParentRepairSession ( parentRepairSession ) ; 
 + / / A repair will be marked as not global if it is a subrange repair to avoid many small anti - compactions 
 + / / in addition to other scenarios such as repairs not involving all DCs or hosts 
 if ( ! prs . isGlobal ) 
 { 
 logger . info ( " Not a global repair , will not do anticompaction " ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index b5ce38b . . 80672dd 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 2882 , 7 + 2882 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 parallelism = RepairParallelism . PARALLEL ; 
 } 
 
 - RepairOption options = new RepairOption ( parallelism , primaryRange , ! fullRepair , false , 1 , Collections . < Range < Token > > emptyList ( ) ) ; 
 + RepairOption options = new RepairOption ( parallelism , primaryRange , ! fullRepair , false , 1 , Collections . < Range < Token > > emptyList ( ) , false ) ; 
 if ( dataCenters ! = null ) 
 { 
 options . getDataCenters ( ) . addAll ( dataCenters ) ; 
 @ @ - 2966 , 11 + 2966 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 
 if ( ! fullRepair ) 
 - throw new IllegalArgumentException ( " Incremental repair can ' t be requested with subrange repair " + 
 - " because each subrange repair would generate an anti - compacted table " ) ; 
 + logger . warn ( " Incremental repair can ' t be requested with subrange repair " + 
 + " because each subrange repair would generate an anti - compacted table . " + 
 + " The repair will occur but without anti - compaction . " ) ; 
 Collection < Range < Token > > repairingRange = createRepairRangeFrom ( beginToken , endToken ) ; 
 
 - RepairOption options = new RepairOption ( parallelism , false , ! fullRepair , false , 1 , repairingRange ) ; 
 + RepairOption options = new RepairOption ( parallelism , false , ! fullRepair , false , 1 , repairingRange , true ) ; 
 options . getDataCenters ( ) . addAll ( dataCenters ) ; 
 if ( hosts ! = null ) 
 { 
 diff - - git a / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java b / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java 
 index 3257a10 . . cc6f46a 100644 
 - - - a / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java 
 + + + b / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java 
 @ @ - 96 , 10 + 96 , 14 @ @ public class RepairOptionTest 
 assertEquals ( expectedHosts , option . getHosts ( ) ) ; 
 } 
 
 - @ Test ( expected = IllegalArgumentException . class ) 
 - public void testIncrementalRepairWithSubrangesThrows ( ) throws Exception 
 + @ Test 
 + public void testIncrementalRepairWithSubrangesIsNotGlobal ( ) throws Exception 
 { 
 - RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " " ) , 
 + RepairOption ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " 42 : 42 " ) , 
 Murmur3Partitioner . instance ) ; 
 + assertFalse ( ro . isGlobal ( ) ) ; 
 + ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " " ) , 
 + Murmur3Partitioner . instance ) ; 
 + assertTrue ( ro . isGlobal ( ) ) ; 
 } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
