BLEU SCORE: 0.027611988917697356

TEST MSG: Fix handling of enable / disable autocompaction .
GENERATED MSG: acquire references on overlapped sstables

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c4bb21c . . 4ef77ed 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 9 <nl> + * Fix handling of enable / disable autocompaction ( CASSANDRA - 9899 ) <nl> * Commit log segment recycling is disabled by default ( CASSANDRA - 9896 ) <nl> * Add consistency level to tracing ouput ( CASSANDRA - 9827 ) <nl> * Fix MarshalException when upgrading superColumn family ( CASSANDRA - 9582 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> index 9eac2d0 . . 73cda77 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> @ @ - 60 , 7 + 60 , 7 @ @ public abstract class AbstractCompactionStrategy <nl> protected static final String UNCHECKED _ TOMBSTONE _ COMPACTION _ OPTION = " unchecked _ tombstone _ compaction " ; <nl> protected static final String COMPACTION _ ENABLED = " enabled " ; <nl> <nl> - public final Map < String , String > options ; <nl> + protected Map < String , String > options ; <nl> <nl> protected final ColumnFamilyStore cfs ; <nl> protected float tombstoneThreshold ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> index 15287bd . . dec0cef 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> @ @ - 57 , 9 + 57 , 6 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> @ Override <nl> public synchronized AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) <nl> { <nl> - if ( ! isEnabled ( ) ) <nl> - return null ; <nl> - <nl> while ( true ) <nl> { <nl> List < SSTableReader > latestBucket = getNextBackgroundSSTables ( gcBefore ) ; <nl> @ @ - 79 , 7 + 76 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> * / <nl> private List < SSTableReader > getNextBackgroundSSTables ( final int gcBefore ) <nl> { <nl> - if ( ! isEnabled ( ) | | cfs . getSSTables ( ) . isEmpty ( ) ) <nl> + if ( cfs . getSSTables ( ) . isEmpty ( ) ) <nl> return Collections . emptyList ( ) ; <nl> <nl> Set < SSTableReader > uncompacting = Sets . intersection ( sstables , cfs . getUncompactingSSTables ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> index f9e5d16 . . 8afe6b6 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> @ @ - 87 , 8 + 87 , 6 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy <nl> * / <nl> public synchronized AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) <nl> { <nl> - if ( ! isEnabled ( ) ) <nl> - return null ; <nl> Collection < AbstractCompactionTask > tasks = getMaximalTask ( gcBefore ) ; <nl> if ( tasks = = null | | tasks . size ( ) = = 0 ) <nl> return null ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> index 93484e8 . . 1f4acdb 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> @ @ - 75 , 9 + 75 , 6 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> <nl> private List < SSTableReader > getNextBackgroundSSTables ( final int gcBefore ) <nl> { <nl> - if ( ! isEnabled ( ) ) <nl> - return Collections . emptyList ( ) ; <nl> - <nl> / / make local copies so they can ' t be changed out from under us mid - method <nl> int minThreshold = cfs . getMinimumCompactionThreshold ( ) ; <nl> int maxThreshold = cfs . getMaximumCompactionThreshold ( ) ; <nl> @ @ - 177 , 9 + 174 , 6 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> <nl> public synchronized AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) <nl> { <nl> - if ( ! isEnabled ( ) ) <nl> - return null ; <nl> - <nl> while ( true ) <nl> { <nl> List < SSTableReader > hottestBucket = getNextBackgroundSSTables ( gcBefore ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / WrappingCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / WrappingCompactionStrategy . java <nl> index 2f8bd7c . . e01b4c6 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / WrappingCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / WrappingCompactionStrategy . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import java . util . List ; <nl> import java . util . Set ; <nl> import java . util . concurrent . Callable ; <nl> <nl> + import com . google . common . collect . ImmutableMap ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 150 , 18 + 151 , 23 @ @ public final class WrappingCompactionStrategy extends AbstractCompactionStrategy <nl> & & repaired . options . equals ( metadata . compactionStrategyOptions ) <nl> & & unrepaired . options . equals ( metadata . compactionStrategyOptions ) ) <nl> return ; <nl> - <nl> reloadCompactionStrategy ( metadata ) ; <nl> } <nl> <nl> public synchronized void reloadCompactionStrategy ( CFMetaData metadata ) <nl> { <nl> + boolean disabledWithJMX = ! isEnabled ( ) & & shouldBeEnabled ( ) ; <nl> if ( repaired ! = null ) <nl> repaired . shutdown ( ) ; <nl> if ( unrepaired ! = null ) <nl> unrepaired . shutdown ( ) ; <nl> repaired = metadata . createCompactionStrategyInstance ( cfs ) ; <nl> unrepaired = metadata . createCompactionStrategyInstance ( cfs ) ; <nl> + options = ImmutableMap . copyOf ( metadata . compactionStrategyOptions ) ; <nl> + if ( disabledWithJMX | | ! shouldBeEnabled ( ) ) <nl> + disable ( ) ; <nl> + else <nl> + enable ( ) ; <nl> startup ( ) ; <nl> } <nl> <nl> @ @ - 344 , 6 + 350 , 28 @ @ public final class WrappingCompactionStrategy extends AbstractCompactionStrategy <nl> } <nl> <nl> @ Override <nl> + public void enable ( ) <nl> + { <nl> + if ( repaired ! = null ) <nl> + repaired . enable ( ) ; <nl> + if ( unrepaired ! = null ) <nl> + unrepaired . enable ( ) ; <nl> + / / enable this last to make sure the strategies are ready to get calls . <nl> + super . enable ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void disable ( ) <nl> + { <nl> + / / disable this first avoid asking disabled strategies for compaction tasks <nl> + super . disable ( ) ; <nl> + if ( repaired ! = null ) <nl> + repaired . disable ( ) ; <nl> + if ( unrepaired ! = null ) <nl> + unrepaired . disable ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> public synchronized ScannerList getScanners ( Collection < SSTableReader > sstables , Range < Token > range ) <nl> { <nl> List < SSTableReader > repairedSSTables = new ArrayList < > ( ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3b80885 . . f6769fe 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 1 . 2 - rc1 <nl> + * Fix rare race condition in getExpireTimeForEndpoint ( CASSANDRA - 4402 ) <nl> * acquire references to overlapping sstables during compaction so bloom filter <nl> doesn ' t get free ' d prematurely ( CASSANDRA - 4934 ) <nl> * Don ' t share slice query filter in CQL3 SelectStatement ( CASSANDRA - 4928 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java <nl> index 85611de . . 18b7e4b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Table . java <nl> + + + b / src / java / org / apache / cassandra / db / Table . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ import java . io . IOException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> import java . util . concurrent . ConcurrentHashMap ; <nl> + import java . util . concurrent . ConcurrentMap ; <nl> import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . Future ; <nl> import java . util . concurrent . locks . ReentrantReadWriteLock ; <nl> @ @ - 71 , 7 + 72 , 7 @ @ public class Table <nl> / * Table name . * / <nl> public final String name ; <nl> / * ColumnFamilyStore per column family * / <nl> - private final Map < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < UUID , ColumnFamilyStore > ( ) ; <nl> + private final ConcurrentMap < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < UUID , ColumnFamilyStore > ( ) ; <nl> private final Object [ ] indexLocks ; <nl> private volatile AbstractReplicationStrategy replicationStrategy ; <nl> <nl> @ @ - 319 , 19 + 320 , 25 @ @ public class Table <nl> * / <nl> public void initCf ( UUID cfId , String cfName , boolean loadSSTables ) <nl> { <nl> - if ( columnFamilyStores . containsKey ( cfId ) ) <nl> - { <nl> - / / this is the case when you reset local schema <nl> - / / just reload metadata <nl> - ColumnFamilyStore cfs = columnFamilyStores . get ( cfId ) ; <nl> - assert cfs . getColumnFamilyName ( ) . equals ( cfName ) ; <nl> + ColumnFamilyStore cfs = columnFamilyStores . get ( cfId ) ; <nl> <nl> - cfs . metadata . reload ( ) ; <nl> - cfs . reload ( ) ; <nl> + if ( cfs = = null ) <nl> + { <nl> + / / CFS being created for the first time , either on server startup or new CF being added . <nl> + / / We don ' t worry about races here ; startup is safe , and adding multiple idential CFs <nl> + / / simultaneously is a " don ' t do that " scenario . <nl> + ColumnFamilyStore oldCfs = columnFamilyStores . putIfAbsent ( cfId , ColumnFamilyStore . createColumnFamilyStore ( this , cfName , loadSSTables ) ) ; <nl> + / / CFS mbean instantiation will error out before we hit this , but in case that changes . . . <nl> + if ( oldCfs ! = null ) <nl> + throw new IllegalStateException ( " added multiple mappings for cf id " + cfId ) ; <nl> } <nl> else <nl> { <nl> - columnFamilyStores . put ( cfId , ColumnFamilyStore . createColumnFamilyStore ( this , cfName , loadSSTables ) ) ; <nl> + / / re - initializing an existing CF . This will happen if you cleared the schema <nl> + / / on this node and it ' s getting repopulated from the rest of the cluster . <nl> + assert cfs . getColumnFamilyName ( ) . equals ( cfName ) ; <nl> + cfs . metadata . reload ( ) ; <nl> + cfs . reload ( ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index e49a6b3 . . 5880210 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import java . util . concurrent . * ; <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 90 , 7 + 91 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> private final Set < InetAddress > seeds = new ConcurrentSkipListSet < InetAddress > ( inetcomparator ) ; <nl> <nl> / * map where key is the endpoint and value is the state associated with the endpoint * / <nl> - final Map < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; <nl> + final ConcurrentMap < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; <nl> <nl> / * map where key is endpoint and value is timestamp when this endpoint was removed from <nl> * gossip . We will ignore any gossip regarding these endpoints for QUARANTINE _ DELAY time <nl> @ @ - 601 , 12 + 602 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> protected long getExpireTimeForEndpoint ( InetAddress endpoint ) <nl> { <nl> / * default expireTime is aVeryLongTime * / <nl> - long expireTime = computeExpireTime ( ) ; <nl> - if ( expireTimeEndpointMap . containsKey ( endpoint ) ) <nl> - { <nl> - expireTime = expireTimeEndpointMap . get ( endpoint ) ; <nl> - } <nl> - return expireTime ; <nl> + Long storedTime = expireTimeEndpointMap . get ( endpoint ) ; <nl> + return storedTime = = null ? computeExpireTime ( ) : storedTime ; <nl> } <nl> <nl> public EndpointState getEndpointStateForEndpoint ( InetAddress ep ) <nl> @ @ - 1031 , 17 + 1028 , 13 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> TimeUnit . MILLISECONDS ) ; <nl> } <nl> <nl> - / / initialize local HB state if needed . <nl> + / / initialize local HB state if needed , i . e . , if gossiper has never been started before . <nl> public void maybeInitializeLocalState ( int generationNbr ) <nl> { <nl> - EndpointState localState = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> - if ( localState = = null ) <nl> - { <nl> - HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; <nl> - localState = new EndpointState ( hbState ) ; <nl> - localState . markAlive ( ) ; <nl> - endpointStateMap . put ( FBUtilities . getBroadcastAddress ( ) , localState ) ; <nl> - } <nl> + HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; <nl> + EndpointState localState = new EndpointState ( hbState ) ; <nl> + localState . markAlive ( ) ; <nl> + endpointStateMap . putIfAbsent ( FBUtilities . getBroadcastAddress ( ) , localState ) ; <nl> } <nl> <nl> <nl> @ @ - 1093 , 27 + 1086 , 20 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> return ( scheduledGossipTask ! = null ) & & ( ! scheduledGossipTask . isCancelled ( ) ) ; <nl> } <nl> <nl> - / * * <nl> - * This should * only * be used for testing purposes . <nl> - * / <nl> - public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) { <nl> - / * initialize the heartbeat state for this localEndpoint * / <nl> - EndpointState localState = endpointStateMap . get ( addr ) ; <nl> - if ( localState = = null ) <nl> - { <nl> - HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; <nl> - localState = new EndpointState ( hbState ) ; <nl> - localState . markAlive ( ) ; <nl> - endpointStateMap . put ( addr , localState ) ; <nl> - } <nl> + @ VisibleForTesting <nl> + public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) <nl> + { <nl> + HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; <nl> + EndpointState localState = new EndpointState ( hbState ) ; <nl> + localState . markAlive ( ) ; <nl> + endpointStateMap . putIfAbsent ( addr , localState ) ; <nl> + <nl> / / always add the version state <nl> localState . addApplicationState ( ApplicationState . NET _ VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; <nl> localState . addApplicationState ( ApplicationState . HOST _ ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; <nl> } <nl> <nl> - / * * <nl> - * This should * only * be used for testing purposes <nl> - * / <nl> + @ VisibleForTesting <nl> public void injectApplicationState ( InetAddress endpoint , ApplicationState state , VersionedValue value ) <nl> { <nl> EndpointState localState = endpointStateMap . get ( endpoint ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c4bb21c . . 4ef77ed 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 9 
 + * Fix handling of enable / disable autocompaction ( CASSANDRA - 9899 ) 
 * Commit log segment recycling is disabled by default ( CASSANDRA - 9896 ) 
 * Add consistency level to tracing ouput ( CASSANDRA - 9827 ) 
 * Fix MarshalException when upgrading superColumn family ( CASSANDRA - 9582 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 index 9eac2d0 . . 73cda77 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 @ @ - 60 , 7 + 60 , 7 @ @ public abstract class AbstractCompactionStrategy 
 protected static final String UNCHECKED _ TOMBSTONE _ COMPACTION _ OPTION = " unchecked _ tombstone _ compaction " ; 
 protected static final String COMPACTION _ ENABLED = " enabled " ; 
 
 - public final Map < String , String > options ; 
 + protected Map < String , String > options ; 
 
 protected final ColumnFamilyStore cfs ; 
 protected float tombstoneThreshold ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 index 15287bd . . dec0cef 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 @ @ - 57 , 9 + 57 , 6 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 @ Override 
 public synchronized AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) 
 { 
 - if ( ! isEnabled ( ) ) 
 - return null ; 
 - 
 while ( true ) 
 { 
 List < SSTableReader > latestBucket = getNextBackgroundSSTables ( gcBefore ) ; 
 @ @ - 79 , 7 + 76 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 * / 
 private List < SSTableReader > getNextBackgroundSSTables ( final int gcBefore ) 
 { 
 - if ( ! isEnabled ( ) | | cfs . getSSTables ( ) . isEmpty ( ) ) 
 + if ( cfs . getSSTables ( ) . isEmpty ( ) ) 
 return Collections . emptyList ( ) ; 
 
 Set < SSTableReader > uncompacting = Sets . intersection ( sstables , cfs . getUncompactingSSTables ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 index f9e5d16 . . 8afe6b6 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 @ @ - 87 , 8 + 87 , 6 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy 
 * / 
 public synchronized AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) 
 { 
 - if ( ! isEnabled ( ) ) 
 - return null ; 
 Collection < AbstractCompactionTask > tasks = getMaximalTask ( gcBefore ) ; 
 if ( tasks = = null | | tasks . size ( ) = = 0 ) 
 return null ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 index 93484e8 . . 1f4acdb 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 @ @ - 75 , 9 + 75 , 6 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 
 private List < SSTableReader > getNextBackgroundSSTables ( final int gcBefore ) 
 { 
 - if ( ! isEnabled ( ) ) 
 - return Collections . emptyList ( ) ; 
 - 
 / / make local copies so they can ' t be changed out from under us mid - method 
 int minThreshold = cfs . getMinimumCompactionThreshold ( ) ; 
 int maxThreshold = cfs . getMaximumCompactionThreshold ( ) ; 
 @ @ - 177 , 9 + 174 , 6 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 
 public synchronized AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) 
 { 
 - if ( ! isEnabled ( ) ) 
 - return null ; 
 - 
 while ( true ) 
 { 
 List < SSTableReader > hottestBucket = getNextBackgroundSSTables ( gcBefore ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / WrappingCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / WrappingCompactionStrategy . java 
 index 2f8bd7c . . e01b4c6 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / WrappingCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / WrappingCompactionStrategy . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import java . util . List ; 
 import java . util . Set ; 
 import java . util . concurrent . Callable ; 
 
 + import com . google . common . collect . ImmutableMap ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 150 , 18 + 151 , 23 @ @ public final class WrappingCompactionStrategy extends AbstractCompactionStrategy 
 & & repaired . options . equals ( metadata . compactionStrategyOptions ) 
 & & unrepaired . options . equals ( metadata . compactionStrategyOptions ) ) 
 return ; 
 - 
 reloadCompactionStrategy ( metadata ) ; 
 } 
 
 public synchronized void reloadCompactionStrategy ( CFMetaData metadata ) 
 { 
 + boolean disabledWithJMX = ! isEnabled ( ) & & shouldBeEnabled ( ) ; 
 if ( repaired ! = null ) 
 repaired . shutdown ( ) ; 
 if ( unrepaired ! = null ) 
 unrepaired . shutdown ( ) ; 
 repaired = metadata . createCompactionStrategyInstance ( cfs ) ; 
 unrepaired = metadata . createCompactionStrategyInstance ( cfs ) ; 
 + options = ImmutableMap . copyOf ( metadata . compactionStrategyOptions ) ; 
 + if ( disabledWithJMX | | ! shouldBeEnabled ( ) ) 
 + disable ( ) ; 
 + else 
 + enable ( ) ; 
 startup ( ) ; 
 } 
 
 @ @ - 344 , 6 + 350 , 28 @ @ public final class WrappingCompactionStrategy extends AbstractCompactionStrategy 
 } 
 
 @ Override 
 + public void enable ( ) 
 + { 
 + if ( repaired ! = null ) 
 + repaired . enable ( ) ; 
 + if ( unrepaired ! = null ) 
 + unrepaired . enable ( ) ; 
 + / / enable this last to make sure the strategies are ready to get calls . 
 + super . enable ( ) ; 
 + } 
 + 
 + @ Override 
 + public void disable ( ) 
 + { 
 + / / disable this first avoid asking disabled strategies for compaction tasks 
 + super . disable ( ) ; 
 + if ( repaired ! = null ) 
 + repaired . disable ( ) ; 
 + if ( unrepaired ! = null ) 
 + unrepaired . disable ( ) ; 
 + } 
 + 
 + @ Override 
 public synchronized ScannerList getScanners ( Collection < SSTableReader > sstables , Range < Token > range ) 
 { 
 List < SSTableReader > repairedSSTables = new ArrayList < > ( ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3b80885 . . f6769fe 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 1 . 2 - rc1 
 + * Fix rare race condition in getExpireTimeForEndpoint ( CASSANDRA - 4402 ) 
 * acquire references to overlapping sstables during compaction so bloom filter 
 doesn ' t get free ' d prematurely ( CASSANDRA - 4934 ) 
 * Don ' t share slice query filter in CQL3 SelectStatement ( CASSANDRA - 4928 ) 
 diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java 
 index 85611de . . 18b7e4b 100644 
 - - - a / src / java / org / apache / cassandra / db / Table . java 
 + + + b / src / java / org / apache / cassandra / db / Table . java 
 @ @ - 22 , 6 + 22 , 7 @ @ import java . io . IOException ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 import java . util . concurrent . ConcurrentHashMap ; 
 + import java . util . concurrent . ConcurrentMap ; 
 import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . Future ; 
 import java . util . concurrent . locks . ReentrantReadWriteLock ; 
 @ @ - 71 , 7 + 72 , 7 @ @ public class Table 
 / * Table name . * / 
 public final String name ; 
 / * ColumnFamilyStore per column family * / 
 - private final Map < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < UUID , ColumnFamilyStore > ( ) ; 
 + private final ConcurrentMap < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < UUID , ColumnFamilyStore > ( ) ; 
 private final Object [ ] indexLocks ; 
 private volatile AbstractReplicationStrategy replicationStrategy ; 
 
 @ @ - 319 , 19 + 320 , 25 @ @ public class Table 
 * / 
 public void initCf ( UUID cfId , String cfName , boolean loadSSTables ) 
 { 
 - if ( columnFamilyStores . containsKey ( cfId ) ) 
 - { 
 - / / this is the case when you reset local schema 
 - / / just reload metadata 
 - ColumnFamilyStore cfs = columnFamilyStores . get ( cfId ) ; 
 - assert cfs . getColumnFamilyName ( ) . equals ( cfName ) ; 
 + ColumnFamilyStore cfs = columnFamilyStores . get ( cfId ) ; 
 
 - cfs . metadata . reload ( ) ; 
 - cfs . reload ( ) ; 
 + if ( cfs = = null ) 
 + { 
 + / / CFS being created for the first time , either on server startup or new CF being added . 
 + / / We don ' t worry about races here ; startup is safe , and adding multiple idential CFs 
 + / / simultaneously is a " don ' t do that " scenario . 
 + ColumnFamilyStore oldCfs = columnFamilyStores . putIfAbsent ( cfId , ColumnFamilyStore . createColumnFamilyStore ( this , cfName , loadSSTables ) ) ; 
 + / / CFS mbean instantiation will error out before we hit this , but in case that changes . . . 
 + if ( oldCfs ! = null ) 
 + throw new IllegalStateException ( " added multiple mappings for cf id " + cfId ) ; 
 } 
 else 
 { 
 - columnFamilyStores . put ( cfId , ColumnFamilyStore . createColumnFamilyStore ( this , cfName , loadSSTables ) ) ; 
 + / / re - initializing an existing CF . This will happen if you cleared the schema 
 + / / on this node and it ' s getting repopulated from the rest of the cluster . 
 + assert cfs . getColumnFamilyName ( ) . equals ( cfName ) ; 
 + cfs . metadata . reload ( ) ; 
 + cfs . reload ( ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index e49a6b3 . . 5880210 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import java . util . concurrent . * ; 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 
 + import com . google . common . annotations . VisibleForTesting ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 90 , 7 + 91 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 private final Set < InetAddress > seeds = new ConcurrentSkipListSet < InetAddress > ( inetcomparator ) ; 
 
 / * map where key is the endpoint and value is the state associated with the endpoint * / 
 - final Map < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; 
 + final ConcurrentMap < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; 
 
 / * map where key is endpoint and value is timestamp when this endpoint was removed from 
 * gossip . We will ignore any gossip regarding these endpoints for QUARANTINE _ DELAY time 
 @ @ - 601 , 12 + 602 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 protected long getExpireTimeForEndpoint ( InetAddress endpoint ) 
 { 
 / * default expireTime is aVeryLongTime * / 
 - long expireTime = computeExpireTime ( ) ; 
 - if ( expireTimeEndpointMap . containsKey ( endpoint ) ) 
 - { 
 - expireTime = expireTimeEndpointMap . get ( endpoint ) ; 
 - } 
 - return expireTime ; 
 + Long storedTime = expireTimeEndpointMap . get ( endpoint ) ; 
 + return storedTime = = null ? computeExpireTime ( ) : storedTime ; 
 } 
 
 public EndpointState getEndpointStateForEndpoint ( InetAddress ep ) 
 @ @ - 1031 , 17 + 1028 , 13 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 TimeUnit . MILLISECONDS ) ; 
 } 
 
 - / / initialize local HB state if needed . 
 + / / initialize local HB state if needed , i . e . , if gossiper has never been started before . 
 public void maybeInitializeLocalState ( int generationNbr ) 
 { 
 - EndpointState localState = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; 
 - if ( localState = = null ) 
 - { 
 - HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; 
 - localState = new EndpointState ( hbState ) ; 
 - localState . markAlive ( ) ; 
 - endpointStateMap . put ( FBUtilities . getBroadcastAddress ( ) , localState ) ; 
 - } 
 + HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; 
 + EndpointState localState = new EndpointState ( hbState ) ; 
 + localState . markAlive ( ) ; 
 + endpointStateMap . putIfAbsent ( FBUtilities . getBroadcastAddress ( ) , localState ) ; 
 } 
 
 
 @ @ - 1093 , 27 + 1086 , 20 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 return ( scheduledGossipTask ! = null ) & & ( ! scheduledGossipTask . isCancelled ( ) ) ; 
 } 
 
 - / * * 
 - * This should * only * be used for testing purposes . 
 - * / 
 - public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) { 
 - / * initialize the heartbeat state for this localEndpoint * / 
 - EndpointState localState = endpointStateMap . get ( addr ) ; 
 - if ( localState = = null ) 
 - { 
 - HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; 
 - localState = new EndpointState ( hbState ) ; 
 - localState . markAlive ( ) ; 
 - endpointStateMap . put ( addr , localState ) ; 
 - } 
 + @ VisibleForTesting 
 + public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) 
 + { 
 + HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; 
 + EndpointState localState = new EndpointState ( hbState ) ; 
 + localState . markAlive ( ) ; 
 + endpointStateMap . putIfAbsent ( addr , localState ) ; 
 + 
 / / always add the version state 
 localState . addApplicationState ( ApplicationState . NET _ VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; 
 localState . addApplicationState ( ApplicationState . HOST _ ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; 
 } 
 
 - / * * 
 - * This should * only * be used for testing purposes 
 - * / 
 + @ VisibleForTesting 
 public void injectApplicationState ( InetAddress endpoint , ApplicationState state , VersionedValue value ) 
 { 
 EndpointState localState = endpointStateMap . get ( endpoint ) ;
