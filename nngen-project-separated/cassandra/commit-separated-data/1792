BLEU SCORE: 0.04576506607182439

TEST MSG: make EchoMessage a singleton
GENERATED MSG: Fix TimeoutException when there is a firewall issue .

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / gms / EchoMessage . java b / src / java / org / apache / cassandra / gms / EchoMessage . java <nl> index 444278f . . 2d4c095 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / EchoMessage . java <nl> + + + b / src / java / org / apache / cassandra / gms / EchoMessage . java <nl> @ @ - 27 , 10 + 27 , 16 @ @ import java . io . IOException ; <nl> import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> <nl> - public class EchoMessage <nl> + public final class EchoMessage <nl> { <nl> - public static IVersionedSerializer < EchoMessage > serializer = new EchoMessageSerializer ( ) ; <nl> + 	 public static final EchoMessage instance = new EchoMessage ( ) ; <nl> + 	 <nl> + public static final IVersionedSerializer < EchoMessage > serializer = new EchoMessageSerializer ( ) ; <nl> <nl> + 	 private EchoMessage ( ) <nl> + 	 { <nl> + 	 } <nl> + 	 <nl> public static class EchoMessageSerializer implements IVersionedSerializer < EchoMessage > <nl> { <nl> public void serialize ( EchoMessage t , DataOutputPlus out , int version ) throws IOException <nl> @ @ - 39 , 7 + 45 , 7 @ @ public class EchoMessage <nl> <nl> public EchoMessage deserialize ( DataInput in , int version ) throws IOException <nl> { <nl> - return new EchoMessage ( ) ; <nl> + return EchoMessage . instance ; <nl> } <nl> <nl> public long serializedSize ( EchoMessage t , int version ) <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index 1820c06 . . d7b1ec7 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 899 , 7 + 899 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> <nl> localState . markDead ( ) ; <nl> <nl> - MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . ECHO , new EchoMessage ( ) , EchoMessage . serializer ) ; <nl> + MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . ECHO , EchoMessage . instance , EchoMessage . serializer ) ; <nl> logger . trace ( " Sending a EchoMessage to { } " , addr ) ; <nl> IAsyncCallback echoHandler = new IAsyncCallback ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / EchoVerbHandler . java b / src / java / org / apache / cassandra / service / EchoVerbHandler . java <nl> index 57e7a0d . . 3d3f69e 100644 <nl> - - - a / src / java / org / apache / cassandra / service / EchoVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / EchoVerbHandler . java <nl> @ @ - 35 , 7 + 35 , 7 @ @ public class EchoVerbHandler implements IVerbHandler < EchoMessage > <nl> <nl> public void doVerb ( MessageIn < EchoMessage > message , int id ) <nl> { <nl> - MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . REQUEST _ RESPONSE , new EchoMessage ( ) , EchoMessage . serializer ) ; <nl> + MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . REQUEST _ RESPONSE , EchoMessage . instance , EchoMessage . serializer ) ; <nl> logger . trace ( " Sending a EchoMessage reply { } " , message . from ) ; <nl> MessagingService . instance ( ) . sendReply ( echoMessage , id , message . from ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c1e2540 . . e64358f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 1 . 2 . 4 <nl> + * Ensure that PerRowSecondaryIndex updates see the most recent values <nl> + ( CASSANDRA - 5397 ) <nl> * avoid duplicate index entries ind PrecompactedRow and <nl> ParallelCompactionIterable ( CASSANDRA - 5395 ) <nl> * remove the index entry on oldColumn when new column is a tombstone <nl> diff - - git a / src / java / org / apache / cassandra / db / AtomicSortedColumns . java b / src / java / org / apache / cassandra / db / AtomicSortedColumns . java <nl> index 83aabea . . 552ad6a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / AtomicSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / AtomicSortedColumns . java <nl> @ @ - 195 , 6 + 195 , 8 @ @ public class AtomicSortedColumns implements ISortedColumns <nl> } <nl> while ( ! ref . compareAndSet ( current , modified ) ) ; <nl> <nl> + indexer . commit ( ) ; <nl> + <nl> return sizeDelta ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> index 83374d9 . . df7ceff 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> @ @ - 19 , 21 + 19 , 18 @ @ package org . apache . cassandra . db . index ; <nl> <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> - import java . util . concurrent . ConcurrentNavigableMap ; <nl> - import java . util . concurrent . ConcurrentSkipListMap ; <nl> - import java . util . concurrent . ExecutionException ; <nl> - import java . util . concurrent . Future ; <nl> + import java . util . concurrent . * ; <nl> <nl> import org . apache . commons . lang . StringUtils ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> - import org . apache . cassandra . db . filter . IDiskAtomFilter ; <nl> - import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . compaction . CompactionManager ; <nl> + import org . apache . cassandra . db . filter . IDiskAtomFilter ; <nl> import org . apache . cassandra . dht . AbstractBounds ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . io . sstable . ReducingKeyIterator ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . thrift . Column ; <nl> @ @ - 54 , 6 + 51 , 8 @ @ public class SecondaryIndexManager <nl> public void update ( IColumn oldColumn , IColumn column ) { } <nl> <nl> public void remove ( IColumn current ) { } <nl> + <nl> + public void commit ( ) { } <nl> } ; <nl> <nl> / * * <nl> @ @ - 580 , 11 + 579 , 17 @ @ public class SecondaryIndexManager <nl> <nl> public static interface Updater <nl> { <nl> + / * * called when constructing the index against pre - existing data * / <nl> public void insert ( IColumn column ) ; <nl> <nl> + / * * called when updating the index from a memtable * / <nl> public void update ( IColumn oldColumn , IColumn column ) ; <nl> <nl> + / * * called when lazy - updating the index during compaction ( CASSANDRA - 2897 ) * / <nl> public void remove ( IColumn current ) ; <nl> + <nl> + / * * called after memtable updates are complete ( CASSANDRA - 5397 ) * / <nl> + public void commit ( ) ; <nl> } <nl> <nl> private class PerColumnIndexUpdater implements Updater <nl> @ @ - 630 , 12 + 635 , 17 @ @ public class SecondaryIndexManager <nl> <nl> ( ( PerColumnSecondaryIndex ) index ) . delete ( key . key , column ) ; <nl> } <nl> + <nl> + public void commit ( ) <nl> + { <nl> + / / this is a no - op as per - column index updates are applied immediately <nl> + } <nl> } <nl> <nl> private class MixedIndexUpdater implements Updater <nl> { <nl> private final DecoratedKey key ; <nl> - Set < Class < ? extends SecondaryIndex > > appliedRowLevelIndexes = new HashSet < Class < ? extends SecondaryIndex > > ( ) ; <nl> + ConcurrentHashMap < SecondaryIndex , ByteBuffer > deferredUpdates = new ConcurrentHashMap < SecondaryIndex , ByteBuffer > ( ) ; <nl> <nl> public MixedIndexUpdater ( DecoratedKey key ) <nl> { <nl> @ @ - 651 , 14 + 661 , 13 @ @ public class SecondaryIndexManager <nl> if ( index = = null ) <nl> return ; <nl> <nl> - if ( index instanceof PerColumnSecondaryIndex ) <nl> + if ( index instanceof PerColumnSecondaryIndex ) <nl> { <nl> ( ( PerColumnSecondaryIndex ) index ) . insert ( key . key , column ) ; <nl> } <nl> else <nl> { <nl> - if ( appliedRowLevelIndexes . add ( index . getClass ( ) ) ) <nl> - ( ( PerRowSecondaryIndex ) index ) . index ( key . key ) ; <nl> + deferredUpdates . putIfAbsent ( index , key . key ) ; <nl> } <nl> } <nl> <nl> @ @ - 668 , 7 + 677 , 7 @ @ public class SecondaryIndexManager <nl> if ( index = = null ) <nl> return ; <nl> <nl> - if ( index instanceof PerColumnSecondaryIndex ) <nl> + if ( index instanceof PerColumnSecondaryIndex ) <nl> { <nl> ( ( PerColumnSecondaryIndex ) index ) . delete ( key . key , oldColumn ) ; <nl> if ( ! column . isMarkedForDelete ( ) ) <nl> @ @ - 676 , 8 + 685 , 7 @ @ public class SecondaryIndexManager <nl> } <nl> else <nl> { <nl> - if ( appliedRowLevelIndexes . add ( index . getClass ( ) ) ) <nl> - ( ( PerRowSecondaryIndex ) index ) . index ( key . key ) ; <nl> + deferredUpdates . putIfAbsent ( index , key . key ) ; <nl> } <nl> } <nl> <nl> @ @ - 690 , 14 + 698 , 23 @ @ public class SecondaryIndexManager <nl> if ( index = = null ) <nl> return ; <nl> <nl> - if ( index instanceof PerColumnSecondaryIndex ) <nl> + if ( index instanceof PerColumnSecondaryIndex ) <nl> { <nl> ( ( PerColumnSecondaryIndex ) index ) . delete ( key . key , column ) ; <nl> } <nl> else <nl> { <nl> - if ( appliedRowLevelIndexes . add ( index . getClass ( ) ) ) <nl> - ( ( PerRowSecondaryIndex ) index ) . index ( key . key ) ; <nl> + / / per - row secondary indexes are assumed to keep the index up - to - date at insert time , rather <nl> + / / than performing lazy updates <nl> + } <nl> + } <nl> + <nl> + public void commit ( ) <nl> + { <nl> + for ( Map . Entry < SecondaryIndex , ByteBuffer > update : deferredUpdates . entrySet ( ) ) <nl> + { <nl> + assert update . getKey ( ) instanceof PerRowSecondaryIndex ; <nl> + ( ( PerRowSecondaryIndex ) update . getKey ( ) ) . index ( update . getValue ( ) ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / SchemaLoader . java b / test / unit / org / apache / cassandra / SchemaLoader . java <nl> index 48fbc04 . . cb17665 100644 <nl> - - - a / test / unit / org / apache / cassandra / SchemaLoader . java <nl> + + + b / test / unit / org / apache / cassandra / SchemaLoader . java <nl> @ @ - 24 , 6 + 24 , 8 @ @ import java . util . * ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> import com . google . common . base . Charsets ; <nl> + import org . apache . cassandra . db . index . PerRowSecondaryIndexTest ; <nl> + import org . apache . cassandra . db . index . SecondaryIndex ; <nl> import org . junit . AfterClass ; <nl> import org . junit . BeforeClass ; <nl> import org . slf4j . Logger ; <nl> @ @ - 113 , 6 + 115 , 8 @ @ public class SchemaLoader <nl> String ks _ kcs = " KeyCacheSpace " ; <nl> String ks _ rcs = " RowCacheSpace " ; <nl> String ks _ nocommit = " NoCommitlogSpace " ; <nl> + String ks _ prsi = " PerRowSecondaryIndex " ; <nl> + <nl> <nl> Class < ? extends AbstractReplicationStrategy > simple = SimpleStrategy . class ; <nl> <nl> @ @ - 290 , 6 + 294 , 12 @ @ public class SchemaLoader <nl> opts _ rf1 , <nl> standardCFMD ( ks _ nocommit , " Standard1 " , withOldCfIds ) ) ) ; <nl> <nl> + / / PerRowSecondaryIndexTest <nl> + schema . add ( KSMetaData . testMetadata ( ks _ prsi , <nl> + simple , <nl> + opts _ rf1 , <nl> + perRowIndexedCFMD ( ks _ prsi , " Indexed1 " , withOldCfIds ) ) ) ; <nl> + <nl> <nl> if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . test . compression " , " false " ) ) ) <nl> useCompression ( schema ) ; <nl> @ @ - 297 , 6 + 307 , 25 @ @ public class SchemaLoader <nl> return schema ; <nl> } <nl> <nl> + private static CFMetaData perRowIndexedCFMD ( String ksName , String cfName , boolean withOldCfIds ) <nl> + { <nl> + final Map < String , String > indexOptions = Collections . singletonMap ( <nl> + SecondaryIndex . CUSTOM _ INDEX _ OPTION _ NAME , <nl> + PerRowSecondaryIndexTest . TestIndex . class . getName ( ) ) ; <nl> + return standardCFMD ( ksName , cfName , withOldCfIds ) <nl> + . keyValidator ( AsciiType . instance ) <nl> + . columnMetadata ( new HashMap < ByteBuffer , ColumnDefinition > ( ) <nl> + { { <nl> + ByteBuffer cName = ByteBuffer . wrap ( " indexed " . getBytes ( Charsets . UTF _ 8 ) ) ; <nl> + put ( cName , new ColumnDefinition ( cName , <nl> + AsciiType . instance , <nl> + IndexType . CUSTOM , <nl> + indexOptions , <nl> + ByteBufferUtil . bytesToHex ( cName ) , <nl> + null ) ) ; <nl> + } } ) ; <nl> + } <nl> + <nl> private static void useCompression ( List < KSMetaData > schema ) <nl> { <nl> for ( KSMetaData ksm : schema ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java b / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java <nl> new file mode 100644 <nl> index 0000000 . . 3a4f947 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java <nl> @ @ - 0 , 0 + 1 , 151 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . db . index ; <nl> + <nl> + <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . db . filter . QueryFilter ; <nl> + import org . apache . cassandra . db . filter . QueryPath ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . Set ; <nl> + <nl> + import static junit . framework . Assert . assertEquals ; <nl> + import static junit . framework . Assert . assertNotNull ; <nl> + <nl> + public class PerRowSecondaryIndexTest extends SchemaLoader <nl> + { <nl> + <nl> + / / test that when index ( key ) is called on a PRSI index , <nl> + / / the data to be indexed can be read using the supplied <nl> + / / key . TestIndex . index ( key ) simply reads the data to be <nl> + / / indexed & stashes it in a static variable for inspection <nl> + / / in the test . <nl> + <nl> + @ Test <nl> + public void testIndexInsertAndUpdate ( ) throws IOException <nl> + { <nl> + / / create a row then test that the configured index instance was able to read the row <nl> + RowMutation rm ; <nl> + rm = new RowMutation ( " PerRowSecondaryIndex " , ByteBufferUtil . bytes ( " k1 " ) ) ; <nl> + rm . add ( new QueryPath ( " Indexed1 " , null , ByteBufferUtil . bytes ( " indexed " ) ) , ByteBufferUtil . bytes ( " foo " ) , 1 ) ; <nl> + rm . apply ( ) ; <nl> + <nl> + ColumnFamily indexedRow = TestIndex . LAST _ INDEXED _ ROW ; <nl> + assertNotNull ( indexedRow ) ; <nl> + assertEquals ( ByteBufferUtil . bytes ( " foo " ) , indexedRow . getColumn ( ByteBufferUtil . bytes ( " indexed " ) ) . value ( ) ) ; <nl> + <nl> + / / update the row and verify what was indexed <nl> + rm = new RowMutation ( " PerRowSecondaryIndex " , ByteBufferUtil . bytes ( " k1 " ) ) ; <nl> + rm . add ( new QueryPath ( " Indexed1 " , null , ByteBufferUtil . bytes ( " indexed " ) ) , ByteBufferUtil . bytes ( " bar " ) , 2 ) ; <nl> + rm . apply ( ) ; <nl> + <nl> + indexedRow = TestIndex . LAST _ INDEXED _ ROW ; <nl> + assertNotNull ( indexedRow ) ; <nl> + assertEquals ( ByteBufferUtil . bytes ( " bar " ) , indexedRow . getColumn ( ByteBufferUtil . bytes ( " indexed " ) ) . value ( ) ) ; <nl> + } <nl> + <nl> + public static class TestIndex extends PerRowSecondaryIndex <nl> + { <nl> + public static ColumnFamily LAST _ INDEXED _ ROW ; <nl> + <nl> + @ Override <nl> + public void index ( ByteBuffer rowKey , ColumnFamily cf ) <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public void index ( ByteBuffer rowKey ) <nl> + { <nl> + QueryFilter filter = QueryFilter . getIdentityFilter ( DatabaseDescriptor . getPartitioner ( ) . decorateKey ( rowKey ) , <nl> + new QueryPath ( baseCfs . getColumnFamilyName ( ) ) ) ; <nl> + LAST _ INDEXED _ ROW = baseCfs . getColumnFamily ( filter ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void delete ( DecoratedKey key ) <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public void init ( ) <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public void reload ( ) <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public void validateOptions ( ) throws ConfigurationException <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public String getIndexName ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + @ Override <nl> + protected SecondaryIndexSearcher createSecondaryIndexSearcher ( Set < ByteBuffer > columns ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + @ Override <nl> + public void forceBlockingFlush ( ) <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public long getLiveSize ( ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + <nl> + @ Override <nl> + public ColumnFamilyStore getIndexCfs ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + @ Override <nl> + public void removeIndex ( ByteBuffer columnName ) <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public void invalidate ( ) <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public void truncate ( long truncatedAt ) <nl> + { <nl> + } <nl> + } <nl> + }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / gms / EchoMessage . java b / src / java / org / apache / cassandra / gms / EchoMessage . java 
 index 444278f . . 2d4c095 100644 
 - - - a / src / java / org / apache / cassandra / gms / EchoMessage . java 
 + + + b / src / java / org / apache / cassandra / gms / EchoMessage . java 
 @ @ - 27 , 10 + 27 , 16 @ @ import java . io . IOException ; 
 import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 
 - public class EchoMessage 
 + public final class EchoMessage 
 { 
 - public static IVersionedSerializer < EchoMessage > serializer = new EchoMessageSerializer ( ) ; 
 + 	 public static final EchoMessage instance = new EchoMessage ( ) ; 
 + 	 
 + public static final IVersionedSerializer < EchoMessage > serializer = new EchoMessageSerializer ( ) ; 
 
 + 	 private EchoMessage ( ) 
 + 	 { 
 + 	 } 
 + 	 
 public static class EchoMessageSerializer implements IVersionedSerializer < EchoMessage > 
 { 
 public void serialize ( EchoMessage t , DataOutputPlus out , int version ) throws IOException 
 @ @ - 39 , 7 + 45 , 7 @ @ public class EchoMessage 
 
 public EchoMessage deserialize ( DataInput in , int version ) throws IOException 
 { 
 - return new EchoMessage ( ) ; 
 + return EchoMessage . instance ; 
 } 
 
 public long serializedSize ( EchoMessage t , int version ) 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index 1820c06 . . d7b1ec7 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 899 , 7 + 899 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 
 localState . markDead ( ) ; 
 
 - MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . ECHO , new EchoMessage ( ) , EchoMessage . serializer ) ; 
 + MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . ECHO , EchoMessage . instance , EchoMessage . serializer ) ; 
 logger . trace ( " Sending a EchoMessage to { } " , addr ) ; 
 IAsyncCallback echoHandler = new IAsyncCallback ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / EchoVerbHandler . java b / src / java / org / apache / cassandra / service / EchoVerbHandler . java 
 index 57e7a0d . . 3d3f69e 100644 
 - - - a / src / java / org / apache / cassandra / service / EchoVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / service / EchoVerbHandler . java 
 @ @ - 35 , 7 + 35 , 7 @ @ public class EchoVerbHandler implements IVerbHandler < EchoMessage > 
 
 public void doVerb ( MessageIn < EchoMessage > message , int id ) 
 { 
 - MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . REQUEST _ RESPONSE , new EchoMessage ( ) , EchoMessage . serializer ) ; 
 + MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . REQUEST _ RESPONSE , EchoMessage . instance , EchoMessage . serializer ) ; 
 logger . trace ( " Sending a EchoMessage reply { } " , message . from ) ; 
 MessagingService . instance ( ) . sendReply ( echoMessage , id , message . from ) ; 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c1e2540 . . e64358f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 1 . 2 . 4 
 + * Ensure that PerRowSecondaryIndex updates see the most recent values 
 + ( CASSANDRA - 5397 ) 
 * avoid duplicate index entries ind PrecompactedRow and 
 ParallelCompactionIterable ( CASSANDRA - 5395 ) 
 * remove the index entry on oldColumn when new column is a tombstone 
 diff - - git a / src / java / org / apache / cassandra / db / AtomicSortedColumns . java b / src / java / org / apache / cassandra / db / AtomicSortedColumns . java 
 index 83aabea . . 552ad6a 100644 
 - - - a / src / java / org / apache / cassandra / db / AtomicSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / AtomicSortedColumns . java 
 @ @ - 195 , 6 + 195 , 8 @ @ public class AtomicSortedColumns implements ISortedColumns 
 } 
 while ( ! ref . compareAndSet ( current , modified ) ) ; 
 
 + indexer . commit ( ) ; 
 + 
 return sizeDelta ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 index 83374d9 . . df7ceff 100644 
 - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 @ @ - 19 , 21 + 19 , 18 @ @ package org . apache . cassandra . db . index ; 
 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 - import java . util . concurrent . ConcurrentNavigableMap ; 
 - import java . util . concurrent . ConcurrentSkipListMap ; 
 - import java . util . concurrent . ExecutionException ; 
 - import java . util . concurrent . Future ; 
 + import java . util . concurrent . * ; 
 
 import org . apache . commons . lang . StringUtils ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . config . ColumnDefinition ; 
 - import org . apache . cassandra . db . filter . IDiskAtomFilter ; 
 - import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . compaction . CompactionManager ; 
 + import org . apache . cassandra . db . filter . IDiskAtomFilter ; 
 import org . apache . cassandra . dht . AbstractBounds ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . io . sstable . ReducingKeyIterator ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . thrift . Column ; 
 @ @ - 54 , 6 + 51 , 8 @ @ public class SecondaryIndexManager 
 public void update ( IColumn oldColumn , IColumn column ) { } 
 
 public void remove ( IColumn current ) { } 
 + 
 + public void commit ( ) { } 
 } ; 
 
 / * * 
 @ @ - 580 , 11 + 579 , 17 @ @ public class SecondaryIndexManager 
 
 public static interface Updater 
 { 
 + / * * called when constructing the index against pre - existing data * / 
 public void insert ( IColumn column ) ; 
 
 + / * * called when updating the index from a memtable * / 
 public void update ( IColumn oldColumn , IColumn column ) ; 
 
 + / * * called when lazy - updating the index during compaction ( CASSANDRA - 2897 ) * / 
 public void remove ( IColumn current ) ; 
 + 
 + / * * called after memtable updates are complete ( CASSANDRA - 5397 ) * / 
 + public void commit ( ) ; 
 } 
 
 private class PerColumnIndexUpdater implements Updater 
 @ @ - 630 , 12 + 635 , 17 @ @ public class SecondaryIndexManager 
 
 ( ( PerColumnSecondaryIndex ) index ) . delete ( key . key , column ) ; 
 } 
 + 
 + public void commit ( ) 
 + { 
 + / / this is a no - op as per - column index updates are applied immediately 
 + } 
 } 
 
 private class MixedIndexUpdater implements Updater 
 { 
 private final DecoratedKey key ; 
 - Set < Class < ? extends SecondaryIndex > > appliedRowLevelIndexes = new HashSet < Class < ? extends SecondaryIndex > > ( ) ; 
 + ConcurrentHashMap < SecondaryIndex , ByteBuffer > deferredUpdates = new ConcurrentHashMap < SecondaryIndex , ByteBuffer > ( ) ; 
 
 public MixedIndexUpdater ( DecoratedKey key ) 
 { 
 @ @ - 651 , 14 + 661 , 13 @ @ public class SecondaryIndexManager 
 if ( index = = null ) 
 return ; 
 
 - if ( index instanceof PerColumnSecondaryIndex ) 
 + if ( index instanceof PerColumnSecondaryIndex ) 
 { 
 ( ( PerColumnSecondaryIndex ) index ) . insert ( key . key , column ) ; 
 } 
 else 
 { 
 - if ( appliedRowLevelIndexes . add ( index . getClass ( ) ) ) 
 - ( ( PerRowSecondaryIndex ) index ) . index ( key . key ) ; 
 + deferredUpdates . putIfAbsent ( index , key . key ) ; 
 } 
 } 
 
 @ @ - 668 , 7 + 677 , 7 @ @ public class SecondaryIndexManager 
 if ( index = = null ) 
 return ; 
 
 - if ( index instanceof PerColumnSecondaryIndex ) 
 + if ( index instanceof PerColumnSecondaryIndex ) 
 { 
 ( ( PerColumnSecondaryIndex ) index ) . delete ( key . key , oldColumn ) ; 
 if ( ! column . isMarkedForDelete ( ) ) 
 @ @ - 676 , 8 + 685 , 7 @ @ public class SecondaryIndexManager 
 } 
 else 
 { 
 - if ( appliedRowLevelIndexes . add ( index . getClass ( ) ) ) 
 - ( ( PerRowSecondaryIndex ) index ) . index ( key . key ) ; 
 + deferredUpdates . putIfAbsent ( index , key . key ) ; 
 } 
 } 
 
 @ @ - 690 , 14 + 698 , 23 @ @ public class SecondaryIndexManager 
 if ( index = = null ) 
 return ; 
 
 - if ( index instanceof PerColumnSecondaryIndex ) 
 + if ( index instanceof PerColumnSecondaryIndex ) 
 { 
 ( ( PerColumnSecondaryIndex ) index ) . delete ( key . key , column ) ; 
 } 
 else 
 { 
 - if ( appliedRowLevelIndexes . add ( index . getClass ( ) ) ) 
 - ( ( PerRowSecondaryIndex ) index ) . index ( key . key ) ; 
 + / / per - row secondary indexes are assumed to keep the index up - to - date at insert time , rather 
 + / / than performing lazy updates 
 + } 
 + } 
 + 
 + public void commit ( ) 
 + { 
 + for ( Map . Entry < SecondaryIndex , ByteBuffer > update : deferredUpdates . entrySet ( ) ) 
 + { 
 + assert update . getKey ( ) instanceof PerRowSecondaryIndex ; 
 + ( ( PerRowSecondaryIndex ) update . getKey ( ) ) . index ( update . getValue ( ) ) ; 
 } 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / SchemaLoader . java b / test / unit / org / apache / cassandra / SchemaLoader . java 
 index 48fbc04 . . cb17665 100644 
 - - - a / test / unit / org / apache / cassandra / SchemaLoader . java 
 + + + b / test / unit / org / apache / cassandra / SchemaLoader . java 
 @ @ - 24 , 6 + 24 , 8 @ @ import java . util . * ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 
 import com . google . common . base . Charsets ; 
 + import org . apache . cassandra . db . index . PerRowSecondaryIndexTest ; 
 + import org . apache . cassandra . db . index . SecondaryIndex ; 
 import org . junit . AfterClass ; 
 import org . junit . BeforeClass ; 
 import org . slf4j . Logger ; 
 @ @ - 113 , 6 + 115 , 8 @ @ public class SchemaLoader 
 String ks _ kcs = " KeyCacheSpace " ; 
 String ks _ rcs = " RowCacheSpace " ; 
 String ks _ nocommit = " NoCommitlogSpace " ; 
 + String ks _ prsi = " PerRowSecondaryIndex " ; 
 + 
 
 Class < ? extends AbstractReplicationStrategy > simple = SimpleStrategy . class ; 
 
 @ @ - 290 , 6 + 294 , 12 @ @ public class SchemaLoader 
 opts _ rf1 , 
 standardCFMD ( ks _ nocommit , " Standard1 " , withOldCfIds ) ) ) ; 
 
 + / / PerRowSecondaryIndexTest 
 + schema . add ( KSMetaData . testMetadata ( ks _ prsi , 
 + simple , 
 + opts _ rf1 , 
 + perRowIndexedCFMD ( ks _ prsi , " Indexed1 " , withOldCfIds ) ) ) ; 
 + 
 
 if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . test . compression " , " false " ) ) ) 
 useCompression ( schema ) ; 
 @ @ - 297 , 6 + 307 , 25 @ @ public class SchemaLoader 
 return schema ; 
 } 
 
 + private static CFMetaData perRowIndexedCFMD ( String ksName , String cfName , boolean withOldCfIds ) 
 + { 
 + final Map < String , String > indexOptions = Collections . singletonMap ( 
 + SecondaryIndex . CUSTOM _ INDEX _ OPTION _ NAME , 
 + PerRowSecondaryIndexTest . TestIndex . class . getName ( ) ) ; 
 + return standardCFMD ( ksName , cfName , withOldCfIds ) 
 + . keyValidator ( AsciiType . instance ) 
 + . columnMetadata ( new HashMap < ByteBuffer , ColumnDefinition > ( ) 
 + { { 
 + ByteBuffer cName = ByteBuffer . wrap ( " indexed " . getBytes ( Charsets . UTF _ 8 ) ) ; 
 + put ( cName , new ColumnDefinition ( cName , 
 + AsciiType . instance , 
 + IndexType . CUSTOM , 
 + indexOptions , 
 + ByteBufferUtil . bytesToHex ( cName ) , 
 + null ) ) ; 
 + } } ) ; 
 + } 
 + 
 private static void useCompression ( List < KSMetaData > schema ) 
 { 
 for ( KSMetaData ksm : schema ) 
 diff - - git a / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java b / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java 
 new file mode 100644 
 index 0000000 . . 3a4f947 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java 
 @ @ - 0 , 0 + 1 , 151 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . db . index ; 
 + 
 + 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . db . filter . QueryFilter ; 
 + import org . apache . cassandra . db . filter . QueryPath ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 + import org . junit . Test ; 
 + 
 + import java . io . IOException ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . Set ; 
 + 
 + import static junit . framework . Assert . assertEquals ; 
 + import static junit . framework . Assert . assertNotNull ; 
 + 
 + public class PerRowSecondaryIndexTest extends SchemaLoader 
 + { 
 + 
 + / / test that when index ( key ) is called on a PRSI index , 
 + / / the data to be indexed can be read using the supplied 
 + / / key . TestIndex . index ( key ) simply reads the data to be 
 + / / indexed & stashes it in a static variable for inspection 
 + / / in the test . 
 + 
 + @ Test 
 + public void testIndexInsertAndUpdate ( ) throws IOException 
 + { 
 + / / create a row then test that the configured index instance was able to read the row 
 + RowMutation rm ; 
 + rm = new RowMutation ( " PerRowSecondaryIndex " , ByteBufferUtil . bytes ( " k1 " ) ) ; 
 + rm . add ( new QueryPath ( " Indexed1 " , null , ByteBufferUtil . bytes ( " indexed " ) ) , ByteBufferUtil . bytes ( " foo " ) , 1 ) ; 
 + rm . apply ( ) ; 
 + 
 + ColumnFamily indexedRow = TestIndex . LAST _ INDEXED _ ROW ; 
 + assertNotNull ( indexedRow ) ; 
 + assertEquals ( ByteBufferUtil . bytes ( " foo " ) , indexedRow . getColumn ( ByteBufferUtil . bytes ( " indexed " ) ) . value ( ) ) ; 
 + 
 + / / update the row and verify what was indexed 
 + rm = new RowMutation ( " PerRowSecondaryIndex " , ByteBufferUtil . bytes ( " k1 " ) ) ; 
 + rm . add ( new QueryPath ( " Indexed1 " , null , ByteBufferUtil . bytes ( " indexed " ) ) , ByteBufferUtil . bytes ( " bar " ) , 2 ) ; 
 + rm . apply ( ) ; 
 + 
 + indexedRow = TestIndex . LAST _ INDEXED _ ROW ; 
 + assertNotNull ( indexedRow ) ; 
 + assertEquals ( ByteBufferUtil . bytes ( " bar " ) , indexedRow . getColumn ( ByteBufferUtil . bytes ( " indexed " ) ) . value ( ) ) ; 
 + } 
 + 
 + public static class TestIndex extends PerRowSecondaryIndex 
 + { 
 + public static ColumnFamily LAST _ INDEXED _ ROW ; 
 + 
 + @ Override 
 + public void index ( ByteBuffer rowKey , ColumnFamily cf ) 
 + { 
 + } 
 + 
 + @ Override 
 + public void index ( ByteBuffer rowKey ) 
 + { 
 + QueryFilter filter = QueryFilter . getIdentityFilter ( DatabaseDescriptor . getPartitioner ( ) . decorateKey ( rowKey ) , 
 + new QueryPath ( baseCfs . getColumnFamilyName ( ) ) ) ; 
 + LAST _ INDEXED _ ROW = baseCfs . getColumnFamily ( filter ) ; 
 + } 
 + 
 + @ Override 
 + public void delete ( DecoratedKey key ) 
 + { 
 + } 
 + 
 + @ Override 
 + public void init ( ) 
 + { 
 + } 
 + 
 + @ Override 
 + public void reload ( ) 
 + { 
 + } 
 + 
 + @ Override 
 + public void validateOptions ( ) throws ConfigurationException 
 + { 
 + } 
 + 
 + @ Override 
 + public String getIndexName ( ) 
 + { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + protected SecondaryIndexSearcher createSecondaryIndexSearcher ( Set < ByteBuffer > columns ) 
 + { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public void forceBlockingFlush ( ) 
 + { 
 + } 
 + 
 + @ Override 
 + public long getLiveSize ( ) 
 + { 
 + return 0 ; 
 + } 
 + 
 + @ Override 
 + public ColumnFamilyStore getIndexCfs ( ) 
 + { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public void removeIndex ( ByteBuffer columnName ) 
 + { 
 + } 
 + 
 + @ Override 
 + public void invalidate ( ) 
 + { 
 + } 
 + 
 + @ Override 
 + public void truncate ( long truncatedAt ) 
 + { 
 + } 
 + } 
 + }
