BLEU SCORE: 0.056697911109760024

TEST MSG: Allow cassandra - stress to set compaction strategy options
GENERATED MSG: Allow nodetool to optionally resolve hostnames .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 607e2dc . . 06331ad 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 0 - beta2 <nl> + * Allow cassandra - stress to set compaction strategy options ( CASSANDRA - 6451 ) <nl> * Add broadcast _ rpc _ address option to cassandra . yaml ( CASSANDRA - 5899 ) <nl> * Auto reload GossipingPropertyFileSnitch config ( CASSANDRA - 5897 ) <nl> * Fix overflow of memtable _ total _ space _ in _ mb ( CASSANDRA - 6573 ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / OptionCompaction . java b / tools / stress / src / org / apache / cassandra / stress / settings / OptionCompaction . java <nl> new file mode 100644 <nl> index 0000000 . . da74e43 <nl> - - - / dev / null <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / OptionCompaction . java <nl> @ @ - 0 , 0 + 1 , 62 @ @ <nl> + package org . apache . cassandra . stress . settings ; <nl> + <nl> + import java . util . Arrays ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + <nl> + import com . google . common . base . Function ; <nl> + <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + <nl> + / * * <nl> + * For specifying replication options <nl> + * / <nl> + class OptionCompaction extends OptionMulti <nl> + { <nl> + <nl> + private final OptionSimple strategy = new OptionSimple ( " strategy = " , new StrategyAdapter ( ) , null , " The compaction strategy to use " , false ) ; <nl> + <nl> + public OptionCompaction ( ) <nl> + { <nl> + super ( " compaction " , " Define the compaction strategy and any parameters " , true ) ; <nl> + } <nl> + <nl> + public String getStrategy ( ) <nl> + { <nl> + return strategy . value ( ) ; <nl> + } <nl> + <nl> + public Map < String , String > getOptions ( ) <nl> + { <nl> + return extraOptions ( ) ; <nl> + } <nl> + <nl> + protected List < ? extends Option > options ( ) <nl> + { <nl> + return Arrays . asList ( strategy ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean happy ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> + private static final class StrategyAdapter implements Function < String , String > <nl> + { <nl> + <nl> + public String apply ( String name ) <nl> + { <nl> + try <nl> + { <nl> + CFMetaData . createCompactionStrategy ( name ) ; <nl> + } catch ( ConfigurationException e ) <nl> + { <nl> + throw new IllegalArgumentException ( " Invalid compaction strategy : " + name ) ; <nl> + } <nl> + return name ; <nl> + } <nl> + } <nl> + <nl> + } <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / OptionMulti . java b / tools / stress / src / org / apache / cassandra / stress / settings / OptionMulti . java <nl> index 1901587 . . 7074dc6 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / OptionMulti . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / OptionMulti . java <nl> @ @ - 22 , 7 + 22 , 11 @ @ package org . apache . cassandra . stress . settings ; <nl> <nl> <nl> import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . LinkedHashMap ; <nl> import java . util . List ; <nl> + import java . util . Map ; <nl> import java . util . regex . Matcher ; <nl> import java . util . regex . Pattern ; <nl> <nl> @ @ - 39 , 21 + 43 , 34 @ @ abstract class OptionMulti extends Option <nl> @ Override <nl> public List < ? extends Option > options ( ) <nl> { <nl> - return OptionMulti . this . options ( ) ; <nl> + if ( collectAsMap = = null ) <nl> + return OptionMulti . this . options ( ) ; <nl> + <nl> + List < Option > options = new ArrayList < > ( OptionMulti . this . options ( ) ) ; <nl> + options . add ( collectAsMap ) ; <nl> + return options ; <nl> } <nl> } <nl> <nl> protected abstract List < ? extends Option > options ( ) ; <nl> <nl> + public Map < String , String > extraOptions ( ) <nl> + { <nl> + return collectAsMap = = null ? new HashMap < String , String > ( ) : collectAsMap . options ; <nl> + } <nl> + <nl> private final String name ; <nl> private final Pattern pattern ; <nl> private final String description ; <nl> private final Delegate delegate = new Delegate ( ) ; <nl> - public OptionMulti ( String name , String description ) <nl> + private final CollectAsMap collectAsMap ; <nl> + <nl> + public OptionMulti ( String name , String description , boolean collectExtraOptionsInMap ) <nl> { <nl> this . name = name ; <nl> pattern = Pattern . compile ( name + " \ \ ( ( . * ) \ \ ) " , Pattern . CASE _ INSENSITIVE ) ; <nl> this . description = description ; <nl> + this . collectAsMap = collectExtraOptionsInMap ? new CollectAsMap ( ) : null ; <nl> } <nl> <nl> @ Override <nl> @ @ - 70 , 7 + 87 , 10 @ @ abstract class OptionMulti extends Option <nl> throw new IllegalArgumentException ( " Invalid " + name + " specification : " + param ) ; <nl> last = m . end ( ) ; <nl> if ( ! delegate . accept ( m . group ( ) ) ) <nl> + { <nl> + <nl> throw new IllegalArgumentException ( " Invalid " + name + " specification : " + m . group ( ) ) ; <nl> + } <nl> } <nl> return true ; <nl> } <nl> @ @ - 125 , 4 + 145 , 42 @ @ abstract class OptionMulti extends Option <nl> return delegate . happy ( ) ; <nl> } <nl> <nl> + private static final class CollectAsMap extends Option <nl> + { <nl> + <nl> + static final String description = " Extra options " ; <nl> + Map < String , String > options = new LinkedHashMap < > ( ) ; <nl> + <nl> + boolean accept ( String param ) <nl> + { <nl> + String [ ] args = param . split ( " = " ) ; <nl> + if ( args . length = = 2 & & args [ 1 ] . length ( ) > 0 & & args [ 0 ] . length ( ) > 0 ) <nl> + { <nl> + options . put ( args [ 0 ] , args [ 1 ] ) ; <nl> + return true ; <nl> + } <nl> + return false ; <nl> + } <nl> + <nl> + boolean happy ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> + String shortDisplay ( ) <nl> + { <nl> + return " [ < option 1 . . N > = ? ] " ; <nl> + } <nl> + <nl> + String longDisplay ( ) <nl> + { <nl> + return GroupedOptions . formatLong ( shortDisplay ( ) , description ) ; <nl> + } <nl> + <nl> + List < String > multiLineDisplay ( ) <nl> + { <nl> + return Collections . emptyList ( ) ; <nl> + } <nl> + } ; <nl> + <nl> } <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / OptionReplication . java b / tools / stress / src / org / apache / cassandra / stress / settings / OptionReplication . java <nl> index 3b8e9d8 . . 88665ab 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / OptionReplication . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / OptionReplication . java <nl> @ @ - 22 , 86 + 22 , 42 @ @ package org . apache . cassandra . stress . settings ; <nl> <nl> <nl> import java . util . Arrays ; <nl> - import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> - import java . util . regex . Matcher ; <nl> - import java . util . regex . Pattern ; <nl> + <nl> + import com . google . common . base . Function ; <nl> <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> <nl> / * * <nl> * For specifying replication options <nl> * / <nl> - class OptionReplication extends Option <nl> + class OptionReplication extends OptionMulti <nl> { <nl> <nl> - private static final Pattern FULL = Pattern . compile ( " replication \ \ ( ( . * ) \ \ ) " , Pattern . CASE _ INSENSITIVE ) ; <nl> - private static final Pattern OPTION = Pattern . compile ( " ( [ ^ , = ] + ) = ( [ ^ , ] + ) " , Pattern . CASE _ INSENSITIVE ) ; <nl> + private final OptionSimple strategy = new OptionSimple ( " strategy = " , new StrategyAdapter ( ) , " org . apache . cassandra . locator . SimpleStrategy " , " The replication strategy to use " , false ) ; <nl> + private final OptionSimple factor = new OptionSimple ( " factor = " , " [ 0 - 9 ] + " , " 1 " , " The number of replicas " , false ) ; <nl> <nl> - private String strategy = " org . apache . cassandra . locator . SimpleStrategy " ; <nl> - private Map < String , String > options = new HashMap < > ( ) ; <nl> + public OptionReplication ( ) <nl> + { <nl> + super ( " replication " , " Define the replication strategy and any parameters " , true ) ; <nl> + } <nl> <nl> public String getStrategy ( ) <nl> { <nl> - return strategy ; <nl> + return strategy . value ( ) ; <nl> } <nl> <nl> public Map < String , String > getOptions ( ) <nl> { <nl> - if ( ! options . containsKey ( " replication _ factor " ) & & strategy . endsWith ( " SimpleStrategy " ) ) <nl> - options . put ( " replication _ factor " , " 1 " ) ; <nl> + Map < String , String > options = extraOptions ( ) ; <nl> + options . put ( " replication _ factor " , factor . value ( ) ) ; <nl> return options ; <nl> } <nl> <nl> - <nl> - @ Override <nl> - public boolean accept ( String param ) <nl> + protected List < ? extends Option > options ( ) <nl> { <nl> - Matcher m = FULL . matcher ( param ) ; <nl> - if ( ! m . matches ( ) ) <nl> - return false ; <nl> - String args = m . group ( 1 ) ; <nl> - m = OPTION . matcher ( args ) ; <nl> - int last = - 1 ; <nl> - while ( m . find ( ) ) <nl> - { <nl> - if ( m . start ( ) ! = last + 1 ) <nl> - throw new IllegalArgumentException ( " Invalid replication specification : " + param ) ; <nl> - last = m . end ( ) ; <nl> - String key = m . group ( 1 ) . toLowerCase ( ) ; <nl> - sw : switch ( key ) <nl> - { <nl> - case " factor " : <nl> - try <nl> - { <nl> - Integer . parseInt ( m . group ( 2 ) ) ; <nl> - } catch ( NumberFormatException e ) <nl> - { <nl> - throw new IllegalArgumentException ( " Invalid replication factor : " + param ) ; <nl> - } <nl> - options . put ( " replication _ factor " , m . group ( 2 ) ) ; <nl> - break ; <nl> - case " strategy " : <nl> - for ( String name : new String [ ] { m . group ( 2 ) , " org . apache . cassandra . locator . " + m . group ( 2 ) } ) <nl> - { <nl> - try <nl> - { <nl> - Class < ? > clazz = Class . forName ( name ) ; <nl> - if ( ! AbstractReplicationStrategy . class . isAssignableFrom ( clazz ) ) <nl> - throw new RuntimeException ( ) ; <nl> - strategy = name ; <nl> - break sw ; <nl> - } catch ( Exception _ ) <nl> - { <nl> - } <nl> - } <nl> - throw new IllegalArgumentException ( " Invalid replication strategy : " + param ) ; <nl> - default : <nl> - <nl> - } <nl> - } <nl> - return true ; <nl> + return Arrays . asList ( strategy , factor ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 110 , 26 + 66 , 28 @ @ class OptionReplication extends Option <nl> return true ; <nl> } <nl> <nl> - @ Override <nl> - public String shortDisplay ( ) <nl> - { <nl> - return " replication ( ? ) " ; <nl> - } <nl> - <nl> - @ Override <nl> - public String longDisplay ( ) <nl> + private static final class StrategyAdapter implements Function < String , String > <nl> { <nl> - return " replication ( factor = ? , strategy = ? , < option1 > = ? , . . . ) " ; <nl> - } <nl> - <nl> - @ Override <nl> - public List < String > multiLineDisplay ( ) <nl> - { <nl> - return Arrays . asList ( <nl> - GroupedOptions . formatMultiLine ( " factor = ? " , " The replication factor to use ( default 1 ) " ) , <nl> - GroupedOptions . formatMultiLine ( " strategy = ? " , " The replication strategy to use ( default SimpleStrategy ) " ) , <nl> - GroupedOptions . formatMultiLine ( " option = ? " , " Arbitrary replication strategy options " ) <nl> - ) ; <nl> + public String apply ( String name ) <nl> + { <nl> + String strategy = null ; <nl> + for ( String fullname : new String [ ] { name , " org . apache . cassandra . locator . " + name } ) <nl> + { <nl> + try <nl> + { <nl> + Class < ? > clazz = Class . forName ( fullname ) ; <nl> + if ( ! AbstractReplicationStrategy . class . isAssignableFrom ( clazz ) ) <nl> + throw new RuntimeException ( ) ; <nl> + strategy = fullname ; <nl> + break ; <nl> + } catch ( Exception _ ) <nl> + { <nl> + } <nl> + } <nl> + if ( strategy = = null ) <nl> + throw new IllegalArgumentException ( " Invalid replication strategy : " + name ) ; <nl> + return strategy ; <nl> + } <nl> } <nl> <nl> } <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / OptionSimple . java b / tools / stress / src / org / apache / cassandra / stress / settings / OptionSimple . java <nl> index 4c80dba . . 2a9738a 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / OptionSimple . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / OptionSimple . java <nl> @ @ - 25 , 35 + 25 , 58 @ @ import java . util . Collections ; <nl> import java . util . List ; <nl> import java . util . regex . Pattern ; <nl> <nl> + import com . google . common . base . Function ; <nl> + <nl> / * * <nl> * For parsing a simple ( sub ) option for a command / major option <nl> * / <nl> class OptionSimple extends Option <nl> { <nl> <nl> - final String displayPrefix ; <nl> - final Pattern matchPrefix ; <nl> - final String defaultValue ; <nl> - final Pattern pattern ; <nl> - final String description ; <nl> - final boolean required ; <nl> - String value ; <nl> + private final String displayPrefix ; <nl> + private final Pattern matchPrefix ; <nl> + private final String defaultValue ; <nl> + private final Function < String , String > valueAdapter ; <nl> + private final String description ; <nl> + private final boolean required ; <nl> + private String value ; <nl> + <nl> + private static final class ValueMatcher implements Function < String , String > <nl> + { <nl> + final Pattern pattern ; <nl> + private ValueMatcher ( Pattern pattern ) <nl> + { <nl> + this . pattern = pattern ; <nl> + } <nl> + public String apply ( String s ) <nl> + { <nl> + if ( ! pattern . matcher ( s ) . matches ( ) ) <nl> + throw new IllegalArgumentException ( " Invalid value " + s + " ; must match pattern " + pattern ) ; <nl> + return s ; <nl> + } <nl> + } <nl> <nl> public OptionSimple ( String prefix , String valuePattern , String defaultValue , String description , boolean required ) <nl> { <nl> - this . displayPrefix = prefix ; <nl> - this . matchPrefix = Pattern . compile ( Pattern . quote ( prefix ) , Pattern . CASE _ INSENSITIVE ) ; <nl> - this . pattern = Pattern . compile ( valuePattern , Pattern . CASE _ INSENSITIVE ) ; <nl> - this . defaultValue = defaultValue ; <nl> - this . description = description ; <nl> - this . required = required ; <nl> + this ( prefix , Pattern . compile ( Pattern . quote ( prefix ) , Pattern . CASE _ INSENSITIVE ) , <nl> + Pattern . compile ( valuePattern , Pattern . CASE _ INSENSITIVE ) , defaultValue , description , required ) ; <nl> + } <nl> + <nl> + public OptionSimple ( String prefix , Function < String , String > valueAdapter , String defaultValue , String description , boolean required ) <nl> + { <nl> + this ( prefix , Pattern . compile ( Pattern . quote ( prefix ) , Pattern . CASE _ INSENSITIVE ) , valueAdapter , defaultValue , description , required ) ; <nl> } <nl> <nl> public OptionSimple ( String displayPrefix , Pattern matchPrefix , Pattern valuePattern , String defaultValue , String description , boolean required ) <nl> { <nl> + this ( displayPrefix , matchPrefix , new ValueMatcher ( valuePattern ) , defaultValue , description , required ) ; <nl> + } <nl> + <nl> + public OptionSimple ( String displayPrefix , Pattern matchPrefix , Function < String , String > valueAdapter , String defaultValue , String description , boolean required ) <nl> + { <nl> this . displayPrefix = displayPrefix ; <nl> this . matchPrefix = matchPrefix ; <nl> - this . pattern = valuePattern ; <nl> + this . valueAdapter = valueAdapter ; <nl> this . defaultValue = defaultValue ; <nl> this . description = description ; <nl> this . required = required ; <nl> @ @ - 81 , 9 + 104 , 8 @ @ class OptionSimple extends Option <nl> if ( value ! = null ) <nl> throw new IllegalArgumentException ( " Suboption " + displayPrefix + " has been specified more than once " ) ; <nl> String v = param . substring ( displayPrefix . length ( ) ) ; <nl> - if ( ! pattern . matcher ( v ) . matches ( ) ) <nl> - throw new IllegalArgumentException ( " Invalid option " + param + " ; must match pattern " + pattern ) ; <nl> - value = v ; <nl> + value = valueAdapter . apply ( v ) ; <nl> + assert value ! = null ; <nl> return true ; <nl> } <nl> return false ; <nl> @ @ - 114 , 7 + 136 , 8 @ @ class OptionSimple extends Option <nl> <nl> public String longDisplay ( ) <nl> { <nl> - if ( description . equals ( " " ) & & defaultValue = = null & & pattern . pattern ( ) . equals ( " " ) ) <nl> + if ( description . equals ( " " ) & & defaultValue = = null <nl> + & & ( valueAdapter instanceof ValueMatcher & & ( ( ValueMatcher ) valueAdapter ) . pattern . pattern ( ) . equals ( " " ) ) ) <nl> return null ; <nl> StringBuilder sb = new StringBuilder ( ) ; <nl> sb . append ( displayPrefix ) ; <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommandMixed . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommandMixed . java <nl> index 289dd30 . . bce786a 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommandMixed . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommandMixed . java <nl> @ @ - 111 , 7 + 111 , 7 @ @ public class SettingsCommandMixed extends SettingsCommandMulti <nl> <nl> public Probabilities ( ) <nl> { <nl> - super ( " ratio " , " Specify the ratios for operations to perform ; e . g . ( reads = 2 , writes = 1 ) will perform 2 reads for each write " ) ; <nl> + super ( " ratio " , " Specify the ratios for operations to perform ; e . g . ( reads = 2 , writes = 1 ) will perform 2 reads for each write " , false ) ; <nl> OptionSimple [ ] ratios = new OptionSimple [ Command . values ( ) . length ] ; <nl> List < OptionSimple > grouping = new ArrayList < > ( ) ; <nl> for ( Command command : Command . values ( ) ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSchema . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSchema . java <nl> index e9b6d55 . . 5b5333c 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSchema . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSchema . java <nl> @ @ - 43 , 6 + 43 , 7 @ @ public class SettingsSchema implements Serializable <nl> private final boolean replicateOnWrite ; <nl> private final String compression ; <nl> private final String compactionStrategy ; <nl> + private final Map < String , String > compactionStrategyOptions ; <nl> public final String keyspace ; <nl> public final String columnFamily ; <nl> <nl> @ @ - 56 , 26 + 57 , 12 @ @ public class SettingsSchema implements Serializable <nl> else <nl> indexType = null ; <nl> compression = options . compression . value ( ) ; <nl> - compactionStrategy = options . compactionStrategy . value ( ) ; <nl> - if ( compactionStrategy ! = null ) <nl> - { <nl> - try <nl> - { <nl> - CFMetaData . createCompactionStrategy ( compactionStrategy ) ; <nl> - } catch ( ConfigurationException e ) <nl> - { <nl> - throw new IllegalArgumentException ( " Invalid compaction strategy : " + compactionStrategy ) ; <nl> - } <nl> - } <nl> + compactionStrategy = options . compaction . getStrategy ( ) ; <nl> + compactionStrategyOptions = options . compaction . getOptions ( ) ; <nl> keyspace = options . keyspace . value ( ) ; <nl> columnFamily = options . columnFamily . value ( ) ; <nl> } <nl> <nl> - private void createKeyspacesCql3 ( StressSettings settings ) <nl> - { <nl> - / / settings . getJavaDriverClient ( ) . execute ( " create table Standard1 " ) <nl> - } <nl> - <nl> public void createKeySpaces ( StressSettings settings ) <nl> { <nl> createKeySpacesThrift ( settings ) ; <nl> @ @ - 152 , 9 + 139 , 16 @ @ public class SettingsSchema implements Serializable <nl> superCfDef . setCompaction _ strategy ( compactionStrategy ) ; <nl> counterCfDef . setCompaction _ strategy ( compactionStrategy ) ; <nl> counterSuperCfDef . setCompaction _ strategy ( compactionStrategy ) ; <nl> + if ( ! compactionStrategyOptions . isEmpty ( ) ) <nl> + { <nl> + standardCfDef . setCompaction _ strategy _ options ( compactionStrategyOptions ) ; <nl> + superCfDef . setCompaction _ strategy _ options ( compactionStrategyOptions ) ; <nl> + counterCfDef . setCompaction _ strategy _ options ( compactionStrategyOptions ) ; <nl> + counterSuperCfDef . setCompaction _ strategy _ options ( compactionStrategyOptions ) ; <nl> + } <nl> } <nl> <nl> - ksdef . setCf _ defs ( new ArrayList < CfDef > ( Arrays . asList ( standardCfDef , superCfDef , counterCfDef , counterSuperCfDef ) ) ) ; <nl> + ksdef . setCf _ defs ( new ArrayList < > ( Arrays . asList ( standardCfDef , superCfDef , counterCfDef , counterSuperCfDef ) ) ) ; <nl> <nl> Cassandra . Client client = settings . getRawThriftClient ( false ) ; <nl> <nl> @ @ - 205 , 17 + 199 , 17 @ @ public class SettingsSchema implements Serializable <nl> private static final class Options extends GroupedOptions <nl> { <nl> final OptionReplication replication = new OptionReplication ( ) ; <nl> + final OptionCompaction compaction = new OptionCompaction ( ) ; <nl> final OptionSimple index = new OptionSimple ( " index = " , " KEYS | CUSTOM | COMPOSITES " , null , " Type of index to create on needed column families ( KEYS ) " , false ) ; <nl> final OptionSimple keyspace = new OptionSimple ( " keyspace = " , " . * " , " Keyspace1 " , " The keyspace name to use " , false ) ; <nl> final OptionSimple columnFamily = new OptionSimple ( " columnfamily = " , " . * " , " Standard1 " , " The column family name to use " , false ) ; <nl> - final OptionSimple compactionStrategy = new OptionSimple ( " compaction = " , " . * " , null , " The compaction strategy to use " , false ) ; <nl> final OptionSimple noReplicateOnWrite = new OptionSimple ( " no - replicate - on - write " , " " , null , " Set replicate _ on _ write to false for counters . Only counter add with CL = ONE will work " , false ) ; <nl> final OptionSimple compression = new OptionSimple ( " compression = " , " . * " , null , " Specify the compression to use for sstable , default : no compression " , false ) ; <nl> <nl> @ Override <nl> public List < ? extends Option > options ( ) <nl> { <nl> - return Arrays . asList ( replication , index , keyspace , columnFamily , compactionStrategy , noReplicateOnWrite , compression ) ; <nl> + return Arrays . asList ( replication , index , keyspace , columnFamily , compaction , noReplicateOnWrite , compression ) ; <nl> } <nl> } <nl>
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 607e2dc . . 06331ad 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 0 - beta2 
 + * Allow cassandra - stress to set compaction strategy options ( CASSANDRA - 6451 ) 
 * Add broadcast _ rpc _ address option to cassandra . yaml ( CASSANDRA - 5899 ) 
 * Auto reload GossipingPropertyFileSnitch config ( CASSANDRA - 5897 ) 
 * Fix overflow of memtable _ total _ space _ in _ mb ( CASSANDRA - 6573 ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / OptionCompaction . java b / tools / stress / src / org / apache / cassandra / stress / settings / OptionCompaction . java 
 new file mode 100644 
 index 0000000 . . da74e43 
 - - - / dev / null 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / OptionCompaction . java 
 @ @ - 0 , 0 + 1 , 62 @ @ 
 + package org . apache . cassandra . stress . settings ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + 
 + import com . google . common . base . Function ; 
 + 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + 
 + / * * 
 + * For specifying replication options 
 + * / 
 + class OptionCompaction extends OptionMulti 
 + { 
 + 
 + private final OptionSimple strategy = new OptionSimple ( " strategy = " , new StrategyAdapter ( ) , null , " The compaction strategy to use " , false ) ; 
 + 
 + public OptionCompaction ( ) 
 + { 
 + super ( " compaction " , " Define the compaction strategy and any parameters " , true ) ; 
 + } 
 + 
 + public String getStrategy ( ) 
 + { 
 + return strategy . value ( ) ; 
 + } 
 + 
 + public Map < String , String > getOptions ( ) 
 + { 
 + return extraOptions ( ) ; 
 + } 
 + 
 + protected List < ? extends Option > options ( ) 
 + { 
 + return Arrays . asList ( strategy ) ; 
 + } 
 + 
 + @ Override 
 + public boolean happy ( ) 
 + { 
 + return true ; 
 + } 
 + 
 + private static final class StrategyAdapter implements Function < String , String > 
 + { 
 + 
 + public String apply ( String name ) 
 + { 
 + try 
 + { 
 + CFMetaData . createCompactionStrategy ( name ) ; 
 + } catch ( ConfigurationException e ) 
 + { 
 + throw new IllegalArgumentException ( " Invalid compaction strategy : " + name ) ; 
 + } 
 + return name ; 
 + } 
 + } 
 + 
 + } 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / OptionMulti . java b / tools / stress / src / org / apache / cassandra / stress / settings / OptionMulti . java 
 index 1901587 . . 7074dc6 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / OptionMulti . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / OptionMulti . java 
 @ @ - 22 , 7 + 22 , 11 @ @ package org . apache . cassandra . stress . settings ; 
 
 
 import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . LinkedHashMap ; 
 import java . util . List ; 
 + import java . util . Map ; 
 import java . util . regex . Matcher ; 
 import java . util . regex . Pattern ; 
 
 @ @ - 39 , 21 + 43 , 34 @ @ abstract class OptionMulti extends Option 
 @ Override 
 public List < ? extends Option > options ( ) 
 { 
 - return OptionMulti . this . options ( ) ; 
 + if ( collectAsMap = = null ) 
 + return OptionMulti . this . options ( ) ; 
 + 
 + List < Option > options = new ArrayList < > ( OptionMulti . this . options ( ) ) ; 
 + options . add ( collectAsMap ) ; 
 + return options ; 
 } 
 } 
 
 protected abstract List < ? extends Option > options ( ) ; 
 
 + public Map < String , String > extraOptions ( ) 
 + { 
 + return collectAsMap = = null ? new HashMap < String , String > ( ) : collectAsMap . options ; 
 + } 
 + 
 private final String name ; 
 private final Pattern pattern ; 
 private final String description ; 
 private final Delegate delegate = new Delegate ( ) ; 
 - public OptionMulti ( String name , String description ) 
 + private final CollectAsMap collectAsMap ; 
 + 
 + public OptionMulti ( String name , String description , boolean collectExtraOptionsInMap ) 
 { 
 this . name = name ; 
 pattern = Pattern . compile ( name + " \ \ ( ( . * ) \ \ ) " , Pattern . CASE _ INSENSITIVE ) ; 
 this . description = description ; 
 + this . collectAsMap = collectExtraOptionsInMap ? new CollectAsMap ( ) : null ; 
 } 
 
 @ Override 
 @ @ - 70 , 7 + 87 , 10 @ @ abstract class OptionMulti extends Option 
 throw new IllegalArgumentException ( " Invalid " + name + " specification : " + param ) ; 
 last = m . end ( ) ; 
 if ( ! delegate . accept ( m . group ( ) ) ) 
 + { 
 + 
 throw new IllegalArgumentException ( " Invalid " + name + " specification : " + m . group ( ) ) ; 
 + } 
 } 
 return true ; 
 } 
 @ @ - 125 , 4 + 145 , 42 @ @ abstract class OptionMulti extends Option 
 return delegate . happy ( ) ; 
 } 
 
 + private static final class CollectAsMap extends Option 
 + { 
 + 
 + static final String description = " Extra options " ; 
 + Map < String , String > options = new LinkedHashMap < > ( ) ; 
 + 
 + boolean accept ( String param ) 
 + { 
 + String [ ] args = param . split ( " = " ) ; 
 + if ( args . length = = 2 & & args [ 1 ] . length ( ) > 0 & & args [ 0 ] . length ( ) > 0 ) 
 + { 
 + options . put ( args [ 0 ] , args [ 1 ] ) ; 
 + return true ; 
 + } 
 + return false ; 
 + } 
 + 
 + boolean happy ( ) 
 + { 
 + return true ; 
 + } 
 + 
 + String shortDisplay ( ) 
 + { 
 + return " [ < option 1 . . N > = ? ] " ; 
 + } 
 + 
 + String longDisplay ( ) 
 + { 
 + return GroupedOptions . formatLong ( shortDisplay ( ) , description ) ; 
 + } 
 + 
 + List < String > multiLineDisplay ( ) 
 + { 
 + return Collections . emptyList ( ) ; 
 + } 
 + } ; 
 + 
 } 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / OptionReplication . java b / tools / stress / src / org / apache / cassandra / stress / settings / OptionReplication . java 
 index 3b8e9d8 . . 88665ab 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / OptionReplication . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / OptionReplication . java 
 @ @ - 22 , 86 + 22 , 42 @ @ package org . apache . cassandra . stress . settings ; 
 
 
 import java . util . Arrays ; 
 - import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 - import java . util . regex . Matcher ; 
 - import java . util . regex . Pattern ; 
 + 
 + import com . google . common . base . Function ; 
 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 
 / * * 
 * For specifying replication options 
 * / 
 - class OptionReplication extends Option 
 + class OptionReplication extends OptionMulti 
 { 
 
 - private static final Pattern FULL = Pattern . compile ( " replication \ \ ( ( . * ) \ \ ) " , Pattern . CASE _ INSENSITIVE ) ; 
 - private static final Pattern OPTION = Pattern . compile ( " ( [ ^ , = ] + ) = ( [ ^ , ] + ) " , Pattern . CASE _ INSENSITIVE ) ; 
 + private final OptionSimple strategy = new OptionSimple ( " strategy = " , new StrategyAdapter ( ) , " org . apache . cassandra . locator . SimpleStrategy " , " The replication strategy to use " , false ) ; 
 + private final OptionSimple factor = new OptionSimple ( " factor = " , " [ 0 - 9 ] + " , " 1 " , " The number of replicas " , false ) ; 
 
 - private String strategy = " org . apache . cassandra . locator . SimpleStrategy " ; 
 - private Map < String , String > options = new HashMap < > ( ) ; 
 + public OptionReplication ( ) 
 + { 
 + super ( " replication " , " Define the replication strategy and any parameters " , true ) ; 
 + } 
 
 public String getStrategy ( ) 
 { 
 - return strategy ; 
 + return strategy . value ( ) ; 
 } 
 
 public Map < String , String > getOptions ( ) 
 { 
 - if ( ! options . containsKey ( " replication _ factor " ) & & strategy . endsWith ( " SimpleStrategy " ) ) 
 - options . put ( " replication _ factor " , " 1 " ) ; 
 + Map < String , String > options = extraOptions ( ) ; 
 + options . put ( " replication _ factor " , factor . value ( ) ) ; 
 return options ; 
 } 
 
 - 
 - @ Override 
 - public boolean accept ( String param ) 
 + protected List < ? extends Option > options ( ) 
 { 
 - Matcher m = FULL . matcher ( param ) ; 
 - if ( ! m . matches ( ) ) 
 - return false ; 
 - String args = m . group ( 1 ) ; 
 - m = OPTION . matcher ( args ) ; 
 - int last = - 1 ; 
 - while ( m . find ( ) ) 
 - { 
 - if ( m . start ( ) ! = last + 1 ) 
 - throw new IllegalArgumentException ( " Invalid replication specification : " + param ) ; 
 - last = m . end ( ) ; 
 - String key = m . group ( 1 ) . toLowerCase ( ) ; 
 - sw : switch ( key ) 
 - { 
 - case " factor " : 
 - try 
 - { 
 - Integer . parseInt ( m . group ( 2 ) ) ; 
 - } catch ( NumberFormatException e ) 
 - { 
 - throw new IllegalArgumentException ( " Invalid replication factor : " + param ) ; 
 - } 
 - options . put ( " replication _ factor " , m . group ( 2 ) ) ; 
 - break ; 
 - case " strategy " : 
 - for ( String name : new String [ ] { m . group ( 2 ) , " org . apache . cassandra . locator . " + m . group ( 2 ) } ) 
 - { 
 - try 
 - { 
 - Class < ? > clazz = Class . forName ( name ) ; 
 - if ( ! AbstractReplicationStrategy . class . isAssignableFrom ( clazz ) ) 
 - throw new RuntimeException ( ) ; 
 - strategy = name ; 
 - break sw ; 
 - } catch ( Exception _ ) 
 - { 
 - } 
 - } 
 - throw new IllegalArgumentException ( " Invalid replication strategy : " + param ) ; 
 - default : 
 - 
 - } 
 - } 
 - return true ; 
 + return Arrays . asList ( strategy , factor ) ; 
 } 
 
 @ Override 
 @ @ - 110 , 26 + 66 , 28 @ @ class OptionReplication extends Option 
 return true ; 
 } 
 
 - @ Override 
 - public String shortDisplay ( ) 
 - { 
 - return " replication ( ? ) " ; 
 - } 
 - 
 - @ Override 
 - public String longDisplay ( ) 
 + private static final class StrategyAdapter implements Function < String , String > 
 { 
 - return " replication ( factor = ? , strategy = ? , < option1 > = ? , . . . ) " ; 
 - } 
 - 
 - @ Override 
 - public List < String > multiLineDisplay ( ) 
 - { 
 - return Arrays . asList ( 
 - GroupedOptions . formatMultiLine ( " factor = ? " , " The replication factor to use ( default 1 ) " ) , 
 - GroupedOptions . formatMultiLine ( " strategy = ? " , " The replication strategy to use ( default SimpleStrategy ) " ) , 
 - GroupedOptions . formatMultiLine ( " option = ? " , " Arbitrary replication strategy options " ) 
 - ) ; 
 + public String apply ( String name ) 
 + { 
 + String strategy = null ; 
 + for ( String fullname : new String [ ] { name , " org . apache . cassandra . locator . " + name } ) 
 + { 
 + try 
 + { 
 + Class < ? > clazz = Class . forName ( fullname ) ; 
 + if ( ! AbstractReplicationStrategy . class . isAssignableFrom ( clazz ) ) 
 + throw new RuntimeException ( ) ; 
 + strategy = fullname ; 
 + break ; 
 + } catch ( Exception _ ) 
 + { 
 + } 
 + } 
 + if ( strategy = = null ) 
 + throw new IllegalArgumentException ( " Invalid replication strategy : " + name ) ; 
 + return strategy ; 
 + } 
 } 
 
 } 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / OptionSimple . java b / tools / stress / src / org / apache / cassandra / stress / settings / OptionSimple . java 
 index 4c80dba . . 2a9738a 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / OptionSimple . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / OptionSimple . java 
 @ @ - 25 , 35 + 25 , 58 @ @ import java . util . Collections ; 
 import java . util . List ; 
 import java . util . regex . Pattern ; 
 
 + import com . google . common . base . Function ; 
 + 
 / * * 
 * For parsing a simple ( sub ) option for a command / major option 
 * / 
 class OptionSimple extends Option 
 { 
 
 - final String displayPrefix ; 
 - final Pattern matchPrefix ; 
 - final String defaultValue ; 
 - final Pattern pattern ; 
 - final String description ; 
 - final boolean required ; 
 - String value ; 
 + private final String displayPrefix ; 
 + private final Pattern matchPrefix ; 
 + private final String defaultValue ; 
 + private final Function < String , String > valueAdapter ; 
 + private final String description ; 
 + private final boolean required ; 
 + private String value ; 
 + 
 + private static final class ValueMatcher implements Function < String , String > 
 + { 
 + final Pattern pattern ; 
 + private ValueMatcher ( Pattern pattern ) 
 + { 
 + this . pattern = pattern ; 
 + } 
 + public String apply ( String s ) 
 + { 
 + if ( ! pattern . matcher ( s ) . matches ( ) ) 
 + throw new IllegalArgumentException ( " Invalid value " + s + " ; must match pattern " + pattern ) ; 
 + return s ; 
 + } 
 + } 
 
 public OptionSimple ( String prefix , String valuePattern , String defaultValue , String description , boolean required ) 
 { 
 - this . displayPrefix = prefix ; 
 - this . matchPrefix = Pattern . compile ( Pattern . quote ( prefix ) , Pattern . CASE _ INSENSITIVE ) ; 
 - this . pattern = Pattern . compile ( valuePattern , Pattern . CASE _ INSENSITIVE ) ; 
 - this . defaultValue = defaultValue ; 
 - this . description = description ; 
 - this . required = required ; 
 + this ( prefix , Pattern . compile ( Pattern . quote ( prefix ) , Pattern . CASE _ INSENSITIVE ) , 
 + Pattern . compile ( valuePattern , Pattern . CASE _ INSENSITIVE ) , defaultValue , description , required ) ; 
 + } 
 + 
 + public OptionSimple ( String prefix , Function < String , String > valueAdapter , String defaultValue , String description , boolean required ) 
 + { 
 + this ( prefix , Pattern . compile ( Pattern . quote ( prefix ) , Pattern . CASE _ INSENSITIVE ) , valueAdapter , defaultValue , description , required ) ; 
 } 
 
 public OptionSimple ( String displayPrefix , Pattern matchPrefix , Pattern valuePattern , String defaultValue , String description , boolean required ) 
 { 
 + this ( displayPrefix , matchPrefix , new ValueMatcher ( valuePattern ) , defaultValue , description , required ) ; 
 + } 
 + 
 + public OptionSimple ( String displayPrefix , Pattern matchPrefix , Function < String , String > valueAdapter , String defaultValue , String description , boolean required ) 
 + { 
 this . displayPrefix = displayPrefix ; 
 this . matchPrefix = matchPrefix ; 
 - this . pattern = valuePattern ; 
 + this . valueAdapter = valueAdapter ; 
 this . defaultValue = defaultValue ; 
 this . description = description ; 
 this . required = required ; 
 @ @ - 81 , 9 + 104 , 8 @ @ class OptionSimple extends Option 
 if ( value ! = null ) 
 throw new IllegalArgumentException ( " Suboption " + displayPrefix + " has been specified more than once " ) ; 
 String v = param . substring ( displayPrefix . length ( ) ) ; 
 - if ( ! pattern . matcher ( v ) . matches ( ) ) 
 - throw new IllegalArgumentException ( " Invalid option " + param + " ; must match pattern " + pattern ) ; 
 - value = v ; 
 + value = valueAdapter . apply ( v ) ; 
 + assert value ! = null ; 
 return true ; 
 } 
 return false ; 
 @ @ - 114 , 7 + 136 , 8 @ @ class OptionSimple extends Option 
 
 public String longDisplay ( ) 
 { 
 - if ( description . equals ( " " ) & & defaultValue = = null & & pattern . pattern ( ) . equals ( " " ) ) 
 + if ( description . equals ( " " ) & & defaultValue = = null 
 + & & ( valueAdapter instanceof ValueMatcher & & ( ( ValueMatcher ) valueAdapter ) . pattern . pattern ( ) . equals ( " " ) ) ) 
 return null ; 
 StringBuilder sb = new StringBuilder ( ) ; 
 sb . append ( displayPrefix ) ; 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommandMixed . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommandMixed . java 
 index 289dd30 . . bce786a 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommandMixed . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsCommandMixed . java 
 @ @ - 111 , 7 + 111 , 7 @ @ public class SettingsCommandMixed extends SettingsCommandMulti 
 
 public Probabilities ( ) 
 { 
 - super ( " ratio " , " Specify the ratios for operations to perform ; e . g . ( reads = 2 , writes = 1 ) will perform 2 reads for each write " ) ; 
 + super ( " ratio " , " Specify the ratios for operations to perform ; e . g . ( reads = 2 , writes = 1 ) will perform 2 reads for each write " , false ) ; 
 OptionSimple [ ] ratios = new OptionSimple [ Command . values ( ) . length ] ; 
 List < OptionSimple > grouping = new ArrayList < > ( ) ; 
 for ( Command command : Command . values ( ) ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSchema . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSchema . java 
 index e9b6d55 . . 5b5333c 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSchema . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsSchema . java 
 @ @ - 43 , 6 + 43 , 7 @ @ public class SettingsSchema implements Serializable 
 private final boolean replicateOnWrite ; 
 private final String compression ; 
 private final String compactionStrategy ; 
 + private final Map < String , String > compactionStrategyOptions ; 
 public final String keyspace ; 
 public final String columnFamily ; 
 
 @ @ - 56 , 26 + 57 , 12 @ @ public class SettingsSchema implements Serializable 
 else 
 indexType = null ; 
 compression = options . compression . value ( ) ; 
 - compactionStrategy = options . compactionStrategy . value ( ) ; 
 - if ( compactionStrategy ! = null ) 
 - { 
 - try 
 - { 
 - CFMetaData . createCompactionStrategy ( compactionStrategy ) ; 
 - } catch ( ConfigurationException e ) 
 - { 
 - throw new IllegalArgumentException ( " Invalid compaction strategy : " + compactionStrategy ) ; 
 - } 
 - } 
 + compactionStrategy = options . compaction . getStrategy ( ) ; 
 + compactionStrategyOptions = options . compaction . getOptions ( ) ; 
 keyspace = options . keyspace . value ( ) ; 
 columnFamily = options . columnFamily . value ( ) ; 
 } 
 
 - private void createKeyspacesCql3 ( StressSettings settings ) 
 - { 
 - / / settings . getJavaDriverClient ( ) . execute ( " create table Standard1 " ) 
 - } 
 - 
 public void createKeySpaces ( StressSettings settings ) 
 { 
 createKeySpacesThrift ( settings ) ; 
 @ @ - 152 , 9 + 139 , 16 @ @ public class SettingsSchema implements Serializable 
 superCfDef . setCompaction _ strategy ( compactionStrategy ) ; 
 counterCfDef . setCompaction _ strategy ( compactionStrategy ) ; 
 counterSuperCfDef . setCompaction _ strategy ( compactionStrategy ) ; 
 + if ( ! compactionStrategyOptions . isEmpty ( ) ) 
 + { 
 + standardCfDef . setCompaction _ strategy _ options ( compactionStrategyOptions ) ; 
 + superCfDef . setCompaction _ strategy _ options ( compactionStrategyOptions ) ; 
 + counterCfDef . setCompaction _ strategy _ options ( compactionStrategyOptions ) ; 
 + counterSuperCfDef . setCompaction _ strategy _ options ( compactionStrategyOptions ) ; 
 + } 
 } 
 
 - ksdef . setCf _ defs ( new ArrayList < CfDef > ( Arrays . asList ( standardCfDef , superCfDef , counterCfDef , counterSuperCfDef ) ) ) ; 
 + ksdef . setCf _ defs ( new ArrayList < > ( Arrays . asList ( standardCfDef , superCfDef , counterCfDef , counterSuperCfDef ) ) ) ; 
 
 Cassandra . Client client = settings . getRawThriftClient ( false ) ; 
 
 @ @ - 205 , 17 + 199 , 17 @ @ public class SettingsSchema implements Serializable 
 private static final class Options extends GroupedOptions 
 { 
 final OptionReplication replication = new OptionReplication ( ) ; 
 + final OptionCompaction compaction = new OptionCompaction ( ) ; 
 final OptionSimple index = new OptionSimple ( " index = " , " KEYS | CUSTOM | COMPOSITES " , null , " Type of index to create on needed column families ( KEYS ) " , false ) ; 
 final OptionSimple keyspace = new OptionSimple ( " keyspace = " , " . * " , " Keyspace1 " , " The keyspace name to use " , false ) ; 
 final OptionSimple columnFamily = new OptionSimple ( " columnfamily = " , " . * " , " Standard1 " , " The column family name to use " , false ) ; 
 - final OptionSimple compactionStrategy = new OptionSimple ( " compaction = " , " . * " , null , " The compaction strategy to use " , false ) ; 
 final OptionSimple noReplicateOnWrite = new OptionSimple ( " no - replicate - on - write " , " " , null , " Set replicate _ on _ write to false for counters . Only counter add with CL = ONE will work " , false ) ; 
 final OptionSimple compression = new OptionSimple ( " compression = " , " . * " , null , " Specify the compression to use for sstable , default : no compression " , false ) ; 
 
 @ Override 
 public List < ? extends Option > options ( ) 
 { 
 - return Arrays . asList ( replication , index , keyspace , columnFamily , compactionStrategy , noReplicateOnWrite , compression ) ; 
 + return Arrays . asList ( replication , index , keyspace , columnFamily , compaction , noReplicateOnWrite , compression ) ; 
 } 
 } 


NEAREST DIFF:
ELIMINATEDSENTENCE
