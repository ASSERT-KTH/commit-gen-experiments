BLEU SCORE: 0.015821934551541402

TEST MSG: Fix NPE in ComponentOfSlice . isEQ ( )
GENERATED MSG: treat expired columns as deleted . patch by Sylvain Lebresne ; reviewed by jbellis for CASSANDRA - 1539

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d12a8f8 . . cbf9ab1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 10 <nl> + * Fix NPE in ComponentOfSlice . isEQ ( ) ( CASSANDRA - 12706 ) <nl> * Fix failure in LogTransactionTest ( CASSANDRA - 12632 ) <nl> * Fix potentially incomplete non - frozen UDT values when querying with the <nl> full primary key specified ( CASSANDRA - 12605 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Slices . java b / src / java / org / apache / cassandra / db / Slices . java <nl> index bb354a1 . . 269386e 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Slices . java <nl> + + + b / src / java / org / apache / cassandra / db / Slices . java <nl> @ @ - 745 , 7 + 745 , 7 @ @ public abstract class Slices implements Iterable < Slice > <nl> <nl> public boolean isEQ ( ) <nl> { <nl> - return startValue . equals ( endValue ) ; <nl> + return Objects . equals ( startValue , endValue ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java <nl> index b5d8159 . . 7f59e2f 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java <nl> @ @ - 215 , 4 + 215 , 25 @ @ public class SinglePartitionSliceCommandTest <nl> checkForS ( pi ) ; <nl> } <nl> } <nl> + <nl> + @ Test <nl> + public void toCQLStringIsSafeToCall ( ) throws IOException <nl> + { <nl> + DecoratedKey key = cfm . decorateKey ( ByteBufferUtil . bytes ( " k1 " ) ) ; <nl> + <nl> + ColumnFilter columnFilter = ColumnFilter . selection ( PartitionColumns . of ( s ) ) ; <nl> + Slice slice = Slice . make ( Slice . Bound . BOTTOM , Slice . Bound . inclusiveEndOf ( ByteBufferUtil . bytes ( " i1 " ) ) ) ; <nl> + ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter ( Slices . with ( cfm . comparator , slice ) , false ) ; <nl> + ReadCommand cmd = new SinglePartitionReadCommand ( false , MessagingService . VERSION _ 30 , true , cfm , <nl> + FBUtilities . nowInSeconds ( ) , <nl> + columnFilter , <nl> + RowFilter . NONE , <nl> + DataLimits . NONE , <nl> + key , <nl> + sliceFilter ) ; <nl> + <nl> + String ret = cmd . toCQLString ( ) ; <nl> + Assert . assertNotNull ( ret ) ; <nl> + Assert . assertFalse ( ret . isEmpty ( ) ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 85256bb . . f73d999 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 87 , 6 + 87 , 7 @ @ <nl> * Close intra - node sockets when connection is broken ( CASSANDRA - 1528 ) <nl> * RPM packaging spec file ( CASSANDRA - 786 ) <nl> * weighted request scheduler ( CASSANDRA - 1485 ) <nl> + * treat expired columns as deleted ( CASSANDRA - 1539 ) <nl> <nl> <nl> 0 . 7 - beta1 <nl> diff - - git a / src / java / org / apache / cassandra / db / ExpiringColumn . java b / src / java / org / apache / cassandra / db / ExpiringColumn . java <nl> index 12f7801 . . d9813ff 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ExpiringColumn . java <nl> + + + b / src / java / org / apache / cassandra / db / ExpiringColumn . java <nl> @ @ - 113 , 4 + 113 , 17 @ @ public class ExpiringColumn extends Column <nl> sb . append ( timeToLive ) ; <nl> return sb . toString ( ) ; <nl> } <nl> + <nl> + @ Override <nl> + public IClock getMarkedForDeleteAt ( ) <nl> + { <nl> + if ( isMarkedForDelete ( ) ) <nl> + { <nl> + return clock ; <nl> + } <nl> + else <nl> + { <nl> + throw new IllegalStateException ( " column is not marked for delete " ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / RowTest . java b / test / unit / org / apache / cassandra / db / RowTest . java <nl> index 2e028d1 . . f23c68d 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RowTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / RowTest . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import org . apache . cassandra . SchemaLoader ; <nl> import org . junit . Test ; <nl> <nl> import static junit . framework . Assert . assertEquals ; <nl> + import static junit . framework . Assert . fail ; <nl> import org . apache . cassandra . db . marshal . AsciiType ; <nl> import static org . apache . cassandra . Util . column ; <nl> <nl> @ @ - 71 , 4 + 72 , 24 @ @ public class RowTest extends SchemaLoader <nl> assert Arrays . equals ( cf1 . getColumn ( " one " . getBytes ( ) ) . value ( ) , " B " . getBytes ( ) ) ; <nl> assert Arrays . equals ( cf1 . getColumn ( " two " . getBytes ( ) ) . value ( ) , " C " . getBytes ( ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testExpiringColumnExpiration ( ) <nl> + { <nl> + Column c = new ExpiringColumn ( " one " . getBytes ( ) , " A " . getBytes ( ) , new TimestampClock ( 0 ) , 1 ) ; <nl> + assert ! c . isMarkedForDelete ( ) ; <nl> + <nl> + try <nl> + { <nl> + / / Because we keep the local deletion time with a precision of a <nl> + / / second , we could have to wait 2 seconds in worst case scenario . <nl> + Thread . sleep ( 2000 ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + fail ( " Cannot test column expiration if you wake me up too early " ) ; <nl> + } <nl> + <nl> + assert c . isMarkedForDelete ( ) & & c . getMarkedForDeleteAt ( ) . equals ( new TimestampClock ( 0 ) ) ; <nl> + } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d12a8f8 . . cbf9ab1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 10 
 + * Fix NPE in ComponentOfSlice . isEQ ( ) ( CASSANDRA - 12706 ) 
 * Fix failure in LogTransactionTest ( CASSANDRA - 12632 ) 
 * Fix potentially incomplete non - frozen UDT values when querying with the 
 full primary key specified ( CASSANDRA - 12605 ) 
 diff - - git a / src / java / org / apache / cassandra / db / Slices . java b / src / java / org / apache / cassandra / db / Slices . java 
 index bb354a1 . . 269386e 100644 
 - - - a / src / java / org / apache / cassandra / db / Slices . java 
 + + + b / src / java / org / apache / cassandra / db / Slices . java 
 @ @ - 745 , 7 + 745 , 7 @ @ public abstract class Slices implements Iterable < Slice > 
 
 public boolean isEQ ( ) 
 { 
 - return startValue . equals ( endValue ) ; 
 + return Objects . equals ( startValue , endValue ) ; 
 } 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java 
 index b5d8159 . . 7f59e2f 100644 
 - - - a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java 
 + + + b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java 
 @ @ - 215 , 4 + 215 , 25 @ @ public class SinglePartitionSliceCommandTest 
 checkForS ( pi ) ; 
 } 
 } 
 + 
 + @ Test 
 + public void toCQLStringIsSafeToCall ( ) throws IOException 
 + { 
 + DecoratedKey key = cfm . decorateKey ( ByteBufferUtil . bytes ( " k1 " ) ) ; 
 + 
 + ColumnFilter columnFilter = ColumnFilter . selection ( PartitionColumns . of ( s ) ) ; 
 + Slice slice = Slice . make ( Slice . Bound . BOTTOM , Slice . Bound . inclusiveEndOf ( ByteBufferUtil . bytes ( " i1 " ) ) ) ; 
 + ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter ( Slices . with ( cfm . comparator , slice ) , false ) ; 
 + ReadCommand cmd = new SinglePartitionReadCommand ( false , MessagingService . VERSION _ 30 , true , cfm , 
 + FBUtilities . nowInSeconds ( ) , 
 + columnFilter , 
 + RowFilter . NONE , 
 + DataLimits . NONE , 
 + key , 
 + sliceFilter ) ; 
 + 
 + String ret = cmd . toCQLString ( ) ; 
 + Assert . assertNotNull ( ret ) ; 
 + Assert . assertFalse ( ret . isEmpty ( ) ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 85256bb . . f73d999 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 87 , 6 + 87 , 7 @ @ 
 * Close intra - node sockets when connection is broken ( CASSANDRA - 1528 ) 
 * RPM packaging spec file ( CASSANDRA - 786 ) 
 * weighted request scheduler ( CASSANDRA - 1485 ) 
 + * treat expired columns as deleted ( CASSANDRA - 1539 ) 
 
 
 0 . 7 - beta1 
 diff - - git a / src / java / org / apache / cassandra / db / ExpiringColumn . java b / src / java / org / apache / cassandra / db / ExpiringColumn . java 
 index 12f7801 . . d9813ff 100644 
 - - - a / src / java / org / apache / cassandra / db / ExpiringColumn . java 
 + + + b / src / java / org / apache / cassandra / db / ExpiringColumn . java 
 @ @ - 113 , 4 + 113 , 17 @ @ public class ExpiringColumn extends Column 
 sb . append ( timeToLive ) ; 
 return sb . toString ( ) ; 
 } 
 + 
 + @ Override 
 + public IClock getMarkedForDeleteAt ( ) 
 + { 
 + if ( isMarkedForDelete ( ) ) 
 + { 
 + return clock ; 
 + } 
 + else 
 + { 
 + throw new IllegalStateException ( " column is not marked for delete " ) ; 
 + } 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / RowTest . java b / test / unit / org / apache / cassandra / db / RowTest . java 
 index 2e028d1 . . f23c68d 100644 
 - - - a / test / unit / org / apache / cassandra / db / RowTest . java 
 + + + b / test / unit / org / apache / cassandra / db / RowTest . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import org . apache . cassandra . SchemaLoader ; 
 import org . junit . Test ; 
 
 import static junit . framework . Assert . assertEquals ; 
 + import static junit . framework . Assert . fail ; 
 import org . apache . cassandra . db . marshal . AsciiType ; 
 import static org . apache . cassandra . Util . column ; 
 
 @ @ - 71 , 4 + 72 , 24 @ @ public class RowTest extends SchemaLoader 
 assert Arrays . equals ( cf1 . getColumn ( " one " . getBytes ( ) ) . value ( ) , " B " . getBytes ( ) ) ; 
 assert Arrays . equals ( cf1 . getColumn ( " two " . getBytes ( ) ) . value ( ) , " C " . getBytes ( ) ) ; 
 } 
 + 
 + @ Test 
 + public void testExpiringColumnExpiration ( ) 
 + { 
 + Column c = new ExpiringColumn ( " one " . getBytes ( ) , " A " . getBytes ( ) , new TimestampClock ( 0 ) , 1 ) ; 
 + assert ! c . isMarkedForDelete ( ) ; 
 + 
 + try 
 + { 
 + / / Because we keep the local deletion time with a precision of a 
 + / / second , we could have to wait 2 seconds in worst case scenario . 
 + Thread . sleep ( 2000 ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + fail ( " Cannot test column expiration if you wake me up too early " ) ; 
 + } 
 + 
 + assert c . isMarkedForDelete ( ) & & c . getMarkedForDeleteAt ( ) . equals ( new TimestampClock ( 0 ) ) ; 
 + } 
 }
