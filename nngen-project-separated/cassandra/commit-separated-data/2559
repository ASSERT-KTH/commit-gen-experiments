BLEU SCORE: 3.817663819004394E-5

TEST MSG: merge
GENERATED MSG: Put nodes into hibernate when join _ ring is false .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b642908 . . 01830ef 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 7 <nl> + * Put nodes in hibernate when join _ ring is false ( CASSANDRA - 6961 ) <nl> * Avoid early loading of non - system keyspaces before compaction - leftovers <nl> cleanup at startup ( CASSANDRA - 6913 ) <nl> * Restrict Windows to parallel repairs ( CASSANDRA - 6907 ) <nl> @ @ - 48 , 6 + 49 , 7 @ @ <nl> * Avoid costly range calculations for range queries on system keyspaces <nl> ( CASSANDRA - 6906 ) <nl> * Fix SSTable not released if stream session fails ( CASSANDRA - 6818 ) <nl> + * Avoid build failure due to ANTLR timeout ( CASSANDRA - 6991 ) <nl> Merged from 1 . 2 : <nl> * Add UNLOGGED , COUNTER options to BATCH documentation ( CASSANDRA - 6816 ) <nl> * add extra SSL cipher suites ( CASSANDRA - 6613 ) <nl> @ @ - 55 , 14 + 57 , 17 @ @ Merged from 1 . 2 : <nl> * Fix BatchlogManager # deleteBatch ( ) use of millisecond timsestamps <nl> ( CASSANDRA - 6822 ) <nl> * Continue assassinating even if the endpoint vanishes ( CASSANDRA - 6787 ) <nl> + * Schedule schema pulls on change ( CASSANDRA - 6971 ) <nl> + * Non - droppable verbs shouldn ' t be dropped from OTC ( CASSANDRA - 6980 ) <nl> + * Shutdown batchlog executor in SS # drain ( ) ( CASSANDRA - 7025 ) <nl> <nl> <nl> 2 . 0 . 6 <nl> * Avoid race - prone second " scrub " of system keyspace ( CASSANDRA - 6797 ) <nl> - * Pool CqlRecordWriter clients by inetaddress rather than Range <nl> + * Pool CqlRecordWriter clients by inetaddress rather than Range <nl> ( CASSANDRA - 6665 ) <nl> * Fix compaction _ history timestamps ( CASSANDRA - 6784 ) <nl> - * Compare scores of full replica ordering in DES ( CASSANDRA - 6883 ) <nl> + * Compare scores of full replica ordering in DES ( CASSANDRA - 6683 ) <nl> * fix CME in SessionInfo updateProgress affecting netstats ( CASSANDRA - 6577 ) <nl> * Allow repairing between specific replicas ( CASSANDRA - 6440 ) <nl> * Allow per - dc enabling of hints ( CASSANDRA - 6157 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 18f89bc . . 05f9392 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 14 , 6 + 14 , 15 @ @ restore snapshots created with the previous major version using the <nl> using the provided ' sstableupgrade ' tool . <nl> <nl> <nl> + 2 . 0 . 7 <nl> + = = = = = <nl> + <nl> + Upgrading <nl> + - - - - - - - - - <nl> + - Nothing specific to this release , but please see 2 . 0 . 6 if you are upgrading <nl> + from a previous version . <nl> + <nl> + <nl> 2 . 0 . 6 <nl> = = = = = <nl> <nl> @ @ - 29 , 7 + 38 , 7 @ @ New features <nl> <nl> Upgrading <nl> - - - - - - - - - <nl> - - Nothing specific to this release , but please see 2 . 0 . 6 if you are upgrading <nl> + - Nothing specific to this release , but please see 2 . 0 . 5 if you are upgrading <nl> from a previous version . <nl> <nl> <nl> diff - - git a / build . xml b / build . xml <nl> index a15415b . . 5c6c736 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 25 , 7 + 25 , 7 @ @ <nl> < property name = " debuglevel " value = " source , lines , vars " / > <nl> <nl> < ! - - default version and SCM information - - > <nl> - < property name = " base . version " value = " 2 . 0 . 6 " / > <nl> + < property name = " base . version " value = " 2 . 0 . 7 " / > <nl> < property name = " scm . connection " value = " scm : git : / / git . apache . org / cassandra . git " / > <nl> < property name = " scm . developerConnection " value = " scm : git : / / git . apache . org / cassandra . git " / > <nl> < property name = " scm . url " value = " http : / / git - wip - us . apache . org / repos / asf ? p = cassandra . git ; a = tree " / > <nl> @ @ - 229 , 6 + 229 , 8 @ @ <nl> classpath = " $ { build . lib } / antlr - 3 . 2 . jar " <nl> fork = " true " <nl> failonerror = " true " > <nl> + < arg value = " - Xconversiontimeout " / > <nl> + < arg value = " 10000 " / > <nl> < arg value = " $ { build . src . java } / org / apache / cassandra / cql3 / Cql . g " / > <nl> < arg value = " - fo " / > <nl> < arg value = " $ { build . src . gen - java } / org / apache / cassandra / cql3 / " / > <nl> diff - - git a / debian / changelog b / debian / changelog <nl> index 6cc4391 . . 37c7425 100644 <nl> - - - a / debian / changelog <nl> + + + b / debian / changelog <nl> @ @ - 1 , 3 + 1 , 9 @ @ <nl> + cassandra ( 2 . 0 . 7 ) unstable ; urgency = low <nl> + <nl> + * New release <nl> + <nl> + - - Sylvain Lebresne < slebresne @ apache . org > Mon , 14 Apr 2014 16 : 42 : 09 + 0200 <nl> + <nl> cassandra ( 2 . 0 . 6 ) unstable ; urgency = low <nl> <nl> * New release <nl> diff - - git a / src / java / org / apache / cassandra / db / BatchlogManager . java b / src / java / org / apache / cassandra / db / BatchlogManager . java <nl> index b5e8297 . . d65a2b0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / BatchlogManager . java <nl> + + + b / src / java / org / apache / cassandra / db / BatchlogManager . java <nl> @ @ - 75 , 7 + 75 , 7 @ @ public class BatchlogManager implements BatchlogManagerMBean <nl> private final AtomicLong totalBatchesReplayed = new AtomicLong ( ) ; <nl> private final AtomicBoolean isReplaying = new AtomicBoolean ( ) ; <nl> <nl> - private static final ScheduledExecutorService batchlogTasks = new DebuggableScheduledThreadPoolExecutor ( " BatchlogTasks " ) ; <nl> + public static final ScheduledExecutorService batchlogTasks = new DebuggableScheduledThreadPoolExecutor ( " BatchlogTasks " ) ; <nl> <nl> public void start ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> index f332abe . . 8b8872b 100644 <nl> - - - a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> @ @ - 145 , 7 + 145 , 7 @ @ public class OutboundTcpConnection extends Thread <nl> break ; <nl> continue ; <nl> } <nl> - if ( qm . timestamp < System . currentTimeMillis ( ) - m . getTimeout ( ) ) <nl> + if ( qm . isTimedOut ( m . getTimeout ( ) ) ) <nl> dropped . incrementAndGet ( ) ; <nl> else if ( socket ! = null | | connect ( ) ) <nl> writeConnected ( qm ) ; <nl> @ @ - 442 , 17 + 442 , 25 @ @ public class OutboundTcpConnection extends Thread <nl> final MessageOut < ? > message ; <nl> final int id ; <nl> final long timestamp ; <nl> + final boolean droppable ; <nl> <nl> QueuedMessage ( MessageOut < ? > message , int id ) <nl> { <nl> this . message = message ; <nl> this . id = id ; <nl> this . timestamp = System . currentTimeMillis ( ) ; <nl> + this . droppable = MessagingService . DROPPABLE _ VERBS . contains ( message . verb ) ; <nl> + } <nl> + <nl> + / * * don ' t drop a non - droppable message just because it ' s timestamp is expired * / <nl> + boolean isTimedOut ( long maxTime ) <nl> + { <nl> + return droppable & & timestamp < System . currentTimeMillis ( ) - maxTime ; <nl> } <nl> <nl> boolean shouldRetry ( ) <nl> { <nl> - return ! MessagingService . DROPPABLE _ VERBS . contains ( message . verb ) ; <nl> + return ! droppable ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / MigrationManager . java b / src / java / org / apache / cassandra / service / MigrationManager . java <nl> index 0e36234 . . b474bdc 100644 <nl> - - - a / src / java / org / apache / cassandra / service / MigrationManager . java <nl> + + + b / src / java / org / apache / cassandra / service / MigrationManager . java <nl> @ @ - 91 , 11 + 91 , 15 @ @ public class MigrationManager <nl> private static void maybeScheduleSchemaPull ( final UUID theirVersion , final InetAddress endpoint ) <nl> { <nl> if ( ( Schema . instance . getVersion ( ) ! = null & & Schema . instance . getVersion ( ) . equals ( theirVersion ) ) | | ! shouldPullSchemaFrom ( endpoint ) ) <nl> + { <nl> + logger . debug ( " Not pulling schema because versions match or shouldPullSchemaFrom returned false " ) ; <nl> return ; <nl> + } <nl> <nl> if ( Schema . emptyVersion . equals ( Schema . instance . getVersion ( ) ) | | runtimeMXBean . getUptime ( ) < MIGRATION _ DELAY _ IN _ MS ) <nl> { <nl> / / If we think we may be bootstrapping or have recently started , submit MigrationTask immediately <nl> + logger . debug ( " Submitting migration task for { } " , endpoint ) ; <nl> submitMigrationTask ( endpoint ) ; <nl> } <nl> else <nl> @ @ - 109 , 12 + 113 , 18 @ @ public class MigrationManager <nl> / / grab the latest version of the schema since it may have changed again since the initial scheduling <nl> EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; <nl> if ( epState = = null ) <nl> + { <nl> + logger . debug ( " epState vanished for { } , not submitting migration task " , endpoint ) ; <nl> return ; <nl> + } <nl> VersionedValue value = epState . getApplicationState ( ApplicationState . SCHEMA ) ; <nl> UUID currentVersion = UUID . fromString ( value . value ) ; <nl> if ( Schema . instance . getVersion ( ) . equals ( currentVersion ) ) <nl> + { <nl> + logger . debug ( " not submitting migration task for { } because our versions match " , endpoint ) ; <nl> return ; <nl> - <nl> + } <nl> + logger . debug ( " submitting migration task for { } " , endpoint ) ; <nl> submitMigrationTask ( endpoint ) ; <nl> } <nl> } ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 6ddfd80 . . 7382cbd 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 42 , 6 + 42 , 7 @ @ import com . google . common . util . concurrent . FutureCallback ; <nl> import com . google . common . util . concurrent . Futures ; <nl> import com . google . common . util . concurrent . Uninterruptibles ; <nl> <nl> + import org . apache . cassandra . cql3 . CQL3Type ; <nl> import org . apache . commons . lang3 . StringUtils ; <nl> import org . apache . log4j . Level ; <nl> import org . slf4j . Logger ; <nl> @ @ - 192 , 6 + 193 , 8 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private final ObjectName jmxObjectName ; <nl> <nl> + private Collection < Token > bootstrapTokens = null ; <nl> + <nl> public void finishBootstrapping ( ) <nl> { <nl> isBootstrapMode = false ; <nl> @ @ - 606 , 12 + 609 , 21 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } , " StorageServiceShutdownHook " ) ; <nl> Runtime . getRuntime ( ) . addShutdownHook ( drainOnShutdown ) ; <nl> <nl> + prepareToJoin ( ) ; <nl> if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) <nl> { <nl> joinTokenRing ( delay ) ; <nl> } <nl> else <nl> { <nl> + Collection < Token > tokens = SystemKeyspace . getSavedTokens ( ) ; <nl> + if ( ! tokens . isEmpty ( ) ) <nl> + { <nl> + tokenMetadata . updateNormalTokens ( tokens , FBUtilities . getBroadcastAddress ( ) ) ; <nl> + / / order is important here , the gossiper can fire in between adding these two states . It ' s ok to send TOKENS without STATUS , but * not * vice versa . <nl> + Gossiper . instance . addLocalApplicationState ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; <nl> + Gossiper . instance . addLocalApplicationState ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; <nl> + } <nl> logger . info ( " Not joining ring as requested . Use JMX ( StorageService - > joinRing ( ) ) to initiate ring joining " ) ; <nl> } <nl> } <nl> @ @ - 621 , 52 + 633 , 58 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return DatabaseDescriptor . isAutoBootstrap ( ) & & ! SystemKeyspace . bootstrapComplete ( ) & & ! DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> } <nl> <nl> - private void joinTokenRing ( int delay ) throws ConfigurationException <nl> + private void prepareToJoin ( ) throws ConfigurationException <nl> { <nl> - joined = true ; <nl> - <nl> - Collection < Token > tokens = null ; <nl> - Map < ApplicationState , VersionedValue > appStates = new HashMap < ApplicationState , VersionedValue > ( ) ; <nl> - <nl> - if ( DatabaseDescriptor . getReplaceTokens ( ) . size ( ) > 0 | | DatabaseDescriptor . getReplaceNode ( ) ! = null ) <nl> - throw new RuntimeException ( " Replace method removed ; use cassandra . replace _ address instead " ) ; <nl> - if ( DatabaseDescriptor . isReplacing ( ) ) <nl> - { <nl> - if ( ! DatabaseDescriptor . isAutoBootstrap ( ) ) <nl> - throw new RuntimeException ( " Trying to replace _ address with auto _ bootstrap disabled will not work , check your configuration " ) ; <nl> - tokens = prepareReplacementInfo ( ) ; <nl> - appStates . put ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; <nl> - appStates . put ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; <nl> - } <nl> - else if ( shouldBootstrap ( ) ) <nl> + if ( ! joined ) <nl> { <nl> - checkForEndpointCollision ( ) ; <nl> - } <nl> + Map < ApplicationState , VersionedValue > appStates = new HashMap < ApplicationState , VersionedValue > ( ) ; <nl> <nl> - / / have to start the gossip service before we can see any info on other nodes . this is necessary <nl> - / / for bootstrap to get the load info it needs . <nl> - / / ( we won ' t be part of the storage ring though until we add a counterId to our state , below . ) <nl> - / / Seed the host ID - to - endpoint map with our own ID . <nl> - getTokenMetadata ( ) . updateHostId ( SystemKeyspace . getLocalHostId ( ) , FBUtilities . getBroadcastAddress ( ) ) ; <nl> - appStates . put ( ApplicationState . NET _ VERSION , valueFactory . networkVersion ( ) ) ; <nl> - appStates . put ( ApplicationState . HOST _ ID , valueFactory . hostId ( SystemKeyspace . getLocalHostId ( ) ) ) ; <nl> - appStates . put ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getRpcAddress ( ) ) ) ; <nl> - appStates . put ( ApplicationState . RELEASE _ VERSION , valueFactory . releaseVersion ( ) ) ; <nl> - logger . info ( " Starting up server gossip " ) ; <nl> - Gossiper . instance . register ( this ) ; <nl> - Gossiper . instance . start ( SystemKeyspace . incrementAndGetGeneration ( ) , appStates ) ; / / needed for node - ring gathering . <nl> - / / gossip snitch infos ( local DC and rack ) <nl> - gossipSnitchInfo ( ) ; <nl> - / / gossip Schema . emptyVersion forcing immediate check for schema updates ( see MigrationManager # maybeScheduleSchemaPull ) <nl> - Schema . instance . updateVersionAndAnnounce ( ) ; / / Ensure we know our own actual Schema UUID in preparation for updates <nl> + if ( DatabaseDescriptor . isReplacing ( ) & & ! ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) ) <nl> + throw new ConfigurationException ( " Cannot set both join _ ring = false and attempt to replace a node " ) ; <nl> + if ( DatabaseDescriptor . getReplaceTokens ( ) . size ( ) > 0 | | DatabaseDescriptor . getReplaceNode ( ) ! = null ) <nl> + throw new RuntimeException ( " Replace method removed ; use cassandra . replace _ address instead " ) ; <nl> + if ( DatabaseDescriptor . isReplacing ( ) ) <nl> + { <nl> + if ( ! DatabaseDescriptor . isAutoBootstrap ( ) ) <nl> + throw new RuntimeException ( " Trying to replace _ address with auto _ bootstrap disabled will not work , check your configuration " ) ; <nl> + bootstrapTokens = prepareReplacementInfo ( ) ; <nl> + appStates . put ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; <nl> + appStates . put ( ApplicationState . TOKENS , valueFactory . tokens ( bootstrapTokens ) ) ; <nl> + } <nl> + else if ( shouldBootstrap ( ) ) <nl> + { <nl> + checkForEndpointCollision ( ) ; <nl> + } <nl> + / / have to start the gossip service before we can see any info on other nodes . this is necessary <nl> + / / for bootstrap to get the load info it needs . <nl> + / / ( we won ' t be part of the storage ring though until we add a counterId to our state , below . ) <nl> + / / Seed the host ID - to - endpoint map with our own ID . <nl> + getTokenMetadata ( ) . updateHostId ( SystemKeyspace . getLocalHostId ( ) , FBUtilities . getBroadcastAddress ( ) ) ; <nl> + appStates . put ( ApplicationState . NET _ VERSION , valueFactory . networkVersion ( ) ) ; <nl> + appStates . put ( ApplicationState . HOST _ ID , valueFactory . hostId ( SystemKeyspace . getLocalHostId ( ) ) ) ; <nl> + appStates . put ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getRpcAddress ( ) ) ) ; <nl> + appStates . put ( ApplicationState . RELEASE _ VERSION , valueFactory . releaseVersion ( ) ) ; <nl> + logger . info ( " Starting up server gossip " ) ; <nl> + Gossiper . instance . register ( this ) ; <nl> + Gossiper . instance . start ( SystemKeyspace . incrementAndGetGeneration ( ) , appStates ) ; / / needed for node - ring gathering . <nl> + / / gossip snitch infos ( local DC and rack ) <nl> + gossipSnitchInfo ( ) ; <nl> + / / gossip Schema . emptyVersion forcing immediate check for schema updates ( see MigrationManager # maybeScheduleSchemaPull ) <nl> + Schema . instance . updateVersionAndAnnounce ( ) ; / / Ensure we know our own actual Schema UUID in preparation for updates <nl> <nl> <nl> - if ( ! MessagingService . instance ( ) . isListening ( ) ) <nl> - MessagingService . instance ( ) . listen ( FBUtilities . getLocalAddress ( ) ) ; <nl> - LoadBroadcaster . instance . startBroadcasting ( ) ; <nl> + if ( ! MessagingService . instance ( ) . isListening ( ) ) <nl> + MessagingService . instance ( ) . listen ( FBUtilities . getLocalAddress ( ) ) ; <nl> + LoadBroadcaster . instance . startBroadcasting ( ) ; <nl> + <nl> + HintedHandOffManager . instance . start ( ) ; <nl> + BatchlogManager . instance . start ( ) ; <nl> + } <nl> + } <nl> <nl> - HintedHandOffManager . instance . start ( ) ; <nl> - BatchlogManager . instance . start ( ) ; <nl> + private void joinTokenRing ( int delay ) throws ConfigurationException <nl> + { <nl> + joined = true ; <nl> <nl> / / We bootstrap if we haven ' t successfully bootstrapped before , as long as we are not a seed . <nl> / / If we are a seed , or if the user manually sets auto _ bootstrap to false , <nl> @ @ - 727 , 7 + 745 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> throw new UnsupportedOperationException ( s ) ; <nl> } <nl> setMode ( Mode . JOINING , " getting bootstrap token " , true ) ; <nl> - tokens = BootStrapper . getBootstrapTokens ( tokenMetadata ) ; <nl> + bootstrapTokens = BootStrapper . getBootstrapTokens ( tokenMetadata ) ; <nl> } <nl> else <nl> { <nl> @ @ - 745 , 7 + 763 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> <nl> / / check for operator errors . . . <nl> - for ( Token token : tokens ) <nl> + for ( Token token : bootstrapTokens ) <nl> { <nl> InetAddress existing = tokenMetadata . getEndpoint ( token ) ; <nl> if ( existing ! = null ) <nl> @ @ - 773 , 46 + 791 , 46 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> <nl> } <nl> - setMode ( Mode . JOINING , " Replacing a node with token ( s ) : " + tokens , true ) ; <nl> + setMode ( Mode . JOINING , " Replacing a node with token ( s ) : " + bootstrapTokens , true ) ; <nl> } <nl> <nl> - bootstrap ( tokens ) ; <nl> + bootstrap ( bootstrapTokens ) ; <nl> assert ! isBootstrapMode ; / / bootstrap will block until finished <nl> } <nl> else <nl> { <nl> - tokens = SystemKeyspace . getSavedTokens ( ) ; <nl> - if ( tokens . isEmpty ( ) ) <nl> + bootstrapTokens = SystemKeyspace . getSavedTokens ( ) ; <nl> + if ( bootstrapTokens . isEmpty ( ) ) <nl> { <nl> Collection < String > initialTokens = DatabaseDescriptor . getInitialTokens ( ) ; <nl> if ( initialTokens . size ( ) < 1 ) <nl> { <nl> - tokens = BootStrapper . getRandomTokens ( tokenMetadata , DatabaseDescriptor . getNumTokens ( ) ) ; <nl> + bootstrapTokens = BootStrapper . getRandomTokens ( tokenMetadata , DatabaseDescriptor . getNumTokens ( ) ) ; <nl> if ( DatabaseDescriptor . getNumTokens ( ) = = 1 ) <nl> - logger . warn ( " Generated random token " + tokens + " . Random tokens will result in an unbalanced ring ; see http : / / wiki . apache . org / cassandra / Operations " ) ; <nl> + logger . warn ( " Generated random token " + bootstrapTokens + " . Random tokens will result in an unbalanced ring ; see http : / / wiki . apache . org / cassandra / Operations " ) ; <nl> else <nl> - logger . info ( " Generated random tokens . tokens are { } " , tokens ) ; <nl> + logger . info ( " Generated random tokens . tokens are { } " , bootstrapTokens ) ; <nl> } <nl> else <nl> { <nl> - tokens = new ArrayList < Token > ( initialTokens . size ( ) ) ; <nl> + bootstrapTokens = new ArrayList < Token > ( initialTokens . size ( ) ) ; <nl> for ( String token : initialTokens ) <nl> - tokens . add ( getPartitioner ( ) . getTokenFactory ( ) . fromString ( token ) ) ; <nl> - logger . info ( " Saved tokens not found . Using configuration value : { } " , tokens ) ; <nl> + bootstrapTokens . add ( getPartitioner ( ) . getTokenFactory ( ) . fromString ( token ) ) ; <nl> + logger . info ( " Saved tokens not found . Using configuration value : { } " , bootstrapTokens ) ; <nl> } <nl> } <nl> else <nl> { <nl> / / if we were already bootstrapped with 1 token but num _ tokens is set higher in the config , <nl> / / then we need to migrate to multi - token <nl> - if ( tokens . size ( ) = = 1 & & DatabaseDescriptor . getNumTokens ( ) > 1 ) <nl> + if ( bootstrapTokens . size ( ) = = 1 & & DatabaseDescriptor . getNumTokens ( ) > 1 ) <nl> { <nl> / / wait for ring info <nl> logger . info ( " Sleeping for ring delay ( " + delay + " ms ) " ) ; <nl> Uninterruptibles . sleepUninterruptibly ( delay , TimeUnit . MILLISECONDS ) ; <nl> logger . info ( " Calculating new tokens " ) ; <nl> / / calculate num _ tokens tokens evenly spaced in the range ( left , right ] <nl> - Token right = tokens . iterator ( ) . next ( ) ; <nl> + Token right = bootstrapTokens . iterator ( ) . next ( ) ; <nl> TokenMetadata clone = tokenMetadata . cloneOnlyTokenMap ( ) ; <nl> clone . updateNormalToken ( right , FBUtilities . getBroadcastAddress ( ) ) ; <nl> Token left = clone . getPredecessor ( right ) ; <nl> @ @ - 842 , 12 + 860 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> r = midpoint ; <nl> midpoint = getPartitioner ( ) . midpoint ( l , r ) ; <nl> } <nl> - tokens . add ( midpoint ) ; <nl> + bootstrapTokens . add ( midpoint ) ; <nl> } <nl> - logger . info ( " Split previous range ( " + left + " , " + right + " ] into " + tokens ) ; <nl> + logger . info ( " Split previous range ( " + left + " , " + right + " ] into " + bootstrapTokens ) ; <nl> } <nl> else <nl> - logger . info ( " Using saved tokens " + tokens ) ; <nl> + logger . info ( " Using saved tokens " + bootstrapTokens ) ; <nl> } <nl> } <nl> <nl> @ @ - 862 , 7 + 880 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> / / start participating in the ring . <nl> SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . COMPLETED ) ; <nl> - setTokens ( tokens ) ; <nl> + setTokens ( bootstrapTokens ) ; <nl> / / remove the existing info about the replaced node . <nl> if ( ! current . isEmpty ( ) ) <nl> for ( InetAddress existing : current ) <nl> @ @ - 1393 , 6 + 1411 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> break ; <nl> case SCHEMA : <nl> SystemKeyspace . updatePeerInfo ( endpoint , " schema _ version " , value . value ) ; <nl> + MigrationManager . instance . scheduleSchemaPull ( endpoint , epState ) ; <nl> break ; <nl> case HOST _ ID : <nl> SystemKeyspace . updatePeerInfo ( endpoint , " host _ id " , value . value ) ; <nl> @ @ - 3442 , 6 + 3461 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> FBUtilities . waitOnFutures ( flushes ) ; <nl> <nl> + BatchlogManager . batchlogTasks . shutdown ( ) ; <nl> + BatchlogManager . batchlogTasks . awaitTermination ( 60 , TimeUnit . SECONDS ) ; <nl> + <nl> ColumnFamilyStore . postFlushExecutor . shutdown ( ) ; <nl> ColumnFamilyStore . postFlushExecutor . awaitTermination ( 60 , TimeUnit . SECONDS ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / streaming / ConnectionHandler . java b / src / java / org / apache / cassandra / streaming / ConnectionHandler . java <nl> index 356138b . . b06a818 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / ConnectionHandler . java <nl> + + + b / src / java / org / apache / cassandra / streaming / ConnectionHandler . java <nl> @ @ - 366 , 7 + 366 , 7 @ @ public class ConnectionHandler <nl> { <nl> throw new AssertionError ( e ) ; <nl> } <nl> - catch ( IOException e ) <nl> + catch ( Throwable e ) <nl> { <nl> session . onError ( e ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> index 449751d . . 7976a40 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> @ @ - 462 , 7 + 462 , 11 @ @ public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDe <nl> StreamingMetrics . totalOutgoingBytes . inc ( headerSize ) ; <nl> metrics . outgoingBytes . inc ( headerSize ) ; <nl> / / schedule timeout for receiving ACK <nl> - transfers . get ( header . cfId ) . scheduleTimeout ( header . sequenceNumber , 12 , TimeUnit . HOURS ) ; <nl> + StreamTransferTask task = transfers . get ( header . cfId ) ; <nl> + if ( task ! = null ) <nl> + { <nl> + task . scheduleTimeout ( header . sequenceNumber , 12 , TimeUnit . HOURS ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> index 86f4ee2 . . 7d0cc87 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> @ @ - 58 , 7 + 58 , 7 @ @ public class StreamTransferTask extends StreamTask <nl> * <nl> * @ param sequenceNumber sequence number of file <nl> * / <nl> - public void complete ( int sequenceNumber ) <nl> + public synchronized void complete ( int sequenceNumber ) <nl> { <nl> OutgoingFileMessage file = files . remove ( sequenceNumber ) ; <nl> if ( file ! = null ) <nl> @ @ - 117 , 7 + 117 , 7 @ @ public class StreamTransferTask extends StreamTask <nl> * @ param unit unit of given time <nl> * @ return scheduled future for timeout task <nl> * / <nl> - public ScheduledFuture scheduleTimeout ( final int sequenceNumber , long time , TimeUnit unit ) <nl> + public synchronized ScheduledFuture scheduleTimeout ( final int sequenceNumber , long time , TimeUnit unit ) <nl> { <nl> if ( timeoutExecutor . isShutdown ( ) ) <nl> return null ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b642908 . . 01830ef 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 7 
 + * Put nodes in hibernate when join _ ring is false ( CASSANDRA - 6961 ) 
 * Avoid early loading of non - system keyspaces before compaction - leftovers 
 cleanup at startup ( CASSANDRA - 6913 ) 
 * Restrict Windows to parallel repairs ( CASSANDRA - 6907 ) 
 @ @ - 48 , 6 + 49 , 7 @ @ 
 * Avoid costly range calculations for range queries on system keyspaces 
 ( CASSANDRA - 6906 ) 
 * Fix SSTable not released if stream session fails ( CASSANDRA - 6818 ) 
 + * Avoid build failure due to ANTLR timeout ( CASSANDRA - 6991 ) 
 Merged from 1 . 2 : 
 * Add UNLOGGED , COUNTER options to BATCH documentation ( CASSANDRA - 6816 ) 
 * add extra SSL cipher suites ( CASSANDRA - 6613 ) 
 @ @ - 55 , 14 + 57 , 17 @ @ Merged from 1 . 2 : 
 * Fix BatchlogManager # deleteBatch ( ) use of millisecond timsestamps 
 ( CASSANDRA - 6822 ) 
 * Continue assassinating even if the endpoint vanishes ( CASSANDRA - 6787 ) 
 + * Schedule schema pulls on change ( CASSANDRA - 6971 ) 
 + * Non - droppable verbs shouldn ' t be dropped from OTC ( CASSANDRA - 6980 ) 
 + * Shutdown batchlog executor in SS # drain ( ) ( CASSANDRA - 7025 ) 
 
 
 2 . 0 . 6 
 * Avoid race - prone second " scrub " of system keyspace ( CASSANDRA - 6797 ) 
 - * Pool CqlRecordWriter clients by inetaddress rather than Range 
 + * Pool CqlRecordWriter clients by inetaddress rather than Range 
 ( CASSANDRA - 6665 ) 
 * Fix compaction _ history timestamps ( CASSANDRA - 6784 ) 
 - * Compare scores of full replica ordering in DES ( CASSANDRA - 6883 ) 
 + * Compare scores of full replica ordering in DES ( CASSANDRA - 6683 ) 
 * fix CME in SessionInfo updateProgress affecting netstats ( CASSANDRA - 6577 ) 
 * Allow repairing between specific replicas ( CASSANDRA - 6440 ) 
 * Allow per - dc enabling of hints ( CASSANDRA - 6157 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 18f89bc . . 05f9392 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 14 , 6 + 14 , 15 @ @ restore snapshots created with the previous major version using the 
 using the provided ' sstableupgrade ' tool . 
 
 
 + 2 . 0 . 7 
 + = = = = = 
 + 
 + Upgrading 
 + - - - - - - - - - 
 + - Nothing specific to this release , but please see 2 . 0 . 6 if you are upgrading 
 + from a previous version . 
 + 
 + 
 2 . 0 . 6 
 = = = = = 
 
 @ @ - 29 , 7 + 38 , 7 @ @ New features 
 
 Upgrading 
 - - - - - - - - - 
 - - Nothing specific to this release , but please see 2 . 0 . 6 if you are upgrading 
 + - Nothing specific to this release , but please see 2 . 0 . 5 if you are upgrading 
 from a previous version . 
 
 
 diff - - git a / build . xml b / build . xml 
 index a15415b . . 5c6c736 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 25 , 7 + 25 , 7 @ @ 
 < property name = " debuglevel " value = " source , lines , vars " / > 
 
 < ! - - default version and SCM information - - > 
 - < property name = " base . version " value = " 2 . 0 . 6 " / > 
 + < property name = " base . version " value = " 2 . 0 . 7 " / > 
 < property name = " scm . connection " value = " scm : git : / / git . apache . org / cassandra . git " / > 
 < property name = " scm . developerConnection " value = " scm : git : / / git . apache . org / cassandra . git " / > 
 < property name = " scm . url " value = " http : / / git - wip - us . apache . org / repos / asf ? p = cassandra . git ; a = tree " / > 
 @ @ - 229 , 6 + 229 , 8 @ @ 
 classpath = " $ { build . lib } / antlr - 3 . 2 . jar " 
 fork = " true " 
 failonerror = " true " > 
 + < arg value = " - Xconversiontimeout " / > 
 + < arg value = " 10000 " / > 
 < arg value = " $ { build . src . java } / org / apache / cassandra / cql3 / Cql . g " / > 
 < arg value = " - fo " / > 
 < arg value = " $ { build . src . gen - java } / org / apache / cassandra / cql3 / " / > 
 diff - - git a / debian / changelog b / debian / changelog 
 index 6cc4391 . . 37c7425 100644 
 - - - a / debian / changelog 
 + + + b / debian / changelog 
 @ @ - 1 , 3 + 1 , 9 @ @ 
 + cassandra ( 2 . 0 . 7 ) unstable ; urgency = low 
 + 
 + * New release 
 + 
 + - - Sylvain Lebresne < slebresne @ apache . org > Mon , 14 Apr 2014 16 : 42 : 09 + 0200 
 + 
 cassandra ( 2 . 0 . 6 ) unstable ; urgency = low 
 
 * New release 
 diff - - git a / src / java / org / apache / cassandra / db / BatchlogManager . java b / src / java / org / apache / cassandra / db / BatchlogManager . java 
 index b5e8297 . . d65a2b0 100644 
 - - - a / src / java / org / apache / cassandra / db / BatchlogManager . java 
 + + + b / src / java / org / apache / cassandra / db / BatchlogManager . java 
 @ @ - 75 , 7 + 75 , 7 @ @ public class BatchlogManager implements BatchlogManagerMBean 
 private final AtomicLong totalBatchesReplayed = new AtomicLong ( ) ; 
 private final AtomicBoolean isReplaying = new AtomicBoolean ( ) ; 
 
 - private static final ScheduledExecutorService batchlogTasks = new DebuggableScheduledThreadPoolExecutor ( " BatchlogTasks " ) ; 
 + public static final ScheduledExecutorService batchlogTasks = new DebuggableScheduledThreadPoolExecutor ( " BatchlogTasks " ) ; 
 
 public void start ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 index f332abe . . 8b8872b 100644 
 - - - a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 @ @ - 145 , 7 + 145 , 7 @ @ public class OutboundTcpConnection extends Thread 
 break ; 
 continue ; 
 } 
 - if ( qm . timestamp < System . currentTimeMillis ( ) - m . getTimeout ( ) ) 
 + if ( qm . isTimedOut ( m . getTimeout ( ) ) ) 
 dropped . incrementAndGet ( ) ; 
 else if ( socket ! = null | | connect ( ) ) 
 writeConnected ( qm ) ; 
 @ @ - 442 , 17 + 442 , 25 @ @ public class OutboundTcpConnection extends Thread 
 final MessageOut < ? > message ; 
 final int id ; 
 final long timestamp ; 
 + final boolean droppable ; 
 
 QueuedMessage ( MessageOut < ? > message , int id ) 
 { 
 this . message = message ; 
 this . id = id ; 
 this . timestamp = System . currentTimeMillis ( ) ; 
 + this . droppable = MessagingService . DROPPABLE _ VERBS . contains ( message . verb ) ; 
 + } 
 + 
 + / * * don ' t drop a non - droppable message just because it ' s timestamp is expired * / 
 + boolean isTimedOut ( long maxTime ) 
 + { 
 + return droppable & & timestamp < System . currentTimeMillis ( ) - maxTime ; 
 } 
 
 boolean shouldRetry ( ) 
 { 
 - return ! MessagingService . DROPPABLE _ VERBS . contains ( message . verb ) ; 
 + return ! droppable ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / service / MigrationManager . java b / src / java / org / apache / cassandra / service / MigrationManager . java 
 index 0e36234 . . b474bdc 100644 
 - - - a / src / java / org / apache / cassandra / service / MigrationManager . java 
 + + + b / src / java / org / apache / cassandra / service / MigrationManager . java 
 @ @ - 91 , 11 + 91 , 15 @ @ public class MigrationManager 
 private static void maybeScheduleSchemaPull ( final UUID theirVersion , final InetAddress endpoint ) 
 { 
 if ( ( Schema . instance . getVersion ( ) ! = null & & Schema . instance . getVersion ( ) . equals ( theirVersion ) ) | | ! shouldPullSchemaFrom ( endpoint ) ) 
 + { 
 + logger . debug ( " Not pulling schema because versions match or shouldPullSchemaFrom returned false " ) ; 
 return ; 
 + } 
 
 if ( Schema . emptyVersion . equals ( Schema . instance . getVersion ( ) ) | | runtimeMXBean . getUptime ( ) < MIGRATION _ DELAY _ IN _ MS ) 
 { 
 / / If we think we may be bootstrapping or have recently started , submit MigrationTask immediately 
 + logger . debug ( " Submitting migration task for { } " , endpoint ) ; 
 submitMigrationTask ( endpoint ) ; 
 } 
 else 
 @ @ - 109 , 12 + 113 , 18 @ @ public class MigrationManager 
 / / grab the latest version of the schema since it may have changed again since the initial scheduling 
 EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; 
 if ( epState = = null ) 
 + { 
 + logger . debug ( " epState vanished for { } , not submitting migration task " , endpoint ) ; 
 return ; 
 + } 
 VersionedValue value = epState . getApplicationState ( ApplicationState . SCHEMA ) ; 
 UUID currentVersion = UUID . fromString ( value . value ) ; 
 if ( Schema . instance . getVersion ( ) . equals ( currentVersion ) ) 
 + { 
 + logger . debug ( " not submitting migration task for { } because our versions match " , endpoint ) ; 
 return ; 
 - 
 + } 
 + logger . debug ( " submitting migration task for { } " , endpoint ) ; 
 submitMigrationTask ( endpoint ) ; 
 } 
 } ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 6ddfd80 . . 7382cbd 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 42 , 6 + 42 , 7 @ @ import com . google . common . util . concurrent . FutureCallback ; 
 import com . google . common . util . concurrent . Futures ; 
 import com . google . common . util . concurrent . Uninterruptibles ; 
 
 + import org . apache . cassandra . cql3 . CQL3Type ; 
 import org . apache . commons . lang3 . StringUtils ; 
 import org . apache . log4j . Level ; 
 import org . slf4j . Logger ; 
 @ @ - 192 , 6 + 193 , 8 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private final ObjectName jmxObjectName ; 
 
 + private Collection < Token > bootstrapTokens = null ; 
 + 
 public void finishBootstrapping ( ) 
 { 
 isBootstrapMode = false ; 
 @ @ - 606 , 12 + 609 , 21 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } , " StorageServiceShutdownHook " ) ; 
 Runtime . getRuntime ( ) . addShutdownHook ( drainOnShutdown ) ; 
 
 + prepareToJoin ( ) ; 
 if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) 
 { 
 joinTokenRing ( delay ) ; 
 } 
 else 
 { 
 + Collection < Token > tokens = SystemKeyspace . getSavedTokens ( ) ; 
 + if ( ! tokens . isEmpty ( ) ) 
 + { 
 + tokenMetadata . updateNormalTokens ( tokens , FBUtilities . getBroadcastAddress ( ) ) ; 
 + / / order is important here , the gossiper can fire in between adding these two states . It ' s ok to send TOKENS without STATUS , but * not * vice versa . 
 + Gossiper . instance . addLocalApplicationState ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; 
 + Gossiper . instance . addLocalApplicationState ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; 
 + } 
 logger . info ( " Not joining ring as requested . Use JMX ( StorageService - > joinRing ( ) ) to initiate ring joining " ) ; 
 } 
 } 
 @ @ - 621 , 52 + 633 , 58 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return DatabaseDescriptor . isAutoBootstrap ( ) & & ! SystemKeyspace . bootstrapComplete ( ) & & ! DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ; 
 } 
 
 - private void joinTokenRing ( int delay ) throws ConfigurationException 
 + private void prepareToJoin ( ) throws ConfigurationException 
 { 
 - joined = true ; 
 - 
 - Collection < Token > tokens = null ; 
 - Map < ApplicationState , VersionedValue > appStates = new HashMap < ApplicationState , VersionedValue > ( ) ; 
 - 
 - if ( DatabaseDescriptor . getReplaceTokens ( ) . size ( ) > 0 | | DatabaseDescriptor . getReplaceNode ( ) ! = null ) 
 - throw new RuntimeException ( " Replace method removed ; use cassandra . replace _ address instead " ) ; 
 - if ( DatabaseDescriptor . isReplacing ( ) ) 
 - { 
 - if ( ! DatabaseDescriptor . isAutoBootstrap ( ) ) 
 - throw new RuntimeException ( " Trying to replace _ address with auto _ bootstrap disabled will not work , check your configuration " ) ; 
 - tokens = prepareReplacementInfo ( ) ; 
 - appStates . put ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; 
 - appStates . put ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; 
 - } 
 - else if ( shouldBootstrap ( ) ) 
 + if ( ! joined ) 
 { 
 - checkForEndpointCollision ( ) ; 
 - } 
 + Map < ApplicationState , VersionedValue > appStates = new HashMap < ApplicationState , VersionedValue > ( ) ; 
 
 - / / have to start the gossip service before we can see any info on other nodes . this is necessary 
 - / / for bootstrap to get the load info it needs . 
 - / / ( we won ' t be part of the storage ring though until we add a counterId to our state , below . ) 
 - / / Seed the host ID - to - endpoint map with our own ID . 
 - getTokenMetadata ( ) . updateHostId ( SystemKeyspace . getLocalHostId ( ) , FBUtilities . getBroadcastAddress ( ) ) ; 
 - appStates . put ( ApplicationState . NET _ VERSION , valueFactory . networkVersion ( ) ) ; 
 - appStates . put ( ApplicationState . HOST _ ID , valueFactory . hostId ( SystemKeyspace . getLocalHostId ( ) ) ) ; 
 - appStates . put ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getRpcAddress ( ) ) ) ; 
 - appStates . put ( ApplicationState . RELEASE _ VERSION , valueFactory . releaseVersion ( ) ) ; 
 - logger . info ( " Starting up server gossip " ) ; 
 - Gossiper . instance . register ( this ) ; 
 - Gossiper . instance . start ( SystemKeyspace . incrementAndGetGeneration ( ) , appStates ) ; / / needed for node - ring gathering . 
 - / / gossip snitch infos ( local DC and rack ) 
 - gossipSnitchInfo ( ) ; 
 - / / gossip Schema . emptyVersion forcing immediate check for schema updates ( see MigrationManager # maybeScheduleSchemaPull ) 
 - Schema . instance . updateVersionAndAnnounce ( ) ; / / Ensure we know our own actual Schema UUID in preparation for updates 
 + if ( DatabaseDescriptor . isReplacing ( ) & & ! ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) ) 
 + throw new ConfigurationException ( " Cannot set both join _ ring = false and attempt to replace a node " ) ; 
 + if ( DatabaseDescriptor . getReplaceTokens ( ) . size ( ) > 0 | | DatabaseDescriptor . getReplaceNode ( ) ! = null ) 
 + throw new RuntimeException ( " Replace method removed ; use cassandra . replace _ address instead " ) ; 
 + if ( DatabaseDescriptor . isReplacing ( ) ) 
 + { 
 + if ( ! DatabaseDescriptor . isAutoBootstrap ( ) ) 
 + throw new RuntimeException ( " Trying to replace _ address with auto _ bootstrap disabled will not work , check your configuration " ) ; 
 + bootstrapTokens = prepareReplacementInfo ( ) ; 
 + appStates . put ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; 
 + appStates . put ( ApplicationState . TOKENS , valueFactory . tokens ( bootstrapTokens ) ) ; 
 + } 
 + else if ( shouldBootstrap ( ) ) 
 + { 
 + checkForEndpointCollision ( ) ; 
 + } 
 + / / have to start the gossip service before we can see any info on other nodes . this is necessary 
 + / / for bootstrap to get the load info it needs . 
 + / / ( we won ' t be part of the storage ring though until we add a counterId to our state , below . ) 
 + / / Seed the host ID - to - endpoint map with our own ID . 
 + getTokenMetadata ( ) . updateHostId ( SystemKeyspace . getLocalHostId ( ) , FBUtilities . getBroadcastAddress ( ) ) ; 
 + appStates . put ( ApplicationState . NET _ VERSION , valueFactory . networkVersion ( ) ) ; 
 + appStates . put ( ApplicationState . HOST _ ID , valueFactory . hostId ( SystemKeyspace . getLocalHostId ( ) ) ) ; 
 + appStates . put ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getRpcAddress ( ) ) ) ; 
 + appStates . put ( ApplicationState . RELEASE _ VERSION , valueFactory . releaseVersion ( ) ) ; 
 + logger . info ( " Starting up server gossip " ) ; 
 + Gossiper . instance . register ( this ) ; 
 + Gossiper . instance . start ( SystemKeyspace . incrementAndGetGeneration ( ) , appStates ) ; / / needed for node - ring gathering . 
 + / / gossip snitch infos ( local DC and rack ) 
 + gossipSnitchInfo ( ) ; 
 + / / gossip Schema . emptyVersion forcing immediate check for schema updates ( see MigrationManager # maybeScheduleSchemaPull ) 
 + Schema . instance . updateVersionAndAnnounce ( ) ; / / Ensure we know our own actual Schema UUID in preparation for updates 
 
 
 - if ( ! MessagingService . instance ( ) . isListening ( ) ) 
 - MessagingService . instance ( ) . listen ( FBUtilities . getLocalAddress ( ) ) ; 
 - LoadBroadcaster . instance . startBroadcasting ( ) ; 
 + if ( ! MessagingService . instance ( ) . isListening ( ) ) 
 + MessagingService . instance ( ) . listen ( FBUtilities . getLocalAddress ( ) ) ; 
 + LoadBroadcaster . instance . startBroadcasting ( ) ; 
 + 
 + HintedHandOffManager . instance . start ( ) ; 
 + BatchlogManager . instance . start ( ) ; 
 + } 
 + } 
 
 - HintedHandOffManager . instance . start ( ) ; 
 - BatchlogManager . instance . start ( ) ; 
 + private void joinTokenRing ( int delay ) throws ConfigurationException 
 + { 
 + joined = true ; 
 
 / / We bootstrap if we haven ' t successfully bootstrapped before , as long as we are not a seed . 
 / / If we are a seed , or if the user manually sets auto _ bootstrap to false , 
 @ @ - 727 , 7 + 745 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 throw new UnsupportedOperationException ( s ) ; 
 } 
 setMode ( Mode . JOINING , " getting bootstrap token " , true ) ; 
 - tokens = BootStrapper . getBootstrapTokens ( tokenMetadata ) ; 
 + bootstrapTokens = BootStrapper . getBootstrapTokens ( tokenMetadata ) ; 
 } 
 else 
 { 
 @ @ - 745 , 7 + 763 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 
 / / check for operator errors . . . 
 - for ( Token token : tokens ) 
 + for ( Token token : bootstrapTokens ) 
 { 
 InetAddress existing = tokenMetadata . getEndpoint ( token ) ; 
 if ( existing ! = null ) 
 @ @ - 773 , 46 + 791 , 46 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 
 } 
 - setMode ( Mode . JOINING , " Replacing a node with token ( s ) : " + tokens , true ) ; 
 + setMode ( Mode . JOINING , " Replacing a node with token ( s ) : " + bootstrapTokens , true ) ; 
 } 
 
 - bootstrap ( tokens ) ; 
 + bootstrap ( bootstrapTokens ) ; 
 assert ! isBootstrapMode ; / / bootstrap will block until finished 
 } 
 else 
 { 
 - tokens = SystemKeyspace . getSavedTokens ( ) ; 
 - if ( tokens . isEmpty ( ) ) 
 + bootstrapTokens = SystemKeyspace . getSavedTokens ( ) ; 
 + if ( bootstrapTokens . isEmpty ( ) ) 
 { 
 Collection < String > initialTokens = DatabaseDescriptor . getInitialTokens ( ) ; 
 if ( initialTokens . size ( ) < 1 ) 
 { 
 - tokens = BootStrapper . getRandomTokens ( tokenMetadata , DatabaseDescriptor . getNumTokens ( ) ) ; 
 + bootstrapTokens = BootStrapper . getRandomTokens ( tokenMetadata , DatabaseDescriptor . getNumTokens ( ) ) ; 
 if ( DatabaseDescriptor . getNumTokens ( ) = = 1 ) 
 - logger . warn ( " Generated random token " + tokens + " . Random tokens will result in an unbalanced ring ; see http : / / wiki . apache . org / cassandra / Operations " ) ; 
 + logger . warn ( " Generated random token " + bootstrapTokens + " . Random tokens will result in an unbalanced ring ; see http : / / wiki . apache . org / cassandra / Operations " ) ; 
 else 
 - logger . info ( " Generated random tokens . tokens are { } " , tokens ) ; 
 + logger . info ( " Generated random tokens . tokens are { } " , bootstrapTokens ) ; 
 } 
 else 
 { 
 - tokens = new ArrayList < Token > ( initialTokens . size ( ) ) ; 
 + bootstrapTokens = new ArrayList < Token > ( initialTokens . size ( ) ) ; 
 for ( String token : initialTokens ) 
 - tokens . add ( getPartitioner ( ) . getTokenFactory ( ) . fromString ( token ) ) ; 
 - logger . info ( " Saved tokens not found . Using configuration value : { } " , tokens ) ; 
 + bootstrapTokens . add ( getPartitioner ( ) . getTokenFactory ( ) . fromString ( token ) ) ; 
 + logger . info ( " Saved tokens not found . Using configuration value : { } " , bootstrapTokens ) ; 
 } 
 } 
 else 
 { 
 / / if we were already bootstrapped with 1 token but num _ tokens is set higher in the config , 
 / / then we need to migrate to multi - token 
 - if ( tokens . size ( ) = = 1 & & DatabaseDescriptor . getNumTokens ( ) > 1 ) 
 + if ( bootstrapTokens . size ( ) = = 1 & & DatabaseDescriptor . getNumTokens ( ) > 1 ) 
 { 
 / / wait for ring info 
 logger . info ( " Sleeping for ring delay ( " + delay + " ms ) " ) ; 
 Uninterruptibles . sleepUninterruptibly ( delay , TimeUnit . MILLISECONDS ) ; 
 logger . info ( " Calculating new tokens " ) ; 
 / / calculate num _ tokens tokens evenly spaced in the range ( left , right ] 
 - Token right = tokens . iterator ( ) . next ( ) ; 
 + Token right = bootstrapTokens . iterator ( ) . next ( ) ; 
 TokenMetadata clone = tokenMetadata . cloneOnlyTokenMap ( ) ; 
 clone . updateNormalToken ( right , FBUtilities . getBroadcastAddress ( ) ) ; 
 Token left = clone . getPredecessor ( right ) ; 
 @ @ - 842 , 12 + 860 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 r = midpoint ; 
 midpoint = getPartitioner ( ) . midpoint ( l , r ) ; 
 } 
 - tokens . add ( midpoint ) ; 
 + bootstrapTokens . add ( midpoint ) ; 
 } 
 - logger . info ( " Split previous range ( " + left + " , " + right + " ] into " + tokens ) ; 
 + logger . info ( " Split previous range ( " + left + " , " + right + " ] into " + bootstrapTokens ) ; 
 } 
 else 
 - logger . info ( " Using saved tokens " + tokens ) ; 
 + logger . info ( " Using saved tokens " + bootstrapTokens ) ; 
 } 
 } 
 
 @ @ - 862 , 7 + 880 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 / / start participating in the ring . 
 SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . COMPLETED ) ; 
 - setTokens ( tokens ) ; 
 + setTokens ( bootstrapTokens ) ; 
 / / remove the existing info about the replaced node . 
 if ( ! current . isEmpty ( ) ) 
 for ( InetAddress existing : current ) 
 @ @ - 1393 , 6 + 1411 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 break ; 
 case SCHEMA : 
 SystemKeyspace . updatePeerInfo ( endpoint , " schema _ version " , value . value ) ; 
 + MigrationManager . instance . scheduleSchemaPull ( endpoint , epState ) ; 
 break ; 
 case HOST _ ID : 
 SystemKeyspace . updatePeerInfo ( endpoint , " host _ id " , value . value ) ; 
 @ @ - 3442 , 6 + 3461 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 FBUtilities . waitOnFutures ( flushes ) ; 
 
 + BatchlogManager . batchlogTasks . shutdown ( ) ; 
 + BatchlogManager . batchlogTasks . awaitTermination ( 60 , TimeUnit . SECONDS ) ; 
 + 
 ColumnFamilyStore . postFlushExecutor . shutdown ( ) ; 
 ColumnFamilyStore . postFlushExecutor . awaitTermination ( 60 , TimeUnit . SECONDS ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / streaming / ConnectionHandler . java b / src / java / org / apache / cassandra / streaming / ConnectionHandler . java 
 index 356138b . . b06a818 100644 
 - - - a / src / java / org / apache / cassandra / streaming / ConnectionHandler . java 
 + + + b / src / java / org / apache / cassandra / streaming / ConnectionHandler . java 
 @ @ - 366 , 7 + 366 , 7 @ @ public class ConnectionHandler 
 { 
 throw new AssertionError ( e ) ; 
 } 
 - catch ( IOException e ) 
 + catch ( Throwable e ) 
 { 
 session . onError ( e ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 index 449751d . . 7976a40 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 @ @ - 462 , 7 + 462 , 11 @ @ public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDe 
 StreamingMetrics . totalOutgoingBytes . inc ( headerSize ) ; 
 metrics . outgoingBytes . inc ( headerSize ) ; 
 / / schedule timeout for receiving ACK 
 - transfers . get ( header . cfId ) . scheduleTimeout ( header . sequenceNumber , 12 , TimeUnit . HOURS ) ; 
 + StreamTransferTask task = transfers . get ( header . cfId ) ; 
 + if ( task ! = null ) 
 + { 
 + task . scheduleTimeout ( header . sequenceNumber , 12 , TimeUnit . HOURS ) ; 
 + } 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 index 86f4ee2 . . 7d0cc87 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 @ @ - 58 , 7 + 58 , 7 @ @ public class StreamTransferTask extends StreamTask 
 * 
 * @ param sequenceNumber sequence number of file 
 * / 
 - public void complete ( int sequenceNumber ) 
 + public synchronized void complete ( int sequenceNumber ) 
 { 
 OutgoingFileMessage file = files . remove ( sequenceNumber ) ; 
 if ( file ! = null ) 
 @ @ - 117 , 7 + 117 , 7 @ @ public class StreamTransferTask extends StreamTask 
 * @ param unit unit of given time 
 * @ return scheduled future for timeout task 
 * / 
 - public ScheduledFuture scheduleTimeout ( final int sequenceNumber , long time , TimeUnit unit ) 
 + public synchronized ScheduledFuture scheduleTimeout ( final int sequenceNumber , long time , TimeUnit unit ) 
 { 
 if ( timeoutExecutor . isShutdown ( ) ) 
 return null ;

NEAREST DIFF:
ELIMINATEDSENTENCE
