BLEU SCORE: 0.24808415001701817

TEST MSG: Change protocol to allow sending key space independent of query string
GENERATED MSG: Allow sending keyspace independent of query string

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 4f3cb3b . . dd33fcf 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Change protocol to allow sending key space independent of query string ( CASSANDRA - 10145 ) <nl> * Make gc _ log and gc _ warn settable at runtime ( CASSANDRA - 12661 ) <nl> * Take number of files in L0 in account when estimating remaining compaction tasks ( CASSANDRA - 13354 ) <nl> * Skip building views during base table streams on range movements ( CASSANDRA - 13065 ) <nl> diff - - git a / doc / native _ protocol _ v5 . spec b / doc / native _ protocol _ v5 . spec <nl> index ac3373c . . 320f6c0 100644 <nl> - - - a / doc / native _ protocol _ v5 . spec <nl> + + + b / doc / native _ protocol _ v5 . spec <nl> @ @ - 332 , 7 + 332 , 7 @ @ Table of Contents <nl> < query > < query _ parameters > <nl> where < query > is a [ long string ] representing the query and <nl> < query _ parameters > must be <nl> - < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] <nl> + < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] [ < keyspace > ] <nl> where : <nl> - < consistency > is the [ consistency ] level for the operation . <nl> - < flags > is a [ int ] whose bits define the options for this query and <nl> @ @ - 375 , 6 + 375 , 9 @ @ Table of Contents <nl> since the names for the expected values was returned during preparation , <nl> a client can always provide values in the right order without any names <nl> and using this flag , while supported , is almost surely inefficient . <nl> + 0x80 : With keyspace . If set , < keyspace > must be present . < keyspace > is a <nl> + [ string ] indicating the keyspace that the query should be executed in . <nl> + It supercedes the keyspace that the connection is bound to , if any . <nl> <nl> Note that the consistency is ignored by some queries ( USE , CREATE , ALTER , <nl> TRUNCATE , . . . ) . <nl> @ @ - 385 , 8 + 388 , 17 @ @ Table of Contents <nl> <nl> 4 . 1 . 5 . PREPARE <nl> <nl> - Prepare a query for later execution ( through EXECUTE ) . The body consists of <nl> - the CQL query to prepare as a [ long string ] . <nl> + Prepare a query for later execution ( through EXECUTE ) . The body of the message must be : <nl> + < query > < flags > [ < keyspace > ] <nl> + where : <nl> + - < query > is a [ long string ] representing the CQL query . <nl> + - < flags > is a [ int ] whose bits define the options for this statement and in particular <nl> + influence what the remainder of the message contains . <nl> + A flag is set if the bit corresponding to its ` mask ` is set . Supported <nl> + flags are , given their mask : <nl> + 0x01 : With keyspace . If set , < keyspace > must be present . < keyspace > is a <nl> + [ string ] indicating the keyspace that the query should be executed in . <nl> + It supercedes the keyspace that the connection is bound to , if any . <nl> <nl> The server will respond with a RESULT message with a ` prepared ` kind ( 0x0004 , <nl> see Section 4 . 2 . 5 ) . <nl> @ @ - 408 , 7 + 420 , 7 @ @ Table of Contents <nl> Allows executing a list of queries ( prepared or not ) as a batch ( note that <nl> only DML statements are accepted in a batch ) . The body of the message must <nl> be : <nl> - < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] <nl> + < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] [ < keyspace > ] <nl> where : <nl> - < type > is a [ byte ] indicating the type of batch to use : <nl> - If < type > = = 0 , the batch will be " logged " . This is equivalent to a <nl> @ @ - 440 , 6 + 452 , 9 @ @ Table of Contents <nl> to implement . This will be fixed in a future version of the native <nl> protocol . See https : / / issues . apache . org / jira / browse / CASSANDRA - 10246 for <nl> more details ] . <nl> + 0x80 : With keyspace . If set , < keyspace > must be present . < keyspace > is a <nl> + [ string ] indicating the keyspace that the query should be executed in . <nl> + It supercedes the keyspace that the connection is bound to , if any . <nl> - < n > is a [ short ] indicating the number of following queries . <nl> - < query _ 1 > . . . < query _ n > are the queries to execute . A < query _ i > must be of the <nl> form : <nl> @ @ - 1211 , 3 + 1226 , 5 @ @ Table of Contents <nl> * Enlarged flag ' s bitmaps for QUERY , EXECUTE and BATCH messages from [ byte ] to [ int ] <nl> ( Sections 4 . 1 . 4 , 4 . 1 . 6 and 4 . 1 . 7 ) . <nl> * Add the duration data type <nl> + * Added keyspace field in QUERY , PREPARE , and BATCH messages ( Sections 4 . 1 . 4 , 4 . 1 . 5 , and 4 . 1 . 7 ) . <nl> + * Added [ int ] flags field in PREPARE message ( Section 4 . 1 . 5 ) . <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> index db7fa39 . . 3d3cda0 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public abstract class BatchQueryOptions <nl> return wrapped . getConsistency ( ) ; <nl> } <nl> <nl> + public String getKeyspace ( ) <nl> + { <nl> + return wrapped . getKeyspace ( ) ; <nl> + } <nl> + <nl> public ConsistencyLevel getSerialConsistency ( ) <nl> { <nl> return wrapped . getSerialConsistency ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java b / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java <nl> index aa8ca48 . . 32cddba 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ import java . util . Map ; <nl> <nl> import org . apache . cassandra . cql3 . statements . BatchStatement ; <nl> import org . apache . cassandra . cql3 . statements . ParsedStatement ; <nl> + import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . QueryState ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> import org . apache . cassandra . utils . MD5Digest ; <nl> @ @ - 46 , 9 + 47 , 9 @ @ public class CustomPayloadMirroringQueryHandler implements QueryHandler <nl> return result ; <nl> } <nl> <nl> - public ResultMessage . Prepared prepare ( String query , QueryState state , Map < String , ByteBuffer > customPayload ) <nl> + public ResultMessage . Prepared prepare ( String query , ClientState clientState , Map < String , ByteBuffer > customPayload ) <nl> { <nl> - ResultMessage . Prepared prepared = queryProcessor . prepare ( query , state , customPayload ) ; <nl> + ResultMessage . Prepared prepared = queryProcessor . prepare ( query , clientState , customPayload ) ; <nl> prepared . setCustomPayload ( customPayload ) ; <nl> return prepared ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryHandler . java b / src / java / org / apache / cassandra / cql3 / QueryHandler . java <nl> index 0339d26 . . d3b41f0 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryHandler . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryHandler . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import org . apache . cassandra . cql3 . statements . BatchStatement ; <nl> import org . apache . cassandra . cql3 . statements . ParsedStatement ; <nl> import org . apache . cassandra . exceptions . RequestExecutionException ; <nl> import org . apache . cassandra . exceptions . RequestValidationException ; <nl> + import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . QueryState ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> import org . apache . cassandra . utils . MD5Digest ; <nl> @ @ - 37 , 7 + 38 , 7 @ @ public interface QueryHandler <nl> long queryStartNanoTime ) throws RequestExecutionException , RequestValidationException ; <nl> <nl> ResultMessage . Prepared prepare ( String query , <nl> - QueryState state , <nl> + ClientState clientState , <nl> Map < String , ByteBuffer > customPayload ) throws RequestValidationException ; <nl> <nl> ParsedStatement . Prepared getPrepared ( MD5Digest id ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryOptions . java b / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> index afe20d7 . . 01df691 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> @ @ - 67 , 9 + 67 , 9 @ @ public abstract class QueryOptions <nl> return new DefaultQueryOptions ( null , null , true , null , protocolVersion ) ; <nl> } <nl> <nl> - public static QueryOptions create ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , int pageSize , PagingState pagingState , ConsistencyLevel serialConsistency , ProtocolVersion version ) <nl> + public static QueryOptions create ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , int pageSize , PagingState pagingState , ConsistencyLevel serialConsistency , ProtocolVersion version , String keyspace ) <nl> { <nl> - return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L ) , version ) ; <nl> + return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L , keyspace ) , version ) ; <nl> } <nl> <nl> public static QueryOptions addColumnSpecifications ( QueryOptions options , List < ColumnSpecification > columnSpecs ) <nl> @ @ - 86 , 11 + 86 , 11 @ @ public abstract class QueryOptions <nl> * <nl> * This is functionally equivalent to : <nl> * { @ code Json . parseJson ( UTF8Type . instance . getSerializer ( ) . deserialize ( getValues ( ) . get ( bindIndex ) ) , expectedReceivers ) . get ( columnName ) } <nl> - * but this cache the result of parsing the JSON so that while this might be called for multiple columns on the same { @ code bindIndex } <nl> + * but this caches the result of parsing the JSON , so that while this might be called for multiple columns on the same { @ code bindIndex } <nl> * value , the underlying JSON value is only parsed / processed once . <nl> * <nl> - * Note : this is a bit more involved in CQL specifics than this class generally is but we as we need to cache this per - query and in an object <nl> - * that is available when we bind values , this is the easier place to have this . <nl> + * Note : this is a bit more involved in CQL specifics than this class generally is , but as we need to cache this per - query and in an object <nl> + * that is available when we bind values , this is the easiest place to have this . <nl> * <nl> * @ param bindIndex the index of the bind value that should be interpreted as a JSON value . <nl> * @ param columnName the name of the column we want the value of . <nl> @ @ - 136 , 7 + 136 , 7 @ @ public abstract class QueryOptions <nl> * <nl> * < p > The column specifications will be present only for prepared statements . < / p > <nl> * <nl> - * < p > Invoke the { @ link hasColumnSpecifications } method before invoking this method in order to ensure that this <nl> + * < p > Invoke the { @ link # hasColumnSpecifications } method before invoking this method in order to ensure that this <nl> * < code > QueryOptions < / code > contains the column specifications . < / p > <nl> * <nl> * @ return the option names <nl> @ @ - 172 , 6 + 172 , 9 @ @ public abstract class QueryOptions <nl> return tstamp ! = Long . MIN _ VALUE ? tstamp : state . getTimestamp ( ) ; <nl> } <nl> <nl> + / * * The keyspace that this query is bound to , or null if not relevant . * / <nl> + public String getKeyspace ( ) { return getSpecificOptions ( ) . keyspace ; } <nl> + <nl> / * * <nl> * The protocol version for the query . <nl> * / <nl> @ @ - 314 , 7 + 317 , 7 @ @ public abstract class QueryOptions <nl> { <nl> super . prepare ( specs ) ; <nl> <nl> - orderedValues = new ArrayList < ByteBuffer > ( specs . size ( ) ) ; <nl> + orderedValues = new ArrayList < > ( specs . size ( ) ) ; <nl> for ( int i = 0 ; i < specs . size ( ) ; i + + ) <nl> { <nl> String name = specs . get ( i ) . name . toString ( ) ; <nl> @ @ - 341 , 19 + 344 , 21 @ @ public abstract class QueryOptions <nl> / / Options that are likely to not be present in most queries <nl> static class SpecificOptions <nl> { <nl> - private static final SpecificOptions DEFAULT = new SpecificOptions ( - 1 , null , null , Long . MIN _ VALUE ) ; <nl> + private static final SpecificOptions DEFAULT = new SpecificOptions ( - 1 , null , null , Long . MIN _ VALUE , null ) ; <nl> <nl> private final int pageSize ; <nl> private final PagingState state ; <nl> private final ConsistencyLevel serialConsistency ; <nl> private final long timestamp ; <nl> + private final String keyspace ; <nl> <nl> - private SpecificOptions ( int pageSize , PagingState state , ConsistencyLevel serialConsistency , long timestamp ) <nl> + private SpecificOptions ( int pageSize , PagingState state , ConsistencyLevel serialConsistency , long timestamp , String keyspace ) <nl> { <nl> this . pageSize = pageSize ; <nl> this . state = state ; <nl> this . serialConsistency = serialConsistency = = null ? ConsistencyLevel . SERIAL : serialConsistency ; <nl> this . timestamp = timestamp ; <nl> + this . keyspace = keyspace ; <nl> } <nl> } <nl> <nl> @ @ - 368 , 7 + 373 , 8 @ @ public abstract class QueryOptions <nl> PAGING _ STATE , <nl> SERIAL _ CONSISTENCY , <nl> TIMESTAMP , <nl> - NAMES _ FOR _ VALUES ; <nl> + NAMES _ FOR _ VALUES , <nl> + KEYSPACE ; <nl> <nl> private static final Flag [ ] ALL _ VALUES = values ( ) ; <nl> <nl> @ @ - 433 , 8 + 439 , 8 @ @ public abstract class QueryOptions <nl> throw new ProtocolException ( String . format ( " Out of bound timestamp , must be in [ % d , % d ] ( got % d ) " , Long . MIN _ VALUE + 1 , Long . MAX _ VALUE , ts ) ) ; <nl> timestamp = ts ; <nl> } <nl> - <nl> - options = new SpecificOptions ( pageSize , pagingState , serialConsistency , timestamp ) ; <nl> + String keyspace = flags . contains ( Flag . KEYSPACE ) ? CBUtil . readString ( body ) : null ; <nl> + options = new SpecificOptions ( pageSize , pagingState , serialConsistency , timestamp , keyspace ) ; <nl> } <nl> DefaultQueryOptions opts = new DefaultQueryOptions ( consistency , values , skipMetadata , options , version ) ; <nl> return names = = null ? opts : new OptionsWithNames ( opts , names ) ; <nl> @ @ - 460 , 6 + 466 , 8 @ @ public abstract class QueryOptions <nl> CBUtil . writeConsistencyLevel ( options . getSerialConsistency ( ) , dest ) ; <nl> if ( flags . contains ( Flag . TIMESTAMP ) ) <nl> dest . writeLong ( options . getSpecificOptions ( ) . timestamp ) ; <nl> + if ( flags . contains ( Flag . KEYSPACE ) ) <nl> + CBUtil . writeString ( options . getSpecificOptions ( ) . keyspace , dest ) ; <nl> <nl> / / Note that we don ' t really have to bother with NAMES _ FOR _ VALUES server side , <nl> / / and in fact we never really encode QueryOptions , only decode them , so we <nl> @ @ - 485 , 7 + 493 , 8 @ @ public abstract class QueryOptions <nl> size + = CBUtil . sizeOfConsistencyLevel ( options . getSerialConsistency ( ) ) ; <nl> if ( flags . contains ( Flag . TIMESTAMP ) ) <nl> size + = 8 ; <nl> - <nl> + if ( flags . contains ( Flag . KEYSPACE ) ) <nl> + size + = CBUtil . sizeOfString ( options . getSpecificOptions ( ) . keyspace ) ; <nl> return size ; <nl> } <nl> <nl> @ @ - 504 , 6 + 513 , 8 @ @ public abstract class QueryOptions <nl> flags . add ( Flag . SERIAL _ CONSISTENCY ) ; <nl> if ( options . getSpecificOptions ( ) . timestamp ! = Long . MIN _ VALUE ) <nl> flags . add ( Flag . TIMESTAMP ) ; <nl> + if ( options . getSpecificOptions ( ) . keyspace ! = null ) <nl> + flags . add ( Flag . KEYSPACE ) ; <nl> return flags ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> index 4aa2026 . . cca93ff 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> @ @ - 219 , 7 + 219 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> public ResultMessage process ( String queryString , QueryState queryState , QueryOptions options , long queryStartNanoTime ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> - ParsedStatement . Prepared p = getStatement ( queryString , queryState . getClientState ( ) ) ; <nl> + ParsedStatement . Prepared p = getStatement ( queryString , queryState . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ) ; <nl> options . prepare ( p . boundNames ) ; <nl> CQLStatement prepared = p . statement ; <nl> if ( prepared . getBoundTerms ( ) ! = options . getValues ( ) . size ( ) ) <nl> @ @ - 231 , 9 + 231 , 9 @ @ public class QueryProcessor implements QueryHandler <nl> return processStatement ( prepared , queryState , options , queryStartNanoTime ) ; <nl> } <nl> <nl> - public static ParsedStatement . Prepared parseStatement ( String queryStr , QueryState queryState ) throws RequestValidationException <nl> + public static ParsedStatement . Prepared parseStatement ( String queryStr , ClientState clientState ) throws RequestValidationException <nl> { <nl> - return getStatement ( queryStr , queryState . getClientState ( ) ) ; <nl> + return getStatement ( queryStr , clientState ) ; <nl> } <nl> <nl> public static UntypedResultSet process ( String query , ConsistencyLevel cl ) throws RequestExecutionException <nl> @ @ - 277 , 7 + 277 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> return prepared ; <nl> <nl> / / Note : if 2 threads prepare the same query , we ' ll live so don ' t bother synchronizing <nl> - prepared = parseStatement ( query , internalQueryState ( ) ) ; <nl> + prepared = parseStatement ( query , internalQueryState ( ) . getClientState ( ) ) ; <nl> prepared . statement . validate ( internalQueryState ( ) . getClientState ( ) ) ; <nl> internalStatements . putIfAbsent ( query , prepared ) ; <nl> return prepared ; <nl> @ @ - 334 , 7 + 334 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> * / <nl> public static UntypedResultSet executeOnceInternal ( String query , Object . . . values ) <nl> { <nl> - ParsedStatement . Prepared prepared = parseStatement ( query , internalQueryState ( ) ) ; <nl> + ParsedStatement . Prepared prepared = parseStatement ( query , internalQueryState ( ) . getClientState ( ) ) ; <nl> prepared . statement . validate ( internalQueryState ( ) . getClientState ( ) ) ; <nl> ResultMessage result = prepared . statement . executeInternal ( internalQueryState ( ) , makeInternalOptions ( prepared , values ) ) ; <nl> if ( result instanceof ResultMessage . Rows ) <nl> @ @ - 374 , 16 + 374 , 10 @ @ public class QueryProcessor implements QueryHandler <nl> } <nl> <nl> public ResultMessage . Prepared prepare ( String query , <nl> - QueryState state , <nl> + ClientState clientState , <nl> Map < String , ByteBuffer > customPayload ) throws RequestValidationException <nl> { <nl> - return prepare ( query , state ) ; <nl> - } <nl> - <nl> - public ResultMessage . Prepared prepare ( String queryString , QueryState queryState ) <nl> - { <nl> - ClientState cState = queryState . getClientState ( ) ; <nl> - return prepare ( queryString , cState ) ; <nl> + return prepare ( query , clientState ) ; <nl> } <nl> <nl> public static ResultMessage . Prepared prepare ( String queryString , ClientState clientState ) <nl> @ @ - 485 , 7 + 479 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> public ResultMessage processBatch ( BatchStatement batch , QueryState queryState , BatchQueryOptions options , long queryStartNanoTime ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> - ClientState clientState = queryState . getClientState ( ) ; <nl> + ClientState clientState = queryState . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ; <nl> batch . checkAccess ( clientState ) ; <nl> batch . validate ( ) ; <nl> batch . validate ( clientState ) ; <nl> @ @ - 500 , 7 + 494 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> <nl> / / Set keyspace for statement that require login <nl> if ( statement instanceof CFStatement ) <nl> - ( ( CFStatement ) statement ) . prepareKeyspace ( clientState ) ; <nl> + ( ( CFStatement ) statement ) . prepareKeyspace ( clientState ) ; <nl> <nl> Tracing . trace ( " Preparing statement " ) ; <nl> return statement . prepare ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java <nl> index 9b2987c . . 136860e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java <nl> @ @ - 37 , 14 + 37 , 16 @ @ public abstract class CFStatement extends ParsedStatement <nl> { <nl> if ( ! cfName . hasKeyspace ( ) ) <nl> { <nl> - / / XXX : We explicitely only want to call state . getKeyspace ( ) in this case , as we don ' t want to throw <nl> - / / if not logged in any keyspace but a keyspace is explicitely set on the statement . So don ' t move <nl> + / / XXX : We explicitly only want to call state . getKeyspace ( ) in this case , as we don ' t want to throw <nl> + / / if not logged in any keyspace but a keyspace is explicitly set on the statement . So don ' t move <nl> / / the call outside the ' if ' or replace the method by ' prepareKeyspace ( state . getKeyspace ( ) ) ' <nl> cfName . setKeyspace ( state . getKeyspace ( ) , true ) ; <nl> } <nl> } <nl> <nl> - / / Only for internal calls , use the version with ClientState for user queries <nl> + / / Only for internal calls , use the version with ClientState for user queries . In particular , the <nl> + / / version with ClientState throws an exception if the statement does not have keyspace set * and * <nl> + / / ClientState has no keyspace . <nl> public void prepareKeyspace ( String keyspace ) <nl> { <nl> if ( ! cfName . hasKeyspace ( ) ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java <nl> index 0cd549a . . e617ba7 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java <nl> @ @ - 51 , 7 + 51 , 7 @ @ public abstract class ParsedStatement <nl> / * * <nl> * Contains the CQL statement source if the statement has been " regularly " perpared via <nl> * { @ link org . apache . cassandra . cql3 . QueryProcessor # prepare ( java . lang . String , org . apache . cassandra . service . ClientState ) } / <nl> - * { @ link QueryHandler # prepare ( java . lang . String , org . apache . cassandra . service . QueryState , java . util . Map ) } . <nl> + * { @ link QueryHandler # prepare ( java . lang . String , org . apache . cassandra . service . ClientState , java . util . Map ) } . <nl> * Other usages of this class may or may not contain the CQL statement source . <nl> * / <nl> public String rawCQLStatement ; <nl> diff - - git a / src / java / org / apache / cassandra / service / ClientState . java b / src / java / org / apache / cassandra / service / ClientState . java <nl> index 80cf810 . . dfddccd 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ClientState . java <nl> + + + b / src / java / org / apache / cassandra / service / ClientState . java <nl> @ @ - 139 , 6 + 139 , 14 @ @ public class ClientState <nl> this . user = AuthenticatedUser . ANONYMOUS _ USER ; <nl> } <nl> <nl> + protected ClientState ( ClientState source ) <nl> + { <nl> + this . isInternal = source . isInternal ; <nl> + this . remoteAddress = source . remoteAddress ; <nl> + this . user = source . user ; <nl> + this . keyspace = source . keyspace ; <nl> + } <nl> + <nl> / * * <nl> * @ return a ClientState object for internal C * calls ( not limited by any kind of auth ) . <nl> * / <nl> @ @ - 156 , 6 + 164 , 22 @ @ public class ClientState <nl> } <nl> <nl> / * * <nl> + * Clone this ClientState object , but use the provided keyspace instead of the <nl> + * keyspace in this ClientState object . <nl> + * <nl> + * @ return a new ClientState object if the keyspace argument is non - null . Otherwise do not clone <nl> + * and return this ClientState object . <nl> + * / <nl> + public ClientState cloneWithKeyspaceIfSet ( String keyspace ) <nl> + { <nl> + if ( keyspace = = null ) <nl> + return this ; <nl> + ClientState clientState = new ClientState ( this ) ; <nl> + clientState . setKeyspace ( keyspace ) ; <nl> + return clientState ; <nl> + } <nl> + <nl> + / * * <nl> * This clock guarantees that updates for the same ClientState will be ordered <nl> * in the sequence seen , even if multiple updates happen in the same millisecond . <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / transport / Client . java b / src / java / org / apache / cassandra / transport / Client . java <nl> index e428b06 . . 9a76e03 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Client . java <nl> + + + b / src / java / org / apache / cassandra / transport / Client . java <nl> @ @ - 136 , 12 + 136 , 12 @ @ public class Client extends SimpleClient <nl> return null ; <nl> } <nl> } <nl> - return new QueryMessage ( query , QueryOptions . create ( ConsistencyLevel . ONE , Collections . < ByteBuffer > emptyList ( ) , false , pageSize , null , null , version ) ) ; <nl> + return new QueryMessage ( query , QueryOptions . create ( ConsistencyLevel . ONE , Collections . < ByteBuffer > emptyList ( ) , false , pageSize , null , null , version , null ) ) ; <nl> } <nl> else if ( msgType . equals ( " PREPARE " ) ) <nl> { <nl> String query = line . substring ( 8 ) ; <nl> - return new PrepareMessage ( query ) ; <nl> + return new PrepareMessage ( query , null ) ; <nl> } <nl> else if ( msgType . equals ( " EXECUTE " ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / transport / SimpleClient . java b / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> index 1bb081b . . 13cd9bd 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> + + + b / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> @ @ - 189 , 7 + 189 , 7 @ @ public class SimpleClient implements Closeable <nl> <nl> public ResultMessage . Prepared prepare ( String query ) <nl> { <nl> - Message . Response msg = execute ( new PrepareMessage ( query ) ) ; <nl> + Message . Response msg = execute ( new PrepareMessage ( query , null ) ) ; <nl> assert msg instanceof ResultMessage . Prepared ; <nl> return ( ResultMessage . Prepared ) msg ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> index bb6411f . . d9123d4 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> + + + b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> @ @ - 180 , 7 + 180 , 8 @ @ public class BatchMessage extends Message . Request <nl> ParsedStatement . Prepared p ; <nl> if ( query instanceof String ) <nl> { <nl> - p = QueryProcessor . parseStatement ( ( String ) query , state ) ; <nl> + p = QueryProcessor . parseStatement ( ( String ) query , <nl> + state . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java b / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java <nl> index b0c9dbe . . bb0fc3a 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java <nl> + + + b / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java <nl> @ @ - 36 , 26 + 36 , 59 @ @ public class PrepareMessage extends Message . Request <nl> public PrepareMessage decode ( ByteBuf body , ProtocolVersion version ) <nl> { <nl> String query = CBUtil . readLongString ( body ) ; <nl> - return new PrepareMessage ( query ) ; <nl> + String keyspace = null ; <nl> + if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) { <nl> + / / If flags grows , we may want to consider creating a PrepareOptions class with an internal codec <nl> + / / class that handles flags and options of the prepare message . Since there ' s only one right now , <nl> + / / we just take care of business here . <nl> + <nl> + int flags = ( int ) body . readUnsignedInt ( ) ; <nl> + if ( ( flags & 0x1 ) = = 0x1 ) <nl> + keyspace = CBUtil . readString ( body ) ; <nl> + } <nl> + return new PrepareMessage ( query , keyspace ) ; <nl> } <nl> <nl> public void encode ( PrepareMessage msg , ByteBuf dest , ProtocolVersion version ) <nl> { <nl> CBUtil . writeLongString ( msg . query , dest ) ; <nl> + if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) <nl> + { <nl> + / / If we have no keyspace , write out a 0 - valued flag field . <nl> + if ( msg . keyspace = = null ) <nl> + dest . writeInt ( 0x0 ) ; <nl> + else { <nl> + dest . writeInt ( 0x1 ) ; <nl> + CBUtil . writeString ( msg . keyspace , dest ) ; <nl> + } <nl> + } <nl> } <nl> <nl> public int encodedSize ( PrepareMessage msg , ProtocolVersion version ) <nl> { <nl> - return CBUtil . sizeOfLongString ( msg . query ) ; <nl> + int size = CBUtil . sizeOfLongString ( msg . query ) ; <nl> + if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) <nl> + { <nl> + / / We always emit a flags int <nl> + size + = 4 ; <nl> + <nl> + / / If we have a keyspace , we ' d write it out . Otherwise , we ' d write nothing . <nl> + size + = msg . keyspace = = null <nl> + ? 0 <nl> + : CBUtil . sizeOfString ( msg . keyspace ) ; <nl> + } <nl> + return size ; <nl> } <nl> } ; <nl> <nl> private final String query ; <nl> + private final String keyspace ; <nl> <nl> - public PrepareMessage ( String query ) <nl> + public PrepareMessage ( String query , String keyspace ) <nl> { <nl> super ( Message . Type . PREPARE ) ; <nl> this . query = query ; <nl> + this . keyspace = keyspace ; <nl> } <nl> <nl> public Message . Response execute ( QueryState state , long queryStartNanoTime ) <nl> @ @ - 75 , 7 + 108 , 9 @ @ public class PrepareMessage extends Message . Request <nl> Tracing . instance . begin ( " Preparing CQL3 query " , state . getClientAddress ( ) , ImmutableMap . of ( " query " , query ) ) ; <nl> } <nl> <nl> - Message . Response response = ClientState . getCQLQueryHandler ( ) . prepare ( query , state , getCustomPayload ( ) ) ; <nl> + Message . Response response = ClientState . getCQLQueryHandler ( ) . prepare ( query , <nl> + state . getClientState ( ) . cloneWithKeyspaceIfSet ( keyspace ) , <nl> + getCustomPayload ( ) ) ; <nl> <nl> if ( tracingId ! = null ) <nl> response . setTracingId ( tracingId ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> index c247d96 . . 26437c9 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> @ @ - 710 , 7 + 710 , 7 @ @ public abstract class CQLTester <nl> state . setKeyspace ( SchemaConstants . SYSTEM _ KEYSPACE _ NAME ) ; <nl> QueryState queryState = new QueryState ( state ) ; <nl> <nl> - ParsedStatement . Prepared prepared = QueryProcessor . parseStatement ( query , queryState ) ; <nl> + ParsedStatement . Prepared prepared = QueryProcessor . parseStatement ( query , queryState . getClientState ( ) ) ; <nl> prepared . statement . validate ( state ) ; <nl> <nl> QueryOptions options = QueryOptions . forInternalCalls ( Collections . < ByteBuffer > emptyList ( ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java b / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java <nl> index cfbfd39 . . c27593b 100644 <nl> - - - a / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java <nl> + + + b / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java <nl> @ @ - 48 , 6 + 48 , 7 @ @ import org . apache . cassandra . transport . messages . QueryMessage ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> import org . apache . cassandra . utils . MD5Digest ; <nl> <nl> + import static org . apache . cassandra . config . EncryptionOptions . ClientEncryptionOptions ; <nl> import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; <nl> <nl> public class MessagePayloadTest extends CQLTester <nl> @ @ - 112 , 6 + 113 , 86 @ @ public class MessagePayloadTest extends CQLTester <nl> } <nl> <nl> @ Test <nl> + public void testMessagePayloadBeta ( ) throws Throwable <nl> + { <nl> + QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; <nl> + cqlQueryHandlerField . set ( null , new TestQueryHandler ( ) ) ; <nl> + try <nl> + { <nl> + requireNetwork ( ) ; <nl> + <nl> + Assert . assertSame ( TestQueryHandler . class , ClientState . getCQLQueryHandler ( ) . getClass ( ) ) ; <nl> + <nl> + SimpleClient client = new SimpleClient ( nativeAddr . getHostAddress ( ) , <nl> + nativePort , <nl> + ProtocolVersion . V5 , <nl> + true , <nl> + new ClientEncryptionOptions ( ) ) ; <nl> + try <nl> + { <nl> + client . connect ( false ) ; <nl> + <nl> + Map < String , ByteBuffer > reqMap ; <nl> + Map < String , ByteBuffer > respMap ; <nl> + <nl> + QueryOptions queryOptions = QueryOptions . create ( <nl> + QueryOptions . DEFAULT . getConsistency ( ) , <nl> + QueryOptions . DEFAULT . getValues ( ) , <nl> + QueryOptions . DEFAULT . skipMetadata ( ) , <nl> + QueryOptions . DEFAULT . getPageSize ( ) , <nl> + QueryOptions . DEFAULT . getPagingState ( ) , <nl> + QueryOptions . DEFAULT . getSerialConsistency ( ) , <nl> + ProtocolVersion . V5 , <nl> + KEYSPACE ) ; <nl> + QueryMessage queryMessage = new QueryMessage ( " CREATE TABLE atable ( pk int PRIMARY KEY , v text ) " , <nl> + queryOptions ) ; <nl> + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM atable " , KEYSPACE ) ; <nl> + <nl> + reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; <nl> + responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; <nl> + queryMessage . setCustomPayload ( reqMap ) ; <nl> + Message . Response queryResponse = client . execute ( queryMessage ) ; <nl> + payloadEquals ( reqMap , requestPayload ) ; <nl> + payloadEquals ( respMap , queryResponse . getCustomPayload ( ) ) ; <nl> + <nl> + reqMap = Collections . singletonMap ( " foo " , bytes ( 43 ) ) ; <nl> + responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 43 ) ) ; <nl> + prepareMessage . setCustomPayload ( reqMap ) ; <nl> + ResultMessage . Prepared prepareResponse = ( ResultMessage . Prepared ) client . execute ( prepareMessage ) ; <nl> + payloadEquals ( reqMap , requestPayload ) ; <nl> + payloadEquals ( respMap , prepareResponse . getCustomPayload ( ) ) ; <nl> + <nl> + ExecuteMessage executeMessage = new ExecuteMessage ( prepareResponse . statementId , QueryOptions . DEFAULT ) ; <nl> + reqMap = Collections . singletonMap ( " foo " , bytes ( 44 ) ) ; <nl> + responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 44 ) ) ; <nl> + executeMessage . setCustomPayload ( reqMap ) ; <nl> + Message . Response executeResponse = client . execute ( executeMessage ) ; <nl> + payloadEquals ( reqMap , requestPayload ) ; <nl> + payloadEquals ( respMap , executeResponse . getCustomPayload ( ) ) ; <nl> + <nl> + BatchMessage batchMessage = new BatchMessage ( BatchStatement . Type . UNLOGGED , <nl> + Collections . < Object > singletonList ( " INSERT INTO atable ( pk , v ) VALUES ( 1 , ' foo ' ) " ) , <nl> + Collections . singletonList ( Collections . < ByteBuffer > emptyList ( ) ) , <nl> + queryOptions ) ; <nl> + reqMap = Collections . singletonMap ( " foo " , bytes ( 45 ) ) ; <nl> + responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 45 ) ) ; <nl> + batchMessage . setCustomPayload ( reqMap ) ; <nl> + Message . Response batchResponse = client . execute ( batchMessage ) ; <nl> + payloadEquals ( reqMap , requestPayload ) ; <nl> + payloadEquals ( respMap , batchResponse . getCustomPayload ( ) ) ; <nl> + } <nl> + finally <nl> + { <nl> + client . close ( ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + cqlQueryHandlerField . set ( null , queryHandler ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> public void testMessagePayload ( ) throws Throwable <nl> { <nl> QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; <nl> @ @ - 134 , 7 + 215 , 7 @ @ public class MessagePayloadTest extends CQLTester <nl> " CREATE TABLE " + KEYSPACE + " . atable ( pk int PRIMARY KEY , v text ) " , <nl> QueryOptions . DEFAULT <nl> ) ; <nl> - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " ) ; <nl> + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " , null ) ; <nl> <nl> reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; <nl> responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; <nl> @ @ - 202 , 7 + 283 , 7 @ @ public class MessagePayloadTest extends CQLTester <nl> " CREATE TABLE " + KEYSPACE + " . atable ( pk int PRIMARY KEY , v text ) " , <nl> QueryOptions . DEFAULT <nl> ) ; <nl> - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " ) ; <nl> + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " , null ) ; <nl> <nl> reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; <nl> responsePayload = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; <nl> @ @ - 293 , 13 + 374 , 13 @ @ public class MessagePayloadTest extends CQLTester <nl> } <nl> <nl> public ResultMessage . Prepared prepare ( String query , <nl> - QueryState state , <nl> + ClientState clientState , <nl> Map < String , ByteBuffer > customPayload ) <nl> throws RequestValidationException <nl> { <nl> if ( customPayload ! = null ) <nl> requestPayload = customPayload ; <nl> - ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , state , customPayload ) ; <nl> + ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , clientState , customPayload ) ; <nl> if ( customPayload ! = null ) <nl> { <nl> result . setCustomPayload ( responsePayload ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / transport / SerDeserTest . java b / test / unit / org / apache / cassandra / transport / SerDeserTest . java <nl> index a1260ba . . 2592ae7 100644 <nl> - - - a / test / unit / org / apache / cassandra / transport / SerDeserTest . java <nl> + + + b / test / unit / org / apache / cassandra / transport / SerDeserTest . java <nl> @ @ - 314 , 15 + 314 , 30 @ @ public class SerDeserTest <nl> <nl> private void queryOptionsSerDeserTest ( ProtocolVersion version ) throws Exception <nl> { <nl> - QueryOptions options = QueryOptions . create ( ConsistencyLevel . ALL , <nl> - Collections . singletonList ( ByteBuffer . wrap ( new byte [ ] { 0x00 , 0x01 , 0x02 } ) ) , <nl> - false , <nl> - 5000 , <nl> - Util . makeSomePagingState ( version ) , <nl> - ConsistencyLevel . SERIAL , <nl> - version <nl> - ) ; <nl> + queryOptionsSerDeserTest ( version , QueryOptions . create ( ConsistencyLevel . ALL , <nl> + Collections . singletonList ( ByteBuffer . wrap ( new byte [ ] { 0x00 , 0x01 , 0x02 } ) ) , <nl> + false , <nl> + 5000 , <nl> + Util . makeSomePagingState ( version ) , <nl> + ConsistencyLevel . SERIAL , <nl> + version , <nl> + null <nl> + ) ) ; <nl> + <nl> + queryOptionsSerDeserTest ( version , QueryOptions . create ( ConsistencyLevel . LOCAL _ ONE , <nl> + Arrays . asList ( ByteBuffer . wrap ( new byte [ ] { 0x00 , 0x01 , 0x02 } ) , <nl> + ByteBuffer . wrap ( new byte [ ] { 0x03 , 0x04 , 0x05 , 0x03 , 0x04 , 0x05 } ) ) , <nl> + true , <nl> + 10 , <nl> + Util . makeSomePagingState ( version ) , <nl> + ConsistencyLevel . SERIAL , <nl> + version , <nl> + " some _ keyspace " <nl> + ) ) ; <nl> + } <nl> <nl> + private void queryOptionsSerDeserTest ( ProtocolVersion version , QueryOptions options ) <nl> + { <nl> ByteBuf buf = Unpooled . buffer ( QueryOptions . codec . encodedSize ( options , version ) ) ; <nl> QueryOptions . codec . encode ( options , buf , version ) ; <nl> QueryOptions decodedOptions = QueryOptions . codec . decode ( buf , version ) ; <nl> @ @ - 335 , 5 + 350 , 6 @ @ public class SerDeserTest <nl> assertEquals ( options . getValues ( ) , decodedOptions . getValues ( ) ) ; <nl> assertEquals ( options . getPagingState ( ) , decodedOptions . getPagingState ( ) ) ; <nl> assertEquals ( options . skipMetadata ( ) , decodedOptions . skipMetadata ( ) ) ; <nl> + assertEquals ( options . getKeyspace ( ) , decodedOptions . getKeyspace ( ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 4f3cb3b . . dd33fcf 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Change protocol to allow sending key space independent of query string ( CASSANDRA - 10145 ) 
 * Make gc _ log and gc _ warn settable at runtime ( CASSANDRA - 12661 ) 
 * Take number of files in L0 in account when estimating remaining compaction tasks ( CASSANDRA - 13354 ) 
 * Skip building views during base table streams on range movements ( CASSANDRA - 13065 ) 
 diff - - git a / doc / native _ protocol _ v5 . spec b / doc / native _ protocol _ v5 . spec 
 index ac3373c . . 320f6c0 100644 
 - - - a / doc / native _ protocol _ v5 . spec 
 + + + b / doc / native _ protocol _ v5 . spec 
 @ @ - 332 , 7 + 332 , 7 @ @ Table of Contents 
 < query > < query _ parameters > 
 where < query > is a [ long string ] representing the query and 
 < query _ parameters > must be 
 - < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] 
 + < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] [ < keyspace > ] 
 where : 
 - < consistency > is the [ consistency ] level for the operation . 
 - < flags > is a [ int ] whose bits define the options for this query and 
 @ @ - 375 , 6 + 375 , 9 @ @ Table of Contents 
 since the names for the expected values was returned during preparation , 
 a client can always provide values in the right order without any names 
 and using this flag , while supported , is almost surely inefficient . 
 + 0x80 : With keyspace . If set , < keyspace > must be present . < keyspace > is a 
 + [ string ] indicating the keyspace that the query should be executed in . 
 + It supercedes the keyspace that the connection is bound to , if any . 
 
 Note that the consistency is ignored by some queries ( USE , CREATE , ALTER , 
 TRUNCATE , . . . ) . 
 @ @ - 385 , 8 + 388 , 17 @ @ Table of Contents 
 
 4 . 1 . 5 . PREPARE 
 
 - Prepare a query for later execution ( through EXECUTE ) . The body consists of 
 - the CQL query to prepare as a [ long string ] . 
 + Prepare a query for later execution ( through EXECUTE ) . The body of the message must be : 
 + < query > < flags > [ < keyspace > ] 
 + where : 
 + - < query > is a [ long string ] representing the CQL query . 
 + - < flags > is a [ int ] whose bits define the options for this statement and in particular 
 + influence what the remainder of the message contains . 
 + A flag is set if the bit corresponding to its ` mask ` is set . Supported 
 + flags are , given their mask : 
 + 0x01 : With keyspace . If set , < keyspace > must be present . < keyspace > is a 
 + [ string ] indicating the keyspace that the query should be executed in . 
 + It supercedes the keyspace that the connection is bound to , if any . 
 
 The server will respond with a RESULT message with a ` prepared ` kind ( 0x0004 , 
 see Section 4 . 2 . 5 ) . 
 @ @ - 408 , 7 + 420 , 7 @ @ Table of Contents 
 Allows executing a list of queries ( prepared or not ) as a batch ( note that 
 only DML statements are accepted in a batch ) . The body of the message must 
 be : 
 - < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] 
 + < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] [ < keyspace > ] 
 where : 
 - < type > is a [ byte ] indicating the type of batch to use : 
 - If < type > = = 0 , the batch will be " logged " . This is equivalent to a 
 @ @ - 440 , 6 + 452 , 9 @ @ Table of Contents 
 to implement . This will be fixed in a future version of the native 
 protocol . See https : / / issues . apache . org / jira / browse / CASSANDRA - 10246 for 
 more details ] . 
 + 0x80 : With keyspace . If set , < keyspace > must be present . < keyspace > is a 
 + [ string ] indicating the keyspace that the query should be executed in . 
 + It supercedes the keyspace that the connection is bound to , if any . 
 - < n > is a [ short ] indicating the number of following queries . 
 - < query _ 1 > . . . < query _ n > are the queries to execute . A < query _ i > must be of the 
 form : 
 @ @ - 1211 , 3 + 1226 , 5 @ @ Table of Contents 
 * Enlarged flag ' s bitmaps for QUERY , EXECUTE and BATCH messages from [ byte ] to [ int ] 
 ( Sections 4 . 1 . 4 , 4 . 1 . 6 and 4 . 1 . 7 ) . 
 * Add the duration data type 
 + * Added keyspace field in QUERY , PREPARE , and BATCH messages ( Sections 4 . 1 . 4 , 4 . 1 . 5 , and 4 . 1 . 7 ) . 
 + * Added [ int ] flags field in PREPARE message ( Section 4 . 1 . 5 ) . 
 diff - - git a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 index db7fa39 . . 3d3cda0 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public abstract class BatchQueryOptions 
 return wrapped . getConsistency ( ) ; 
 } 
 
 + public String getKeyspace ( ) 
 + { 
 + return wrapped . getKeyspace ( ) ; 
 + } 
 + 
 public ConsistencyLevel getSerialConsistency ( ) 
 { 
 return wrapped . getSerialConsistency ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java b / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java 
 index aa8ca48 . . 32cddba 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java 
 + + + b / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java 
 @ @ - 22 , 6 + 22 , 7 @ @ import java . util . Map ; 
 
 import org . apache . cassandra . cql3 . statements . BatchStatement ; 
 import org . apache . cassandra . cql3 . statements . ParsedStatement ; 
 + import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . QueryState ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 import org . apache . cassandra . utils . MD5Digest ; 
 @ @ - 46 , 9 + 47 , 9 @ @ public class CustomPayloadMirroringQueryHandler implements QueryHandler 
 return result ; 
 } 
 
 - public ResultMessage . Prepared prepare ( String query , QueryState state , Map < String , ByteBuffer > customPayload ) 
 + public ResultMessage . Prepared prepare ( String query , ClientState clientState , Map < String , ByteBuffer > customPayload ) 
 { 
 - ResultMessage . Prepared prepared = queryProcessor . prepare ( query , state , customPayload ) ; 
 + ResultMessage . Prepared prepared = queryProcessor . prepare ( query , clientState , customPayload ) ; 
 prepared . setCustomPayload ( customPayload ) ; 
 return prepared ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryHandler . java b / src / java / org / apache / cassandra / cql3 / QueryHandler . java 
 index 0339d26 . . d3b41f0 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryHandler . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryHandler . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import org . apache . cassandra . cql3 . statements . BatchStatement ; 
 import org . apache . cassandra . cql3 . statements . ParsedStatement ; 
 import org . apache . cassandra . exceptions . RequestExecutionException ; 
 import org . apache . cassandra . exceptions . RequestValidationException ; 
 + import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . QueryState ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 import org . apache . cassandra . utils . MD5Digest ; 
 @ @ - 37 , 7 + 38 , 7 @ @ public interface QueryHandler 
 long queryStartNanoTime ) throws RequestExecutionException , RequestValidationException ; 
 
 ResultMessage . Prepared prepare ( String query , 
 - QueryState state , 
 + ClientState clientState , 
 Map < String , ByteBuffer > customPayload ) throws RequestValidationException ; 
 
 ParsedStatement . Prepared getPrepared ( MD5Digest id ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryOptions . java b / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 index afe20d7 . . 01df691 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 @ @ - 67 , 9 + 67 , 9 @ @ public abstract class QueryOptions 
 return new DefaultQueryOptions ( null , null , true , null , protocolVersion ) ; 
 } 
 
 - public static QueryOptions create ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , int pageSize , PagingState pagingState , ConsistencyLevel serialConsistency , ProtocolVersion version ) 
 + public static QueryOptions create ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , int pageSize , PagingState pagingState , ConsistencyLevel serialConsistency , ProtocolVersion version , String keyspace ) 
 { 
 - return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L ) , version ) ; 
 + return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L , keyspace ) , version ) ; 
 } 
 
 public static QueryOptions addColumnSpecifications ( QueryOptions options , List < ColumnSpecification > columnSpecs ) 
 @ @ - 86 , 11 + 86 , 11 @ @ public abstract class QueryOptions 
 * 
 * This is functionally equivalent to : 
 * { @ code Json . parseJson ( UTF8Type . instance . getSerializer ( ) . deserialize ( getValues ( ) . get ( bindIndex ) ) , expectedReceivers ) . get ( columnName ) } 
 - * but this cache the result of parsing the JSON so that while this might be called for multiple columns on the same { @ code bindIndex } 
 + * but this caches the result of parsing the JSON , so that while this might be called for multiple columns on the same { @ code bindIndex } 
 * value , the underlying JSON value is only parsed / processed once . 
 * 
 - * Note : this is a bit more involved in CQL specifics than this class generally is but we as we need to cache this per - query and in an object 
 - * that is available when we bind values , this is the easier place to have this . 
 + * Note : this is a bit more involved in CQL specifics than this class generally is , but as we need to cache this per - query and in an object 
 + * that is available when we bind values , this is the easiest place to have this . 
 * 
 * @ param bindIndex the index of the bind value that should be interpreted as a JSON value . 
 * @ param columnName the name of the column we want the value of . 
 @ @ - 136 , 7 + 136 , 7 @ @ public abstract class QueryOptions 
 * 
 * < p > The column specifications will be present only for prepared statements . < / p > 
 * 
 - * < p > Invoke the { @ link hasColumnSpecifications } method before invoking this method in order to ensure that this 
 + * < p > Invoke the { @ link # hasColumnSpecifications } method before invoking this method in order to ensure that this 
 * < code > QueryOptions < / code > contains the column specifications . < / p > 
 * 
 * @ return the option names 
 @ @ - 172 , 6 + 172 , 9 @ @ public abstract class QueryOptions 
 return tstamp ! = Long . MIN _ VALUE ? tstamp : state . getTimestamp ( ) ; 
 } 
 
 + / * * The keyspace that this query is bound to , or null if not relevant . * / 
 + public String getKeyspace ( ) { return getSpecificOptions ( ) . keyspace ; } 
 + 
 / * * 
 * The protocol version for the query . 
 * / 
 @ @ - 314 , 7 + 317 , 7 @ @ public abstract class QueryOptions 
 { 
 super . prepare ( specs ) ; 
 
 - orderedValues = new ArrayList < ByteBuffer > ( specs . size ( ) ) ; 
 + orderedValues = new ArrayList < > ( specs . size ( ) ) ; 
 for ( int i = 0 ; i < specs . size ( ) ; i + + ) 
 { 
 String name = specs . get ( i ) . name . toString ( ) ; 
 @ @ - 341 , 19 + 344 , 21 @ @ public abstract class QueryOptions 
 / / Options that are likely to not be present in most queries 
 static class SpecificOptions 
 { 
 - private static final SpecificOptions DEFAULT = new SpecificOptions ( - 1 , null , null , Long . MIN _ VALUE ) ; 
 + private static final SpecificOptions DEFAULT = new SpecificOptions ( - 1 , null , null , Long . MIN _ VALUE , null ) ; 
 
 private final int pageSize ; 
 private final PagingState state ; 
 private final ConsistencyLevel serialConsistency ; 
 private final long timestamp ; 
 + private final String keyspace ; 
 
 - private SpecificOptions ( int pageSize , PagingState state , ConsistencyLevel serialConsistency , long timestamp ) 
 + private SpecificOptions ( int pageSize , PagingState state , ConsistencyLevel serialConsistency , long timestamp , String keyspace ) 
 { 
 this . pageSize = pageSize ; 
 this . state = state ; 
 this . serialConsistency = serialConsistency = = null ? ConsistencyLevel . SERIAL : serialConsistency ; 
 this . timestamp = timestamp ; 
 + this . keyspace = keyspace ; 
 } 
 } 
 
 @ @ - 368 , 7 + 373 , 8 @ @ public abstract class QueryOptions 
 PAGING _ STATE , 
 SERIAL _ CONSISTENCY , 
 TIMESTAMP , 
 - NAMES _ FOR _ VALUES ; 
 + NAMES _ FOR _ VALUES , 
 + KEYSPACE ; 
 
 private static final Flag [ ] ALL _ VALUES = values ( ) ; 
 
 @ @ - 433 , 8 + 439 , 8 @ @ public abstract class QueryOptions 
 throw new ProtocolException ( String . format ( " Out of bound timestamp , must be in [ % d , % d ] ( got % d ) " , Long . MIN _ VALUE + 1 , Long . MAX _ VALUE , ts ) ) ; 
 timestamp = ts ; 
 } 
 - 
 - options = new SpecificOptions ( pageSize , pagingState , serialConsistency , timestamp ) ; 
 + String keyspace = flags . contains ( Flag . KEYSPACE ) ? CBUtil . readString ( body ) : null ; 
 + options = new SpecificOptions ( pageSize , pagingState , serialConsistency , timestamp , keyspace ) ; 
 } 
 DefaultQueryOptions opts = new DefaultQueryOptions ( consistency , values , skipMetadata , options , version ) ; 
 return names = = null ? opts : new OptionsWithNames ( opts , names ) ; 
 @ @ - 460 , 6 + 466 , 8 @ @ public abstract class QueryOptions 
 CBUtil . writeConsistencyLevel ( options . getSerialConsistency ( ) , dest ) ; 
 if ( flags . contains ( Flag . TIMESTAMP ) ) 
 dest . writeLong ( options . getSpecificOptions ( ) . timestamp ) ; 
 + if ( flags . contains ( Flag . KEYSPACE ) ) 
 + CBUtil . writeString ( options . getSpecificOptions ( ) . keyspace , dest ) ; 
 
 / / Note that we don ' t really have to bother with NAMES _ FOR _ VALUES server side , 
 / / and in fact we never really encode QueryOptions , only decode them , so we 
 @ @ - 485 , 7 + 493 , 8 @ @ public abstract class QueryOptions 
 size + = CBUtil . sizeOfConsistencyLevel ( options . getSerialConsistency ( ) ) ; 
 if ( flags . contains ( Flag . TIMESTAMP ) ) 
 size + = 8 ; 
 - 
 + if ( flags . contains ( Flag . KEYSPACE ) ) 
 + size + = CBUtil . sizeOfString ( options . getSpecificOptions ( ) . keyspace ) ; 
 return size ; 
 } 
 
 @ @ - 504 , 6 + 513 , 8 @ @ public abstract class QueryOptions 
 flags . add ( Flag . SERIAL _ CONSISTENCY ) ; 
 if ( options . getSpecificOptions ( ) . timestamp ! = Long . MIN _ VALUE ) 
 flags . add ( Flag . TIMESTAMP ) ; 
 + if ( options . getSpecificOptions ( ) . keyspace ! = null ) 
 + flags . add ( Flag . KEYSPACE ) ; 
 return flags ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 index 4aa2026 . . cca93ff 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 @ @ - 219 , 7 + 219 , 7 @ @ public class QueryProcessor implements QueryHandler 
 public ResultMessage process ( String queryString , QueryState queryState , QueryOptions options , long queryStartNanoTime ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 - ParsedStatement . Prepared p = getStatement ( queryString , queryState . getClientState ( ) ) ; 
 + ParsedStatement . Prepared p = getStatement ( queryString , queryState . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ) ; 
 options . prepare ( p . boundNames ) ; 
 CQLStatement prepared = p . statement ; 
 if ( prepared . getBoundTerms ( ) ! = options . getValues ( ) . size ( ) ) 
 @ @ - 231 , 9 + 231 , 9 @ @ public class QueryProcessor implements QueryHandler 
 return processStatement ( prepared , queryState , options , queryStartNanoTime ) ; 
 } 
 
 - public static ParsedStatement . Prepared parseStatement ( String queryStr , QueryState queryState ) throws RequestValidationException 
 + public static ParsedStatement . Prepared parseStatement ( String queryStr , ClientState clientState ) throws RequestValidationException 
 { 
 - return getStatement ( queryStr , queryState . getClientState ( ) ) ; 
 + return getStatement ( queryStr , clientState ) ; 
 } 
 
 public static UntypedResultSet process ( String query , ConsistencyLevel cl ) throws RequestExecutionException 
 @ @ - 277 , 7 + 277 , 7 @ @ public class QueryProcessor implements QueryHandler 
 return prepared ; 
 
 / / Note : if 2 threads prepare the same query , we ' ll live so don ' t bother synchronizing 
 - prepared = parseStatement ( query , internalQueryState ( ) ) ; 
 + prepared = parseStatement ( query , internalQueryState ( ) . getClientState ( ) ) ; 
 prepared . statement . validate ( internalQueryState ( ) . getClientState ( ) ) ; 
 internalStatements . putIfAbsent ( query , prepared ) ; 
 return prepared ; 
 @ @ - 334 , 7 + 334 , 7 @ @ public class QueryProcessor implements QueryHandler 
 * / 
 public static UntypedResultSet executeOnceInternal ( String query , Object . . . values ) 
 { 
 - ParsedStatement . Prepared prepared = parseStatement ( query , internalQueryState ( ) ) ; 
 + ParsedStatement . Prepared prepared = parseStatement ( query , internalQueryState ( ) . getClientState ( ) ) ; 
 prepared . statement . validate ( internalQueryState ( ) . getClientState ( ) ) ; 
 ResultMessage result = prepared . statement . executeInternal ( internalQueryState ( ) , makeInternalOptions ( prepared , values ) ) ; 
 if ( result instanceof ResultMessage . Rows ) 
 @ @ - 374 , 16 + 374 , 10 @ @ public class QueryProcessor implements QueryHandler 
 } 
 
 public ResultMessage . Prepared prepare ( String query , 
 - QueryState state , 
 + ClientState clientState , 
 Map < String , ByteBuffer > customPayload ) throws RequestValidationException 
 { 
 - return prepare ( query , state ) ; 
 - } 
 - 
 - public ResultMessage . Prepared prepare ( String queryString , QueryState queryState ) 
 - { 
 - ClientState cState = queryState . getClientState ( ) ; 
 - return prepare ( queryString , cState ) ; 
 + return prepare ( query , clientState ) ; 
 } 
 
 public static ResultMessage . Prepared prepare ( String queryString , ClientState clientState ) 
 @ @ - 485 , 7 + 479 , 7 @ @ public class QueryProcessor implements QueryHandler 
 public ResultMessage processBatch ( BatchStatement batch , QueryState queryState , BatchQueryOptions options , long queryStartNanoTime ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 - ClientState clientState = queryState . getClientState ( ) ; 
 + ClientState clientState = queryState . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ; 
 batch . checkAccess ( clientState ) ; 
 batch . validate ( ) ; 
 batch . validate ( clientState ) ; 
 @ @ - 500 , 7 + 494 , 7 @ @ public class QueryProcessor implements QueryHandler 
 
 / / Set keyspace for statement that require login 
 if ( statement instanceof CFStatement ) 
 - ( ( CFStatement ) statement ) . prepareKeyspace ( clientState ) ; 
 + ( ( CFStatement ) statement ) . prepareKeyspace ( clientState ) ; 
 
 Tracing . trace ( " Preparing statement " ) ; 
 return statement . prepare ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java 
 index 9b2987c . . 136860e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java 
 @ @ - 37 , 14 + 37 , 16 @ @ public abstract class CFStatement extends ParsedStatement 
 { 
 if ( ! cfName . hasKeyspace ( ) ) 
 { 
 - / / XXX : We explicitely only want to call state . getKeyspace ( ) in this case , as we don ' t want to throw 
 - / / if not logged in any keyspace but a keyspace is explicitely set on the statement . So don ' t move 
 + / / XXX : We explicitly only want to call state . getKeyspace ( ) in this case , as we don ' t want to throw 
 + / / if not logged in any keyspace but a keyspace is explicitly set on the statement . So don ' t move 
 / / the call outside the ' if ' or replace the method by ' prepareKeyspace ( state . getKeyspace ( ) ) ' 
 cfName . setKeyspace ( state . getKeyspace ( ) , true ) ; 
 } 
 } 
 
 - / / Only for internal calls , use the version with ClientState for user queries 
 + / / Only for internal calls , use the version with ClientState for user queries . In particular , the 
 + / / version with ClientState throws an exception if the statement does not have keyspace set * and * 
 + / / ClientState has no keyspace . 
 public void prepareKeyspace ( String keyspace ) 
 { 
 if ( ! cfName . hasKeyspace ( ) ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java 
 index 0cd549a . . e617ba7 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java 
 @ @ - 51 , 7 + 51 , 7 @ @ public abstract class ParsedStatement 
 / * * 
 * Contains the CQL statement source if the statement has been " regularly " perpared via 
 * { @ link org . apache . cassandra . cql3 . QueryProcessor # prepare ( java . lang . String , org . apache . cassandra . service . ClientState ) } / 
 - * { @ link QueryHandler # prepare ( java . lang . String , org . apache . cassandra . service . QueryState , java . util . Map ) } . 
 + * { @ link QueryHandler # prepare ( java . lang . String , org . apache . cassandra . service . ClientState , java . util . Map ) } . 
 * Other usages of this class may or may not contain the CQL statement source . 
 * / 
 public String rawCQLStatement ; 
 diff - - git a / src / java / org / apache / cassandra / service / ClientState . java b / src / java / org / apache / cassandra / service / ClientState . java 
 index 80cf810 . . dfddccd 100644 
 - - - a / src / java / org / apache / cassandra / service / ClientState . java 
 + + + b / src / java / org / apache / cassandra / service / ClientState . java 
 @ @ - 139 , 6 + 139 , 14 @ @ public class ClientState 
 this . user = AuthenticatedUser . ANONYMOUS _ USER ; 
 } 
 
 + protected ClientState ( ClientState source ) 
 + { 
 + this . isInternal = source . isInternal ; 
 + this . remoteAddress = source . remoteAddress ; 
 + this . user = source . user ; 
 + this . keyspace = source . keyspace ; 
 + } 
 + 
 / * * 
 * @ return a ClientState object for internal C * calls ( not limited by any kind of auth ) . 
 * / 
 @ @ - 156 , 6 + 164 , 22 @ @ public class ClientState 
 } 
 
 / * * 
 + * Clone this ClientState object , but use the provided keyspace instead of the 
 + * keyspace in this ClientState object . 
 + * 
 + * @ return a new ClientState object if the keyspace argument is non - null . Otherwise do not clone 
 + * and return this ClientState object . 
 + * / 
 + public ClientState cloneWithKeyspaceIfSet ( String keyspace ) 
 + { 
 + if ( keyspace = = null ) 
 + return this ; 
 + ClientState clientState = new ClientState ( this ) ; 
 + clientState . setKeyspace ( keyspace ) ; 
 + return clientState ; 
 + } 
 + 
 + / * * 
 * This clock guarantees that updates for the same ClientState will be ordered 
 * in the sequence seen , even if multiple updates happen in the same millisecond . 
 * / 
 diff - - git a / src / java / org / apache / cassandra / transport / Client . java b / src / java / org / apache / cassandra / transport / Client . java 
 index e428b06 . . 9a76e03 100644 
 - - - a / src / java / org / apache / cassandra / transport / Client . java 
 + + + b / src / java / org / apache / cassandra / transport / Client . java 
 @ @ - 136 , 12 + 136 , 12 @ @ public class Client extends SimpleClient 
 return null ; 
 } 
 } 
 - return new QueryMessage ( query , QueryOptions . create ( ConsistencyLevel . ONE , Collections . < ByteBuffer > emptyList ( ) , false , pageSize , null , null , version ) ) ; 
 + return new QueryMessage ( query , QueryOptions . create ( ConsistencyLevel . ONE , Collections . < ByteBuffer > emptyList ( ) , false , pageSize , null , null , version , null ) ) ; 
 } 
 else if ( msgType . equals ( " PREPARE " ) ) 
 { 
 String query = line . substring ( 8 ) ; 
 - return new PrepareMessage ( query ) ; 
 + return new PrepareMessage ( query , null ) ; 
 } 
 else if ( msgType . equals ( " EXECUTE " ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / transport / SimpleClient . java b / src / java / org / apache / cassandra / transport / SimpleClient . java 
 index 1bb081b . . 13cd9bd 100644 
 - - - a / src / java / org / apache / cassandra / transport / SimpleClient . java 
 + + + b / src / java / org / apache / cassandra / transport / SimpleClient . java 
 @ @ - 189 , 7 + 189 , 7 @ @ public class SimpleClient implements Closeable 
 
 public ResultMessage . Prepared prepare ( String query ) 
 { 
 - Message . Response msg = execute ( new PrepareMessage ( query ) ) ; 
 + Message . Response msg = execute ( new PrepareMessage ( query , null ) ) ; 
 assert msg instanceof ResultMessage . Prepared ; 
 return ( ResultMessage . Prepared ) msg ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 index bb6411f . . d9123d4 100644 
 - - - a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 + + + b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 @ @ - 180 , 7 + 180 , 8 @ @ public class BatchMessage extends Message . Request 
 ParsedStatement . Prepared p ; 
 if ( query instanceof String ) 
 { 
 - p = QueryProcessor . parseStatement ( ( String ) query , state ) ; 
 + p = QueryProcessor . parseStatement ( ( String ) query , 
 + state . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ) ; 
 } 
 else 
 { 
 diff - - git a / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java b / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java 
 index b0c9dbe . . bb0fc3a 100644 
 - - - a / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java 
 + + + b / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java 
 @ @ - 36 , 26 + 36 , 59 @ @ public class PrepareMessage extends Message . Request 
 public PrepareMessage decode ( ByteBuf body , ProtocolVersion version ) 
 { 
 String query = CBUtil . readLongString ( body ) ; 
 - return new PrepareMessage ( query ) ; 
 + String keyspace = null ; 
 + if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) { 
 + / / If flags grows , we may want to consider creating a PrepareOptions class with an internal codec 
 + / / class that handles flags and options of the prepare message . Since there ' s only one right now , 
 + / / we just take care of business here . 
 + 
 + int flags = ( int ) body . readUnsignedInt ( ) ; 
 + if ( ( flags & 0x1 ) = = 0x1 ) 
 + keyspace = CBUtil . readString ( body ) ; 
 + } 
 + return new PrepareMessage ( query , keyspace ) ; 
 } 
 
 public void encode ( PrepareMessage msg , ByteBuf dest , ProtocolVersion version ) 
 { 
 CBUtil . writeLongString ( msg . query , dest ) ; 
 + if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) 
 + { 
 + / / If we have no keyspace , write out a 0 - valued flag field . 
 + if ( msg . keyspace = = null ) 
 + dest . writeInt ( 0x0 ) ; 
 + else { 
 + dest . writeInt ( 0x1 ) ; 
 + CBUtil . writeString ( msg . keyspace , dest ) ; 
 + } 
 + } 
 } 
 
 public int encodedSize ( PrepareMessage msg , ProtocolVersion version ) 
 { 
 - return CBUtil . sizeOfLongString ( msg . query ) ; 
 + int size = CBUtil . sizeOfLongString ( msg . query ) ; 
 + if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) 
 + { 
 + / / We always emit a flags int 
 + size + = 4 ; 
 + 
 + / / If we have a keyspace , we ' d write it out . Otherwise , we ' d write nothing . 
 + size + = msg . keyspace = = null 
 + ? 0 
 + : CBUtil . sizeOfString ( msg . keyspace ) ; 
 + } 
 + return size ; 
 } 
 } ; 
 
 private final String query ; 
 + private final String keyspace ; 
 
 - public PrepareMessage ( String query ) 
 + public PrepareMessage ( String query , String keyspace ) 
 { 
 super ( Message . Type . PREPARE ) ; 
 this . query = query ; 
 + this . keyspace = keyspace ; 
 } 
 
 public Message . Response execute ( QueryState state , long queryStartNanoTime ) 
 @ @ - 75 , 7 + 108 , 9 @ @ public class PrepareMessage extends Message . Request 
 Tracing . instance . begin ( " Preparing CQL3 query " , state . getClientAddress ( ) , ImmutableMap . of ( " query " , query ) ) ; 
 } 
 
 - Message . Response response = ClientState . getCQLQueryHandler ( ) . prepare ( query , state , getCustomPayload ( ) ) ; 
 + Message . Response response = ClientState . getCQLQueryHandler ( ) . prepare ( query , 
 + state . getClientState ( ) . cloneWithKeyspaceIfSet ( keyspace ) , 
 + getCustomPayload ( ) ) ; 
 
 if ( tracingId ! = null ) 
 response . setTracingId ( tracingId ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 index c247d96 . . 26437c9 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 @ @ - 710 , 7 + 710 , 7 @ @ public abstract class CQLTester 
 state . setKeyspace ( SchemaConstants . SYSTEM _ KEYSPACE _ NAME ) ; 
 QueryState queryState = new QueryState ( state ) ; 
 
 - ParsedStatement . Prepared prepared = QueryProcessor . parseStatement ( query , queryState ) ; 
 + ParsedStatement . Prepared prepared = QueryProcessor . parseStatement ( query , queryState . getClientState ( ) ) ; 
 prepared . statement . validate ( state ) ; 
 
 QueryOptions options = QueryOptions . forInternalCalls ( Collections . < ByteBuffer > emptyList ( ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java b / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java 
 index cfbfd39 . . c27593b 100644 
 - - - a / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java 
 + + + b / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java 
 @ @ - 48 , 6 + 48 , 7 @ @ import org . apache . cassandra . transport . messages . QueryMessage ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 import org . apache . cassandra . utils . MD5Digest ; 
 
 + import static org . apache . cassandra . config . EncryptionOptions . ClientEncryptionOptions ; 
 import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; 
 
 public class MessagePayloadTest extends CQLTester 
 @ @ - 112 , 6 + 113 , 86 @ @ public class MessagePayloadTest extends CQLTester 
 } 
 
 @ Test 
 + public void testMessagePayloadBeta ( ) throws Throwable 
 + { 
 + QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; 
 + cqlQueryHandlerField . set ( null , new TestQueryHandler ( ) ) ; 
 + try 
 + { 
 + requireNetwork ( ) ; 
 + 
 + Assert . assertSame ( TestQueryHandler . class , ClientState . getCQLQueryHandler ( ) . getClass ( ) ) ; 
 + 
 + SimpleClient client = new SimpleClient ( nativeAddr . getHostAddress ( ) , 
 + nativePort , 
 + ProtocolVersion . V5 , 
 + true , 
 + new ClientEncryptionOptions ( ) ) ; 
 + try 
 + { 
 + client . connect ( false ) ; 
 + 
 + Map < String , ByteBuffer > reqMap ; 
 + Map < String , ByteBuffer > respMap ; 
 + 
 + QueryOptions queryOptions = QueryOptions . create ( 
 + QueryOptions . DEFAULT . getConsistency ( ) , 
 + QueryOptions . DEFAULT . getValues ( ) , 
 + QueryOptions . DEFAULT . skipMetadata ( ) , 
 + QueryOptions . DEFAULT . getPageSize ( ) , 
 + QueryOptions . DEFAULT . getPagingState ( ) , 
 + QueryOptions . DEFAULT . getSerialConsistency ( ) , 
 + ProtocolVersion . V5 , 
 + KEYSPACE ) ; 
 + QueryMessage queryMessage = new QueryMessage ( " CREATE TABLE atable ( pk int PRIMARY KEY , v text ) " , 
 + queryOptions ) ; 
 + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM atable " , KEYSPACE ) ; 
 + 
 + reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; 
 + responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; 
 + queryMessage . setCustomPayload ( reqMap ) ; 
 + Message . Response queryResponse = client . execute ( queryMessage ) ; 
 + payloadEquals ( reqMap , requestPayload ) ; 
 + payloadEquals ( respMap , queryResponse . getCustomPayload ( ) ) ; 
 + 
 + reqMap = Collections . singletonMap ( " foo " , bytes ( 43 ) ) ; 
 + responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 43 ) ) ; 
 + prepareMessage . setCustomPayload ( reqMap ) ; 
 + ResultMessage . Prepared prepareResponse = ( ResultMessage . Prepared ) client . execute ( prepareMessage ) ; 
 + payloadEquals ( reqMap , requestPayload ) ; 
 + payloadEquals ( respMap , prepareResponse . getCustomPayload ( ) ) ; 
 + 
 + ExecuteMessage executeMessage = new ExecuteMessage ( prepareResponse . statementId , QueryOptions . DEFAULT ) ; 
 + reqMap = Collections . singletonMap ( " foo " , bytes ( 44 ) ) ; 
 + responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 44 ) ) ; 
 + executeMessage . setCustomPayload ( reqMap ) ; 
 + Message . Response executeResponse = client . execute ( executeMessage ) ; 
 + payloadEquals ( reqMap , requestPayload ) ; 
 + payloadEquals ( respMap , executeResponse . getCustomPayload ( ) ) ; 
 + 
 + BatchMessage batchMessage = new BatchMessage ( BatchStatement . Type . UNLOGGED , 
 + Collections . < Object > singletonList ( " INSERT INTO atable ( pk , v ) VALUES ( 1 , ' foo ' ) " ) , 
 + Collections . singletonList ( Collections . < ByteBuffer > emptyList ( ) ) , 
 + queryOptions ) ; 
 + reqMap = Collections . singletonMap ( " foo " , bytes ( 45 ) ) ; 
 + responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 45 ) ) ; 
 + batchMessage . setCustomPayload ( reqMap ) ; 
 + Message . Response batchResponse = client . execute ( batchMessage ) ; 
 + payloadEquals ( reqMap , requestPayload ) ; 
 + payloadEquals ( respMap , batchResponse . getCustomPayload ( ) ) ; 
 + } 
 + finally 
 + { 
 + client . close ( ) ; 
 + } 
 + } 
 + finally 
 + { 
 + cqlQueryHandlerField . set ( null , queryHandler ) ; 
 + } 
 + } 
 + 
 + @ Test 
 public void testMessagePayload ( ) throws Throwable 
 { 
 QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; 
 @ @ - 134 , 7 + 215 , 7 @ @ public class MessagePayloadTest extends CQLTester 
 " CREATE TABLE " + KEYSPACE + " . atable ( pk int PRIMARY KEY , v text ) " , 
 QueryOptions . DEFAULT 
 ) ; 
 - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " ) ; 
 + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " , null ) ; 
 
 reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; 
 responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; 
 @ @ - 202 , 7 + 283 , 7 @ @ public class MessagePayloadTest extends CQLTester 
 " CREATE TABLE " + KEYSPACE + " . atable ( pk int PRIMARY KEY , v text ) " , 
 QueryOptions . DEFAULT 
 ) ; 
 - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " ) ; 
 + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " , null ) ; 
 
 reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; 
 responsePayload = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; 
 @ @ - 293 , 13 + 374 , 13 @ @ public class MessagePayloadTest extends CQLTester 
 } 
 
 public ResultMessage . Prepared prepare ( String query , 
 - QueryState state , 
 + ClientState clientState , 
 Map < String , ByteBuffer > customPayload ) 
 throws RequestValidationException 
 { 
 if ( customPayload ! = null ) 
 requestPayload = customPayload ; 
 - ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , state , customPayload ) ; 
 + ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , clientState , customPayload ) ; 
 if ( customPayload ! = null ) 
 { 
 result . setCustomPayload ( responsePayload ) ; 
 diff - - git a / test / unit / org / apache / cassandra / transport / SerDeserTest . java b / test / unit / org / apache / cassandra / transport / SerDeserTest . java 
 index a1260ba . . 2592ae7 100644 
 - - - a / test / unit / org / apache / cassandra / transport / SerDeserTest . java 
 + + + b / test / unit / org / apache / cassandra / transport / SerDeserTest . java 
 @ @ - 314 , 15 + 314 , 30 @ @ public class SerDeserTest 
 
 private void queryOptionsSerDeserTest ( ProtocolVersion version ) throws Exception 
 { 
 - QueryOptions options = QueryOptions . create ( ConsistencyLevel . ALL , 
 - Collections . singletonList ( ByteBuffer . wrap ( new byte [ ] { 0x00 , 0x01 , 0x02 } ) ) , 
 - false , 
 - 5000 , 
 - Util . makeSomePagingState ( version ) , 
 - ConsistencyLevel . SERIAL , 
 - version 
 - ) ; 
 + queryOptionsSerDeserTest ( version , QueryOptions . create ( ConsistencyLevel . ALL , 
 + Collections . singletonList ( ByteBuffer . wrap ( new byte [ ] { 0x00 , 0x01 , 0x02 } ) ) , 
 + false , 
 + 5000 , 
 + Util . makeSomePagingState ( version ) , 
 + ConsistencyLevel . SERIAL , 
 + version , 
 + null 
 + ) ) ; 
 + 
 + queryOptionsSerDeserTest ( version , QueryOptions . create ( ConsistencyLevel . LOCAL _ ONE , 
 + Arrays . asList ( ByteBuffer . wrap ( new byte [ ] { 0x00 , 0x01 , 0x02 } ) , 
 + ByteBuffer . wrap ( new byte [ ] { 0x03 , 0x04 , 0x05 , 0x03 , 0x04 , 0x05 } ) ) , 
 + true , 
 + 10 , 
 + Util . makeSomePagingState ( version ) , 
 + ConsistencyLevel . SERIAL , 
 + version , 
 + " some _ keyspace " 
 + ) ) ; 
 + } 
 
 + private void queryOptionsSerDeserTest ( ProtocolVersion version , QueryOptions options ) 
 + { 
 ByteBuf buf = Unpooled . buffer ( QueryOptions . codec . encodedSize ( options , version ) ) ; 
 QueryOptions . codec . encode ( options , buf , version ) ; 
 QueryOptions decodedOptions = QueryOptions . codec . decode ( buf , version ) ; 
 @ @ - 335 , 5 + 350 , 6 @ @ public class SerDeserTest 
 assertEquals ( options . getValues ( ) , decodedOptions . getValues ( ) ) ; 
 assertEquals ( options . getPagingState ( ) , decodedOptions . getPagingState ( ) ) ; 
 assertEquals ( options . skipMetadata ( ) , decodedOptions . skipMetadata ( ) ) ; 
 + assertEquals ( options . getKeyspace ( ) , decodedOptions . getKeyspace ( ) ) ; 
 } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
