BLEU SCORE: 0.03435488317233918

TEST MSG: Adding more test coverage for authenticated user login audit activity
GENERATED MSG: Workaround for netty issue causing corrupted data to come off the wire

TEST DIFF (one line): diff - - git a / test / unit / org / apache / cassandra / audit / AuditLoggerAuthTest . java b / test / unit / org / apache / cassandra / audit / AuditLoggerAuthTest . java <nl> new file mode 100644 <nl> index 0000000 . . 1105770 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / audit / AuditLoggerAuthTest . java <nl> @ @ - 0 , 0 + 1 , 291 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . audit ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . Arrays ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> + import java . util . Queue ; <nl> + <nl> + import org . junit . AfterClass ; <nl> + import org . junit . Before ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import com . datastax . driver . core . Cluster ; <nl> + import com . datastax . driver . core . Session ; <nl> + import com . datastax . driver . core . exceptions . AuthenticationException ; <nl> + import com . datastax . driver . core . exceptions . UnauthorizedException ; <nl> + import org . apache . cassandra . OrderedJUnit4ClassRunner ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . config . OverrideConfigurationLoader ; <nl> + import org . apache . cassandra . cql3 . CQLTester ; <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . service . EmbeddedCassandraService ; <nl> + <nl> + import static org . hamcrest . CoreMatchers . containsString ; <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertNotEquals ; <nl> + import static org . junit . Assert . assertThat ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + / * * <nl> + * AuditLoggerAuthTest class is responsible for covering test cases for Authenticated user ( LOGIN ) audits . <nl> + * Non authenticated tests are covered in { @ link AuditLoggerTest } <nl> + * / <nl> + <nl> + @ RunWith ( OrderedJUnit4ClassRunner . class ) <nl> + public class AuditLoggerAuthTest <nl> + { <nl> + private static EmbeddedCassandraService embedded ; <nl> + <nl> + private static final String TEST _ USER = " testuser " ; <nl> + private static final String TEST _ ROLE = " testrole " ; <nl> + private static final String TEST _ PW = " testpassword " ; <nl> + private static final String CASS _ USER = " cassandra " ; <nl> + private static final String CASS _ PW = " cassandra " ; <nl> + <nl> + @ BeforeClass <nl> + public static void setup ( ) throws Exception <nl> + { <nl> + OverrideConfigurationLoader . override ( ( config ) - > { <nl> + config . authenticator = " PasswordAuthenticator " ; <nl> + config . role _ manager = " CassandraRoleManager " ; <nl> + config . authorizer = " CassandraAuthorizer " ; <nl> + config . audit _ logging _ options . enabled = true ; <nl> + config . audit _ logging _ options . logger = " InMemoryAuditLogger " ; <nl> + } ) ; <nl> + CQLTester . prepareServer ( ) ; <nl> + <nl> + System . setProperty ( " cassandra . superuser _ setup _ delay _ ms " , " 0 " ) ; <nl> + embedded = new EmbeddedCassandraService ( ) ; <nl> + embedded . start ( ) ; <nl> + <nl> + executeWithCredentials ( <nl> + Arrays . asList ( getCreateRoleCql ( TEST _ USER , true , false ) , <nl> + getCreateRoleCql ( " testuser _ nologin " , false , false ) , <nl> + " CREATE KEYSPACE testks WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " , <nl> + " CREATE TABLE testks . table1 ( key text PRIMARY KEY , col1 int , col2 int ) " ) , <nl> + " cassandra " , " cassandra " , null ) ; <nl> + } <nl> + <nl> + @ AfterClass <nl> + public static void shutdown ( ) <nl> + { <nl> + embedded . stop ( ) ; <nl> + } <nl> + <nl> + @ Before <nl> + public void clearInMemoryLogger ( ) <nl> + { <nl> + getInMemAuditLogger ( ) . clear ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCqlLoginAuditing ( ) throws Throwable <nl> + { <nl> + executeWithCredentials ( Collections . emptyList ( ) , TEST _ USER , " wrongpassword " , <nl> + AuditLogEntryType . LOGIN _ ERROR ) ; <nl> + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; <nl> + clearInMemoryLogger ( ) ; <nl> + <nl> + executeWithCredentials ( Collections . emptyList ( ) , " wronguser " , TEST _ PW , AuditLogEntryType . LOGIN _ ERROR ) ; <nl> + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; <nl> + clearInMemoryLogger ( ) ; <nl> + <nl> + executeWithCredentials ( Collections . emptyList ( ) , " testuser _ nologin " , <nl> + TEST _ PW , AuditLogEntryType . LOGIN _ ERROR ) ; <nl> + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; <nl> + clearInMemoryLogger ( ) ; <nl> + <nl> + executeWithCredentials ( Collections . emptyList ( ) , TEST _ USER , TEST _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; <nl> + clearInMemoryLogger ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCqlCreateRoleAuditing ( ) <nl> + { <nl> + createTestRole ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCqlALTERRoleAuditing ( ) <nl> + { <nl> + createTestRole ( ) ; <nl> + String cql = " ALTER ROLE " + TEST _ ROLE + " WITH PASSWORD = ' foo _ bar ' " ; <nl> + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + assertLogEntry ( logEntry , AuditLogEntryType . ALTER _ ROLE , cql , CASS _ USER ) ; <nl> + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCqlDROPRoleAuditing ( ) <nl> + { <nl> + createTestRole ( ) ; <nl> + String cql = " DROP ROLE " + TEST _ ROLE ; <nl> + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + assertLogEntry ( logEntry , AuditLogEntryType . DROP _ ROLE , cql , CASS _ USER ) ; <nl> + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCqlLISTROLESAuditing ( ) <nl> + { <nl> + String cql = " LIST ROLES " ; <nl> + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + assertLogEntry ( logEntry , AuditLogEntryType . LIST _ ROLES , cql , CASS _ USER ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCqlLISTPERMISSIONSAuditing ( ) <nl> + { <nl> + String cql = " LIST ALL " ; <nl> + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + assertLogEntry ( logEntry , AuditLogEntryType . LIST _ PERMISSIONS , cql , CASS _ USER ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCqlGRANTAuditing ( ) <nl> + { <nl> + createTestRole ( ) ; <nl> + String cql = " GRANT SELECT ON ALL KEYSPACES TO " + TEST _ ROLE ; <nl> + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + assertLogEntry ( logEntry , AuditLogEntryType . GRANT , cql , CASS _ USER ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCqlREVOKEAuditing ( ) <nl> + { <nl> + createTestRole ( ) ; <nl> + String cql = " REVOKE ALTER ON ALL KEYSPACES FROM " + TEST _ ROLE ; <nl> + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + assertLogEntry ( logEntry , AuditLogEntryType . REVOKE , cql , CASS _ USER ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testUNAUTHORIZED _ ATTEMPTAuditing ( ) <nl> + { <nl> + createTestRole ( ) ; <nl> + String cql = " ALTER ROLE " + TEST _ ROLE + " WITH superuser = true " ; <nl> + executeWithCredentials ( Arrays . asList ( cql ) , TEST _ USER , TEST _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + assertLogEntry ( logEntry , AuditLogEntryType . UNAUTHORIZED _ ATTEMPT , cql , TEST _ USER ) ; <nl> + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Helper methods <nl> + * / <nl> + <nl> + private static void executeWithCredentials ( List < String > queries , String username , String password , <nl> + AuditLogEntryType expectedType ) <nl> + { <nl> + boolean authFailed = false ; <nl> + try ( Cluster cluster = Cluster . builder ( ) . addContactPoints ( InetAddress . getLoopbackAddress ( ) ) <nl> + . withoutJMXReporting ( ) <nl> + . withCredentials ( username , password ) <nl> + . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ) <nl> + { <nl> + try ( Session session = cluster . connect ( ) ) <nl> + { <nl> + for ( String query : queries ) <nl> + session . execute ( query ) ; <nl> + } <nl> + catch ( AuthenticationException e ) <nl> + { <nl> + authFailed = true ; <nl> + } <nl> + catch ( UnauthorizedException ue ) <nl> + { <nl> + / / no - op , taken care by caller <nl> + } <nl> + } <nl> + <nl> + if ( expectedType ! = null ) <nl> + { <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + <nl> + assertEquals ( expectedType , logEntry . getType ( ) ) ; <nl> + assertTrue ( ! authFailed | | logEntry . getType ( ) = = AuditLogEntryType . LOGIN _ ERROR ) ; <nl> + assertSource ( logEntry , username ) ; <nl> + <nl> + / / drain all remaining login related events , as there ' s no specification how connections and login attempts <nl> + / / should be handled by the driver , so we can ' t assert a fixed number of login events <nl> + getInMemAuditLogger ( ) <nl> + . removeIf ( auditLogEntry - > auditLogEntry . getType ( ) = = AuditLogEntryType . LOGIN _ ERROR <nl> + | | auditLogEntry . getType ( ) = = AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + } <nl> + } <nl> + <nl> + private static Queue < AuditLogEntry > getInMemAuditLogger ( ) <nl> + { <nl> + return ( ( InMemoryAuditLogger ) AuditLogManager . getInstance ( ) . getLogger ( ) ) . inMemQueue ; <nl> + } <nl> + <nl> + private static void assertLogEntry ( AuditLogEntry logEntry , AuditLogEntryType type , String cql , String username ) <nl> + { <nl> + assertSource ( logEntry , username ) ; <nl> + assertNotEquals ( 0 , logEntry . getTimestamp ( ) ) ; <nl> + assertEquals ( type , logEntry . getType ( ) ) ; <nl> + if ( null ! = cql & & ! cql . isEmpty ( ) ) <nl> + { <nl> + assertThat ( logEntry . getOperation ( ) , containsString ( cql ) ) ; <nl> + } <nl> + } <nl> + <nl> + private static void assertSource ( AuditLogEntry logEntry , String username ) <nl> + { <nl> + assertEquals ( InetAddressAndPort . getLoopbackAddress ( ) . address , logEntry . getSource ( ) . address ) ; <nl> + assertTrue ( logEntry . getSource ( ) . port > 0 ) ; <nl> + if ( logEntry . getType ( ) ! = AuditLogEntryType . LOGIN _ ERROR ) <nl> + assertEquals ( username , logEntry . getUser ( ) ) ; <nl> + } <nl> + <nl> + private static String getCreateRoleCql ( String role , boolean login , boolean superUser ) <nl> + { <nl> + return String . format ( " CREATE ROLE IF NOT EXISTS % s WITH LOGIN = % s AND SUPERUSER = % s AND PASSWORD = ' % s ' " , <nl> + role , login , superUser , TEST _ PW ) ; <nl> + } <nl> + <nl> + private static void createTestRole ( ) <nl> + { <nl> + String createTestRoleCQL = getCreateRoleCql ( TEST _ ROLE , true , false ) ; <nl> + executeWithCredentials ( Arrays . asList ( createTestRoleCQL ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; <nl> + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; <nl> + assertLogEntry ( logEntry , AuditLogEntryType . CREATE _ ROLE , createTestRoleCQL , CASS _ USER ) ; <nl> + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; <nl> + } <nl> + } <nl> \ No newline at end of file <nl> diff - - git a / test / unit / org / apache / cassandra / audit / AuditLoggerTest . java b / test / unit / org / apache / cassandra / audit / AuditLoggerTest . java <nl> index ac73504 . . b0299dc 100644 <nl> - - - a / test / unit / org / apache / cassandra / audit / AuditLoggerTest . java <nl> + + + b / test / unit / org / apache / cassandra / audit / AuditLoggerTest . java <nl> @ @ - 38 , 7 + 38 , 12 @ @ import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertNotEquals ; <nl> import static org . junit . Assert . assertNull ; <nl> import static org . junit . Assert . assertThat ; <nl> + import static org . junit . Assert . assertTrue ; <nl> <nl> + / * * <nl> + * AuditLoggerTest is responsible for covering the test cases for Audit Logging CASSANDRA - 12151 functionality . <nl> + * Authenticated user audit ( LOGIN ) tests are segregated from unauthenticated user audit tests . <nl> + * / <nl> public class AuditLoggerTest extends CQLTester <nl> { <nl> @ BeforeClass <nl> @ @ - 290 , 6 + 295 , 10 @ @ public class AuditLoggerTest extends CQLTester <nl> assertEquals ( 5 , ( ( InMemoryAuditLogger ) AuditLogManager . getInstance ( ) . getLogger ( ) ) . inMemQueue . size ( ) ) ; <nl> logEntry = ( ( InMemoryAuditLogger ) AuditLogManager . getInstance ( ) . getLogger ( ) ) . inMemQueue . poll ( ) ; <nl> <nl> + assertEquals ( AuditLogEntryType . BATCH , logEntry . getType ( ) ) ; <nl> + assertTrue ( logEntry . getOperation ( ) . contains ( " BatchId " ) ) ; <nl> + assertNotEquals ( 0 , logEntry . getTimestamp ( ) ) ; <nl> + <nl> logEntry = ( ( InMemoryAuditLogger ) AuditLogManager . getInstance ( ) . getLogger ( ) ) . inMemQueue . poll ( ) ; <nl> assertLogEntry ( cqlInsert , AuditLogEntryType . UPDATE , logEntry , false ) ; <nl>
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / test / unit / org / apache / cassandra / audit / AuditLoggerAuthTest . java b / test / unit / org / apache / cassandra / audit / AuditLoggerAuthTest . java 
 new file mode 100644 
 index 0000000 . . 1105770 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / audit / AuditLoggerAuthTest . java 
 @ @ - 0 , 0 + 1 , 291 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . audit ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . Arrays ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 + import java . util . Queue ; 
 + 
 + import org . junit . AfterClass ; 
 + import org . junit . Before ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import com . datastax . driver . core . Cluster ; 
 + import com . datastax . driver . core . Session ; 
 + import com . datastax . driver . core . exceptions . AuthenticationException ; 
 + import com . datastax . driver . core . exceptions . UnauthorizedException ; 
 + import org . apache . cassandra . OrderedJUnit4ClassRunner ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . config . OverrideConfigurationLoader ; 
 + import org . apache . cassandra . cql3 . CQLTester ; 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . service . EmbeddedCassandraService ; 
 + 
 + import static org . hamcrest . CoreMatchers . containsString ; 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertNotEquals ; 
 + import static org . junit . Assert . assertThat ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + / * * 
 + * AuditLoggerAuthTest class is responsible for covering test cases for Authenticated user ( LOGIN ) audits . 
 + * Non authenticated tests are covered in { @ link AuditLoggerTest } 
 + * / 
 + 
 + @ RunWith ( OrderedJUnit4ClassRunner . class ) 
 + public class AuditLoggerAuthTest 
 + { 
 + private static EmbeddedCassandraService embedded ; 
 + 
 + private static final String TEST _ USER = " testuser " ; 
 + private static final String TEST _ ROLE = " testrole " ; 
 + private static final String TEST _ PW = " testpassword " ; 
 + private static final String CASS _ USER = " cassandra " ; 
 + private static final String CASS _ PW = " cassandra " ; 
 + 
 + @ BeforeClass 
 + public static void setup ( ) throws Exception 
 + { 
 + OverrideConfigurationLoader . override ( ( config ) - > { 
 + config . authenticator = " PasswordAuthenticator " ; 
 + config . role _ manager = " CassandraRoleManager " ; 
 + config . authorizer = " CassandraAuthorizer " ; 
 + config . audit _ logging _ options . enabled = true ; 
 + config . audit _ logging _ options . logger = " InMemoryAuditLogger " ; 
 + } ) ; 
 + CQLTester . prepareServer ( ) ; 
 + 
 + System . setProperty ( " cassandra . superuser _ setup _ delay _ ms " , " 0 " ) ; 
 + embedded = new EmbeddedCassandraService ( ) ; 
 + embedded . start ( ) ; 
 + 
 + executeWithCredentials ( 
 + Arrays . asList ( getCreateRoleCql ( TEST _ USER , true , false ) , 
 + getCreateRoleCql ( " testuser _ nologin " , false , false ) , 
 + " CREATE KEYSPACE testks WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " , 
 + " CREATE TABLE testks . table1 ( key text PRIMARY KEY , col1 int , col2 int ) " ) , 
 + " cassandra " , " cassandra " , null ) ; 
 + } 
 + 
 + @ AfterClass 
 + public static void shutdown ( ) 
 + { 
 + embedded . stop ( ) ; 
 + } 
 + 
 + @ Before 
 + public void clearInMemoryLogger ( ) 
 + { 
 + getInMemAuditLogger ( ) . clear ( ) ; 
 + } 
 + 
 + @ Test 
 + public void testCqlLoginAuditing ( ) throws Throwable 
 + { 
 + executeWithCredentials ( Collections . emptyList ( ) , TEST _ USER , " wrongpassword " , 
 + AuditLogEntryType . LOGIN _ ERROR ) ; 
 + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; 
 + clearInMemoryLogger ( ) ; 
 + 
 + executeWithCredentials ( Collections . emptyList ( ) , " wronguser " , TEST _ PW , AuditLogEntryType . LOGIN _ ERROR ) ; 
 + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; 
 + clearInMemoryLogger ( ) ; 
 + 
 + executeWithCredentials ( Collections . emptyList ( ) , " testuser _ nologin " , 
 + TEST _ PW , AuditLogEntryType . LOGIN _ ERROR ) ; 
 + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; 
 + clearInMemoryLogger ( ) ; 
 + 
 + executeWithCredentials ( Collections . emptyList ( ) , TEST _ USER , TEST _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; 
 + clearInMemoryLogger ( ) ; 
 + } 
 + 
 + @ Test 
 + public void testCqlCreateRoleAuditing ( ) 
 + { 
 + createTestRole ( ) ; 
 + } 
 + 
 + @ Test 
 + public void testCqlALTERRoleAuditing ( ) 
 + { 
 + createTestRole ( ) ; 
 + String cql = " ALTER ROLE " + TEST _ ROLE + " WITH PASSWORD = ' foo _ bar ' " ; 
 + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + assertLogEntry ( logEntry , AuditLogEntryType . ALTER _ ROLE , cql , CASS _ USER ) ; 
 + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testCqlDROPRoleAuditing ( ) 
 + { 
 + createTestRole ( ) ; 
 + String cql = " DROP ROLE " + TEST _ ROLE ; 
 + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + assertLogEntry ( logEntry , AuditLogEntryType . DROP _ ROLE , cql , CASS _ USER ) ; 
 + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testCqlLISTROLESAuditing ( ) 
 + { 
 + String cql = " LIST ROLES " ; 
 + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + assertLogEntry ( logEntry , AuditLogEntryType . LIST _ ROLES , cql , CASS _ USER ) ; 
 + } 
 + 
 + @ Test 
 + public void testCqlLISTPERMISSIONSAuditing ( ) 
 + { 
 + String cql = " LIST ALL " ; 
 + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + assertLogEntry ( logEntry , AuditLogEntryType . LIST _ PERMISSIONS , cql , CASS _ USER ) ; 
 + } 
 + 
 + @ Test 
 + public void testCqlGRANTAuditing ( ) 
 + { 
 + createTestRole ( ) ; 
 + String cql = " GRANT SELECT ON ALL KEYSPACES TO " + TEST _ ROLE ; 
 + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + assertLogEntry ( logEntry , AuditLogEntryType . GRANT , cql , CASS _ USER ) ; 
 + } 
 + 
 + @ Test 
 + public void testCqlREVOKEAuditing ( ) 
 + { 
 + createTestRole ( ) ; 
 + String cql = " REVOKE ALTER ON ALL KEYSPACES FROM " + TEST _ ROLE ; 
 + executeWithCredentials ( Arrays . asList ( cql ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + assertLogEntry ( logEntry , AuditLogEntryType . REVOKE , cql , CASS _ USER ) ; 
 + } 
 + 
 + @ Test 
 + public void testUNAUTHORIZED _ ATTEMPTAuditing ( ) 
 + { 
 + createTestRole ( ) ; 
 + String cql = " ALTER ROLE " + TEST _ ROLE + " WITH superuser = true " ; 
 + executeWithCredentials ( Arrays . asList ( cql ) , TEST _ USER , TEST _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + assertLogEntry ( logEntry , AuditLogEntryType . UNAUTHORIZED _ ATTEMPT , cql , TEST _ USER ) ; 
 + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Helper methods 
 + * / 
 + 
 + private static void executeWithCredentials ( List < String > queries , String username , String password , 
 + AuditLogEntryType expectedType ) 
 + { 
 + boolean authFailed = false ; 
 + try ( Cluster cluster = Cluster . builder ( ) . addContactPoints ( InetAddress . getLoopbackAddress ( ) ) 
 + . withoutJMXReporting ( ) 
 + . withCredentials ( username , password ) 
 + . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ) 
 + { 
 + try ( Session session = cluster . connect ( ) ) 
 + { 
 + for ( String query : queries ) 
 + session . execute ( query ) ; 
 + } 
 + catch ( AuthenticationException e ) 
 + { 
 + authFailed = true ; 
 + } 
 + catch ( UnauthorizedException ue ) 
 + { 
 + / / no - op , taken care by caller 
 + } 
 + } 
 + 
 + if ( expectedType ! = null ) 
 + { 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + 
 + assertEquals ( expectedType , logEntry . getType ( ) ) ; 
 + assertTrue ( ! authFailed | | logEntry . getType ( ) = = AuditLogEntryType . LOGIN _ ERROR ) ; 
 + assertSource ( logEntry , username ) ; 
 + 
 + / / drain all remaining login related events , as there ' s no specification how connections and login attempts 
 + / / should be handled by the driver , so we can ' t assert a fixed number of login events 
 + getInMemAuditLogger ( ) 
 + . removeIf ( auditLogEntry - > auditLogEntry . getType ( ) = = AuditLogEntryType . LOGIN _ ERROR 
 + | | auditLogEntry . getType ( ) = = AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + } 
 + } 
 + 
 + private static Queue < AuditLogEntry > getInMemAuditLogger ( ) 
 + { 
 + return ( ( InMemoryAuditLogger ) AuditLogManager . getInstance ( ) . getLogger ( ) ) . inMemQueue ; 
 + } 
 + 
 + private static void assertLogEntry ( AuditLogEntry logEntry , AuditLogEntryType type , String cql , String username ) 
 + { 
 + assertSource ( logEntry , username ) ; 
 + assertNotEquals ( 0 , logEntry . getTimestamp ( ) ) ; 
 + assertEquals ( type , logEntry . getType ( ) ) ; 
 + if ( null ! = cql & & ! cql . isEmpty ( ) ) 
 + { 
 + assertThat ( logEntry . getOperation ( ) , containsString ( cql ) ) ; 
 + } 
 + } 
 + 
 + private static void assertSource ( AuditLogEntry logEntry , String username ) 
 + { 
 + assertEquals ( InetAddressAndPort . getLoopbackAddress ( ) . address , logEntry . getSource ( ) . address ) ; 
 + assertTrue ( logEntry . getSource ( ) . port > 0 ) ; 
 + if ( logEntry . getType ( ) ! = AuditLogEntryType . LOGIN _ ERROR ) 
 + assertEquals ( username , logEntry . getUser ( ) ) ; 
 + } 
 + 
 + private static String getCreateRoleCql ( String role , boolean login , boolean superUser ) 
 + { 
 + return String . format ( " CREATE ROLE IF NOT EXISTS % s WITH LOGIN = % s AND SUPERUSER = % s AND PASSWORD = ' % s ' " , 
 + role , login , superUser , TEST _ PW ) ; 
 + } 
 + 
 + private static void createTestRole ( ) 
 + { 
 + String createTestRoleCQL = getCreateRoleCql ( TEST _ ROLE , true , false ) ; 
 + executeWithCredentials ( Arrays . asList ( createTestRoleCQL ) , CASS _ USER , CASS _ PW , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertTrue ( getInMemAuditLogger ( ) . size ( ) > 0 ) ; 
 + AuditLogEntry logEntry = getInMemAuditLogger ( ) . poll ( ) ; 
 + assertLogEntry ( logEntry , AuditLogEntryType . CREATE _ ROLE , createTestRoleCQL , CASS _ USER ) ; 
 + assertEquals ( 0 , getInMemAuditLogger ( ) . size ( ) ) ; 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / test / unit / org / apache / cassandra / audit / AuditLoggerTest . java b / test / unit / org / apache / cassandra / audit / AuditLoggerTest . java 
 index ac73504 . . b0299dc 100644 
 - - - a / test / unit / org / apache / cassandra / audit / AuditLoggerTest . java 
 + + + b / test / unit / org / apache / cassandra / audit / AuditLoggerTest . java 
 @ @ - 38 , 7 + 38 , 12 @ @ import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertNotEquals ; 
 import static org . junit . Assert . assertNull ; 
 import static org . junit . Assert . assertThat ; 
 + import static org . junit . Assert . assertTrue ; 
 
 + / * * 
 + * AuditLoggerTest is responsible for covering the test cases for Audit Logging CASSANDRA - 12151 functionality . 
 + * Authenticated user audit ( LOGIN ) tests are segregated from unauthenticated user audit tests . 
 + * / 
 public class AuditLoggerTest extends CQLTester 
 { 
 @ BeforeClass 
 @ @ - 290 , 6 + 295 , 10 @ @ public class AuditLoggerTest extends CQLTester 
 assertEquals ( 5 , ( ( InMemoryAuditLogger ) AuditLogManager . getInstance ( ) . getLogger ( ) ) . inMemQueue . size ( ) ) ; 
 logEntry = ( ( InMemoryAuditLogger ) AuditLogManager . getInstance ( ) . getLogger ( ) ) . inMemQueue . poll ( ) ; 
 
 + assertEquals ( AuditLogEntryType . BATCH , logEntry . getType ( ) ) ; 
 + assertTrue ( logEntry . getOperation ( ) . contains ( " BatchId " ) ) ; 
 + assertNotEquals ( 0 , logEntry . getTimestamp ( ) ) ; 
 + 
 logEntry = ( ( InMemoryAuditLogger ) AuditLogManager . getInstance ( ) . getLogger ( ) ) . inMemQueue . poll ( ) ; 
 assertLogEntry ( cqlInsert , AuditLogEntryType . UPDATE , logEntry , false ) ; 


NEAREST DIFF:
ELIMINATEDSENTENCE
