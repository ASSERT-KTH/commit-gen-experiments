BLEU SCORE: 0.09599621398238427

TEST MSG: Fix marking commitlog segments clean
GENERATED MSG: fix bug preventing obsolete commitlog segments from being removed

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 714a475 . . 5afe800 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 0 - rc1 <nl> + * Fix marking commitlogsegments clean ( CASSANDRA - 6959 ) <nl> * Add snapshot " manifest " describing files included ( CASSANDRA - 6326 ) <nl> * Parallel streaming for sstableloader ( CASSANDRA - 3668 ) <nl> * Fix bugs in supercolumns handling ( CASSANDRA - 7138 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> index e5c9b3e . . 3830966 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> @ @ - 469 , 7 + 469 , 7 @ @ public class CommitLogSegment <nl> UUID cfId = clean . getKey ( ) ; <nl> AtomicInteger cleanPos = clean . getValue ( ) ; <nl> AtomicInteger dirtyPos = cfDirty . get ( cfId ) ; <nl> - if ( dirtyPos ! = null & & dirtyPos . intValue ( ) < cleanPos . intValue ( ) ) <nl> + if ( dirtyPos ! = null & & dirtyPos . intValue ( ) < = cleanPos . intValue ( ) ) <nl> { <nl> cfDirty . remove ( cfId ) ; <nl> iter . remove ( ) ; <nl> @ @ - 482 , 9 + 482 , 9 @ @ public class CommitLogSegment <nl> * / <nl> public synchronized Collection < UUID > getDirtyCFIDs ( ) <nl> { <nl> - removeCleanFromDirty ( ) ; <nl> if ( cfClean . isEmpty ( ) | | cfDirty . isEmpty ( ) ) <nl> return cfDirty . keySet ( ) ; <nl> + <nl> List < UUID > r = new ArrayList < > ( cfDirty . size ( ) ) ; <nl> for ( Map . Entry < UUID , AtomicInteger > dirty : cfDirty . entrySet ( ) ) <nl> {
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 5cbd41e . . d420f0c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 7 , 6 + 7 , 8 @ @ <nl> 1 . 0 . 0 - final <nl> * Fix tool . bat files when CASSANDRA _ HOME contains spaces ( CASSANDRA - 3258 ) <nl> * Force flush of status table when removing / updating token ( CASSANDRA - 3243 ) <nl> + * fix bug preventing obsolete commitlog segments from being removed <nl> + ( CASSANDRA - 3269 ) <nl> <nl> <nl> 1 . 0 . 0 - rc2 <nl> @ @ - 26 , 6 + 28 , 7 @ @ <nl> * CLI documentation change for ColumnFamily ` compression _ options ` ( CASSANDRA - 3282 ) <nl> * ignore any CF ids sent by client for adding CF / KS ( CASSANDRA - 3288 ) <nl> * remove obsolete hints on first startup ( CASSANDRA - 3291 ) <nl> + * use correct ISortedColumns for time - optimized reads ( CASSANDRA - 3289 ) <nl> <nl> 1 . 0 . 0 - rc1 <nl> * Update CQL to generate microsecond timestamps by default ( CASSANDRA - 3227 ) <nl> diff - - git a / contrib / pig / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java b / contrib / pig / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java <nl> index a6bb845 . . 044ea3f 100644 <nl> - - - a / contrib / pig / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java <nl> + + + b / contrib / pig / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java <nl> @ @ - 17 , 11 + 17 , 13 @ @ <nl> package org . apache . cassandra . hadoop . pig ; <nl> <nl> import java . io . IOException ; <nl> + import java . math . BigInteger ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> <nl> import org . apache . cassandra . config . ConfigurationException ; <nl> import org . apache . cassandra . db . marshal . BytesType ; <nl> + import org . apache . cassandra . db . marshal . IntegerType ; <nl> import org . apache . cassandra . db . marshal . TypeParser ; <nl> import org . apache . cassandra . thrift . * ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> @ @ - 31 , 7 + 33 , 7 @ @ import org . apache . commons . logging . LogFactory ; <nl> import org . apache . cassandra . db . Column ; <nl> import org . apache . cassandra . db . IColumn ; <nl> import org . apache . cassandra . db . SuperColumn ; <nl> - import org . apache . cassandra . db . marshal . AbstractType ; <nl> + import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . hadoop . * ; <nl> import org . apache . cassandra . thrift . Mutation ; <nl> import org . apache . cassandra . thrift . Deletion ; <nl> @ @ - 46 , 6 + 48 , 7 @ @ import org . apache . pig . * ; <nl> import org . apache . pig . backend . executionengine . ExecException ; <nl> import org . apache . pig . backend . hadoop . executionengine . mapReduceLayer . PigSplit ; <nl> import org . apache . pig . data . * ; <nl> + import org . apache . pig . ResourceSchema . ResourceFieldSchema ; <nl> import org . apache . pig . impl . logicalLayer . FrontendException ; <nl> import org . apache . pig . impl . util . UDFContext ; <nl> import org . apache . thrift . TDeserializer ; <nl> @ @ - 61 , 7 + 64 , 7 @ @ import org . apache . thrift . transport . TTransportException ; <nl> * <nl> * A row from a standard CF will be returned as nested tuples : ( key , ( ( name1 , val1 ) , ( name2 , val2 ) ) ) . <nl> * / <nl> - public class CassandraStorage extends LoadFunc implements StoreFuncInterface <nl> + public class CassandraStorage extends LoadFunc implements StoreFuncInterface , LoadMetadata <nl> { <nl> / / system environment variables that can be set to configure connection info : <nl> / / alternatively , Hadoop JobConf variables can be set using keys from ConfigHelper <nl> @ @ - 142 , 18 + 145 , 14 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface <nl> List < AbstractType > marshallers = getDefaultMarshallers ( cfDef ) ; <nl> Map < ByteBuffer , AbstractType > validators = getValidatorMap ( cfDef ) ; <nl> <nl> + setTupleValue ( pair , 0 , marshallers . get ( 0 ) . compose ( name ) ) ; <nl> if ( col instanceof Column ) <nl> { <nl> / / standard <nl> - pair . set ( 0 , marshallers . get ( 0 ) . compose ( name ) ) ; <nl> if ( validators . get ( name ) = = null ) <nl> - / / Have to special case BytesType because compose returns a ByteBuffer <nl> - if ( marshallers . get ( 1 ) instanceof BytesType ) <nl> - pair . set ( 1 , new DataByteArray ( ByteBufferUtil . getArray ( col . value ( ) ) ) ) ; <nl> - else <nl> - pair . set ( 1 , marshallers . get ( 1 ) . compose ( col . value ( ) ) ) ; <nl> + setTupleValue ( pair , 1 , marshallers . get ( 1 ) . compose ( col . value ( ) ) ) ; <nl> else <nl> - pair . set ( 1 , validators . get ( name ) . compose ( col . value ( ) ) ) ; <nl> + setTupleValue ( pair , 1 , validators . get ( name ) . compose ( col . value ( ) ) ) ; <nl> return pair ; <nl> } <nl> <nl> @ @ - 166 , 6 + 165 , 16 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface <nl> return pair ; <nl> } <nl> <nl> + private void setTupleValue ( Tuple pair , int position , Object value ) throws ExecException <nl> + { <nl> + if ( value instanceof BigInteger ) <nl> + pair . set ( position , ( ( BigInteger ) value ) . intValue ( ) ) ; <nl> + else if ( value instanceof ByteBuffer ) <nl> + pair . set ( position , new DataByteArray ( ByteBufferUtil . getArray ( ( ByteBuffer ) value ) ) ) ; <nl> + else <nl> + pair . set ( position , value ) ; <nl> + } <nl> + <nl> private CfDef getCfDef ( String signature ) <nl> { <nl> UDFContext context = UDFContext . getUDFContext ( ) ; <nl> @ @ - 293 , 6 + 302 , 103 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface <nl> initSchema ( loadSignature ) ; <nl> } <nl> <nl> + public ResourceSchema getSchema ( String location , Job job ) throws IOException <nl> + { <nl> + setLocation ( location , job ) ; <nl> + CfDef cfDef = getCfDef ( loadSignature ) ; <nl> + <nl> + if ( cfDef . column _ type . equals ( " Super " ) ) <nl> + return null ; <nl> + / / top - level schema , no type <nl> + ResourceSchema schema = new ResourceSchema ( ) ; <nl> + <nl> + / / add key <nl> + ResourceFieldSchema keyFieldSchema = new ResourceFieldSchema ( ) ; <nl> + keyFieldSchema . setName ( " key " ) ; <nl> + keyFieldSchema . setType ( DataType . CHARARRAY ) ; / / TODO : get key type <nl> + <nl> + / / will become the bag of tuples <nl> + ResourceFieldSchema bagFieldSchema = new ResourceFieldSchema ( ) ; <nl> + bagFieldSchema . setName ( " columns " ) ; <nl> + bagFieldSchema . setType ( DataType . BAG ) ; <nl> + ResourceSchema bagSchema = new ResourceSchema ( ) ; <nl> + <nl> + <nl> + List < AbstractType > marshallers = getDefaultMarshallers ( cfDef ) ; <nl> + Map < ByteBuffer , AbstractType > validators = getValidatorMap ( cfDef ) ; <nl> + List < ResourceFieldSchema > tupleFields = new ArrayList < ResourceFieldSchema > ( ) ; <nl> + <nl> + / / default comparator / validator <nl> + ResourceSchema innerTupleSchema = new ResourceSchema ( ) ; <nl> + ResourceFieldSchema tupleField = new ResourceFieldSchema ( ) ; <nl> + tupleField . setType ( DataType . TUPLE ) ; <nl> + tupleField . setSchema ( innerTupleSchema ) ; <nl> + <nl> + ResourceFieldSchema colSchema = new ResourceFieldSchema ( ) ; <nl> + colSchema . setName ( " name " ) ; <nl> + colSchema . setType ( getPigType ( marshallers . get ( 0 ) ) ) ; <nl> + tupleFields . add ( colSchema ) ; <nl> + <nl> + ResourceFieldSchema valSchema = new ResourceFieldSchema ( ) ; <nl> + AbstractType validator = marshallers . get ( 1 ) ; <nl> + valSchema . setName ( " value " ) ; <nl> + valSchema . setType ( getPigType ( validator ) ) ; <nl> + tupleFields . add ( valSchema ) ; <nl> + <nl> + / / defined validators / indexes <nl> + for ( ColumnDef cdef : cfDef . column _ metadata ) <nl> + { <nl> + colSchema = new ResourceFieldSchema ( ) ; <nl> + colSchema . setName ( new String ( cdef . getName ( ) ) ) ; <nl> + colSchema . setType ( getPigType ( marshallers . get ( 0 ) ) ) ; <nl> + tupleFields . add ( colSchema ) ; <nl> + <nl> + valSchema = new ResourceFieldSchema ( ) ; <nl> + validator = validators . get ( cdef . getName ( ) ) ; <nl> + if ( validator = = null ) <nl> + validator = marshallers . get ( 1 ) ; <nl> + valSchema . setName ( " value " ) ; <nl> + valSchema . setType ( getPigType ( validator ) ) ; <nl> + tupleFields . add ( valSchema ) ; <nl> + } <nl> + innerTupleSchema . setFields ( tupleFields . toArray ( new ResourceFieldSchema [ tupleFields . size ( ) ] ) ) ; <nl> + <nl> + / / a bag can contain only one tuple , but that tuple can contain anything <nl> + bagSchema . setFields ( new ResourceFieldSchema [ ] { tupleField } ) ; <nl> + bagFieldSchema . setSchema ( bagSchema ) ; <nl> + / / top level schema contains everything <nl> + schema . setFields ( new ResourceFieldSchema [ ] { keyFieldSchema , bagFieldSchema } ) ; <nl> + return schema ; <nl> + } <nl> + <nl> + private byte getPigType ( AbstractType type ) <nl> + { <nl> + if ( type instanceof LongType ) <nl> + return DataType . LONG ; <nl> + else if ( type instanceof IntegerType ) <nl> + return DataType . INTEGER ; <nl> + else if ( type instanceof AsciiType ) <nl> + return DataType . CHARARRAY ; <nl> + else if ( type instanceof UTF8Type ) <nl> + return DataType . CHARARRAY ; <nl> + return DataType . BYTEARRAY ; <nl> + } <nl> + <nl> + public ResourceStatistics getStatistics ( String location , Job job ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + public String [ ] getPartitionKeys ( String location , Job job ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + public void setPartitionFilter ( Expression partitionFilter ) <nl> + { <nl> + / / no - op <nl> + } <nl> + <nl> @ Override <nl> public String relativeToAbsolutePath ( String location , Path curDir ) throws IOException <nl> { <nl> @ @ - 355 , 8 + 461 , 6 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface <nl> DefaultDataBag pairs = ( DefaultDataBag ) t . get ( 1 ) ; <nl> ArrayList < Mutation > mutationList = new ArrayList < Mutation > ( ) ; <nl> CfDef cfDef = getCfDef ( storeSignature ) ; <nl> - List < AbstractType > marshallers = getDefaultMarshallers ( cfDef ) ; <nl> - Map < ByteBuffer , AbstractType > validators = getValidatorMap ( cfDef ) ; <nl> try <nl> { <nl> for ( Tuple pair : pairs ) <nl> @ @ - 400 , 15 + 504 , 8 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface <nl> else <nl> { <nl> org . apache . cassandra . thrift . Column column = new org . apache . cassandra . thrift . Column ( ) ; <nl> - column . name = marshallers . get ( 0 ) . decompose ( ( pair . get ( 0 ) ) ) ; <nl> - if ( validators . get ( column . name ) = = null ) <nl> - / / Have to special case BytesType to convert DataByteArray into ByteBuffer <nl> - if ( marshallers . get ( 1 ) instanceof BytesType ) <nl> - column . value = objToBB ( pair . get ( 1 ) ) ; <nl> - else <nl> - column . value = marshallers . get ( 1 ) . decompose ( pair . get ( 1 ) ) ; <nl> - else <nl> - column . value = validators . get ( column . name ) . decompose ( pair . get ( 1 ) ) ; <nl> + column . name = objToBB ( pair . get ( 0 ) ) ; <nl> + column . value = objToBB ( pair . get ( 1 ) ) ; <nl> column . setTimestamp ( System . currentTimeMillis ( ) * 1000 ) ; <nl> mutation . column _ or _ supercolumn = new ColumnOrSuperColumn ( ) ; <nl> mutation . column _ or _ supercolumn . column = column ; <nl> @ @ - 528 , 3 + 625 , 4 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface <nl> return cfDef ; <nl> } <nl> } <nl> + <nl> diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java <nl> index e08ffd8 . . 3451ed1 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CollationController . java <nl> + + + b / src / java / org / apache / cassandra / db / CollationController . java <nl> @ @ - 42 , 16 + 42 , 16 @ @ public class CollationController <nl> private static Logger logger = LoggerFactory . getLogger ( CollationController . class ) ; <nl> <nl> private final ColumnFamilyStore cfs ; <nl> - private final ISortedColumns . Factory factory ; <nl> + private final boolean mutableColumns ; <nl> private final QueryFilter filter ; <nl> private final int gcBefore ; <nl> <nl> private int sstablesIterated = 0 ; <nl> <nl> - public CollationController ( ColumnFamilyStore cfs , ISortedColumns . Factory factory , QueryFilter filter , int gcBefore ) <nl> + public CollationController ( ColumnFamilyStore cfs , boolean mutableColumns , QueryFilter filter , int gcBefore ) <nl> { <nl> this . cfs = cfs ; <nl> - this . factory = factory ; <nl> + this . mutableColumns = mutableColumns ; <nl> this . filter = filter ; <nl> this . gcBefore = gcBefore ; <nl> } <nl> @ @ - 72 , 6 + 72 , 9 @ @ public class CollationController <nl> { <nl> logger . debug ( " collectTimeOrderedData " ) ; <nl> <nl> + ISortedColumns . Factory factory = mutableColumns <nl> + ? ThreadSafeSortedColumns . factory ( ) <nl> + : TreeMapBackedSortedColumns . factory ( ) ; <nl> ColumnFamily container = ColumnFamily . create ( cfs . metadata , factory , filter . filter . isReversed ( ) ) ; <nl> List < IColumnIterator > iterators = new ArrayList < IColumnIterator > ( ) ; <nl> ColumnFamilyStore . ViewFragment view = cfs . markReferenced ( filter . key ) ; <nl> @ @ - 184 , 6 + 187 , 9 @ @ public class CollationController <nl> private ColumnFamily collectAllData ( ) <nl> { <nl> logger . debug ( " collectAllData " ) ; <nl> + ISortedColumns . Factory factory = mutableColumns <nl> + ? ThreadSafeSortedColumns . factory ( ) <nl> + : ArrayBackedSortedColumns . factory ( ) ; <nl> List < IColumnIterator > iterators = new ArrayList < IColumnIterator > ( ) ; <nl> ColumnFamily returnCF = ColumnFamily . create ( cfs . metadata , factory , filter . filter . isReversed ( ) ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 92c6eff . . 067308b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1106 , 12 + 1106 , 12 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> * / <nl> public ColumnFamily getColumnFamily ( QueryFilter filter ) <nl> { <nl> - return getColumnFamily ( filter , gcBefore ( ) , ThreadSafeSortedColumns . factory ( ) ) ; <nl> + return getColumnFamily ( filter , gcBefore ( ) ) ; <nl> } <nl> <nl> public ColumnFamily getColumnFamily ( QueryFilter filter , ISortedColumns . Factory factory ) <nl> { <nl> - return getColumnFamily ( filter , gcBefore ( ) , factory ) ; <nl> + return getColumnFamily ( filter , gcBefore ( ) ) ; <nl> } <nl> <nl> public int gcBefore ( ) <nl> @ @ - 1125 , 7 + 1125 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> if ( ( cached = rowCache . get ( key ) ) = = null ) <nl> { <nl> / / We force ThreadSafeSortedColumns because cached row will be accessed concurrently <nl> - cached = getTopLevelColumns ( QueryFilter . getIdentityFilter ( key , new QueryPath ( columnFamily ) ) , Integer . MIN _ VALUE , ThreadSafeSortedColumns . factory ( ) ) ; <nl> + cached = getTopLevelColumns ( QueryFilter . getIdentityFilter ( key , new QueryPath ( columnFamily ) ) , Integer . MIN _ VALUE , true ) ; <nl> if ( cached = = null ) <nl> return null ; <nl> <nl> @ @ - 1135 , 7 + 1135 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> return cached ; <nl> } <nl> <nl> - private ColumnFamily getColumnFamily ( QueryFilter filter , int gcBefore , ISortedColumns . Factory factory ) <nl> + private ColumnFamily getColumnFamily ( QueryFilter filter , int gcBefore ) <nl> { <nl> assert columnFamily . equals ( filter . getColumnFamilyName ( ) ) : filter . getColumnFamilyName ( ) ; <nl> <nl> @ @ - 1144 , 7 + 1144 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> if ( rowCache . getCapacity ( ) = = 0 ) <nl> { <nl> - ColumnFamily cf = getTopLevelColumns ( filter , gcBefore , factory ) ; <nl> + ColumnFamily cf = getTopLevelColumns ( filter , gcBefore , false ) ; <nl> <nl> if ( cf = = null ) <nl> return null ; <nl> @ @ - 1291 , 9 + 1291 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> return new ViewFragment ( sstables , Iterables . concat ( Collections . singleton ( view . memtable ) , view . memtablesPendingFlush ) ) ; <nl> } <nl> <nl> - private ColumnFamily getTopLevelColumns ( QueryFilter filter , int gcBefore , ISortedColumns . Factory factory ) <nl> + private ColumnFamily getTopLevelColumns ( QueryFilter filter , int gcBefore , boolean forCache ) <nl> { <nl> - CollationController controller = new CollationController ( this , factory , filter , gcBefore ) ; <nl> + CollationController controller = new CollationController ( this , forCache , filter , gcBefore ) ; <nl> ColumnFamily columns = controller . getTopLevelColumns ( ) ; <nl> recentSSTablesPerRead . add ( controller . getSstablesIterated ( ) ) ; <nl> sstablesPerRead . add ( controller . getSstablesIterated ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> index d4bcaf6 . . b08b5d0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> @ @ - 97 , 11 + 97 , 10 @ @ public class CommitLogSegment <nl> <nl> public ReplayPosition write ( RowMutation rowMutation ) throws IOException <nl> { <nl> - long currentPosition = - 1L ; <nl> + ReplayPosition cLogCtx = getContext ( ) ; <nl> + <nl> try <nl> { <nl> - ReplayPosition cLogCtx = getContext ( ) ; <nl> - <nl> for ( ColumnFamily columnFamily : rowMutation . getColumnFamilies ( ) ) <nl> { <nl> / / check for null cfm in case a cl write goes through after the cf is <nl> @ @ - 113 , 7 + 112 , 7 @ @ public class CommitLogSegment <nl> } <nl> else <nl> { <nl> - turnOn ( cfm . cfId , ( int ) currentPosition ) ; <nl> + turnOn ( cfm . cfId , cLogCtx . position ) ; <nl> } <nl> } <nl> <nl> @ @ - 131 , 8 + 130 , 7 @ @ public class CommitLogSegment <nl> } <nl> catch ( IOException e ) <nl> { <nl> - if ( currentPosition ! = - 1 ) <nl> - logWriter . truncate ( currentPosition ) ; <nl> + logWriter . truncate ( cLogCtx . position ) ; <nl> throw e ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index 922a7dd . . 43bbdce 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 486 , 6 + 486 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> <nl> String indexFilename = sstable . descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ; <nl> RandomAccessReader indexFile = RandomAccessReader . open ( new File ( indexFilename ) , true ) ; <nl> + ScrubInfo scrubInfo = new ScrubInfo ( dataFile , sstable ) ; <nl> + <nl> try <nl> { <nl> ByteBuffer nextIndexKey = ByteBufferUtil . readWithShortLength ( indexFile ) ; <nl> @ @ - 495 , 12 + 497 , 19 @ @ public class CompactionManager implements CompactionManagerMBean <nl> assert firstRowPositionFromIndex = = 0 : firstRowPositionFromIndex ; <nl> } <nl> <nl> - / / errors when creating the writer may leave empty temp files . <nl> - SSTableWriter writer = maybeCreateWriter ( cfs , compactionFileLocation , expectedBloomFilterSize , null , Collections . singletonList ( sstable ) ) ; <nl> SSTableReader newSstable = null ; <nl> - executor . beginCompaction ( new ScrubInfo ( dataFile , sstable ) ) ; <nl> + <nl> + / / errors when creating the writer may leave empty temp files . <nl> + SSTableWriter writer = maybeCreateWriter ( cfs , <nl> + compactionFileLocation , <nl> + expectedBloomFilterSize , <nl> + null , <nl> + Collections . singletonList ( sstable ) ) ; <nl> + <nl> int goodRows = 0 , badRows = 0 , emptyRows = 0 ; <nl> <nl> + executor . beginCompaction ( scrubInfo ) ; <nl> + <nl> try <nl> { <nl> while ( ! dataFile . isEOF ( ) ) <nl> @ @ - 649 , 6 + 658 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> { <nl> FileUtils . closeQuietly ( dataFile ) ; <nl> FileUtils . closeQuietly ( indexFile ) ; <nl> + <nl> + executor . finishCompaction ( scrubInfo ) ; <nl> } <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 714a475 . . 5afe800 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 0 - rc1 
 + * Fix marking commitlogsegments clean ( CASSANDRA - 6959 ) 
 * Add snapshot " manifest " describing files included ( CASSANDRA - 6326 ) 
 * Parallel streaming for sstableloader ( CASSANDRA - 3668 ) 
 * Fix bugs in supercolumns handling ( CASSANDRA - 7138 ) 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 index e5c9b3e . . 3830966 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 @ @ - 469 , 7 + 469 , 7 @ @ public class CommitLogSegment 
 UUID cfId = clean . getKey ( ) ; 
 AtomicInteger cleanPos = clean . getValue ( ) ; 
 AtomicInteger dirtyPos = cfDirty . get ( cfId ) ; 
 - if ( dirtyPos ! = null & & dirtyPos . intValue ( ) < cleanPos . intValue ( ) ) 
 + if ( dirtyPos ! = null & & dirtyPos . intValue ( ) < = cleanPos . intValue ( ) ) 
 { 
 cfDirty . remove ( cfId ) ; 
 iter . remove ( ) ; 
 @ @ - 482 , 9 + 482 , 9 @ @ public class CommitLogSegment 
 * / 
 public synchronized Collection < UUID > getDirtyCFIDs ( ) 
 { 
 - removeCleanFromDirty ( ) ; 
 if ( cfClean . isEmpty ( ) | | cfDirty . isEmpty ( ) ) 
 return cfDirty . keySet ( ) ; 
 + 
 List < UUID > r = new ArrayList < > ( cfDirty . size ( ) ) ; 
 for ( Map . Entry < UUID , AtomicInteger > dirty : cfDirty . entrySet ( ) ) 
 {

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 5cbd41e . . d420f0c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 7 , 6 + 7 , 8 @ @ 
 1 . 0 . 0 - final 
 * Fix tool . bat files when CASSANDRA _ HOME contains spaces ( CASSANDRA - 3258 ) 
 * Force flush of status table when removing / updating token ( CASSANDRA - 3243 ) 
 + * fix bug preventing obsolete commitlog segments from being removed 
 + ( CASSANDRA - 3269 ) 
 
 
 1 . 0 . 0 - rc2 
 @ @ - 26 , 6 + 28 , 7 @ @ 
 * CLI documentation change for ColumnFamily ` compression _ options ` ( CASSANDRA - 3282 ) 
 * ignore any CF ids sent by client for adding CF / KS ( CASSANDRA - 3288 ) 
 * remove obsolete hints on first startup ( CASSANDRA - 3291 ) 
 + * use correct ISortedColumns for time - optimized reads ( CASSANDRA - 3289 ) 
 
 1 . 0 . 0 - rc1 
 * Update CQL to generate microsecond timestamps by default ( CASSANDRA - 3227 ) 
 diff - - git a / contrib / pig / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java b / contrib / pig / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java 
 index a6bb845 . . 044ea3f 100644 
 - - - a / contrib / pig / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java 
 + + + b / contrib / pig / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java 
 @ @ - 17 , 11 + 17 , 13 @ @ 
 package org . apache . cassandra . hadoop . pig ; 
 
 import java . io . IOException ; 
 + import java . math . BigInteger ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 
 import org . apache . cassandra . config . ConfigurationException ; 
 import org . apache . cassandra . db . marshal . BytesType ; 
 + import org . apache . cassandra . db . marshal . IntegerType ; 
 import org . apache . cassandra . db . marshal . TypeParser ; 
 import org . apache . cassandra . thrift . * ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 @ @ - 31 , 7 + 33 , 7 @ @ import org . apache . commons . logging . LogFactory ; 
 import org . apache . cassandra . db . Column ; 
 import org . apache . cassandra . db . IColumn ; 
 import org . apache . cassandra . db . SuperColumn ; 
 - import org . apache . cassandra . db . marshal . AbstractType ; 
 + import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . hadoop . * ; 
 import org . apache . cassandra . thrift . Mutation ; 
 import org . apache . cassandra . thrift . Deletion ; 
 @ @ - 46 , 6 + 48 , 7 @ @ import org . apache . pig . * ; 
 import org . apache . pig . backend . executionengine . ExecException ; 
 import org . apache . pig . backend . hadoop . executionengine . mapReduceLayer . PigSplit ; 
 import org . apache . pig . data . * ; 
 + import org . apache . pig . ResourceSchema . ResourceFieldSchema ; 
 import org . apache . pig . impl . logicalLayer . FrontendException ; 
 import org . apache . pig . impl . util . UDFContext ; 
 import org . apache . thrift . TDeserializer ; 
 @ @ - 61 , 7 + 64 , 7 @ @ import org . apache . thrift . transport . TTransportException ; 
 * 
 * A row from a standard CF will be returned as nested tuples : ( key , ( ( name1 , val1 ) , ( name2 , val2 ) ) ) . 
 * / 
 - public class CassandraStorage extends LoadFunc implements StoreFuncInterface 
 + public class CassandraStorage extends LoadFunc implements StoreFuncInterface , LoadMetadata 
 { 
 / / system environment variables that can be set to configure connection info : 
 / / alternatively , Hadoop JobConf variables can be set using keys from ConfigHelper 
 @ @ - 142 , 18 + 145 , 14 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface 
 List < AbstractType > marshallers = getDefaultMarshallers ( cfDef ) ; 
 Map < ByteBuffer , AbstractType > validators = getValidatorMap ( cfDef ) ; 
 
 + setTupleValue ( pair , 0 , marshallers . get ( 0 ) . compose ( name ) ) ; 
 if ( col instanceof Column ) 
 { 
 / / standard 
 - pair . set ( 0 , marshallers . get ( 0 ) . compose ( name ) ) ; 
 if ( validators . get ( name ) = = null ) 
 - / / Have to special case BytesType because compose returns a ByteBuffer 
 - if ( marshallers . get ( 1 ) instanceof BytesType ) 
 - pair . set ( 1 , new DataByteArray ( ByteBufferUtil . getArray ( col . value ( ) ) ) ) ; 
 - else 
 - pair . set ( 1 , marshallers . get ( 1 ) . compose ( col . value ( ) ) ) ; 
 + setTupleValue ( pair , 1 , marshallers . get ( 1 ) . compose ( col . value ( ) ) ) ; 
 else 
 - pair . set ( 1 , validators . get ( name ) . compose ( col . value ( ) ) ) ; 
 + setTupleValue ( pair , 1 , validators . get ( name ) . compose ( col . value ( ) ) ) ; 
 return pair ; 
 } 
 
 @ @ - 166 , 6 + 165 , 16 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface 
 return pair ; 
 } 
 
 + private void setTupleValue ( Tuple pair , int position , Object value ) throws ExecException 
 + { 
 + if ( value instanceof BigInteger ) 
 + pair . set ( position , ( ( BigInteger ) value ) . intValue ( ) ) ; 
 + else if ( value instanceof ByteBuffer ) 
 + pair . set ( position , new DataByteArray ( ByteBufferUtil . getArray ( ( ByteBuffer ) value ) ) ) ; 
 + else 
 + pair . set ( position , value ) ; 
 + } 
 + 
 private CfDef getCfDef ( String signature ) 
 { 
 UDFContext context = UDFContext . getUDFContext ( ) ; 
 @ @ - 293 , 6 + 302 , 103 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface 
 initSchema ( loadSignature ) ; 
 } 
 
 + public ResourceSchema getSchema ( String location , Job job ) throws IOException 
 + { 
 + setLocation ( location , job ) ; 
 + CfDef cfDef = getCfDef ( loadSignature ) ; 
 + 
 + if ( cfDef . column _ type . equals ( " Super " ) ) 
 + return null ; 
 + / / top - level schema , no type 
 + ResourceSchema schema = new ResourceSchema ( ) ; 
 + 
 + / / add key 
 + ResourceFieldSchema keyFieldSchema = new ResourceFieldSchema ( ) ; 
 + keyFieldSchema . setName ( " key " ) ; 
 + keyFieldSchema . setType ( DataType . CHARARRAY ) ; / / TODO : get key type 
 + 
 + / / will become the bag of tuples 
 + ResourceFieldSchema bagFieldSchema = new ResourceFieldSchema ( ) ; 
 + bagFieldSchema . setName ( " columns " ) ; 
 + bagFieldSchema . setType ( DataType . BAG ) ; 
 + ResourceSchema bagSchema = new ResourceSchema ( ) ; 
 + 
 + 
 + List < AbstractType > marshallers = getDefaultMarshallers ( cfDef ) ; 
 + Map < ByteBuffer , AbstractType > validators = getValidatorMap ( cfDef ) ; 
 + List < ResourceFieldSchema > tupleFields = new ArrayList < ResourceFieldSchema > ( ) ; 
 + 
 + / / default comparator / validator 
 + ResourceSchema innerTupleSchema = new ResourceSchema ( ) ; 
 + ResourceFieldSchema tupleField = new ResourceFieldSchema ( ) ; 
 + tupleField . setType ( DataType . TUPLE ) ; 
 + tupleField . setSchema ( innerTupleSchema ) ; 
 + 
 + ResourceFieldSchema colSchema = new ResourceFieldSchema ( ) ; 
 + colSchema . setName ( " name " ) ; 
 + colSchema . setType ( getPigType ( marshallers . get ( 0 ) ) ) ; 
 + tupleFields . add ( colSchema ) ; 
 + 
 + ResourceFieldSchema valSchema = new ResourceFieldSchema ( ) ; 
 + AbstractType validator = marshallers . get ( 1 ) ; 
 + valSchema . setName ( " value " ) ; 
 + valSchema . setType ( getPigType ( validator ) ) ; 
 + tupleFields . add ( valSchema ) ; 
 + 
 + / / defined validators / indexes 
 + for ( ColumnDef cdef : cfDef . column _ metadata ) 
 + { 
 + colSchema = new ResourceFieldSchema ( ) ; 
 + colSchema . setName ( new String ( cdef . getName ( ) ) ) ; 
 + colSchema . setType ( getPigType ( marshallers . get ( 0 ) ) ) ; 
 + tupleFields . add ( colSchema ) ; 
 + 
 + valSchema = new ResourceFieldSchema ( ) ; 
 + validator = validators . get ( cdef . getName ( ) ) ; 
 + if ( validator = = null ) 
 + validator = marshallers . get ( 1 ) ; 
 + valSchema . setName ( " value " ) ; 
 + valSchema . setType ( getPigType ( validator ) ) ; 
 + tupleFields . add ( valSchema ) ; 
 + } 
 + innerTupleSchema . setFields ( tupleFields . toArray ( new ResourceFieldSchema [ tupleFields . size ( ) ] ) ) ; 
 + 
 + / / a bag can contain only one tuple , but that tuple can contain anything 
 + bagSchema . setFields ( new ResourceFieldSchema [ ] { tupleField } ) ; 
 + bagFieldSchema . setSchema ( bagSchema ) ; 
 + / / top level schema contains everything 
 + schema . setFields ( new ResourceFieldSchema [ ] { keyFieldSchema , bagFieldSchema } ) ; 
 + return schema ; 
 + } 
 + 
 + private byte getPigType ( AbstractType type ) 
 + { 
 + if ( type instanceof LongType ) 
 + return DataType . LONG ; 
 + else if ( type instanceof IntegerType ) 
 + return DataType . INTEGER ; 
 + else if ( type instanceof AsciiType ) 
 + return DataType . CHARARRAY ; 
 + else if ( type instanceof UTF8Type ) 
 + return DataType . CHARARRAY ; 
 + return DataType . BYTEARRAY ; 
 + } 
 + 
 + public ResourceStatistics getStatistics ( String location , Job job ) 
 + { 
 + return null ; 
 + } 
 + 
 + public String [ ] getPartitionKeys ( String location , Job job ) 
 + { 
 + return null ; 
 + } 
 + 
 + public void setPartitionFilter ( Expression partitionFilter ) 
 + { 
 + / / no - op 
 + } 
 + 
 @ Override 
 public String relativeToAbsolutePath ( String location , Path curDir ) throws IOException 
 { 
 @ @ - 355 , 8 + 461 , 6 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface 
 DefaultDataBag pairs = ( DefaultDataBag ) t . get ( 1 ) ; 
 ArrayList < Mutation > mutationList = new ArrayList < Mutation > ( ) ; 
 CfDef cfDef = getCfDef ( storeSignature ) ; 
 - List < AbstractType > marshallers = getDefaultMarshallers ( cfDef ) ; 
 - Map < ByteBuffer , AbstractType > validators = getValidatorMap ( cfDef ) ; 
 try 
 { 
 for ( Tuple pair : pairs ) 
 @ @ - 400 , 15 + 504 , 8 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface 
 else 
 { 
 org . apache . cassandra . thrift . Column column = new org . apache . cassandra . thrift . Column ( ) ; 
 - column . name = marshallers . get ( 0 ) . decompose ( ( pair . get ( 0 ) ) ) ; 
 - if ( validators . get ( column . name ) = = null ) 
 - / / Have to special case BytesType to convert DataByteArray into ByteBuffer 
 - if ( marshallers . get ( 1 ) instanceof BytesType ) 
 - column . value = objToBB ( pair . get ( 1 ) ) ; 
 - else 
 - column . value = marshallers . get ( 1 ) . decompose ( pair . get ( 1 ) ) ; 
 - else 
 - column . value = validators . get ( column . name ) . decompose ( pair . get ( 1 ) ) ; 
 + column . name = objToBB ( pair . get ( 0 ) ) ; 
 + column . value = objToBB ( pair . get ( 1 ) ) ; 
 column . setTimestamp ( System . currentTimeMillis ( ) * 1000 ) ; 
 mutation . column _ or _ supercolumn = new ColumnOrSuperColumn ( ) ; 
 mutation . column _ or _ supercolumn . column = column ; 
 @ @ - 528 , 3 + 625 , 4 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface 
 return cfDef ; 
 } 
 } 
 + 
 diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java 
 index e08ffd8 . . 3451ed1 100644 
 - - - a / src / java / org / apache / cassandra / db / CollationController . java 
 + + + b / src / java / org / apache / cassandra / db / CollationController . java 
 @ @ - 42 , 16 + 42 , 16 @ @ public class CollationController 
 private static Logger logger = LoggerFactory . getLogger ( CollationController . class ) ; 
 
 private final ColumnFamilyStore cfs ; 
 - private final ISortedColumns . Factory factory ; 
 + private final boolean mutableColumns ; 
 private final QueryFilter filter ; 
 private final int gcBefore ; 
 
 private int sstablesIterated = 0 ; 
 
 - public CollationController ( ColumnFamilyStore cfs , ISortedColumns . Factory factory , QueryFilter filter , int gcBefore ) 
 + public CollationController ( ColumnFamilyStore cfs , boolean mutableColumns , QueryFilter filter , int gcBefore ) 
 { 
 this . cfs = cfs ; 
 - this . factory = factory ; 
 + this . mutableColumns = mutableColumns ; 
 this . filter = filter ; 
 this . gcBefore = gcBefore ; 
 } 
 @ @ - 72 , 6 + 72 , 9 @ @ public class CollationController 
 { 
 logger . debug ( " collectTimeOrderedData " ) ; 
 
 + ISortedColumns . Factory factory = mutableColumns 
 + ? ThreadSafeSortedColumns . factory ( ) 
 + : TreeMapBackedSortedColumns . factory ( ) ; 
 ColumnFamily container = ColumnFamily . create ( cfs . metadata , factory , filter . filter . isReversed ( ) ) ; 
 List < IColumnIterator > iterators = new ArrayList < IColumnIterator > ( ) ; 
 ColumnFamilyStore . ViewFragment view = cfs . markReferenced ( filter . key ) ; 
 @ @ - 184 , 6 + 187 , 9 @ @ public class CollationController 
 private ColumnFamily collectAllData ( ) 
 { 
 logger . debug ( " collectAllData " ) ; 
 + ISortedColumns . Factory factory = mutableColumns 
 + ? ThreadSafeSortedColumns . factory ( ) 
 + : ArrayBackedSortedColumns . factory ( ) ; 
 List < IColumnIterator > iterators = new ArrayList < IColumnIterator > ( ) ; 
 ColumnFamily returnCF = ColumnFamily . create ( cfs . metadata , factory , filter . filter . isReversed ( ) ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 92c6eff . . 067308b 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1106 , 12 + 1106 , 12 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 * / 
 public ColumnFamily getColumnFamily ( QueryFilter filter ) 
 { 
 - return getColumnFamily ( filter , gcBefore ( ) , ThreadSafeSortedColumns . factory ( ) ) ; 
 + return getColumnFamily ( filter , gcBefore ( ) ) ; 
 } 
 
 public ColumnFamily getColumnFamily ( QueryFilter filter , ISortedColumns . Factory factory ) 
 { 
 - return getColumnFamily ( filter , gcBefore ( ) , factory ) ; 
 + return getColumnFamily ( filter , gcBefore ( ) ) ; 
 } 
 
 public int gcBefore ( ) 
 @ @ - 1125 , 7 + 1125 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 if ( ( cached = rowCache . get ( key ) ) = = null ) 
 { 
 / / We force ThreadSafeSortedColumns because cached row will be accessed concurrently 
 - cached = getTopLevelColumns ( QueryFilter . getIdentityFilter ( key , new QueryPath ( columnFamily ) ) , Integer . MIN _ VALUE , ThreadSafeSortedColumns . factory ( ) ) ; 
 + cached = getTopLevelColumns ( QueryFilter . getIdentityFilter ( key , new QueryPath ( columnFamily ) ) , Integer . MIN _ VALUE , true ) ; 
 if ( cached = = null ) 
 return null ; 
 
 @ @ - 1135 , 7 + 1135 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 return cached ; 
 } 
 
 - private ColumnFamily getColumnFamily ( QueryFilter filter , int gcBefore , ISortedColumns . Factory factory ) 
 + private ColumnFamily getColumnFamily ( QueryFilter filter , int gcBefore ) 
 { 
 assert columnFamily . equals ( filter . getColumnFamilyName ( ) ) : filter . getColumnFamilyName ( ) ; 
 
 @ @ - 1144 , 7 + 1144 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 if ( rowCache . getCapacity ( ) = = 0 ) 
 { 
 - ColumnFamily cf = getTopLevelColumns ( filter , gcBefore , factory ) ; 
 + ColumnFamily cf = getTopLevelColumns ( filter , gcBefore , false ) ; 
 
 if ( cf = = null ) 
 return null ; 
 @ @ - 1291 , 9 + 1291 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 return new ViewFragment ( sstables , Iterables . concat ( Collections . singleton ( view . memtable ) , view . memtablesPendingFlush ) ) ; 
 } 
 
 - private ColumnFamily getTopLevelColumns ( QueryFilter filter , int gcBefore , ISortedColumns . Factory factory ) 
 + private ColumnFamily getTopLevelColumns ( QueryFilter filter , int gcBefore , boolean forCache ) 
 { 
 - CollationController controller = new CollationController ( this , factory , filter , gcBefore ) ; 
 + CollationController controller = new CollationController ( this , forCache , filter , gcBefore ) ; 
 ColumnFamily columns = controller . getTopLevelColumns ( ) ; 
 recentSSTablesPerRead . add ( controller . getSstablesIterated ( ) ) ; 
 sstablesPerRead . add ( controller . getSstablesIterated ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 index d4bcaf6 . . b08b5d0 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 @ @ - 97 , 11 + 97 , 10 @ @ public class CommitLogSegment 
 
 public ReplayPosition write ( RowMutation rowMutation ) throws IOException 
 { 
 - long currentPosition = - 1L ; 
 + ReplayPosition cLogCtx = getContext ( ) ; 
 + 
 try 
 { 
 - ReplayPosition cLogCtx = getContext ( ) ; 
 - 
 for ( ColumnFamily columnFamily : rowMutation . getColumnFamilies ( ) ) 
 { 
 / / check for null cfm in case a cl write goes through after the cf is 
 @ @ - 113 , 7 + 112 , 7 @ @ public class CommitLogSegment 
 } 
 else 
 { 
 - turnOn ( cfm . cfId , ( int ) currentPosition ) ; 
 + turnOn ( cfm . cfId , cLogCtx . position ) ; 
 } 
 } 
 
 @ @ - 131 , 8 + 130 , 7 @ @ public class CommitLogSegment 
 } 
 catch ( IOException e ) 
 { 
 - if ( currentPosition ! = - 1 ) 
 - logWriter . truncate ( currentPosition ) ; 
 + logWriter . truncate ( cLogCtx . position ) ; 
 throw e ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index 922a7dd . . 43bbdce 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 486 , 6 + 486 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 
 String indexFilename = sstable . descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ; 
 RandomAccessReader indexFile = RandomAccessReader . open ( new File ( indexFilename ) , true ) ; 
 + ScrubInfo scrubInfo = new ScrubInfo ( dataFile , sstable ) ; 
 + 
 try 
 { 
 ByteBuffer nextIndexKey = ByteBufferUtil . readWithShortLength ( indexFile ) ; 
 @ @ - 495 , 12 + 497 , 19 @ @ public class CompactionManager implements CompactionManagerMBean 
 assert firstRowPositionFromIndex = = 0 : firstRowPositionFromIndex ; 
 } 
 
 - / / errors when creating the writer may leave empty temp files . 
 - SSTableWriter writer = maybeCreateWriter ( cfs , compactionFileLocation , expectedBloomFilterSize , null , Collections . singletonList ( sstable ) ) ; 
 SSTableReader newSstable = null ; 
 - executor . beginCompaction ( new ScrubInfo ( dataFile , sstable ) ) ; 
 + 
 + / / errors when creating the writer may leave empty temp files . 
 + SSTableWriter writer = maybeCreateWriter ( cfs , 
 + compactionFileLocation , 
 + expectedBloomFilterSize , 
 + null , 
 + Collections . singletonList ( sstable ) ) ; 
 + 
 int goodRows = 0 , badRows = 0 , emptyRows = 0 ; 
 
 + executor . beginCompaction ( scrubInfo ) ; 
 + 
 try 
 { 
 while ( ! dataFile . isEOF ( ) ) 
 @ @ - 649 , 6 + 658 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 { 
 FileUtils . closeQuietly ( dataFile ) ; 
 FileUtils . closeQuietly ( indexFile ) ; 
 + 
 + executor . finishCompaction ( scrubInfo ) ; 
 } 
 } 

