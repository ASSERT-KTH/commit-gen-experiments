BLEU SCORE: 0.04767707020457096

TEST MSG: Flush system . repair table before IR finalize promise
GENERATED MSG: Start compaction when incremental repair finishes

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 52bb6d2 . . 22045e8 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Flush system . repair table before IR finalize promise ( CASSANDRA - 13660 ) <nl> * Fix column filter creation for wildcard queries ( CASSANDRA - 13650 ) <nl> * Add ' nodetool getbatchlogreplaythrottle ' and ' nodetool setbatchlogreplaythrottle ' ( CASSANDRA - 13614 ) <nl> * fix race condition in PendingRepairManager ( CASSANDRA - 13659 ) <nl> diff - - git a / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java b / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java <nl> index 72ec50b . . 61df2b0 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java <nl> + + + b / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java <nl> @ @ - 374 , 6 + 374 , 13 @ @ public class LocalSessions <nl> QueryProcessor . executeInternal ( String . format ( query , keyspace , table ) , sessionID ) ; <nl> } <nl> <nl> + private void syncTable ( ) <nl> + { <nl> + TableId tid = Schema . instance . getTableMetadata ( keyspace , table ) . id ; <nl> + ColumnFamilyStore cfm = Schema . instance . getColumnFamilyStoreInstance ( tid ) ; <nl> + cfm . forceBlockingFlush ( ) ; <nl> + } <nl> + <nl> / * * <nl> * Loads a session directly from the table . Should be used for testing only <nl> * / <nl> @ @ - 585 , 7 + 592 , 7 @ @ public class LocalSessions <nl> LocalSession session = getSession ( sessionID ) ; <nl> if ( session = = null ) <nl> { <nl> - logger . debug ( " Received FinalizePropose message for unknown repair session { } , responding with failure " ) ; <nl> + logger . debug ( " Received FinalizePropose message for unknown repair session { } , responding with failure " , sessionID ) ; <nl> sendMessage ( from , new FailSession ( sessionID ) ) ; <nl> return ; <nl> } <nl> @ @ - 593 , 8 + 600 , 18 @ @ public class LocalSessions <nl> try <nl> { <nl> setStateAndSave ( session , FINALIZE _ PROMISED ) ; <nl> + <nl> + / * <nl> + Flushing the repairs table here , * before * responding to the coordinator prevents a scenario where we respond <nl> + with a promise to the coordinator , but there is a failure before the commit log mutation with the <nl> + FINALIZE _ PROMISED status is synced to disk . This could cause the state for this session to revert to an <nl> + earlier status on startup , which would prevent the failure recovery mechanism from ever being able to promote <nl> + this session to FINALIZED , likely creating inconsistencies in the repaired data sets across nodes . <nl> + * / <nl> + syncTable ( ) ; <nl> + <nl> sendMessage ( from , new FinalizePromise ( sessionID , getBroadcastAddress ( ) , true ) ) ; <nl> - logger . debug ( " Received FinalizePropose message for incremental repair session { } , responded with FinalizePromise " ) ; <nl> + logger . debug ( " Received FinalizePropose message for incremental repair session { } , responded with FinalizePromise " , sessionID ) ; <nl> } <nl> catch ( IllegalArgumentException e ) <nl> {
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 52bb6d2 . . 22045e8 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Flush system . repair table before IR finalize promise ( CASSANDRA - 13660 ) 
 * Fix column filter creation for wildcard queries ( CASSANDRA - 13650 ) 
 * Add ' nodetool getbatchlogreplaythrottle ' and ' nodetool setbatchlogreplaythrottle ' ( CASSANDRA - 13614 ) 
 * fix race condition in PendingRepairManager ( CASSANDRA - 13659 ) 
 diff - - git a / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java b / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java 
 index 72ec50b . . 61df2b0 100644 
 - - - a / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java 
 + + + b / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java 
 @ @ - 374 , 6 + 374 , 13 @ @ public class LocalSessions 
 QueryProcessor . executeInternal ( String . format ( query , keyspace , table ) , sessionID ) ; 
 } 
 
 + private void syncTable ( ) 
 + { 
 + TableId tid = Schema . instance . getTableMetadata ( keyspace , table ) . id ; 
 + ColumnFamilyStore cfm = Schema . instance . getColumnFamilyStoreInstance ( tid ) ; 
 + cfm . forceBlockingFlush ( ) ; 
 + } 
 + 
 / * * 
 * Loads a session directly from the table . Should be used for testing only 
 * / 
 @ @ - 585 , 7 + 592 , 7 @ @ public class LocalSessions 
 LocalSession session = getSession ( sessionID ) ; 
 if ( session = = null ) 
 { 
 - logger . debug ( " Received FinalizePropose message for unknown repair session { } , responding with failure " ) ; 
 + logger . debug ( " Received FinalizePropose message for unknown repair session { } , responding with failure " , sessionID ) ; 
 sendMessage ( from , new FailSession ( sessionID ) ) ; 
 return ; 
 } 
 @ @ - 593 , 8 + 600 , 18 @ @ public class LocalSessions 
 try 
 { 
 setStateAndSave ( session , FINALIZE _ PROMISED ) ; 
 + 
 + / * 
 + Flushing the repairs table here , * before * responding to the coordinator prevents a scenario where we respond 
 + with a promise to the coordinator , but there is a failure before the commit log mutation with the 
 + FINALIZE _ PROMISED status is synced to disk . This could cause the state for this session to revert to an 
 + earlier status on startup , which would prevent the failure recovery mechanism from ever being able to promote 
 + this session to FINALIZED , likely creating inconsistencies in the repaired data sets across nodes . 
 + * / 
 + syncTable ( ) ; 
 + 
 sendMessage ( from , new FinalizePromise ( sessionID , getBroadcastAddress ( ) , true ) ) ; 
 - logger . debug ( " Received FinalizePropose message for incremental repair session { } , responded with FinalizePromise " ) ; 
 + logger . debug ( " Received FinalizePropose message for incremental repair session { } , responded with FinalizePromise " , sessionID ) ; 
 } 
 catch ( IllegalArgumentException e ) 
 {

NEAREST DIFF:
ELIMINATEDSENTENCE
