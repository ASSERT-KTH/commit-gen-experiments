BLEU SCORE: 0.015445276590783498

TEST MSG: Don ' t use - 1 as position for partition key in schema
GENERATED MSG: Reuse TemporalRow when updating multiple MaterializedViews

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a72cab2 . . 146ee73 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 <nl> + * Don ' t use - 1 for the position of partition key in schema ( CASSANDRA - 10491 ) <nl> * Fix distinct queries in mixed version cluster ( CASSANDRA - 10573 ) <nl> * Skip sstable on clustering in names query ( CASSANDRA - 10571 ) <nl> * Remove value skipping as it breaks read - repair ( CASSANDRA - 10655 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index 86f78eb . . 4d5a176 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 1266 , 8 + 1266 , 7 @ @ public final class CFMetaData <nl> for ( int i = 0 ; i < partitionKeys . size ( ) ; i + + ) <nl> { <nl> Pair < ColumnIdentifier , AbstractType > p = partitionKeys . get ( i ) ; <nl> - int position = partitionKeys . size ( ) = = 1 ? ColumnDefinition . NO _ POSITION : i ; <nl> - partitions . add ( new ColumnDefinition ( keyspace , table , p . left , p . right , position , ColumnDefinition . Kind . PARTITION _ KEY ) ) ; <nl> + partitions . add ( new ColumnDefinition ( keyspace , table , p . left , p . right , i , ColumnDefinition . Kind . PARTITION _ KEY ) ) ; <nl> } <nl> <nl> for ( int i = 0 ; i < clusteringColumns . size ( ) ; i + + ) <nl> diff - - git a / src / java / org / apache / cassandra / config / ColumnDefinition . java b / src / java / org / apache / cassandra / config / ColumnDefinition . java <nl> index 96513c2 . . 6bcc2e0 100644 <nl> - - - a / src / java / org / apache / cassandra / config / ColumnDefinition . java <nl> + + + b / src / java / org / apache / cassandra / config / ColumnDefinition . java <nl> @ @ - 69 , 9 + 69 , 11 @ @ public class ColumnDefinition extends ColumnSpecification implements Comparable < <nl> public final Kind kind ; <nl> <nl> / * <nl> - * If the column comparator is a composite type , indicates to which <nl> - * component this definition refers to . If NO _ POSITION ( - 1 ) , the definition refers to <nl> - * the full column name . <nl> + * If the column is a partition key or clustering column , its position relative to <nl> + * other columns of the same kind . Otherwise , NO _ POSITION ( - 1 ) . <nl> + * <nl> + * Note that partition key and clustering columns are numbered separately so <nl> + * the first clustering column is 0 . <nl> * / <nl> private final int position ; <nl> <nl> @ @ - 150 , 14 + 152 , 14 @ @ public class ColumnDefinition extends ColumnSpecification implements Comparable < <nl> super ( ksName , cfName , name , type ) ; <nl> assert name ! = null & & type ! = null & & kind ! = null ; <nl> assert name . isInterned ( ) ; <nl> - assert position = = NO _ POSITION | | kind . isPrimaryKeyKind ( ) ; / / The position really only make sense for partition and clustering columns , <nl> - / / so make sure we don ' t sneak it for something else since it ' d breaks equals ( ) <nl> + assert ( position = = NO _ POSITION ) = = ! kind . isPrimaryKeyKind ( ) ; / / The position really only make sense for partition and clustering columns ( and those must have one ) , <nl> + / / so make sure we don ' t sneak it for something else since it ' d breaks equals ( ) <nl> this . kind = kind ; <nl> this . position = position ; <nl> this . cellPathComparator = makeCellPathComparator ( kind , type ) ; <nl> this . cellComparator = cellPathComparator = = null ? ColumnData . comparator : ( a , b ) - > cellPathComparator . compare ( a . path ( ) , b . path ( ) ) ; <nl> this . asymmetricCellPathComparator = cellPathComparator = = null ? null : ( a , b ) - > cellPathComparator . compare ( ( ( Cell ) a ) . path ( ) , ( CellPath ) b ) ; <nl> - this . comparisonOrder = comparisonOrder ( kind , isComplex ( ) , position ( ) , name ) ; <nl> + this . comparisonOrder = comparisonOrder ( kind , isComplex ( ) , Math . max ( 0 , position ) , name ) ; <nl> } <nl> <nl> private static Comparator < CellPath > makeCellPathComparator ( Kind kind , AbstractType < ? > type ) <nl> @ @ - 202 , 11 + 204 , 6 @ @ public class ColumnDefinition extends ColumnSpecification implements Comparable < <nl> return new ColumnDefinition ( ksName , cfName , name , newType , position , kind ) ; <nl> } <nl> <nl> - public boolean isOnAllComponents ( ) <nl> - { <nl> - return position = = NO _ POSITION ; <nl> - } <nl> - <nl> public boolean isPartitionKey ( ) <nl> { <nl> return kind = = Kind . PARTITION _ KEY ; <nl> @ @ - 235 , 13 + 232 , 9 @ @ public class ColumnDefinition extends ColumnSpecification implements Comparable < <nl> return type . isReversed ( ) ? ClusteringOrder . DESC : ClusteringOrder . ASC ; <nl> } <nl> <nl> - / * * <nl> - * For convenience sake , if position = = NO _ POSITION , this method will return 0 . The callers should first check <nl> - * isOnAllComponents ( ) to distinguish between proper 0 position and NO _ POSITION . <nl> - * / <nl> public int position ( ) <nl> { <nl> - return Math . max ( 0 , position ) ; <nl> + return position ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> index d11d2c5 . . e26a1eb 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> @ @ - 114 , 7 + 114 , 7 @ @ public class CreateIndexStatement extends SchemaAlteringStatement <nl> if ( ! cfm . isCompactTable ( ) & & cd . isStatic ( ) ) <nl> throw new InvalidRequestException ( " Secondary indexes are not allowed on static columns " ) ; <nl> <nl> - if ( cd . kind = = ColumnDefinition . Kind . PARTITION _ KEY & & cd . isOnAllComponents ( ) ) <nl> + if ( cd . kind = = ColumnDefinition . Kind . PARTITION _ KEY & & cfm . getKeyValidatorAsClusteringComparator ( ) . size ( ) = = 1 ) <nl> throw new InvalidRequestException ( String . format ( " Cannot create secondary index on partition key column % s " , target . column ) ) ; <nl> <nl> boolean isMap = cd . type instanceof MapType ; <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / RowFilter . java b / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> index 09dc342 . . 17db323 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> @ @ - 222 , 6 + 222 , 8 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> if ( expressions . isEmpty ( ) ) <nl> return iter ; <nl> <nl> + final CFMetaData metadata = iter . metadata ( ) ; <nl> + <nl> class IsSatisfiedFilter extends Transformation < UnfilteredRowIterator > <nl> { <nl> DecoratedKey pk ; <nl> @ @ - 238 , 7 + 240 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> return null ; <nl> <nl> for ( Expression e : expressions ) <nl> - if ( ! e . isSatisfiedBy ( pk , purged ) ) <nl> + if ( ! e . isSatisfiedBy ( metadata , pk , purged ) ) <nl> return null ; <nl> return row ; <nl> } <nl> @ @ - 282 , 7 + 284 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> { <nl> assert expr instanceof ThriftExpression ; <nl> Row row = result . getRow ( makeCompactClustering ( iter . metadata ( ) , expr . column ( ) . name . bytes ) ) ; <nl> - if ( row = = null | | ! expr . isSatisfiedBy ( iter . partitionKey ( ) , row ) ) <nl> + if ( row = = null | | ! expr . isSatisfiedBy ( iter . metadata ( ) , iter . partitionKey ( ) , row ) ) <nl> return null ; <nl> } <nl> / / If we get there , it means all expressions where satisfied , so return the original result <nl> @ @ - 378 , 16 + 380 , 16 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> * ( i . e . it should come from a RowIterator ) . <nl> * @ return whether the row is satisfied by this expression . <nl> * / <nl> - public abstract boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) ; <nl> + public abstract boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) ; <nl> <nl> - protected ByteBuffer getValue ( DecoratedKey partitionKey , Row row ) <nl> + protected ByteBuffer getValue ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) <nl> { <nl> switch ( column . kind ) <nl> { <nl> case PARTITION _ KEY : <nl> - return column . isOnAllComponents ( ) <nl> - ? partitionKey . getKey ( ) <nl> - : CompositeType . extractComponent ( partitionKey . getKey ( ) , column . position ( ) ) ; <nl> + return metadata . getKeyValidator ( ) instanceof CompositeType <nl> + ? CompositeType . extractComponent ( partitionKey . getKey ( ) , column . position ( ) ) <nl> + : partitionKey . getKey ( ) ; <nl> case CLUSTERING : <nl> return row . clustering ( ) . get ( column . position ( ) ) ; <nl> default : <nl> @ @ - 572 , 7 + 574 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> super ( column , operator , value ) ; <nl> } <nl> <nl> - public boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) <nl> + public boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) <nl> { <nl> / / We support null conditions for LWT ( in ColumnCondition ) but not for RowFilter . <nl> / / TODO : we should try to merge both code someday . <nl> @ @ - 591 , 7 + 593 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> case NEQ : <nl> { <nl> assert ! column . isComplex ( ) : " Only CONTAINS and CONTAINS _ KEY are supported for ' complex ' types " ; <nl> - ByteBuffer foundValue = getValue ( partitionKey , row ) ; <nl> + ByteBuffer foundValue = getValue ( metadata , partitionKey , row ) ; <nl> / / Note that CQL expression are always of the form ' x < 4 ' , i . e . the tested value is on the left . <nl> return foundValue ! = null & & operator . isSatisfiedBy ( column . type , foundValue , value ) ; <nl> } <nl> @ @ - 618 , 7 + 620 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> } <nl> else <nl> { <nl> - ByteBuffer foundValue = getValue ( partitionKey , row ) ; <nl> + ByteBuffer foundValue = getValue ( metadata , partitionKey , row ) ; <nl> if ( foundValue = = null ) <nl> return false ; <nl> <nl> @ @ - 645 , 7 + 647 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> } <nl> else <nl> { <nl> - ByteBuffer foundValue = getValue ( partitionKey , row ) ; <nl> + ByteBuffer foundValue = getValue ( metadata , partitionKey , row ) ; <nl> return foundValue ! = null & & mapType . getSerializer ( ) . getSerializedValue ( foundValue , value , mapType . getKeysType ( ) ) ! = null ; <nl> } <nl> <nl> @ @ - 717 , 7 + 719 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> return CompositeType . build ( key , value ) ; <nl> } <nl> <nl> - public boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) <nl> + public boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) <nl> { <nl> assert key ! = null ; <nl> / / We support null conditions for LWT ( in ColumnCondition ) but not for RowFilter . <nl> @ @ - 735 , 7 + 737 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> } <nl> else <nl> { <nl> - ByteBuffer serializedMap = getValue ( partitionKey , row ) ; <nl> + ByteBuffer serializedMap = getValue ( metadata , partitionKey , row ) ; <nl> if ( serializedMap = = null ) <nl> return false ; <nl> <nl> @ @ - 807 , 7 + 809 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> return ColumnDefinition . regularDef ( metadata , name , metadata . compactValueColumn ( ) . type ) ; <nl> } <nl> <nl> - public boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) <nl> + public boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) <nl> { <nl> assert value ! = null ; <nl> <nl> @ @ - 882 , 7 + 884 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> } <nl> <nl> / / Filtering by custom expressions isn ' t supported yet , so just accept any row <nl> - public boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) <nl> + public boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) <nl> { <nl> return true ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / view / TemporalRow . java b / src / java / org / apache / cassandra / db / view / TemporalRow . java <nl> index 46dc3fa . . d876b00 100644 <nl> - - - a / src / java / org / apache / cassandra / db / view / TemporalRow . java <nl> + + + b / src / java / org / apache / cassandra / db / view / TemporalRow . java <nl> @ @ - 380 , 14 + 380 , 16 @ @ public class TemporalRow <nl> <nl> if ( baseDefinition . isPartitionKey ( ) ) <nl> { <nl> - if ( baseDefinition . isOnAllComponents ( ) ) <nl> - return basePartitionKey ; <nl> - else <nl> + if ( baseCfs . metadata . getKeyValidator ( ) instanceof CompositeType ) <nl> { <nl> CompositeType keyComparator = ( CompositeType ) baseCfs . metadata . getKeyValidator ( ) ; <nl> ByteBuffer [ ] components = keyComparator . split ( basePartitionKey ) ; <nl> return components [ baseDefinition . position ( ) ] ; <nl> } <nl> + else <nl> + { <nl> + return basePartitionKey ; <nl> + } <nl> } <nl> else <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> index 79f9e99 . . 9008cc8 100644 <nl> - - - a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> + + + b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> @ @ - 486 , 7 + 486 , 7 @ @ public final class LegacySchemaMigrator <nl> } <nl> else if ( isStaticCompactTable ) <nl> { <nl> - defs . add ( ColumnDefinition . clusteringDef ( ksName , cfName , names . defaultClusteringName ( ) , rawComparator , ColumnDefinition . NO _ POSITION ) ) ; <nl> + defs . add ( ColumnDefinition . clusteringDef ( ksName , cfName , names . defaultClusteringName ( ) , rawComparator , 0 ) ) ; <nl> defs . add ( ColumnDefinition . regularDef ( ksName , cfName , names . defaultCompactValueName ( ) , defaultValidator ) ) ; <nl> } <nl> else <nl> @ @ - 586 , 8 + 586 , 9 @ @ public final class LegacySchemaMigrator <nl> / / Note that the component _ index is not useful for non - primary key parts ( it never really in fact since there is <nl> / / no particular ordering of non - PK columns , we only used to use it as a simplification but that ' s not needed <nl> / / anymore ) <nl> - if ( kind . isPrimaryKeyKind ( ) & & row . has ( " component _ index " ) ) <nl> - componentIndex = row . getInt ( " component _ index " ) ; <nl> + if ( kind . isPrimaryKeyKind ( ) ) <nl> + / / We use to not have a component index when there was a single partition key , we don ' t anymore
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a72cab2 . . 146ee73 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 
 + * Don ' t use - 1 for the position of partition key in schema ( CASSANDRA - 10491 ) 
 * Fix distinct queries in mixed version cluster ( CASSANDRA - 10573 ) 
 * Skip sstable on clustering in names query ( CASSANDRA - 10571 ) 
 * Remove value skipping as it breaks read - repair ( CASSANDRA - 10655 ) 
 diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index 86f78eb . . 4d5a176 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 1266 , 8 + 1266 , 7 @ @ public final class CFMetaData 
 for ( int i = 0 ; i < partitionKeys . size ( ) ; i + + ) 
 { 
 Pair < ColumnIdentifier , AbstractType > p = partitionKeys . get ( i ) ; 
 - int position = partitionKeys . size ( ) = = 1 ? ColumnDefinition . NO _ POSITION : i ; 
 - partitions . add ( new ColumnDefinition ( keyspace , table , p . left , p . right , position , ColumnDefinition . Kind . PARTITION _ KEY ) ) ; 
 + partitions . add ( new ColumnDefinition ( keyspace , table , p . left , p . right , i , ColumnDefinition . Kind . PARTITION _ KEY ) ) ; 
 } 
 
 for ( int i = 0 ; i < clusteringColumns . size ( ) ; i + + ) 
 diff - - git a / src / java / org / apache / cassandra / config / ColumnDefinition . java b / src / java / org / apache / cassandra / config / ColumnDefinition . java 
 index 96513c2 . . 6bcc2e0 100644 
 - - - a / src / java / org / apache / cassandra / config / ColumnDefinition . java 
 + + + b / src / java / org / apache / cassandra / config / ColumnDefinition . java 
 @ @ - 69 , 9 + 69 , 11 @ @ public class ColumnDefinition extends ColumnSpecification implements Comparable < 
 public final Kind kind ; 
 
 / * 
 - * If the column comparator is a composite type , indicates to which 
 - * component this definition refers to . If NO _ POSITION ( - 1 ) , the definition refers to 
 - * the full column name . 
 + * If the column is a partition key or clustering column , its position relative to 
 + * other columns of the same kind . Otherwise , NO _ POSITION ( - 1 ) . 
 + * 
 + * Note that partition key and clustering columns are numbered separately so 
 + * the first clustering column is 0 . 
 * / 
 private final int position ; 
 
 @ @ - 150 , 14 + 152 , 14 @ @ public class ColumnDefinition extends ColumnSpecification implements Comparable < 
 super ( ksName , cfName , name , type ) ; 
 assert name ! = null & & type ! = null & & kind ! = null ; 
 assert name . isInterned ( ) ; 
 - assert position = = NO _ POSITION | | kind . isPrimaryKeyKind ( ) ; / / The position really only make sense for partition and clustering columns , 
 - / / so make sure we don ' t sneak it for something else since it ' d breaks equals ( ) 
 + assert ( position = = NO _ POSITION ) = = ! kind . isPrimaryKeyKind ( ) ; / / The position really only make sense for partition and clustering columns ( and those must have one ) , 
 + / / so make sure we don ' t sneak it for something else since it ' d breaks equals ( ) 
 this . kind = kind ; 
 this . position = position ; 
 this . cellPathComparator = makeCellPathComparator ( kind , type ) ; 
 this . cellComparator = cellPathComparator = = null ? ColumnData . comparator : ( a , b ) - > cellPathComparator . compare ( a . path ( ) , b . path ( ) ) ; 
 this . asymmetricCellPathComparator = cellPathComparator = = null ? null : ( a , b ) - > cellPathComparator . compare ( ( ( Cell ) a ) . path ( ) , ( CellPath ) b ) ; 
 - this . comparisonOrder = comparisonOrder ( kind , isComplex ( ) , position ( ) , name ) ; 
 + this . comparisonOrder = comparisonOrder ( kind , isComplex ( ) , Math . max ( 0 , position ) , name ) ; 
 } 
 
 private static Comparator < CellPath > makeCellPathComparator ( Kind kind , AbstractType < ? > type ) 
 @ @ - 202 , 11 + 204 , 6 @ @ public class ColumnDefinition extends ColumnSpecification implements Comparable < 
 return new ColumnDefinition ( ksName , cfName , name , newType , position , kind ) ; 
 } 
 
 - public boolean isOnAllComponents ( ) 
 - { 
 - return position = = NO _ POSITION ; 
 - } 
 - 
 public boolean isPartitionKey ( ) 
 { 
 return kind = = Kind . PARTITION _ KEY ; 
 @ @ - 235 , 13 + 232 , 9 @ @ public class ColumnDefinition extends ColumnSpecification implements Comparable < 
 return type . isReversed ( ) ? ClusteringOrder . DESC : ClusteringOrder . ASC ; 
 } 
 
 - / * * 
 - * For convenience sake , if position = = NO _ POSITION , this method will return 0 . The callers should first check 
 - * isOnAllComponents ( ) to distinguish between proper 0 position and NO _ POSITION . 
 - * / 
 public int position ( ) 
 { 
 - return Math . max ( 0 , position ) ; 
 + return position ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 index d11d2c5 . . e26a1eb 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 @ @ - 114 , 7 + 114 , 7 @ @ public class CreateIndexStatement extends SchemaAlteringStatement 
 if ( ! cfm . isCompactTable ( ) & & cd . isStatic ( ) ) 
 throw new InvalidRequestException ( " Secondary indexes are not allowed on static columns " ) ; 
 
 - if ( cd . kind = = ColumnDefinition . Kind . PARTITION _ KEY & & cd . isOnAllComponents ( ) ) 
 + if ( cd . kind = = ColumnDefinition . Kind . PARTITION _ KEY & & cfm . getKeyValidatorAsClusteringComparator ( ) . size ( ) = = 1 ) 
 throw new InvalidRequestException ( String . format ( " Cannot create secondary index on partition key column % s " , target . column ) ) ; 
 
 boolean isMap = cd . type instanceof MapType ; 
 diff - - git a / src / java / org / apache / cassandra / db / filter / RowFilter . java b / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 index 09dc342 . . 17db323 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 + + + b / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 @ @ - 222 , 6 + 222 , 8 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 if ( expressions . isEmpty ( ) ) 
 return iter ; 
 
 + final CFMetaData metadata = iter . metadata ( ) ; 
 + 
 class IsSatisfiedFilter extends Transformation < UnfilteredRowIterator > 
 { 
 DecoratedKey pk ; 
 @ @ - 238 , 7 + 240 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 return null ; 
 
 for ( Expression e : expressions ) 
 - if ( ! e . isSatisfiedBy ( pk , purged ) ) 
 + if ( ! e . isSatisfiedBy ( metadata , pk , purged ) ) 
 return null ; 
 return row ; 
 } 
 @ @ - 282 , 7 + 284 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 { 
 assert expr instanceof ThriftExpression ; 
 Row row = result . getRow ( makeCompactClustering ( iter . metadata ( ) , expr . column ( ) . name . bytes ) ) ; 
 - if ( row = = null | | ! expr . isSatisfiedBy ( iter . partitionKey ( ) , row ) ) 
 + if ( row = = null | | ! expr . isSatisfiedBy ( iter . metadata ( ) , iter . partitionKey ( ) , row ) ) 
 return null ; 
 } 
 / / If we get there , it means all expressions where satisfied , so return the original result 
 @ @ - 378 , 16 + 380 , 16 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 * ( i . e . it should come from a RowIterator ) . 
 * @ return whether the row is satisfied by this expression . 
 * / 
 - public abstract boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) ; 
 + public abstract boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) ; 
 
 - protected ByteBuffer getValue ( DecoratedKey partitionKey , Row row ) 
 + protected ByteBuffer getValue ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) 
 { 
 switch ( column . kind ) 
 { 
 case PARTITION _ KEY : 
 - return column . isOnAllComponents ( ) 
 - ? partitionKey . getKey ( ) 
 - : CompositeType . extractComponent ( partitionKey . getKey ( ) , column . position ( ) ) ; 
 + return metadata . getKeyValidator ( ) instanceof CompositeType 
 + ? CompositeType . extractComponent ( partitionKey . getKey ( ) , column . position ( ) ) 
 + : partitionKey . getKey ( ) ; 
 case CLUSTERING : 
 return row . clustering ( ) . get ( column . position ( ) ) ; 
 default : 
 @ @ - 572 , 7 + 574 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 super ( column , operator , value ) ; 
 } 
 
 - public boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) 
 + public boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) 
 { 
 / / We support null conditions for LWT ( in ColumnCondition ) but not for RowFilter . 
 / / TODO : we should try to merge both code someday . 
 @ @ - 591 , 7 + 593 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 case NEQ : 
 { 
 assert ! column . isComplex ( ) : " Only CONTAINS and CONTAINS _ KEY are supported for ' complex ' types " ; 
 - ByteBuffer foundValue = getValue ( partitionKey , row ) ; 
 + ByteBuffer foundValue = getValue ( metadata , partitionKey , row ) ; 
 / / Note that CQL expression are always of the form ' x < 4 ' , i . e . the tested value is on the left . 
 return foundValue ! = null & & operator . isSatisfiedBy ( column . type , foundValue , value ) ; 
 } 
 @ @ - 618 , 7 + 620 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 } 
 else 
 { 
 - ByteBuffer foundValue = getValue ( partitionKey , row ) ; 
 + ByteBuffer foundValue = getValue ( metadata , partitionKey , row ) ; 
 if ( foundValue = = null ) 
 return false ; 
 
 @ @ - 645 , 7 + 647 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 } 
 else 
 { 
 - ByteBuffer foundValue = getValue ( partitionKey , row ) ; 
 + ByteBuffer foundValue = getValue ( metadata , partitionKey , row ) ; 
 return foundValue ! = null & & mapType . getSerializer ( ) . getSerializedValue ( foundValue , value , mapType . getKeysType ( ) ) ! = null ; 
 } 
 
 @ @ - 717 , 7 + 719 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 return CompositeType . build ( key , value ) ; 
 } 
 
 - public boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) 
 + public boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) 
 { 
 assert key ! = null ; 
 / / We support null conditions for LWT ( in ColumnCondition ) but not for RowFilter . 
 @ @ - 735 , 7 + 737 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 } 
 else 
 { 
 - ByteBuffer serializedMap = getValue ( partitionKey , row ) ; 
 + ByteBuffer serializedMap = getValue ( metadata , partitionKey , row ) ; 
 if ( serializedMap = = null ) 
 return false ; 
 
 @ @ - 807 , 7 + 809 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 return ColumnDefinition . regularDef ( metadata , name , metadata . compactValueColumn ( ) . type ) ; 
 } 
 
 - public boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) 
 + public boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) 
 { 
 assert value ! = null ; 
 
 @ @ - 882 , 7 + 884 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 } 
 
 / / Filtering by custom expressions isn ' t supported yet , so just accept any row 
 - public boolean isSatisfiedBy ( DecoratedKey partitionKey , Row row ) 
 + public boolean isSatisfiedBy ( CFMetaData metadata , DecoratedKey partitionKey , Row row ) 
 { 
 return true ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / view / TemporalRow . java b / src / java / org / apache / cassandra / db / view / TemporalRow . java 
 index 46dc3fa . . d876b00 100644 
 - - - a / src / java / org / apache / cassandra / db / view / TemporalRow . java 
 + + + b / src / java / org / apache / cassandra / db / view / TemporalRow . java 
 @ @ - 380 , 14 + 380 , 16 @ @ public class TemporalRow 
 
 if ( baseDefinition . isPartitionKey ( ) ) 
 { 
 - if ( baseDefinition . isOnAllComponents ( ) ) 
 - return basePartitionKey ; 
 - else 
 + if ( baseCfs . metadata . getKeyValidator ( ) instanceof CompositeType ) 
 { 
 CompositeType keyComparator = ( CompositeType ) baseCfs . metadata . getKeyValidator ( ) ; 
 ByteBuffer [ ] components = keyComparator . split ( basePartitionKey ) ; 
 return components [ baseDefinition . position ( ) ] ; 
 } 
 + else 
 + { 
 + return basePartitionKey ; 
 + } 
 } 
 else 
 { 
 diff - - git a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 index 79f9e99 . . 9008cc8 100644 
 - - - a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 + + + b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 @ @ - 486 , 7 + 486 , 7 @ @ public final class LegacySchemaMigrator 
 } 
 else if ( isStaticCompactTable ) 
 { 
 - defs . add ( ColumnDefinition . clusteringDef ( ksName , cfName , names . defaultClusteringName ( ) , rawComparator , ColumnDefinition . NO _ POSITION ) ) ; 
 + defs . add ( ColumnDefinition . clusteringDef ( ksName , cfName , names . defaultClusteringName ( ) , rawComparator , 0 ) ) ; 
 defs . add ( ColumnDefinition . regularDef ( ksName , cfName , names . defaultCompactValueName ( ) , defaultValidator ) ) ; 
 } 
 else 
 @ @ - 586 , 8 + 586 , 9 @ @ public final class LegacySchemaMigrator 
 / / Note that the component _ index is not useful for non - primary key parts ( it never really in fact since there is 
 / / no particular ordering of non - PK columns , we only used to use it as a simplification but that ' s not needed 
 / / anymore ) 
 - if ( kind . isPrimaryKeyKind ( ) & & row . has ( " component _ index " ) ) 
 - componentIndex = row . getInt ( " component _ index " ) ; 
 + if ( kind . isPrimaryKeyKind ( ) ) 
 + / / We use to not have a component index when there was a single partition key , we don ' t anymore

NEAREST DIFF:
ELIMINATEDSENTENCE
