BLEU SCORE: 0.02383853510228548

TEST MSG: markCompacting only succeeds if the exact SSTableReader instances being
GENERATED MSG: wip

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3b373ae . . 52f33b3 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 27 , 6 + 27 , 8 @ @ <nl> * Show progress of streaming in nodetool netstats ( CASSANDRA - 8886 ) <nl> * IndexSummaryBuilder utilises offheap memory , and shares data between <nl> each IndexSummary opened from it ( CASSANDRA - 8757 ) <nl> + * markCompacting only succeeds if the exact SSTableReader instances being <nl> + marked are in the live set ( CASSANDRA - 8689 ) <nl> Merged from 2 . 0 : <nl> * Add offline tool to relevel sstables ( CASSANDRA - 8301 ) <nl> * Preserve stream ID for more protocol errors ( CASSANDRA - 8848 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 38c5dbe . . 1f03090 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 2616 , 7 + 2616 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> public Iterable < SSTableReader > call ( ) throws Exception <nl> { <nl> assert data . getCompacting ( ) . isEmpty ( ) : data . getCompacting ( ) ; <nl> - Iterable < SSTableReader > sstables = Lists . newArrayList ( AbstractCompactionStrategy . filterSuspectSSTables ( getSSTables ( ) ) ) ; <nl> + Collection < SSTableReader > sstables = Lists . newArrayList ( AbstractCompactionStrategy . filterSuspectSSTables ( getSSTables ( ) ) ) ; <nl> if ( Iterables . isEmpty ( sstables ) ) <nl> return Collections . emptyList ( ) ; <nl> boolean success = data . markCompacting ( sstables ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / DataTracker . java b / src / java / org / apache / cassandra / db / DataTracker . java <nl> index 81964f9 . . 2c2053c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DataTracker . java <nl> + + + b / src / java / org / apache / cassandra / db / DataTracker . java <nl> @ @ - 23 , 6 + 23 , 7 @ @ import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . atomic . AtomicReference ; <nl> <nl> import com . google . common . base . Predicate ; <nl> + import com . google . common . base . Predicates ; <nl> import com . google . common . collect . * ; <nl> import org . apache . cassandra . db . commitlog . ReplayPosition ; <nl> import org . slf4j . Logger ; <nl> @ @ - 191 , 30 + 192 , 32 @ @ public class DataTracker <nl> * unmarkCompacting , but since we will never call markObsolete on a sstable marked <nl> * as compacting ( unless there is a serious bug ) , we can skip this . <nl> * / <nl> - public boolean markCompacting ( Iterable < SSTableReader > sstables ) <nl> + public boolean markCompacting ( Collection < SSTableReader > sstables ) <nl> + { <nl> + return markCompacting ( sstables , false ) ; <nl> + } <nl> + public boolean markCompacting ( Collection < SSTableReader > sstables , boolean newTables ) <nl> { <nl> assert sstables ! = null & & ! Iterables . isEmpty ( sstables ) ; <nl> while ( true ) <nl> { <nl> - View currentView = view . get ( ) ; <nl> - Set < SSTableReader > set = ImmutableSet . copyOf ( sstables ) ; <nl> - Set < SSTableReader > inactive = Sets . difference ( set , currentView . compacting ) ; <nl> - if ( inactive . size ( ) < set . size ( ) ) <nl> + final View currentView = view . get ( ) ; <nl> + if ( Iterables . any ( sstables , Predicates . in ( currentView . compacting ) ) ) <nl> return false ; <nl> <nl> - if ( Iterables . any ( set , new Predicate < SSTableReader > ( ) <nl> + Predicate live = new Predicate < SSTableReader > ( ) <nl> { <nl> - @ Override <nl> public boolean apply ( SSTableReader sstable ) <nl> { <nl> - return sstable . isMarkedCompacted ( ) ; <nl> + return currentView . sstablesMap . get ( sstable ) = = sstable & & ! sstable . isMarkedCompacted ( ) ; <nl> } <nl> - } ) ) <nl> - { <nl> + } ; <nl> + if ( newTables ) <nl> + assert ! Iterables . any ( sstables , Predicates . in ( currentView . sstables ) ) ; <nl> + else if ( ! Iterables . all ( sstables , live ) ) <nl> return false ; <nl> - } <nl> <nl> - View newView = currentView . markCompacting ( set ) ; <nl> + View newView = currentView . markCompacting ( sstables ) ; <nl> if ( view . compareAndSet ( currentView , newView ) ) <nl> return true ; <nl> } <nl> @ @ - 376 , 12 + 379 , 12 @ @ public class DataTracker <nl> void init ( ) <nl> { <nl> view . set ( new View ( <nl> - ImmutableList . of ( new Memtable ( cfstore ) ) , <nl> - ImmutableList . < Memtable > of ( ) , <nl> - Collections . < SSTableReader > emptySet ( ) , <nl> - Collections . < SSTableReader > emptySet ( ) , <nl> - Collections . < SSTableReader > emptySet ( ) , <nl> - SSTableIntervalTree . empty ( ) ) ) ; <nl> + ImmutableList . of ( new Memtable ( cfstore ) ) , <nl> + ImmutableList . < Memtable > of ( ) , <nl> + Collections . < SSTableReader , SSTableReader > emptyMap ( ) , <nl> + Collections . < SSTableReader > emptySet ( ) , <nl> + Collections . < SSTableReader > emptySet ( ) , <nl> + SSTableIntervalTree . empty ( ) ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 613 , 12 + 616 , 17 @ @ public class DataTracker <nl> private final List < Memtable > flushingMemtables ; <nl> public final Set < SSTableReader > compacting ; <nl> public final Set < SSTableReader > sstables ; <nl> + / / we use a Map here so that we can easily perform identity checks as well as equality checks . <nl> + / / When marking compacting , we now indicate if we expect the sstables to be present ( by default we do ) , <nl> + / / and we then check that not only are they all present in the live set , but that the exact instance present is <nl> + / / the one we made our decision to compact against . <nl> + public final Map < SSTableReader , SSTableReader > sstablesMap ; <nl> <nl> / / all sstables that are still in the live set , but have been completely shadowed by a replacement sstable <nl> public final Set < SSTableReader > shadowed ; <nl> public final SSTableIntervalTree intervalTree ; <nl> <nl> - View ( List < Memtable > liveMemtables , List < Memtable > flushingMemtables , Set < SSTableReader > sstables , Set < SSTableReader > compacting , Set < SSTableReader > shadowed , SSTableIntervalTree intervalTree ) <nl> + View ( List < Memtable > liveMemtables , List < Memtable > flushingMemtables , Map < SSTableReader , SSTableReader > sstables , Set < SSTableReader > compacting , Set < SSTableReader > shadowed , SSTableIntervalTree intervalTree ) <nl> { <nl> this . shadowed = shadowed ; <nl> assert liveMemtables ! = null ; <nl> @ @ - 629 , 7 + 637 , 9 @ @ public class DataTracker <nl> <nl> this . liveMemtables = liveMemtables ; <nl> this . flushingMemtables = flushingMemtables ; <nl> - this . sstables = sstables ; <nl> + <nl> + this . sstablesMap = sstables ; <nl> + this . sstables = sstablesMap . keySet ( ) ; <nl> this . compacting = compacting ; <nl> this . intervalTree = intervalTree ; <nl> } <nl> @ @ - 669 , 7 + 679 , 7 @ @ public class DataTracker <nl> View switchMemtable ( Memtable newMemtable ) <nl> { <nl> List < Memtable > newLiveMemtables = ImmutableList . < Memtable > builder ( ) . addAll ( liveMemtables ) . add ( newMemtable ) . build ( ) ; <nl> - return new View ( newLiveMemtables , flushingMemtables , sstables , compacting , shadowed , intervalTree ) ; <nl> + return new View ( newLiveMemtables , flushingMemtables , sstablesMap , compacting , shadowed , intervalTree ) ; <nl> } <nl> <nl> View markFlushing ( Memtable toFlushMemtable ) <nl> @ @ - 696 , 7 + 706 , 7 @ @ public class DataTracker <nl> . addAll ( flushing . subList ( i , flushing . size ( ) ) ) <nl> . build ( ) ; <nl> <nl> - return new View ( newLive , newFlushing , sstables , compacting , shadowed , intervalTree ) ; <nl> + return new View ( newLive , newFlushing , sstablesMap , compacting , shadowed , intervalTree ) ; <nl> } <nl> <nl> View replaceFlushed ( Memtable flushedMemtable , SSTableReader newSSTable ) <nl> @ @ - 706 , 14 + 716 , 15 @ @ public class DataTracker <nl> . addAll ( flushingMemtables . subList ( 0 , index ) ) <nl> . addAll ( flushingMemtables . subList ( index + 1 , flushingMemtables . size ( ) ) ) <nl> . build ( ) ; <nl> - Set < SSTableReader > newSSTables = sstables ; <nl> + Map < SSTableReader , SSTableReader > newSSTables = sstablesMap ; <nl> SSTableIntervalTree intervalTree = this . intervalTree ; <nl> if ( newSSTable ! = null ) <nl> { <nl> assert ! sstables . contains ( newSSTable ) ; <nl> assert ! shadowed . contains ( newSSTable ) ; <nl> - newSSTables = ImmutableSet . < SSTableReader > builder ( ) . addAll ( sstables ) . add ( newSSTable ) . build ( ) ; <nl> - intervalTree = buildIntervalTree ( newSSTables ) ; <nl> + newSSTables = ImmutableMap . < SSTableReader , SSTableReader > builder ( ) <nl> + . putAll ( sstablesMap ) . put ( newSSTable , newSSTable ) . build ( ) ; <nl> + intervalTree = buildIntervalTree ( newSSTables . keySet ( ) ) ; <nl> } <nl> return new View ( liveMemtables , newQueuedMemtables , newSSTables , compacting , shadowed , intervalTree ) ; <nl> } <nl> @ @ - 723 , 12 + 734 , 12 @ @ public class DataTracker <nl> ImmutableSet < SSTableReader > oldSet = ImmutableSet . copyOf ( oldSSTables ) ; <nl> int newSSTablesSize = shadowed . size ( ) + sstables . size ( ) - oldSSTables . size ( ) + Iterables . size ( replacements ) ; <nl> assert newSSTablesSize > = Iterables . size ( replacements ) : String . format ( " Incoherent new size % d replacing % s by % s in % s " , newSSTablesSize , oldSSTables , replacements , this ) ; <nl> - Set < SSTableReader > newSSTables = new HashSet < > ( newSSTablesSize ) ; <nl> + Map < SSTableReader , SSTableReader > newSSTables = new HashMap < > ( newSSTablesSize ) ; <nl> Set < SSTableReader > newShadowed = new HashSet < > ( shadowed . size ( ) ) ; <nl> <nl> for ( SSTableReader sstable : sstables ) <nl> if ( ! oldSet . contains ( sstable ) ) <nl> - newSSTables . add ( sstable ) ; <nl> + newSSTables . put ( sstable , sstable ) ; <nl> <nl> for ( SSTableReader sstable : shadowed ) <nl> if ( ! oldSet . contains ( sstable ) ) <nl> @ @ - 739 , 28 + 750 , 28 @ @ public class DataTracker <nl> if ( replacement . openReason = = SSTableReader . OpenReason . SHADOWED ) <nl> newShadowed . add ( replacement ) ; <nl> else <nl> - newSSTables . add ( replacement ) ; <nl> + newSSTables . put ( replacement , replacement ) ; <nl> } <nl> <nl> assert newSSTables . size ( ) + newShadowed . size ( ) = = newSSTablesSize : <nl> String . format ( " Expecting new size of % d , got % d while replacing % s by % s in % s " , <nl> newSSTablesSize , newSSTables . size ( ) + newShadowed . size ( ) , oldSSTables , replacements , this ) ; <nl> - newSSTables = ImmutableSet . copyOf ( newSSTables ) ; <nl> newShadowed = ImmutableSet . copyOf ( newShadowed ) ; <nl> - SSTableIntervalTree intervalTree = buildIntervalTree ( newSSTables ) ; <nl> + newSSTables = ImmutableMap . copyOf ( newSSTables ) ; <nl> + SSTableIntervalTree intervalTree = buildIntervalTree ( newSSTables . keySet ( ) ) ; <nl> return new View ( liveMemtables , flushingMemtables , newSSTables , compacting , newShadowed , intervalTree ) ; <nl> } <nl> <nl> View markCompacting ( Collection < SSTableReader > tomark ) <nl> { <nl> Set < SSTableReader > compactingNew = ImmutableSet . < SSTableReader > builder ( ) . addAll ( compacting ) . addAll ( tomark ) . build ( ) ; <nl> - return new View ( liveMemtables , flushingMemtables , sstables , compactingNew , shadowed , intervalTree ) ; <nl> + return new View ( liveMemtables , flushingMemtables , sstablesMap , compactingNew , shadowed , intervalTree ) ; <nl> } <nl> <nl> View unmarkCompacting ( Iterable < SSTableReader > tounmark ) <nl> { <nl> Set < SSTableReader > compactingNew = ImmutableSet . copyOf ( Sets . difference ( compacting , ImmutableSet . copyOf ( tounmark ) ) ) ; <nl> - return new View ( liveMemtables , flushingMemtables , sstables , compactingNew , shadowed , intervalTree ) ; <nl> + return new View ( liveMemtables , flushingMemtables , sstablesMap , compactingNew , shadowed , intervalTree ) ; <nl> } <nl> <nl> private Set < SSTableReader > newSSTables ( Collection < SSTableReader > oldSSTables , Iterable < SSTableReader > replacements ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> index 19abd9c . . 93484e8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ import java . util . * ; <nl> import java . util . Map . Entry ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> + import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Lists ; <nl> import com . google . common . collect . Sets ; <nl> @ @ - 196 , 7 + 197 , 7 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> Iterable < SSTableReader > filteredSSTables = filterSuspectSSTables ( sstables ) ; <nl> if ( Iterables . isEmpty ( filteredSSTables ) ) <nl> return null ; <nl> - if ( ! cfs . getDataTracker ( ) . markCompacting ( filteredSSTables ) ) <nl> + if ( ! cfs . getDataTracker ( ) . markCompacting ( ImmutableList . copyOf ( filteredSSTables ) ) ) <nl> return null ; <nl> return Arrays . < AbstractCompactionTask > asList ( new CompactionTask ( cfs , filteredSSTables , gcBefore , false ) ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java <nl> index be1085b . . 914ce1f 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java <nl> @ @ - 351 , 7 + 351 , 7 @ @ public class SSTableRewriter <nl> } <nl> else <nl> { <nl> - dataTracker . markCompacting ( Collections . singleton ( replaceWith ) ) ; <nl> + dataTracker . markCompacting ( Collections . singleton ( replaceWith ) , true ) ; <nl> toReplaceSet = Collections . emptySet ( ) ; <nl> } <nl> dataTracker . replaceEarlyOpenedFiles ( toReplaceSet , Collections . singleton ( replaceWith ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / SchemaLoader . java b / test / unit / org / apache / cassandra / SchemaLoader . java <nl> index ce65d5a . . db1758f 100644 <nl> - - - a / test / unit / org / apache / cassandra / SchemaLoader . java <nl> + + + b / test / unit / org / apache / cassandra / SchemaLoader . java <nl> @ @ - 189 , 7 + 189 , 9 @ @ public class SchemaLoader <nl> standardCFMD ( ks1 , " StandardLowIndexInterval " ) . minIndexInterval ( 8 ) <nl> . maxIndexInterval ( 256 ) <nl> . caching ( CachingOptions . NONE ) , <nl> - <nl> + standardCFMD ( ks1 , " StandardRace " ) . minIndexInterval ( 8 ) <nl> + . maxIndexInterval ( 256 ) <nl> + . caching ( CachingOptions . NONE ) , <nl> standardCFMD ( ks1 , " UUIDKeys " ) . keyValidator ( UUIDType . instance ) , <nl> CFMetaData . denseCFMetaData ( ks1 , " MixedTypes " , LongType . instance ) . keyValidator ( UUIDType . instance ) . defaultValidator ( BooleanType . instance ) , <nl> CFMetaData . denseCFMetaData ( ks1 , " MixedTypesComposite " , composite ) . keyValidator ( composite ) . defaultValidator ( BooleanType . instance ) , <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryManagerTest . java b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryManagerTest . java <nl> index 0bb9d5f . . dec7705 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryManagerTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryManagerTest . java <nl> @ @ - 20 , 22 + 20 , 27 @ @ package org . apache . cassandra . io . sstable ; <nl> import java . io . IOException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> - import java . util . concurrent . ExecutionException ; <nl> - import java . util . concurrent . Future ; <nl> - import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . * ; <nl> + import java . util . concurrent . atomic . AtomicBoolean ; <nl> <nl> import org . junit . After ; <nl> import org . junit . Before ; <nl> import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> + import junit . framework . Assert ; <nl> + import org . apache . cassandra . OrderedJUnit4ClassRunner ; <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . filter . QueryFilter ; <nl> import org . apache . cassandra . metrics . RestorableMeter ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> <nl> import static org . apache . cassandra . io . sstable . Downsampling . BASE _ SAMPLING _ LEVEL ; <nl> import static org . apache . cassandra . io . sstable . IndexSummaryManager . DOWNSAMPLE _ THESHOLD ; <nl> @ @ - 46 , 6 + 51 , 7 @ @ import static org . junit . Assert . assertNotNull ; <nl> import static org . junit . Assert . assertNull ; <nl> import static org . junit . Assert . assertTrue ; <nl> <nl> + @ RunWith ( OrderedJUnit4ClassRunner . class ) <nl> public class IndexSummaryManagerTest extends SchemaLoader <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryManagerTest . class ) ; <nl> @ @ - 83 , 7 + 89 , 6 @ @ public class IndexSummaryManagerTest extends SchemaLoader <nl> long total = 0 ; <nl> for ( SSTableReader sstable : sstables ) <nl> total + = sstable . getIndexSummaryOffHeapSize ( ) ; <nl> - <nl> return total ; <nl> } <nl> <nl> @ @ - 494 , 4 + 499 , 73 @ @ public class IndexSummaryManagerTest extends SchemaLoader <nl> assertTrue ( entry . getValue ( ) > = cfs . metadata . getMinIndexInterval ( ) ) ; <nl> } <nl> } <nl> + <nl> + / / This test runs last , since cleaning up compactions and tp is a pain <nl> + @ Test <nl> + public void testCompactionRace ( ) throws InterruptedException , ExecutionException <nl> + { <nl> + String ksname = " Keyspace1 " ; <nl> + String cfname = " StandardRace " ; / / index interval of 8 , no key caching <nl> + Keyspace keyspace = Keyspace . open ( ksname ) ; <nl> + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; <nl> + int numSSTables = 20 ; <nl> + int numRows = 28 ; <nl> + createSSTables ( ksname , cfname , numSSTables , numRows ) ; <nl> + <nl> + List < SSTableReader > sstables = new ArrayList < > ( cfs . getSSTables ( ) ) ; <nl> + <nl> + ExecutorService tp = Executors . newFixedThreadPool ( 2 ) ; <nl> + <nl> + final AtomicBoolean failed = new AtomicBoolean ( false ) ; <nl> + <nl> + for ( int i = 0 ; i < 2 ; i + + ) <nl> + { <nl> + tp . submit ( new Runnable ( ) <nl> + { <nl> + @ Override <nl> + public void run ( ) <nl> + { <nl> + while ( ! failed . get ( ) ) <nl> + { <nl> + try <nl> + { <nl> + IndexSummaryManager . instance . redistributeSummaries ( ) ; <nl> + } catch ( Throwable e ) <nl> + { <nl> + failed . set ( true ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + while ( cfs . getSSTables ( ) . size ( ) ! = 1 ) <nl> + cfs . forceMajorCompaction ( ) ; <nl> + <nl> + try <nl> + { <nl> + Assert . assertFalse ( failed . get ( ) ) ; <nl> + <nl> + for ( SSTableReader sstable : sstables ) <nl> + { <nl> + Assert . assertEquals ( true , sstable . isMarkedCompacted ( ) ) ; <nl> + } <nl> + <nl> + Assert . assertEquals ( 20 , sstables . size ( ) ) ; <nl> + <nl> + try <nl> + { <nl> + totalOffHeapSize ( sstables ) ; <nl> + Assert . fail ( " This should have failed " ) ; <nl> + } catch ( AssertionError e ) <nl> + { <nl> + <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + tp . shutdownNow ( ) ; <nl> + CompactionManager . instance . finishCompactionsAndShutdown ( 10 , TimeUnit . SECONDS ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java <nl> index 258b6b5 . . 6c96905 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java <nl> @ @ - 540 , 7 + 540 , 7 @ @ public class SSTableRewriterTest extends SchemaLoader <nl> cfs . truncateBlocking ( ) ; <nl> cfs . disableAutoCompaction ( ) ; <nl> SSTableReader s = writeFile ( cfs , 1000 ) ; <nl> - cfs . getDataTracker ( ) . markCompacting ( Arrays . asList ( s ) ) ; <nl> + cfs . getDataTracker ( ) . markCompacting ( Arrays . asList ( s ) , true ) ; <nl> SSTableSplitter splitter = new SSTableSplitter ( cfs , s , 10 ) ; <nl> splitter . split ( ) ; <nl> Thread . sleep ( 1000 ) ; <nl> @ @ - 584 , 6 + 584 , 7 @ @ public class SSTableRewriterTest extends SchemaLoader <nl> if ( ! offline ) <nl> cfs . addSSTable ( s ) ; <nl> Set < SSTableReader > compacting = Sets . newHashSet ( s ) ; <nl> + cfs . getDataTracker ( ) . markCompacting ( compacting ) ; <nl> SSTableRewriter . overrideOpenInterval ( 10000000 ) ; <nl> SSTableRewriter rewriter = new SSTableRewriter ( cfs , compacting , 1000 , offline ) ; <nl> SSTableWriter w = getWriter ( cfs , s . descriptor . directory ) ; <nl> @ @ - 608 , 6 + 609 , 10 @ @ public class SSTableRewriterTest extends SchemaLoader <nl> rewriter . abort ( ) ; <nl> } <nl> } <nl> + finally <nl> + { <nl> + cfs . getDataTracker ( ) . unmarkCompacting ( compacting ) ; <nl> + } <nl> Thread . sleep ( 1000 ) ; <nl> int filecount = assertFileCounts ( s . descriptor . directory . list ( ) , 0 , 0 ) ; <nl> assertEquals ( filecount , 1 ) ;
NEAREST DIFF (one line): diff - - git a / NEWS . txt b / NEWS . txt <nl> index 14af273 . . 7900ce3 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 11 , 8 + 11 , 10 @ @ Features <nl> - " cassandra . bat install " will install Cassandra as a Windows Service <nl> - SSTable compression can be enabled by setting options ? ? ? <nl> - Compressed SSTable blocks are checksummed to protect against bitrot <nl> - - New LevelDB - inspired compaction algorithm can be enabled by setting <nl> - option ? ? ? <nl> + - New LevelDB - inspired compaction algorithm can be enabled by setting the <nl> + Columnfamily compaction _ strategy = LeveledCompactionStrategy option . <nl> + Leveled compaction means you only need to keep a few MB of space free for <nl> + compaction instead of ( in the worst case ) 50 % . <nl> - Windows Service ( " cassandra . bat install " to enable ) <nl> <nl> Other

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3b373ae . . 52f33b3 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 27 , 6 + 27 , 8 @ @ 
 * Show progress of streaming in nodetool netstats ( CASSANDRA - 8886 ) 
 * IndexSummaryBuilder utilises offheap memory , and shares data between 
 each IndexSummary opened from it ( CASSANDRA - 8757 ) 
 + * markCompacting only succeeds if the exact SSTableReader instances being 
 + marked are in the live set ( CASSANDRA - 8689 ) 
 Merged from 2 . 0 : 
 * Add offline tool to relevel sstables ( CASSANDRA - 8301 ) 
 * Preserve stream ID for more protocol errors ( CASSANDRA - 8848 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 38c5dbe . . 1f03090 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 2616 , 7 + 2616 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 public Iterable < SSTableReader > call ( ) throws Exception 
 { 
 assert data . getCompacting ( ) . isEmpty ( ) : data . getCompacting ( ) ; 
 - Iterable < SSTableReader > sstables = Lists . newArrayList ( AbstractCompactionStrategy . filterSuspectSSTables ( getSSTables ( ) ) ) ; 
 + Collection < SSTableReader > sstables = Lists . newArrayList ( AbstractCompactionStrategy . filterSuspectSSTables ( getSSTables ( ) ) ) ; 
 if ( Iterables . isEmpty ( sstables ) ) 
 return Collections . emptyList ( ) ; 
 boolean success = data . markCompacting ( sstables ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / DataTracker . java b / src / java / org / apache / cassandra / db / DataTracker . java 
 index 81964f9 . . 2c2053c 100644 
 - - - a / src / java / org / apache / cassandra / db / DataTracker . java 
 + + + b / src / java / org / apache / cassandra / db / DataTracker . java 
 @ @ - 23 , 6 + 23 , 7 @ @ import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . atomic . AtomicReference ; 
 
 import com . google . common . base . Predicate ; 
 + import com . google . common . base . Predicates ; 
 import com . google . common . collect . * ; 
 import org . apache . cassandra . db . commitlog . ReplayPosition ; 
 import org . slf4j . Logger ; 
 @ @ - 191 , 30 + 192 , 32 @ @ public class DataTracker 
 * unmarkCompacting , but since we will never call markObsolete on a sstable marked 
 * as compacting ( unless there is a serious bug ) , we can skip this . 
 * / 
 - public boolean markCompacting ( Iterable < SSTableReader > sstables ) 
 + public boolean markCompacting ( Collection < SSTableReader > sstables ) 
 + { 
 + return markCompacting ( sstables , false ) ; 
 + } 
 + public boolean markCompacting ( Collection < SSTableReader > sstables , boolean newTables ) 
 { 
 assert sstables ! = null & & ! Iterables . isEmpty ( sstables ) ; 
 while ( true ) 
 { 
 - View currentView = view . get ( ) ; 
 - Set < SSTableReader > set = ImmutableSet . copyOf ( sstables ) ; 
 - Set < SSTableReader > inactive = Sets . difference ( set , currentView . compacting ) ; 
 - if ( inactive . size ( ) < set . size ( ) ) 
 + final View currentView = view . get ( ) ; 
 + if ( Iterables . any ( sstables , Predicates . in ( currentView . compacting ) ) ) 
 return false ; 
 
 - if ( Iterables . any ( set , new Predicate < SSTableReader > ( ) 
 + Predicate live = new Predicate < SSTableReader > ( ) 
 { 
 - @ Override 
 public boolean apply ( SSTableReader sstable ) 
 { 
 - return sstable . isMarkedCompacted ( ) ; 
 + return currentView . sstablesMap . get ( sstable ) = = sstable & & ! sstable . isMarkedCompacted ( ) ; 
 } 
 - } ) ) 
 - { 
 + } ; 
 + if ( newTables ) 
 + assert ! Iterables . any ( sstables , Predicates . in ( currentView . sstables ) ) ; 
 + else if ( ! Iterables . all ( sstables , live ) ) 
 return false ; 
 - } 
 
 - View newView = currentView . markCompacting ( set ) ; 
 + View newView = currentView . markCompacting ( sstables ) ; 
 if ( view . compareAndSet ( currentView , newView ) ) 
 return true ; 
 } 
 @ @ - 376 , 12 + 379 , 12 @ @ public class DataTracker 
 void init ( ) 
 { 
 view . set ( new View ( 
 - ImmutableList . of ( new Memtable ( cfstore ) ) , 
 - ImmutableList . < Memtable > of ( ) , 
 - Collections . < SSTableReader > emptySet ( ) , 
 - Collections . < SSTableReader > emptySet ( ) , 
 - Collections . < SSTableReader > emptySet ( ) , 
 - SSTableIntervalTree . empty ( ) ) ) ; 
 + ImmutableList . of ( new Memtable ( cfstore ) ) , 
 + ImmutableList . < Memtable > of ( ) , 
 + Collections . < SSTableReader , SSTableReader > emptyMap ( ) , 
 + Collections . < SSTableReader > emptySet ( ) , 
 + Collections . < SSTableReader > emptySet ( ) , 
 + SSTableIntervalTree . empty ( ) ) ) ; 
 } 
 
 / * * 
 @ @ - 613 , 12 + 616 , 17 @ @ public class DataTracker 
 private final List < Memtable > flushingMemtables ; 
 public final Set < SSTableReader > compacting ; 
 public final Set < SSTableReader > sstables ; 
 + / / we use a Map here so that we can easily perform identity checks as well as equality checks . 
 + / / When marking compacting , we now indicate if we expect the sstables to be present ( by default we do ) , 
 + / / and we then check that not only are they all present in the live set , but that the exact instance present is 
 + / / the one we made our decision to compact against . 
 + public final Map < SSTableReader , SSTableReader > sstablesMap ; 
 
 / / all sstables that are still in the live set , but have been completely shadowed by a replacement sstable 
 public final Set < SSTableReader > shadowed ; 
 public final SSTableIntervalTree intervalTree ; 
 
 - View ( List < Memtable > liveMemtables , List < Memtable > flushingMemtables , Set < SSTableReader > sstables , Set < SSTableReader > compacting , Set < SSTableReader > shadowed , SSTableIntervalTree intervalTree ) 
 + View ( List < Memtable > liveMemtables , List < Memtable > flushingMemtables , Map < SSTableReader , SSTableReader > sstables , Set < SSTableReader > compacting , Set < SSTableReader > shadowed , SSTableIntervalTree intervalTree ) 
 { 
 this . shadowed = shadowed ; 
 assert liveMemtables ! = null ; 
 @ @ - 629 , 7 + 637 , 9 @ @ public class DataTracker 
 
 this . liveMemtables = liveMemtables ; 
 this . flushingMemtables = flushingMemtables ; 
 - this . sstables = sstables ; 
 + 
 + this . sstablesMap = sstables ; 
 + this . sstables = sstablesMap . keySet ( ) ; 
 this . compacting = compacting ; 
 this . intervalTree = intervalTree ; 
 } 
 @ @ - 669 , 7 + 679 , 7 @ @ public class DataTracker 
 View switchMemtable ( Memtable newMemtable ) 
 { 
 List < Memtable > newLiveMemtables = ImmutableList . < Memtable > builder ( ) . addAll ( liveMemtables ) . add ( newMemtable ) . build ( ) ; 
 - return new View ( newLiveMemtables , flushingMemtables , sstables , compacting , shadowed , intervalTree ) ; 
 + return new View ( newLiveMemtables , flushingMemtables , sstablesMap , compacting , shadowed , intervalTree ) ; 
 } 
 
 View markFlushing ( Memtable toFlushMemtable ) 
 @ @ - 696 , 7 + 706 , 7 @ @ public class DataTracker 
 . addAll ( flushing . subList ( i , flushing . size ( ) ) ) 
 . build ( ) ; 
 
 - return new View ( newLive , newFlushing , sstables , compacting , shadowed , intervalTree ) ; 
 + return new View ( newLive , newFlushing , sstablesMap , compacting , shadowed , intervalTree ) ; 
 } 
 
 View replaceFlushed ( Memtable flushedMemtable , SSTableReader newSSTable ) 
 @ @ - 706 , 14 + 716 , 15 @ @ public class DataTracker 
 . addAll ( flushingMemtables . subList ( 0 , index ) ) 
 . addAll ( flushingMemtables . subList ( index + 1 , flushingMemtables . size ( ) ) ) 
 . build ( ) ; 
 - Set < SSTableReader > newSSTables = sstables ; 
 + Map < SSTableReader , SSTableReader > newSSTables = sstablesMap ; 
 SSTableIntervalTree intervalTree = this . intervalTree ; 
 if ( newSSTable ! = null ) 
 { 
 assert ! sstables . contains ( newSSTable ) ; 
 assert ! shadowed . contains ( newSSTable ) ; 
 - newSSTables = ImmutableSet . < SSTableReader > builder ( ) . addAll ( sstables ) . add ( newSSTable ) . build ( ) ; 
 - intervalTree = buildIntervalTree ( newSSTables ) ; 
 + newSSTables = ImmutableMap . < SSTableReader , SSTableReader > builder ( ) 
 + . putAll ( sstablesMap ) . put ( newSSTable , newSSTable ) . build ( ) ; 
 + intervalTree = buildIntervalTree ( newSSTables . keySet ( ) ) ; 
 } 
 return new View ( liveMemtables , newQueuedMemtables , newSSTables , compacting , shadowed , intervalTree ) ; 
 } 
 @ @ - 723 , 12 + 734 , 12 @ @ public class DataTracker 
 ImmutableSet < SSTableReader > oldSet = ImmutableSet . copyOf ( oldSSTables ) ; 
 int newSSTablesSize = shadowed . size ( ) + sstables . size ( ) - oldSSTables . size ( ) + Iterables . size ( replacements ) ; 
 assert newSSTablesSize > = Iterables . size ( replacements ) : String . format ( " Incoherent new size % d replacing % s by % s in % s " , newSSTablesSize , oldSSTables , replacements , this ) ; 
 - Set < SSTableReader > newSSTables = new HashSet < > ( newSSTablesSize ) ; 
 + Map < SSTableReader , SSTableReader > newSSTables = new HashMap < > ( newSSTablesSize ) ; 
 Set < SSTableReader > newShadowed = new HashSet < > ( shadowed . size ( ) ) ; 
 
 for ( SSTableReader sstable : sstables ) 
 if ( ! oldSet . contains ( sstable ) ) 
 - newSSTables . add ( sstable ) ; 
 + newSSTables . put ( sstable , sstable ) ; 
 
 for ( SSTableReader sstable : shadowed ) 
 if ( ! oldSet . contains ( sstable ) ) 
 @ @ - 739 , 28 + 750 , 28 @ @ public class DataTracker 
 if ( replacement . openReason = = SSTableReader . OpenReason . SHADOWED ) 
 newShadowed . add ( replacement ) ; 
 else 
 - newSSTables . add ( replacement ) ; 
 + newSSTables . put ( replacement , replacement ) ; 
 } 
 
 assert newSSTables . size ( ) + newShadowed . size ( ) = = newSSTablesSize : 
 String . format ( " Expecting new size of % d , got % d while replacing % s by % s in % s " , 
 newSSTablesSize , newSSTables . size ( ) + newShadowed . size ( ) , oldSSTables , replacements , this ) ; 
 - newSSTables = ImmutableSet . copyOf ( newSSTables ) ; 
 newShadowed = ImmutableSet . copyOf ( newShadowed ) ; 
 - SSTableIntervalTree intervalTree = buildIntervalTree ( newSSTables ) ; 
 + newSSTables = ImmutableMap . copyOf ( newSSTables ) ; 
 + SSTableIntervalTree intervalTree = buildIntervalTree ( newSSTables . keySet ( ) ) ; 
 return new View ( liveMemtables , flushingMemtables , newSSTables , compacting , newShadowed , intervalTree ) ; 
 } 
 
 View markCompacting ( Collection < SSTableReader > tomark ) 
 { 
 Set < SSTableReader > compactingNew = ImmutableSet . < SSTableReader > builder ( ) . addAll ( compacting ) . addAll ( tomark ) . build ( ) ; 
 - return new View ( liveMemtables , flushingMemtables , sstables , compactingNew , shadowed , intervalTree ) ; 
 + return new View ( liveMemtables , flushingMemtables , sstablesMap , compactingNew , shadowed , intervalTree ) ; 
 } 
 
 View unmarkCompacting ( Iterable < SSTableReader > tounmark ) 
 { 
 Set < SSTableReader > compactingNew = ImmutableSet . copyOf ( Sets . difference ( compacting , ImmutableSet . copyOf ( tounmark ) ) ) ; 
 - return new View ( liveMemtables , flushingMemtables , sstables , compactingNew , shadowed , intervalTree ) ; 
 + return new View ( liveMemtables , flushingMemtables , sstablesMap , compactingNew , shadowed , intervalTree ) ; 
 } 
 
 private Set < SSTableReader > newSSTables ( Collection < SSTableReader > oldSSTables , Iterable < SSTableReader > replacements ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 index 19abd9c . . 93484e8 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 @ @ - 21 , 6 + 21 , 7 @ @ import java . util . * ; 
 import java . util . Map . Entry ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 + import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Lists ; 
 import com . google . common . collect . Sets ; 
 @ @ - 196 , 7 + 197 , 7 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 Iterable < SSTableReader > filteredSSTables = filterSuspectSSTables ( sstables ) ; 
 if ( Iterables . isEmpty ( filteredSSTables ) ) 
 return null ; 
 - if ( ! cfs . getDataTracker ( ) . markCompacting ( filteredSSTables ) ) 
 + if ( ! cfs . getDataTracker ( ) . markCompacting ( ImmutableList . copyOf ( filteredSSTables ) ) ) 
 return null ; 
 return Arrays . < AbstractCompactionTask > asList ( new CompactionTask ( cfs , filteredSSTables , gcBefore , false ) ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java 
 index be1085b . . 914ce1f 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java 
 @ @ - 351 , 7 + 351 , 7 @ @ public class SSTableRewriter 
 } 
 else 
 { 
 - dataTracker . markCompacting ( Collections . singleton ( replaceWith ) ) ; 
 + dataTracker . markCompacting ( Collections . singleton ( replaceWith ) , true ) ; 
 toReplaceSet = Collections . emptySet ( ) ; 
 } 
 dataTracker . replaceEarlyOpenedFiles ( toReplaceSet , Collections . singleton ( replaceWith ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / SchemaLoader . java b / test / unit / org / apache / cassandra / SchemaLoader . java 
 index ce65d5a . . db1758f 100644 
 - - - a / test / unit / org / apache / cassandra / SchemaLoader . java 
 + + + b / test / unit / org / apache / cassandra / SchemaLoader . java 
 @ @ - 189 , 7 + 189 , 9 @ @ public class SchemaLoader 
 standardCFMD ( ks1 , " StandardLowIndexInterval " ) . minIndexInterval ( 8 ) 
 . maxIndexInterval ( 256 ) 
 . caching ( CachingOptions . NONE ) , 
 - 
 + standardCFMD ( ks1 , " StandardRace " ) . minIndexInterval ( 8 ) 
 + . maxIndexInterval ( 256 ) 
 + . caching ( CachingOptions . NONE ) , 
 standardCFMD ( ks1 , " UUIDKeys " ) . keyValidator ( UUIDType . instance ) , 
 CFMetaData . denseCFMetaData ( ks1 , " MixedTypes " , LongType . instance ) . keyValidator ( UUIDType . instance ) . defaultValidator ( BooleanType . instance ) , 
 CFMetaData . denseCFMetaData ( ks1 , " MixedTypesComposite " , composite ) . keyValidator ( composite ) . defaultValidator ( BooleanType . instance ) , 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryManagerTest . java b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryManagerTest . java 
 index 0bb9d5f . . dec7705 100644 
 - - - a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryManagerTest . java 
 + + + b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryManagerTest . java 
 @ @ - 20 , 22 + 20 , 27 @ @ package org . apache . cassandra . io . sstable ; 
 import java . io . IOException ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 - import java . util . concurrent . ExecutionException ; 
 - import java . util . concurrent . Future ; 
 - import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . * ; 
 + import java . util . concurrent . atomic . AtomicBoolean ; 
 
 import org . junit . After ; 
 import org . junit . Before ; 
 import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 + import junit . framework . Assert ; 
 + import org . apache . cassandra . OrderedJUnit4ClassRunner ; 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . Util ; 
 import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . filter . QueryFilter ; 
 import org . apache . cassandra . metrics . RestorableMeter ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . concurrent . OpOrder ; 
 
 import static org . apache . cassandra . io . sstable . Downsampling . BASE _ SAMPLING _ LEVEL ; 
 import static org . apache . cassandra . io . sstable . IndexSummaryManager . DOWNSAMPLE _ THESHOLD ; 
 @ @ - 46 , 6 + 51 , 7 @ @ import static org . junit . Assert . assertNotNull ; 
 import static org . junit . Assert . assertNull ; 
 import static org . junit . Assert . assertTrue ; 
 
 + @ RunWith ( OrderedJUnit4ClassRunner . class ) 
 public class IndexSummaryManagerTest extends SchemaLoader 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryManagerTest . class ) ; 
 @ @ - 83 , 7 + 89 , 6 @ @ public class IndexSummaryManagerTest extends SchemaLoader 
 long total = 0 ; 
 for ( SSTableReader sstable : sstables ) 
 total + = sstable . getIndexSummaryOffHeapSize ( ) ; 
 - 
 return total ; 
 } 
 
 @ @ - 494 , 4 + 499 , 73 @ @ public class IndexSummaryManagerTest extends SchemaLoader 
 assertTrue ( entry . getValue ( ) > = cfs . metadata . getMinIndexInterval ( ) ) ; 
 } 
 } 
 + 
 + / / This test runs last , since cleaning up compactions and tp is a pain 
 + @ Test 
 + public void testCompactionRace ( ) throws InterruptedException , ExecutionException 
 + { 
 + String ksname = " Keyspace1 " ; 
 + String cfname = " StandardRace " ; / / index interval of 8 , no key caching 
 + Keyspace keyspace = Keyspace . open ( ksname ) ; 
 + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; 
 + int numSSTables = 20 ; 
 + int numRows = 28 ; 
 + createSSTables ( ksname , cfname , numSSTables , numRows ) ; 
 + 
 + List < SSTableReader > sstables = new ArrayList < > ( cfs . getSSTables ( ) ) ; 
 + 
 + ExecutorService tp = Executors . newFixedThreadPool ( 2 ) ; 
 + 
 + final AtomicBoolean failed = new AtomicBoolean ( false ) ; 
 + 
 + for ( int i = 0 ; i < 2 ; i + + ) 
 + { 
 + tp . submit ( new Runnable ( ) 
 + { 
 + @ Override 
 + public void run ( ) 
 + { 
 + while ( ! failed . get ( ) ) 
 + { 
 + try 
 + { 
 + IndexSummaryManager . instance . redistributeSummaries ( ) ; 
 + } catch ( Throwable e ) 
 + { 
 + failed . set ( true ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + } 
 + 
 + while ( cfs . getSSTables ( ) . size ( ) ! = 1 ) 
 + cfs . forceMajorCompaction ( ) ; 
 + 
 + try 
 + { 
 + Assert . assertFalse ( failed . get ( ) ) ; 
 + 
 + for ( SSTableReader sstable : sstables ) 
 + { 
 + Assert . assertEquals ( true , sstable . isMarkedCompacted ( ) ) ; 
 + } 
 + 
 + Assert . assertEquals ( 20 , sstables . size ( ) ) ; 
 + 
 + try 
 + { 
 + totalOffHeapSize ( sstables ) ; 
 + Assert . fail ( " This should have failed " ) ; 
 + } catch ( AssertionError e ) 
 + { 
 + 
 + } 
 + } 
 + finally 
 + { 
 + tp . shutdownNow ( ) ; 
 + CompactionManager . instance . finishCompactionsAndShutdown ( 10 , TimeUnit . SECONDS ) ; 
 + } 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java 
 index 258b6b5 . . 6c96905 100644 
 - - - a / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java 
 + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java 
 @ @ - 540 , 7 + 540 , 7 @ @ public class SSTableRewriterTest extends SchemaLoader 
 cfs . truncateBlocking ( ) ; 
 cfs . disableAutoCompaction ( ) ; 
 SSTableReader s = writeFile ( cfs , 1000 ) ; 
 - cfs . getDataTracker ( ) . markCompacting ( Arrays . asList ( s ) ) ; 
 + cfs . getDataTracker ( ) . markCompacting ( Arrays . asList ( s ) , true ) ; 
 SSTableSplitter splitter = new SSTableSplitter ( cfs , s , 10 ) ; 
 splitter . split ( ) ; 
 Thread . sleep ( 1000 ) ; 
 @ @ - 584 , 6 + 584 , 7 @ @ public class SSTableRewriterTest extends SchemaLoader 
 if ( ! offline ) 
 cfs . addSSTable ( s ) ; 
 Set < SSTableReader > compacting = Sets . newHashSet ( s ) ; 
 + cfs . getDataTracker ( ) . markCompacting ( compacting ) ; 
 SSTableRewriter . overrideOpenInterval ( 10000000 ) ; 
 SSTableRewriter rewriter = new SSTableRewriter ( cfs , compacting , 1000 , offline ) ; 
 SSTableWriter w = getWriter ( cfs , s . descriptor . directory ) ; 
 @ @ - 608 , 6 + 609 , 10 @ @ public class SSTableRewriterTest extends SchemaLoader 
 rewriter . abort ( ) ; 
 } 
 } 
 + finally 
 + { 
 + cfs . getDataTracker ( ) . unmarkCompacting ( compacting ) ; 
 + } 
 Thread . sleep ( 1000 ) ; 
 int filecount = assertFileCounts ( s . descriptor . directory . list ( ) , 0 , 0 ) ; 
 assertEquals ( filecount , 1 ) ;

NEAREST DIFF:
diff - - git a / NEWS . txt b / NEWS . txt 
 index 14af273 . . 7900ce3 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 11 , 8 + 11 , 10 @ @ Features 
 - " cassandra . bat install " will install Cassandra as a Windows Service 
 - SSTable compression can be enabled by setting options ? ? ? 
 - Compressed SSTable blocks are checksummed to protect against bitrot 
 - - New LevelDB - inspired compaction algorithm can be enabled by setting 
 - option ? ? ? 
 + - New LevelDB - inspired compaction algorithm can be enabled by setting the 
 + Columnfamily compaction _ strategy = LeveledCompactionStrategy option . 
 + Leveled compaction means you only need to keep a few MB of space free for 
 + compaction instead of ( in the worst case ) 50 % . 
 - Windows Service ( " cassandra . bat install " to enable ) 
 
 Other
