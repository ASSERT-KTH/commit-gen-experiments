BLEU SCORE: 0.028465126651392333

TEST MSG: Fix race / ref leak in PendingRepairManager
GENERATED MSG: identify and blacklist corrupted SSTables from future compactions

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 849848f . . e997b50 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Fix race / ref leak in PendingRepairManager ( CASSANDRA - 13751 ) <nl> * Enable ppc64le runtime as unsupported architecture ( CASSANDRA - 13615 ) <nl> * Improve sstablemetadata output ( CASSANDRA - 11483 ) <nl> * Support for migrating legacy users to roles has been dropped ( CASSANDRA - 13371 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> index 5333683 . . f1f42a7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> @ @ - 293 , 15 + 293 , 7 @ @ public abstract class AbstractCompactionStrategy <nl> } <nl> catch ( Throwable t ) <nl> { <nl> - try <nl> - { <nl> - new ScannerList ( scanners ) . close ( ) ; <nl> - } <nl> - catch ( Throwable t2 ) <nl> - { <nl> - t . addSuppressed ( t2 ) ; <nl> - } <nl> - throw t ; <nl> + ISSTableScanner . closeAllAndPropagate ( scanners , t ) ; <nl> } <nl> return new ScannerList ( scanners ) ; <nl> } <nl> @ @ - 385 , 24 + 377 , 7 @ @ public abstract class AbstractCompactionStrategy <nl> <nl> public void close ( ) <nl> { <nl> - Throwable t = null ; <nl> - for ( ISSTableScanner scanner : scanners ) <nl> - { <nl> - try <nl> - { <nl> - scanner . close ( ) ; <nl> - } <nl> - catch ( Throwable t2 ) <nl> - { <nl> - JVMStabilityInspector . inspectThrowable ( t2 ) ; <nl> - if ( t = = null ) <nl> - t = t2 ; <nl> - else <nl> - t . addSuppressed ( t2 ) ; <nl> - } <nl> - } <nl> - if ( t ! = null ) <nl> - throw Throwables . propagate ( t ) ; <nl> + ISSTableScanner . closeAllAndPropagate ( scanners , null ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> index e58ccc2 . . 6342a1b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> @ @ - 21 , 7 + 21 , 6 @ @ package org . apache . cassandra . db . compaction ; <nl> import java . util . * ; <nl> import java . util . concurrent . Callable ; <nl> import java . util . concurrent . locks . ReentrantReadWriteLock ; <nl> - import java . util . function . Predicate ; <nl> import java . util . stream . Collectors ; <nl> import java . util . stream . Stream ; <nl> import java . util . function . Supplier ; <nl> @ @ - 735 , 7 + 734 , 7 @ @ public class CompactionStrategyManager implements INotificationConsumer <nl> * @ return <nl> * / <nl> @ SuppressWarnings ( " resource " ) <nl> - public AbstractCompactionStrategy . ScannerList getScanners ( Collection < SSTableReader > sstables , Collection < Range < Token > > ranges ) <nl> + public AbstractCompactionStrategy . ScannerList maybeGetScanners ( Collection < SSTableReader > sstables , Collection < Range < Token > > ranges ) <nl> { <nl> assert repaired . size ( ) = = unrepaired . size ( ) ; <nl> assert repaired . size ( ) = = pendingRepairs . size ( ) ; <nl> @ @ - 781 , 13 + 780 , 31 @ @ public class CompactionStrategyManager implements INotificationConsumer <nl> if ( ! unrepairedSSTables . get ( i ) . isEmpty ( ) ) <nl> scanners . addAll ( unrepaired . get ( i ) . getScanners ( unrepairedSSTables . get ( i ) , ranges ) . scanners ) ; <nl> } <nl> - <nl> - return new AbstractCompactionStrategy . ScannerList ( scanners ) ; <nl> + } <nl> + catch ( PendingRepairManager . IllegalSSTableArgumentException e ) <nl> + { <nl> + ISSTableScanner . closeAllAndPropagate ( scanners , new ConcurrentModificationException ( e ) ) ; <nl> } <nl> finally <nl> { <nl> readLock . unlock ( ) ; <nl> } <nl> + return new AbstractCompactionStrategy . ScannerList ( scanners ) ; <nl> + } <nl> + <nl> + public AbstractCompactionStrategy . ScannerList getScanners ( Collection < SSTableReader > sstables , Collection < Range < Token > > ranges ) <nl> + { <nl> + while ( true ) <nl> + { <nl> + try <nl> + { <nl> + return maybeGetScanners ( sstables , ranges ) ; <nl> + } <nl> + catch ( ConcurrentModificationException e ) <nl> + { <nl> + logger . debug ( " SSTable repairedAt / pendingRepaired values changed while getting scanners " ) ; <nl> + } <nl> + } <nl> } <nl> <nl> public AbstractCompactionStrategy . ScannerList getScanners ( Collection < SSTableReader > sstables ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> index 4f11a03 . . 8086be9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> @ @ - 307 , 15 + 307 , 7 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy <nl> } <nl> catch ( Throwable t ) <nl> { <nl> - try <nl> - { <nl> - new ScannerList ( scanners ) . close ( ) ; <nl> - } <nl> - catch ( Throwable t2 ) <nl> - { <nl> - t . addSuppressed ( t2 ) ; <nl> - } <nl> - throw t ; <nl> + ISSTableScanner . closeAllAndPropagate ( scanners , t ) ; <nl> } <nl> <nl> return new ScannerList ( scanners ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java b / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java <nl> index afde263 . . 183af7a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java <nl> @ @ - 64 , 6 + 64 , 17 @ @ class PendingRepairManager <nl> private final CompactionParams params ; <nl> private volatile ImmutableMap < UUID , AbstractCompactionStrategy > strategies = ImmutableMap . of ( ) ; <nl> <nl> + / * * <nl> + * Indicates we ' re being asked to do something with an sstable that isn ' t marked pending repair <nl> + * / <nl> + public static class IllegalSSTableArgumentException extends IllegalArgumentException <nl> + { <nl> + public IllegalSSTableArgumentException ( String s ) <nl> + { <nl> + super ( s ) ; <nl> + } <nl> + } <nl> + <nl> PendingRepairManager ( ColumnFamilyStore cfs , CompactionParams params ) <nl> { <nl> this . cfs = cfs ; <nl> @ @ - 88 , 6 + 99 , 7 @ @ class PendingRepairManager <nl> <nl> AbstractCompactionStrategy getOrCreate ( UUID id ) <nl> { <nl> + checkPendingID ( id ) ; <nl> assert id ! = null ; <nl> AbstractCompactionStrategy strategy = get ( id ) ; <nl> if ( strategy = = null ) <nl> @ @ - 107 , 9 + 119 , 16 @ @ class PendingRepairManager <nl> return strategy ; <nl> } <nl> <nl> + private static void checkPendingID ( UUID pendingID ) <nl> + { <nl> + if ( pendingID = = null ) <nl> + { <nl> + throw new IllegalSSTableArgumentException ( " sstable is not pending repair " ) ; <nl> + } <nl> + } <nl> + <nl> AbstractCompactionStrategy getOrCreate ( SSTableReader sstable ) <nl> { <nl> - assert sstable . isPendingRepair ( ) ; <nl> return getOrCreate ( sstable . getSSTableMetadata ( ) . pendingRepair ) ; <nl> } <nl> <nl> @ @ - 352 , 14 + 371 , 21 @ @ class PendingRepairManager <nl> for ( SSTableReader sstable : sstables ) <nl> { <nl> UUID sessionID = sstable . getSSTableMetadata ( ) . pendingRepair ; <nl> - assert sessionID ! = null ; <nl> + checkPendingID ( sessionID ) ; <nl> sessionSSTables . computeIfAbsent ( sessionID , k - > new HashSet < > ( ) ) . add ( sstable ) ; <nl> } <nl> <nl> Set < ISSTableScanner > scanners = new HashSet < > ( sessionSSTables . size ( ) ) ; <nl> - for ( Map . Entry < UUID , Set < SSTableReader > > entry : sessionSSTables . entrySet ( ) ) <nl> + try <nl> + { <nl> + for ( Map . Entry < UUID , Set < SSTableReader > > entry : sessionSSTables . entrySet ( ) ) <nl> + { <nl> + scanners . addAll ( getOrCreate ( entry . getKey ( ) ) . getScanners ( entry . getValue ( ) , ranges ) . scanners ) ; <nl> + } <nl> + } <nl> + catch ( Throwable t ) <nl> { <nl> - scanners . addAll ( getOrCreate ( entry . getKey ( ) ) . getScanners ( entry . getValue ( ) , ranges ) . scanners ) ; <nl> + ISSTableScanner . closeAllAndPropagate ( scanners , t ) ; <nl> } <nl> return scanners ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / ISSTableScanner . java b / src / java / org / apache / cassandra / io / sstable / ISSTableScanner . java <nl> index 2dff34e . . 1c1d74b 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / ISSTableScanner . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / ISSTableScanner . java <nl> @ @ - 19 , 7 + 19 , 12 @ @ <nl> <nl> package org . apache . cassandra . io . sstable ; <nl> <nl> + import java . util . Collection ; <nl> + <nl> + import com . google . common . base . Throwables ; <nl> + <nl> import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; <nl> + import org . apache . cassandra . utils . JVMStabilityInspector ; <nl> <nl> / * * <nl> * An ISSTableScanner is an abstraction allowing multiple SSTableScanners to be <nl> @ @ - 32 , 4 + 37 , 33 @ @ public interface ISSTableScanner extends UnfilteredPartitionIterator <nl> public long getCurrentPosition ( ) ; <nl> public long getBytesScanned ( ) ; <nl> public String getBackingFiles ( ) ; <nl> + <nl> + public static void closeAllAndPropagate ( Collection < ISSTableScanner > scanners , Throwable throwable ) <nl> + { <nl> + for ( ISSTableScanner scanner : scanners ) <nl> + { <nl> + try <nl> + { <nl> + scanner . close ( ) ; <nl> + } <nl> + catch ( Throwable t2 ) <nl> + { <nl> + JVMStabilityInspector . inspectThrowable ( t2 ) ; <nl> + if ( throwable = = null ) <nl> + { <nl> + throwable = t2 ; <nl> + } <nl> + else <nl> + { <nl> + throwable . addSuppressed ( t2 ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + if ( throwable ! = null ) <nl> + { <nl> + Throwables . propagate ( throwable ) ; <nl> + } <nl> + <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java b / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java <nl> index a173b4b . . 93b68b5 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java <nl> @ @ - 240 , 4 + 240 , 28 @ @ public class PendingRepairManagerTest extends AbstractPendingRepairTest <nl> tasks . stream ( ) . forEach ( t - > t . transaction . abort ( ) ) ; <nl> } <nl> } <nl> + <nl> + / * * <nl> + * Tests that a IllegalSSTableArgumentException is thrown if we try to get <nl> + * scanners for an sstable that isn ' t pending repair <nl> + * / <nl> + @ Test ( expected = PendingRepairManager . IllegalSSTableArgumentException . class ) <nl> + public void getScannersInvalidSSTable ( ) throws Exception <nl> + { <nl> + PendingRepairManager prm = csm . getPendingRepairManagers ( ) . get ( 0 ) ; <nl> + SSTableReader sstable = makeSSTable ( true ) ; <nl> + prm . getScanners ( Collections . singleton ( sstable ) , Collections . singleton ( RANGE1 ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Tests that a IllegalSSTableArgumentException is thrown if we try to get <nl> + * scanners for an sstable that isn ' t pending repair <nl> + * / <nl> + @ Test ( expected = PendingRepairManager . IllegalSSTableArgumentException . class ) <nl> + public void getOrCreateInvalidSSTable ( ) throws Exception <nl> + { <nl> + PendingRepairManager prm = csm . getPendingRepairManagers ( ) . get ( 0 ) ; <nl> + SSTableReader sstable = makeSSTable ( true ) ; <nl> + prm . getOrCreate ( sstable ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6a2a56e . . 591ae9f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 6 + 1 , 6 @ @ <nl> 1 . 1 . 1 - dev <nl> * optimize commitlog checksumming ( CASSANDRA - 3610 ) <nl> - <nl> + * identify and blacklist corrupted SSTables from future compactions ( CASSANDRA - 2261 ) <nl> <nl> 1 . 1 - dev <nl> * start hint replay as soon as FD notifies that the target is back up <nl> diff - - git a / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java b / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java <nl> index cd9f04d . . d4c7a47 100644 <nl> - - - a / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java <nl> + + + b / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java <nl> @ @ - 72 , 6 + 72 , 7 @ @ class IndexedSliceReader extends AbstractIterator < IColumn > implements IColumnIte <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new IOError ( e ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / columniterator / SSTableNamesIterator . java b / src / java / org / apache / cassandra / db / columniterator / SSTableNamesIterator . java <nl> index 2d791c4 . . 7471778 100644 <nl> - - - a / src / java / org / apache / cassandra / db / columniterator / SSTableNamesIterator . java <nl> + + + b / src / java / org / apache / cassandra / db / columniterator / SSTableNamesIterator . java <nl> @ @ - 70 , 6 + 70 , 7 @ @ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new IOError ( e ) ; <nl> } <nl> finally <nl> @ @ - 90 , 6 + 91 , 7 @ @ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement <nl> } <nl> catch ( IOException ioe ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new IOError ( ioe ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / columniterator / SSTableSliceIterator . java b / src / java / org / apache / cassandra / db / columniterator / SSTableSliceIterator . java <nl> index 8e374b3 . . 5e6aff0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / columniterator / SSTableSliceIterator . java <nl> + + + b / src / java / org / apache / cassandra / db / columniterator / SSTableSliceIterator . java <nl> @ @ - 56 , 6 + 56 , 7 @ @ public class SSTableSliceIterator implements IColumnIterator <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new IOError ( e ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / columniterator / SimpleSliceReader . java b / src / java / org / apache / cassandra / db / columniterator / SimpleSliceReader . java <nl> index 2a1e5cf . . e54e9bf 100644 <nl> - - - a / src / java / org / apache / cassandra / db / columniterator / SimpleSliceReader . java <nl> + + + b / src / java / org / apache / cassandra / db / columniterator / SimpleSliceReader . java <nl> @ @ - 58 , 6 + 58 , 7 @ @ class SimpleSliceReader extends AbstractIterator < IColumn > implements IColumnIter <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new IOError ( e ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> index bb84d1d . . 5e0a911 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> @ @ - 17 , 9 + 17 , 7 @ @ <nl> * / <nl> package org . apache . cassandra . db . compaction ; <nl> <nl> - import java . util . Collection ; <nl> - import java . util . Map ; <nl> - import java . util . Set ; <nl> + import java . util . * ; <nl> import java . util . concurrent . TimeUnit ; <nl> <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> @ @ - 107 , 4 + 105 , 24 @ @ public abstract class AbstractCompactionStrategy <nl> * is going to be expensive <nl> * / <nl> public abstract boolean isKeyExistenceExpensive ( Set < ? extends SSTable > sstablesToIgnore ) ; <nl> + <nl> + / * * <nl> + * Filters SSTables that are to be blacklisted from the given collection <nl> + * <nl> + * @ param originalCandidates The collection to check for blacklisted SSTables <nl> + * <nl> + * @ return list of the SSTables with blacklisted ones filtered out <nl> + * / <nl> + public static List < SSTableReader > filterSuspectSSTables ( Collection < SSTableReader > originalCandidates ) <nl> + { <nl> + List < SSTableReader > filteredCandidates = new ArrayList < SSTableReader > ( ) ; <nl> + <nl> + for ( SSTableReader candidate : originalCandidates ) <nl> + { <nl> + if ( ! candidate . isMarkedSuspect ( ) ) <nl> + filteredCandidates . add ( candidate ) ; <nl> + } <nl> + <nl> + return filteredCandidates ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> index 069d289 . . 47b489d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> @ @ - 40 , 6 + 40 , 8 @ @ import org . codehaus . jackson . JsonGenerator ; <nl> import org . codehaus . jackson . JsonNode ; <nl> import org . codehaus . jackson . map . ObjectMapper ; <nl> <nl> + import static org . apache . cassandra . db . compaction . AbstractCompactionStrategy . filterSuspectSSTables ; <nl> + <nl> public class LeveledManifest <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( LeveledManifest . class ) ; <nl> @ @ - 245 , 15 + 247 , 39 @ @ public class LeveledManifest <nl> if ( score > 1 . 001 | | i = = 0 ) <nl> { <nl> Collection < SSTableReader > candidates = getCandidatesFor ( i ) ; <nl> + <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Compaction candidates for L { } are { } " , i , toString ( candidates ) ) ; <nl> - return candidates ; <nl> + <nl> + / / check if have any SSTables marked as suspected , <nl> + / / saves us filter time when no SSTables are suspects <nl> + return hasSuspectSSTables ( candidates ) <nl> + ? filterSuspectSSTables ( candidates ) <nl> + : candidates ; <nl> } <nl> } <nl> <nl> return Collections . emptyList ( ) ; <nl> } <nl> <nl> + / * * <nl> + * Go through candidates collection and check if any of the SSTables are marked as suspected . <nl> + * <nl> + * @ param candidates The SSTable collection to examine . <nl> + * <nl> + * @ return true if collection has at least one SSTable marked as suspected , false otherwise . <nl> + * / <nl> + private boolean hasSuspectSSTables ( Collection < SSTableReader > candidates ) <nl> + { <nl> + for ( SSTableReader candidate : candidates ) <nl> + { <nl> + if ( candidate . isMarkedSuspect ( ) ) <nl> + return true ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> public int getLevelSize ( int i ) <nl> { <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> index 043e301 . . 97396e4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> @ @ - 54 , 7 + 54 , 8 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> return null ; <nl> } <nl> <nl> - List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndLengthPairs ( cfs . getUncompactingSSTables ( ) ) , minSSTableSize ) ; <nl> + Set < SSTableReader > candidates = cfs . getUncompactingSSTables ( ) ; <nl> + List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndLengthPairs ( filterSuspectSSTables ( candidates ) ) , minSSTableSize ) ; <nl> updateEstimatedCompactionsByTasks ( buckets ) ; <nl> <nl> List < List < SSTableReader > > prunedBuckets = new ArrayList < List < SSTableReader > > ( ) ; <nl> @ @ - 101 , 7 + 102 , 7 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> <nl> public AbstractCompactionTask getMaximalTask ( final int gcBefore ) <nl> { <nl> - return cfs . getSSTables ( ) . isEmpty ( ) ? null : new CompactionTask ( cfs , cfs . getSSTables ( ) , gcBefore ) ; <nl> + return cfs . getSSTables ( ) . isEmpty ( ) ? null : new CompactionTask ( cfs , filterSuspectSSTables ( cfs . getSSTables ( ) ) , gcBefore ) ; <nl> } <nl> <nl> public AbstractCompactionTask getUserDefinedTask ( Collection < SSTableReader > sstables , final int gcBefore ) <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableBoundedScanner . java b / src / java / org / apache / cassandra / io / sstable / SSTableBoundedScanner . java <nl> index ccadb30 . . d69eb16 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableBoundedScanner . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableBoundedScanner . java <nl> @ @ - 48 , 6 + 48 , 7 @ @ public class SSTableBoundedScanner extends SSTableScanner <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new RuntimeException ( e ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java b / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java <nl> index ee88d94 . . bc16f91 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java <nl> @ @ - 147 , 6 + 147 , 7 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new IOError ( e ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index c674c0c . . 0728e18 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 90 , 6 + 90 , 7 @ @ public class SSTableReader extends SSTable <nl> / / technically isCompacted is not necessary since it should never be unreferenced unless it is also compacted , <nl> / / but it seems like a good extra layer of protection against reference counting bugs to not delete data based on that alone <nl> private final AtomicBoolean isCompacted = new AtomicBoolean ( false ) ; <nl> + private final AtomicBoolean isSuspect = new AtomicBoolean ( false ) ; <nl> private final SSTableDeletingTask deletingTask ; <nl> <nl> private final SSTableMetadata sstableMetadata ; <nl> @ @ - 711 , 6 + 712 , 7 @ @ public class SSTableReader extends SSTable <nl> } <nl> catch ( IOException e ) <nl> { <nl> + markSuspect ( ) ; <nl> throw new IOError ( e ) ; <nl> } <nl> finally <nl> @ @ - 797 , 6 + 799 , 19 @ @ public class SSTableReader extends SSTable <nl> return true ; <nl> } <nl> <nl> + public void markSuspect ( ) <nl> + { <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " Marking " + getFilename ( ) + " as a suspect for blacklisting . " ) ; <nl> + <nl> + isSuspect . getAndSet ( true ) ; <nl> + } <nl> + <nl> + public boolean isMarkedSuspect ( ) <nl> + { <nl> + return isSuspect . get ( ) ; <nl> + } <nl> + <nl> / * * <nl> * <nl> * @ param filter filter to use when reading the columns <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java b / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java <nl> index 87ff96c . . f7b52b5 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java <nl> @ @ - 55 , 6 + 55 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new IOError ( e ) ; <nl> } <nl> this . sstable = sstable ; <nl> @ @ - 72 , 6 + 73 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new IOError ( e ) ; <nl> } <nl> this . sstable = sstable ; <nl> @ @ - 98 , 6 + 100 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new RuntimeException ( " corrupt sstable " , e ) ; <nl> } <nl> } <nl> @ @ - 152 , 6 + 155 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new RuntimeException ( e ) ; <nl> } <nl> } <nl> @ @ - 183 , 6 + 187 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > <nl> } <nl> catch ( IOException e ) <nl> { <nl> + sstable . markSuspect ( ) ; <nl> throw new RuntimeException ( SSTableScanner . this + " failed to provide next columns from " + this , e ) ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> index ff6636d . . 23a2657 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> @ @ - 18 , 7 + 18 , 7 @ @ <nl> * / <nl> package org . apache . cassandra . db . compaction ; <nl> <nl> - import java . io . IOException ; <nl> + import java . io . * ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> import java . util . HashSet ; <nl> @ @ - 30 , 6 + 30 , 7 @ @ import java . util . concurrent . Future ; <nl> <nl> import org . junit . Test ; <nl> import static junit . framework . Assert . assertEquals ; <nl> + import static junit . framework . Assert . assertNotNull ; <nl> <nl> import org . apache . cassandra . CleanupHelper ; <nl> import org . apache . cassandra . Util ; <nl> @ @ - 38 , 6 + 39 , 7 @ @ import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . filter . QueryFilter ; <nl> import org . apache . cassandra . db . filter . QueryPath ; <nl> import org . apache . cassandra . io . sstable . * ; <nl> + import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> @ @ - 46 , 6 + 48 , 18 @ @ public class CompactionsTest extends CleanupHelper <nl> public static final String TABLE1 = " Keyspace1 " ; <nl> <nl> @ Test <nl> + public void testBlacklistingWithSizeTieredCompactionStrategy ( ) throws Exception <nl> + { <nl> + testBlacklisting ( SizeTieredCompactionStrategy . class . getCanonicalName ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testBlacklistingWithLeveledCompactionStrategy ( ) throws Exception <nl> + { <nl> + testBlacklisting ( LeveledCompactionStrategy . class . getCanonicalName ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testStandardColumnCompactions ( ) throws IOException , ExecutionException , InterruptedException <nl> { <nl> / / this test does enough rows to force multiple block indexes to be used <nl> @ @ - 83 , 6 + 97 , 7 @ @ public class CompactionsTest extends CleanupHelper <nl> <nl> / / make sure max timestamp of compacted sstables is recorded properly after compaction . <nl> assertMaxTimestamp ( store , maxTimestampExpected ) ; <nl> + store . truncate ( ) ; <nl> } <nl> <nl> <nl> @ @ - 269 , 4 + 284 , 100 @ @ public class CompactionsTest extends CleanupHelper <nl> cf = store . getColumnFamily ( filter ) ; <nl> assert cf = = null | | cf . isEmpty ( ) : " should be empty : " + cf ; <nl> } <nl> + <nl> + public void testBlacklisting ( String compactionStrategy ) throws Exception <nl> + { <nl> + / / this test does enough rows to force multiple block indexes to be used <nl> + Table table = Table . open ( TABLE1 ) ; <nl> + final ColumnFamilyStore store = table . getColumnFamilyStore ( " Standard1 " ) ; <nl> + <nl> + final int ROWS _ PER _ SSTABLE = 10 ; <nl> + final int SSTABLES = DatabaseDescriptor . getIndexInterval ( ) * 2 / ROWS _ PER _ SSTABLE ; <nl> + <nl> + store . setCompactionStrategyClass ( compactionStrategy ) ; <nl> + <nl> + / / disable compaction while flushing <nl> + store . disableAutoCompaction ( ) ; <nl> + / / test index corruption <nl> + / / now create a few new SSTables <nl> + long maxTimestampExpected = Long . MIN _ VALUE ; <nl> + Set < DecoratedKey > inserted = new HashSet < DecoratedKey > ( ) ; <nl> + for ( int j = 0 ; j < SSTABLES ; j + + ) <nl> + { <nl> + for ( int i = 0 ; i < ROWS _ PER _ SSTABLE ; i + + ) <nl> + { <nl> + DecoratedKey key = Util . dk ( String . valueOf ( i % 2 ) ) ; <nl> + RowMutation rm = new RowMutation ( TABLE1 , key . key ) ; <nl> + long timestamp = j * ROWS _ PER _ SSTABLE + i ; <nl> + rm . add ( new QueryPath ( " Standard1 " , null , ByteBufferUtil . bytes ( String . valueOf ( i / 2 ) ) ) , <nl> + ByteBufferUtil . EMPTY _ BYTE _ BUFFER , <nl> + timestamp ) ; <nl> + maxTimestampExpected = Math . max ( timestamp , maxTimestampExpected ) ; <nl> + rm . apply ( ) ; <nl> + inserted . add ( key ) ; <nl> + } <nl> + store . forceBlockingFlush ( ) ; <nl> + assertMaxTimestamp ( store , maxTimestampExpected ) ; <nl> + assertEquals ( inserted . toString ( ) , inserted . size ( ) , Util . getRangeSlice ( store ) . size ( ) ) ; <nl> + } <nl> + <nl> + Collection < SSTableReader > sstables = store . getSSTables ( ) ; <nl> + int currentSSTable = 0 ; <nl> + int sstablesToCorrupt = 8 ; <nl> + <nl> + / / corrupt first ' sstablesToCorrupt ' SSTables <nl> + for ( SSTableReader sstable : sstables ) <nl> + { <nl> + if ( currentSSTable + 1 > sstablesToCorrupt ) <nl> + break ; <nl> + <nl> + RandomAccessFile raf = null ; <nl> + <nl> + try <nl> + { <nl> + raf = new RandomAccessFile ( sstable . getFilename ( ) , " rw " ) ; <nl> + assertNotNull ( raf ) ; <nl> + raf . write ( 0xFFFFFF ) ; <nl> + } <nl> + finally <nl> + { <nl> + FileUtils . closeQuietly ( raf ) ; <nl> + } <nl> + <nl> + currentSSTable + + ; <nl> + } <nl> + <nl> + int failures = 0 ; <nl> + <nl> + / / close error output steam to avoid printing ton of useless RuntimeException <nl> + System . err . close ( ) ; <nl> + <nl> + try <nl> + { <nl> + / / in case something will go wrong we don ' t want to loop forever using for ( ; ; ) <nl> + for ( int i = 0 ; i < sstables . size ( ) ; i + + ) <nl> + { <nl> + try <nl> + { <nl> + store . forceMajorCompaction ( ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + failures + + ; <nl> + continue ; <nl> + } <nl> + <nl> + assertEquals ( sstablesToCorrupt + 1 , store . getSSTables ( ) . size ( ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + System . setErr ( new PrintStream ( new ByteArrayOutputStream ( ) ) ) ; <nl> + } <nl> + <nl> + <nl> + store . truncate ( ) ; <nl> + assertEquals ( failures , sstablesToCorrupt ) ; <nl> + } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 849848f . . e997b50 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Fix race / ref leak in PendingRepairManager ( CASSANDRA - 13751 ) 
 * Enable ppc64le runtime as unsupported architecture ( CASSANDRA - 13615 ) 
 * Improve sstablemetadata output ( CASSANDRA - 11483 ) 
 * Support for migrating legacy users to roles has been dropped ( CASSANDRA - 13371 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 index 5333683 . . f1f42a7 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 @ @ - 293 , 15 + 293 , 7 @ @ public abstract class AbstractCompactionStrategy 
 } 
 catch ( Throwable t ) 
 { 
 - try 
 - { 
 - new ScannerList ( scanners ) . close ( ) ; 
 - } 
 - catch ( Throwable t2 ) 
 - { 
 - t . addSuppressed ( t2 ) ; 
 - } 
 - throw t ; 
 + ISSTableScanner . closeAllAndPropagate ( scanners , t ) ; 
 } 
 return new ScannerList ( scanners ) ; 
 } 
 @ @ - 385 , 24 + 377 , 7 @ @ public abstract class AbstractCompactionStrategy 
 
 public void close ( ) 
 { 
 - Throwable t = null ; 
 - for ( ISSTableScanner scanner : scanners ) 
 - { 
 - try 
 - { 
 - scanner . close ( ) ; 
 - } 
 - catch ( Throwable t2 ) 
 - { 
 - JVMStabilityInspector . inspectThrowable ( t2 ) ; 
 - if ( t = = null ) 
 - t = t2 ; 
 - else 
 - t . addSuppressed ( t2 ) ; 
 - } 
 - } 
 - if ( t ! = null ) 
 - throw Throwables . propagate ( t ) ; 
 + ISSTableScanner . closeAllAndPropagate ( scanners , null ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 index e58ccc2 . . 6342a1b 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 @ @ - 21 , 7 + 21 , 6 @ @ package org . apache . cassandra . db . compaction ; 
 import java . util . * ; 
 import java . util . concurrent . Callable ; 
 import java . util . concurrent . locks . ReentrantReadWriteLock ; 
 - import java . util . function . Predicate ; 
 import java . util . stream . Collectors ; 
 import java . util . stream . Stream ; 
 import java . util . function . Supplier ; 
 @ @ - 735 , 7 + 734 , 7 @ @ public class CompactionStrategyManager implements INotificationConsumer 
 * @ return 
 * / 
 @ SuppressWarnings ( " resource " ) 
 - public AbstractCompactionStrategy . ScannerList getScanners ( Collection < SSTableReader > sstables , Collection < Range < Token > > ranges ) 
 + public AbstractCompactionStrategy . ScannerList maybeGetScanners ( Collection < SSTableReader > sstables , Collection < Range < Token > > ranges ) 
 { 
 assert repaired . size ( ) = = unrepaired . size ( ) ; 
 assert repaired . size ( ) = = pendingRepairs . size ( ) ; 
 @ @ - 781 , 13 + 780 , 31 @ @ public class CompactionStrategyManager implements INotificationConsumer 
 if ( ! unrepairedSSTables . get ( i ) . isEmpty ( ) ) 
 scanners . addAll ( unrepaired . get ( i ) . getScanners ( unrepairedSSTables . get ( i ) , ranges ) . scanners ) ; 
 } 
 - 
 - return new AbstractCompactionStrategy . ScannerList ( scanners ) ; 
 + } 
 + catch ( PendingRepairManager . IllegalSSTableArgumentException e ) 
 + { 
 + ISSTableScanner . closeAllAndPropagate ( scanners , new ConcurrentModificationException ( e ) ) ; 
 } 
 finally 
 { 
 readLock . unlock ( ) ; 
 } 
 + return new AbstractCompactionStrategy . ScannerList ( scanners ) ; 
 + } 
 + 
 + public AbstractCompactionStrategy . ScannerList getScanners ( Collection < SSTableReader > sstables , Collection < Range < Token > > ranges ) 
 + { 
 + while ( true ) 
 + { 
 + try 
 + { 
 + return maybeGetScanners ( sstables , ranges ) ; 
 + } 
 + catch ( ConcurrentModificationException e ) 
 + { 
 + logger . debug ( " SSTable repairedAt / pendingRepaired values changed while getting scanners " ) ; 
 + } 
 + } 
 } 
 
 public AbstractCompactionStrategy . ScannerList getScanners ( Collection < SSTableReader > sstables ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 index 4f11a03 . . 8086be9 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 @ @ - 307 , 15 + 307 , 7 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy 
 } 
 catch ( Throwable t ) 
 { 
 - try 
 - { 
 - new ScannerList ( scanners ) . close ( ) ; 
 - } 
 - catch ( Throwable t2 ) 
 - { 
 - t . addSuppressed ( t2 ) ; 
 - } 
 - throw t ; 
 + ISSTableScanner . closeAllAndPropagate ( scanners , t ) ; 
 } 
 
 return new ScannerList ( scanners ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java b / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java 
 index afde263 . . 183af7a 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java 
 @ @ - 64 , 6 + 64 , 17 @ @ class PendingRepairManager 
 private final CompactionParams params ; 
 private volatile ImmutableMap < UUID , AbstractCompactionStrategy > strategies = ImmutableMap . of ( ) ; 
 
 + / * * 
 + * Indicates we ' re being asked to do something with an sstable that isn ' t marked pending repair 
 + * / 
 + public static class IllegalSSTableArgumentException extends IllegalArgumentException 
 + { 
 + public IllegalSSTableArgumentException ( String s ) 
 + { 
 + super ( s ) ; 
 + } 
 + } 
 + 
 PendingRepairManager ( ColumnFamilyStore cfs , CompactionParams params ) 
 { 
 this . cfs = cfs ; 
 @ @ - 88 , 6 + 99 , 7 @ @ class PendingRepairManager 
 
 AbstractCompactionStrategy getOrCreate ( UUID id ) 
 { 
 + checkPendingID ( id ) ; 
 assert id ! = null ; 
 AbstractCompactionStrategy strategy = get ( id ) ; 
 if ( strategy = = null ) 
 @ @ - 107 , 9 + 119 , 16 @ @ class PendingRepairManager 
 return strategy ; 
 } 
 
 + private static void checkPendingID ( UUID pendingID ) 
 + { 
 + if ( pendingID = = null ) 
 + { 
 + throw new IllegalSSTableArgumentException ( " sstable is not pending repair " ) ; 
 + } 
 + } 
 + 
 AbstractCompactionStrategy getOrCreate ( SSTableReader sstable ) 
 { 
 - assert sstable . isPendingRepair ( ) ; 
 return getOrCreate ( sstable . getSSTableMetadata ( ) . pendingRepair ) ; 
 } 
 
 @ @ - 352 , 14 + 371 , 21 @ @ class PendingRepairManager 
 for ( SSTableReader sstable : sstables ) 
 { 
 UUID sessionID = sstable . getSSTableMetadata ( ) . pendingRepair ; 
 - assert sessionID ! = null ; 
 + checkPendingID ( sessionID ) ; 
 sessionSSTables . computeIfAbsent ( sessionID , k - > new HashSet < > ( ) ) . add ( sstable ) ; 
 } 
 
 Set < ISSTableScanner > scanners = new HashSet < > ( sessionSSTables . size ( ) ) ; 
 - for ( Map . Entry < UUID , Set < SSTableReader > > entry : sessionSSTables . entrySet ( ) ) 
 + try 
 + { 
 + for ( Map . Entry < UUID , Set < SSTableReader > > entry : sessionSSTables . entrySet ( ) ) 
 + { 
 + scanners . addAll ( getOrCreate ( entry . getKey ( ) ) . getScanners ( entry . getValue ( ) , ranges ) . scanners ) ; 
 + } 
 + } 
 + catch ( Throwable t ) 
 { 
 - scanners . addAll ( getOrCreate ( entry . getKey ( ) ) . getScanners ( entry . getValue ( ) , ranges ) . scanners ) ; 
 + ISSTableScanner . closeAllAndPropagate ( scanners , t ) ; 
 } 
 return scanners ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / ISSTableScanner . java b / src / java / org / apache / cassandra / io / sstable / ISSTableScanner . java 
 index 2dff34e . . 1c1d74b 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / ISSTableScanner . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / ISSTableScanner . java 
 @ @ - 19 , 7 + 19 , 12 @ @ 
 
 package org . apache . cassandra . io . sstable ; 
 
 + import java . util . Collection ; 
 + 
 + import com . google . common . base . Throwables ; 
 + 
 import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; 
 + import org . apache . cassandra . utils . JVMStabilityInspector ; 
 
 / * * 
 * An ISSTableScanner is an abstraction allowing multiple SSTableScanners to be 
 @ @ - 32 , 4 + 37 , 33 @ @ public interface ISSTableScanner extends UnfilteredPartitionIterator 
 public long getCurrentPosition ( ) ; 
 public long getBytesScanned ( ) ; 
 public String getBackingFiles ( ) ; 
 + 
 + public static void closeAllAndPropagate ( Collection < ISSTableScanner > scanners , Throwable throwable ) 
 + { 
 + for ( ISSTableScanner scanner : scanners ) 
 + { 
 + try 
 + { 
 + scanner . close ( ) ; 
 + } 
 + catch ( Throwable t2 ) 
 + { 
 + JVMStabilityInspector . inspectThrowable ( t2 ) ; 
 + if ( throwable = = null ) 
 + { 
 + throwable = t2 ; 
 + } 
 + else 
 + { 
 + throwable . addSuppressed ( t2 ) ; 
 + } 
 + } 
 + } 
 + 
 + if ( throwable ! = null ) 
 + { 
 + Throwables . propagate ( throwable ) ; 
 + } 
 + 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java b / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java 
 index a173b4b . . 93b68b5 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java 
 @ @ - 240 , 4 + 240 , 28 @ @ public class PendingRepairManagerTest extends AbstractPendingRepairTest 
 tasks . stream ( ) . forEach ( t - > t . transaction . abort ( ) ) ; 
 } 
 } 
 + 
 + / * * 
 + * Tests that a IllegalSSTableArgumentException is thrown if we try to get 
 + * scanners for an sstable that isn ' t pending repair 
 + * / 
 + @ Test ( expected = PendingRepairManager . IllegalSSTableArgumentException . class ) 
 + public void getScannersInvalidSSTable ( ) throws Exception 
 + { 
 + PendingRepairManager prm = csm . getPendingRepairManagers ( ) . get ( 0 ) ; 
 + SSTableReader sstable = makeSSTable ( true ) ; 
 + prm . getScanners ( Collections . singleton ( sstable ) , Collections . singleton ( RANGE1 ) ) ; 
 + } 
 + 
 + / * * 
 + * Tests that a IllegalSSTableArgumentException is thrown if we try to get 
 + * scanners for an sstable that isn ' t pending repair 
 + * / 
 + @ Test ( expected = PendingRepairManager . IllegalSSTableArgumentException . class ) 
 + public void getOrCreateInvalidSSTable ( ) throws Exception 
 + { 
 + PendingRepairManager prm = csm . getPendingRepairManagers ( ) . get ( 0 ) ; 
 + SSTableReader sstable = makeSSTable ( true ) ; 
 + prm . getOrCreate ( sstable ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6a2a56e . . 591ae9f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 1 . 1 . 1 - dev 
 * optimize commitlog checksumming ( CASSANDRA - 3610 ) 
 - 
 + * identify and blacklist corrupted SSTables from future compactions ( CASSANDRA - 2261 ) 
 
 1 . 1 - dev 
 * start hint replay as soon as FD notifies that the target is back up 
 diff - - git a / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java b / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java 
 index cd9f04d . . d4c7a47 100644 
 - - - a / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java 
 + + + b / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java 
 @ @ - 72 , 6 + 72 , 7 @ @ class IndexedSliceReader extends AbstractIterator < IColumn > implements IColumnIte 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new IOError ( e ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / columniterator / SSTableNamesIterator . java b / src / java / org / apache / cassandra / db / columniterator / SSTableNamesIterator . java 
 index 2d791c4 . . 7471778 100644 
 - - - a / src / java / org / apache / cassandra / db / columniterator / SSTableNamesIterator . java 
 + + + b / src / java / org / apache / cassandra / db / columniterator / SSTableNamesIterator . java 
 @ @ - 70 , 6 + 70 , 7 @ @ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new IOError ( e ) ; 
 } 
 finally 
 @ @ - 90 , 6 + 91 , 7 @ @ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement 
 } 
 catch ( IOException ioe ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new IOError ( ioe ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / columniterator / SSTableSliceIterator . java b / src / java / org / apache / cassandra / db / columniterator / SSTableSliceIterator . java 
 index 8e374b3 . . 5e6aff0 100644 
 - - - a / src / java / org / apache / cassandra / db / columniterator / SSTableSliceIterator . java 
 + + + b / src / java / org / apache / cassandra / db / columniterator / SSTableSliceIterator . java 
 @ @ - 56 , 6 + 56 , 7 @ @ public class SSTableSliceIterator implements IColumnIterator 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new IOError ( e ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / columniterator / SimpleSliceReader . java b / src / java / org / apache / cassandra / db / columniterator / SimpleSliceReader . java 
 index 2a1e5cf . . e54e9bf 100644 
 - - - a / src / java / org / apache / cassandra / db / columniterator / SimpleSliceReader . java 
 + + + b / src / java / org / apache / cassandra / db / columniterator / SimpleSliceReader . java 
 @ @ - 58 , 6 + 58 , 7 @ @ class SimpleSliceReader extends AbstractIterator < IColumn > implements IColumnIter 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new IOError ( e ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 index bb84d1d . . 5e0a911 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 @ @ - 17 , 9 + 17 , 7 @ @ 
 * / 
 package org . apache . cassandra . db . compaction ; 
 
 - import java . util . Collection ; 
 - import java . util . Map ; 
 - import java . util . Set ; 
 + import java . util . * ; 
 import java . util . concurrent . TimeUnit ; 
 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 @ @ - 107 , 4 + 105 , 24 @ @ public abstract class AbstractCompactionStrategy 
 * is going to be expensive 
 * / 
 public abstract boolean isKeyExistenceExpensive ( Set < ? extends SSTable > sstablesToIgnore ) ; 
 + 
 + / * * 
 + * Filters SSTables that are to be blacklisted from the given collection 
 + * 
 + * @ param originalCandidates The collection to check for blacklisted SSTables 
 + * 
 + * @ return list of the SSTables with blacklisted ones filtered out 
 + * / 
 + public static List < SSTableReader > filterSuspectSSTables ( Collection < SSTableReader > originalCandidates ) 
 + { 
 + List < SSTableReader > filteredCandidates = new ArrayList < SSTableReader > ( ) ; 
 + 
 + for ( SSTableReader candidate : originalCandidates ) 
 + { 
 + if ( ! candidate . isMarkedSuspect ( ) ) 
 + filteredCandidates . add ( candidate ) ; 
 + } 
 + 
 + return filteredCandidates ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 index 069d289 . . 47b489d 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 @ @ - 40 , 6 + 40 , 8 @ @ import org . codehaus . jackson . JsonGenerator ; 
 import org . codehaus . jackson . JsonNode ; 
 import org . codehaus . jackson . map . ObjectMapper ; 
 
 + import static org . apache . cassandra . db . compaction . AbstractCompactionStrategy . filterSuspectSSTables ; 
 + 
 public class LeveledManifest 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( LeveledManifest . class ) ; 
 @ @ - 245 , 15 + 247 , 39 @ @ public class LeveledManifest 
 if ( score > 1 . 001 | | i = = 0 ) 
 { 
 Collection < SSTableReader > candidates = getCandidatesFor ( i ) ; 
 + 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Compaction candidates for L { } are { } " , i , toString ( candidates ) ) ; 
 - return candidates ; 
 + 
 + / / check if have any SSTables marked as suspected , 
 + / / saves us filter time when no SSTables are suspects 
 + return hasSuspectSSTables ( candidates ) 
 + ? filterSuspectSSTables ( candidates ) 
 + : candidates ; 
 } 
 } 
 
 return Collections . emptyList ( ) ; 
 } 
 
 + / * * 
 + * Go through candidates collection and check if any of the SSTables are marked as suspected . 
 + * 
 + * @ param candidates The SSTable collection to examine . 
 + * 
 + * @ return true if collection has at least one SSTable marked as suspected , false otherwise . 
 + * / 
 + private boolean hasSuspectSSTables ( Collection < SSTableReader > candidates ) 
 + { 
 + for ( SSTableReader candidate : candidates ) 
 + { 
 + if ( candidate . isMarkedSuspect ( ) ) 
 + return true ; 
 + } 
 + 
 + return false ; 
 + } 
 + 
 public int getLevelSize ( int i ) 
 { 
 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 index 043e301 . . 97396e4 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 @ @ - 54 , 7 + 54 , 8 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 return null ; 
 } 
 
 - List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndLengthPairs ( cfs . getUncompactingSSTables ( ) ) , minSSTableSize ) ; 
 + Set < SSTableReader > candidates = cfs . getUncompactingSSTables ( ) ; 
 + List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndLengthPairs ( filterSuspectSSTables ( candidates ) ) , minSSTableSize ) ; 
 updateEstimatedCompactionsByTasks ( buckets ) ; 
 
 List < List < SSTableReader > > prunedBuckets = new ArrayList < List < SSTableReader > > ( ) ; 
 @ @ - 101 , 7 + 102 , 7 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 
 public AbstractCompactionTask getMaximalTask ( final int gcBefore ) 
 { 
 - return cfs . getSSTables ( ) . isEmpty ( ) ? null : new CompactionTask ( cfs , cfs . getSSTables ( ) , gcBefore ) ; 
 + return cfs . getSSTables ( ) . isEmpty ( ) ? null : new CompactionTask ( cfs , filterSuspectSSTables ( cfs . getSSTables ( ) ) , gcBefore ) ; 
 } 
 
 public AbstractCompactionTask getUserDefinedTask ( Collection < SSTableReader > sstables , final int gcBefore ) 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableBoundedScanner . java b / src / java / org / apache / cassandra / io / sstable / SSTableBoundedScanner . java 
 index ccadb30 . . d69eb16 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableBoundedScanner . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableBoundedScanner . java 
 @ @ - 48 , 6 + 48 , 7 @ @ public class SSTableBoundedScanner extends SSTableScanner 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new RuntimeException ( e ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java b / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java 
 index ee88d94 . . bc16f91 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java 
 @ @ - 147 , 6 + 147 , 7 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new IOError ( e ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index c674c0c . . 0728e18 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 90 , 6 + 90 , 7 @ @ public class SSTableReader extends SSTable 
 / / technically isCompacted is not necessary since it should never be unreferenced unless it is also compacted , 
 / / but it seems like a good extra layer of protection against reference counting bugs to not delete data based on that alone 
 private final AtomicBoolean isCompacted = new AtomicBoolean ( false ) ; 
 + private final AtomicBoolean isSuspect = new AtomicBoolean ( false ) ; 
 private final SSTableDeletingTask deletingTask ; 
 
 private final SSTableMetadata sstableMetadata ; 
 @ @ - 711 , 6 + 712 , 7 @ @ public class SSTableReader extends SSTable 
 } 
 catch ( IOException e ) 
 { 
 + markSuspect ( ) ; 
 throw new IOError ( e ) ; 
 } 
 finally 
 @ @ - 797 , 6 + 799 , 19 @ @ public class SSTableReader extends SSTable 
 return true ; 
 } 
 
 + public void markSuspect ( ) 
 + { 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " Marking " + getFilename ( ) + " as a suspect for blacklisting . " ) ; 
 + 
 + isSuspect . getAndSet ( true ) ; 
 + } 
 + 
 + public boolean isMarkedSuspect ( ) 
 + { 
 + return isSuspect . get ( ) ; 
 + } 
 + 
 / * * 
 * 
 * @ param filter filter to use when reading the columns 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java b / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java 
 index 87ff96c . . f7b52b5 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java 
 @ @ - 55 , 6 + 55 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new IOError ( e ) ; 
 } 
 this . sstable = sstable ; 
 @ @ - 72 , 6 + 73 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new IOError ( e ) ; 
 } 
 this . sstable = sstable ; 
 @ @ - 98 , 6 + 100 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new RuntimeException ( " corrupt sstable " , e ) ; 
 } 
 } 
 @ @ - 152 , 6 + 155 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new RuntimeException ( e ) ; 
 } 
 } 
 @ @ - 183 , 6 + 187 , 7 @ @ public class SSTableScanner implements CloseableIterator < IColumnIterator > 
 } 
 catch ( IOException e ) 
 { 
 + sstable . markSuspect ( ) ; 
 throw new RuntimeException ( SSTableScanner . this + " failed to provide next columns from " + this , e ) ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 index ff6636d . . 23a2657 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 @ @ - 18 , 7 + 18 , 7 @ @ 
 * / 
 package org . apache . cassandra . db . compaction ; 
 
 - import java . io . IOException ; 
 + import java . io . * ; 
 import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 import java . util . HashSet ; 
 @ @ - 30 , 6 + 30 , 7 @ @ import java . util . concurrent . Future ; 
 
 import org . junit . Test ; 
 import static junit . framework . Assert . assertEquals ; 
 + import static junit . framework . Assert . assertNotNull ; 
 
 import org . apache . cassandra . CleanupHelper ; 
 import org . apache . cassandra . Util ; 
 @ @ - 38 , 6 + 39 , 7 @ @ import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . filter . QueryFilter ; 
 import org . apache . cassandra . db . filter . QueryPath ; 
 import org . apache . cassandra . io . sstable . * ; 
 + import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 @ @ - 46 , 6 + 48 , 18 @ @ public class CompactionsTest extends CleanupHelper 
 public static final String TABLE1 = " Keyspace1 " ; 
 
 @ Test 
 + public void testBlacklistingWithSizeTieredCompactionStrategy ( ) throws Exception 
 + { 
 + testBlacklisting ( SizeTieredCompactionStrategy . class . getCanonicalName ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testBlacklistingWithLeveledCompactionStrategy ( ) throws Exception 
 + { 
 + testBlacklisting ( LeveledCompactionStrategy . class . getCanonicalName ( ) ) ; 
 + } 
 + 
 + @ Test 
 public void testStandardColumnCompactions ( ) throws IOException , ExecutionException , InterruptedException 
 { 
 / / this test does enough rows to force multiple block indexes to be used 
 @ @ - 83 , 6 + 97 , 7 @ @ public class CompactionsTest extends CleanupHelper 
 
 / / make sure max timestamp of compacted sstables is recorded properly after compaction . 
 assertMaxTimestamp ( store , maxTimestampExpected ) ; 
 + store . truncate ( ) ; 
 } 
 
 
 @ @ - 269 , 4 + 284 , 100 @ @ public class CompactionsTest extends CleanupHelper 
 cf = store . getColumnFamily ( filter ) ; 
 assert cf = = null | | cf . isEmpty ( ) : " should be empty : " + cf ; 
 } 
 + 
 + public void testBlacklisting ( String compactionStrategy ) throws Exception 
 + { 
 + / / this test does enough rows to force multiple block indexes to be used 
 + Table table = Table . open ( TABLE1 ) ; 
 + final ColumnFamilyStore store = table . getColumnFamilyStore ( " Standard1 " ) ; 
 + 
 + final int ROWS _ PER _ SSTABLE = 10 ; 
 + final int SSTABLES = DatabaseDescriptor . getIndexInterval ( ) * 2 / ROWS _ PER _ SSTABLE ; 
 + 
 + store . setCompactionStrategyClass ( compactionStrategy ) ; 
 + 
 + / / disable compaction while flushing 
 + store . disableAutoCompaction ( ) ; 
 + / / test index corruption 
 + / / now create a few new SSTables 
 + long maxTimestampExpected = Long . MIN _ VALUE ; 
 + Set < DecoratedKey > inserted = new HashSet < DecoratedKey > ( ) ; 
 + for ( int j = 0 ; j < SSTABLES ; j + + ) 
 + { 
 + for ( int i = 0 ; i < ROWS _ PER _ SSTABLE ; i + + ) 
 + { 
 + DecoratedKey key = Util . dk ( String . valueOf ( i % 2 ) ) ; 
 + RowMutation rm = new RowMutation ( TABLE1 , key . key ) ; 
 + long timestamp = j * ROWS _ PER _ SSTABLE + i ; 
 + rm . add ( new QueryPath ( " Standard1 " , null , ByteBufferUtil . bytes ( String . valueOf ( i / 2 ) ) ) , 
 + ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 
 + timestamp ) ; 
 + maxTimestampExpected = Math . max ( timestamp , maxTimestampExpected ) ; 
 + rm . apply ( ) ; 
 + inserted . add ( key ) ; 
 + } 
 + store . forceBlockingFlush ( ) ; 
 + assertMaxTimestamp ( store , maxTimestampExpected ) ; 
 + assertEquals ( inserted . toString ( ) , inserted . size ( ) , Util . getRangeSlice ( store ) . size ( ) ) ; 
 + } 
 + 
 + Collection < SSTableReader > sstables = store . getSSTables ( ) ; 
 + int currentSSTable = 0 ; 
 + int sstablesToCorrupt = 8 ; 
 + 
 + / / corrupt first ' sstablesToCorrupt ' SSTables 
 + for ( SSTableReader sstable : sstables ) 
 + { 
 + if ( currentSSTable + 1 > sstablesToCorrupt ) 
 + break ; 
 + 
 + RandomAccessFile raf = null ; 
 + 
 + try 
 + { 
 + raf = new RandomAccessFile ( sstable . getFilename ( ) , " rw " ) ; 
 + assertNotNull ( raf ) ; 
 + raf . write ( 0xFFFFFF ) ; 
 + } 
 + finally 
 + { 
 + FileUtils . closeQuietly ( raf ) ; 
 + } 
 + 
 + currentSSTable + + ; 
 + } 
 + 
 + int failures = 0 ; 
 + 
 + / / close error output steam to avoid printing ton of useless RuntimeException 
 + System . err . close ( ) ; 
 + 
 + try 
 + { 
 + / / in case something will go wrong we don ' t want to loop forever using for ( ; ; ) 
 + for ( int i = 0 ; i < sstables . size ( ) ; i + + ) 
 + { 
 + try 
 + { 
 + store . forceMajorCompaction ( ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + failures + + ; 
 + continue ; 
 + } 
 + 
 + assertEquals ( sstablesToCorrupt + 1 , store . getSSTables ( ) . size ( ) ) ; 
 + break ; 
 + } 
 + } 
 + finally 
 + { 
 + System . setErr ( new PrintStream ( new ByteArrayOutputStream ( ) ) ) ; 
 + } 
 + 
 + 
 + store . truncate ( ) ; 
 + assertEquals ( failures , sstablesToCorrupt ) ; 
 + } 
 }
