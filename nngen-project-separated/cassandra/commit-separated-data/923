BLEU SCORE: 0.037477767366779206

TEST MSG: Fix PER PARTITION LIMIT for queries requiring post - query ordering
GENERATED MSG: Allow per partition limit in SELECT queries

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3b5f1b7 . . 443c8bc 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 6 <nl> + * Fix PER PARTITION LIMIT for queries requiring post - query ordering ( CASSANDRA - 11556 ) <nl> * Allow instantiation of UDTs and tuples in UDFs ( CASSANDRA - 10818 ) <nl> * Support UDT in CQLSSTableWriter ( CASSANDRA - 10624 ) <nl> * Support for non - frozen user - defined types , updating <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 9745b05 . . 2f64b25 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 596 , 12 + 596 , 12 @ @ public class SelectStatement implements CQLStatement <nl> / / Whenever we support GROUP BY , we ' ll have to add a new DataLimits kind that knows how things are grouped and is thus <nl> / / able to apply the user limit properly . <nl> / / If we do post ordering we need to get all the results sorted before we can trim them . <nl> - if ( ! selection . isAggregate ( ) & & ! needsPostQueryOrdering ( ) ) <nl> + if ( ! selection . isAggregate ( ) ) <nl> { <nl> - cqlRowLimit = userLimit ; <nl> + if ( ! needsPostQueryOrdering ( ) ) <nl> + cqlRowLimit = userLimit ; <nl> cqlPerPartitionLimit = perPartitionLimit ; <nl> } <nl> - <nl> if ( parameters . isDistinct ) <nl> return cqlRowLimit = = DataLimits . NO _ LIMIT ? DataLimits . DISTINCT _ NONE : DataLimits . distinctLimits ( cqlRowLimit ) ; <nl> <nl> @ @ - 853 , 6 + 853 , 9 @ @ public class SelectStatement implements CQLStatement <nl> validateDistinctSelection ( cfm , selection , restrictions ) ; <nl> } <nl> <nl> + checkFalse ( selection . isAggregate ( ) & & perPartitionLimit ! = null , <nl> + " PER PARTITION LIMIT is not allowed with aggregate queries . " ) ; <nl> + <nl> Comparator < List < ByteBuffer > > orderingComparator = null ; <nl> boolean isReversed = false ; <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectLimitTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectLimitTest . java <nl> index cf028a1 . . 1dffb0c 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectLimitTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectLimitTest . java <nl> @ @ - 113 , 4 + 113 , 116 @ @ public class SelectLimitTest extends CQLTester <nl> row ( 2 , 2 ) , <nl> row ( 2 , 3 ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testPerPartitionLimit ( ) throws Throwable <nl> + { <nl> + perPartitionLimitTest ( false ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testPerPartitionLimitWithCompactStorage ( ) throws Throwable <nl> + { <nl> + perPartitionLimitTest ( true ) ; <nl> + } <nl> + <nl> + private void perPartitionLimitTest ( boolean withCompactStorage ) throws Throwable <nl> + { <nl> + String query = " CREATE TABLE % s ( a int , b int , c int , PRIMARY KEY ( a , b ) ) " ; <nl> + <nl> + if ( withCompactStorage ) <nl> + createTable ( query + " WITH COMPACT STORAGE " ) ; <nl> + else <nl> + createTable ( query ) ; <nl> + <nl> + for ( int i = 0 ; i < 5 ; i + + ) <nl> + { <nl> + for ( int j = 0 ; j < 5 ; j + + ) <nl> + { <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( ? , ? , ? ) " , i , j , j ) ; <nl> + } <nl> + } <nl> + <nl> + assertInvalidMessage ( " LIMIT must be strictly positive " , <nl> + " SELECT * FROM % s PER PARTITION LIMIT ? " , 0 ) ; <nl> + assertInvalidMessage ( " LIMIT must be strictly positive " , <nl> + " SELECT * FROM % s PER PARTITION LIMIT ? " , - 1 ) ; <nl> + <nl> + assertRowsIgnoringOrder ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? " , 2 ) , <nl> + row ( 0 , 0 , 0 ) , <nl> + row ( 0 , 1 , 1 ) , <nl> + row ( 1 , 0 , 0 ) , <nl> + row ( 1 , 1 , 1 ) , <nl> + row ( 2 , 0 , 0 ) , <nl> + row ( 2 , 1 , 1 ) , <nl> + row ( 3 , 0 , 0 ) , <nl> + row ( 3 , 1 , 1 ) , <nl> + row ( 4 , 0 , 0 ) , <nl> + row ( 4 , 1 , 1 ) ) ; <nl> + <nl> + / / Combined Per Partition and " global " limit <nl> + assertRowCount ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? LIMIT ? " , 2 , 6 ) , <nl> + 6 ) ; <nl> + <nl> + / / odd amount of results <nl> + assertRowCount ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? LIMIT ? " , 2 , 5 ) , <nl> + 5 ) ; <nl> + <nl> + / / IN query <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 2 , 3 ) PER PARTITION LIMIT ? " , 2 ) , <nl> + row ( 2 , 0 , 0 ) , <nl> + row ( 2 , 1 , 1 ) , <nl> + row ( 3 , 0 , 0 ) , <nl> + row ( 3 , 1 , 1 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 2 , 3 ) PER PARTITION LIMIT ? LIMIT 3 " , 2 ) , <nl> + row ( 2 , 0 , 0 ) , <nl> + row ( 2 , 1 , 1 ) , <nl> + row ( 3 , 0 , 0 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 1 , 2 , 3 ) PER PARTITION LIMIT ? LIMIT 3 " , 2 ) , <nl> + row ( 1 , 0 , 0 ) , <nl> + row ( 1 , 1 , 1 ) , <nl> + row ( 2 , 0 , 0 ) ) ; <nl> + <nl> + / / with restricted partition key <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? PER PARTITION LIMIT ? " , 2 , 3 ) , <nl> + row ( 2 , 0 , 0 ) , <nl> + row ( 2 , 1 , 1 ) , <nl> + row ( 2 , 2 , 2 ) ) ; <nl> + <nl> + / / with ordering <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 3 , 2 ) ORDER BY b DESC PER PARTITION LIMIT ? " , 2 ) , <nl> + row ( 2 , 4 , 4 ) , <nl> + row ( 3 , 4 , 4 ) , <nl> + row ( 2 , 3 , 3 ) , <nl> + row ( 3 , 3 , 3 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 3 , 2 ) ORDER BY b DESC PER PARTITION LIMIT ? LIMIT ? " , 3 , 4 ) , <nl> + row ( 2 , 4 , 4 ) , <nl> + row ( 3 , 4 , 4 ) , <nl> + row ( 2 , 3 , 3 ) , <nl> + row ( 3 , 3 , 3 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? ORDER BY b DESC PER PARTITION LIMIT ? " , 2 , 3 ) , <nl> + row ( 2 , 4 , 4 ) , <nl> + row ( 2 , 3 , 3 ) , <nl> + row ( 2 , 2 , 2 ) ) ; <nl> + <nl> + / / with filtering <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND b > ? PER PARTITION LIMIT ? ALLOW FILTERING " , 2 , 0 , 2 ) , <nl> + row ( 2 , 1 , 1 ) , <nl> + row ( 2 , 2 , 2 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND b > ? ORDER BY b DESC PER PARTITION LIMIT ? ALLOW FILTERING " , 2 , 2 , 2 ) , <nl> + row ( 2 , 4 , 4 ) , <nl> + row ( 2 , 3 , 3 ) ) ; <nl> + <nl> + assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries " , <nl> + " SELECT DISTINCT a FROM % s PER PARTITION LIMIT ? " , 3 ) ; <nl> + assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries " , <nl> + " SELECT DISTINCT a FROM % s PER PARTITION LIMIT ? LIMIT ? " , 3 , 4 ) ; <nl> + assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with aggregate queries . " , <nl> + " SELECT COUNT ( * ) FROM % s PER PARTITION LIMIT ? " , 3 ) ; <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> index be62f6c . . 08c2732 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> @ @ - 2354 , 96 + 2354 , 4 @ @ public class SelectTest extends CQLTester <nl> unset ( ) ) ; <nl> } <nl> <nl> - @ Test <nl> - public void testPerPartitionLimit ( ) throws Throwable <nl> - { <nl> - perPartitionLimitTest ( false ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void testPerPartitionLimitWithCompactStorage ( ) throws Throwable <nl> - { <nl> - perPartitionLimitTest ( true ) ; <nl> - } <nl> - <nl> - private void perPartitionLimitTest ( boolean withCompactStorage ) throws Throwable <nl> - { <nl> - String query = " CREATE TABLE % s ( a int , b int , c int , PRIMARY KEY ( a , b ) ) " ; <nl> - <nl> - if ( withCompactStorage ) <nl> - createTable ( query + " WITH COMPACT STORAGE " ) ; <nl> - else <nl> - createTable ( query ) ; <nl> - <nl> - for ( int i = 0 ; i < 5 ; i + + ) <nl> - { <nl> - for ( int j = 0 ; j < 5 ; j + + ) <nl> - { <nl> - execute ( " INSERT INTO % s ( a , b , c ) VALUES ( ? , ? , ? ) " , i , j , j ) ; <nl> - } <nl> - } <nl> - <nl> - assertInvalidMessage ( " LIMIT must be strictly positive " , <nl> - " SELECT * FROM % s PER PARTITION LIMIT ? " , 0 ) ; <nl> - assertInvalidMessage ( " LIMIT must be strictly positive " , <nl> - " SELECT * FROM % s PER PARTITION LIMIT ? " , - 1 ) ; <nl> - <nl> - assertRowsIgnoringOrder ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? " , 2 ) , <nl> - row ( 0 , 0 , 0 ) , <nl> - row ( 0 , 1 , 1 ) , <nl> - row ( 1 , 0 , 0 ) , <nl> - row ( 1 , 1 , 1 ) , <nl> - row ( 2 , 0 , 0 ) , <nl> - row ( 2 , 1 , 1 ) , <nl> - row ( 3 , 0 , 0 ) , <nl> - row ( 3 , 1 , 1 ) , <nl> - row ( 4 , 0 , 0 ) , <nl> - row ( 4 , 1 , 1 ) ) ; <nl> - <nl> - <nl> - / / Combined Per Partition and " global " limit <nl> - assertRowCount ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? LIMIT ? " , 2 , 6 ) , <nl> - 6 ) ; <nl> - <nl> - / / odd amount of results <nl> - assertRowCount ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? LIMIT ? " , 2 , 5 ) , <nl> - 5 ) ; <nl> - <nl> - / / IN query <nl> - assertRowsIgnoringOrder ( execute ( " SELECT * FROM % s WHERE a IN ( 2 , 3 ) PER PARTITION LIMIT ? " , 2 ) , <nl> - row ( 2 , 0 , 0 ) , <nl> - row ( 2 , 1 , 1 ) , <nl> - row ( 3 , 0 , 0 ) , <nl> - row ( 3 , 1 , 1 ) ) ; <nl> - <nl> - assertRowCount ( execute ( " SELECT * FROM % s WHERE a IN ( 2 , 3 ) PER PARTITION LIMIT ? LIMIT 3 " , 2 ) , 3 ) ; <nl> - assertRowCount ( execute ( " SELECT * FROM % s WHERE a IN ( 1 , 2 , 3 ) PER PARTITION LIMIT ? LIMIT 3 " , 2 ) , 3 ) ; <nl> - <nl> - <nl> - / / with restricted partition key <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE a = ? PER PARTITION LIMIT ? " , 2 , 3 ) , <nl> - row ( 2 , 0 , 0 ) , <nl> - row ( 2 , 1 , 1 ) , <nl> - row ( 2 , 2 , 2 ) ) ; <nl> - <nl> - / / with ordering <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE a = ? ORDER BY b DESC PER PARTITION LIMIT ? " , 2 , 3 ) , <nl> - row ( 2 , 4 , 4 ) , <nl> - row ( 2 , 3 , 3 ) , <nl> - row ( 2 , 2 , 2 ) ) ; <nl> - <nl> - / / with filtering <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND b > ? PER PARTITION LIMIT ? ALLOW FILTERING " , 2 , 0 , 2 ) , <nl> - row ( 2 , 1 , 1 ) , <nl> - row ( 2 , 2 , 2 ) ) ; <nl> - <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND b > ? ORDER BY b DESC PER PARTITION LIMIT ? ALLOW FILTERING " , 2 , 2 , 2 ) , <nl> - row ( 2 , 4 , 4 ) , <nl> - row ( 2 , 3 , 3 ) ) ; <nl> - <nl> - assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries " , <nl> - " SELECT DISTINCT a FROM % s PER PARTITION LIMIT ? " , 3 ) ; <nl> - assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries " , <nl> - " SELECT DISTINCT a FROM % s PER PARTITION LIMIT ? LIMIT ? " , 3 , 4 ) ; <nl> - } <nl> } <nl> \ No newline at end of file
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3b5f1b7 . . 443c8bc 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 6 
 + * Fix PER PARTITION LIMIT for queries requiring post - query ordering ( CASSANDRA - 11556 ) 
 * Allow instantiation of UDTs and tuples in UDFs ( CASSANDRA - 10818 ) 
 * Support UDT in CQLSSTableWriter ( CASSANDRA - 10624 ) 
 * Support for non - frozen user - defined types , updating 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 9745b05 . . 2f64b25 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 596 , 12 + 596 , 12 @ @ public class SelectStatement implements CQLStatement 
 / / Whenever we support GROUP BY , we ' ll have to add a new DataLimits kind that knows how things are grouped and is thus 
 / / able to apply the user limit properly . 
 / / If we do post ordering we need to get all the results sorted before we can trim them . 
 - if ( ! selection . isAggregate ( ) & & ! needsPostQueryOrdering ( ) ) 
 + if ( ! selection . isAggregate ( ) ) 
 { 
 - cqlRowLimit = userLimit ; 
 + if ( ! needsPostQueryOrdering ( ) ) 
 + cqlRowLimit = userLimit ; 
 cqlPerPartitionLimit = perPartitionLimit ; 
 } 
 - 
 if ( parameters . isDistinct ) 
 return cqlRowLimit = = DataLimits . NO _ LIMIT ? DataLimits . DISTINCT _ NONE : DataLimits . distinctLimits ( cqlRowLimit ) ; 
 
 @ @ - 853 , 6 + 853 , 9 @ @ public class SelectStatement implements CQLStatement 
 validateDistinctSelection ( cfm , selection , restrictions ) ; 
 } 
 
 + checkFalse ( selection . isAggregate ( ) & & perPartitionLimit ! = null , 
 + " PER PARTITION LIMIT is not allowed with aggregate queries . " ) ; 
 + 
 Comparator < List < ByteBuffer > > orderingComparator = null ; 
 boolean isReversed = false ; 
 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectLimitTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectLimitTest . java 
 index cf028a1 . . 1dffb0c 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectLimitTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectLimitTest . java 
 @ @ - 113 , 4 + 113 , 116 @ @ public class SelectLimitTest extends CQLTester 
 row ( 2 , 2 ) , 
 row ( 2 , 3 ) ) ; 
 } 
 + 
 + @ Test 
 + public void testPerPartitionLimit ( ) throws Throwable 
 + { 
 + perPartitionLimitTest ( false ) ; 
 + } 
 + 
 + @ Test 
 + public void testPerPartitionLimitWithCompactStorage ( ) throws Throwable 
 + { 
 + perPartitionLimitTest ( true ) ; 
 + } 
 + 
 + private void perPartitionLimitTest ( boolean withCompactStorage ) throws Throwable 
 + { 
 + String query = " CREATE TABLE % s ( a int , b int , c int , PRIMARY KEY ( a , b ) ) " ; 
 + 
 + if ( withCompactStorage ) 
 + createTable ( query + " WITH COMPACT STORAGE " ) ; 
 + else 
 + createTable ( query ) ; 
 + 
 + for ( int i = 0 ; i < 5 ; i + + ) 
 + { 
 + for ( int j = 0 ; j < 5 ; j + + ) 
 + { 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( ? , ? , ? ) " , i , j , j ) ; 
 + } 
 + } 
 + 
 + assertInvalidMessage ( " LIMIT must be strictly positive " , 
 + " SELECT * FROM % s PER PARTITION LIMIT ? " , 0 ) ; 
 + assertInvalidMessage ( " LIMIT must be strictly positive " , 
 + " SELECT * FROM % s PER PARTITION LIMIT ? " , - 1 ) ; 
 + 
 + assertRowsIgnoringOrder ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? " , 2 ) , 
 + row ( 0 , 0 , 0 ) , 
 + row ( 0 , 1 , 1 ) , 
 + row ( 1 , 0 , 0 ) , 
 + row ( 1 , 1 , 1 ) , 
 + row ( 2 , 0 , 0 ) , 
 + row ( 2 , 1 , 1 ) , 
 + row ( 3 , 0 , 0 ) , 
 + row ( 3 , 1 , 1 ) , 
 + row ( 4 , 0 , 0 ) , 
 + row ( 4 , 1 , 1 ) ) ; 
 + 
 + / / Combined Per Partition and " global " limit 
 + assertRowCount ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? LIMIT ? " , 2 , 6 ) , 
 + 6 ) ; 
 + 
 + / / odd amount of results 
 + assertRowCount ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? LIMIT ? " , 2 , 5 ) , 
 + 5 ) ; 
 + 
 + / / IN query 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 2 , 3 ) PER PARTITION LIMIT ? " , 2 ) , 
 + row ( 2 , 0 , 0 ) , 
 + row ( 2 , 1 , 1 ) , 
 + row ( 3 , 0 , 0 ) , 
 + row ( 3 , 1 , 1 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 2 , 3 ) PER PARTITION LIMIT ? LIMIT 3 " , 2 ) , 
 + row ( 2 , 0 , 0 ) , 
 + row ( 2 , 1 , 1 ) , 
 + row ( 3 , 0 , 0 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 1 , 2 , 3 ) PER PARTITION LIMIT ? LIMIT 3 " , 2 ) , 
 + row ( 1 , 0 , 0 ) , 
 + row ( 1 , 1 , 1 ) , 
 + row ( 2 , 0 , 0 ) ) ; 
 + 
 + / / with restricted partition key 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? PER PARTITION LIMIT ? " , 2 , 3 ) , 
 + row ( 2 , 0 , 0 ) , 
 + row ( 2 , 1 , 1 ) , 
 + row ( 2 , 2 , 2 ) ) ; 
 + 
 + / / with ordering 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 3 , 2 ) ORDER BY b DESC PER PARTITION LIMIT ? " , 2 ) , 
 + row ( 2 , 4 , 4 ) , 
 + row ( 3 , 4 , 4 ) , 
 + row ( 2 , 3 , 3 ) , 
 + row ( 3 , 3 , 3 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( 3 , 2 ) ORDER BY b DESC PER PARTITION LIMIT ? LIMIT ? " , 3 , 4 ) , 
 + row ( 2 , 4 , 4 ) , 
 + row ( 3 , 4 , 4 ) , 
 + row ( 2 , 3 , 3 ) , 
 + row ( 3 , 3 , 3 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? ORDER BY b DESC PER PARTITION LIMIT ? " , 2 , 3 ) , 
 + row ( 2 , 4 , 4 ) , 
 + row ( 2 , 3 , 3 ) , 
 + row ( 2 , 2 , 2 ) ) ; 
 + 
 + / / with filtering 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND b > ? PER PARTITION LIMIT ? ALLOW FILTERING " , 2 , 0 , 2 ) , 
 + row ( 2 , 1 , 1 ) , 
 + row ( 2 , 2 , 2 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND b > ? ORDER BY b DESC PER PARTITION LIMIT ? ALLOW FILTERING " , 2 , 2 , 2 ) , 
 + row ( 2 , 4 , 4 ) , 
 + row ( 2 , 3 , 3 ) ) ; 
 + 
 + assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries " , 
 + " SELECT DISTINCT a FROM % s PER PARTITION LIMIT ? " , 3 ) ; 
 + assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries " , 
 + " SELECT DISTINCT a FROM % s PER PARTITION LIMIT ? LIMIT ? " , 3 , 4 ) ; 
 + assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with aggregate queries . " , 
 + " SELECT COUNT ( * ) FROM % s PER PARTITION LIMIT ? " , 3 ) ; 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 index be62f6c . . 08c2732 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 @ @ - 2354 , 96 + 2354 , 4 @ @ public class SelectTest extends CQLTester 
 unset ( ) ) ; 
 } 
 
 - @ Test 
 - public void testPerPartitionLimit ( ) throws Throwable 
 - { 
 - perPartitionLimitTest ( false ) ; 
 - } 
 - 
 - @ Test 
 - public void testPerPartitionLimitWithCompactStorage ( ) throws Throwable 
 - { 
 - perPartitionLimitTest ( true ) ; 
 - } 
 - 
 - private void perPartitionLimitTest ( boolean withCompactStorage ) throws Throwable 
 - { 
 - String query = " CREATE TABLE % s ( a int , b int , c int , PRIMARY KEY ( a , b ) ) " ; 
 - 
 - if ( withCompactStorage ) 
 - createTable ( query + " WITH COMPACT STORAGE " ) ; 
 - else 
 - createTable ( query ) ; 
 - 
 - for ( int i = 0 ; i < 5 ; i + + ) 
 - { 
 - for ( int j = 0 ; j < 5 ; j + + ) 
 - { 
 - execute ( " INSERT INTO % s ( a , b , c ) VALUES ( ? , ? , ? ) " , i , j , j ) ; 
 - } 
 - } 
 - 
 - assertInvalidMessage ( " LIMIT must be strictly positive " , 
 - " SELECT * FROM % s PER PARTITION LIMIT ? " , 0 ) ; 
 - assertInvalidMessage ( " LIMIT must be strictly positive " , 
 - " SELECT * FROM % s PER PARTITION LIMIT ? " , - 1 ) ; 
 - 
 - assertRowsIgnoringOrder ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? " , 2 ) , 
 - row ( 0 , 0 , 0 ) , 
 - row ( 0 , 1 , 1 ) , 
 - row ( 1 , 0 , 0 ) , 
 - row ( 1 , 1 , 1 ) , 
 - row ( 2 , 0 , 0 ) , 
 - row ( 2 , 1 , 1 ) , 
 - row ( 3 , 0 , 0 ) , 
 - row ( 3 , 1 , 1 ) , 
 - row ( 4 , 0 , 0 ) , 
 - row ( 4 , 1 , 1 ) ) ; 
 - 
 - 
 - / / Combined Per Partition and " global " limit 
 - assertRowCount ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? LIMIT ? " , 2 , 6 ) , 
 - 6 ) ; 
 - 
 - / / odd amount of results 
 - assertRowCount ( execute ( " SELECT * FROM % s PER PARTITION LIMIT ? LIMIT ? " , 2 , 5 ) , 
 - 5 ) ; 
 - 
 - / / IN query 
 - assertRowsIgnoringOrder ( execute ( " SELECT * FROM % s WHERE a IN ( 2 , 3 ) PER PARTITION LIMIT ? " , 2 ) , 
 - row ( 2 , 0 , 0 ) , 
 - row ( 2 , 1 , 1 ) , 
 - row ( 3 , 0 , 0 ) , 
 - row ( 3 , 1 , 1 ) ) ; 
 - 
 - assertRowCount ( execute ( " SELECT * FROM % s WHERE a IN ( 2 , 3 ) PER PARTITION LIMIT ? LIMIT 3 " , 2 ) , 3 ) ; 
 - assertRowCount ( execute ( " SELECT * FROM % s WHERE a IN ( 1 , 2 , 3 ) PER PARTITION LIMIT ? LIMIT 3 " , 2 ) , 3 ) ; 
 - 
 - 
 - / / with restricted partition key 
 - assertRows ( execute ( " SELECT * FROM % s WHERE a = ? PER PARTITION LIMIT ? " , 2 , 3 ) , 
 - row ( 2 , 0 , 0 ) , 
 - row ( 2 , 1 , 1 ) , 
 - row ( 2 , 2 , 2 ) ) ; 
 - 
 - / / with ordering 
 - assertRows ( execute ( " SELECT * FROM % s WHERE a = ? ORDER BY b DESC PER PARTITION LIMIT ? " , 2 , 3 ) , 
 - row ( 2 , 4 , 4 ) , 
 - row ( 2 , 3 , 3 ) , 
 - row ( 2 , 2 , 2 ) ) ; 
 - 
 - / / with filtering 
 - assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND b > ? PER PARTITION LIMIT ? ALLOW FILTERING " , 2 , 0 , 2 ) , 
 - row ( 2 , 1 , 1 ) , 
 - row ( 2 , 2 , 2 ) ) ; 
 - 
 - assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND b > ? ORDER BY b DESC PER PARTITION LIMIT ? ALLOW FILTERING " , 2 , 2 , 2 ) , 
 - row ( 2 , 4 , 4 ) , 
 - row ( 2 , 3 , 3 ) ) ; 
 - 
 - assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries " , 
 - " SELECT DISTINCT a FROM % s PER PARTITION LIMIT ? " , 3 ) ; 
 - assertInvalidMessage ( " PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries " , 
 - " SELECT DISTINCT a FROM % s PER PARTITION LIMIT ? LIMIT ? " , 3 , 4 ) ; 
 - } 
 } 
 \ No newline at end of file

NEAREST DIFF:
ELIMINATEDSENTENCE
