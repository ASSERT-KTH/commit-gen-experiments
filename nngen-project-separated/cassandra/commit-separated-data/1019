BLEU SCORE: 0.03283637368030199

TEST MSG: fix EQ semantics of analyzed SASI indexes
GENERATED MSG: nodetool scrub

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c09a453 . . 28651e2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 4 <nl> + * fix EQ semantics of analyzed SASI indexes ( CASSANDRA - 11130 ) <nl> * Support long name output for nodetool commands ( CASSANDRA - 7950 ) <nl> * Encrypted hints ( CASSANDRA - 11040 ) <nl> * SASI index options validation ( CASSANDRA - 11136 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index d560119 . . 5cb479c 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 209 , 7 + 209 , 7 @ @ options { <nl> } <nl> else <nl> { <nl> - operator = Operator . EQ ; <nl> + operator = Operator . LIKE _ MATCHES ; <nl> endIndex + = 1 ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Operator . java b / src / java / org / apache / cassandra / cql3 / Operator . java <nl> index d518961 . . accb786 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Operator . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / Operator . java <nl> @ @ - 126 , 6 + 126 , 14 @ @ public enum Operator <nl> { <nl> return " LIKE ' % < term > % ' " ; <nl> } <nl> + } , <nl> + LIKE _ MATCHES ( 13 ) <nl> + { <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + return " LIKE ' < term > ' " ; <nl> + } <nl> } ; <nl> <nl> / * * <nl> @ @ - 222 , 6 + 230 , 7 @ @ public enum Operator <nl> return ByteBufferUtil . startsWith ( leftOperand , rightOperand ) ; <nl> case LIKE _ SUFFIX : <nl> return ByteBufferUtil . endsWith ( leftOperand , rightOperand ) ; <nl> + case LIKE _ MATCHES : <nl> case LIKE _ CONTAINS : <nl> return ByteBufferUtil . contains ( leftOperand , rightOperand ) ; <nl> default : <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Relation . java b / src / java / org / apache / cassandra / cql3 / Relation . java <nl> index 81f46a6 . . 616fd30 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Relation . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / Relation . java <nl> @ @ - 112 , 7 + 112 , 8 @ @ public abstract class Relation { <nl> { <nl> return relationType = = Operator . LIKE _ PREFIX <nl> | | relationType = = Operator . LIKE _ SUFFIX <nl> - | | relationType = = Operator . LIKE _ CONTAINS ; <nl> + | | relationType = = Operator . LIKE _ CONTAINS <nl> + | | relationType = = Operator . LIKE _ MATCHES ; <nl> } <nl> <nl> / * * <nl> @ @ - 153 , 6 + 154 , 7 @ @ public abstract class Relation { <nl> case LIKE _ PREFIX : <nl> case LIKE _ SUFFIX : <nl> case LIKE _ CONTAINS : <nl> + case LIKE _ MATCHES : <nl> return newLikeRestriction ( cfm , boundNames , relationType ) ; <nl> default : throw invalidRequest ( " Unsupported \ " ! = \ " relation : % s " , this ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / RowFilter . java b / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> index 1141fd9 . . fcc3cd5 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> @ @ - 604 , 6 + 604 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> case LIKE _ PREFIX : <nl> case LIKE _ SUFFIX : <nl> case LIKE _ CONTAINS : <nl> + case LIKE _ MATCHES : <nl> { <nl> assert ! column . isComplex ( ) : " Only CONTAINS and CONTAINS _ KEY are supported for ' complex ' types " ; <nl> ByteBuffer foundValue = getValue ( metadata , partitionKey , row ) ; <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / analyzer / AbstractAnalyzer . java b / src / java / org / apache / cassandra / index / sasi / analyzer / AbstractAnalyzer . java <nl> index b3fdd8c . . 31c66cc 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / analyzer / AbstractAnalyzer . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / analyzer / AbstractAnalyzer . java <nl> @ @ - 42 , 6 + 42 , 14 @ @ public abstract class AbstractAnalyzer implements Iterator < ByteBuffer > <nl> <nl> public abstract void reset ( ByteBuffer input ) ; <nl> <nl> + / * * <nl> + * @ return true if current analyzer provides text tokenization , false otherwise . <nl> + * / <nl> + public boolean isTokenizing ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> public static String normalize ( String original ) <nl> { <nl> return Normalizer . isNormalized ( original , Normalizer . Form . NFC ) <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / analyzer / StandardAnalyzer . java b / src / java / org / apache / cassandra / index / sasi / analyzer / StandardAnalyzer . java <nl> index bcc63df . . 5e09b9f 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / analyzer / StandardAnalyzer . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / analyzer / StandardAnalyzer . java <nl> @ @ - 191 , 4 + 191 , 9 @ @ public class StandardAnalyzer extends AbstractAnalyzer <nl> scanner . yyreset ( reader ) ; <nl> this . inputReader = reader ; <nl> } <nl> + <nl> + public boolean isTokenizing ( ) <nl> + { <nl> + return true ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> index 29e7c28 . . 1703bd4 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . index . sasi . conf . view . View ; <nl> import org . apache . cassandra . index . sasi . disk . Token ; <nl> import org . apache . cassandra . index . sasi . memory . IndexMemtable ; <nl> import org . apache . cassandra . index . sasi . plan . Expression ; <nl> + import org . apache . cassandra . index . sasi . plan . Expression . Op ; <nl> import org . apache . cassandra . index . sasi . utils . RangeIterator ; <nl> import org . apache . cassandra . io . sstable . Component ; <nl> import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> @ @ - 58 , 6 + 59 , 8 @ @ public class ColumnIndex <nl> private final Component component ; <nl> private final DataTracker tracker ; <nl> <nl> + private final boolean isTokenized ; <nl> + <nl> public ColumnIndex ( AbstractType < ? > keyValidator , ColumnDefinition column , IndexMetadata metadata ) <nl> { <nl> this . keyValidator = keyValidator ; <nl> @ @ - 67 , 6 + 70 , 7 @ @ public class ColumnIndex <nl> this . memtable = new AtomicReference < > ( new IndexMemtable ( this ) ) ; <nl> this . tracker = new DataTracker ( keyValidator , this ) ; <nl> this . component = new Component ( Component . Type . SECONDARY _ INDEX , String . format ( FILE _ NAME _ FORMAT , getIndexName ( ) ) ) ; <nl> + this . isTokenized = getAnalyzer ( ) . isTokenizing ( ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 170 , 9 + 174 , 13 @ @ public class ColumnIndex <nl> return isIndexed ( ) ? mode . isLiteral : ( validator instanceof UTF8Type | | validator instanceof AsciiType ) ; <nl> } <nl> <nl> - public boolean supports ( Operator operator ) <nl> + public boolean supports ( Operator op ) <nl> { <nl> - return mode . supports ( Expression . Op . valueOf ( operator ) ) ; <nl> + Op operator = Op . valueOf ( op ) ; <nl> + return ! ( isTokenized & & operator = = Op . EQ ) / / EQ is only applicable to non - tokenized indexes <nl> + & & ! ( isLiteral ( ) & & operator = = Op . RANGE ) / / RANGE only applicable to indexes non - literal indexes <nl> + & & mode . supports ( operator ) ; / / for all other cases let ' s refer to index itself <nl> + <nl> } <nl> <nl> public static ByteBuffer getValueOf ( ColumnDefinition column , Row row , int nowInSecs ) <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java b / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java <nl> index b9c5653 . . 1c85ed5 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java <nl> @ @ - 179 , 6 + 179 , 6 @ @ public class IndexMode <nl> <nl> public boolean supports ( Op operator ) <nl> { <nl> - return ! ( isLiteral & & operator = = Op . RANGE ) & & mode . supports ( operator ) ; <nl> + return mode . supports ( operator ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / disk / OnDiskIndexBuilder . java b / src / java / org / apache / cassandra / index / sasi / disk / OnDiskIndexBuilder . java <nl> index 20a8739 . . 04b7b1c 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / disk / OnDiskIndexBuilder . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / disk / OnDiskIndexBuilder . java <nl> @ @ - 50 , 8 + 50 , 8 @ @ public class OnDiskIndexBuilder <nl> <nl> public enum Mode <nl> { <nl> - PREFIX ( EnumSet . of ( Op . EQ , Op . PREFIX , Op . NOT _ EQ , Op . RANGE ) ) , <nl> - CONTAINS ( EnumSet . of ( Op . EQ , Op . CONTAINS , Op . SUFFIX , Op . NOT _ EQ ) ) , <nl> + PREFIX ( EnumSet . of ( Op . EQ , Op . MATCH , Op . PREFIX , Op . NOT _ EQ , Op . RANGE ) ) , <nl> + CONTAINS ( EnumSet . of ( Op . MATCH , Op . CONTAINS , Op . SUFFIX , Op . NOT _ EQ ) ) , <nl> SPARSE ( EnumSet . of ( Op . EQ , Op . NOT _ EQ , Op . RANGE ) ) ; <nl> <nl> Set < Op > supportedOps ; <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / memory / TrieMemIndex . java b / src / java / org / apache / cassandra / index / sasi / memory / TrieMemIndex . java <nl> index 99a417a . . 0da65c7 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / memory / TrieMemIndex . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / memory / TrieMemIndex . java <nl> @ @ - 182 , 6 + 182 , 7 @ @ public class TrieMemIndex extends MemIndex <nl> switch ( operator ) <nl> { <nl> case EQ : <nl> + case MATCH : <nl> ConcurrentSkipListSet < DecoratedKey > keys = trie . getValueForExactKey ( value ) ; <nl> return keys = = null ? Collections . emptyList ( ) : Collections . singletonList ( keys ) ; <nl> <nl> @ @ - 219 , 6 + 220 , 7 @ @ public class TrieMemIndex extends MemIndex <nl> switch ( operator ) <nl> { <nl> case EQ : <nl> + case MATCH : <nl> ConcurrentSkipListSet < DecoratedKey > keys = trie . getValueForExactKey ( value ) ; <nl> return keys = = null ? Collections . emptyList ( ) : Collections . singletonList ( keys ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / plan / Expression . java b / src / java / org / apache / cassandra / index / sasi / plan / Expression . java <nl> index 43f8251 . . 679d866 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / plan / Expression . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / plan / Expression . java <nl> @ @ - 46 , 7 + 46 , 7 @ @ public class Expression <nl> <nl> public enum Op <nl> { <nl> - EQ , PREFIX , SUFFIX , CONTAINS , NOT _ EQ , RANGE ; <nl> + EQ , MATCH , PREFIX , SUFFIX , CONTAINS , NOT _ EQ , RANGE ; <nl> <nl> public static Op valueOf ( Operator operator ) <nl> { <nl> @ @ - 73 , 6 + 73 , 9 @ @ public class Expression <nl> case LIKE _ CONTAINS : <nl> return CONTAINS ; <nl> <nl> + case LIKE _ MATCHES : <nl> + return MATCH ; <nl> + <nl> default : <nl> throw new IllegalArgumentException ( " unknown operator : " + operator ) ; <nl> } <nl> @ @ - 140 , 6 + 143 , 7 @ @ public class Expression <nl> case LIKE _ PREFIX : <nl> case LIKE _ SUFFIX : <nl> case LIKE _ CONTAINS : <nl> + case LIKE _ MATCHES : <nl> case EQ : <nl> lower = new Bound ( value , true ) ; <nl> upper = lower ; <nl> @ @ - 262 , 6 + 266 , 7 @ @ public class Expression <nl> switch ( operation ) <nl> { <nl> case EQ : <nl> + case MATCH : <nl> / / Operation . isSatisfiedBy handles conclusion on ! = , <nl> / / here we just need to make sure that term matched it <nl> case NOT _ EQ : <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / plan / Operation . java b / src / java / org / apache / cassandra / index / sasi / plan / Operation . java <nl> index 28bcc51 . . f8b02a3 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / plan / Operation . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / plan / Operation . java <nl> @ @ - 292 , 9 + 292 , 13 @ @ public class Operation extends RangeIterator < Long , Token > <nl> switch ( e . operator ( ) ) <nl> { <nl> case EQ : <nl> + isMultiExpression = false ; <nl> + break ; <nl> + <nl> case LIKE _ PREFIX : <nl> case LIKE _ SUFFIX : <nl> case LIKE _ CONTAINS : <nl> + case LIKE _ MATCHES : <nl> isMultiExpression = true ; <nl> break ; <nl> <nl> @ @ - 341 , 6 + 345 , 7 @ @ public class Operation extends RangeIterator < Long , Token > <nl> case LIKE _ PREFIX : <nl> case LIKE _ SUFFIX : <nl> case LIKE _ CONTAINS : <nl> + case LIKE _ MATCHES : <nl> return 4 ; <nl> <nl> case GTE : <nl> diff - - git a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> index 2ae1e70 . . a88e594 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> + + + b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> @ @ - 167 , 7 + 167 , 7 @ @ public class SASIIndexTest <nl> <nl> ColumnFamilyStore store = loadData ( data , forceFlush ) ; <nl> <nl> - Set < String > rows = getIndexed ( store , 10 , buildExpression ( UTF8Type . instance . decompose ( " first _ name " ) , Operator . EQ , UTF8Type . instance . decompose ( " doesntmatter " ) ) ) ; <nl> + Set < String > rows = getIndexed ( store , 10 , buildExpression ( UTF8Type . instance . decompose ( " first _ name " ) , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " doesntmatter " ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> } <nl> <nl> @ @ - 502 , 18 + 502 , 18 @ @ public class SASIIndexTest <nl> store = loadData ( part4 , forceFlush ) ; <nl> <nl> rows = getIndexed ( store , 10 , <nl> - buildExpression ( firstName , Operator . EQ , UTF8Type . instance . decompose ( " Susana " ) ) , <nl> + buildExpression ( firstName , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " Susana " ) ) , <nl> buildExpression ( age , Operator . LTE , Int32Type . instance . decompose ( 13 ) ) , <nl> buildExpression ( age , Operator . GT , Int32Type . instance . decompose ( 10 ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key12 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> <nl> rows = getIndexed ( store , 10 , <nl> - buildExpression ( firstName , Operator . EQ , UTF8Type . instance . decompose ( " Demario " ) ) , <nl> + buildExpression ( firstName , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " Demario " ) ) , <nl> buildExpression ( age , Operator . LTE , Int32Type . instance . decompose ( 30 ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , rows . size ( ) = = 0 ) ; <nl> <nl> rows = getIndexed ( store , 10 , <nl> - buildExpression ( firstName , Operator . EQ , UTF8Type . instance . decompose ( " Josephine " ) ) ) ; <nl> + buildExpression ( firstName , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " Josephine " ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , rows . size ( ) = = 0 ) ; <nl> <nl> rows = getIndexed ( store , 10 , <nl> @ @ - 1142 , 7 + 1142 , 7 @ @ public class SASIIndexTest <nl> rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ SUFFIX , UTF8Type . instance . decompose ( " ン " ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key4 " , " key5 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> <nl> - rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . EQ , UTF8Type . instance . decompose ( " レ ス ト ラ ン " ) ) ) ; <nl> + rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " レ ス ト ラ ン " ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key4 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> } <nl> <nl> @ @ - 1211 , 7 + 1211 , 7 @ @ public class SASIIndexTest <nl> rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ SUFFIX , UTF8Type . instance . decompose ( " ン " ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key3 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> <nl> - rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . EQ , UTF8Type . instance . decompose ( " ベ ン ジ ャ ミ ン ウ エ ス ト " ) ) ) ; <nl> + rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " ベ ン ジ ャ ミ ン ウ エ ス ト " ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key4 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> } <nl> <nl> @ @ - 1235 , 12 + 1235 , 12 @ @ public class SASIIndexTest <nl> <nl> Set < String > rows ; <nl> <nl> - rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . EQ , bigValue . duplicate ( ) ) ) ; <nl> + rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ MATCHES , bigValue . duplicate ( ) ) ) ; <nl> Assert . assertEquals ( 0 , rows . size ( ) ) ; <nl> <nl> store . forceBlockingFlush ( ) ; <nl> <nl> - rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . EQ , bigValue . duplicate ( ) ) ) ; <nl> + rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ MATCHES , bigValue . duplicate ( ) ) ) ; <nl> Assert . assertEquals ( 0 , rows . size ( ) ) ; <nl> } <nl> } <nl> @ @ - 1471 , 6 + 1471 , 10 @ @ public class SASIIndexTest <nl> update ( rm , name , UTF8Type . instance . decompose ( " Vijay " ) , System . currentTimeMillis ( ) ) ; <nl> rm . apply ( ) ; <nl> <nl> + rm = new Mutation ( KS _ NAME , decoratedKey ( " key8 " ) ) ; / / this name is going to be tokenized <nl> + update ( rm , name , UTF8Type . instance . decompose ( " Jean - Claude " ) , System . currentTimeMillis ( ) ) ; <nl> + rm . apply ( ) ; <nl> + <nl> / / this flush is going to produce range - ' jason ' - > ' vijay ' <nl> store . forceBlockingFlush ( ) ; <nl> <nl> @ @ - 1478 , 11 + 1482 , 12 @ @ public class SASIIndexTest <nl> / / since simple interval tree lookup is not going to cover it , prefix lookup actually required . <nl> <nl> Set < String > rows ; <nl> + <nl> rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ PREFIX , UTF8Type . instance . decompose ( " J " ) ) ) ; <nl> - Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key5 " , " key6 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key5 " , " key6 " , " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> <nl> rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ PREFIX , UTF8Type . instance . decompose ( " j " ) ) ) ; <nl> - Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key5 " , " key6 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key5 " , " key6 " , " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> <nl> rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ PREFIX , UTF8Type . instance . decompose ( " m " ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key3 " , " key4 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> @ @ - 1495 , 13 + 1500 , 28 @ @ public class SASIIndexTest <nl> <nl> rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ PREFIX , UTF8Type . instance . decompose ( " j " ) ) , <nl> buildExpression ( name , Operator . NEQ , UTF8Type . instance . decompose ( " joh " ) ) ) ; <nl> - Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key6 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key6 " , " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> <nl> - rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " pavel " ) ) ) ; <nl> + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " pavel " ) ) ) ; <nl> Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key1 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> <nl> rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " Pave " ) ) ) ; <nl> Assert . assertTrue ( rows . isEmpty ( ) ) ; <nl> + <nl> + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " Pavel " ) ) ) ; <nl> + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key1 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> + <nl> + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " JeAn " ) ) ) ; <nl> + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> + <nl> + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " claUde " ) ) ) ; <nl> + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> + <nl> + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " Jean " ) ) ) ; <nl> + Assert . assertTrue ( rows . isEmpty ( ) ) ; <nl> + <nl> + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " Jean - Claude " ) ) ) ; <nl> + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 1746 , 6 + 1766 , 178 @ @ public class SASIIndexTest <nl> } <nl> } <nl> <nl> + @ Test <nl> + public void testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes ( ) <nl> + { <nl> + String containsTable = " sasi _ like _ contains _ test " ; <nl> + String prefixTable = " sasi _ like _ prefix _ test " ; <nl> + String analyzedPrefixTable = " sasi _ like _ analyzed _ prefix _ test " ; <nl> + <nl> + QueryProcessor . executeOnceInternal ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( k int primary key , v text ) ; " , KS _ NAME , containsTable ) ) ; <nl> + QueryProcessor . executeOnceInternal ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( k int primary key , v text ) ; " , KS _ NAME , prefixTable ) ) ; <nl> + QueryProcessor . executeOnceInternal ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( k int primary key , v text ) ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + <nl> + QueryProcessor . executeOnceInternal ( String . format ( " CREATE CUSTOM INDEX IF NOT EXISTS ON % s . % s ( v ) " + <nl> + " USING ' org . apache . cassandra . index . sasi . SASIIndex ' WITH OPTIONS = { ' mode ' : ' CONTAINS ' } ; " , KS _ NAME , containsTable ) ) ; <nl> + QueryProcessor . executeOnceInternal ( String . format ( " CREATE CUSTOM INDEX IF NOT EXISTS ON % s . % s ( v ) " + <nl> + " USING ' org . apache . cassandra . index . sasi . SASIIndex ' WITH OPTIONS = { ' mode ' : ' PREFIX ' } ; " , KS _ NAME , prefixTable ) ) ; <nl> + QueryProcessor . executeOnceInternal ( String . format ( " CREATE CUSTOM INDEX IF NOT EXISTS ON % s . % s ( v ) " + <nl> + " USING ' org . apache . cassandra . index . sasi . SASIIndex ' WITH OPTIONS = { ' mode ' : ' PREFIX ' , ' analyzed ' : ' true ' } ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + <nl> + testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes ( containsTable , prefixTable , analyzedPrefixTable , false ) ; <nl> + testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes ( containsTable , prefixTable , analyzedPrefixTable , true ) ; <nl> + } <nl> + <nl> + private void testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes ( String containsTable , <nl> + String prefixTable , <nl> + String analyzedPrefixTable , <nl> + boolean forceFlush ) <nl> + { <nl> + QueryProcessor . executeOnceInternal ( String . format ( " INSERT INTO % s . % s ( k , v ) VALUES ( ? , ? ) ; " , KS _ NAME , containsTable ) , 0 , " Pavel " ) ; <nl> + QueryProcessor . executeOnceInternal ( String . format ( " INSERT INTO % s . % s ( k , v ) VALUES ( ? , ? ) ; " , KS _ NAME , prefixTable ) , 0 , " Jean - Claude " ) ; <nl> + QueryProcessor . executeOnceInternal ( String . format ( " INSERT INTO % s . % s ( k , v ) VALUES ( ? , ? ) ; " , KS _ NAME , analyzedPrefixTable ) , 0 , " Jean - Claude " ) ; <nl> + <nl> + if ( forceFlush ) <nl> + { <nl> + Keyspace keyspace = Keyspace . open ( KS _ NAME ) ; <nl> + for ( String table : Arrays . asList ( containsTable , prefixTable , analyzedPrefixTable ) ) <nl> + keyspace . getColumnFamilyStore ( table ) . forceBlockingFlush ( ) ; <nl> + } <nl> + <nl> + UntypedResultSet results ; <nl> + <nl> + / / CONTAINS <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Pav ' ; " , KS _ NAME , containsTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Pavel ' ; " , KS _ NAME , containsTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + try <nl> + { <nl> + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v = ' Pav ' ; " , KS _ NAME , containsTable ) ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + / / expected since CONTAINS indexes only support LIKE <nl> + } <nl> + <nl> + try <nl> + { <nl> + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Pav % % ' ; " , KS _ NAME , containsTable ) ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + / / expected since CONTAINS indexes only support LIKE ' % < term > ' and LIKE ' % < term > % ' <nl> + } <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Pav ' ; " , KS _ NAME , containsTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Pav % % ' ; " , KS _ NAME , containsTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + / / PREFIX <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v = ' Jean ' ; " , KS _ NAME , prefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v = ' Jean - Claude ' ; " , KS _ NAME , prefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jea ' ; " , KS _ NAME , prefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jea % % ' ; " , KS _ NAME , prefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + try <nl> + { <nl> + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Jea ' ; " , KS _ NAME , prefixTable ) ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + / / expected since PREFIX indexes only support LIKE ' < term > % ' <nl> + } <nl> + <nl> + try <nl> + { <nl> + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Jea % % ' ; " , KS _ NAME , prefixTable ) ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + / / expected since PREFIX indexes only support LIKE ' < term > % ' <nl> + } <nl> + <nl> + / / PREFIX + analyzer <nl> + <nl> + try <nl> + { <nl> + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v = ' Jean ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + / / expected since PREFIX indexes only support EQ without tokenization <nl> + } <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jean ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Claude ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jean - Claude ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jean % % ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Claude % % ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + Assert . assertNotNull ( results ) ; <nl> + Assert . assertEquals ( 1 , results . size ( ) ) ; <nl> + <nl> + try <nl> + { <nl> + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Jean ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + / / expected since PREFIX indexes only support LIKE ' < term > % ' and LIKE ' < term > ' <nl> + } <nl> + <nl> + try <nl> + { <nl> + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Claude % % ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + / / expected since PREFIX indexes only support LIKE ' < term > % ' and LIKE ' < term > ' <nl> + } <nl> + <nl> + for ( String table : Arrays . asList ( containsTable , prefixTable , analyzedPrefixTable ) ) <nl> + QueryProcessor . executeOnceInternal ( String . format ( " TRUNCATE TABLE % s . % s " , KS _ NAME , table ) ) ; <nl> + } <nl> + <nl> private static ColumnFamilyStore loadData ( Map < String , Pair < String , Integer > > data , boolean forceFlush ) <nl> { <nl> return loadData ( data , System . currentTimeMillis ( ) , forceFlush ) ; <nl> @ @ - 1860 , 7 + 2052 , 8 @ @ public class SASIIndexTest <nl> { <nl> try ( UnfilteredRowIterator row = rows . next ( ) ) <nl> { <nl> - add ( AsciiType . instance . compose ( row . partitionKey ( ) . getKey ( ) ) ) ; <nl> + if ( ! row . isEmpty ( ) ) <nl> + add ( AsciiType . instance . compose ( row . partitionKey ( ) . getKey ( ) ) ) ; <nl> } <nl> } <nl> } } ; <nl> diff - - git a / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java b / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java <nl> index 4f38b92 . . cf2b8c0 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java <nl> + + + b / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java <nl> @ @ - 181 , 21 + 181 , 21 @ @ public class OperationTest extends SchemaLoader <nl> <nl> / / comment = ' soft eng ' and comment ! = ' likes do ' <nl> ListMultimap < ColumnDefinition , Expression > e = Operation . analyzeGroup ( controller , OperationType . OR , <nl> - Arrays . asList ( new SimpleExpression ( comment , Operator . EQ , UTF8Type . instance . decompose ( " soft eng " ) ) , <nl> + Arrays . asList ( new SimpleExpression ( comment , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " soft eng " ) ) , <nl> new SimpleExpression ( comment , Operator . NEQ , UTF8Type . instance . decompose ( " likes do " ) ) ) ) ; <nl> <nl> List < Expression > expectedExpressions = new ArrayList < Expression > ( 2 ) <nl> { { <nl> add ( new Expression ( " comment " , UTF8Type . instance ) <nl> { { <nl> - operation = Op . EQ ; <nl> + operation = Op . MATCH ; <nl> lower = new Bound ( UTF8Type . instance . decompose ( " soft " ) , true ) ; <nl> upper = lower ; <nl> } } ) ; <nl> <nl> add ( new Expression ( " comment " , UTF8Type . instance ) <nl> { { <nl> - operation = Op . EQ ; <nl> + operation = Op . MATCH ; <nl> lower = new Bound ( UTF8Type . instance . decompose ( " eng " ) , true ) ; <nl> upper = lower ; <nl> } } ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7b277c5 . . 09c75f7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 19 , 6 + 19 , 7 @ @ <nl> * fix sstable2json large - row pagination ( CASSANDRA - 2188 ) <nl> * fix EOFing on requests for the last bytes in a file ( CASSANDRA - 2213 ) <nl> * fix BRAF performance when seeking to EOF ( CASSANDRA - 2218 ) <nl> + * check for memtable flush _ after _ mins exceeded every 10s ( CASSANDRA - 2183 ) <nl> <nl> <nl> 0 . 7 . 2 <nl> diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java <nl> index c046538 . . 6eb0b14 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Table . java <nl> + + + b / src / java / org / apache / cassandra / db / Table . java <nl> @ @ - 250 , 13 + 250 , 6 @ @ public class Table <nl> initCf ( cfm . cfId , cfm . cfName ) ; <nl> } <nl> <nl> - / / check 10x as often as the shortest lifetime , so we can exceed all lifetimes by 10 % at most <nl> - int minCheckMs = Integer . MAX _ VALUE ; <nl> - for ( ColumnFamilyStore cfs : columnFamilyStores . values ( ) ) <nl> - { <nl> - minCheckMs = Math . min ( minCheckMs , cfs . getMemtableFlushAfterMins ( ) * 60 * 1000 / 10 ) ; <nl> - } <nl> - <nl> Runnable runnable = new Runnable ( ) <nl> { <nl> public void run ( ) <nl> @ @ - 267 , 7 + 260 , 7 @ @ public class Table <nl> } <nl> } <nl> } ; <nl> - flushTask = StorageService . scheduledTasks . scheduleWithFixedDelay ( runnable , minCheckMs , minCheckMs , TimeUnit . MILLISECONDS ) ; <nl> + flushTask = StorageService . scheduledTasks . scheduleWithFixedDelay ( runnable , 10 , 10 , TimeUnit . SECONDS ) ; <nl> } <nl> <nl> public void createReplicationStrategy ( KSMetaData ksm ) throws ConfigurationException

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c09a453 . . 28651e2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 4 
 + * fix EQ semantics of analyzed SASI indexes ( CASSANDRA - 11130 ) 
 * Support long name output for nodetool commands ( CASSANDRA - 7950 ) 
 * Encrypted hints ( CASSANDRA - 11040 ) 
 * SASI index options validation ( CASSANDRA - 11136 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index d560119 . . 5cb479c 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 209 , 7 + 209 , 7 @ @ options { 
 } 
 else 
 { 
 - operator = Operator . EQ ; 
 + operator = Operator . LIKE _ MATCHES ; 
 endIndex + = 1 ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Operator . java b / src / java / org / apache / cassandra / cql3 / Operator . java 
 index d518961 . . accb786 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Operator . java 
 + + + b / src / java / org / apache / cassandra / cql3 / Operator . java 
 @ @ - 126 , 6 + 126 , 14 @ @ public enum Operator 
 { 
 return " LIKE ' % < term > % ' " ; 
 } 
 + } , 
 + LIKE _ MATCHES ( 13 ) 
 + { 
 + @ Override 
 + public String toString ( ) 
 + { 
 + return " LIKE ' < term > ' " ; 
 + } 
 } ; 
 
 / * * 
 @ @ - 222 , 6 + 230 , 7 @ @ public enum Operator 
 return ByteBufferUtil . startsWith ( leftOperand , rightOperand ) ; 
 case LIKE _ SUFFIX : 
 return ByteBufferUtil . endsWith ( leftOperand , rightOperand ) ; 
 + case LIKE _ MATCHES : 
 case LIKE _ CONTAINS : 
 return ByteBufferUtil . contains ( leftOperand , rightOperand ) ; 
 default : 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Relation . java b / src / java / org / apache / cassandra / cql3 / Relation . java 
 index 81f46a6 . . 616fd30 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Relation . java 
 + + + b / src / java / org / apache / cassandra / cql3 / Relation . java 
 @ @ - 112 , 7 + 112 , 8 @ @ public abstract class Relation { 
 { 
 return relationType = = Operator . LIKE _ PREFIX 
 | | relationType = = Operator . LIKE _ SUFFIX 
 - | | relationType = = Operator . LIKE _ CONTAINS ; 
 + | | relationType = = Operator . LIKE _ CONTAINS 
 + | | relationType = = Operator . LIKE _ MATCHES ; 
 } 
 
 / * * 
 @ @ - 153 , 6 + 154 , 7 @ @ public abstract class Relation { 
 case LIKE _ PREFIX : 
 case LIKE _ SUFFIX : 
 case LIKE _ CONTAINS : 
 + case LIKE _ MATCHES : 
 return newLikeRestriction ( cfm , boundNames , relationType ) ; 
 default : throw invalidRequest ( " Unsupported \ " ! = \ " relation : % s " , this ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / filter / RowFilter . java b / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 index 1141fd9 . . fcc3cd5 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 + + + b / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 @ @ - 604 , 6 + 604 , 7 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 case LIKE _ PREFIX : 
 case LIKE _ SUFFIX : 
 case LIKE _ CONTAINS : 
 + case LIKE _ MATCHES : 
 { 
 assert ! column . isComplex ( ) : " Only CONTAINS and CONTAINS _ KEY are supported for ' complex ' types " ; 
 ByteBuffer foundValue = getValue ( metadata , partitionKey , row ) ; 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / analyzer / AbstractAnalyzer . java b / src / java / org / apache / cassandra / index / sasi / analyzer / AbstractAnalyzer . java 
 index b3fdd8c . . 31c66cc 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / analyzer / AbstractAnalyzer . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / analyzer / AbstractAnalyzer . java 
 @ @ - 42 , 6 + 42 , 14 @ @ public abstract class AbstractAnalyzer implements Iterator < ByteBuffer > 
 
 public abstract void reset ( ByteBuffer input ) ; 
 
 + / * * 
 + * @ return true if current analyzer provides text tokenization , false otherwise . 
 + * / 
 + public boolean isTokenizing ( ) 
 + { 
 + return false ; 
 + } 
 + 
 public static String normalize ( String original ) 
 { 
 return Normalizer . isNormalized ( original , Normalizer . Form . NFC ) 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / analyzer / StandardAnalyzer . java b / src / java / org / apache / cassandra / index / sasi / analyzer / StandardAnalyzer . java 
 index bcc63df . . 5e09b9f 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / analyzer / StandardAnalyzer . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / analyzer / StandardAnalyzer . java 
 @ @ - 191 , 4 + 191 , 9 @ @ public class StandardAnalyzer extends AbstractAnalyzer 
 scanner . yyreset ( reader ) ; 
 this . inputReader = reader ; 
 } 
 + 
 + public boolean isTokenizing ( ) 
 + { 
 + return true ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 index 29e7c28 . . 1703bd4 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . index . sasi . conf . view . View ; 
 import org . apache . cassandra . index . sasi . disk . Token ; 
 import org . apache . cassandra . index . sasi . memory . IndexMemtable ; 
 import org . apache . cassandra . index . sasi . plan . Expression ; 
 + import org . apache . cassandra . index . sasi . plan . Expression . Op ; 
 import org . apache . cassandra . index . sasi . utils . RangeIterator ; 
 import org . apache . cassandra . io . sstable . Component ; 
 import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 @ @ - 58 , 6 + 59 , 8 @ @ public class ColumnIndex 
 private final Component component ; 
 private final DataTracker tracker ; 
 
 + private final boolean isTokenized ; 
 + 
 public ColumnIndex ( AbstractType < ? > keyValidator , ColumnDefinition column , IndexMetadata metadata ) 
 { 
 this . keyValidator = keyValidator ; 
 @ @ - 67 , 6 + 70 , 7 @ @ public class ColumnIndex 
 this . memtable = new AtomicReference < > ( new IndexMemtable ( this ) ) ; 
 this . tracker = new DataTracker ( keyValidator , this ) ; 
 this . component = new Component ( Component . Type . SECONDARY _ INDEX , String . format ( FILE _ NAME _ FORMAT , getIndexName ( ) ) ) ; 
 + this . isTokenized = getAnalyzer ( ) . isTokenizing ( ) ; 
 } 
 
 / * * 
 @ @ - 170 , 9 + 174 , 13 @ @ public class ColumnIndex 
 return isIndexed ( ) ? mode . isLiteral : ( validator instanceof UTF8Type | | validator instanceof AsciiType ) ; 
 } 
 
 - public boolean supports ( Operator operator ) 
 + public boolean supports ( Operator op ) 
 { 
 - return mode . supports ( Expression . Op . valueOf ( operator ) ) ; 
 + Op operator = Op . valueOf ( op ) ; 
 + return ! ( isTokenized & & operator = = Op . EQ ) / / EQ is only applicable to non - tokenized indexes 
 + & & ! ( isLiteral ( ) & & operator = = Op . RANGE ) / / RANGE only applicable to indexes non - literal indexes 
 + & & mode . supports ( operator ) ; / / for all other cases let ' s refer to index itself 
 + 
 } 
 
 public static ByteBuffer getValueOf ( ColumnDefinition column , Row row , int nowInSecs ) 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java b / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java 
 index b9c5653 . . 1c85ed5 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java 
 @ @ - 179 , 6 + 179 , 6 @ @ public class IndexMode 
 
 public boolean supports ( Op operator ) 
 { 
 - return ! ( isLiteral & & operator = = Op . RANGE ) & & mode . supports ( operator ) ; 
 + return mode . supports ( operator ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / disk / OnDiskIndexBuilder . java b / src / java / org / apache / cassandra / index / sasi / disk / OnDiskIndexBuilder . java 
 index 20a8739 . . 04b7b1c 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / disk / OnDiskIndexBuilder . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / disk / OnDiskIndexBuilder . java 
 @ @ - 50 , 8 + 50 , 8 @ @ public class OnDiskIndexBuilder 
 
 public enum Mode 
 { 
 - PREFIX ( EnumSet . of ( Op . EQ , Op . PREFIX , Op . NOT _ EQ , Op . RANGE ) ) , 
 - CONTAINS ( EnumSet . of ( Op . EQ , Op . CONTAINS , Op . SUFFIX , Op . NOT _ EQ ) ) , 
 + PREFIX ( EnumSet . of ( Op . EQ , Op . MATCH , Op . PREFIX , Op . NOT _ EQ , Op . RANGE ) ) , 
 + CONTAINS ( EnumSet . of ( Op . MATCH , Op . CONTAINS , Op . SUFFIX , Op . NOT _ EQ ) ) , 
 SPARSE ( EnumSet . of ( Op . EQ , Op . NOT _ EQ , Op . RANGE ) ) ; 
 
 Set < Op > supportedOps ; 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / memory / TrieMemIndex . java b / src / java / org / apache / cassandra / index / sasi / memory / TrieMemIndex . java 
 index 99a417a . . 0da65c7 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / memory / TrieMemIndex . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / memory / TrieMemIndex . java 
 @ @ - 182 , 6 + 182 , 7 @ @ public class TrieMemIndex extends MemIndex 
 switch ( operator ) 
 { 
 case EQ : 
 + case MATCH : 
 ConcurrentSkipListSet < DecoratedKey > keys = trie . getValueForExactKey ( value ) ; 
 return keys = = null ? Collections . emptyList ( ) : Collections . singletonList ( keys ) ; 
 
 @ @ - 219 , 6 + 220 , 7 @ @ public class TrieMemIndex extends MemIndex 
 switch ( operator ) 
 { 
 case EQ : 
 + case MATCH : 
 ConcurrentSkipListSet < DecoratedKey > keys = trie . getValueForExactKey ( value ) ; 
 return keys = = null ? Collections . emptyList ( ) : Collections . singletonList ( keys ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / plan / Expression . java b / src / java / org / apache / cassandra / index / sasi / plan / Expression . java 
 index 43f8251 . . 679d866 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / plan / Expression . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / plan / Expression . java 
 @ @ - 46 , 7 + 46 , 7 @ @ public class Expression 
 
 public enum Op 
 { 
 - EQ , PREFIX , SUFFIX , CONTAINS , NOT _ EQ , RANGE ; 
 + EQ , MATCH , PREFIX , SUFFIX , CONTAINS , NOT _ EQ , RANGE ; 
 
 public static Op valueOf ( Operator operator ) 
 { 
 @ @ - 73 , 6 + 73 , 9 @ @ public class Expression 
 case LIKE _ CONTAINS : 
 return CONTAINS ; 
 
 + case LIKE _ MATCHES : 
 + return MATCH ; 
 + 
 default : 
 throw new IllegalArgumentException ( " unknown operator : " + operator ) ; 
 } 
 @ @ - 140 , 6 + 143 , 7 @ @ public class Expression 
 case LIKE _ PREFIX : 
 case LIKE _ SUFFIX : 
 case LIKE _ CONTAINS : 
 + case LIKE _ MATCHES : 
 case EQ : 
 lower = new Bound ( value , true ) ; 
 upper = lower ; 
 @ @ - 262 , 6 + 266 , 7 @ @ public class Expression 
 switch ( operation ) 
 { 
 case EQ : 
 + case MATCH : 
 / / Operation . isSatisfiedBy handles conclusion on ! = , 
 / / here we just need to make sure that term matched it 
 case NOT _ EQ : 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / plan / Operation . java b / src / java / org / apache / cassandra / index / sasi / plan / Operation . java 
 index 28bcc51 . . f8b02a3 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / plan / Operation . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / plan / Operation . java 
 @ @ - 292 , 9 + 292 , 13 @ @ public class Operation extends RangeIterator < Long , Token > 
 switch ( e . operator ( ) ) 
 { 
 case EQ : 
 + isMultiExpression = false ; 
 + break ; 
 + 
 case LIKE _ PREFIX : 
 case LIKE _ SUFFIX : 
 case LIKE _ CONTAINS : 
 + case LIKE _ MATCHES : 
 isMultiExpression = true ; 
 break ; 
 
 @ @ - 341 , 6 + 345 , 7 @ @ public class Operation extends RangeIterator < Long , Token > 
 case LIKE _ PREFIX : 
 case LIKE _ SUFFIX : 
 case LIKE _ CONTAINS : 
 + case LIKE _ MATCHES : 
 return 4 ; 
 
 case GTE : 
 diff - - git a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 index 2ae1e70 . . a88e594 100644 
 - - - a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 + + + b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 @ @ - 167 , 7 + 167 , 7 @ @ public class SASIIndexTest 
 
 ColumnFamilyStore store = loadData ( data , forceFlush ) ; 
 
 - Set < String > rows = getIndexed ( store , 10 , buildExpression ( UTF8Type . instance . decompose ( " first _ name " ) , Operator . EQ , UTF8Type . instance . decompose ( " doesntmatter " ) ) ) ; 
 + Set < String > rows = getIndexed ( store , 10 , buildExpression ( UTF8Type . instance . decompose ( " first _ name " ) , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " doesntmatter " ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 } 
 
 @ @ - 502 , 18 + 502 , 18 @ @ public class SASIIndexTest 
 store = loadData ( part4 , forceFlush ) ; 
 
 rows = getIndexed ( store , 10 , 
 - buildExpression ( firstName , Operator . EQ , UTF8Type . instance . decompose ( " Susana " ) ) , 
 + buildExpression ( firstName , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " Susana " ) ) , 
 buildExpression ( age , Operator . LTE , Int32Type . instance . decompose ( 13 ) ) , 
 buildExpression ( age , Operator . GT , Int32Type . instance . decompose ( 10 ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key12 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 
 rows = getIndexed ( store , 10 , 
 - buildExpression ( firstName , Operator . EQ , UTF8Type . instance . decompose ( " Demario " ) ) , 
 + buildExpression ( firstName , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " Demario " ) ) , 
 buildExpression ( age , Operator . LTE , Int32Type . instance . decompose ( 30 ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , rows . size ( ) = = 0 ) ; 
 
 rows = getIndexed ( store , 10 , 
 - buildExpression ( firstName , Operator . EQ , UTF8Type . instance . decompose ( " Josephine " ) ) ) ; 
 + buildExpression ( firstName , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " Josephine " ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , rows . size ( ) = = 0 ) ; 
 
 rows = getIndexed ( store , 10 , 
 @ @ - 1142 , 7 + 1142 , 7 @ @ public class SASIIndexTest 
 rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ SUFFIX , UTF8Type . instance . decompose ( " ン " ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key4 " , " key5 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 
 - rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . EQ , UTF8Type . instance . decompose ( " レ ス ト ラ ン " ) ) ) ; 
 + rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " レ ス ト ラ ン " ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key4 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 } 
 
 @ @ - 1211 , 7 + 1211 , 7 @ @ public class SASIIndexTest 
 rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ SUFFIX , UTF8Type . instance . decompose ( " ン " ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key3 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 
 - rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . EQ , UTF8Type . instance . decompose ( " ベ ン ジ ャ ミ ン ウ エ ス ト " ) ) ) ; 
 + rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " ベ ン ジ ャ ミ ン ウ エ ス ト " ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key4 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 } 
 
 @ @ - 1235 , 12 + 1235 , 12 @ @ public class SASIIndexTest 
 
 Set < String > rows ; 
 
 - rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . EQ , bigValue . duplicate ( ) ) ) ; 
 + rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ MATCHES , bigValue . duplicate ( ) ) ) ; 
 Assert . assertEquals ( 0 , rows . size ( ) ) ; 
 
 store . forceBlockingFlush ( ) ; 
 
 - rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . EQ , bigValue . duplicate ( ) ) ) ; 
 + rows = getIndexed ( store , 10 , buildExpression ( comment , Operator . LIKE _ MATCHES , bigValue . duplicate ( ) ) ) ; 
 Assert . assertEquals ( 0 , rows . size ( ) ) ; 
 } 
 } 
 @ @ - 1471 , 6 + 1471 , 10 @ @ public class SASIIndexTest 
 update ( rm , name , UTF8Type . instance . decompose ( " Vijay " ) , System . currentTimeMillis ( ) ) ; 
 rm . apply ( ) ; 
 
 + rm = new Mutation ( KS _ NAME , decoratedKey ( " key8 " ) ) ; / / this name is going to be tokenized 
 + update ( rm , name , UTF8Type . instance . decompose ( " Jean - Claude " ) , System . currentTimeMillis ( ) ) ; 
 + rm . apply ( ) ; 
 + 
 / / this flush is going to produce range - ' jason ' - > ' vijay ' 
 store . forceBlockingFlush ( ) ; 
 
 @ @ - 1478 , 11 + 1482 , 12 @ @ public class SASIIndexTest 
 / / since simple interval tree lookup is not going to cover it , prefix lookup actually required . 
 
 Set < String > rows ; 
 + 
 rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ PREFIX , UTF8Type . instance . decompose ( " J " ) ) ) ; 
 - Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key5 " , " key6 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key5 " , " key6 " , " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 
 rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ PREFIX , UTF8Type . instance . decompose ( " j " ) ) ) ; 
 - Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key5 " , " key6 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key5 " , " key6 " , " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 
 rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ PREFIX , UTF8Type . instance . decompose ( " m " ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key3 " , " key4 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 @ @ - 1495 , 13 + 1500 , 28 @ @ public class SASIIndexTest 
 
 rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ PREFIX , UTF8Type . instance . decompose ( " j " ) ) , 
 buildExpression ( name , Operator . NEQ , UTF8Type . instance . decompose ( " joh " ) ) ) ; 
 - Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key6 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key2 " , " key6 " , " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 
 - rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " pavel " ) ) ) ; 
 + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " pavel " ) ) ) ; 
 Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key1 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 
 rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " Pave " ) ) ) ; 
 Assert . assertTrue ( rows . isEmpty ( ) ) ; 
 + 
 + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " Pavel " ) ) ) ; 
 + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key1 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 + 
 + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " JeAn " ) ) ) ; 
 + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 + 
 + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " claUde " ) ) ) ; 
 + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 + 
 + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " Jean " ) ) ) ; 
 + Assert . assertTrue ( rows . isEmpty ( ) ) ; 
 + 
 + rows = getIndexed ( store , 10 , buildExpression ( name , Operator . EQ , UTF8Type . instance . decompose ( " Jean - Claude " ) ) ) ; 
 + Assert . assertTrue ( rows . toString ( ) , Arrays . equals ( new String [ ] { " key8 " } , rows . toArray ( new String [ rows . size ( ) ] ) ) ) ; 
 } 
 
 @ Test 
 @ @ - 1746 , 6 + 1766 , 178 @ @ public class SASIIndexTest 
 } 
 } 
 
 + @ Test 
 + public void testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes ( ) 
 + { 
 + String containsTable = " sasi _ like _ contains _ test " ; 
 + String prefixTable = " sasi _ like _ prefix _ test " ; 
 + String analyzedPrefixTable = " sasi _ like _ analyzed _ prefix _ test " ; 
 + 
 + QueryProcessor . executeOnceInternal ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( k int primary key , v text ) ; " , KS _ NAME , containsTable ) ) ; 
 + QueryProcessor . executeOnceInternal ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( k int primary key , v text ) ; " , KS _ NAME , prefixTable ) ) ; 
 + QueryProcessor . executeOnceInternal ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( k int primary key , v text ) ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + 
 + QueryProcessor . executeOnceInternal ( String . format ( " CREATE CUSTOM INDEX IF NOT EXISTS ON % s . % s ( v ) " + 
 + " USING ' org . apache . cassandra . index . sasi . SASIIndex ' WITH OPTIONS = { ' mode ' : ' CONTAINS ' } ; " , KS _ NAME , containsTable ) ) ; 
 + QueryProcessor . executeOnceInternal ( String . format ( " CREATE CUSTOM INDEX IF NOT EXISTS ON % s . % s ( v ) " + 
 + " USING ' org . apache . cassandra . index . sasi . SASIIndex ' WITH OPTIONS = { ' mode ' : ' PREFIX ' } ; " , KS _ NAME , prefixTable ) ) ; 
 + QueryProcessor . executeOnceInternal ( String . format ( " CREATE CUSTOM INDEX IF NOT EXISTS ON % s . % s ( v ) " + 
 + " USING ' org . apache . cassandra . index . sasi . SASIIndex ' WITH OPTIONS = { ' mode ' : ' PREFIX ' , ' analyzed ' : ' true ' } ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + 
 + testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes ( containsTable , prefixTable , analyzedPrefixTable , false ) ; 
 + testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes ( containsTable , prefixTable , analyzedPrefixTable , true ) ; 
 + } 
 + 
 + private void testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes ( String containsTable , 
 + String prefixTable , 
 + String analyzedPrefixTable , 
 + boolean forceFlush ) 
 + { 
 + QueryProcessor . executeOnceInternal ( String . format ( " INSERT INTO % s . % s ( k , v ) VALUES ( ? , ? ) ; " , KS _ NAME , containsTable ) , 0 , " Pavel " ) ; 
 + QueryProcessor . executeOnceInternal ( String . format ( " INSERT INTO % s . % s ( k , v ) VALUES ( ? , ? ) ; " , KS _ NAME , prefixTable ) , 0 , " Jean - Claude " ) ; 
 + QueryProcessor . executeOnceInternal ( String . format ( " INSERT INTO % s . % s ( k , v ) VALUES ( ? , ? ) ; " , KS _ NAME , analyzedPrefixTable ) , 0 , " Jean - Claude " ) ; 
 + 
 + if ( forceFlush ) 
 + { 
 + Keyspace keyspace = Keyspace . open ( KS _ NAME ) ; 
 + for ( String table : Arrays . asList ( containsTable , prefixTable , analyzedPrefixTable ) ) 
 + keyspace . getColumnFamilyStore ( table ) . forceBlockingFlush ( ) ; 
 + } 
 + 
 + UntypedResultSet results ; 
 + 
 + / / CONTAINS 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Pav ' ; " , KS _ NAME , containsTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Pavel ' ; " , KS _ NAME , containsTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + try 
 + { 
 + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v = ' Pav ' ; " , KS _ NAME , containsTable ) ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + / / expected since CONTAINS indexes only support LIKE 
 + } 
 + 
 + try 
 + { 
 + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Pav % % ' ; " , KS _ NAME , containsTable ) ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + / / expected since CONTAINS indexes only support LIKE ' % < term > ' and LIKE ' % < term > % ' 
 + } 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Pav ' ; " , KS _ NAME , containsTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Pav % % ' ; " , KS _ NAME , containsTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + / / PREFIX 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v = ' Jean ' ; " , KS _ NAME , prefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v = ' Jean - Claude ' ; " , KS _ NAME , prefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jea ' ; " , KS _ NAME , prefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jea % % ' ; " , KS _ NAME , prefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + try 
 + { 
 + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Jea ' ; " , KS _ NAME , prefixTable ) ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + / / expected since PREFIX indexes only support LIKE ' < term > % ' 
 + } 
 + 
 + try 
 + { 
 + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Jea % % ' ; " , KS _ NAME , prefixTable ) ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + / / expected since PREFIX indexes only support LIKE ' < term > % ' 
 + } 
 + 
 + / / PREFIX + analyzer 
 + 
 + try 
 + { 
 + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v = ' Jean ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + / / expected since PREFIX indexes only support EQ without tokenization 
 + } 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jean ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Claude ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jean - Claude ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Jean % % ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + results = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' Claude % % ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + Assert . assertNotNull ( results ) ; 
 + Assert . assertEquals ( 1 , results . size ( ) ) ; 
 + 
 + try 
 + { 
 + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Jean ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + / / expected since PREFIX indexes only support LIKE ' < term > % ' and LIKE ' < term > ' 
 + } 
 + 
 + try 
 + { 
 + QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s WHERE v LIKE ' % % Claude % % ' ; " , KS _ NAME , analyzedPrefixTable ) ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + / / expected since PREFIX indexes only support LIKE ' < term > % ' and LIKE ' < term > ' 
 + } 
 + 
 + for ( String table : Arrays . asList ( containsTable , prefixTable , analyzedPrefixTable ) ) 
 + QueryProcessor . executeOnceInternal ( String . format ( " TRUNCATE TABLE % s . % s " , KS _ NAME , table ) ) ; 
 + } 
 + 
 private static ColumnFamilyStore loadData ( Map < String , Pair < String , Integer > > data , boolean forceFlush ) 
 { 
 return loadData ( data , System . currentTimeMillis ( ) , forceFlush ) ; 
 @ @ - 1860 , 7 + 2052 , 8 @ @ public class SASIIndexTest 
 { 
 try ( UnfilteredRowIterator row = rows . next ( ) ) 
 { 
 - add ( AsciiType . instance . compose ( row . partitionKey ( ) . getKey ( ) ) ) ; 
 + if ( ! row . isEmpty ( ) ) 
 + add ( AsciiType . instance . compose ( row . partitionKey ( ) . getKey ( ) ) ) ; 
 } 
 } 
 } } ; 
 diff - - git a / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java b / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java 
 index 4f38b92 . . cf2b8c0 100644 
 - - - a / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java 
 + + + b / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java 
 @ @ - 181 , 21 + 181 , 21 @ @ public class OperationTest extends SchemaLoader 
 
 / / comment = ' soft eng ' and comment ! = ' likes do ' 
 ListMultimap < ColumnDefinition , Expression > e = Operation . analyzeGroup ( controller , OperationType . OR , 
 - Arrays . asList ( new SimpleExpression ( comment , Operator . EQ , UTF8Type . instance . decompose ( " soft eng " ) ) , 
 + Arrays . asList ( new SimpleExpression ( comment , Operator . LIKE _ MATCHES , UTF8Type . instance . decompose ( " soft eng " ) ) , 
 new SimpleExpression ( comment , Operator . NEQ , UTF8Type . instance . decompose ( " likes do " ) ) ) ) ; 
 
 List < Expression > expectedExpressions = new ArrayList < Expression > ( 2 ) 
 { { 
 add ( new Expression ( " comment " , UTF8Type . instance ) 
 { { 
 - operation = Op . EQ ; 
 + operation = Op . MATCH ; 
 lower = new Bound ( UTF8Type . instance . decompose ( " soft " ) , true ) ; 
 upper = lower ; 
 } } ) ; 
 
 add ( new Expression ( " comment " , UTF8Type . instance ) 
 { { 
 - operation = Op . EQ ; 
 + operation = Op . MATCH ; 
 lower = new Bound ( UTF8Type . instance . decompose ( " eng " ) , true ) ; 
 upper = lower ; 
 } } ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7b277c5 . . 09c75f7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 19 , 6 + 19 , 7 @ @ 
 * fix sstable2json large - row pagination ( CASSANDRA - 2188 ) 
 * fix EOFing on requests for the last bytes in a file ( CASSANDRA - 2213 ) 
 * fix BRAF performance when seeking to EOF ( CASSANDRA - 2218 ) 
 + * check for memtable flush _ after _ mins exceeded every 10s ( CASSANDRA - 2183 ) 
 
 
 0 . 7 . 2 
 diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java 
 index c046538 . . 6eb0b14 100644 
 - - - a / src / java / org / apache / cassandra / db / Table . java 
 + + + b / src / java / org / apache / cassandra / db / Table . java 
 @ @ - 250 , 13 + 250 , 6 @ @ public class Table 
 initCf ( cfm . cfId , cfm . cfName ) ; 
 } 
 
 - / / check 10x as often as the shortest lifetime , so we can exceed all lifetimes by 10 % at most 
 - int minCheckMs = Integer . MAX _ VALUE ; 
 - for ( ColumnFamilyStore cfs : columnFamilyStores . values ( ) ) 
 - { 
 - minCheckMs = Math . min ( minCheckMs , cfs . getMemtableFlushAfterMins ( ) * 60 * 1000 / 10 ) ; 
 - } 
 - 
 Runnable runnable = new Runnable ( ) 
 { 
 public void run ( ) 
 @ @ - 267 , 7 + 260 , 7 @ @ public class Table 
 } 
 } 
 } ; 
 - flushTask = StorageService . scheduledTasks . scheduleWithFixedDelay ( runnable , minCheckMs , minCheckMs , TimeUnit . MILLISECONDS ) ; 
 + flushTask = StorageService . scheduledTasks . scheduleWithFixedDelay ( runnable , 10 , 10 , TimeUnit . SECONDS ) ; 
 } 
 
 public void createReplicationStrategy ( KSMetaData ksm ) throws ConfigurationException
