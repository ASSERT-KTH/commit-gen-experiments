BLEU SCORE: 0.044568827606990644

TEST MSG: Add broadcast _ rpc _ address option to cassandra . yaml
GENERATED MSG: add jmx listener to publish metrics for cassandra - 5838

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 98fc33c . . 709b05a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 0 - beta2 <nl> + * Add broadcast _ rpc _ address option to cassandra . yaml ( CASSANDRA - 5899 ) <nl> * Auto reload GossipingPropertyFileSnitch config ( CASSANDRA - 5897 ) <nl> * Fix overflow of memtable _ total _ space _ in _ mb ( CASSANDRA - 6573 ) <nl> * Fix ABTC NPE ( CASSANDRA - 6692 ) <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 98cbb2a . . 477594f 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 373 , 18 + 373 , 23 @ @ native _ transport _ port : 9042 <nl> start _ rpc : true <nl> <nl> # The address to bind the Thrift RPC service and native transport <nl> - # server - - clients connect here . <nl> + # server to . <nl> # <nl> - # Leaving this blank has the same effect it does for ListenAddress , <nl> + # Leaving this blank has the same effect as on listen _ address <nl> # ( i . e . it will be based on the configured hostname of the node ) . <nl> # <nl> - # Note that unlike ListenAddress above , it is allowed to specify 0 . 0 . 0 . 0 <nl> - # here if you want to listen on all interfaces , but that will break clients <nl> - # that rely on node auto - discovery . <nl> + # Note that unlike listen _ address , you can specify 0 . 0 . 0 . 0 , but you must also <nl> + # set broadcast _ rpc _ address to a value other than 0 . 0 . 0 . 0 . <nl> rpc _ address : localhost <nl> # port for Thrift to listen for clients on <nl> rpc _ port : 9160 <nl> <nl> + # RPC address to broadcast to drivers and other Cassandra nodes . This cannot <nl> + # be set to 0 . 0 . 0 . 0 . If left blank , this will be set to the value of <nl> + # rpc _ address . If rpc _ address is set to 0 . 0 . 0 . 0 , broadcast _ rpc _ address must <nl> + # be set . <nl> + # broadcast _ rpc _ address : 1 . 2 . 3 . 4 <nl> + <nl> # enable or disable keepalive on rpc connections <nl> rpc _ keepalive : true <nl> <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index a9b9237 . . c5d35a3 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 104 , 6 + 104 , 7 @ @ public class Config <nl> <nl> public Boolean start _ rpc = true ; <nl> public String rpc _ address ; <nl> + public String broadcast _ rpc _ address ; <nl> public Integer rpc _ port = 9160 ; <nl> public Integer rpc _ listen _ backlog = 50 ; <nl> public String rpc _ server _ type = " sync " ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 930bbcc . . 25b05ff 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 68 , 6 + 68 , 7 @ @ public class DatabaseDescriptor <nl> private static InetAddress listenAddress ; / / leave null so we can fall through to getLocalHost <nl> private static InetAddress broadcastAddress ; <nl> private static InetAddress rpcAddress ; <nl> + private static InetAddress broadcastRpcAddress ; <nl> private static SeedProvider seedProvider ; <nl> private static IInternodeAuthenticator internodeAuthenticator ; <nl> <nl> @ @ - 325 , 6 + 326 , 39 @ @ public class DatabaseDescriptor <nl> rpcAddress = FBUtilities . getLocalAddress ( ) ; <nl> } <nl> <nl> + / * RPC address to broadcast * / <nl> + if ( conf . broadcast _ rpc _ address ! = null ) <nl> + { <nl> + if ( conf . broadcast _ rpc _ address . equals ( " 0 . 0 . 0 . 0 " ) ) <nl> + throw new ConfigurationException ( " broadcast _ rpc _ address cannot be 0 . 0 . 0 . 0 " ) ; <nl> + <nl> + try <nl> + { <nl> + broadcastRpcAddress = InetAddress . getByName ( conf . broadcast _ rpc _ address ) ; <nl> + } <nl> + catch ( UnknownHostException e ) <nl> + { <nl> + throw new ConfigurationException ( " Unkown broadcast _ rpc _ address ' " + conf . broadcast _ rpc _ address + " ' " ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + InetAddress bindAll ; <nl> + try <nl> + { <nl> + bindAll = InetAddress . getByAddress ( new byte [ 4 ] ) ; <nl> + } <nl> + catch ( UnknownHostException e ) <nl> + { <nl> + throw new RuntimeException ( " Host 0 . 0 . 0 . 0 is somehow unknown " ) ; <nl> + } <nl> + <nl> + if ( rpcAddress . equals ( bindAll ) ) <nl> + throw new ConfigurationException ( " If rpc _ address is set to 0 . 0 . 0 . 0 , you must set broadcast _ rpc _ address " + <nl> + " to a value other than 0 . 0 . 0 . 0 " ) ; <nl> + broadcastRpcAddress = rpcAddress ; <nl> + } <nl> + <nl> if ( conf . thrift _ framed _ transport _ size _ in _ mb < = 0 ) <nl> throw new ConfigurationException ( " thrift _ framed _ transport _ size _ in _ mb must be positive " ) ; <nl> <nl> @ @ - 1026 , 6 + 1060 , 16 @ @ public class DatabaseDescriptor <nl> return rpcAddress ; <nl> } <nl> <nl> + public static void setBroadcastRpcAddress ( InetAddress broadcastRPCAddr ) <nl> + { <nl> + broadcastRpcAddress = broadcastRPCAddr ; <nl> + } <nl> + <nl> + public static InetAddress getBroadcastRpcAddress ( ) <nl> + { <nl> + return broadcastRpcAddress ; <nl> + } <nl> + <nl> public static String getRpcServerType ( ) <nl> { <nl> return conf . rpc _ server _ type ; <nl> @ @ - 1071 , 11 + 1115 , 6 @ @ public class DatabaseDescriptor <nl> return conf . start _ native _ transport ; <nl> } <nl> <nl> - public static InetAddress getNativeTransportAddress ( ) <nl> - { <nl> - return getRpcAddress ( ) ; <nl> - } <nl> - <nl> public static int getNativeTransportPort ( ) <nl> { <nl> return Integer . parseInt ( System . getProperty ( " cassandra . native _ transport _ port " , conf . native _ transport _ port . toString ( ) ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / locator / Ec2MultiRegionSnitch . java b / src / java / org / apache / cassandra / locator / Ec2MultiRegionSnitch . java <nl> index 7dc2fa9 . . 511cbb5 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / Ec2MultiRegionSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / Ec2MultiRegionSnitch . java <nl> @ @ - 52 , 6 + 52 , 7 @ @ public class Ec2MultiRegionSnitch extends Ec2Snitch <nl> localPrivateAddress = awsApiCall ( PRIVATE _ IP _ QUERY _ URL ) ; <nl> / / use the Public IP to broadcast Address to other nodes . <nl> DatabaseDescriptor . setBroadcastAddress ( localPublicAddress ) ; <nl> + DatabaseDescriptor . setBroadcastRpcAddress ( localPublicAddress ) ; <nl> } <nl> <nl> public void gossiperStarting ( ) <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index 50bbe02 . . 7c56fb7 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 360 , 7 + 360 , 7 @ @ public class CassandraDaemon <nl> thriftServer = new ThriftServer ( rpcAddr , rpcPort , listenBacklog ) ; <nl> <nl> / / Native transport <nl> - InetAddress nativeAddr = DatabaseDescriptor . getNativeTransportAddress ( ) ; <nl> + InetAddress nativeAddr = DatabaseDescriptor . getRpcAddress ( ) ; <nl> int nativePort = DatabaseDescriptor . getNativeTransportPort ( ) ; <nl> nativeServer = new org . apache . cassandra . transport . Server ( nativeAddr , nativePort ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 132e674 . . d1db703 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 637 , 7 + 637 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> getTokenMetadata ( ) . updateHostId ( SystemKeyspace . getLocalHostId ( ) , FBUtilities . getBroadcastAddress ( ) ) ; <nl> appStates . put ( ApplicationState . NET _ VERSION , valueFactory . networkVersion ( ) ) ; <nl> appStates . put ( ApplicationState . HOST _ ID , valueFactory . hostId ( SystemKeyspace . getLocalHostId ( ) ) ) ; <nl> - appStates . put ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getRpcAddress ( ) ) ) ; <nl> + appStates . put ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getBroadcastRpcAddress ( ) ) ) ; <nl> appStates . put ( ApplicationState . RELEASE _ VERSION , valueFactory . releaseVersion ( ) ) ; <nl> logger . info ( " Starting up server gossip " ) ; <nl> Gossiper . instance . register ( this ) ; <nl> @ @ - 1049 , 7 + 1049 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> public String getRpcaddress ( InetAddress endpoint ) <nl> { <nl> if ( endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> - return DatabaseDescriptor . getRpcAddress ( ) . getHostAddress ( ) ; <nl> + return DatabaseDescriptor . getBroadcastRpcAddress ( ) . getHostAddress ( ) ; <nl> else if ( Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( ApplicationState . RPC _ ADDRESS ) = = null ) <nl> return endpoint . getHostAddress ( ) ; <nl> else <nl> diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java <nl> index 4f46614 . . 801a3e5 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Server . java <nl> + + + b / src / java / org / apache / cassandra / transport / Server . java <nl> @ @ - 331 , 6 + 331 , 8 @ @ public class Server implements CassandraDaemon . Server <nl> InetAddress rpcAddress = InetAddress . getByName ( StorageService . instance . getRpcaddress ( endpoint ) ) ; <nl> / / If rpcAddress = = 0 . 0 . 0 . 0 ( i . e . bound on all addresses ) , returning that is not very helpful , <nl> / / so return the internal address ( which is ok since " we ' re bound on all addresses " ) . <nl> + / / Note that after all nodes are running a version that includes CASSANDRA - 5899 , rpcAddress should <nl> + / / never be 0 . 0 . 0 . 0 , so this can eventually be removed . <nl> return rpcAddress . equals ( bindAll ) ? endpoint : rpcAddress ; <nl> } <nl> catch ( UnknownHostException e )
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f7e439c . . 805dca2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 3 , 7 + 3 , 7 @ @ <nl> * Log Merkle tree stats ( CASSANDRA - 2698 ) <nl> * Switch from crc32 to adler32 for compressed sstable checksums ( CASSANDRA - 5862 ) <nl> * Improve offheap memcpy performance ( CASSANDRA - 5884 ) <nl> - <nl> + * Use a range aware scanner for cleanup ( CASSANDRA - 2524 ) <nl> <nl> 2 . 0 . 0 - rc2 <nl> * enable vnodes by default ( CASSANDRA - 5869 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 7b11672 . . 2adda32 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1459 , 6 + 1459 , 18 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> return columns ; <nl> } <nl> <nl> + public void cleanupCache ( ) <nl> + { <nl> + Collection < Range < Token > > ranges = StorageService . instance . getLocalRanges ( keyspace . getName ( ) ) ; <nl> + <nl> + for ( RowCacheKey key : CacheService . instance . rowCache . getKeySet ( ) ) <nl> + { <nl> + DecoratedKey dk = StorageService . getPartitioner ( ) . decorateKey ( ByteBuffer . wrap ( key . key ) ) ; <nl> + if ( key . cfId = = metadata . cfId & & ! Range . isInRanges ( dk . token , ranges ) ) <nl> + invalidateCachedRow ( dk ) ; <nl> + } <nl> + } <nl> + <nl> public static abstract class AbstractScanIterator extends AbstractIterator < Row > implements CloseableIterator < Row > <nl> { <nl> public boolean needsFiltering ( ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index 35354c8 . . ed6770f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 97 , 6 + 97 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> <nl> private final CompactionExecutor executor = new CompactionExecutor ( ) ; <nl> private final CompactionExecutor validationExecutor = new ValidationExecutor ( ) ; <nl> + private final static CompactionExecutor cacheCleanupExecutor = new CacheCleanupExecutor ( ) ; <nl> + <nl> private final CompactionMetrics metrics = new CompactionMetrics ( executor , validationExecutor ) ; <nl> private final Multiset < ColumnFamilyStore > compactingCF = ConcurrentHashMultiset . create ( ) ; <nl> <nl> @ @ - 461 , 7 + 463 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> * <nl> * @ throws IOException <nl> * / <nl> - private void doCleanupCompaction ( ColumnFamilyStore cfs , Collection < SSTableReader > sstables , CounterId . OneShotRenewer renewer ) throws IOException <nl> + private void doCleanupCompaction ( final ColumnFamilyStore cfs , Collection < SSTableReader > sstables , CounterId . OneShotRenewer renewer ) throws IOException <nl> { <nl> assert ! cfs . isIndex ( ) ; <nl> Keyspace keyspace = cfs . keyspace ; <nl> @ @ - 472 , 8 + 474 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return ; <nl> } <nl> <nl> - boolean isCommutative = cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ; <nl> boolean hasIndexes = ! cfs . indexManager . getIndexes ( ) . isEmpty ( ) ; <nl> + CleanupStrategy cleanupStrategy = CleanupStrategy . get ( cfs , ranges , renewer ) ; <nl> <nl> for ( SSTableReader sstable : sstables ) <nl> { <nl> @ @ - 500 , 10 + 502 , 9 @ @ public class CompactionManager implements CompactionManagerMBean <nl> if ( compactionFileLocation = = null ) <nl> throw new IOException ( " disk full " ) ; <nl> <nl> - SSTableScanner scanner = sstable . getScanner ( getRateLimiter ( ) ) ; <nl> - List < Column > indexedColumnsInRow = null ; <nl> + ICompactionScanner scanner = cleanupStrategy . getScanner ( sstable , getRateLimiter ( ) ) ; <nl> + CleanupInfo ci = new CleanupInfo ( sstable , ( SSTableScanner ) scanner ) ; <nl> <nl> - CleanupInfo ci = new CleanupInfo ( sstable , scanner ) ; <nl> metrics . beginCompaction ( ci ) ; <nl> SSTableWriter writer = createWriter ( cfs , <nl> compactionFileLocation , <nl> @ @ - 517 , 50 + 518 , 13 @ @ public class CompactionManager implements CompactionManagerMBean <nl> if ( ci . isStopRequested ( ) ) <nl> throw new CompactionInterruptedException ( ci . getCompactionInfo ( ) ) ; <nl> SSTableIdentityIterator row = ( SSTableIdentityIterator ) scanner . next ( ) ; <nl> - if ( Range . isInRanges ( row . getKey ( ) . token , ranges ) ) <nl> - { <nl> - AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; <nl> - if ( writer . append ( compactedRow ) ! = null ) <nl> - totalkeysWritten + + ; <nl> - } <nl> - else <nl> - { <nl> - cfs . invalidateCachedRow ( row . getKey ( ) ) ; <nl> - <nl> - if ( hasIndexes | | isCommutative ) <nl> - { <nl> - if ( indexedColumnsInRow ! = null ) <nl> - indexedColumnsInRow . clear ( ) ; <nl> - <nl> - while ( row . hasNext ( ) ) <nl> - { <nl> - OnDiskAtom column = row . next ( ) ; <nl> - if ( column instanceof CounterColumn ) <nl> - renewer . maybeRenew ( ( CounterColumn ) column ) ; <nl> - if ( column instanceof Column & & cfs . indexManager . indexes ( ( Column ) column ) ) <nl> - { <nl> - if ( indexedColumnsInRow = = null ) <nl> - indexedColumnsInRow = new ArrayList < Column > ( ) ; <nl> - <nl> - indexedColumnsInRow . add ( ( Column ) column ) ; <nl> - } <nl> - } <nl> - <nl> - if ( indexedColumnsInRow ! = null & & ! indexedColumnsInRow . isEmpty ( ) ) <nl> - { <nl> - / / acquire memtable lock here because secondary index deletion may cause a race . See CASSANDRA - 3712 <nl> - Keyspace . switchLock . readLock ( ) . lock ( ) ; <nl> - try <nl> - { <nl> - cfs . indexManager . deleteFromIndexes ( row . getKey ( ) , indexedColumnsInRow ) ; <nl> - } <nl> - finally <nl> - { <nl> - Keyspace . switchLock . readLock ( ) . unlock ( ) ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> + <nl> + row = cleanupStrategy . cleanup ( row ) ; <nl> + if ( row = = null ) <nl> + continue ; <nl> + AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; <nl> + if ( writer . append ( compactedRow ) ! = null ) <nl> + totalkeysWritten + + ; <nl> } <nl> if ( totalkeysWritten > 0 ) <nl> newSstable = writer . closeAndOpenReader ( sstable . maxDataAge ) ; <nl> @ @ - 599 , 6 + 563 , 114 @ @ public class CompactionManager implements CompactionManagerMBean <nl> } <nl> } <nl> <nl> + private static abstract class CleanupStrategy <nl> + { <nl> + public static CleanupStrategy get ( ColumnFamilyStore cfs , Collection < Range < Token > > ranges , CounterId . OneShotRenewer renewer ) <nl> + { <nl> + if ( ! cfs . indexManager . getIndexes ( ) . isEmpty ( ) | | cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ) <nl> + return new Full ( cfs , ranges , renewer ) ; <nl> + <nl> + return new Bounded ( cfs , ranges ) ; <nl> + } <nl> + <nl> + public abstract ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) ; <nl> + public abstract SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) ; <nl> + <nl> + private static final class Bounded extends CleanupStrategy <nl> + { <nl> + private final Collection < Range < Token > > ranges ; <nl> + <nl> + public Bounded ( final ColumnFamilyStore cfs , Collection < Range < Token > > ranges ) <nl> + { <nl> + this . ranges = ranges ; <nl> + cacheCleanupExecutor . submit ( new Runnable ( ) <nl> + { <nl> + @ Override <nl> + public void run ( ) <nl> + { <nl> + cfs . cleanupCache ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + } <nl> + @ Override <nl> + public ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) <nl> + { <nl> + return sstable . getScanner ( ranges , limiter ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) <nl> + { <nl> + return row ; <nl> + } <nl> + } <nl> + <nl> + private static final class Full extends CleanupStrategy <nl> + { <nl> + private final Collection < Range < Token > > ranges ; <nl> + private final ColumnFamilyStore cfs ; <nl> + private List < Column > indexedColumnsInRow ; <nl> + private final CounterId . OneShotRenewer renewer ; <nl> + <nl> + public Full ( ColumnFamilyStore cfs , Collection < Range < Token > > ranges , CounterId . OneShotRenewer renewer ) <nl> + { <nl> + this . cfs = cfs ; <nl> + this . ranges = ranges ; <nl> + this . indexedColumnsInRow = null ; <nl> + this . renewer = renewer ; <nl> + } <nl> + <nl> + @ Override <nl> + public ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) <nl> + { <nl> + return sstable . getScanner ( limiter ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) <nl> + { <nl> + if ( Range . isInRanges ( row . getKey ( ) . token , ranges ) ) <nl> + return row ; <nl> + <nl> + cfs . invalidateCachedRow ( row . getKey ( ) ) ; <nl> + <nl> + if ( indexedColumnsInRow ! = null ) <nl> + indexedColumnsInRow . clear ( ) ; <nl> + <nl> + while ( row . hasNext ( ) ) <nl> + { <nl> + OnDiskAtom column = row . next ( ) ; <nl> + if ( column instanceof CounterColumn ) <nl> + renewer . maybeRenew ( ( CounterColumn ) column ) ; <nl> + <nl> + if ( column instanceof Column & & cfs . indexManager . indexes ( ( Column ) column ) ) <nl> + { <nl> + if ( indexedColumnsInRow = = null ) <nl> + indexedColumnsInRow = new ArrayList < > ( ) ; <nl> + <nl> + indexedColumnsInRow . add ( ( Column ) column ) ; <nl> + } <nl> + } <nl> + <nl> + if ( indexedColumnsInRow ! = null & & ! indexedColumnsInRow . isEmpty ( ) ) <nl> + { <nl> + / / acquire memtable lock here because secondary index deletion may cause a race . See CASSANDRA - 3712 <nl> + Keyspace . switchLock . readLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + cfs . indexManager . deleteFromIndexes ( row . getKey ( ) , indexedColumnsInRow ) ; <nl> + } <nl> + finally <nl> + { <nl> + Keyspace . switchLock . readLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> + return null ; <nl> + } <nl> + } <nl> + } <nl> + <nl> public static SSTableWriter createWriter ( ColumnFamilyStore cfs , <nl> File compactionFileLocation , <nl> int expectedBloomFilterSize , <nl> @ @ - 847 , 6 + 919 , 14 @ @ public class CompactionManager implements CompactionManagerMBean <nl> } <nl> } <nl> <nl> + private static class CacheCleanupExecutor extends CompactionExecutor <nl> + { <nl> + public CacheCleanupExecutor ( ) <nl> + { <nl> + super ( 1 , " CacheCleanupExecutor " ) ; <nl> + } <nl> + } <nl> + <nl> public interface CompactionExecutorStatsCollector <nl> { <nl> void beginCompaction ( CompactionInfo . Holder ci ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index 4a62d85 . . bbca089 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 1081 , 11 + 1081 , 23 @ @ public class SSTableReader extends SSTable <nl> { <nl> if ( range = = null ) <nl> return getScanner ( limiter ) ; <nl> + return getScanner ( Collections . singletonList ( range ) , limiter ) ; <nl> + } <nl> <nl> + / * * <nl> + * Direct I / O SSTableScanner over a defined collection of ranges of tokens . <nl> + * <nl> + * @ param ranges the range of keys to cover <nl> + * @ return A Scanner for seeking over the rows of the SSTable . <nl> + * / <nl> + public ICompactionScanner getScanner ( Collection < Range < Token > > ranges , RateLimiter limiter ) <nl> + { <nl> / / We want to avoid allocating a SSTableScanner if the range don ' t overlap the sstable

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 98fc33c . . 709b05a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 0 - beta2 
 + * Add broadcast _ rpc _ address option to cassandra . yaml ( CASSANDRA - 5899 ) 
 * Auto reload GossipingPropertyFileSnitch config ( CASSANDRA - 5897 ) 
 * Fix overflow of memtable _ total _ space _ in _ mb ( CASSANDRA - 6573 ) 
 * Fix ABTC NPE ( CASSANDRA - 6692 ) 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 98cbb2a . . 477594f 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 373 , 18 + 373 , 23 @ @ native _ transport _ port : 9042 
 start _ rpc : true 
 
 # The address to bind the Thrift RPC service and native transport 
 - # server - - clients connect here . 
 + # server to . 
 # 
 - # Leaving this blank has the same effect it does for ListenAddress , 
 + # Leaving this blank has the same effect as on listen _ address 
 # ( i . e . it will be based on the configured hostname of the node ) . 
 # 
 - # Note that unlike ListenAddress above , it is allowed to specify 0 . 0 . 0 . 0 
 - # here if you want to listen on all interfaces , but that will break clients 
 - # that rely on node auto - discovery . 
 + # Note that unlike listen _ address , you can specify 0 . 0 . 0 . 0 , but you must also 
 + # set broadcast _ rpc _ address to a value other than 0 . 0 . 0 . 0 . 
 rpc _ address : localhost 
 # port for Thrift to listen for clients on 
 rpc _ port : 9160 
 
 + # RPC address to broadcast to drivers and other Cassandra nodes . This cannot 
 + # be set to 0 . 0 . 0 . 0 . If left blank , this will be set to the value of 
 + # rpc _ address . If rpc _ address is set to 0 . 0 . 0 . 0 , broadcast _ rpc _ address must 
 + # be set . 
 + # broadcast _ rpc _ address : 1 . 2 . 3 . 4 
 + 
 # enable or disable keepalive on rpc connections 
 rpc _ keepalive : true 
 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index a9b9237 . . c5d35a3 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 104 , 6 + 104 , 7 @ @ public class Config 
 
 public Boolean start _ rpc = true ; 
 public String rpc _ address ; 
 + public String broadcast _ rpc _ address ; 
 public Integer rpc _ port = 9160 ; 
 public Integer rpc _ listen _ backlog = 50 ; 
 public String rpc _ server _ type = " sync " ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 930bbcc . . 25b05ff 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 68 , 6 + 68 , 7 @ @ public class DatabaseDescriptor 
 private static InetAddress listenAddress ; / / leave null so we can fall through to getLocalHost 
 private static InetAddress broadcastAddress ; 
 private static InetAddress rpcAddress ; 
 + private static InetAddress broadcastRpcAddress ; 
 private static SeedProvider seedProvider ; 
 private static IInternodeAuthenticator internodeAuthenticator ; 
 
 @ @ - 325 , 6 + 326 , 39 @ @ public class DatabaseDescriptor 
 rpcAddress = FBUtilities . getLocalAddress ( ) ; 
 } 
 
 + / * RPC address to broadcast * / 
 + if ( conf . broadcast _ rpc _ address ! = null ) 
 + { 
 + if ( conf . broadcast _ rpc _ address . equals ( " 0 . 0 . 0 . 0 " ) ) 
 + throw new ConfigurationException ( " broadcast _ rpc _ address cannot be 0 . 0 . 0 . 0 " ) ; 
 + 
 + try 
 + { 
 + broadcastRpcAddress = InetAddress . getByName ( conf . broadcast _ rpc _ address ) ; 
 + } 
 + catch ( UnknownHostException e ) 
 + { 
 + throw new ConfigurationException ( " Unkown broadcast _ rpc _ address ' " + conf . broadcast _ rpc _ address + " ' " ) ; 
 + } 
 + } 
 + else 
 + { 
 + InetAddress bindAll ; 
 + try 
 + { 
 + bindAll = InetAddress . getByAddress ( new byte [ 4 ] ) ; 
 + } 
 + catch ( UnknownHostException e ) 
 + { 
 + throw new RuntimeException ( " Host 0 . 0 . 0 . 0 is somehow unknown " ) ; 
 + } 
 + 
 + if ( rpcAddress . equals ( bindAll ) ) 
 + throw new ConfigurationException ( " If rpc _ address is set to 0 . 0 . 0 . 0 , you must set broadcast _ rpc _ address " + 
 + " to a value other than 0 . 0 . 0 . 0 " ) ; 
 + broadcastRpcAddress = rpcAddress ; 
 + } 
 + 
 if ( conf . thrift _ framed _ transport _ size _ in _ mb < = 0 ) 
 throw new ConfigurationException ( " thrift _ framed _ transport _ size _ in _ mb must be positive " ) ; 
 
 @ @ - 1026 , 6 + 1060 , 16 @ @ public class DatabaseDescriptor 
 return rpcAddress ; 
 } 
 
 + public static void setBroadcastRpcAddress ( InetAddress broadcastRPCAddr ) 
 + { 
 + broadcastRpcAddress = broadcastRPCAddr ; 
 + } 
 + 
 + public static InetAddress getBroadcastRpcAddress ( ) 
 + { 
 + return broadcastRpcAddress ; 
 + } 
 + 
 public static String getRpcServerType ( ) 
 { 
 return conf . rpc _ server _ type ; 
 @ @ - 1071 , 11 + 1115 , 6 @ @ public class DatabaseDescriptor 
 return conf . start _ native _ transport ; 
 } 
 
 - public static InetAddress getNativeTransportAddress ( ) 
 - { 
 - return getRpcAddress ( ) ; 
 - } 
 - 
 public static int getNativeTransportPort ( ) 
 { 
 return Integer . parseInt ( System . getProperty ( " cassandra . native _ transport _ port " , conf . native _ transport _ port . toString ( ) ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / locator / Ec2MultiRegionSnitch . java b / src / java / org / apache / cassandra / locator / Ec2MultiRegionSnitch . java 
 index 7dc2fa9 . . 511cbb5 100644 
 - - - a / src / java / org / apache / cassandra / locator / Ec2MultiRegionSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / Ec2MultiRegionSnitch . java 
 @ @ - 52 , 6 + 52 , 7 @ @ public class Ec2MultiRegionSnitch extends Ec2Snitch 
 localPrivateAddress = awsApiCall ( PRIVATE _ IP _ QUERY _ URL ) ; 
 / / use the Public IP to broadcast Address to other nodes . 
 DatabaseDescriptor . setBroadcastAddress ( localPublicAddress ) ; 
 + DatabaseDescriptor . setBroadcastRpcAddress ( localPublicAddress ) ; 
 } 
 
 public void gossiperStarting ( ) 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index 50bbe02 . . 7c56fb7 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 360 , 7 + 360 , 7 @ @ public class CassandraDaemon 
 thriftServer = new ThriftServer ( rpcAddr , rpcPort , listenBacklog ) ; 
 
 / / Native transport 
 - InetAddress nativeAddr = DatabaseDescriptor . getNativeTransportAddress ( ) ; 
 + InetAddress nativeAddr = DatabaseDescriptor . getRpcAddress ( ) ; 
 int nativePort = DatabaseDescriptor . getNativeTransportPort ( ) ; 
 nativeServer = new org . apache . cassandra . transport . Server ( nativeAddr , nativePort ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 132e674 . . d1db703 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 637 , 7 + 637 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 getTokenMetadata ( ) . updateHostId ( SystemKeyspace . getLocalHostId ( ) , FBUtilities . getBroadcastAddress ( ) ) ; 
 appStates . put ( ApplicationState . NET _ VERSION , valueFactory . networkVersion ( ) ) ; 
 appStates . put ( ApplicationState . HOST _ ID , valueFactory . hostId ( SystemKeyspace . getLocalHostId ( ) ) ) ; 
 - appStates . put ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getRpcAddress ( ) ) ) ; 
 + appStates . put ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getBroadcastRpcAddress ( ) ) ) ; 
 appStates . put ( ApplicationState . RELEASE _ VERSION , valueFactory . releaseVersion ( ) ) ; 
 logger . info ( " Starting up server gossip " ) ; 
 Gossiper . instance . register ( this ) ; 
 @ @ - 1049 , 7 + 1049 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 public String getRpcaddress ( InetAddress endpoint ) 
 { 
 if ( endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 - return DatabaseDescriptor . getRpcAddress ( ) . getHostAddress ( ) ; 
 + return DatabaseDescriptor . getBroadcastRpcAddress ( ) . getHostAddress ( ) ; 
 else if ( Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( ApplicationState . RPC _ ADDRESS ) = = null ) 
 return endpoint . getHostAddress ( ) ; 
 else 
 diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java 
 index 4f46614 . . 801a3e5 100644 
 - - - a / src / java / org / apache / cassandra / transport / Server . java 
 + + + b / src / java / org / apache / cassandra / transport / Server . java 
 @ @ - 331 , 6 + 331 , 8 @ @ public class Server implements CassandraDaemon . Server 
 InetAddress rpcAddress = InetAddress . getByName ( StorageService . instance . getRpcaddress ( endpoint ) ) ; 
 / / If rpcAddress = = 0 . 0 . 0 . 0 ( i . e . bound on all addresses ) , returning that is not very helpful , 
 / / so return the internal address ( which is ok since " we ' re bound on all addresses " ) . 
 + / / Note that after all nodes are running a version that includes CASSANDRA - 5899 , rpcAddress should 
 + / / never be 0 . 0 . 0 . 0 , so this can eventually be removed . 
 return rpcAddress . equals ( bindAll ) ? endpoint : rpcAddress ; 
 } 
 catch ( UnknownHostException e )

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f7e439c . . 805dca2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 3 , 7 + 3 , 7 @ @ 
 * Log Merkle tree stats ( CASSANDRA - 2698 ) 
 * Switch from crc32 to adler32 for compressed sstable checksums ( CASSANDRA - 5862 ) 
 * Improve offheap memcpy performance ( CASSANDRA - 5884 ) 
 - 
 + * Use a range aware scanner for cleanup ( CASSANDRA - 2524 ) 
 
 2 . 0 . 0 - rc2 
 * enable vnodes by default ( CASSANDRA - 5869 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 7b11672 . . 2adda32 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1459 , 6 + 1459 , 18 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 return columns ; 
 } 
 
 + public void cleanupCache ( ) 
 + { 
 + Collection < Range < Token > > ranges = StorageService . instance . getLocalRanges ( keyspace . getName ( ) ) ; 
 + 
 + for ( RowCacheKey key : CacheService . instance . rowCache . getKeySet ( ) ) 
 + { 
 + DecoratedKey dk = StorageService . getPartitioner ( ) . decorateKey ( ByteBuffer . wrap ( key . key ) ) ; 
 + if ( key . cfId = = metadata . cfId & & ! Range . isInRanges ( dk . token , ranges ) ) 
 + invalidateCachedRow ( dk ) ; 
 + } 
 + } 
 + 
 public static abstract class AbstractScanIterator extends AbstractIterator < Row > implements CloseableIterator < Row > 
 { 
 public boolean needsFiltering ( ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index 35354c8 . . ed6770f 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 97 , 6 + 97 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 
 private final CompactionExecutor executor = new CompactionExecutor ( ) ; 
 private final CompactionExecutor validationExecutor = new ValidationExecutor ( ) ; 
 + private final static CompactionExecutor cacheCleanupExecutor = new CacheCleanupExecutor ( ) ; 
 + 
 private final CompactionMetrics metrics = new CompactionMetrics ( executor , validationExecutor ) ; 
 private final Multiset < ColumnFamilyStore > compactingCF = ConcurrentHashMultiset . create ( ) ; 
 
 @ @ - 461 , 7 + 463 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 * 
 * @ throws IOException 
 * / 
 - private void doCleanupCompaction ( ColumnFamilyStore cfs , Collection < SSTableReader > sstables , CounterId . OneShotRenewer renewer ) throws IOException 
 + private void doCleanupCompaction ( final ColumnFamilyStore cfs , Collection < SSTableReader > sstables , CounterId . OneShotRenewer renewer ) throws IOException 
 { 
 assert ! cfs . isIndex ( ) ; 
 Keyspace keyspace = cfs . keyspace ; 
 @ @ - 472 , 8 + 474 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 return ; 
 } 
 
 - boolean isCommutative = cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ; 
 boolean hasIndexes = ! cfs . indexManager . getIndexes ( ) . isEmpty ( ) ; 
 + CleanupStrategy cleanupStrategy = CleanupStrategy . get ( cfs , ranges , renewer ) ; 
 
 for ( SSTableReader sstable : sstables ) 
 { 
 @ @ - 500 , 10 + 502 , 9 @ @ public class CompactionManager implements CompactionManagerMBean 
 if ( compactionFileLocation = = null ) 
 throw new IOException ( " disk full " ) ; 
 
 - SSTableScanner scanner = sstable . getScanner ( getRateLimiter ( ) ) ; 
 - List < Column > indexedColumnsInRow = null ; 
 + ICompactionScanner scanner = cleanupStrategy . getScanner ( sstable , getRateLimiter ( ) ) ; 
 + CleanupInfo ci = new CleanupInfo ( sstable , ( SSTableScanner ) scanner ) ; 
 
 - CleanupInfo ci = new CleanupInfo ( sstable , scanner ) ; 
 metrics . beginCompaction ( ci ) ; 
 SSTableWriter writer = createWriter ( cfs , 
 compactionFileLocation , 
 @ @ - 517 , 50 + 518 , 13 @ @ public class CompactionManager implements CompactionManagerMBean 
 if ( ci . isStopRequested ( ) ) 
 throw new CompactionInterruptedException ( ci . getCompactionInfo ( ) ) ; 
 SSTableIdentityIterator row = ( SSTableIdentityIterator ) scanner . next ( ) ; 
 - if ( Range . isInRanges ( row . getKey ( ) . token , ranges ) ) 
 - { 
 - AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; 
 - if ( writer . append ( compactedRow ) ! = null ) 
 - totalkeysWritten + + ; 
 - } 
 - else 
 - { 
 - cfs . invalidateCachedRow ( row . getKey ( ) ) ; 
 - 
 - if ( hasIndexes | | isCommutative ) 
 - { 
 - if ( indexedColumnsInRow ! = null ) 
 - indexedColumnsInRow . clear ( ) ; 
 - 
 - while ( row . hasNext ( ) ) 
 - { 
 - OnDiskAtom column = row . next ( ) ; 
 - if ( column instanceof CounterColumn ) 
 - renewer . maybeRenew ( ( CounterColumn ) column ) ; 
 - if ( column instanceof Column & & cfs . indexManager . indexes ( ( Column ) column ) ) 
 - { 
 - if ( indexedColumnsInRow = = null ) 
 - indexedColumnsInRow = new ArrayList < Column > ( ) ; 
 - 
 - indexedColumnsInRow . add ( ( Column ) column ) ; 
 - } 
 - } 
 - 
 - if ( indexedColumnsInRow ! = null & & ! indexedColumnsInRow . isEmpty ( ) ) 
 - { 
 - / / acquire memtable lock here because secondary index deletion may cause a race . See CASSANDRA - 3712 
 - Keyspace . switchLock . readLock ( ) . lock ( ) ; 
 - try 
 - { 
 - cfs . indexManager . deleteFromIndexes ( row . getKey ( ) , indexedColumnsInRow ) ; 
 - } 
 - finally 
 - { 
 - Keyspace . switchLock . readLock ( ) . unlock ( ) ; 
 - } 
 - } 
 - } 
 - } 
 + 
 + row = cleanupStrategy . cleanup ( row ) ; 
 + if ( row = = null ) 
 + continue ; 
 + AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; 
 + if ( writer . append ( compactedRow ) ! = null ) 
 + totalkeysWritten + + ; 
 } 
 if ( totalkeysWritten > 0 ) 
 newSstable = writer . closeAndOpenReader ( sstable . maxDataAge ) ; 
 @ @ - 599 , 6 + 563 , 114 @ @ public class CompactionManager implements CompactionManagerMBean 
 } 
 } 
 
 + private static abstract class CleanupStrategy 
 + { 
 + public static CleanupStrategy get ( ColumnFamilyStore cfs , Collection < Range < Token > > ranges , CounterId . OneShotRenewer renewer ) 
 + { 
 + if ( ! cfs . indexManager . getIndexes ( ) . isEmpty ( ) | | cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ) 
 + return new Full ( cfs , ranges , renewer ) ; 
 + 
 + return new Bounded ( cfs , ranges ) ; 
 + } 
 + 
 + public abstract ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) ; 
 + public abstract SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) ; 
 + 
 + private static final class Bounded extends CleanupStrategy 
 + { 
 + private final Collection < Range < Token > > ranges ; 
 + 
 + public Bounded ( final ColumnFamilyStore cfs , Collection < Range < Token > > ranges ) 
 + { 
 + this . ranges = ranges ; 
 + cacheCleanupExecutor . submit ( new Runnable ( ) 
 + { 
 + @ Override 
 + public void run ( ) 
 + { 
 + cfs . cleanupCache ( ) ; 
 + } 
 + } ) ; 
 + 
 + } 
 + @ Override 
 + public ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) 
 + { 
 + return sstable . getScanner ( ranges , limiter ) ; 
 + } 
 + 
 + @ Override 
 + public SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) 
 + { 
 + return row ; 
 + } 
 + } 
 + 
 + private static final class Full extends CleanupStrategy 
 + { 
 + private final Collection < Range < Token > > ranges ; 
 + private final ColumnFamilyStore cfs ; 
 + private List < Column > indexedColumnsInRow ; 
 + private final CounterId . OneShotRenewer renewer ; 
 + 
 + public Full ( ColumnFamilyStore cfs , Collection < Range < Token > > ranges , CounterId . OneShotRenewer renewer ) 
 + { 
 + this . cfs = cfs ; 
 + this . ranges = ranges ; 
 + this . indexedColumnsInRow = null ; 
 + this . renewer = renewer ; 
 + } 
 + 
 + @ Override 
 + public ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) 
 + { 
 + return sstable . getScanner ( limiter ) ; 
 + } 
 + 
 + @ Override 
 + public SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) 
 + { 
 + if ( Range . isInRanges ( row . getKey ( ) . token , ranges ) ) 
 + return row ; 
 + 
 + cfs . invalidateCachedRow ( row . getKey ( ) ) ; 
 + 
 + if ( indexedColumnsInRow ! = null ) 
 + indexedColumnsInRow . clear ( ) ; 
 + 
 + while ( row . hasNext ( ) ) 
 + { 
 + OnDiskAtom column = row . next ( ) ; 
 + if ( column instanceof CounterColumn ) 
 + renewer . maybeRenew ( ( CounterColumn ) column ) ; 
 + 
 + if ( column instanceof Column & & cfs . indexManager . indexes ( ( Column ) column ) ) 
 + { 
 + if ( indexedColumnsInRow = = null ) 
 + indexedColumnsInRow = new ArrayList < > ( ) ; 
 + 
 + indexedColumnsInRow . add ( ( Column ) column ) ; 
 + } 
 + } 
 + 
 + if ( indexedColumnsInRow ! = null & & ! indexedColumnsInRow . isEmpty ( ) ) 
 + { 
 + / / acquire memtable lock here because secondary index deletion may cause a race . See CASSANDRA - 3712 
 + Keyspace . switchLock . readLock ( ) . lock ( ) ; 
 + try 
 + { 
 + cfs . indexManager . deleteFromIndexes ( row . getKey ( ) , indexedColumnsInRow ) ; 
 + } 
 + finally 
 + { 
 + Keyspace . switchLock . readLock ( ) . unlock ( ) ; 
 + } 
 + } 
 + return null ; 
 + } 
 + } 
 + } 
 + 
 public static SSTableWriter createWriter ( ColumnFamilyStore cfs , 
 File compactionFileLocation , 
 int expectedBloomFilterSize , 
 @ @ - 847 , 6 + 919 , 14 @ @ public class CompactionManager implements CompactionManagerMBean 
 } 
 } 
 
 + private static class CacheCleanupExecutor extends CompactionExecutor 
 + { 
 + public CacheCleanupExecutor ( ) 
 + { 
 + super ( 1 , " CacheCleanupExecutor " ) ; 
 + } 
 + } 
 + 
 public interface CompactionExecutorStatsCollector 
 { 
 void beginCompaction ( CompactionInfo . Holder ci ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index 4a62d85 . . bbca089 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 1081 , 11 + 1081 , 23 @ @ public class SSTableReader extends SSTable 
 { 
 if ( range = = null ) 
 return getScanner ( limiter ) ; 
 + return getScanner ( Collections . singletonList ( range ) , limiter ) ; 
 + } 
 
 + / * * 
 + * Direct I / O SSTableScanner over a defined collection of ranges of tokens . 
 + * 
 + * @ param ranges the range of keys to cover 
 + * @ return A Scanner for seeking over the rows of the SSTable . 
 + * / 
 + public ICompactionScanner getScanner ( Collection < Range < Token > > ranges , RateLimiter limiter ) 
 + { 
 / / We want to avoid allocating a SSTableScanner if the range don ' t overlap the sstable
