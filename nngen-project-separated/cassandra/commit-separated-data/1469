BLEU SCORE: 8.926124668793946E-4

TEST MSG: sysexit on cassandra - stress main thread error
GENERATED MSG: bind outgoing sockets to the locally specified cassandra interface ( avoids using the result of InetAddress . anyLocalAddress ( ) , which may not be the right cassandra interface ) . Patch by Gary Dusbabek , reviewed by Jonathan Ellis .

TEST DIFF (one line): diff - - git a / tools / stress / src / org / apache / cassandra / stress / Stress . java b / tools / stress / src / org / apache / cassandra / stress / Stress . java <nl> index a4ec8a0 . . bc6d027 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / Stress . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / Stress . java <nl> @ @ - 57 , 66 + 57 , 78 @ @ public final class Stress <nl> if ( FBUtilities . isWindows ( ) ) <nl> WindowsTimer . startTimerPeriod ( 1 ) ; <nl> <nl> - final StressSettings settings ; <nl> try <nl> { <nl> - settings = StressSettings . parse ( arguments ) ; <nl> - } <nl> - catch ( IllegalArgumentException e ) <nl> - { <nl> - printHelpMessage ( ) ; <nl> - e . printStackTrace ( ) ; <nl> - return ; <nl> - } <nl> <nl> - PrintStream logout = settings . log . getOutput ( ) ; <nl> + final StressSettings settings ; <nl> + try <nl> + { <nl> + settings = StressSettings . parse ( arguments ) ; <nl> + } <nl> + catch ( IllegalArgumentException e ) <nl> + { <nl> + printHelpMessage ( ) ; <nl> + e . printStackTrace ( ) ; <nl> + return ; <nl> + } <nl> <nl> - if ( settings . sendToDaemon ! = null ) <nl> - { <nl> - Socket socket = new Socket ( settings . sendToDaemon , 2159 ) ; <nl> + PrintStream logout = settings . log . getOutput ( ) ; <nl> <nl> - ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; <nl> - BufferedReader inp = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; <nl> + if ( settings . sendToDaemon ! = null ) <nl> + { <nl> + Socket socket = new Socket ( settings . sendToDaemon , 2159 ) ; <nl> <nl> - Runtime . getRuntime ( ) . addShutdownHook ( new ShutDown ( socket , out ) ) ; <nl> + ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; <nl> + BufferedReader inp = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; <nl> <nl> - out . writeObject ( settings ) ; <nl> + Runtime . getRuntime ( ) . addShutdownHook ( new ShutDown ( socket , out ) ) ; <nl> <nl> - String line ; <nl> + out . writeObject ( settings ) ; <nl> <nl> - try <nl> - { <nl> - while ( ! socket . isClosed ( ) & & ( line = inp . readLine ( ) ) ! = null ) <nl> + String line ; <nl> + <nl> + try <nl> { <nl> - if ( line . equals ( " END " ) | | line . equals ( " FAILURE " ) ) <nl> + while ( ! socket . isClosed ( ) & & ( line = inp . readLine ( ) ) ! = null ) <nl> { <nl> - out . writeInt ( 1 ) ; <nl> - break ; <nl> - } <nl> + if ( line . equals ( " END " ) | | line . equals ( " FAILURE " ) ) <nl> + { <nl> + out . writeInt ( 1 ) ; <nl> + break ; <nl> + } <nl> <nl> - logout . println ( line ) ; <nl> + logout . println ( line ) ; <nl> + } <nl> + } <nl> + catch ( SocketException e ) <nl> + { <nl> + if ( ! stopped ) <nl> + e . printStackTrace ( ) ; <nl> } <nl> + <nl> + out . close ( ) ; <nl> + inp . close ( ) ; <nl> + <nl> + socket . close ( ) ; <nl> } <nl> - catch ( SocketException e ) <nl> + else <nl> { <nl> - if ( ! stopped ) <nl> - e . printStackTrace ( ) ; <nl> + StressAction stressAction = new StressAction ( settings , logout ) ; <nl> + stressAction . run ( ) ; <nl> } <nl> <nl> - out . close ( ) ; <nl> - inp . close ( ) ; <nl> - <nl> - socket . close ( ) ; <nl> } <nl> - else <nl> + catch ( Throwable t ) <nl> { <nl> - StressAction stressAction = new StressAction ( settings , logout ) ; <nl> - stressAction . run ( ) ; <nl> + t . printStackTrace ( ) ; <nl> + } <nl> + finally <nl> + { <nl> + if ( FBUtilities . isWindows ( ) ) <nl> + WindowsTimer . endTimerPeriod ( 1 ) ; <nl> + System . exit ( 0 ) ; <nl> } <nl> <nl> - if ( FBUtilities . isWindows ( ) ) <nl> - WindowsTimer . endTimerPeriod ( 1 ) ; <nl> - System . exit ( 0 ) ; <nl> } <nl> <nl> / * *
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / net / FileStreamTask . java b / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> index e7f3cf7 . . 152ea35 100644 <nl> - - - a / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> + + + b / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import java . nio . ByteBuffer ; <nl> import java . nio . channels . FileChannel ; <nl> import java . nio . channels . SocketChannel ; <nl> <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . log4j . Logger ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> @ @ - 51 , 7 + 52 , 11 @ @ public class FileStreamTask extends WrappedRunnable <nl> <nl> public void runMayThrow ( ) throws IOException <nl> { <nl> - SocketChannel channel = SocketChannel . open ( new InetSocketAddress ( to , DatabaseDescriptor . getStoragePort ( ) ) ) ; <nl> + SocketChannel channel = SocketChannel . open ( ) ; <nl> + / / force local binding on correctly specified interface . <nl> + channel . socket ( ) . bind ( new InetSocketAddress ( FBUtilities . getLocalAddress ( ) , 0 ) ) ; <nl> + / / obey the unwritten law that all nodes on a cluster must use the same storage port . <nl> + channel . connect ( new InetSocketAddress ( to , DatabaseDescriptor . getStoragePort ( ) ) ) ; <nl> try <nl> { <nl> stream ( channel ) ; <nl> diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> index d7ac4d3 . . 5d116bb 100644 <nl> - - - a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> @ @ - 1 , 148 + 1 , 150 @ @ <nl> - package org . apache . cassandra . net ; <nl> - <nl> - import java . io . DataOutputStream ; <nl> - import java . io . IOException ; <nl> - import java . net . InetAddress ; <nl> - import java . net . Socket ; <nl> - import java . nio . ByteBuffer ; <nl> - import java . util . concurrent . BlockingQueue ; <nl> - import java . util . concurrent . LinkedBlockingQueue ; <nl> - <nl> - import org . apache . log4j . Logger ; <nl> - <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - <nl> - public class OutboundTcpConnection extends Thread <nl> - { <nl> - private static final Logger logger = Logger . getLogger ( OutboundTcpConnection . class ) ; <nl> - <nl> - private static final ByteBuffer CLOSE _ SENTINEL = ByteBuffer . allocate ( 0 ) ; <nl> - private static final int OPEN _ RETRY _ DELAY = 100 ; / / ms between retries <nl> - <nl> - private final OutboundTcpConnectionPool pool ; <nl> - private final InetAddress endpoint ; <nl> - private final BlockingQueue < ByteBuffer > queue = new LinkedBlockingQueue < ByteBuffer > ( ) ; <nl> - private DataOutputStream output ; <nl> - private Socket socket ; <nl> - <nl> - public OutboundTcpConnection ( final OutboundTcpConnectionPool pool , final InetAddress remoteEp ) <nl> - { <nl> - super ( " WRITE - " + remoteEp ) ; <nl> - this . pool = pool ; <nl> - this . endpoint = remoteEp ; <nl> - } <nl> - <nl> - public void write ( ByteBuffer buffer ) <nl> - { <nl> - try <nl> - { <nl> - queue . put ( buffer ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> - } <nl> - <nl> - public void closeSocket ( ) <nl> - { <nl> - queue . clear ( ) ; <nl> - write ( CLOSE _ SENTINEL ) ; <nl> - } <nl> - <nl> - public void run ( ) <nl> - { <nl> - while ( true ) <nl> - { <nl> - ByteBuffer bb = take ( ) ; <nl> - if ( bb = = CLOSE _ SENTINEL ) <nl> - { <nl> - disconnect ( ) ; <nl> - continue ; <nl> - } <nl> - if ( socket ! = null | | connect ( ) ) <nl> - writeConnected ( bb ) ; <nl> - } <nl> - } <nl> - <nl> - private void writeConnected ( ByteBuffer bb ) <nl> - { <nl> - try <nl> - { <nl> - output . write ( bb . array ( ) , 0 , bb . limit ( ) ) ; <nl> - if ( queue . peek ( ) = = null ) <nl> - { <nl> - output . flush ( ) ; <nl> - } <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - logger . info ( " error writing to " + endpoint ) ; <nl> - disconnect ( ) ; <nl> - } <nl> - } <nl> - <nl> - private void disconnect ( ) <nl> - { <nl> - if ( socket ! = null ) <nl> - { <nl> - try <nl> - { <nl> - socket . close ( ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " exception closing connection to " + endpoint , e ) ; <nl> - } <nl> - output = null ; <nl> - socket = null ; <nl> - } <nl> - } <nl> - <nl> - private ByteBuffer take ( ) <nl> - { <nl> - ByteBuffer bb ; <nl> - try <nl> - { <nl> - bb = queue . take ( ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> - return bb ; <nl> - } <nl> - <nl> - private boolean connect ( ) <nl> - { <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " attempting to connect to " + endpoint ) ; <nl> - long start = System . currentTimeMillis ( ) ; <nl> - while ( System . currentTimeMillis ( ) < start + DatabaseDescriptor . getRpcTimeout ( ) ) <nl> - { <nl> - try <nl> - { <nl> - socket = new Socket ( endpoint , DatabaseDescriptor . getStoragePort ( ) ) ; <nl> - socket . setTcpNoDelay ( true ) ; <nl> - output = new DataOutputStream ( socket . getOutputStream ( ) ) ; <nl> - return true ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - socket = null ; <nl> - if ( logger . isTraceEnabled ( ) ) <nl> - logger . trace ( " unable to connect to " + endpoint , e ) ; <nl> - try <nl> - { <nl> - Thread . sleep ( OPEN _ RETRY _ DELAY ) ; <nl> - } <nl> - catch ( InterruptedException e1 ) <nl> - { <nl> - throw new AssertionError ( e1 ) ; <nl> - } <nl> - } <nl> - } <nl> - return false ; <nl> - } <nl> - } <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . io . DataOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . net . InetAddress ; <nl> + import java . net . Socket ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . concurrent . BlockingQueue ; <nl> + import java . util . concurrent . LinkedBlockingQueue ; <nl> + <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . log4j . Logger ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + <nl> + public class OutboundTcpConnection extends Thread <nl> + { <nl> + private static final Logger logger = Logger . getLogger ( OutboundTcpConnection . class ) ; <nl> + <nl> + private static final ByteBuffer CLOSE _ SENTINEL = ByteBuffer . allocate ( 0 ) ; <nl> + private static final int OPEN _ RETRY _ DELAY = 100 ; / / ms between retries <nl> + <nl> + private final OutboundTcpConnectionPool pool ; <nl> + private final InetAddress endpoint ; <nl> + private final BlockingQueue < ByteBuffer > queue = new LinkedBlockingQueue < ByteBuffer > ( ) ; <nl> + private DataOutputStream output ; <nl> + private Socket socket ; <nl> + <nl> + public OutboundTcpConnection ( final OutboundTcpConnectionPool pool , final InetAddress remoteEp ) <nl> + { <nl> + super ( " WRITE - " + remoteEp ) ; <nl> + this . pool = pool ; <nl> + this . endpoint = remoteEp ; <nl> + } <nl> + <nl> + public void write ( ByteBuffer buffer ) <nl> + { <nl> + try <nl> + { <nl> + queue . put ( buffer ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public void closeSocket ( ) <nl> + { <nl> + queue . clear ( ) ; <nl> + write ( CLOSE _ SENTINEL ) ; <nl> + } <nl> + <nl> + public void run ( ) <nl> + { <nl> + while ( true ) <nl> + { <nl> + ByteBuffer bb = take ( ) ; <nl> + if ( bb = = CLOSE _ SENTINEL ) <nl> + { <nl> + disconnect ( ) ; <nl> + continue ; <nl> + } <nl> + if ( socket ! = null | | connect ( ) ) <nl> + writeConnected ( bb ) ; <nl> + } <nl> + } <nl> + <nl> + private void writeConnected ( ByteBuffer bb ) <nl> + { <nl> + try <nl> + { <nl> + output . write ( bb . array ( ) , 0 , bb . limit ( ) ) ; <nl> + if ( queue . peek ( ) = = null ) <nl> + { <nl> + output . flush ( ) ; <nl> + } <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + logger . info ( " error writing to " + endpoint ) ; <nl> + disconnect ( ) ; <nl> + } <nl> + } <nl> + <nl> + private void disconnect ( ) <nl> + { <nl> + if ( socket ! = null ) <nl> + { <nl> + try <nl> + { <nl> + socket . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " exception closing connection to " + endpoint , e ) ; <nl> + } <nl> + output = null ; <nl> + socket = null ; <nl> + } <nl> + } <nl> + <nl> + private ByteBuffer take ( ) <nl> + { <nl> + ByteBuffer bb ; <nl> + try <nl> + { <nl> + bb = queue . take ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + return bb ; <nl> + } <nl> + <nl> + private boolean connect ( ) <nl> + { <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " attempting to connect to " + endpoint ) ; <nl> + long start = System . currentTimeMillis ( ) ; <nl> + while ( System . currentTimeMillis ( ) < start + DatabaseDescriptor . getRpcTimeout ( ) ) <nl> + { <nl> + try <nl> + { <nl> + / / zero means ' bind on any available port . ' <nl> + socket = new Socket ( endpoint , DatabaseDescriptor . getStoragePort ( ) , FBUtilities . getLocalAddress ( ) , 0 ) ; <nl> + socket . setTcpNoDelay ( true ) ; <nl> + output = new DataOutputStream ( socket . getOutputStream ( ) ) ; <nl> + return true ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + socket = null ; <nl> + if ( logger . isTraceEnabled ( ) ) <nl> + logger . trace ( " unable to connect to " + endpoint , e ) ; <nl> + try <nl> + { <nl> + Thread . sleep ( OPEN _ RETRY _ DELAY ) ; <nl> + } <nl> + catch ( InterruptedException e1 ) <nl> + { <nl> + throw new AssertionError ( e1 ) ; <nl> + } <nl> + } <nl> + } <nl> + return false ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / tools / stress / src / org / apache / cassandra / stress / Stress . java b / tools / stress / src / org / apache / cassandra / stress / Stress . java 
 index a4ec8a0 . . bc6d027 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / Stress . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / Stress . java 
 @ @ - 57 , 66 + 57 , 78 @ @ public final class Stress 
 if ( FBUtilities . isWindows ( ) ) 
 WindowsTimer . startTimerPeriod ( 1 ) ; 
 
 - final StressSettings settings ; 
 try 
 { 
 - settings = StressSettings . parse ( arguments ) ; 
 - } 
 - catch ( IllegalArgumentException e ) 
 - { 
 - printHelpMessage ( ) ; 
 - e . printStackTrace ( ) ; 
 - return ; 
 - } 
 
 - PrintStream logout = settings . log . getOutput ( ) ; 
 + final StressSettings settings ; 
 + try 
 + { 
 + settings = StressSettings . parse ( arguments ) ; 
 + } 
 + catch ( IllegalArgumentException e ) 
 + { 
 + printHelpMessage ( ) ; 
 + e . printStackTrace ( ) ; 
 + return ; 
 + } 
 
 - if ( settings . sendToDaemon ! = null ) 
 - { 
 - Socket socket = new Socket ( settings . sendToDaemon , 2159 ) ; 
 + PrintStream logout = settings . log . getOutput ( ) ; 
 
 - ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; 
 - BufferedReader inp = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; 
 + if ( settings . sendToDaemon ! = null ) 
 + { 
 + Socket socket = new Socket ( settings . sendToDaemon , 2159 ) ; 
 
 - Runtime . getRuntime ( ) . addShutdownHook ( new ShutDown ( socket , out ) ) ; 
 + ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; 
 + BufferedReader inp = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; 
 
 - out . writeObject ( settings ) ; 
 + Runtime . getRuntime ( ) . addShutdownHook ( new ShutDown ( socket , out ) ) ; 
 
 - String line ; 
 + out . writeObject ( settings ) ; 
 
 - try 
 - { 
 - while ( ! socket . isClosed ( ) & & ( line = inp . readLine ( ) ) ! = null ) 
 + String line ; 
 + 
 + try 
 { 
 - if ( line . equals ( " END " ) | | line . equals ( " FAILURE " ) ) 
 + while ( ! socket . isClosed ( ) & & ( line = inp . readLine ( ) ) ! = null ) 
 { 
 - out . writeInt ( 1 ) ; 
 - break ; 
 - } 
 + if ( line . equals ( " END " ) | | line . equals ( " FAILURE " ) ) 
 + { 
 + out . writeInt ( 1 ) ; 
 + break ; 
 + } 
 
 - logout . println ( line ) ; 
 + logout . println ( line ) ; 
 + } 
 + } 
 + catch ( SocketException e ) 
 + { 
 + if ( ! stopped ) 
 + e . printStackTrace ( ) ; 
 } 
 + 
 + out . close ( ) ; 
 + inp . close ( ) ; 
 + 
 + socket . close ( ) ; 
 } 
 - catch ( SocketException e ) 
 + else 
 { 
 - if ( ! stopped ) 
 - e . printStackTrace ( ) ; 
 + StressAction stressAction = new StressAction ( settings , logout ) ; 
 + stressAction . run ( ) ; 
 } 
 
 - out . close ( ) ; 
 - inp . close ( ) ; 
 - 
 - socket . close ( ) ; 
 } 
 - else 
 + catch ( Throwable t ) 
 { 
 - StressAction stressAction = new StressAction ( settings , logout ) ; 
 - stressAction . run ( ) ; 
 + t . printStackTrace ( ) ; 
 + } 
 + finally 
 + { 
 + if ( FBUtilities . isWindows ( ) ) 
 + WindowsTimer . endTimerPeriod ( 1 ) ; 
 + System . exit ( 0 ) ; 
 } 
 
 - if ( FBUtilities . isWindows ( ) ) 
 - WindowsTimer . endTimerPeriod ( 1 ) ; 
 - System . exit ( 0 ) ; 
 } 
 
 / * *

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / net / FileStreamTask . java b / src / java / org / apache / cassandra / net / FileStreamTask . java 
 index e7f3cf7 . . 152ea35 100644 
 - - - a / src / java / org / apache / cassandra / net / FileStreamTask . java 
 + + + b / src / java / org / apache / cassandra / net / FileStreamTask . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import java . nio . ByteBuffer ; 
 import java . nio . channels . FileChannel ; 
 import java . nio . channels . SocketChannel ; 
 
 + import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . log4j . Logger ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 @ @ - 51 , 7 + 52 , 11 @ @ public class FileStreamTask extends WrappedRunnable 
 
 public void runMayThrow ( ) throws IOException 
 { 
 - SocketChannel channel = SocketChannel . open ( new InetSocketAddress ( to , DatabaseDescriptor . getStoragePort ( ) ) ) ; 
 + SocketChannel channel = SocketChannel . open ( ) ; 
 + / / force local binding on correctly specified interface . 
 + channel . socket ( ) . bind ( new InetSocketAddress ( FBUtilities . getLocalAddress ( ) , 0 ) ) ; 
 + / / obey the unwritten law that all nodes on a cluster must use the same storage port . 
 + channel . connect ( new InetSocketAddress ( to , DatabaseDescriptor . getStoragePort ( ) ) ) ; 
 try 
 { 
 stream ( channel ) ; 
 diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 index d7ac4d3 . . 5d116bb 100644 
 - - - a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 @ @ - 1 , 148 + 1 , 150 @ @ 
 - package org . apache . cassandra . net ; 
 - 
 - import java . io . DataOutputStream ; 
 - import java . io . IOException ; 
 - import java . net . InetAddress ; 
 - import java . net . Socket ; 
 - import java . nio . ByteBuffer ; 
 - import java . util . concurrent . BlockingQueue ; 
 - import java . util . concurrent . LinkedBlockingQueue ; 
 - 
 - import org . apache . log4j . Logger ; 
 - 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 - 
 - public class OutboundTcpConnection extends Thread 
 - { 
 - private static final Logger logger = Logger . getLogger ( OutboundTcpConnection . class ) ; 
 - 
 - private static final ByteBuffer CLOSE _ SENTINEL = ByteBuffer . allocate ( 0 ) ; 
 - private static final int OPEN _ RETRY _ DELAY = 100 ; / / ms between retries 
 - 
 - private final OutboundTcpConnectionPool pool ; 
 - private final InetAddress endpoint ; 
 - private final BlockingQueue < ByteBuffer > queue = new LinkedBlockingQueue < ByteBuffer > ( ) ; 
 - private DataOutputStream output ; 
 - private Socket socket ; 
 - 
 - public OutboundTcpConnection ( final OutboundTcpConnectionPool pool , final InetAddress remoteEp ) 
 - { 
 - super ( " WRITE - " + remoteEp ) ; 
 - this . pool = pool ; 
 - this . endpoint = remoteEp ; 
 - } 
 - 
 - public void write ( ByteBuffer buffer ) 
 - { 
 - try 
 - { 
 - queue . put ( buffer ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 - } 
 - 
 - public void closeSocket ( ) 
 - { 
 - queue . clear ( ) ; 
 - write ( CLOSE _ SENTINEL ) ; 
 - } 
 - 
 - public void run ( ) 
 - { 
 - while ( true ) 
 - { 
 - ByteBuffer bb = take ( ) ; 
 - if ( bb = = CLOSE _ SENTINEL ) 
 - { 
 - disconnect ( ) ; 
 - continue ; 
 - } 
 - if ( socket ! = null | | connect ( ) ) 
 - writeConnected ( bb ) ; 
 - } 
 - } 
 - 
 - private void writeConnected ( ByteBuffer bb ) 
 - { 
 - try 
 - { 
 - output . write ( bb . array ( ) , 0 , bb . limit ( ) ) ; 
 - if ( queue . peek ( ) = = null ) 
 - { 
 - output . flush ( ) ; 
 - } 
 - } 
 - catch ( IOException e ) 
 - { 
 - logger . info ( " error writing to " + endpoint ) ; 
 - disconnect ( ) ; 
 - } 
 - } 
 - 
 - private void disconnect ( ) 
 - { 
 - if ( socket ! = null ) 
 - { 
 - try 
 - { 
 - socket . close ( ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " exception closing connection to " + endpoint , e ) ; 
 - } 
 - output = null ; 
 - socket = null ; 
 - } 
 - } 
 - 
 - private ByteBuffer take ( ) 
 - { 
 - ByteBuffer bb ; 
 - try 
 - { 
 - bb = queue . take ( ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 - return bb ; 
 - } 
 - 
 - private boolean connect ( ) 
 - { 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " attempting to connect to " + endpoint ) ; 
 - long start = System . currentTimeMillis ( ) ; 
 - while ( System . currentTimeMillis ( ) < start + DatabaseDescriptor . getRpcTimeout ( ) ) 
 - { 
 - try 
 - { 
 - socket = new Socket ( endpoint , DatabaseDescriptor . getStoragePort ( ) ) ; 
 - socket . setTcpNoDelay ( true ) ; 
 - output = new DataOutputStream ( socket . getOutputStream ( ) ) ; 
 - return true ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - socket = null ; 
 - if ( logger . isTraceEnabled ( ) ) 
 - logger . trace ( " unable to connect to " + endpoint , e ) ; 
 - try 
 - { 
 - Thread . sleep ( OPEN _ RETRY _ DELAY ) ; 
 - } 
 - catch ( InterruptedException e1 ) 
 - { 
 - throw new AssertionError ( e1 ) ; 
 - } 
 - } 
 - } 
 - return false ; 
 - } 
 - } 
 + package org . apache . cassandra . net ; 
 + 
 + import java . io . DataOutputStream ; 
 + import java . io . IOException ; 
 + import java . net . InetAddress ; 
 + import java . net . Socket ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . concurrent . BlockingQueue ; 
 + import java . util . concurrent . LinkedBlockingQueue ; 
 + 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . log4j . Logger ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + 
 + public class OutboundTcpConnection extends Thread 
 + { 
 + private static final Logger logger = Logger . getLogger ( OutboundTcpConnection . class ) ; 
 + 
 + private static final ByteBuffer CLOSE _ SENTINEL = ByteBuffer . allocate ( 0 ) ; 
 + private static final int OPEN _ RETRY _ DELAY = 100 ; / / ms between retries 
 + 
 + private final OutboundTcpConnectionPool pool ; 
 + private final InetAddress endpoint ; 
 + private final BlockingQueue < ByteBuffer > queue = new LinkedBlockingQueue < ByteBuffer > ( ) ; 
 + private DataOutputStream output ; 
 + private Socket socket ; 
 + 
 + public OutboundTcpConnection ( final OutboundTcpConnectionPool pool , final InetAddress remoteEp ) 
 + { 
 + super ( " WRITE - " + remoteEp ) ; 
 + this . pool = pool ; 
 + this . endpoint = remoteEp ; 
 + } 
 + 
 + public void write ( ByteBuffer buffer ) 
 + { 
 + try 
 + { 
 + queue . put ( buffer ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + } 
 + 
 + public void closeSocket ( ) 
 + { 
 + queue . clear ( ) ; 
 + write ( CLOSE _ SENTINEL ) ; 
 + } 
 + 
 + public void run ( ) 
 + { 
 + while ( true ) 
 + { 
 + ByteBuffer bb = take ( ) ; 
 + if ( bb = = CLOSE _ SENTINEL ) 
 + { 
 + disconnect ( ) ; 
 + continue ; 
 + } 
 + if ( socket ! = null | | connect ( ) ) 
 + writeConnected ( bb ) ; 
 + } 
 + } 
 + 
 + private void writeConnected ( ByteBuffer bb ) 
 + { 
 + try 
 + { 
 + output . write ( bb . array ( ) , 0 , bb . limit ( ) ) ; 
 + if ( queue . peek ( ) = = null ) 
 + { 
 + output . flush ( ) ; 
 + } 
 + } 
 + catch ( IOException e ) 
 + { 
 + logger . info ( " error writing to " + endpoint ) ; 
 + disconnect ( ) ; 
 + } 
 + } 
 + 
 + private void disconnect ( ) 
 + { 
 + if ( socket ! = null ) 
 + { 
 + try 
 + { 
 + socket . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " exception closing connection to " + endpoint , e ) ; 
 + } 
 + output = null ; 
 + socket = null ; 
 + } 
 + } 
 + 
 + private ByteBuffer take ( ) 
 + { 
 + ByteBuffer bb ; 
 + try 
 + { 
 + bb = queue . take ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + return bb ; 
 + } 
 + 
 + private boolean connect ( ) 
 + { 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " attempting to connect to " + endpoint ) ; 
 + long start = System . currentTimeMillis ( ) ; 
 + while ( System . currentTimeMillis ( ) < start + DatabaseDescriptor . getRpcTimeout ( ) ) 
 + { 
 + try 
 + { 
 + / / zero means ' bind on any available port . ' 
 + socket = new Socket ( endpoint , DatabaseDescriptor . getStoragePort ( ) , FBUtilities . getLocalAddress ( ) , 0 ) ; 
 + socket . setTcpNoDelay ( true ) ; 
 + output = new DataOutputStream ( socket . getOutputStream ( ) ) ; 
 + return true ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + socket = null ; 
 + if ( logger . isTraceEnabled ( ) ) 
 + logger . trace ( " unable to connect to " + endpoint , e ) ; 
 + try 
 + { 
 + Thread . sleep ( OPEN _ RETRY _ DELAY ) ; 
 + } 
 + catch ( InterruptedException e1 ) 
 + { 
 + throw new AssertionError ( e1 ) ; 
 + } 
 + } 
 + } 
 + return false ; 
 + } 
 + }
