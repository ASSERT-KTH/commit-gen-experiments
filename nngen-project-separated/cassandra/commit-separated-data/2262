BLEU SCORE: 0.029859662827819124

TEST MSG: Add support for custom 2i validation
GENERATED MSG: Push the validation of secondary index values to the secondary index manager

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e2cc92b . . 6ba5e7a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 1 <nl> + * Add support for custom 2i validation ( CASSANDRA - 7575 ) <nl> * Pig support for hadoop CqlInputFormat ( CASSANDRA - 6454 ) <nl> * Add listen _ interface and rpc _ interface options ( CASSANDRA - 7417 ) <nl> * Improve schema merge performance ( CASSANDRA - 7444 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index e4ef0a8 . . 45dd77e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 36 , 6 + 36 , 7 @ @ import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . filter . * ; <nl> + import org . apache . cassandra . db . index . SecondaryIndexManager ; <nl> import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . dht . * ; <nl> import org . apache . cassandra . exceptions . * ; <nl> @ @ - 357 , 7 + 358 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> if ( filter = = null ) <nl> return null ; <nl> <nl> - List < IndexExpression > expressions = getIndexExpressions ( options ) ; <nl> + List < IndexExpression > expressions = getValidatedIndexExpressions ( options ) ; <nl> / / The LIMIT provided by the user is the number of CQL row he wants returned . <nl> / / We want to have getRangeSlice to count the number of columns , not the number of keys . <nl> AbstractBounds < RowPosition > keyBounds = getKeyBounds ( options ) ; <nl> @ @ - 1012 , 7 + 1013 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> return buildBound ( b , cfm . clusteringColumns ( ) , columnRestrictions , isReversed , cfm . comparator , options ) ; <nl> } <nl> <nl> - public List < IndexExpression > getIndexExpressions ( QueryOptions options ) throws InvalidRequestException <nl> + public List < IndexExpression > getValidatedIndexExpressions ( QueryOptions options ) throws InvalidRequestException <nl> { <nl> if ( ! usesSecondaryIndexing | | restrictedColumns . isEmpty ( ) ) <nl> return Collections . emptyList ( ) ; <nl> @ @ - 1081 , 6 + 1082 , 14 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> expressions . add ( new IndexExpression ( def . name . bytes , IndexExpression . Operator . EQ , value ) ) ; <nl> } <nl> } <nl> + <nl> + if ( usesSecondaryIndexing ) <nl> + { <nl> + ColumnFamilyStore cfs = Keyspace . open ( keyspace ( ) ) . getColumnFamilyStore ( columnFamily ( ) ) ; <nl> + SecondaryIndexManager secondaryIndexManager = cfs . indexManager ; <nl> + secondaryIndexManager . validateIndexSearchersForQuery ( expressions ) ; <nl> + } <nl> + <nl> return expressions ; <nl> } <nl> <nl> @ @ - 1858 , 7 + 1867 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> / / the static parts . But 1 ) we don ' t have an easy way to do that with 2i and 2 ) since we don ' t support index on static columns <nl> / / so far , 2i means that you ' ve restricted a non static column , so the query is somewhat non - sensical . <nl> if ( stmt . selectsOnlyStaticColumns ) <nl> - throw new InvalidRequestException ( " Queries using 2ndary indexes don ' t support selecting only static columns " ) ; <nl> + throw new InvalidRequestException ( " Queries using 2ndary indexes don ' t support selecting only static columns " ) ; <nl> } <nl> <nl> private void verifyOrderingIsAllowed ( SelectStatement stmt ) throws InvalidRequestException <nl> diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> index edb9126 . . 669f651 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> @ @ - 50 , 6 + 50 , 7 @ @ import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . composites . CellName ; <nl> import org . apache . cassandra . db . filter . ExtendedFilter ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . io . sstable . ReducingKeyIterator ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> @ @ - 563 , 6 + 564 , 52 @ @ public class SecondaryIndexManager <nl> } <nl> <nl> / * * <nl> + * Validates an union of expression index types . It will throw a { @ link RuntimeException } if <nl> + * any of the expressions in the provided clause is not valid for its index implementation . <nl> + * @ param clause the query clause <nl> + * @ throws org . apache . cassandra . exceptions . InvalidRequestException in case of validation errors <nl> + * / <nl> + public void validateIndexSearchersForQuery ( List < IndexExpression > clause ) throws InvalidRequestException <nl> + { <nl> + / / Group by index type <nl> + Map < String , Set < IndexExpression > > expressionsByIndexType = new HashMap < > ( ) ; <nl> + Map < String , Set < ByteBuffer > > columnsByIndexType = new HashMap < > ( ) ; <nl> + for ( IndexExpression indexExpression : clause ) <nl> + { <nl> + SecondaryIndex index = getIndexForColumn ( indexExpression . column ) ; <nl> + <nl> + if ( index = = null ) <nl> + continue ; <nl> + <nl> + String canonicalIndexName = index . getClass ( ) . getCanonicalName ( ) ; <nl> + Set < IndexExpression > expressions = expressionsByIndexType . get ( canonicalIndexName ) ; <nl> + Set < ByteBuffer > columns = columnsByIndexType . get ( canonicalIndexName ) ; <nl> + if ( expressions = = null ) <nl> + { <nl> + expressions = new HashSet < > ( ) ; <nl> + columns = new HashSet < > ( ) ; <nl> + expressionsByIndexType . put ( canonicalIndexName , expressions ) ; <nl> + columnsByIndexType . put ( canonicalIndexName , columns ) ; <nl> + } <nl> + <nl> + expressions . add ( indexExpression ) ; <nl> + columns . add ( indexExpression . column ) ; <nl> + } <nl> + <nl> + / / Validate <nl> + for ( Map . Entry < String , Set < IndexExpression > > expressions : expressionsByIndexType . entrySet ( ) ) <nl> + { <nl> + Set < ByteBuffer > columns = columnsByIndexType . get ( expressions . getKey ( ) ) ; <nl> + SecondaryIndex secondaryIndex = getIndexForColumn ( columns . iterator ( ) . next ( ) ) ; <nl> + SecondaryIndexSearcher searcher = secondaryIndex . createSecondaryIndexSearcher ( columns ) ; <nl> + for ( IndexExpression expression : expressions . getValue ( ) ) <nl> + { <nl> + searcher . validate ( expression ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> * Performs a search across a number of column indexes <nl> * <nl> * @ param filter the column range to restrict to <nl> diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexSearcher . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexSearcher . java <nl> index 395708a . . 1239c29 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexSearcher . java <nl> + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexSearcher . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ import java . util . * ; <nl> <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . filter . ExtendedFilter ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . tracing . Tracing ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> @ @ - 62 , 6 + 63 , 17 @ @ public abstract class SecondaryIndexSearcher <nl> } <nl> return false ; <nl> } <nl> + <nl> + / * * <nl> + * Validates the specified { @ link IndexExpression } . It will throw an { @ link org . apache . cassandra . exceptions . InvalidRequestException } <nl> + * if the provided clause is not valid for the index implementation . <nl> + * <nl> + * @ param indexExpression An { @ link IndexExpression } to be validated <nl> + * @ throws org . apache . cassandra . exceptions . InvalidRequestException in case of validation errors <nl> + * / <nl> + public void validate ( IndexExpression indexExpression ) throws InvalidRequestException <nl> + { <nl> + } <nl> <nl> protected IndexExpression highestSelectivityPredicate ( List < IndexExpression > clause ) <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java b / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java <nl> index 158dd2c . . c6a80ea 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java <nl> @ @ - 18 , 8 + 18 , 11 @ @ <nl> package org . apache . cassandra . db . index ; <nl> <nl> <nl> + import java . io . IOException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . Arrays ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> import java . util . Set ; <nl> <nl> import org . junit . Before ; <nl> @ @ - 28 , 14 + 31 , 16 @ @ import org . junit . Test ; <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - import org . apache . cassandra . db . Cell ; <nl> - import org . apache . cassandra . db . ColumnFamily ; <nl> - import org . apache . cassandra . db . ColumnFamilyStore ; <nl> - import org . apache . cassandra . db . DecoratedKey ; <nl> - import org . apache . cassandra . db . Mutation ; <nl> + import org . apache . cassandra . cql3 . QueryProcessor ; <nl> + import org . apache . cassandra . cql3 . UntypedResultSet ; <nl> + import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . db . columniterator . IdentityQueryFilter ; <nl> import org . apache . cassandra . db . composites . CellName ; <nl> + import org . apache . cassandra . db . filter . ExtendedFilter ; <nl> import org . apache . cassandra . db . filter . QueryFilter ; <nl> + import org . apache . cassandra . db . marshal . UTF8Type ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> <nl> @ @ - 114 , 6 + 119 , 30 @ @ public class PerRowSecondaryIndexTest extends SchemaLoader <nl> <nl> assertTrue ( Arrays . equals ( " k3 " . getBytes ( ) , PerRowSecondaryIndexTest . TestIndex . LAST _ INDEXED _ KEY . array ( ) ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testInvalidSearch ( ) throws IOException <nl> + { <nl> + Mutation rm ; <nl> + rm = new Mutation ( " PerRowSecondaryIndex " , ByteBufferUtil . bytes ( " k4 " ) ) ; <nl> + rm . add ( " Indexed1 " , Util . cellname ( " indexed " ) , ByteBufferUtil . bytes ( " foo " ) , 1 ) ; <nl> + rm . apply ( ) ; <nl> + <nl> + / / test we can search : <nl> + UntypedResultSet result = QueryProcessor . executeInternal ( " SELECT * FROM \ " PerRowSecondaryIndex \ " . \ " Indexed1 \ " WHERE indexed = ' foo ' " ) ; <nl> + assertEquals ( 1 , result . size ( ) ) ; <nl> + <nl> + / / test we can ' t search if the searcher doesn ' t validate the expression : <nl> + try <nl> + { <nl> + QueryProcessor . executeInternal ( " SELECT * FROM \ " PerRowSecondaryIndex \ " . \ " Indexed1 \ " WHERE indexed = ' invalid ' " ) ; <nl> + fail ( " Query should have been invalid ! " ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + assertTrue ( e instanceof InvalidRequestException | | ( e . getCause ( ) ! = null & & ( e . getCause ( ) instanceof InvalidRequestException ) ) ) ; <nl> + } <nl> + } <nl> <nl> public static class TestIndex extends PerRowSecondaryIndex <nl> { <nl> @ @ - 165 , 7 + 194 , 23 @ @ public class PerRowSecondaryIndexTest extends SchemaLoader <nl> @ Override <nl> protected SecondaryIndexSearcher createSecondaryIndexSearcher ( Set < ByteBuffer > columns ) <nl> { <nl> - return null ; <nl> + return new SecondaryIndexSearcher ( baseCfs . indexManager , columns ) <nl> + { <nl> + <nl> + @ Override <nl> + public List < Row > search ( ExtendedFilter filter ) <nl> + { <nl> + return Arrays . asList ( new Row ( LAST _ INDEXED _ KEY , LAST _ INDEXED _ ROW ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void validate ( IndexExpression indexExpression ) throws InvalidRequestException <nl> + { <nl> + if ( indexExpression . value . equals ( ByteBufferUtil . bytes ( " invalid " ) ) ) <nl> + throw new InvalidRequestException ( " Invalid search ! " ) ; <nl> + } <nl> + <nl> + } ; <nl> } <nl> <nl> @ Override <nl> @ @ - 176 , 7 + 221 , 7 @ @ public class PerRowSecondaryIndexTest extends SchemaLoader <nl> @ Override <nl> public ColumnFamilyStore getIndexCfs ( ) <nl> { <nl> - return null ; <nl> + return baseCfs ; <nl> } <nl> <nl> @ Override
NEAREST DIFF (one line): diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index c67a818 . . c4b35fc 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 329 , 6 + 329 , 9 @ @ class NoKeyspaceError ( Exception ) : <nl> class KeyspaceNotFound ( Exception ) : <nl> pass <nl> <nl> + class ColumnFamilyNotFound ( Exception ) : <nl> + pass <nl> + <nl> class VersionNotSupported ( Exception ) : <nl> pass <nl> <nl> @ @ - 678 , 6 + 681 , 8 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> def fetchdict ( self ) : <nl> row = self . cursor . fetchone ( ) <nl> + if row is None : <nl> + return None <nl> desc = self . cursor . description <nl> return dict ( zip ( [ d [ 0 ] for d in desc ] , row ) ) <nl> <nl> @ @ - 705 , 7 + 710 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> for c in cf _ defs : <nl> if c . name = = cfname : <nl> return c <nl> - raise KeyError ( " Unconfigured column family % r " % ( cfname , ) ) <nl> + raise ColumnFamilyNotFound ( " Unconfigured column family % r " % ( cfname , ) ) <nl> <nl> def get _ columnfamily _ names ( self , ksname = None ) : <nl> return [ c . name for c in self . get _ columnfamilies ( ksname ) ] <nl> @ @ - 800 , 6 + 805 , 8 @ @ class Shell ( cmd . Cmd ) : <nl> where " keyspace " = : ks and " columnfamily " = : cf " " " , <nl> { ' ks ' : ksname , ' cf ' : cfname } ) <nl> layout = self . fetchdict ( ) <nl> + if layout is None : <nl> + raise ColumnFamilyNotFound ( " Column family % r not found " % cfname ) <nl> self . cursor . execute ( " " " select * from system . schema _ columns <nl> where " keyspace " = : ks and " columnfamily " = : cf " " " , <nl> { ' ks ' : ksname , ' cf ' : cfname } )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e2cc92b . . 6ba5e7a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 1 
 + * Add support for custom 2i validation ( CASSANDRA - 7575 ) 
 * Pig support for hadoop CqlInputFormat ( CASSANDRA - 6454 ) 
 * Add listen _ interface and rpc _ interface options ( CASSANDRA - 7417 ) 
 * Improve schema merge performance ( CASSANDRA - 7444 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index e4ef0a8 . . 45dd77e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 36 , 6 + 36 , 7 @ @ import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ColumnDefinition ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . filter . * ; 
 + import org . apache . cassandra . db . index . SecondaryIndexManager ; 
 import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . dht . * ; 
 import org . apache . cassandra . exceptions . * ; 
 @ @ - 357 , 7 + 358 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 if ( filter = = null ) 
 return null ; 
 
 - List < IndexExpression > expressions = getIndexExpressions ( options ) ; 
 + List < IndexExpression > expressions = getValidatedIndexExpressions ( options ) ; 
 / / The LIMIT provided by the user is the number of CQL row he wants returned . 
 / / We want to have getRangeSlice to count the number of columns , not the number of keys . 
 AbstractBounds < RowPosition > keyBounds = getKeyBounds ( options ) ; 
 @ @ - 1012 , 7 + 1013 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 return buildBound ( b , cfm . clusteringColumns ( ) , columnRestrictions , isReversed , cfm . comparator , options ) ; 
 } 
 
 - public List < IndexExpression > getIndexExpressions ( QueryOptions options ) throws InvalidRequestException 
 + public List < IndexExpression > getValidatedIndexExpressions ( QueryOptions options ) throws InvalidRequestException 
 { 
 if ( ! usesSecondaryIndexing | | restrictedColumns . isEmpty ( ) ) 
 return Collections . emptyList ( ) ; 
 @ @ - 1081 , 6 + 1082 , 14 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 expressions . add ( new IndexExpression ( def . name . bytes , IndexExpression . Operator . EQ , value ) ) ; 
 } 
 } 
 + 
 + if ( usesSecondaryIndexing ) 
 + { 
 + ColumnFamilyStore cfs = Keyspace . open ( keyspace ( ) ) . getColumnFamilyStore ( columnFamily ( ) ) ; 
 + SecondaryIndexManager secondaryIndexManager = cfs . indexManager ; 
 + secondaryIndexManager . validateIndexSearchersForQuery ( expressions ) ; 
 + } 
 + 
 return expressions ; 
 } 
 
 @ @ - 1858 , 7 + 1867 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 / / the static parts . But 1 ) we don ' t have an easy way to do that with 2i and 2 ) since we don ' t support index on static columns 
 / / so far , 2i means that you ' ve restricted a non static column , so the query is somewhat non - sensical . 
 if ( stmt . selectsOnlyStaticColumns ) 
 - throw new InvalidRequestException ( " Queries using 2ndary indexes don ' t support selecting only static columns " ) ; 
 + throw new InvalidRequestException ( " Queries using 2ndary indexes don ' t support selecting only static columns " ) ; 
 } 
 
 private void verifyOrderingIsAllowed ( SelectStatement stmt ) throws InvalidRequestException 
 diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 index edb9126 . . 669f651 100644 
 - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 @ @ - 50 , 6 + 50 , 7 @ @ import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . composites . CellName ; 
 import org . apache . cassandra . db . filter . ExtendedFilter ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . io . sstable . ReducingKeyIterator ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 @ @ - 563 , 6 + 564 , 52 @ @ public class SecondaryIndexManager 
 } 
 
 / * * 
 + * Validates an union of expression index types . It will throw a { @ link RuntimeException } if 
 + * any of the expressions in the provided clause is not valid for its index implementation . 
 + * @ param clause the query clause 
 + * @ throws org . apache . cassandra . exceptions . InvalidRequestException in case of validation errors 
 + * / 
 + public void validateIndexSearchersForQuery ( List < IndexExpression > clause ) throws InvalidRequestException 
 + { 
 + / / Group by index type 
 + Map < String , Set < IndexExpression > > expressionsByIndexType = new HashMap < > ( ) ; 
 + Map < String , Set < ByteBuffer > > columnsByIndexType = new HashMap < > ( ) ; 
 + for ( IndexExpression indexExpression : clause ) 
 + { 
 + SecondaryIndex index = getIndexForColumn ( indexExpression . column ) ; 
 + 
 + if ( index = = null ) 
 + continue ; 
 + 
 + String canonicalIndexName = index . getClass ( ) . getCanonicalName ( ) ; 
 + Set < IndexExpression > expressions = expressionsByIndexType . get ( canonicalIndexName ) ; 
 + Set < ByteBuffer > columns = columnsByIndexType . get ( canonicalIndexName ) ; 
 + if ( expressions = = null ) 
 + { 
 + expressions = new HashSet < > ( ) ; 
 + columns = new HashSet < > ( ) ; 
 + expressionsByIndexType . put ( canonicalIndexName , expressions ) ; 
 + columnsByIndexType . put ( canonicalIndexName , columns ) ; 
 + } 
 + 
 + expressions . add ( indexExpression ) ; 
 + columns . add ( indexExpression . column ) ; 
 + } 
 + 
 + / / Validate 
 + for ( Map . Entry < String , Set < IndexExpression > > expressions : expressionsByIndexType . entrySet ( ) ) 
 + { 
 + Set < ByteBuffer > columns = columnsByIndexType . get ( expressions . getKey ( ) ) ; 
 + SecondaryIndex secondaryIndex = getIndexForColumn ( columns . iterator ( ) . next ( ) ) ; 
 + SecondaryIndexSearcher searcher = secondaryIndex . createSecondaryIndexSearcher ( columns ) ; 
 + for ( IndexExpression expression : expressions . getValue ( ) ) 
 + { 
 + searcher . validate ( expression ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 * Performs a search across a number of column indexes 
 * 
 * @ param filter the column range to restrict to 
 diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexSearcher . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexSearcher . java 
 index 395708a . . 1239c29 100644 
 - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexSearcher . java 
 + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexSearcher . java 
 @ @ - 22 , 6 + 22 , 7 @ @ import java . util . * ; 
 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . filter . ExtendedFilter ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . tracing . Tracing ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 @ @ - 62 , 6 + 63 , 17 @ @ public abstract class SecondaryIndexSearcher 
 } 
 return false ; 
 } 
 + 
 + / * * 
 + * Validates the specified { @ link IndexExpression } . It will throw an { @ link org . apache . cassandra . exceptions . InvalidRequestException } 
 + * if the provided clause is not valid for the index implementation . 
 + * 
 + * @ param indexExpression An { @ link IndexExpression } to be validated 
 + * @ throws org . apache . cassandra . exceptions . InvalidRequestException in case of validation errors 
 + * / 
 + public void validate ( IndexExpression indexExpression ) throws InvalidRequestException 
 + { 
 + } 
 
 protected IndexExpression highestSelectivityPredicate ( List < IndexExpression > clause ) 
 { 
 diff - - git a / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java b / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java 
 index 158dd2c . . c6a80ea 100644 
 - - - a / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java 
 + + + b / test / unit / org / apache / cassandra / db / index / PerRowSecondaryIndexTest . java 
 @ @ - 18 , 8 + 18 , 11 @ @ 
 package org . apache . cassandra . db . index ; 
 
 
 + import java . io . IOException ; 
 import java . nio . ByteBuffer ; 
 import java . util . Arrays ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 import java . util . Set ; 
 
 import org . junit . Before ; 
 @ @ - 28 , 14 + 31 , 16 @ @ import org . junit . Test ; 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . Util ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 - import org . apache . cassandra . db . Cell ; 
 - import org . apache . cassandra . db . ColumnFamily ; 
 - import org . apache . cassandra . db . ColumnFamilyStore ; 
 - import org . apache . cassandra . db . DecoratedKey ; 
 - import org . apache . cassandra . db . Mutation ; 
 + import org . apache . cassandra . cql3 . QueryProcessor ; 
 + import org . apache . cassandra . cql3 . UntypedResultSet ; 
 + import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . db . columniterator . IdentityQueryFilter ; 
 import org . apache . cassandra . db . composites . CellName ; 
 + import org . apache . cassandra . db . filter . ExtendedFilter ; 
 import org . apache . cassandra . db . filter . QueryFilter ; 
 + import org . apache . cassandra . db . marshal . UTF8Type ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . concurrent . OpOrder ; 
 
 @ @ - 114 , 6 + 119 , 30 @ @ public class PerRowSecondaryIndexTest extends SchemaLoader 
 
 assertTrue ( Arrays . equals ( " k3 " . getBytes ( ) , PerRowSecondaryIndexTest . TestIndex . LAST _ INDEXED _ KEY . array ( ) ) ) ; 
 } 
 + 
 + @ Test 
 + public void testInvalidSearch ( ) throws IOException 
 + { 
 + Mutation rm ; 
 + rm = new Mutation ( " PerRowSecondaryIndex " , ByteBufferUtil . bytes ( " k4 " ) ) ; 
 + rm . add ( " Indexed1 " , Util . cellname ( " indexed " ) , ByteBufferUtil . bytes ( " foo " ) , 1 ) ; 
 + rm . apply ( ) ; 
 + 
 + / / test we can search : 
 + UntypedResultSet result = QueryProcessor . executeInternal ( " SELECT * FROM \ " PerRowSecondaryIndex \ " . \ " Indexed1 \ " WHERE indexed = ' foo ' " ) ; 
 + assertEquals ( 1 , result . size ( ) ) ; 
 + 
 + / / test we can ' t search if the searcher doesn ' t validate the expression : 
 + try 
 + { 
 + QueryProcessor . executeInternal ( " SELECT * FROM \ " PerRowSecondaryIndex \ " . \ " Indexed1 \ " WHERE indexed = ' invalid ' " ) ; 
 + fail ( " Query should have been invalid ! " ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + assertTrue ( e instanceof InvalidRequestException | | ( e . getCause ( ) ! = null & & ( e . getCause ( ) instanceof InvalidRequestException ) ) ) ; 
 + } 
 + } 
 
 public static class TestIndex extends PerRowSecondaryIndex 
 { 
 @ @ - 165 , 7 + 194 , 23 @ @ public class PerRowSecondaryIndexTest extends SchemaLoader 
 @ Override 
 protected SecondaryIndexSearcher createSecondaryIndexSearcher ( Set < ByteBuffer > columns ) 
 { 
 - return null ; 
 + return new SecondaryIndexSearcher ( baseCfs . indexManager , columns ) 
 + { 
 + 
 + @ Override 
 + public List < Row > search ( ExtendedFilter filter ) 
 + { 
 + return Arrays . asList ( new Row ( LAST _ INDEXED _ KEY , LAST _ INDEXED _ ROW ) ) ; 
 + } 
 + 
 + @ Override 
 + public void validate ( IndexExpression indexExpression ) throws InvalidRequestException 
 + { 
 + if ( indexExpression . value . equals ( ByteBufferUtil . bytes ( " invalid " ) ) ) 
 + throw new InvalidRequestException ( " Invalid search ! " ) ; 
 + } 
 + 
 + } ; 
 } 
 
 @ Override 
 @ @ - 176 , 7 + 221 , 7 @ @ public class PerRowSecondaryIndexTest extends SchemaLoader 
 @ Override 
 public ColumnFamilyStore getIndexCfs ( ) 
 { 
 - return null ; 
 + return baseCfs ; 
 } 
 
 @ Override

NEAREST DIFF:
diff - - git a / bin / cqlsh b / bin / cqlsh 
 index c67a818 . . c4b35fc 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 329 , 6 + 329 , 9 @ @ class NoKeyspaceError ( Exception ) : 
 class KeyspaceNotFound ( Exception ) : 
 pass 
 
 + class ColumnFamilyNotFound ( Exception ) : 
 + pass 
 + 
 class VersionNotSupported ( Exception ) : 
 pass 
 
 @ @ - 678 , 6 + 681 , 8 @ @ class Shell ( cmd . Cmd ) : 
 
 def fetchdict ( self ) : 
 row = self . cursor . fetchone ( ) 
 + if row is None : 
 + return None 
 desc = self . cursor . description 
 return dict ( zip ( [ d [ 0 ] for d in desc ] , row ) ) 
 
 @ @ - 705 , 7 + 710 , 7 @ @ class Shell ( cmd . Cmd ) : 
 for c in cf _ defs : 
 if c . name = = cfname : 
 return c 
 - raise KeyError ( " Unconfigured column family % r " % ( cfname , ) ) 
 + raise ColumnFamilyNotFound ( " Unconfigured column family % r " % ( cfname , ) ) 
 
 def get _ columnfamily _ names ( self , ksname = None ) : 
 return [ c . name for c in self . get _ columnfamilies ( ksname ) ] 
 @ @ - 800 , 6 + 805 , 8 @ @ class Shell ( cmd . Cmd ) : 
 where " keyspace " = : ks and " columnfamily " = : cf " " " , 
 { ' ks ' : ksname , ' cf ' : cfname } ) 
 layout = self . fetchdict ( ) 
 + if layout is None : 
 + raise ColumnFamilyNotFound ( " Column family % r not found " % cfname ) 
 self . cursor . execute ( " " " select * from system . schema _ columns 
 where " keyspace " = : ks and " columnfamily " = : cf " " " , 
 { ' ks ' : ksname , ' cf ' : cfname } )
