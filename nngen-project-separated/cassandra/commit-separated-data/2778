BLEU SCORE: 0.010738456044579523

TEST MSG: don ' t use commons - lang and commons - lang3 at the same time - > 3
GENERATED MSG: document reference to # 1938

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / IterableCqlPagingRecordReader . java b / src / java / org / apache / cassandra / hadoop / cql3 / IterableCqlPagingRecordReader . java <nl> index 85beed9 . . d7348b0 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / cql3 / IterableCqlPagingRecordReader . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / IterableCqlPagingRecordReader . java <nl> @ @ - 23 , 8 + 23 , 6 @ @ import java . nio . ByteBuffer ; <nl> import java . util . Iterator ; <nl> import java . util . Map ; <nl> <nl> - import org . apache . commons . lang . NotImplementedException ; <nl> - <nl> import org . apache . cassandra . utils . Pair ; <nl> <nl> / * * <nl> @ @ - 49 , 7 + 47 , 7 @ @ public class IterableCqlPagingRecordReader extends CqlPagingRecordReader <nl> <nl> public void remove ( ) <nl> { <nl> - throw new NotImplementedException ( " Cannot remove an element on this iterator ! " ) ; <nl> + throw new UnsupportedOperationException ( " Cannot remove an element on this iterator ! " ) ; <nl> <nl> } <nl> } ; <nl> @ @ - 61 , 7 + 59 , 7 @ @ public class IterableCqlPagingRecordReader extends CqlPagingRecordReader <nl> @ Override <nl> public boolean nextKeyValue ( ) throws IOException <nl> { <nl> - throw new NotImplementedException ( " Calling method nextKeyValue ( ) does not make sense in this implementation " ) ; <nl> + throw new UnsupportedOperationException ( " Calling method nextKeyValue ( ) does not make sense in this implementation " ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 70 , 6 + 68 , 6 @ @ public class IterableCqlPagingRecordReader extends CqlPagingRecordReader <nl> @ Override <nl> public boolean next ( Map < String , ByteBuffer > keys , Map < String , ByteBuffer > value ) throws IOException <nl> { <nl> - throw new NotImplementedException ( " Calling method next ( ) does not make sense in this implementation " ) ; <nl> + throw new UnsupportedOperationException ( " Calling method next ( ) does not make sense in this implementation " ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / utils / ByteBufferUtil . java b / src / java / org / apache / cassandra / utils / ByteBufferUtil . java <nl> index 491f1fb . . 20abaee 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / ByteBufferUtil . java <nl> + + + b / src / java / org / apache / cassandra / utils / ByteBufferUtil . java <nl> @ @ - 190 , 7 + 190 , 7 @ @ public class ByteBufferUtil <nl> } <nl> <nl> / * * <nl> - * ByteBuffer adaptation of org . apache . commons . lang . ArrayUtils . lastIndexOf method <nl> + * ByteBuffer adaptation of org . apache . commons . lang3 . ArrayUtils . lastIndexOf method <nl> * <nl> * @ param buffer the array to traverse for looking for the object , may be < code > null < / code > <nl> * @ param valueToFind the value to find
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ee149c8 . . f0e762c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 25 , 6 + 25 , 7 @ @ <nl> ( CASSANDRA - 3538 ) <nl> * Improve memtable slice iteration performance ( CASSANDRA - 3545 ) <nl> * more efficient allocation of small bloom filters ( CASSANDRA - 3618 ) <nl> + * Use separate writer thread in SSTableSimpleUnsortedWriter ( CASSANDRA - 3619 ) <nl> <nl> <nl> 1 . 0 . 7 <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java <nl> index 40e37e2 . . 472f6c7 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java <nl> @ @ - 23 , 6 + 23 , 9 @ @ import java . io . IOException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . Map ; <nl> import java . util . TreeMap ; <nl> + import java . util . concurrent . BlockingQueue ; <nl> + import java . util . concurrent . SynchronousQueue ; <nl> + import java . util . concurrent . locks . Condition ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . db . * ; <nl> @ @ - 31 , 6 + 34 , 7 @ @ import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . HeapAllocator ; <nl> <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . SimpleCondition ; <nl> <nl> / * * <nl> * A SSTable writer that doesn ' t assume rows are in sorted order . <nl> @ @ - 43 , 10 + 47 , 15 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; <nl> * / <nl> public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter <nl> { <nl> - private final Map < DecoratedKey , ColumnFamily > keys = new TreeMap < DecoratedKey , ColumnFamily > ( ) ; <nl> + private static final Buffer SENTINEL = new Buffer ( ) ; <nl> + <nl> + private Buffer buffer = new Buffer ( ) ; <nl> private final long bufferSize ; <nl> private long currentSize ; <nl> <nl> + private final BlockingQueue < Buffer > writeQueue = new SynchronousQueue < Buffer > ( ) ; <nl> + private final DiskWriter diskWriter = new DiskWriter ( ) ; <nl> + <nl> / * * <nl> * Create a new buffering writer . <nl> * @ param directory the directory where to write the sstables <nl> @ @ - 67 , 6 + 76 , 7 @ @ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter <nl> { <nl> super ( directory , new CFMetaData ( keyspace , columnFamily , subComparator = = null ? ColumnFamilyType . Standard : ColumnFamilyType . Super , comparator , subComparator ) ) ; <nl> this . bufferSize = bufferSizeInMB * 1024L * 1024L ; <nl> + this . diskWriter . start ( ) ; <nl> } <nl> <nl> protected void writeRow ( DecoratedKey key , ColumnFamily columnFamily ) throws IOException <nl> @ @ - 79 , 12 + 89 , 12 @ @ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter <nl> <nl> protected ColumnFamily getColumnFamily ( ) <nl> { <nl> - ColumnFamily previous = keys . get ( currentKey ) ; <nl> + ColumnFamily previous = buffer . get ( currentKey ) ; <nl> / / If the CF already exist in memory , we ' ll just continue adding to it <nl> if ( previous = = null ) <nl> { <nl> previous = ColumnFamily . create ( metadata , TreeMapBackedSortedColumns . factory ( ) ) ; <nl> - keys . put ( currentKey , previous ) ; <nl> + buffer . put ( currentKey , previous ) ; <nl> } <nl> else <nl> { <nl> @ @ - 98 , 20 + 108 , 77 @ @ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter <nl> public void close ( ) throws IOException <nl> { <nl> sync ( ) ; <nl> + try <nl> + { <nl> + writeQueue . put ( SENTINEL ) ; <nl> + diskWriter . join ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + <nl> + checkForWriterException ( ) ; <nl> } <nl> <nl> private void sync ( ) throws IOException <nl> { <nl> - if ( keys . isEmpty ( ) ) <nl> + if ( buffer . isEmpty ( ) ) <nl> return ; <nl> <nl> - SSTableWriter writer = getWriter ( ) ; <nl> - for ( Map . Entry < DecoratedKey , ColumnFamily > entry : keys . entrySet ( ) ) <nl> + checkForWriterException ( ) ; <nl> + <nl> + try <nl> + { <nl> + writeQueue . put ( buffer ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> { <nl> - writer . append ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + throw new RuntimeException ( e ) ; <nl> } <nl> - writer . closeAndOpenReader ( ) ; <nl> + buffer = new Buffer ( ) ; <nl> currentSize = 0 ; <nl> - keys . clear ( ) ; <nl> + } <nl> + <nl> + private void checkForWriterException ( ) throws IOException <nl> + { <nl> + / / slightly lame way to report exception from the writer , but that should be good enough <nl> + if ( diskWriter . exception ! = null ) <nl> + { <nl> + if ( diskWriter . exception instanceof IOException ) <nl> + throw ( IOException ) diskWriter . exception ; <nl> + else <nl> + throw new RuntimeException ( diskWriter . exception ) ; <nl> + } <nl> + } <nl> + <nl> + / / typedef <nl> + private static class Buffer extends TreeMap < DecoratedKey , ColumnFamily > { } <nl> + <nl> + private class DiskWriter extends Thread <nl> + { <nl> + volatile Exception exception = null ; <nl> + <nl> + public void run ( ) <nl> + { <nl> + try <nl> + { <nl> + while ( true ) <nl> + { <nl> + Buffer b = writeQueue . take ( ) ; <nl> + if ( b = = SENTINEL ) <nl> + return ; <nl> + <nl> + SSTableWriter writer = getWriter ( ) ; <nl> + for ( Map . Entry < DecoratedKey , ColumnFamily > entry : b . entrySet ( ) ) <nl> + writer . append ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + writer . closeAndOpenReader ( ) ; <nl> + } <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + exception = e ; <nl> + } <nl> + } <nl> } <nl> }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / IterableCqlPagingRecordReader . java b / src / java / org / apache / cassandra / hadoop / cql3 / IterableCqlPagingRecordReader . java 
 index 85beed9 . . d7348b0 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / cql3 / IterableCqlPagingRecordReader . java 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / IterableCqlPagingRecordReader . java 
 @ @ - 23 , 8 + 23 , 6 @ @ import java . nio . ByteBuffer ; 
 import java . util . Iterator ; 
 import java . util . Map ; 
 
 - import org . apache . commons . lang . NotImplementedException ; 
 - 
 import org . apache . cassandra . utils . Pair ; 
 
 / * * 
 @ @ - 49 , 7 + 47 , 7 @ @ public class IterableCqlPagingRecordReader extends CqlPagingRecordReader 
 
 public void remove ( ) 
 { 
 - throw new NotImplementedException ( " Cannot remove an element on this iterator ! " ) ; 
 + throw new UnsupportedOperationException ( " Cannot remove an element on this iterator ! " ) ; 
 
 } 
 } ; 
 @ @ - 61 , 7 + 59 , 7 @ @ public class IterableCqlPagingRecordReader extends CqlPagingRecordReader 
 @ Override 
 public boolean nextKeyValue ( ) throws IOException 
 { 
 - throw new NotImplementedException ( " Calling method nextKeyValue ( ) does not make sense in this implementation " ) ; 
 + throw new UnsupportedOperationException ( " Calling method nextKeyValue ( ) does not make sense in this implementation " ) ; 
 } 
 
 / * * 
 @ @ - 70 , 6 + 68 , 6 @ @ public class IterableCqlPagingRecordReader extends CqlPagingRecordReader 
 @ Override 
 public boolean next ( Map < String , ByteBuffer > keys , Map < String , ByteBuffer > value ) throws IOException 
 { 
 - throw new NotImplementedException ( " Calling method next ( ) does not make sense in this implementation " ) ; 
 + throw new UnsupportedOperationException ( " Calling method next ( ) does not make sense in this implementation " ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / utils / ByteBufferUtil . java b / src / java / org / apache / cassandra / utils / ByteBufferUtil . java 
 index 491f1fb . . 20abaee 100644 
 - - - a / src / java / org / apache / cassandra / utils / ByteBufferUtil . java 
 + + + b / src / java / org / apache / cassandra / utils / ByteBufferUtil . java 
 @ @ - 190 , 7 + 190 , 7 @ @ public class ByteBufferUtil 
 } 
 
 / * * 
 - * ByteBuffer adaptation of org . apache . commons . lang . ArrayUtils . lastIndexOf method 
 + * ByteBuffer adaptation of org . apache . commons . lang3 . ArrayUtils . lastIndexOf method 
 * 
 * @ param buffer the array to traverse for looking for the object , may be < code > null < / code > 
 * @ param valueToFind the value to find

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ee149c8 . . f0e762c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 25 , 6 + 25 , 7 @ @ 
 ( CASSANDRA - 3538 ) 
 * Improve memtable slice iteration performance ( CASSANDRA - 3545 ) 
 * more efficient allocation of small bloom filters ( CASSANDRA - 3618 ) 
 + * Use separate writer thread in SSTableSimpleUnsortedWriter ( CASSANDRA - 3619 ) 
 
 
 1 . 0 . 7 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java 
 index 40e37e2 . . 472f6c7 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java 
 @ @ - 23 , 6 + 23 , 9 @ @ import java . io . IOException ; 
 import java . nio . ByteBuffer ; 
 import java . util . Map ; 
 import java . util . TreeMap ; 
 + import java . util . concurrent . BlockingQueue ; 
 + import java . util . concurrent . SynchronousQueue ; 
 + import java . util . concurrent . locks . Condition ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . db . * ; 
 @ @ - 31 , 6 + 34 , 7 @ @ import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . HeapAllocator ; 
 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . SimpleCondition ; 
 
 / * * 
 * A SSTable writer that doesn ' t assume rows are in sorted order . 
 @ @ - 43 , 10 + 47 , 15 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; 
 * / 
 public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter 
 { 
 - private final Map < DecoratedKey , ColumnFamily > keys = new TreeMap < DecoratedKey , ColumnFamily > ( ) ; 
 + private static final Buffer SENTINEL = new Buffer ( ) ; 
 + 
 + private Buffer buffer = new Buffer ( ) ; 
 private final long bufferSize ; 
 private long currentSize ; 
 
 + private final BlockingQueue < Buffer > writeQueue = new SynchronousQueue < Buffer > ( ) ; 
 + private final DiskWriter diskWriter = new DiskWriter ( ) ; 
 + 
 / * * 
 * Create a new buffering writer . 
 * @ param directory the directory where to write the sstables 
 @ @ - 67 , 6 + 76 , 7 @ @ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter 
 { 
 super ( directory , new CFMetaData ( keyspace , columnFamily , subComparator = = null ? ColumnFamilyType . Standard : ColumnFamilyType . Super , comparator , subComparator ) ) ; 
 this . bufferSize = bufferSizeInMB * 1024L * 1024L ; 
 + this . diskWriter . start ( ) ; 
 } 
 
 protected void writeRow ( DecoratedKey key , ColumnFamily columnFamily ) throws IOException 
 @ @ - 79 , 12 + 89 , 12 @ @ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter 
 
 protected ColumnFamily getColumnFamily ( ) 
 { 
 - ColumnFamily previous = keys . get ( currentKey ) ; 
 + ColumnFamily previous = buffer . get ( currentKey ) ; 
 / / If the CF already exist in memory , we ' ll just continue adding to it 
 if ( previous = = null ) 
 { 
 previous = ColumnFamily . create ( metadata , TreeMapBackedSortedColumns . factory ( ) ) ; 
 - keys . put ( currentKey , previous ) ; 
 + buffer . put ( currentKey , previous ) ; 
 } 
 else 
 { 
 @ @ - 98 , 20 + 108 , 77 @ @ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter 
 public void close ( ) throws IOException 
 { 
 sync ( ) ; 
 + try 
 + { 
 + writeQueue . put ( SENTINEL ) ; 
 + diskWriter . join ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + 
 + checkForWriterException ( ) ; 
 } 
 
 private void sync ( ) throws IOException 
 { 
 - if ( keys . isEmpty ( ) ) 
 + if ( buffer . isEmpty ( ) ) 
 return ; 
 
 - SSTableWriter writer = getWriter ( ) ; 
 - for ( Map . Entry < DecoratedKey , ColumnFamily > entry : keys . entrySet ( ) ) 
 + checkForWriterException ( ) ; 
 + 
 + try 
 + { 
 + writeQueue . put ( buffer ) ; 
 + } 
 + catch ( InterruptedException e ) 
 { 
 - writer . append ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + throw new RuntimeException ( e ) ; 
 } 
 - writer . closeAndOpenReader ( ) ; 
 + buffer = new Buffer ( ) ; 
 currentSize = 0 ; 
 - keys . clear ( ) ; 
 + } 
 + 
 + private void checkForWriterException ( ) throws IOException 
 + { 
 + / / slightly lame way to report exception from the writer , but that should be good enough 
 + if ( diskWriter . exception ! = null ) 
 + { 
 + if ( diskWriter . exception instanceof IOException ) 
 + throw ( IOException ) diskWriter . exception ; 
 + else 
 + throw new RuntimeException ( diskWriter . exception ) ; 
 + } 
 + } 
 + 
 + / / typedef 
 + private static class Buffer extends TreeMap < DecoratedKey , ColumnFamily > { } 
 + 
 + private class DiskWriter extends Thread 
 + { 
 + volatile Exception exception = null ; 
 + 
 + public void run ( ) 
 + { 
 + try 
 + { 
 + while ( true ) 
 + { 
 + Buffer b = writeQueue . take ( ) ; 
 + if ( b = = SENTINEL ) 
 + return ; 
 + 
 + SSTableWriter writer = getWriter ( ) ; 
 + for ( Map . Entry < DecoratedKey , ColumnFamily > entry : b . entrySet ( ) ) 
 + writer . append ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + writer . closeAndOpenReader ( ) ; 
 + } 
 + } 
 + catch ( Exception e ) 
 + { 
 + exception = e ; 
 + } 
 + } 
 } 
 }
