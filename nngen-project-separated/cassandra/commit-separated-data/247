BLEU SCORE: 0.03214954573057458

TEST MSG: Allow only one concurrent call to StatusLogger
GENERATED MSG: Workaround for netty issue causing corrupted data to come off the wire

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 71f4b1d . . e214177 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Allow only one concurrent call to StatusLogger ( CASSANDRA - 12182 ) <nl> * Refactoring to specialised functional interfaces ( CASSANDRA - 13982 ) <nl> * Speculative retry should allow more friendly params ( CASSANDRA - 13876 ) <nl> * Throw exception if we send / receive repair messages to incompatible nodes ( CASSANDRA - 13944 ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / StatusLogger . java b / src / java / org / apache / cassandra / utils / StatusLogger . java <nl> index c33190b . . 9f9d869 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / StatusLogger . java <nl> + + + b / src / java / org / apache / cassandra / utils / StatusLogger . java <nl> @ @ - 19 , 11 + 19 , 13 @ @ package org . apache . cassandra . utils ; <nl> <nl> import java . lang . management . ManagementFactory ; <nl> import java . util . Map ; <nl> + import java . util . concurrent . locks . ReentrantLock ; <nl> import javax . management . * ; <nl> <nl> import org . apache . cassandra . cache . * ; <nl> <nl> import org . apache . cassandra . metrics . ThreadPoolMetrics ; <nl> + <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 37 , 10 + 39 , 31 @ @ import org . apache . cassandra . service . CacheService ; <nl> public class StatusLogger <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( StatusLogger . class ) ; <nl> - <nl> + private static final ReentrantLock busyMonitor = new ReentrantLock ( ) ; <nl> <nl> public static void log ( ) <nl> { <nl> + / / avoid logging more than once at the same time . throw away any attempts to log concurrently , as it would be <nl> + / / confusing and noisy for operators - and don ' t bother logging again , immediately as it ' ll just be the same data <nl> + if ( busyMonitor . tryLock ( ) ) <nl> + { <nl> + try <nl> + { <nl> + logStatus ( ) ; <nl> + } <nl> + finally <nl> + { <nl> + busyMonitor . unlock ( ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + logger . trace ( " StatusLogger is busy " ) ; <nl> + } <nl> + } <nl> + <nl> + private static void logStatus ( ) <nl> + { <nl> MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; <nl> <nl> / / everything from o . a . c . concurrent <nl> diff - - git a / test / unit / org / apache / cassandra / utils / StatusLoggerTest . java b / test / unit / org / apache / cassandra / utils / StatusLoggerTest . java <nl> new file mode 100644 <nl> index 0000000 . . 878e6e8 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / utils / StatusLoggerTest . java <nl> @ @ - 0 , 0 + 1 , 160 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . Comparator ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Executors ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + import com . google . common . collect . Range ; <nl> + import org . junit . Test ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import ch . qos . logback . classic . Level ; <nl> + import ch . qos . logback . classic . spi . ILoggingEvent ; <nl> + import ch . qos . logback . core . AppenderBase ; <nl> + import org . apache . cassandra . cql3 . CQLTester ; <nl> + <nl> + import static com . google . common . collect . Lists . newArrayList ; <nl> + import static java . util . stream . Collectors . groupingBy ; <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + import static org . junit . Assert . fail ; <nl> + <nl> + public class StatusLoggerTest extends CQLTester <nl> + { <nl> + private static final Logger log = LoggerFactory . getLogger ( StatusLoggerTest . class ) ; <nl> + <nl> + @ Test <nl> + public void testStatusLoggerPrintsStatusOnlyOnceWhenInvokedConcurrently ( ) throws Exception <nl> + { <nl> + ch . qos . logback . classic . Logger logger = ( ch . qos . logback . classic . Logger ) LoggerFactory . getLogger ( StatusLogger . class ) ; <nl> + InMemoryAppender inMemoryAppender = new InMemoryAppender ( ) ; <nl> + logger . addAppender ( inMemoryAppender ) ; <nl> + logger . setLevel ( Level . TRACE ) ; <nl> + try <nl> + { <nl> + submitTwoLogRequestsConcurrently ( ) ; <nl> + verifyOnlySingleStatusWasAppendedConcurrently ( inMemoryAppender . events ) ; <nl> + } <nl> + finally <nl> + { <nl> + assertTrue ( " Could not remove in memory appender " , logger . detachAppender ( inMemoryAppender ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void submitTwoLogRequestsConcurrently ( ) throws InterruptedException <nl> + { <nl> + ExecutorService executorService = Executors . newFixedThreadPool ( 2 ) ; <nl> + executorService . submit ( StatusLogger : : log ) ; <nl> + executorService . submit ( StatusLogger : : log ) ; <nl> + executorService . shutdown ( ) ; <nl> + executorService . awaitTermination ( 1 , TimeUnit . SECONDS ) ; <nl> + } <nl> + <nl> + private void verifyOnlySingleStatusWasAppendedConcurrently ( List < ILoggingEvent > events ) <nl> + { <nl> + Map < String , List < ILoggingEvent > > eventsByThread = events . stream ( ) . collect ( groupingBy ( ILoggingEvent : : getThreadName ) ) ; <nl> + List < String > threadNames = newArrayList ( eventsByThread . keySet ( ) ) ; <nl> + <nl> + assertEquals ( " Expected events from 2 threads only " , 2 , threadNames . size ( ) ) ; <nl> + <nl> + List < ILoggingEvent > firstThreadEvents = eventsByThread . get ( threadNames . get ( 0 ) ) ; <nl> + List < ILoggingEvent > secondThreadEvents = eventsByThread . get ( threadNames . get ( 1 ) ) ; <nl> + <nl> + assertTrue ( " Expected at least one event from the first thread " , firstThreadEvents . size ( ) > = 1 ) ; <nl> + assertTrue ( " Expected at least one event from the second thread " , secondThreadEvents . size ( ) > = 1 ) ; <nl> + <nl> + if ( areDisjunctive ( firstThreadEvents , secondThreadEvents ) ) <nl> + { <nl> + log . debug ( " Event time ranges are disjunctive - log invocations were made one after another " ) ; <nl> + } <nl> + else <nl> + { <nl> + verifyStatusWasPrintedAndBusyEventOccured ( firstThreadEvents , secondThreadEvents ) ; <nl> + } <nl> + } <nl> + <nl> + private boolean areDisjunctive ( List < ILoggingEvent > firstThreadEvents , List < ILoggingEvent > secondThreadEvents ) <nl> + { <nl> + Range < Long > firstThreadTimeRange = timestampsRange ( firstThreadEvents ) ; <nl> + Range < Long > secondThreadTimeRange = timestampsRange ( secondThreadEvents ) ; <nl> + boolean connected = firstThreadTimeRange . isConnected ( secondThreadTimeRange ) ; <nl> + boolean disjunctive = ! connected | | firstThreadTimeRange . intersection ( secondThreadTimeRange ) . isEmpty ( ) ; <nl> + log . debug ( " Time ranges { } , { } , disjunctive = { } " , firstThreadTimeRange , secondThreadTimeRange , disjunctive ) ; <nl> + return disjunctive ; <nl> + } <nl> + <nl> + private Range < Long > timestampsRange ( List < ILoggingEvent > events ) <nl> + { <nl> + List < Long > timestamps = events . stream ( ) . map ( ILoggingEvent : : getTimeStamp ) . collect ( Collectors . toList ( ) ) ; <nl> + Long min = timestamps . stream ( ) . min ( Comparator . naturalOrder ( ) ) . get ( ) ; <nl> + Long max = timestamps . stream ( ) . max ( Comparator . naturalOrder ( ) ) . get ( ) ; <nl> + / / It ' s open on one side to cover a case when second status starts printing at the same timestamp that previous one was finished <nl> + return Range . closedOpen ( min , max ) ; <nl> + } <nl> + <nl> + private void verifyStatusWasPrintedAndBusyEventOccured ( List < ILoggingEvent > firstThreadEvents , List < ILoggingEvent > secondThreadEvents ) <nl> + { <nl> + if ( firstThreadEvents . size ( ) > 1 & & secondThreadEvents . size ( ) > 1 ) <nl> + { <nl> + log . error ( " Both event lists contain more than one entry . First = { } , Second = { } " , firstThreadEvents , secondThreadEvents ) ; <nl> + fail ( " More that one status log was appended concurrently " ) ; <nl> + } <nl> + else if ( firstThreadEvents . size ( ) < = 1 & & secondThreadEvents . size ( ) < = 1 ) <nl> + { <nl> + log . error ( " No status log was recorded . First = { } , Second = { } " , firstThreadEvents , secondThreadEvents ) ; <nl> + fail ( " Status log was not appended " ) ; <nl> + } <nl> + else <nl> + { <nl> + log . info ( " Checking if logger was busy . First = { } , Second = { } " , firstThreadEvents , secondThreadEvents ) ; <nl> + assertTrue ( " One ' logger busy ' entry was expected " , <nl> + isLoggerBusyTheOnlyEvent ( firstThreadEvents ) | | isLoggerBusyTheOnlyEvent ( secondThreadEvents ) ) ; <nl> + } <nl> + } <nl> + <nl> + private boolean isLoggerBusyTheOnlyEvent ( List < ILoggingEvent > events ) <nl> + { <nl> + return events . size ( ) = = 1 & & <nl> + events . get ( 0 ) . getMessage ( ) . equals ( " StatusLogger is busy " ) & & <nl> + events . get ( 0 ) . getLevel ( ) = = Level . TRACE ; <nl> + } <nl> + <nl> + private static class InMemoryAppender extends AppenderBase < ILoggingEvent > <nl> + { <nl> + private final List < ILoggingEvent > events = newArrayList ( ) ; <nl> + <nl> + private InMemoryAppender ( ) <nl> + { <nl> + start ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected synchronized void append ( ILoggingEvent event ) <nl> + { <nl> + events . add ( event ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 71f4b1d . . e214177 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Allow only one concurrent call to StatusLogger ( CASSANDRA - 12182 ) 
 * Refactoring to specialised functional interfaces ( CASSANDRA - 13982 ) 
 * Speculative retry should allow more friendly params ( CASSANDRA - 13876 ) 
 * Throw exception if we send / receive repair messages to incompatible nodes ( CASSANDRA - 13944 ) 
 diff - - git a / src / java / org / apache / cassandra / utils / StatusLogger . java b / src / java / org / apache / cassandra / utils / StatusLogger . java 
 index c33190b . . 9f9d869 100644 
 - - - a / src / java / org / apache / cassandra / utils / StatusLogger . java 
 + + + b / src / java / org / apache / cassandra / utils / StatusLogger . java 
 @ @ - 19 , 11 + 19 , 13 @ @ package org . apache . cassandra . utils ; 
 
 import java . lang . management . ManagementFactory ; 
 import java . util . Map ; 
 + import java . util . concurrent . locks . ReentrantLock ; 
 import javax . management . * ; 
 
 import org . apache . cassandra . cache . * ; 
 
 import org . apache . cassandra . metrics . ThreadPoolMetrics ; 
 + 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 37 , 10 + 39 , 31 @ @ import org . apache . cassandra . service . CacheService ; 
 public class StatusLogger 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( StatusLogger . class ) ; 
 - 
 + private static final ReentrantLock busyMonitor = new ReentrantLock ( ) ; 
 
 public static void log ( ) 
 { 
 + / / avoid logging more than once at the same time . throw away any attempts to log concurrently , as it would be 
 + / / confusing and noisy for operators - and don ' t bother logging again , immediately as it ' ll just be the same data 
 + if ( busyMonitor . tryLock ( ) ) 
 + { 
 + try 
 + { 
 + logStatus ( ) ; 
 + } 
 + finally 
 + { 
 + busyMonitor . unlock ( ) ; 
 + } 
 + } 
 + else 
 + { 
 + logger . trace ( " StatusLogger is busy " ) ; 
 + } 
 + } 
 + 
 + private static void logStatus ( ) 
 + { 
 MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; 
 
 / / everything from o . a . c . concurrent 
 diff - - git a / test / unit / org / apache / cassandra / utils / StatusLoggerTest . java b / test / unit / org / apache / cassandra / utils / StatusLoggerTest . java 
 new file mode 100644 
 index 0000000 . . 878e6e8 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / utils / StatusLoggerTest . java 
 @ @ - 0 , 0 + 1 , 160 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . Comparator ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 + import java . util . concurrent . TimeUnit ; 
 + import java . util . stream . Collectors ; 
 + 
 + import com . google . common . collect . Range ; 
 + import org . junit . Test ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import ch . qos . logback . classic . Level ; 
 + import ch . qos . logback . classic . spi . ILoggingEvent ; 
 + import ch . qos . logback . core . AppenderBase ; 
 + import org . apache . cassandra . cql3 . CQLTester ; 
 + 
 + import static com . google . common . collect . Lists . newArrayList ; 
 + import static java . util . stream . Collectors . groupingBy ; 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + import static org . junit . Assert . fail ; 
 + 
 + public class StatusLoggerTest extends CQLTester 
 + { 
 + private static final Logger log = LoggerFactory . getLogger ( StatusLoggerTest . class ) ; 
 + 
 + @ Test 
 + public void testStatusLoggerPrintsStatusOnlyOnceWhenInvokedConcurrently ( ) throws Exception 
 + { 
 + ch . qos . logback . classic . Logger logger = ( ch . qos . logback . classic . Logger ) LoggerFactory . getLogger ( StatusLogger . class ) ; 
 + InMemoryAppender inMemoryAppender = new InMemoryAppender ( ) ; 
 + logger . addAppender ( inMemoryAppender ) ; 
 + logger . setLevel ( Level . TRACE ) ; 
 + try 
 + { 
 + submitTwoLogRequestsConcurrently ( ) ; 
 + verifyOnlySingleStatusWasAppendedConcurrently ( inMemoryAppender . events ) ; 
 + } 
 + finally 
 + { 
 + assertTrue ( " Could not remove in memory appender " , logger . detachAppender ( inMemoryAppender ) ) ; 
 + } 
 + } 
 + 
 + private void submitTwoLogRequestsConcurrently ( ) throws InterruptedException 
 + { 
 + ExecutorService executorService = Executors . newFixedThreadPool ( 2 ) ; 
 + executorService . submit ( StatusLogger : : log ) ; 
 + executorService . submit ( StatusLogger : : log ) ; 
 + executorService . shutdown ( ) ; 
 + executorService . awaitTermination ( 1 , TimeUnit . SECONDS ) ; 
 + } 
 + 
 + private void verifyOnlySingleStatusWasAppendedConcurrently ( List < ILoggingEvent > events ) 
 + { 
 + Map < String , List < ILoggingEvent > > eventsByThread = events . stream ( ) . collect ( groupingBy ( ILoggingEvent : : getThreadName ) ) ; 
 + List < String > threadNames = newArrayList ( eventsByThread . keySet ( ) ) ; 
 + 
 + assertEquals ( " Expected events from 2 threads only " , 2 , threadNames . size ( ) ) ; 
 + 
 + List < ILoggingEvent > firstThreadEvents = eventsByThread . get ( threadNames . get ( 0 ) ) ; 
 + List < ILoggingEvent > secondThreadEvents = eventsByThread . get ( threadNames . get ( 1 ) ) ; 
 + 
 + assertTrue ( " Expected at least one event from the first thread " , firstThreadEvents . size ( ) > = 1 ) ; 
 + assertTrue ( " Expected at least one event from the second thread " , secondThreadEvents . size ( ) > = 1 ) ; 
 + 
 + if ( areDisjunctive ( firstThreadEvents , secondThreadEvents ) ) 
 + { 
 + log . debug ( " Event time ranges are disjunctive - log invocations were made one after another " ) ; 
 + } 
 + else 
 + { 
 + verifyStatusWasPrintedAndBusyEventOccured ( firstThreadEvents , secondThreadEvents ) ; 
 + } 
 + } 
 + 
 + private boolean areDisjunctive ( List < ILoggingEvent > firstThreadEvents , List < ILoggingEvent > secondThreadEvents ) 
 + { 
 + Range < Long > firstThreadTimeRange = timestampsRange ( firstThreadEvents ) ; 
 + Range < Long > secondThreadTimeRange = timestampsRange ( secondThreadEvents ) ; 
 + boolean connected = firstThreadTimeRange . isConnected ( secondThreadTimeRange ) ; 
 + boolean disjunctive = ! connected | | firstThreadTimeRange . intersection ( secondThreadTimeRange ) . isEmpty ( ) ; 
 + log . debug ( " Time ranges { } , { } , disjunctive = { } " , firstThreadTimeRange , secondThreadTimeRange , disjunctive ) ; 
 + return disjunctive ; 
 + } 
 + 
 + private Range < Long > timestampsRange ( List < ILoggingEvent > events ) 
 + { 
 + List < Long > timestamps = events . stream ( ) . map ( ILoggingEvent : : getTimeStamp ) . collect ( Collectors . toList ( ) ) ; 
 + Long min = timestamps . stream ( ) . min ( Comparator . naturalOrder ( ) ) . get ( ) ; 
 + Long max = timestamps . stream ( ) . max ( Comparator . naturalOrder ( ) ) . get ( ) ; 
 + / / It ' s open on one side to cover a case when second status starts printing at the same timestamp that previous one was finished 
 + return Range . closedOpen ( min , max ) ; 
 + } 
 + 
 + private void verifyStatusWasPrintedAndBusyEventOccured ( List < ILoggingEvent > firstThreadEvents , List < ILoggingEvent > secondThreadEvents ) 
 + { 
 + if ( firstThreadEvents . size ( ) > 1 & & secondThreadEvents . size ( ) > 1 ) 
 + { 
 + log . error ( " Both event lists contain more than one entry . First = { } , Second = { } " , firstThreadEvents , secondThreadEvents ) ; 
 + fail ( " More that one status log was appended concurrently " ) ; 
 + } 
 + else if ( firstThreadEvents . size ( ) < = 1 & & secondThreadEvents . size ( ) < = 1 ) 
 + { 
 + log . error ( " No status log was recorded . First = { } , Second = { } " , firstThreadEvents , secondThreadEvents ) ; 
 + fail ( " Status log was not appended " ) ; 
 + } 
 + else 
 + { 
 + log . info ( " Checking if logger was busy . First = { } , Second = { } " , firstThreadEvents , secondThreadEvents ) ; 
 + assertTrue ( " One ' logger busy ' entry was expected " , 
 + isLoggerBusyTheOnlyEvent ( firstThreadEvents ) | | isLoggerBusyTheOnlyEvent ( secondThreadEvents ) ) ; 
 + } 
 + } 
 + 
 + private boolean isLoggerBusyTheOnlyEvent ( List < ILoggingEvent > events ) 
 + { 
 + return events . size ( ) = = 1 & & 
 + events . get ( 0 ) . getMessage ( ) . equals ( " StatusLogger is busy " ) & & 
 + events . get ( 0 ) . getLevel ( ) = = Level . TRACE ; 
 + } 
 + 
 + private static class InMemoryAppender extends AppenderBase < ILoggingEvent > 
 + { 
 + private final List < ILoggingEvent > events = newArrayList ( ) ; 
 + 
 + private InMemoryAppender ( ) 
 + { 
 + start ( ) ; 
 + } 
 + 
 + @ Override 
 + protected synchronized void append ( ILoggingEvent event ) 
 + { 
 + events . add ( event ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
