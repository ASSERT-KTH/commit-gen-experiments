BLEU SCORE: 0.02383853510228548

TEST MSG: Add the ability to cleanup files after CqlBulkRecordWriter succeeds
GENERATED MSG: Support compression using BulkWriter

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkOutputFormat . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkOutputFormat . java <nl> index 58e05b6 . . 887fe8e 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkOutputFormat . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkOutputFormat . java <nl> @ @ - 53 , 6 + 53 , 7 @ @ public class CqlBulkOutputFormat extends AbstractBulkOutputFormat < Object , List < B <nl> <nl> private static final String OUTPUT _ CQL _ SCHEMA _ PREFIX = " cassandra . columnfamily . schema . " ; <nl> private static final String OUTPUT _ CQL _ INSERT _ PREFIX = " cassandra . columnfamily . insert . " ; <nl> + private static final String DELETE _ SOURCE = " cassandra . output . delete . source " ; <nl> <nl> / * * Fills the deprecated OutputFormat interface for streaming . * / <nl> @ Deprecated <nl> @ @ - 103 , 4 + 104 , 14 @ @ public class CqlBulkOutputFormat extends AbstractBulkOutputFormat < Object , List < B <nl> } <nl> return insert ; <nl> } <nl> + <nl> + public static void setDeleteSourceOnSuccess ( Configuration conf , boolean deleteSrc ) <nl> + { <nl> + conf . setBoolean ( DELETE _ SOURCE , deleteSrc ) ; <nl> + } <nl> + <nl> + public static boolean getDeleteSourceOnSuccess ( Configuration conf ) <nl> + { <nl> + return conf . getBoolean ( DELETE _ SOURCE , false ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkRecordWriter . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkRecordWriter . java <nl> index 7a75bb4 . . 43e3a12 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkRecordWriter . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkRecordWriter . java <nl> @ @ - 32 , 6 + 32 , 8 @ @ import org . apache . cassandra . hadoop . ConfigHelper ; <nl> import org . apache . cassandra . hadoop . HadoopCompat ; <nl> import org . apache . cassandra . io . sstable . CQLSSTableWriter ; <nl> import org . apache . cassandra . io . sstable . SSTableLoader ; <nl> + import org . apache . cassandra . io . util . FileUtils ; <nl> + import org . apache . cassandra . streaming . StreamState ; <nl> import org . apache . hadoop . conf . Configuration ; <nl> import org . apache . hadoop . mapreduce . TaskAttemptContext ; <nl> import org . apache . hadoop . util . Progressable ; <nl> @ @ - 57 , 6 + 59 , 7 @ @ public class CqlBulkRecordWriter extends AbstractBulkRecordWriter < Object , List < B <nl> private String schema ; <nl> private String insertStatement ; <nl> private File outputDir ; <nl> + private boolean deleteSrc ; <nl> <nl> CqlBulkRecordWriter ( TaskAttemptContext context ) throws IOException <nl> { <nl> @ @ - 84 , 6 + 87 , 7 @ @ public class CqlBulkRecordWriter extends AbstractBulkRecordWriter < Object , List < B <nl> schema = CqlBulkOutputFormat . getColumnFamilySchema ( conf , columnFamily ) ; <nl> insertStatement = CqlBulkOutputFormat . getColumnFamilyInsertStatement ( conf , columnFamily ) ; <nl> outputDir = getColumnFamilyDirectory ( ) ; <nl> + deleteSrc = CqlBulkOutputFormat . getDeleteSourceOnSuccess ( conf ) ; <nl> } <nl> <nl> <nl> @ @ - 107 , 7 + 111 , 14 @ @ public class CqlBulkRecordWriter extends AbstractBulkRecordWriter < Object , List < B <nl> <nl> externalClient . addKnownCfs ( keyspace , schema ) ; <nl> <nl> - this . loader = new SSTableLoader ( outputDir , externalClient , new BulkRecordWriter . NullOutputHandler ( ) ) ; <nl> + this . loader = new SSTableLoader ( outputDir , externalClient , new BulkRecordWriter . NullOutputHandler ( ) ) { <nl> + @ Override <nl> + public void onSuccess ( StreamState finalState ) <nl> + { <nl> + if ( deleteSrc ) <nl> + FileUtils . deleteRecursive ( outputDir ) ; <nl> + } <nl> + } ; <nl> } <nl> } <nl> catch ( Exception e )
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index bf4a000 . . ab3b064 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1423 , 6 + 1423 , 14 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> + public List < SSTableReader > getSnapshotSSTableReader ( String tag ) throws IOException <nl> + { <nl> + List < SSTableReader > readers = new ArrayList < SSTableReader > ( ) ; <nl> + for ( Map . Entry < Descriptor , Set < Component > > entries : directories . sstableLister ( ) . snapshots ( tag ) . list ( ) . entrySet ( ) ) <nl> + readers . add ( SSTableReader . open ( entries . getKey ( ) , entries . getValue ( ) , metadata , partitioner ) ) ; <nl> + return readers ; <nl> + } <nl> + <nl> / * * <nl> * Take a snap shot of this columnfamily store . <nl> * <nl> diff - - git a / src / java / org / apache / cassandra / db / Directories . java b / src / java / org / apache / cassandra / db / Directories . java <nl> index 2afefd2 . . 7c51830 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Directories . java <nl> + + + b / src / java / org / apache / cassandra / db / Directories . java <nl> @ @ - 185 , 6 + 185 , 7 @ @ public class Directories <nl> private int nbFiles ; <nl> private final Map < Descriptor , Set < Component > > components = new HashMap < Descriptor , Set < Component > > ( ) ; <nl> private boolean filtered ; <nl> + private String snapshotName ; <nl> <nl> public SSTableLister skipCompacted ( boolean b ) <nl> { <nl> @ @ - 219 , 6 + 220 , 14 @ @ public class Directories <nl> return this ; <nl> } <nl> <nl> + public SSTableLister snapshots ( String sn ) <nl> + { <nl> + if ( filtered ) <nl> + throw new IllegalStateException ( " list ( ) has already been called " ) ; <nl> + snapshotName = sn ; <nl> + return this ; <nl> + } <nl> + <nl> public Map < Descriptor , Set < Component > > list ( ) <nl> { <nl> filter ( ) ; <nl> @ @ - 246 , 6 + 255 , 12 @ @ public class Directories <nl> <nl> for ( File location : sstableDirectories ) <nl> { <nl> + if ( snapshotName ! = null ) <nl> + { <nl> + new File ( location , join ( SNAPSHOT _ SUBDIR , snapshotName ) ) . listFiles ( getFilter ( ) ) ; <nl> + continue ; <nl> + } <nl> + <nl> if ( ! onlyBackups ) <nl> location . listFiles ( getFilter ( ) ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index c02aed2 . . 448c569 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 799 , 23 + 799 , 33 @ @ public class CompactionManager implements CompactionManagerMBean <nl> if ( ! cfs . isValid ( ) ) <nl> return ; <nl> <nl> - / / flush first so everyone is validating data that is as similar as possible <nl> - try <nl> - { <nl> - StorageService . instance . forceTableFlush ( cfs . table . name , cfs . getColumnFamilyName ( ) ) ; <nl> - } <nl> - catch ( ExecutionException e ) <nl> + Collection < SSTableReader > sstables ; <nl> + if ( cfs . table . snapshotExists ( validator . request . sessionid ) ) <nl> { <nl> - throw new IOException ( e ) ; <nl> + / / If there is a snapshot created for the session then read from there . <nl> + sstables = cfs . getSnapshotSSTableReader ( validator . request . sessionid ) ; <nl> } <nl> - catch ( InterruptedException e ) <nl> + else <nl> { <nl> - throw new AssertionError ( e ) ; <nl> + / / flush first so everyone is validating data that is as similar as possible <nl> + try <nl> + { <nl> + StorageService . instance . forceTableFlush ( cfs . table . name , cfs . getColumnFamilyName ( ) ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + throw new IOException ( e ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + <nl> + / / we don ' t mark validating sstables as compacting in DataTracker , so we have to mark them referenced <nl> + / / instead so they won ' t be cleaned up if they do get compacted during the validation <nl> + sstables = cfs . markCurrentSSTablesReferenced ( ) ; <nl> } <nl> <nl> - / / we don ' t mark validating sstables as compacting in DataTracker , so we have to mark them referenced <nl> - / / instead so they won ' t be cleaned up if they do get compacted during the validation <nl> - Collection < SSTableReader > sstables = cfs . markCurrentSSTablesReferenced ( ) ; <nl> CompactionIterable ci = new ValidationCompactionIterable ( cfs , sstables , validator . request . range ) ; <nl> CloseableIterator < AbstractCompactedRow > iter = ci . iterator ( ) ; <nl> validationExecutor . beginCompaction ( ci ) ; <nl> @ @ - 838 , 6 + 848 , 9 @ @ public class CompactionManager implements CompactionManagerMBean <nl> { <nl> SSTableReader . releaseReferences ( sstables ) ; <nl> iter . close ( ) ; <nl> + if ( cfs . table . snapshotExists ( validator . request . sessionid ) ) <nl> + cfs . table . clearSnapshot ( validator . request . sessionid ) ; <nl> + <nl> validationExecutor . finishCompaction ( ci ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / AntiEntropyService . java b / src / java / org / apache / cassandra / service / AntiEntropyService . java <nl> index 812c23a . . 10ea80c 100644 <nl> - - - a / src / java / org / apache / cassandra / service / AntiEntropyService . java <nl> + + + b / src / java / org / apache / cassandra / service / AntiEntropyService . java <nl> @ @ - 38 , 6 + 38 , 7 @ @ import org . apache . cassandra . db . compaction . AbstractCompactedRow ; <nl> import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . DecoratedKey ; <nl> import org . apache . cassandra . db . Table ; <nl> + import org . apache . cassandra . db . SnapshotCommand ; <nl> import org . apache . cassandra . dht . AbstractBounds ; <nl> import org . apache . cassandra . dht . RandomPartitioner ; <nl> import org . apache . cassandra . dht . Range ; <nl> @ @ - 47 , 6 + 48 , 7 @ @ import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . io . util . FastByteArrayInputStream ; <nl> import org . apache . cassandra . io . util . FastByteArrayOutputStream ; <nl> import org . apache . cassandra . net . CompactEndpointSerializationHelper ; <nl> + import org . apache . cassandra . net . IAsyncCallback ; <nl> import org . apache . cassandra . net . IVerbHandler ; <nl> import org . apache . cassandra . net . Message ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> @ @ - 119 , 9 + 121 , 9 @ @ public class AntiEntropyService <nl> / * * <nl> * Requests repairs for the given table and column families , and blocks until all repairs have been completed . <nl> * / <nl> - public RepairFuture submitRepairSession ( Range < Token > range , String tablename , String . . . cfnames ) <nl> + public RepairFuture submitRepairSession ( Range < Token > range , String tablename , boolean isSequential , String . . . cfnames ) <nl> { <nl> - RepairFuture futureTask = new RepairSession ( range , tablename , cfnames ) . getFuture ( ) ; <nl> + RepairFuture futureTask = new RepairSession ( range , tablename , isSequential , cfnames ) . getFuture ( ) ; <nl> executor . execute ( futureTask ) ; <nl> return futureTask ; <nl> } <nl> @ @ - 209 , 16 + 211 , 6 @ @ public class AntiEntropyService <nl> } <nl> <nl> / * * <nl> - * Requests a tree from the given node , and returns the request that was sent . <nl> - * / <nl> - TreeRequest request ( String sessionid , InetAddress remote , Range < Token > range , String ksname , String cfname ) <nl> - { <nl> - TreeRequest request = new TreeRequest ( sessionid , remote , range , new CFPair ( ksname , cfname ) ) ; <nl> - MessagingService . instance ( ) . sendOneWay ( TreeRequestVerbHandler . makeVerb ( request , Gossiper . instance . getVersion ( remote ) ) , remote ) ; <nl> - return request ; <nl> - } <nl> - <nl> - / * * <nl> * Responds to the node that requested the given valid tree . <nl> * @ param validator A locally generated validator <nl> * @ param local localhost ( parameterized for testing ) <nl> @ @ - 598 , 6 + 590 , 7 @ @ public class AntiEntropyService <nl> static class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber , IFailureDetectionEventListener <nl> { <nl> private final String sessionName ; <nl> + private final boolean isSequential ; <nl> private final String tablename ; <nl> private final String [ ] cfnames ; <nl> private final Range < Token > range ; <nl> @ @ - 615 , 18 + 608 , 19 @ @ public class AntiEntropyService <nl> <nl> public RepairSession ( TreeRequest req , String tablename , String . . . cfnames ) <nl> { <nl> - this ( req . sessionid , req . range , tablename , cfnames ) ; <nl> + this ( req . sessionid , req . range , tablename , false , cfnames ) ; <nl> AntiEntropyService . instance . sessions . put ( getName ( ) , this ) ; <nl> } <nl> <nl> - public RepairSession ( Range < Token > range , String tablename , String . . . cfnames ) <nl> + public RepairSession ( Range < Token > range , String tablename , boolean isSequential , String . . . cfnames ) <nl> { <nl> - this ( UUIDGen . makeType1UUIDFromHost ( FBUtilities . getBroadcastAddress ( ) ) . toString ( ) , range , tablename , cfnames ) ; <nl> + this ( UUIDGen . makeType1UUIDFromHost ( FBUtilities . getBroadcastAddress ( ) ) . toString ( ) , range , tablename , isSequential , cfnames ) ; <nl> } <nl> <nl> - private RepairSession ( String id , Range < Token > range , String tablename , String [ ] cfnames ) <nl> + private RepairSession ( String id , Range < Token > range , String tablename , boolean isSequential , String [ ] cfnames ) <nl> { <nl> this . sessionName = id ; <nl> + this . isSequential = isSequential ; <nl> this . tablename = tablename ; <nl> this . cfnames = cfnames ; <nl> assert cfnames . length > 0 : " Repairing no column families seems pointless , doesn ' t it " ; <nl> @ @ - 674 , 6 + 668 , 12 @ @ public class AntiEntropyService <nl> logger . info ( String . format ( " [ repair # % s ] Cannot proceed on repair because a neighbor ( % s ) is dead : session failed " , getName ( ) , endpoint ) ) ; <nl> return ; <nl> } <nl> + <nl> + if ( Gossiper . instance . getVersion ( endpoint ) < MessagingService . VERSION _ 11 & & isSequential ) <nl> + { <nl> + logger . info ( String . format ( " [ repair # % s ] Cannot repair using snapshots as node % s is pre - 1 . 1 " , getName ( ) , endpoint ) ) ; <nl> + return ; <nl> + } <nl> } <nl> <nl> AntiEntropyService . instance . sessions . put ( getName ( ) , this ) ; <nl> @ @ - 729 , 6 + 729 , 8 @ @ public class AntiEntropyService <nl> public void terminate ( ) <nl> { <nl> terminated = true ; <nl> + for ( RepairJob job : jobs ) <nl> + job . terminate ( ) ; <nl> jobs . clear ( ) ; <nl> activeJobs . clear ( ) ; <nl> } <nl> @ @ - 810 , 17 + 812 , 32 @ @ public class AntiEntropyService <nl> { <nl> private final String cfname ; <nl> / / first we send tree requests . this tracks the endpoints remaining to hear from <nl> - private final Set < InetAddress > remainingEndpoints = new HashSet < InetAddress > ( ) ; <nl> + private final RequestCoordinator < TreeRequest > treeRequests ; <nl> / / tree responses are then tracked here <nl> private final List < TreeResponse > trees = new ArrayList < TreeResponse > ( endpoints . size ( ) + 1 ) ; <nl> / / once all responses are received , each tree is compared with each other , and differencer tasks <nl> / / are submitted . the job is done when all differencers are complete . <nl> - private final Set < Differencer > remainingDifferencers = new HashSet < Differencer > ( ) ; <nl> + private final RequestCoordinator < Differencer > differencers ; <nl> private final Condition requestsSent = new SimpleCondition ( ) ; <nl> + private CountDownLatch snapshotLatch = null ; <nl> <nl> public RepairJob ( String cfname ) <nl> { <nl> this . cfname = cfname ; <nl> + this . treeRequests = new RequestCoordinator < TreeRequest > ( isSequential ) <nl> + { <nl> + public void send ( TreeRequest r ) <nl> + { <nl> + MessagingService . instance ( ) . sendOneWay ( TreeRequestVerbHandler . makeVerb ( r , Gossiper . instance . getVersion ( r . endpoint ) ) , r . endpoint ) ; <nl> + } <nl> + } ; <nl> + this . differencers = new RequestCoordinator < Differencer > ( isSequential ) <nl> + { <nl> + public void send ( Differencer d ) <nl> + { <nl> + StageManager . getStage ( Stage . ANTI _ ENTROPY ) . execute ( d ) ; <nl> + } <nl> + } ; <nl> } <nl> <nl> / * * <nl> @ @ - 828 , 17 + 845 , 51 @ @ public class AntiEntropyService <nl> * / <nl> public void sendTreeRequests ( ) <nl> { <nl> - remainingEndpoints . addAll ( endpoints ) ; <nl> - remainingEndpoints . add ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> - <nl> / / send requests to all nodes <nl> - for ( InetAddress endpoint : remainingEndpoints ) <nl> - AntiEntropyService . instance . request ( getName ( ) , endpoint , range , tablename , cfname ) ; <nl> + List < InetAddress > allEndpoints = new ArrayList < InetAddress > ( endpoints ) ; <nl> + allEndpoints . add ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> <nl> - logger . info ( String . format ( " [ repair # % s ] requests for merkle tree sent for % s ( to % s ) " , getName ( ) , cfname , remainingEndpoints ) ) ; <nl> + if ( isSequential ) <nl> + makeSnapshots ( endpoints ) ; <nl> + <nl> + for ( InetAddress endpoint : allEndpoints ) <nl> + treeRequests . add ( new TreeRequest ( getName ( ) , endpoint , range , new CFPair ( tablename , cfname ) ) ) ; <nl> + <nl> + logger . info ( String . format ( " [ repair # % s ] requesting merkle trees for % s ( to % s ) " , getName ( ) , cfname , allEndpoints ) ) ; <nl> + treeRequests . start ( ) ; <nl> requestsSent . signalAll ( ) ; <nl> } <nl> <nl> + public void makeSnapshots ( Collection < InetAddress > endpoints ) <nl> + { <nl> + try <nl> + { <nl> + snapshotLatch = new CountDownLatch ( endpoints . size ( ) ) ; <nl> + IAsyncCallback callback = new IAsyncCallback ( ) <nl> + { <nl> + @ Override <nl> + public boolean isLatencyForSnitch ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + @ Override <nl> + public void response ( Message msg ) <nl> + { <nl> + RepairJob . this . snapshotLatch . countDown ( ) ; <nl> + } <nl> + } ; <nl> + for ( InetAddress endpoint : endpoints ) <nl> + MessagingService . instance ( ) . sendRR ( new SnapshotCommand ( tablename , cfname , sessionName , false ) , endpoint , callback ) ; <nl> + snapshotLatch . await ( ) ; <nl> + snapshotLatch = null ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> / * * <nl> * Add a new received tree and return the number of remaining tree to <nl> * be received for the job to be complete . <nl> @ @ - 859 , 8 + 910 , 7 @ @ public class AntiEntropyService <nl> <nl> assert request . cf . right . equals ( cfname ) ; <nl> trees . add ( new TreeResponse ( request . endpoint , tree ) ) ; <nl> - remainingEndpoints . remove ( request . endpoint ) ; <nl> - return remainingEndpoints . size ( ) ; <nl> + return treeRequests . completed ( request ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 869 , 8 + 919 , 6 @ @ public class AntiEntropyService <nl> * / <nl> public void submitDifferencers ( ) <nl> { <nl> - assert remainingEndpoints . isEmpty ( ) ; <nl> - <nl> / / We need to difference all trees one against another <nl> for ( int i = 0 ; i < trees . size ( ) - 1 ; + + i ) <nl> { <nl> @ @ - 880 , 10 + 928 , 10 @ @ public class AntiEntropyService <nl> TreeResponse r2 = trees . get ( j ) ; <nl> Differencer differencer = new Differencer ( cfname , r1 , r2 ) ; <nl> logger . debug ( " Queueing comparison { } " , differencer ) ; <nl> - remainingDifferencers . add ( differencer ) ; <nl> - StageManager . getStage ( Stage . ANTI _ ENTROPY ) . execute ( differencer ) ; <nl> + differencers . add ( differencer ) ; <nl> } <nl> } <nl> + differencers . start ( ) ; <nl> trees . clear ( ) ; / / allows gc to do its thing <nl> } <nl> <nl> @ @ - 892 , 8 + 940 , 16 @ @ public class AntiEntropyService <nl> * / <nl> synchronized boolean completedSynchronization ( Differencer differencer ) <nl> { <nl> - remainingDifferencers . remove ( differencer ) ; <nl> - return remainingDifferencers . isEmpty ( ) ; <nl> + return differencers . completed ( differencer ) = = 0 ; <nl> + } <nl> + <nl> + public void terminate ( ) <nl> + { <nl> + if ( snapshotLatch ! = null ) <nl> + { <nl> + while ( snapshotLatch . getCount ( ) > 0 ) <nl> + snapshotLatch . countDown ( ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 992 , 4 + 1048 , 107 @ @ public class AntiEntropyService <nl> this . session = session ; <nl> } <nl> } <nl> + <nl> + public static abstract class RequestCoordinator < R > <nl> + { <nl> + private final Order < R > orderer ; <nl> + <nl> + protected RequestCoordinator ( boolean isSequential ) <nl> + { <nl> + this . orderer = isSequential ? new SequentialOrder < R > ( this ) : new ParallelOrder < R > ( this ) ; <nl> + } <nl> + <nl> + public abstract void send ( R request ) ; <nl> + <nl> + public void add ( R request ) <nl> + { <nl> + orderer . add ( request ) ; <nl> + } <nl> + <nl> + public void start ( ) <nl> + { <nl> + orderer . start ( ) ; <nl> + } <nl> + <nl> + / / Returns how many request remains <nl> + public int completed ( R request ) <nl> + { <nl> + return orderer . completed ( request ) ; <nl> + } <nl> + <nl> + private static abstract class Order < R > <nl> + { <nl> + protected final RequestCoordinator < R > coordinator ; <nl> + <nl> + Order ( RequestCoordinator < R > coordinator ) <nl> + { <nl> + this . coordinator = coordinator ; <nl> + } <nl> + <nl> + public abstract void add ( R request ) ; <nl> + public abstract void start ( ) ; <nl> + public abstract int completed ( R request ) ; <nl> + } <nl> + <nl> + private static class SequentialOrder < R > extends Order < R > <nl> + { <nl> + private final Queue < R > requests = new LinkedList < R > ( ) ; <nl> + <nl> + SequentialOrder ( RequestCoordinator < R > coordinator ) <nl> + { <nl> + super ( coordinator ) ; <nl> + } <nl> + <nl> + public void add ( R request ) <nl> + { <nl> + requests . add ( request ) ; <nl> + } <nl> + <nl> + public void start ( ) <nl> + { <nl> + if ( requests . isEmpty ( ) ) <nl> + return ; <nl> + <nl> + coordinator . send ( requests . peek ( ) ) ; <nl> + } <nl> + <nl> + public int completed ( R request ) <nl> + { <nl> + assert request . equals ( requests . peek ( ) ) ; <nl> + requests . poll ( ) ; <nl> + int remaining = requests . size ( ) ; <nl> + if ( remaining ! = 0 ) <nl> + coordinator . send ( requests . peek ( ) ) ; <nl> + return remaining ; <nl> + } <nl> + } <nl> + <nl> + private static class ParallelOrder < R > extends Order < R > <nl> + { <nl> + private final Set < R > requests = new HashSet < R > ( ) ; <nl> + <nl> + ParallelOrder ( RequestCoordinator < R > coordinator ) <nl> + { <nl> + super ( coordinator ) ; <nl> + } <nl> + <nl> + public void add ( R request ) <nl> + { <nl> + requests . add ( request ) ; <nl> + } <nl> + <nl> + public void start ( ) <nl> + { <nl> + for ( R request : requests ) <nl> + coordinator . send ( request ) ; <nl> + } <nl> + <nl> + public int completed ( R request ) <nl> + { <nl> + requests . remove ( request ) ; <nl> + return requests . size ( ) ; <nl> + } <nl> + } <nl> + <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index c1681b9 . . 58986a5 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 1827 , 12 + 1827 , 11 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> * @ param columnFamilies <nl> * @ throws IOException <nl> * / <nl> - public void forceTableRepair ( final String tableName , final String . . . columnFamilies ) throws IOException <nl> + public void forceTableRepair ( final String tableName , boolean isSequential , final String . . . columnFamilies ) throws IOException <nl> { <nl> if ( Table . SYSTEM _ TABLE . equals ( tableName ) ) <nl> return ; <nl> <nl> - <nl> Collection < Range < Token > > ranges = getLocalRanges ( tableName ) ; <nl> int cmd = nextRepairCommand . incrementAndGet ( ) ; <nl> logger _ . info ( " Starting repair command # { } , repairing { } ranges . " , cmd , ranges . size ( ) ) ; <nl> @ @ - 1840 , 7 + 1839 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> List < AntiEntropyService . RepairFuture > futures = new ArrayList < AntiEntropyService . RepairFuture > ( ranges . size ( ) ) ; <nl> for ( Range < Token > range : ranges ) <nl> { <nl> - AntiEntropyService . RepairFuture future = forceTableRepair ( range , tableName , columnFamilies ) ; <nl> + AntiEntropyService . RepairFuture future = forceTableRepair ( range , tableName , isSequential , columnFamilies ) ; <nl> futures . add ( future ) ; <nl> / / wait for a session to be done with its differencing before starting the next one <nl> try <nl> @ @ - 1875 , 12 + 1874 , 12 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> logger _ . info ( " Repair command # { } completed successfully " , cmd ) ; <nl> } <nl> <nl> - public void forceTableRepairPrimaryRange ( final String tableName , final String . . . columnFamilies ) throws IOException <nl> + public void forceTableRepairPrimaryRange ( final String tableName , boolean isSequential , final String . . . columnFamilies ) throws IOException <nl> { <nl> if ( Table . SYSTEM _ TABLE . equals ( tableName ) ) <nl> return ; <nl> <nl> - AntiEntropyService . RepairFuture future = forceTableRepair ( getLocalPrimaryRange ( ) , tableName , columnFamilies ) ; <nl> + AntiEntropyService . RepairFuture future = forceTableRepair ( getLocalPrimaryRange ( ) , tableName , isSequential , columnFamilies ) ; <nl> try <nl> { <nl> future . get ( ) ; <nl> @ @ - 1892 , 7 + 1891 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> } <nl> } <nl> <nl> - public AntiEntropyService . RepairFuture forceTableRepair ( final Range < Token > range , final String tableName , final String . . . columnFamilies ) throws IOException <nl> + public AntiEntropyService . RepairFuture forceTableRepair ( final Range < Token > range , final String tableName , boolean isSequential , final String . . . columnFamilies ) throws IOException <nl> { <nl> ArrayList < String > names = new ArrayList < String > ( ) ; <nl> for ( ColumnFamilyStore cfStore : getValidColumnFamilies ( tableName , columnFamilies ) ) <nl> @ @ - 1900 , 7 + 1899 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> names . add ( cfStore . getColumnFamilyName ( ) ) ; <nl> } <nl> <nl> - return AntiEntropyService . instance . submitRepairSession ( range , tableName , names . toArray ( new String [ names . size ( ) ] ) ) ; <nl> + return AntiEntropyService . instance . submitRepairSession ( range , tableName , isSequential , names . toArray ( new String [ names . size ( ) ] ) ) ; <nl> } <nl> <nl> public void forceTerminateAllRepairSessions ( ) { <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> index 6af63b7 . . c5aa9fd 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> @ @ - 231 , 12 + 231 , 12 @ @ public interface StorageServiceMBean <nl> * @ param columnFamilies <nl> * @ throws IOException <nl> * / <nl> - public void forceTableRepair ( String tableName , String . . . columnFamilies ) throws IOException ; <nl> + public void forceTableRepair ( String tableName , boolean isSequential , String . . . columnFamilies ) throws IOException ; <nl> <nl> / * * <nl> * Triggers proactive repair but only for the node primary range . <nl> * / <nl> - public void forceTableRepairPrimaryRange ( String tableName , String . . . columnFamilies ) throws IOException ; <nl> + public void forceTableRepairPrimaryRange ( String tableName , boolean isSequential , String . . . columnFamilies ) throws IOException ; <nl> <nl> public void forceTerminateAllRepairSessions ( ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index 2b19074 . . 8a224b8 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 53 , 6 + 53 , 7 @ @ public class NodeCmd <nl> private static final Pair < String , String > PASSWORD _ OPT = new Pair < String , String > ( " pw " , " password " ) ; <nl> private static final Pair < String , String > TAG _ OPT = new Pair < String , String > ( " t " , " tag " ) ; <nl> private static final Pair < String , String > PRIMARY _ RANGE _ OPT = new Pair < String , String > ( " pr " , " partitioner - range " ) ; <nl> + private static final Pair < String , String > SNAPSHOT _ REPAIR _ OPT = new Pair < String , String > ( " snapshot " , " with - snapshot " ) ; <nl> <nl> private static final String DEFAULT _ HOST = " 127 . 0 . 0 . 1 " ; <nl> private static final int DEFAULT _ PORT = 7199 ; <nl> @ @ - 71 , 6 + 72 , 7 @ @ public class NodeCmd <nl> options . addOption ( PASSWORD _ OPT , true , " remote jmx agent password " ) ; <nl> options . addOption ( TAG _ OPT , true , " optional name to give a snapshot " ) ; <nl> options . addOption ( PRIMARY _ RANGE _ OPT , false , " only repair the first range returned by the partitioner for the node " ) ; <nl> + options . addOption ( SNAPSHOT _ REPAIR _ OPT , false , " repair one node at a time using snapshots " ) ; <nl> } <nl> <nl> public NodeCmd ( NodeProbe probe ) <nl> @ @ - 921 , 10 + 923 , 11 @ @ public class NodeCmd <nl> switch ( nc ) <nl> { <nl> case REPAIR : <nl> + boolean snapshot = cmd . hasOption ( SNAPSHOT _ REPAIR _ OPT . left ) ; <nl> if ( cmd . hasOption ( PRIMARY _ RANGE _ OPT . left ) ) <nl> - probe . forceTableRepairPrimaryRange ( keyspace , columnFamilies ) ; <nl> + probe . forceTableRepairPrimaryRange ( keyspace , snapshot , columnFamilies ) ; <nl> else <nl> - probe . forceTableRepair ( keyspace , columnFamilies ) ; <nl> + probe . forceTableRepair ( keyspace , snapshot , columnFamilies ) ; <nl> break ; <nl> case FLUSH : <nl> try { probe . forceTableFlush ( keyspace , columnFamilies ) ; } <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> index 46d4c63 . . 8739745 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 202 , 14 + 202 , 14 @ @ public class NodeProbe <nl> ssProxy . forceTableFlush ( tableName , columnFamilies ) ; <nl> } <nl> <nl> - public void forceTableRepair ( String tableName , String . . . columnFamilies ) throws IOException <nl> + public void forceTableRepair ( String tableName , boolean isSequential , String . . . columnFamilies ) throws IOException <nl> { <nl> - ssProxy . forceTableRepair ( tableName , columnFamilies ) ; <nl> + ssProxy . forceTableRepair ( tableName , isSequential , columnFamilies ) ; <nl> } <nl> <nl> - public void forceTableRepairPrimaryRange ( String tableName , String . . . columnFamilies ) throws IOException <nl> + public void forceTableRepairPrimaryRange ( String tableName , boolean isSequential , String . . . columnFamilies ) throws IOException <nl> { <nl> - ssProxy . forceTableRepairPrimaryRange ( tableName , columnFamilies ) ; <nl> + ssProxy . forceTableRepairPrimaryRange ( tableName , isSequential , columnFamilies ) ; <nl> } <nl> <nl> public void invalidateKeyCache ( ) throws IOException

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkOutputFormat . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkOutputFormat . java 
 index 58e05b6 . . 887fe8e 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkOutputFormat . java 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkOutputFormat . java 
 @ @ - 53 , 6 + 53 , 7 @ @ public class CqlBulkOutputFormat extends AbstractBulkOutputFormat < Object , List < B 
 
 private static final String OUTPUT _ CQL _ SCHEMA _ PREFIX = " cassandra . columnfamily . schema . " ; 
 private static final String OUTPUT _ CQL _ INSERT _ PREFIX = " cassandra . columnfamily . insert . " ; 
 + private static final String DELETE _ SOURCE = " cassandra . output . delete . source " ; 
 
 / * * Fills the deprecated OutputFormat interface for streaming . * / 
 @ Deprecated 
 @ @ - 103 , 4 + 104 , 14 @ @ public class CqlBulkOutputFormat extends AbstractBulkOutputFormat < Object , List < B 
 } 
 return insert ; 
 } 
 + 
 + public static void setDeleteSourceOnSuccess ( Configuration conf , boolean deleteSrc ) 
 + { 
 + conf . setBoolean ( DELETE _ SOURCE , deleteSrc ) ; 
 + } 
 + 
 + public static boolean getDeleteSourceOnSuccess ( Configuration conf ) 
 + { 
 + return conf . getBoolean ( DELETE _ SOURCE , false ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkRecordWriter . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkRecordWriter . java 
 index 7a75bb4 . . 43e3a12 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkRecordWriter . java 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlBulkRecordWriter . java 
 @ @ - 32 , 6 + 32 , 8 @ @ import org . apache . cassandra . hadoop . ConfigHelper ; 
 import org . apache . cassandra . hadoop . HadoopCompat ; 
 import org . apache . cassandra . io . sstable . CQLSSTableWriter ; 
 import org . apache . cassandra . io . sstable . SSTableLoader ; 
 + import org . apache . cassandra . io . util . FileUtils ; 
 + import org . apache . cassandra . streaming . StreamState ; 
 import org . apache . hadoop . conf . Configuration ; 
 import org . apache . hadoop . mapreduce . TaskAttemptContext ; 
 import org . apache . hadoop . util . Progressable ; 
 @ @ - 57 , 6 + 59 , 7 @ @ public class CqlBulkRecordWriter extends AbstractBulkRecordWriter < Object , List < B 
 private String schema ; 
 private String insertStatement ; 
 private File outputDir ; 
 + private boolean deleteSrc ; 
 
 CqlBulkRecordWriter ( TaskAttemptContext context ) throws IOException 
 { 
 @ @ - 84 , 6 + 87 , 7 @ @ public class CqlBulkRecordWriter extends AbstractBulkRecordWriter < Object , List < B 
 schema = CqlBulkOutputFormat . getColumnFamilySchema ( conf , columnFamily ) ; 
 insertStatement = CqlBulkOutputFormat . getColumnFamilyInsertStatement ( conf , columnFamily ) ; 
 outputDir = getColumnFamilyDirectory ( ) ; 
 + deleteSrc = CqlBulkOutputFormat . getDeleteSourceOnSuccess ( conf ) ; 
 } 
 
 
 @ @ - 107 , 7 + 111 , 14 @ @ public class CqlBulkRecordWriter extends AbstractBulkRecordWriter < Object , List < B 
 
 externalClient . addKnownCfs ( keyspace , schema ) ; 
 
 - this . loader = new SSTableLoader ( outputDir , externalClient , new BulkRecordWriter . NullOutputHandler ( ) ) ; 
 + this . loader = new SSTableLoader ( outputDir , externalClient , new BulkRecordWriter . NullOutputHandler ( ) ) { 
 + @ Override 
 + public void onSuccess ( StreamState finalState ) 
 + { 
 + if ( deleteSrc ) 
 + FileUtils . deleteRecursive ( outputDir ) ; 
 + } 
 + } ; 
 } 
 } 
 catch ( Exception e )

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index bf4a000 . . ab3b064 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1423 , 6 + 1423 , 14 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 + public List < SSTableReader > getSnapshotSSTableReader ( String tag ) throws IOException 
 + { 
 + List < SSTableReader > readers = new ArrayList < SSTableReader > ( ) ; 
 + for ( Map . Entry < Descriptor , Set < Component > > entries : directories . sstableLister ( ) . snapshots ( tag ) . list ( ) . entrySet ( ) ) 
 + readers . add ( SSTableReader . open ( entries . getKey ( ) , entries . getValue ( ) , metadata , partitioner ) ) ; 
 + return readers ; 
 + } 
 + 
 / * * 
 * Take a snap shot of this columnfamily store . 
 * 
 diff - - git a / src / java / org / apache / cassandra / db / Directories . java b / src / java / org / apache / cassandra / db / Directories . java 
 index 2afefd2 . . 7c51830 100644 
 - - - a / src / java / org / apache / cassandra / db / Directories . java 
 + + + b / src / java / org / apache / cassandra / db / Directories . java 
 @ @ - 185 , 6 + 185 , 7 @ @ public class Directories 
 private int nbFiles ; 
 private final Map < Descriptor , Set < Component > > components = new HashMap < Descriptor , Set < Component > > ( ) ; 
 private boolean filtered ; 
 + private String snapshotName ; 
 
 public SSTableLister skipCompacted ( boolean b ) 
 { 
 @ @ - 219 , 6 + 220 , 14 @ @ public class Directories 
 return this ; 
 } 
 
 + public SSTableLister snapshots ( String sn ) 
 + { 
 + if ( filtered ) 
 + throw new IllegalStateException ( " list ( ) has already been called " ) ; 
 + snapshotName = sn ; 
 + return this ; 
 + } 
 + 
 public Map < Descriptor , Set < Component > > list ( ) 
 { 
 filter ( ) ; 
 @ @ - 246 , 6 + 255 , 12 @ @ public class Directories 
 
 for ( File location : sstableDirectories ) 
 { 
 + if ( snapshotName ! = null ) 
 + { 
 + new File ( location , join ( SNAPSHOT _ SUBDIR , snapshotName ) ) . listFiles ( getFilter ( ) ) ; 
 + continue ; 
 + } 
 + 
 if ( ! onlyBackups ) 
 location . listFiles ( getFilter ( ) ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index c02aed2 . . 448c569 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 799 , 23 + 799 , 33 @ @ public class CompactionManager implements CompactionManagerMBean 
 if ( ! cfs . isValid ( ) ) 
 return ; 
 
 - / / flush first so everyone is validating data that is as similar as possible 
 - try 
 - { 
 - StorageService . instance . forceTableFlush ( cfs . table . name , cfs . getColumnFamilyName ( ) ) ; 
 - } 
 - catch ( ExecutionException e ) 
 + Collection < SSTableReader > sstables ; 
 + if ( cfs . table . snapshotExists ( validator . request . sessionid ) ) 
 { 
 - throw new IOException ( e ) ; 
 + / / If there is a snapshot created for the session then read from there . 
 + sstables = cfs . getSnapshotSSTableReader ( validator . request . sessionid ) ; 
 } 
 - catch ( InterruptedException e ) 
 + else 
 { 
 - throw new AssertionError ( e ) ; 
 + / / flush first so everyone is validating data that is as similar as possible 
 + try 
 + { 
 + StorageService . instance . forceTableFlush ( cfs . table . name , cfs . getColumnFamilyName ( ) ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + throw new IOException ( e ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + 
 + / / we don ' t mark validating sstables as compacting in DataTracker , so we have to mark them referenced 
 + / / instead so they won ' t be cleaned up if they do get compacted during the validation 
 + sstables = cfs . markCurrentSSTablesReferenced ( ) ; 
 } 
 
 - / / we don ' t mark validating sstables as compacting in DataTracker , so we have to mark them referenced 
 - / / instead so they won ' t be cleaned up if they do get compacted during the validation 
 - Collection < SSTableReader > sstables = cfs . markCurrentSSTablesReferenced ( ) ; 
 CompactionIterable ci = new ValidationCompactionIterable ( cfs , sstables , validator . request . range ) ; 
 CloseableIterator < AbstractCompactedRow > iter = ci . iterator ( ) ; 
 validationExecutor . beginCompaction ( ci ) ; 
 @ @ - 838 , 6 + 848 , 9 @ @ public class CompactionManager implements CompactionManagerMBean 
 { 
 SSTableReader . releaseReferences ( sstables ) ; 
 iter . close ( ) ; 
 + if ( cfs . table . snapshotExists ( validator . request . sessionid ) ) 
 + cfs . table . clearSnapshot ( validator . request . sessionid ) ; 
 + 
 validationExecutor . finishCompaction ( ci ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / AntiEntropyService . java b / src / java / org / apache / cassandra / service / AntiEntropyService . java 
 index 812c23a . . 10ea80c 100644 
 - - - a / src / java / org / apache / cassandra / service / AntiEntropyService . java 
 + + + b / src / java / org / apache / cassandra / service / AntiEntropyService . java 
 @ @ - 38 , 6 + 38 , 7 @ @ import org . apache . cassandra . db . compaction . AbstractCompactedRow ; 
 import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . DecoratedKey ; 
 import org . apache . cassandra . db . Table ; 
 + import org . apache . cassandra . db . SnapshotCommand ; 
 import org . apache . cassandra . dht . AbstractBounds ; 
 import org . apache . cassandra . dht . RandomPartitioner ; 
 import org . apache . cassandra . dht . Range ; 
 @ @ - 47 , 6 + 48 , 7 @ @ import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . io . util . FastByteArrayInputStream ; 
 import org . apache . cassandra . io . util . FastByteArrayOutputStream ; 
 import org . apache . cassandra . net . CompactEndpointSerializationHelper ; 
 + import org . apache . cassandra . net . IAsyncCallback ; 
 import org . apache . cassandra . net . IVerbHandler ; 
 import org . apache . cassandra . net . Message ; 
 import org . apache . cassandra . net . MessagingService ; 
 @ @ - 119 , 9 + 121 , 9 @ @ public class AntiEntropyService 
 / * * 
 * Requests repairs for the given table and column families , and blocks until all repairs have been completed . 
 * / 
 - public RepairFuture submitRepairSession ( Range < Token > range , String tablename , String . . . cfnames ) 
 + public RepairFuture submitRepairSession ( Range < Token > range , String tablename , boolean isSequential , String . . . cfnames ) 
 { 
 - RepairFuture futureTask = new RepairSession ( range , tablename , cfnames ) . getFuture ( ) ; 
 + RepairFuture futureTask = new RepairSession ( range , tablename , isSequential , cfnames ) . getFuture ( ) ; 
 executor . execute ( futureTask ) ; 
 return futureTask ; 
 } 
 @ @ - 209 , 16 + 211 , 6 @ @ public class AntiEntropyService 
 } 
 
 / * * 
 - * Requests a tree from the given node , and returns the request that was sent . 
 - * / 
 - TreeRequest request ( String sessionid , InetAddress remote , Range < Token > range , String ksname , String cfname ) 
 - { 
 - TreeRequest request = new TreeRequest ( sessionid , remote , range , new CFPair ( ksname , cfname ) ) ; 
 - MessagingService . instance ( ) . sendOneWay ( TreeRequestVerbHandler . makeVerb ( request , Gossiper . instance . getVersion ( remote ) ) , remote ) ; 
 - return request ; 
 - } 
 - 
 - / * * 
 * Responds to the node that requested the given valid tree . 
 * @ param validator A locally generated validator 
 * @ param local localhost ( parameterized for testing ) 
 @ @ - 598 , 6 + 590 , 7 @ @ public class AntiEntropyService 
 static class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber , IFailureDetectionEventListener 
 { 
 private final String sessionName ; 
 + private final boolean isSequential ; 
 private final String tablename ; 
 private final String [ ] cfnames ; 
 private final Range < Token > range ; 
 @ @ - 615 , 18 + 608 , 19 @ @ public class AntiEntropyService 
 
 public RepairSession ( TreeRequest req , String tablename , String . . . cfnames ) 
 { 
 - this ( req . sessionid , req . range , tablename , cfnames ) ; 
 + this ( req . sessionid , req . range , tablename , false , cfnames ) ; 
 AntiEntropyService . instance . sessions . put ( getName ( ) , this ) ; 
 } 
 
 - public RepairSession ( Range < Token > range , String tablename , String . . . cfnames ) 
 + public RepairSession ( Range < Token > range , String tablename , boolean isSequential , String . . . cfnames ) 
 { 
 - this ( UUIDGen . makeType1UUIDFromHost ( FBUtilities . getBroadcastAddress ( ) ) . toString ( ) , range , tablename , cfnames ) ; 
 + this ( UUIDGen . makeType1UUIDFromHost ( FBUtilities . getBroadcastAddress ( ) ) . toString ( ) , range , tablename , isSequential , cfnames ) ; 
 } 
 
 - private RepairSession ( String id , Range < Token > range , String tablename , String [ ] cfnames ) 
 + private RepairSession ( String id , Range < Token > range , String tablename , boolean isSequential , String [ ] cfnames ) 
 { 
 this . sessionName = id ; 
 + this . isSequential = isSequential ; 
 this . tablename = tablename ; 
 this . cfnames = cfnames ; 
 assert cfnames . length > 0 : " Repairing no column families seems pointless , doesn ' t it " ; 
 @ @ - 674 , 6 + 668 , 12 @ @ public class AntiEntropyService 
 logger . info ( String . format ( " [ repair # % s ] Cannot proceed on repair because a neighbor ( % s ) is dead : session failed " , getName ( ) , endpoint ) ) ; 
 return ; 
 } 
 + 
 + if ( Gossiper . instance . getVersion ( endpoint ) < MessagingService . VERSION _ 11 & & isSequential ) 
 + { 
 + logger . info ( String . format ( " [ repair # % s ] Cannot repair using snapshots as node % s is pre - 1 . 1 " , getName ( ) , endpoint ) ) ; 
 + return ; 
 + } 
 } 
 
 AntiEntropyService . instance . sessions . put ( getName ( ) , this ) ; 
 @ @ - 729 , 6 + 729 , 8 @ @ public class AntiEntropyService 
 public void terminate ( ) 
 { 
 terminated = true ; 
 + for ( RepairJob job : jobs ) 
 + job . terminate ( ) ; 
 jobs . clear ( ) ; 
 activeJobs . clear ( ) ; 
 } 
 @ @ - 810 , 17 + 812 , 32 @ @ public class AntiEntropyService 
 { 
 private final String cfname ; 
 / / first we send tree requests . this tracks the endpoints remaining to hear from 
 - private final Set < InetAddress > remainingEndpoints = new HashSet < InetAddress > ( ) ; 
 + private final RequestCoordinator < TreeRequest > treeRequests ; 
 / / tree responses are then tracked here 
 private final List < TreeResponse > trees = new ArrayList < TreeResponse > ( endpoints . size ( ) + 1 ) ; 
 / / once all responses are received , each tree is compared with each other , and differencer tasks 
 / / are submitted . the job is done when all differencers are complete . 
 - private final Set < Differencer > remainingDifferencers = new HashSet < Differencer > ( ) ; 
 + private final RequestCoordinator < Differencer > differencers ; 
 private final Condition requestsSent = new SimpleCondition ( ) ; 
 + private CountDownLatch snapshotLatch = null ; 
 
 public RepairJob ( String cfname ) 
 { 
 this . cfname = cfname ; 
 + this . treeRequests = new RequestCoordinator < TreeRequest > ( isSequential ) 
 + { 
 + public void send ( TreeRequest r ) 
 + { 
 + MessagingService . instance ( ) . sendOneWay ( TreeRequestVerbHandler . makeVerb ( r , Gossiper . instance . getVersion ( r . endpoint ) ) , r . endpoint ) ; 
 + } 
 + } ; 
 + this . differencers = new RequestCoordinator < Differencer > ( isSequential ) 
 + { 
 + public void send ( Differencer d ) 
 + { 
 + StageManager . getStage ( Stage . ANTI _ ENTROPY ) . execute ( d ) ; 
 + } 
 + } ; 
 } 
 
 / * * 
 @ @ - 828 , 17 + 845 , 51 @ @ public class AntiEntropyService 
 * / 
 public void sendTreeRequests ( ) 
 { 
 - remainingEndpoints . addAll ( endpoints ) ; 
 - remainingEndpoints . add ( FBUtilities . getBroadcastAddress ( ) ) ; 
 - 
 / / send requests to all nodes 
 - for ( InetAddress endpoint : remainingEndpoints ) 
 - AntiEntropyService . instance . request ( getName ( ) , endpoint , range , tablename , cfname ) ; 
 + List < InetAddress > allEndpoints = new ArrayList < InetAddress > ( endpoints ) ; 
 + allEndpoints . add ( FBUtilities . getBroadcastAddress ( ) ) ; 
 
 - logger . info ( String . format ( " [ repair # % s ] requests for merkle tree sent for % s ( to % s ) " , getName ( ) , cfname , remainingEndpoints ) ) ; 
 + if ( isSequential ) 
 + makeSnapshots ( endpoints ) ; 
 + 
 + for ( InetAddress endpoint : allEndpoints ) 
 + treeRequests . add ( new TreeRequest ( getName ( ) , endpoint , range , new CFPair ( tablename , cfname ) ) ) ; 
 + 
 + logger . info ( String . format ( " [ repair # % s ] requesting merkle trees for % s ( to % s ) " , getName ( ) , cfname , allEndpoints ) ) ; 
 + treeRequests . start ( ) ; 
 requestsSent . signalAll ( ) ; 
 } 
 
 + public void makeSnapshots ( Collection < InetAddress > endpoints ) 
 + { 
 + try 
 + { 
 + snapshotLatch = new CountDownLatch ( endpoints . size ( ) ) ; 
 + IAsyncCallback callback = new IAsyncCallback ( ) 
 + { 
 + @ Override 
 + public boolean isLatencyForSnitch ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + @ Override 
 + public void response ( Message msg ) 
 + { 
 + RepairJob . this . snapshotLatch . countDown ( ) ; 
 + } 
 + } ; 
 + for ( InetAddress endpoint : endpoints ) 
 + MessagingService . instance ( ) . sendRR ( new SnapshotCommand ( tablename , cfname , sessionName , false ) , endpoint , callback ) ; 
 + snapshotLatch . await ( ) ; 
 + snapshotLatch = null ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 / * * 
 * Add a new received tree and return the number of remaining tree to 
 * be received for the job to be complete . 
 @ @ - 859 , 8 + 910 , 7 @ @ public class AntiEntropyService 
 
 assert request . cf . right . equals ( cfname ) ; 
 trees . add ( new TreeResponse ( request . endpoint , tree ) ) ; 
 - remainingEndpoints . remove ( request . endpoint ) ; 
 - return remainingEndpoints . size ( ) ; 
 + return treeRequests . completed ( request ) ; 
 } 
 
 / * * 
 @ @ - 869 , 8 + 919 , 6 @ @ public class AntiEntropyService 
 * / 
 public void submitDifferencers ( ) 
 { 
 - assert remainingEndpoints . isEmpty ( ) ; 
 - 
 / / We need to difference all trees one against another 
 for ( int i = 0 ; i < trees . size ( ) - 1 ; + + i ) 
 { 
 @ @ - 880 , 10 + 928 , 10 @ @ public class AntiEntropyService 
 TreeResponse r2 = trees . get ( j ) ; 
 Differencer differencer = new Differencer ( cfname , r1 , r2 ) ; 
 logger . debug ( " Queueing comparison { } " , differencer ) ; 
 - remainingDifferencers . add ( differencer ) ; 
 - StageManager . getStage ( Stage . ANTI _ ENTROPY ) . execute ( differencer ) ; 
 + differencers . add ( differencer ) ; 
 } 
 } 
 + differencers . start ( ) ; 
 trees . clear ( ) ; / / allows gc to do its thing 
 } 
 
 @ @ - 892 , 8 + 940 , 16 @ @ public class AntiEntropyService 
 * / 
 synchronized boolean completedSynchronization ( Differencer differencer ) 
 { 
 - remainingDifferencers . remove ( differencer ) ; 
 - return remainingDifferencers . isEmpty ( ) ; 
 + return differencers . completed ( differencer ) = = 0 ; 
 + } 
 + 
 + public void terminate ( ) 
 + { 
 + if ( snapshotLatch ! = null ) 
 + { 
 + while ( snapshotLatch . getCount ( ) > 0 ) 
 + snapshotLatch . countDown ( ) ; 
 + } 
 } 
 } 
 
 @ @ - 992 , 4 + 1048 , 107 @ @ public class AntiEntropyService 
 this . session = session ; 
 } 
 } 
 + 
 + public static abstract class RequestCoordinator < R > 
 + { 
 + private final Order < R > orderer ; 
 + 
 + protected RequestCoordinator ( boolean isSequential ) 
 + { 
 + this . orderer = isSequential ? new SequentialOrder < R > ( this ) : new ParallelOrder < R > ( this ) ; 
 + } 
 + 
 + public abstract void send ( R request ) ; 
 + 
 + public void add ( R request ) 
 + { 
 + orderer . add ( request ) ; 
 + } 
 + 
 + public void start ( ) 
 + { 
 + orderer . start ( ) ; 
 + } 
 + 
 + / / Returns how many request remains 
 + public int completed ( R request ) 
 + { 
 + return orderer . completed ( request ) ; 
 + } 
 + 
 + private static abstract class Order < R > 
 + { 
 + protected final RequestCoordinator < R > coordinator ; 
 + 
 + Order ( RequestCoordinator < R > coordinator ) 
 + { 
 + this . coordinator = coordinator ; 
 + } 
 + 
 + public abstract void add ( R request ) ; 
 + public abstract void start ( ) ; 
 + public abstract int completed ( R request ) ; 
 + } 
 + 
 + private static class SequentialOrder < R > extends Order < R > 
 + { 
 + private final Queue < R > requests = new LinkedList < R > ( ) ; 
 + 
 + SequentialOrder ( RequestCoordinator < R > coordinator ) 
 + { 
 + super ( coordinator ) ; 
 + } 
 + 
 + public void add ( R request ) 
 + { 
 + requests . add ( request ) ; 
 + } 
 + 
 + public void start ( ) 
 + { 
 + if ( requests . isEmpty ( ) ) 
 + return ; 
 + 
 + coordinator . send ( requests . peek ( ) ) ; 
 + } 
 + 
 + public int completed ( R request ) 
 + { 
 + assert request . equals ( requests . peek ( ) ) ; 
 + requests . poll ( ) ; 
 + int remaining = requests . size ( ) ; 
 + if ( remaining ! = 0 ) 
 + coordinator . send ( requests . peek ( ) ) ; 
 + return remaining ; 
 + } 
 + } 
 + 
 + private static class ParallelOrder < R > extends Order < R > 
 + { 
 + private final Set < R > requests = new HashSet < R > ( ) ; 
 + 
 + ParallelOrder ( RequestCoordinator < R > coordinator ) 
 + { 
 + super ( coordinator ) ; 
 + } 
 + 
 + public void add ( R request ) 
 + { 
 + requests . add ( request ) ; 
 + } 
 + 
 + public void start ( ) 
 + { 
 + for ( R request : requests ) 
 + coordinator . send ( request ) ; 
 + } 
 + 
 + public int completed ( R request ) 
 + { 
 + requests . remove ( request ) ; 
 + return requests . size ( ) ; 
 + } 
 + } 
 + 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index c1681b9 . . 58986a5 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 1827 , 12 + 1827 , 11 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 * @ param columnFamilies 
 * @ throws IOException 
 * / 
 - public void forceTableRepair ( final String tableName , final String . . . columnFamilies ) throws IOException 
 + public void forceTableRepair ( final String tableName , boolean isSequential , final String . . . columnFamilies ) throws IOException 
 { 
 if ( Table . SYSTEM _ TABLE . equals ( tableName ) ) 
 return ; 
 
 - 
 Collection < Range < Token > > ranges = getLocalRanges ( tableName ) ; 
 int cmd = nextRepairCommand . incrementAndGet ( ) ; 
 logger _ . info ( " Starting repair command # { } , repairing { } ranges . " , cmd , ranges . size ( ) ) ; 
 @ @ - 1840 , 7 + 1839 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 List < AntiEntropyService . RepairFuture > futures = new ArrayList < AntiEntropyService . RepairFuture > ( ranges . size ( ) ) ; 
 for ( Range < Token > range : ranges ) 
 { 
 - AntiEntropyService . RepairFuture future = forceTableRepair ( range , tableName , columnFamilies ) ; 
 + AntiEntropyService . RepairFuture future = forceTableRepair ( range , tableName , isSequential , columnFamilies ) ; 
 futures . add ( future ) ; 
 / / wait for a session to be done with its differencing before starting the next one 
 try 
 @ @ - 1875 , 12 + 1874 , 12 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 logger _ . info ( " Repair command # { } completed successfully " , cmd ) ; 
 } 
 
 - public void forceTableRepairPrimaryRange ( final String tableName , final String . . . columnFamilies ) throws IOException 
 + public void forceTableRepairPrimaryRange ( final String tableName , boolean isSequential , final String . . . columnFamilies ) throws IOException 
 { 
 if ( Table . SYSTEM _ TABLE . equals ( tableName ) ) 
 return ; 
 
 - AntiEntropyService . RepairFuture future = forceTableRepair ( getLocalPrimaryRange ( ) , tableName , columnFamilies ) ; 
 + AntiEntropyService . RepairFuture future = forceTableRepair ( getLocalPrimaryRange ( ) , tableName , isSequential , columnFamilies ) ; 
 try 
 { 
 future . get ( ) ; 
 @ @ - 1892 , 7 + 1891 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 } 
 } 
 
 - public AntiEntropyService . RepairFuture forceTableRepair ( final Range < Token > range , final String tableName , final String . . . columnFamilies ) throws IOException 
 + public AntiEntropyService . RepairFuture forceTableRepair ( final Range < Token > range , final String tableName , boolean isSequential , final String . . . columnFamilies ) throws IOException 
 { 
 ArrayList < String > names = new ArrayList < String > ( ) ; 
 for ( ColumnFamilyStore cfStore : getValidColumnFamilies ( tableName , columnFamilies ) ) 
 @ @ - 1900 , 7 + 1899 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 names . add ( cfStore . getColumnFamilyName ( ) ) ; 
 } 
 
 - return AntiEntropyService . instance . submitRepairSession ( range , tableName , names . toArray ( new String [ names . size ( ) ] ) ) ; 
 + return AntiEntropyService . instance . submitRepairSession ( range , tableName , isSequential , names . toArray ( new String [ names . size ( ) ] ) ) ; 
 } 
 
 public void forceTerminateAllRepairSessions ( ) { 
 diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 index 6af63b7 . . c5aa9fd 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 @ @ - 231 , 12 + 231 , 12 @ @ public interface StorageServiceMBean 
 * @ param columnFamilies 
 * @ throws IOException 
 * / 
 - public void forceTableRepair ( String tableName , String . . . columnFamilies ) throws IOException ; 
 + public void forceTableRepair ( String tableName , boolean isSequential , String . . . columnFamilies ) throws IOException ; 
 
 / * * 
 * Triggers proactive repair but only for the node primary range . 
 * / 
 - public void forceTableRepairPrimaryRange ( String tableName , String . . . columnFamilies ) throws IOException ; 
 + public void forceTableRepairPrimaryRange ( String tableName , boolean isSequential , String . . . columnFamilies ) throws IOException ; 
 
 public void forceTerminateAllRepairSessions ( ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index 2b19074 . . 8a224b8 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 53 , 6 + 53 , 7 @ @ public class NodeCmd 
 private static final Pair < String , String > PASSWORD _ OPT = new Pair < String , String > ( " pw " , " password " ) ; 
 private static final Pair < String , String > TAG _ OPT = new Pair < String , String > ( " t " , " tag " ) ; 
 private static final Pair < String , String > PRIMARY _ RANGE _ OPT = new Pair < String , String > ( " pr " , " partitioner - range " ) ; 
 + private static final Pair < String , String > SNAPSHOT _ REPAIR _ OPT = new Pair < String , String > ( " snapshot " , " with - snapshot " ) ; 
 
 private static final String DEFAULT _ HOST = " 127 . 0 . 0 . 1 " ; 
 private static final int DEFAULT _ PORT = 7199 ; 
 @ @ - 71 , 6 + 72 , 7 @ @ public class NodeCmd 
 options . addOption ( PASSWORD _ OPT , true , " remote jmx agent password " ) ; 
 options . addOption ( TAG _ OPT , true , " optional name to give a snapshot " ) ; 
 options . addOption ( PRIMARY _ RANGE _ OPT , false , " only repair the first range returned by the partitioner for the node " ) ; 
 + options . addOption ( SNAPSHOT _ REPAIR _ OPT , false , " repair one node at a time using snapshots " ) ; 
 } 
 
 public NodeCmd ( NodeProbe probe ) 
 @ @ - 921 , 10 + 923 , 11 @ @ public class NodeCmd 
 switch ( nc ) 
 { 
 case REPAIR : 
 + boolean snapshot = cmd . hasOption ( SNAPSHOT _ REPAIR _ OPT . left ) ; 
 if ( cmd . hasOption ( PRIMARY _ RANGE _ OPT . left ) ) 
 - probe . forceTableRepairPrimaryRange ( keyspace , columnFamilies ) ; 
 + probe . forceTableRepairPrimaryRange ( keyspace , snapshot , columnFamilies ) ; 
 else 
 - probe . forceTableRepair ( keyspace , columnFamilies ) ; 
 + probe . forceTableRepair ( keyspace , snapshot , columnFamilies ) ; 
 break ; 
 case FLUSH : 
 try { probe . forceTableFlush ( keyspace , columnFamilies ) ; } 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 index 46d4c63 . . 8739745 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 202 , 14 + 202 , 14 @ @ public class NodeProbe 
 ssProxy . forceTableFlush ( tableName , columnFamilies ) ; 
 } 
 
 - public void forceTableRepair ( String tableName , String . . . columnFamilies ) throws IOException 
 + public void forceTableRepair ( String tableName , boolean isSequential , String . . . columnFamilies ) throws IOException 
 { 
 - ssProxy . forceTableRepair ( tableName , columnFamilies ) ; 
 + ssProxy . forceTableRepair ( tableName , isSequential , columnFamilies ) ; 
 } 
 
 - public void forceTableRepairPrimaryRange ( String tableName , String . . . columnFamilies ) throws IOException 
 + public void forceTableRepairPrimaryRange ( String tableName , boolean isSequential , String . . . columnFamilies ) throws IOException 
 { 
 - ssProxy . forceTableRepairPrimaryRange ( tableName , columnFamilies ) ; 
 + ssProxy . forceTableRepairPrimaryRange ( tableName , isSequential , columnFamilies ) ; 
 } 
 
 public void invalidateKeyCache ( ) throws IOException
