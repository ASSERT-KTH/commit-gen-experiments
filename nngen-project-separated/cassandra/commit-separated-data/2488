BLEU SCORE: 0.021906016114066472

TEST MSG: Fix broken build
GENERATED MSG: Support query by names for compact CF ( CQL3 )

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> index 23f7cfe . . 7f8b678 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> @ @ - 23 , 23 + 23 , 18 @ @ import java . util . * ; <nl> import com . google . common . base . Function ; <nl> import com . google . common . collect . Iterables ; <nl> import org . github . jamm . MemoryMeter ; <nl> - import org . slf4j . Logger ; <nl> - import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . auth . Permission ; <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> import org . apache . cassandra . cql3 . * ; <nl> import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . db . composites . CBuilder ; <nl> + import org . apache . cassandra . db . composites . Composite ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> - import org . apache . cassandra . db . filter . IDiskAtomFilter ; <nl> import org . apache . cassandra . db . filter . SliceQueryFilter ; <nl> - import org . apache . cassandra . db . marshal . CompositeType ; <nl> - import org . apache . cassandra . db . marshal . UTF8Type ; <nl> - import org . apache . cassandra . db . marshal . ListType ; <nl> import org . apache . cassandra . db . marshal . BooleanType ; <nl> import org . apache . cassandra . exceptions . * ; <nl> - import org . apache . cassandra . service . CASConditions ; <nl> import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . QueryState ; <nl> import org . apache . cassandra . service . StorageProxy ; <nl> @ @ - 54 , 21 + 49 , 16 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> { <nl> private static final ColumnIdentifier CAS _ RESULT _ COLUMN = new ColumnIdentifier ( " [ applied ] " , false ) ; <nl> <nl> - private static final Logger logger = LoggerFactory . getLogger ( ModificationStatement . class ) ; <nl> - <nl> - private static boolean loggedCounterTTL = false ; <nl> - private static boolean loggedCounterTimestamp = false ; <nl> - <nl> public static enum StatementType { INSERT , UPDATE , DELETE } <nl> public final StatementType type ; <nl> <nl> + private final int boundTerms ; <nl> public final CFMetaData cfm ; <nl> public final Attributes attrs ; <nl> <nl> private final Map < ColumnIdentifier , Restriction > processedKeys = new HashMap < ColumnIdentifier , Restriction > ( ) ; <nl> private final List < Operation > columnOperations = new ArrayList < Operation > ( ) ; <nl> <nl> - private int boundTerms ; <nl> / / Separating normal and static conditions makes things somewhat easier <nl> private List < ColumnCondition > columnConditions ; <nl> private List < ColumnCondition > staticConditions ; <nl> @ @ - 80 , 17 + 70 , 18 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> private boolean setsStaticColumns ; <nl> private boolean setsRegularColumns ; <nl> <nl> - private final Function < ColumnCondition , ColumnIdentifier > getColumnForCondition = new Function < ColumnCondition , ColumnIdentifier > ( ) <nl> + private final Function < ColumnCondition , ColumnDefinition > getColumnForCondition = new Function < ColumnCondition , ColumnDefinition > ( ) <nl> { <nl> - public ColumnIdentifier apply ( ColumnCondition cond ) <nl> + public ColumnDefinition apply ( ColumnCondition cond ) <nl> { <nl> - return cond . column . name ; <nl> + return cond . column ; <nl> } <nl> } ; <nl> <nl> - public ModificationStatement ( StatementType type , CFMetaData cfm , Attributes attrs ) <nl> + public ModificationStatement ( StatementType type , int boundTerms , CFMetaData cfm , Attributes attrs ) <nl> { <nl> this . type = type ; <nl> + this . boundTerms = boundTerms ; <nl> this . cfm = cfm ; <nl> this . attrs = attrs ; <nl> } <nl> @ @ - 106 , 7 + 97 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> } <nl> <nl> public abstract boolean requireFullClusteringKey ( ) ; <nl> - public abstract void addUpdateForKey ( ColumnFamily updates , ByteBuffer key , ColumnNameBuilder builder , UpdateParameters params ) throws InvalidRequestException ; <nl> + public abstract void addUpdateForKey ( ColumnFamily updates , ByteBuffer key , Composite prefix , UpdateParameters params ) throws InvalidRequestException ; <nl> <nl> public int getBoundTerms ( ) <nl> { <nl> @ @ - 125 , 12 + 116 , 12 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> <nl> public boolean isCounter ( ) <nl> { <nl> - return cfm . getDefaultValidator ( ) . isCommutative ( ) ; <nl> + return cfm . isCounter ( ) ; <nl> } <nl> <nl> - public long getTimestamp ( long now , List < ByteBuffer > variables ) throws InvalidRequestException <nl> + public long getTimestamp ( long now , QueryOptions options ) throws InvalidRequestException <nl> { <nl> - return attrs . getTimestamp ( now , variables ) ; <nl> + return attrs . getTimestamp ( now , options ) ; <nl> } <nl> <nl> public boolean isTimestampSet ( ) <nl> @ @ - 138 , 9 + 129 , 9 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> return attrs . isTimestampSet ( ) ; <nl> } <nl> <nl> - public int getTimeToLive ( List < ByteBuffer > variables ) throws InvalidRequestException <nl> + public int getTimeToLive ( QueryOptions options ) throws InvalidRequestException <nl> { <nl> - return attrs . getTimeToLive ( variables ) ; <nl> + return attrs . getTimeToLive ( options ) ; <nl> } <nl> <nl> public void checkAccess ( ClientState state ) throws InvalidRequestException , UnauthorizedException <nl> @ @ - 155 , 31 + 146 , 18 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> public void validate ( ClientState state ) throws InvalidRequestException <nl> { <nl> if ( hasConditions ( ) & & attrs . isTimestampSet ( ) ) <nl> - throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; <nl> + throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional updates " ) ; <nl> <nl> - if ( isCounter ( ) ) <nl> - { <nl> - if ( attrs . isTimestampSet ( ) & & ! loggedCounterTimestamp ) <nl> - { <nl> - logger . warn ( " Detected use of ' USING TIMESTAMP ' in a counter UPDATE . This is invalid " + <nl> - " because counters do not use timestamps , and the timestamp has been ignored . " + <nl> - " Such queries will be rejected in Cassandra 2 . 1 + - please fix your queries before then . " ) ; <nl> - loggedCounterTimestamp = true ; <nl> - } <nl> + if ( isCounter ( ) & & attrs . isTimestampSet ( ) ) <nl> + throw new InvalidRequestException ( " Cannot provide custom timestamp for counter updates " ) ; <nl> <nl> - if ( attrs . isTimeToLiveSet ( ) & & ! loggedCounterTTL ) <nl> - { <nl> - logger . warn ( " Detected use of ' USING TTL ' in a counter UPDATE . This is invalid " + <nl> - " because counter tables do not support TTL , and the TTL value has been ignored . " + <nl> - " Such queries will be rejected in Cassandra 2 . 1 + - please fix your queries before then . " ) ; <nl> - loggedCounterTTL = true ; <nl> - } <nl> - } <nl> + if ( isCounter ( ) & & attrs . isTimeToLiveSet ( ) ) <nl> + throw new InvalidRequestException ( " Cannot provide custom TTL for counter updates " ) ; <nl> } <nl> <nl> public void addOperation ( Operation op ) <nl> { <nl> - if ( op . isStatic ( cfm ) ) <nl> + if ( op . column . isStatic ( ) ) <nl> setsStaticColumns = true ; <nl> else <nl> setsRegularColumns = true ; <nl> @ @ - 191 , 19 + 169 , 19 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> return columnOperations ; <nl> } <nl> <nl> - public Iterable < ColumnIdentifier > getColumnsWithConditions ( ) <nl> + public Iterable < ColumnDefinition > getColumnsWithConditions ( ) <nl> { <nl> if ( ifNotExists | | ifExists ) <nl> return null ; <nl> <nl> - return Iterables . concat ( columnConditions = = null ? Collections . < ColumnIdentifier > emptyList ( ) : Iterables . transform ( columnConditions , getColumnForCondition ) , <nl> - staticConditions = = null ? Collections . < ColumnIdentifier > emptyList ( ) : Iterables . transform ( staticConditions , getColumnForCondition ) ) ; <nl> + return Iterables . concat ( columnConditions = = null ? Collections . < ColumnDefinition > emptyList ( ) : Iterables . transform ( columnConditions , getColumnForCondition ) , <nl> + staticConditions = = null ? Collections . < ColumnDefinition > emptyList ( ) : Iterables . transform ( staticConditions , getColumnForCondition ) ) ; <nl> } <nl> <nl> public void addCondition ( ColumnCondition cond ) throws InvalidRequestException <nl> { <nl> List < ColumnCondition > conds = null ; <nl> - if ( cond . column . kind = = CFDefinition . Name . Kind . STATIC ) <nl> + if ( cond . column . isStatic ( ) ) <nl> { <nl> setsStaticColumns = true ; <nl> if ( staticConditions = = null ) <nl> @ @ - 240 , 45 + 218 , 44 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> return ifExists ; <nl> } <nl> <nl> - private void addKeyValues ( CFDefinition . Name name , Restriction values ) throws InvalidRequestException <nl> + private void addKeyValues ( ColumnDefinition def , Restriction values ) throws InvalidRequestException <nl> { <nl> - if ( name . kind = = CFDefinition . Name . Kind . COLUMN _ ALIAS ) <nl> + if ( def . kind = = ColumnDefinition . Kind . CLUSTERING _ COLUMN ) <nl> hasNoClusteringColumns = false ; <nl> - if ( processedKeys . put ( name . name , values ) ! = null ) <nl> - throw new InvalidRequestException ( String . format ( " Multiple definitions found for PRIMARY KEY part % s " , name . name ) ) ; <nl> + if ( processedKeys . put ( def . name , values ) ! = null ) <nl> + throw new InvalidRequestException ( String . format ( " Multiple definitions found for PRIMARY KEY part % s " , def . name ) ) ; <nl> } <nl> <nl> - public void addKeyValue ( CFDefinition . Name name , Term value ) throws InvalidRequestException <nl> + public void addKeyValue ( ColumnDefinition def , Term value ) throws InvalidRequestException <nl> { <nl> - addKeyValues ( name , new Restriction . EQ ( value , false ) ) ; <nl> + addKeyValues ( def , new Restriction . EQ ( value , false ) ) ; <nl> } <nl> <nl> public void processWhereClause ( List < Relation > whereClause , VariableSpecifications names ) throws InvalidRequestException <nl> { <nl> - CFDefinition cfDef = cfm . getCfDef ( ) ; <nl> for ( Relation rel : whereClause ) <nl> { <nl> - CFDefinition . Name name = cfDef . get ( rel . getEntity ( ) ) ; <nl> - if ( name = = null ) <nl> + ColumnDefinition def = cfm . getColumnDefinition ( rel . getEntity ( ) ) ; <nl> + if ( def = = null ) <nl> throw new InvalidRequestException ( String . format ( " Unknown key identifier % s " , rel . getEntity ( ) ) ) ; <nl> <nl> - switch ( name . kind ) <nl> + switch ( def . kind ) <nl> { <nl> - case KEY _ ALIAS : <nl> - case COLUMN _ ALIAS : <nl> + case PARTITION _ KEY : <nl> + case CLUSTERING _ COLUMN : <nl> Restriction restriction ; <nl> <nl> if ( rel . operator ( ) = = Relation . Type . EQ ) <nl> { <nl> - Term t = rel . getValue ( ) . prepare ( name ) ; <nl> + Term t = rel . getValue ( ) . prepare ( keyspace ( ) , def ) ; <nl> t . collectMarkerSpecification ( names ) ; <nl> restriction = new Restriction . EQ ( t , false ) ; <nl> } <nl> - else if ( name . kind = = CFDefinition . Name . Kind . KEY _ ALIAS & & rel . operator ( ) = = Relation . Type . IN ) <nl> + else if ( def . kind = = ColumnDefinition . Kind . PARTITION _ KEY & & rel . operator ( ) = = Relation . Type . IN ) <nl> { <nl> if ( rel . getValue ( ) ! = null ) <nl> { <nl> - Term t = rel . getValue ( ) . prepare ( name ) ; <nl> + Term t = rel . getValue ( ) . prepare ( keyspace ( ) , def ) ; <nl> t . collectMarkerSpecification ( names ) ; <nl> restriction = Restriction . IN . create ( t ) ; <nl> } <nl> @ @ - 287 , 7 + 264 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> List < Term > values = new ArrayList < Term > ( rel . getInValues ( ) . size ( ) ) ; <nl> for ( Term . Raw raw : rel . getInValues ( ) ) <nl> { <nl> - Term t = raw . prepare ( name ) ; <nl> + Term t = raw . prepare ( keyspace ( ) , def ) ; <nl> t . collectMarkerSpecification ( names ) ; <nl> values . add ( t ) ; <nl> } <nl> @ @ - 296 , 40 + 273 , 37 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> } <nl> else <nl> { <nl> - throw new InvalidRequestException ( String . format ( " Invalid operator % s for PRIMARY KEY part % s " , rel . operator ( ) , name ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Invalid operator % s for PRIMARY KEY part % s " , rel . operator ( ) , def . name ) ) ; <nl> } <nl> <nl> - addKeyValues ( name , restriction ) ; <nl> + addKeyValues ( def , restriction ) ; <nl> break ; <nl> - case VALUE _ ALIAS : <nl> - case COLUMN _ METADATA : <nl> - case STATIC : <nl> - throw new InvalidRequestException ( String . format ( " Non PRIMARY KEY % s found in where clause " , name ) ) ; <nl> + default : <nl> + throw new InvalidRequestException ( String . format ( " Non PRIMARY KEY % s found in where clause " , def . name ) ) ; <nl> } <nl> } <nl> } <nl> <nl> - public List < ByteBuffer > buildPartitionKeyNames ( List < ByteBuffer > variables ) <nl> + public List < ByteBuffer > buildPartitionKeyNames ( QueryOptions options ) <nl> throws InvalidRequestException <nl> { <nl> - CFDefinition cfDef = cfm . getCfDef ( ) ; <nl> - ColumnNameBuilder keyBuilder = cfDef . getKeyNameBuilder ( ) ; <nl> + CBuilder keyBuilder = cfm . getKeyValidatorAsCType ( ) . builder ( ) ; <nl> List < ByteBuffer > keys = new ArrayList < ByteBuffer > ( ) ; <nl> - for ( CFDefinition . Name name : cfDef . partitionKeys ( ) ) <nl> + for ( ColumnDefinition def : cfm . partitionKeyColumns ( ) ) <nl> { <nl> - Restriction r = processedKeys . get ( name . name ) ; <nl> + Restriction r = processedKeys . get ( def . name ) ; <nl> if ( r = = null ) <nl> - throw new InvalidRequestException ( String . format ( " Missing mandatory PRIMARY KEY part % s " , name ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Missing mandatory PRIMARY KEY part % s " , def . name ) ) ; <nl> <nl> - List < ByteBuffer > values = r . values ( variables ) ; <nl> + List < ByteBuffer > values = r . values ( options ) ; <nl> <nl> if ( keyBuilder . remainingCount ( ) = = 1 ) <nl> { <nl> for ( ByteBuffer val : values ) <nl> { <nl> if ( val = = null ) <nl> - throw new InvalidRequestException ( String . format ( " Invalid null value for partition key part % s " , name ) ) ; <nl> - ByteBuffer key = keyBuilder . copy ( ) . add ( val ) . build ( ) ; <nl> + throw new InvalidRequestException ( String . format ( " Invalid null value for partition key part % s " , def . name ) ) ; <nl> + ByteBuffer key = keyBuilder . buildWith ( val ) . toByteBuffer ( ) ; <nl> ThriftValidation . validateKey ( cfm , key ) ; <nl> keys . add ( key ) ; <nl> } <nl> @ @ - 340 , 14 + 314 , 14 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> throw new InvalidRequestException ( " IN is only supported on the last column of the partition key " ) ; <nl> ByteBuffer val = values . get ( 0 ) ; <nl> if ( val = = null ) <nl> - throw new InvalidRequestException ( String . format ( " Invalid null value for partition key part % s " , name ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Invalid null value for partition key part % s " , def . name ) ) ; <nl> keyBuilder . add ( val ) ; <nl> } <nl> } <nl> return keys ; <nl> } <nl> <nl> - public ColumnNameBuilder createClusteringPrefixBuilder ( List < ByteBuffer > variables ) <nl> + public Composite createClusteringPrefix ( QueryOptions options ) <nl> throws InvalidRequestException <nl> { <nl> / / If the only updated / deleted columns are static , then we don ' t need clustering columns . <nl> @ @ - 364 , 96 + 338 , 83 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> { <nl> / / If we set no non - static columns , then it ' s fine not to have clustering columns <nl> if ( hasNoClusteringColumns ) <nl> - return cfm . getStaticColumnNameBuilder ( ) ; <nl> + return cfm . comparator . staticPrefix ( ) ; <nl> <nl> / / If we do have clustering columns however , then either it ' s an INSERT and the query is valid <nl> / / but we still need to build a proper prefix , or it ' s not an INSERT , and then we want to reject <nl> / / ( see above ) <nl> if ( type ! = StatementType . INSERT ) <nl> { <nl> - for ( CFDefinition . Name name : cfm . getCfDef ( ) . clusteringColumns ( ) ) <nl> - if ( processedKeys . get ( name . name ) ! = null ) <nl> - throw new InvalidRequestException ( String . format ( " Invalid restriction on clustering column % s since the % s statement modifies only static columns " , name . name , type ) ) ; <nl> + for ( ColumnDefinition def : cfm . clusteringColumns ( ) ) <nl> + if ( processedKeys . get ( def . name ) ! = null ) <nl> + throw new InvalidRequestException ( String . format ( " Invalid restriction on clustering column % s since the % s statement modifies only static columns " , def . name , type ) ) ; <nl> / / we should get there as it contradicts hasNoClusteringColumns = = false <nl> throw new AssertionError ( ) ; <nl> } <nl> } <nl> <nl> - return createClusteringPrefixBuilderInternal ( variables ) ; <nl> + return createClusteringPrefixBuilderInternal ( options ) ; <nl> } <nl> <nl> - private ColumnNameBuilder updatePrefixFor ( ByteBuffer name , ColumnNameBuilder prefix ) <nl> - { <nl> - return isStatic ( name ) ? cfm . getStaticColumnNameBuilder ( ) : prefix ; <nl> - } <nl> - <nl> - public boolean isStatic ( ByteBuffer name ) <nl> - { <nl> - ColumnDefinition def = cfm . getColumnDefinition ( name ) ; <nl> - return def ! = null & & def . type = = ColumnDefinition . Type . STATIC ; <nl> - } <nl> - <nl> - private ColumnNameBuilder createClusteringPrefixBuilderInternal ( List < ByteBuffer > variables ) <nl> + private Composite createClusteringPrefixBuilderInternal ( QueryOptions options ) <nl> throws InvalidRequestException <nl> { <nl> - CFDefinition cfDef = cfm . getCfDef ( ) ; <nl> - ColumnNameBuilder builder = cfDef . getColumnNameBuilder ( ) ; <nl> - CFDefinition . Name firstEmptyKey = null ; <nl> - for ( CFDefinition . Name name : cfDef . clusteringColumns ( ) ) <nl> + CBuilder builder = cfm . comparator . prefixBuilder ( ) ; <nl> + ColumnDefinition firstEmptyKey = null ; <nl> + for ( ColumnDefinition def : cfm . clusteringColumns ( ) ) <nl> { <nl> - Restriction r = processedKeys . get ( name . name ) ; <nl> + Restriction r = processedKeys . get ( def . name ) ; <nl> if ( r = = null ) <nl> { <nl> - firstEmptyKey = name ; <nl> - if ( requireFullClusteringKey ( ) & & cfDef . isComposite & & ! cfDef . isCompact ) <nl> - throw new InvalidRequestException ( String . format ( " Missing mandatory PRIMARY KEY part % s " , name ) ) ; <nl> + firstEmptyKey = def ; <nl> + if ( requireFullClusteringKey ( ) & & ! cfm . comparator . isDense ( ) & & cfm . comparator . isCompound ( ) ) <nl> + throw new InvalidRequestException ( String . format ( " Missing mandatory PRIMARY KEY part % s " , def . name ) ) ; <nl> } <nl> else if ( firstEmptyKey ! = null ) <nl> { <nl> - throw new InvalidRequestException ( String . format ( " Missing PRIMARY KEY part % s since % s is set " , firstEmptyKey . name , name . name ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Missing PRIMARY KEY part % s since % s is set " , firstEmptyKey . name , def . name ) ) ; <nl> } <nl> else <nl> { <nl> - List < ByteBuffer > values = r . values ( variables ) ; <nl> + List < ByteBuffer > values = r . values ( options ) ; <nl> assert values . size ( ) = = 1 ; / / We only allow IN for row keys so far <nl> ByteBuffer val = values . get ( 0 ) ; <nl> if ( val = = null ) <nl> - throw new InvalidRequestException ( String . format ( " Invalid null value for clustering key part % s " , name ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Invalid null value for clustering key part % s " , def . name ) ) ; <nl> builder . add ( val ) ; <nl> } <nl> } <nl> - return builder ; <nl> + return builder . build ( ) ; <nl> } <nl> <nl> - protected CFDefinition . Name getFirstEmptyKey ( ) <nl> + protected ColumnDefinition getFirstEmptyKey ( ) <nl> { <nl> - for ( CFDefinition . Name name : cfm . getCfDef ( ) . clusteringColumns ( ) ) <nl> + for ( ColumnDefinition def : cfm . clusteringColumns ( ) ) <nl> { <nl> - if ( processedKeys . get ( name . name ) = = null ) <nl> - return name ; <nl> + if ( processedKeys . get ( def . name ) = = null ) <nl> + return def ; <nl> } <nl> return null ; <nl> } <nl> <nl> - protected Map < ByteBuffer , ColumnGroupMap > readRequiredRows ( Collection < ByteBuffer > partitionKeys , ColumnNameBuilder clusteringPrefix , boolean local , ConsistencyLevel cl ) <nl> + protected Map < ByteBuffer , CQL3Row > readRequiredRows ( Collection < ByteBuffer > partitionKeys , Composite clusteringPrefix , boolean local , ConsistencyLevel cl ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> / / Lists SET operation incurs a read . <nl> - Set < ByteBuffer > toRead = null ; <nl> + boolean requiresRead = false ; <nl> for ( Operation op : columnOperations ) <nl> { <nl> if ( op . requiresRead ( ) ) <nl> { <nl> - if ( toRead = = null ) <nl> - toRead = new TreeSet < ByteBuffer > ( UTF8Type . instance ) ; <nl> - toRead . add ( op . columnName . key ) ; <nl> + requiresRead = true ; <nl> + break ; <nl> } <nl> } <nl> <nl> - return toRead = = null ? null : readRows ( partitionKeys , clusteringPrefix , toRead , ( CompositeType ) cfm . comparator , local , cl ) ; <nl> + return requiresRead ? readRows ( partitionKeys , clusteringPrefix , cfm , local , cl ) : null ; <nl> } <nl> <nl> - private Map < ByteBuffer , ColumnGroupMap > readRows ( Collection < ByteBuffer > partitionKeys , ColumnNameBuilder clusteringPrefix , Set < ByteBuffer > toRead , CompositeType composite , boolean local , ConsistencyLevel cl ) <nl> + protected Map < ByteBuffer , CQL3Row > readRows ( Collection < ByteBuffer > partitionKeys , Composite rowPrefix , CFMetaData cfm , boolean local , ConsistencyLevel cl ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> try <nl> @ @ - 465 , 16 + 426 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> throw new InvalidRequestException ( String . format ( " Write operation require a read but consistency % s is not supported on reads " , cl ) ) ; <nl> } <nl> <nl> - ColumnSlice [ ] slices = new ColumnSlice [ toRead . size ( ) ] ; <nl> - int i = 0 ; <nl> - for ( ByteBuffer name : toRead ) <nl> - { <nl> - ColumnNameBuilder prefix = updatePrefixFor ( name , clusteringPrefix ) ; <nl> - ByteBuffer start = prefix . copy ( ) . add ( name ) . build ( ) ; <nl> - ByteBuffer finish = prefix . copy ( ) . add ( name ) . buildAsEndOfRange ( ) ; <nl> - slices [ i + + ] = new ColumnSlice ( start , finish ) ; <nl> - } <nl> - <nl> + ColumnSlice [ ] slices = new ColumnSlice [ ] { rowPrefix . slice ( ) } ; <nl> List < ReadCommand > commands = new ArrayList < ReadCommand > ( partitionKeys . size ( ) ) ; <nl> long now = System . currentTimeMillis ( ) ; <nl> for ( ByteBuffer key : partitionKeys ) <nl> @ @ - 488 , 20 + 440 , 19 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> ? SelectStatement . readLocally ( keyspace ( ) , commands ) <nl> : StorageProxy . read ( commands , cl ) ; <nl> <nl> - Map < ByteBuffer , ColumnGroupMap > map = new HashMap < ByteBuffer , ColumnGroupMap > ( ) ; <nl> + Map < ByteBuffer , CQL3Row > map = new HashMap < ByteBuffer , CQL3Row > ( ) ; <nl> for ( Row row : rows ) <nl> { <nl> - if ( row . cf = = null | | row . cf . getColumnCount ( ) = = 0 ) <nl> + if ( row . cf = = null | | row . cf . isEmpty ( ) ) <nl> continue ; <nl> <nl> - ColumnGroupMap . Builder groupBuilder = new ColumnGroupMap . Builder ( composite , true , now ) ; <nl> - for ( Column column : row . cf ) <nl> - groupBuilder . add ( column ) ; <nl> - <nl> - List < ColumnGroupMap > groups = groupBuilder . groups ( ) ; <nl> - assert groups . isEmpty ( ) | | groups . size ( ) = = 1 ; <nl> - if ( ! groups . isEmpty ( ) ) <nl> - map . put ( row . key . key , groups . get ( 0 ) ) ; <nl> + Iterator < CQL3Row > iter = cfm . comparator . CQL3RowBuilder ( cfm , now ) . group ( row . cf . getSortedColumns ( ) . iterator ( ) ) ; <nl> + if ( iter . hasNext ( ) ) <nl> + { <nl> + map . put ( row . key . getKey ( ) , iter . next ( ) ) ; <nl> + / / We can only update one CQ3Row per partition key at a time ( we don ' t allow IN for clustering key ) <nl> + assert ! iter . hasNext ( ) ; <nl> + } <nl> } <nl> return map ; <nl> } <nl> @ @ - 537 , 7 + 488 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> else <nl> cl . validateForWrite ( cfm . ksName ) ; <nl> <nl> - Collection < ? extends IMutation > mutations = getMutations ( options . getValues ( ) , false , cl , queryState . getTimestamp ( ) ) ; <nl> + Collection < ? extends IMutation > mutations = getMutations ( options , false , options . getTimestamp ( queryState ) ) ; <nl> if ( ! mutations . isEmpty ( ) ) <nl> StorageProxy . mutateWithTriggers ( mutations , cl , false ) ; <nl> <nl> @ @ - 547 , 18 + 498 , 18 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> public ResultMessage executeWithCondition ( QueryState queryState , QueryOptions options ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> - List < ByteBuffer > variables = options . getValues ( ) ; <nl> - List < ByteBuffer > keys = buildPartitionKeyNames ( variables ) ; <nl> + List < ByteBuffer > keys = buildPartitionKeyNames ( options ) ; <nl> / / We don ' t support IN for CAS operation so far <nl> if ( keys . size ( ) > 1 ) <nl> throw new InvalidRequestException ( " IN on the partition key is not supported with conditional updates " ) ; <nl> <nl> ByteBuffer key = keys . get ( 0 ) ; <nl> <nl> - CQL3CasConditions conditions = new CQL3CasConditions ( cfm , queryState . getTimestamp ( ) ) ; <nl> - ColumnNameBuilder prefix = createClusteringPrefixBuilder ( variables ) ; <nl> - ColumnFamily updates = UnsortedColumns . factory . create ( cfm ) ; <nl> - addUpdatesAndConditions ( key , prefix , updates , conditions , variables , getTimestamp ( queryState . getTimestamp ( ) , variables ) ) ; <nl> + long now = options . getTimestamp ( queryState ) ; <nl> + CQL3CasConditions conditions = new CQL3CasConditions ( cfm , now ) ; <nl> + Composite prefix = createClusteringPrefix ( options ) ; <nl> + ColumnFamily updates = ArrayBackedSortedColumns . factory . create ( cfm ) ; <nl> + addUpdatesAndConditions ( key , prefix , updates , conditions , options , getTimestamp ( now , options ) ) ; <nl> <nl> ColumnFamily result = StorageProxy . cas ( keyspace ( ) , <nl> columnFamily ( ) , <nl> @ @ - 570 , 16 + 521 , 16 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> return new ResultMessage . Rows ( buildCasResultSet ( key , result ) ) ; <nl> } <nl> <nl> - public void addUpdatesAndConditions ( ByteBuffer key , ColumnNameBuilder clusteringPrefix , ColumnFamily updates , CQL3CasConditions conditions , List < ByteBuffer > variables , long now ) <nl> + public void addUpdatesAndConditions ( ByteBuffer key , Composite clusteringPrefix , ColumnFamily updates , CQL3CasConditions conditions , QueryOptions options , long now ) <nl> throws InvalidRequestException <nl> { <nl> - UpdateParameters updParams = new UpdateParameters ( cfm , variables , now , getTimeToLive ( variables ) , null ) ; <nl> + UpdateParameters updParams = new UpdateParameters ( cfm , options , now , getTimeToLive ( options ) , null ) ; <nl> addUpdateForKey ( updates , key , clusteringPrefix , updParams ) ; <nl> <nl> if ( ifNotExists ) <nl> { <nl> / / If we use ifNotExists , if the statement applies to any non static columns , then the condition is on the row of the non - static <nl> - / / columns and the prefix should be the rowPrefix . But if only static columns are set , then the ifNotExists apply to the existence <nl> + / / columns and the prefix should be the clusteringPrefix . But if only static columns are set , then the ifNotExists apply to the existence <nl> / / of any static columns and we should use the prefix for the " static part " of the partition . <nl> conditions . addNotExist ( clusteringPrefix ) ; <nl> } <nl> @ @ - 590 , 9 + 541 , 9 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> else <nl> { <nl> if ( columnConditions ! = null ) <nl> - conditions . addConditions ( clusteringPrefix , columnConditions , variables ) ; <nl> + conditions . addConditions ( clusteringPrefix , columnConditions , options ) ; <nl> if ( staticConditions ! = null ) <nl> - conditions . addConditions ( cfm . getStaticColumnNameBuilder ( ) , staticConditions , variables ) ; <nl> + conditions . addConditions ( cfm . comparator . staticPrefix ( ) , staticConditions , options ) ; <nl> } <nl> } <nl> <nl> @ @ - 601 , 7 + 552 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> return buildCasResultSet ( keyspace ( ) , key , columnFamily ( ) , cf , getColumnsWithConditions ( ) , false ) ; <nl> } <nl> <nl> - public static ResultSet buildCasResultSet ( String ksName , ByteBuffer key , String cfName , ColumnFamily cf , Iterable < ColumnIdentifier > columnsWithConditions , boolean isBatch ) <nl> + public static ResultSet buildCasResultSet ( String ksName , ByteBuffer key , String cfName , ColumnFamily cf , Iterable < ColumnDefinition > columnsWithConditions , boolean isBatch ) <nl> throws InvalidRequestException <nl> { <nl> boolean success = cf = = null ; <nl> @ @ - 637 , 34 + 588 , 33 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> return new ResultSet ( new ResultSet . Metadata ( specs ) , rows ) ; <nl> } <nl> <nl> - private static ResultSet buildCasFailureResultSet ( ByteBuffer key , ColumnFamily cf , Iterable < ColumnIdentifier > columnsWithConditions , boolean isBatch ) <nl> + private static ResultSet buildCasFailureResultSet ( ByteBuffer key , ColumnFamily cf , Iterable < ColumnDefinition > columnsWithConditions , boolean isBatch ) <nl> throws InvalidRequestException <nl> { <nl> - CFDefinition cfDef = cf . metadata ( ) . getCfDef ( ) ; <nl> - <nl> + CFMetaData cfm = cf . metadata ( ) ; <nl> Selection selection ; <nl> if ( columnsWithConditions = = null ) <nl> { <nl> - selection = Selection . wildcard ( cfDef ) ; <nl> + selection = Selection . wildcard ( cfm ) ; <nl> } <nl> else <nl> { <nl> - List < CFDefinition . Name > names = new ArrayList < CFDefinition . Name > ( ) ; <nl> + List < ColumnDefinition > defs = new ArrayList < > ( ) ; <nl> / / Adding the partition key for batches to disambiguate if the conditions span multipe rows ( we don ' t add them outside <nl> / / of batches for compatibility sakes ) . <nl> if ( isBatch ) <nl> { <nl> - names . addAll ( cfDef . partitionKeys ( ) ) ; <nl> - names . addAll ( cfDef . clusteringColumns ( ) ) ; <nl> + defs . addAll ( cfm . partitionKeyColumns ( ) ) ; <nl> + defs . addAll ( cfm . clusteringColumns ( ) ) ; <nl> } <nl> - for ( ColumnIdentifier id : columnsWithConditions ) <nl> - names . add ( cfDef . get ( id ) ) ; <nl> - selection = Selection . forColumns ( names ) ; <nl> + for ( ColumnDefinition def : columnsWithConditions ) <nl> + defs . add ( def ) ; <nl> + selection = Selection . forColumns ( defs ) ; <nl> } <nl> <nl> long now = System . currentTimeMillis ( ) ; <nl> Selection . ResultSetBuilder builder = selection . resultSetBuilder ( now ) ; <nl> - SelectStatement . forSelection ( cfDef , selection ) . processColumnFamily ( key , cf , Collections . < ByteBuffer > emptyList ( ) , now , builder ) ; <nl> + SelectStatement . forSelection ( cfm , selection ) . processColumnFamily ( key , cf , QueryOptions . DEFAULT , now , builder ) ; <nl> <nl> return builder . build ( ) ; <nl> } <nl> @ @ - 674 , 15 + 624 , 19 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> if ( hasConditions ( ) ) <nl> throw new UnsupportedOperationException ( ) ; <nl> <nl> - for ( IMutation mutation : getMutations ( Collections . < ByteBuffer > emptyList ( ) , true , null , queryState . getTimestamp ( ) ) ) <nl> - mutation . apply ( ) ; <nl> + for ( IMutation mutation : getMutations ( QueryOptions . DEFAULT , true , queryState . getTimestamp ( ) ) ) <nl> + { <nl> + / / We don ' t use counters internally . <nl> + assert mutation instanceof Mutation ; <nl> + ( ( Mutation ) mutation ) . apply ( ) ; <nl> + } <nl> return null ; <nl> } <nl> <nl> / * * <nl> * Convert statement into a list of mutations to apply on the server <nl> * <nl> - * @ param variables value for prepared statement markers <nl> + * @ param options value for prepared statement markers <nl> * @ param local if true , any requests ( for collections ) performed by getMutation should be done locally only . <nl> * @ param cl the consistency to use for the potential reads involved in generating the mutations ( for lists set / delete operations ) <nl> * @ param now the current timestamp in microseconds to use if no timestamp is user provided . <nl> @ @ - 690 , 37 + 644 , 36 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> * @ return list of the mutations <nl> * @ throws InvalidRequestException on invalid requests <nl> * / <nl> - private Collection < ? extends IMutation > getMutations ( List < ByteBuffer > variables , boolean local , ConsistencyLevel cl , long now ) <nl> + private Collection < ? extends IMutation > getMutations ( QueryOptions options , boolean local , long now ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> - List < ByteBuffer > keys = buildPartitionKeyNames ( variables ) ; <nl> - ColumnNameBuilder clusteringPrefix = createClusteringPrefixBuilder ( variables ) ; <nl> + List < ByteBuffer > keys = buildPartitionKeyNames ( options ) ; <nl> + Composite clusteringPrefix = createClusteringPrefix ( options ) ; <nl> <nl> - UpdateParameters params = makeUpdateParameters ( keys , clusteringPrefix , variables , local , cl , now ) ; <nl> + UpdateParameters params = makeUpdateParameters ( keys , clusteringPrefix , options , local , now ) ; <nl> <nl> Collection < IMutation > mutations = new ArrayList < IMutation > ( ) ; <nl> for ( ByteBuffer key : keys ) <nl> { <nl> ThriftValidation . validateKey ( cfm , key ) ; <nl> - ColumnFamily cf = UnsortedColumns . factory . create ( cfm ) ; <nl> + ColumnFamily cf = ArrayBackedSortedColumns . factory . create ( cfm ) ; <nl> addUpdateForKey ( cf , key , clusteringPrefix , params ) ; <nl> - RowMutation rm = new RowMutation ( cfm . ksName , key , cf ) ; <nl> - mutations . add ( isCounter ( ) ? new CounterMutation ( rm , cl ) : rm ) ; <nl> + Mutation mut = new Mutation ( cfm . ksName , key , cf ) ; <nl> + mutations . add ( isCounter ( ) ? new CounterMutation ( mut , options . getConsistency ( ) ) : mut ) ; <nl> } <nl> return mutations ; <nl> } <nl> <nl> public UpdateParameters makeUpdateParameters ( Collection < ByteBuffer > keys , <nl> - ColumnNameBuilder prefix , <nl> - List < ByteBuffer > variables , <nl> + Composite prefix , <nl> + QueryOptions options , <nl> boolean local , <nl> - ConsistencyLevel cl , <nl> long now ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> / / Some lists operation requires reading <nl> - Map < ByteBuffer , ColumnGroupMap > rows = readRequiredRows ( keys , prefix , local , cl ) ; <nl> - return new UpdateParameters ( cfm , variables , getTimestamp ( now , variables ) , getTimeToLive ( variables ) , rows ) ; <nl> + Map < ByteBuffer , CQL3Row > rows = readRequiredRows ( keys , prefix , local , options . getConsistency ( ) ) ; <nl> + return new UpdateParameters ( cfm , options , getTimestamp ( now , options ) , getTimeToLive ( options ) , rows ) ; <nl> } <nl> <nl> public static abstract class Parsed extends CFStatement <nl> @ @ - 749 , 16 + 702 , 11 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> public ModificationStatement prepare ( VariableSpecifications boundNames ) throws InvalidRequestException <nl> { <nl> CFMetaData metadata = ThriftValidation . validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; <nl> - CFDefinition cfDef = metadata . getCfDef ( ) ; <nl> - <nl> - / / The collected count in the beginning of preparation . <nl> - / / Will start at non - zero for statements nested inside a BatchStatement ( the second and the further ones ) . <nl> - int collected = boundNames . getCollectedCount ( ) ; <nl> <nl> Attributes preparedAttributes = attrs . prepare ( keyspace ( ) , columnFamily ( ) ) ; <nl> preparedAttributes . collectMarkerSpecification ( boundNames ) ; <nl> <nl> - ModificationStatement stmt = prepareInternal ( cfDef , boundNames , preparedAttributes ) ; <nl> + ModificationStatement stmt = prepareInternal ( metadata , boundNames , preparedAttributes ) ; <nl> <nl> if ( ifNotExists | | ifExists | | ! conditions . isEmpty ( ) ) <nl> { <nl> @ @ - 766 , 7 + 714 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; <nl> <nl> if ( attrs . timestamp ! = null ) <nl> - throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; <nl> + throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional updates " ) ; <nl> <nl> if ( ifNotExists ) <nl> { <nl> @ @ - 786 , 32 + 734 , 28 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF <nl> { <nl> for ( Pair < ColumnIdentifier , ColumnCondition . Raw > entry : conditions ) <nl> { <nl> - CFDefinition . Name name = cfDef . get ( entry . left ) ; <nl> - if ( name = = null ) <nl> + ColumnDefinition def = metadata . getColumnDefinition ( entry . left ) ; <nl> + if ( def = = null ) <nl> throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; <nl> <nl> - ColumnCondition condition = entry . right . prepare ( name ) ; <nl> + ColumnCondition condition = entry . right . prepare ( keyspace ( ) , def ) ; <nl> condition . collectMarkerSpecification ( boundNames ) ; <nl> <nl> - switch ( name . kind ) <nl> + switch ( def . kind ) <nl> { <nl> - case KEY _ ALIAS : <nl> - case COLUMN _ ALIAS : <nl> + case PARTITION _ KEY : <nl> + case CLUSTERING _ COLUMN : <nl> throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; <nl> - case VALUE _ ALIAS : <nl> - case COLUMN _ METADATA : <nl> - case STATIC : <nl> + default : <nl> stmt . addCondition ( condition ) ; <nl> break ; <nl> } <nl> } <nl> } <nl> } <nl> - <nl> - stmt . boundTerms = boundNames . getCollectedCount ( ) - collected ; <nl> return stmt ; <nl> } <nl> <nl> - protected abstract ModificationStatement prepareInternal ( CFDefinition cfDef , VariableSpecifications boundNames , Attributes attrs ) throws InvalidRequestException ; <nl> + protected abstract ModificationStatement prepareInternal ( CFMetaData cfm , VariableSpecifications boundNames , Attributes attrs ) throws InvalidRequestException ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 83eca8a . . 27831ba 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 11 , 6 + 11 , 8 @ @ <nl> * synchronize BiMap of bootstrapping tokens ( CASSANDRA - 3417 ) <nl> * show index options in CLI ( CASSANDRA - 3809 ) <nl> * add optional socket timeout for streaming ( CASSANDRA - 3838 ) <nl> + * fix truncate not to leave behind non - CFS backed secondary indexes <nl> + ( CASSANDRA - 3844 ) <nl> Merged from 0 . 8 : <nl> * ( Pig ) fix CassandraStorage to use correct comparator in Super ColumnFamily <nl> case ( CASSANDRA - 3251 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 151564c . . 0952ffd 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1939 , 4 + 1939 , 24 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> DataTracker . View view = data . getView ( ) ; <nl> return view . sstables . isEmpty ( ) & & view . memtable . getOperations ( ) = = 0 & & view . memtablesPendingFlush . isEmpty ( ) ; <nl> } <nl> + <nl> + / * * <nl> + * Discard all SSTables that were created before given timestamp . Caller is responsible to obtain compactionLock . <nl> + * <nl> + * @ param truncatedAt The timestamp of the truncation <nl> + * ( all SSTables before that timestamp are going be marked as compacted ) <nl> + * / <nl> + public void discardSSTables ( long truncatedAt ) <nl> + { <nl> + List < SSTableReader > truncatedSSTables = new ArrayList < SSTableReader > ( ) ; <nl> + <nl> + for ( SSTableReader sstable : getSSTables ( ) ) <nl> + { <nl> + if ( ! sstable . newSince ( truncatedAt ) ) <nl> + truncatedSSTables . add ( sstable ) ; <nl> + } <nl> + <nl> + if ( ! truncatedSSTables . isEmpty ( ) ) <nl> + markCompacted ( truncatedSSTables ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index ac25c4b . . caaf6d2 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . db . index . SecondaryIndex ; <nl> import org . apache . cassandra . db . index . SecondaryIndexBuilder ; <nl> import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . io . sstable . * ; <nl> @ @ - 928 , 19 + 929 , 13 @ @ public class CompactionManager implements CompactionManagerMBean <nl> public void runMayThrow ( ) throws InterruptedException , IOException <nl> { <nl> compactionLock . writeLock ( ) . lock ( ) ; <nl> + <nl> try <nl> { <nl> - for ( ColumnFamilyStore cfs : main . concatWithIndexes ( ) ) <nl> - { <nl> - List < SSTableReader > truncatedSSTables = new ArrayList < SSTableReader > ( ) ; <nl> - for ( SSTableReader sstable : cfs . getSSTables ( ) ) <nl> - { <nl> - if ( ! sstable . newSince ( truncatedAt ) ) <nl> - truncatedSSTables . add ( sstable ) ; <nl> - } <nl> - if ( ! truncatedSSTables . isEmpty ( ) ) <nl> - cfs . markCompacted ( truncatedSSTables ) ; <nl> - } <nl> + main . discardSSTables ( truncatedAt ) ; <nl> + <nl> + for ( SecondaryIndex index : main . indexManager . getIndexes ( ) ) <nl> + index . truncate ( truncatedAt ) ; <nl> } <nl> finally <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndex . java b / src / java / org / apache / cassandra / db / index / SecondaryIndex . java <nl> index c2d2318 . . 5006217 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndex . java <nl> + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndex . java <nl> @ @ - 133 , 7 + 133 , 13 @ @ public abstract class SecondaryIndex <nl> * Remove the index and unregisters this index ' s mbean if one exists <nl> * / <nl> public abstract void invalidate ( ) ; <nl> - <nl> + <nl> + / * * <nl> + * Truncate all the data from the current index <nl> + * <nl> + * @ param truncatedAt The truncation timestamp , all data before that timestamp should be rejected . <nl> + * / <nl> + public abstract void truncate ( long truncatedAt ) ; <nl> <nl> / * * <nl> * Builds the index using the data in the underlying CFS <nl> diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> index d5fdd2c . . 77bf954 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> @ @ - 327 , 7 + 327 , 21 @ @ public class SecondaryIndexManager <nl> <nl> return indexList . keySet ( ) ; <nl> } <nl> - <nl> + <nl> + / * * <nl> + * @ return all of the secondary indexes without distinction to the ( non - ) backed by secondary ColumnFamilyStore . <nl> + * / <nl> + public Collection < SecondaryIndex > getIndexes ( ) <nl> + { <nl> + / / we use identity map because per row indexes use same instance across many columns <nl> + IdentityHashMap < SecondaryIndex , Object > indexList = new IdentityHashMap < SecondaryIndex , Object > ( ) ; <nl> + <nl> + for ( Map . Entry < ByteBuffer , SecondaryIndex > entry : indexesByColumn . entrySet ( ) ) <nl> + indexList . put ( entry . getValue ( ) , null ) ; <nl> + <nl> + return indexList . keySet ( ) ; <nl> + } <nl> + <nl> / * * <nl> * @ return total current ram size of all indexes <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / db / index / keys / KeysIndex . java b / src / java / org / apache / cassandra / db / index / keys / KeysIndex . java <nl> index ce26ab3 . . 6ce6242 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / keys / KeysIndex . java <nl> + + + b / src / java / org / apache / cassandra / db / index / keys / KeysIndex . java <nl> @ @ - 133 , 6 + 133 , 11 @ @ public class KeysIndex extends PerColumnSecondaryIndex <nl> indexCfs . invalidate ( ) ; <nl> } <nl> <nl> + public void truncate ( long truncatedAt ) <nl> + { <nl> + indexCfs . discardSSTables ( truncatedAt ) ; <nl> + } <nl> + <nl> public ColumnFamilyStore getIndexCfs ( ) <nl> { <nl> return indexCfs ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 index 23f7cfe . . 7f8b678 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 @ @ - 23 , 23 + 23 , 18 @ @ import java . util . * ; 
 import com . google . common . base . Function ; 
 import com . google . common . collect . Iterables ; 
 import org . github . jamm . MemoryMeter ; 
 - import org . slf4j . Logger ; 
 - import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . auth . Permission ; 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ColumnDefinition ; 
 import org . apache . cassandra . cql3 . * ; 
 import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . db . composites . CBuilder ; 
 + import org . apache . cassandra . db . composites . Composite ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 - import org . apache . cassandra . db . filter . IDiskAtomFilter ; 
 import org . apache . cassandra . db . filter . SliceQueryFilter ; 
 - import org . apache . cassandra . db . marshal . CompositeType ; 
 - import org . apache . cassandra . db . marshal . UTF8Type ; 
 - import org . apache . cassandra . db . marshal . ListType ; 
 import org . apache . cassandra . db . marshal . BooleanType ; 
 import org . apache . cassandra . exceptions . * ; 
 - import org . apache . cassandra . service . CASConditions ; 
 import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . QueryState ; 
 import org . apache . cassandra . service . StorageProxy ; 
 @ @ - 54 , 21 + 49 , 16 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 { 
 private static final ColumnIdentifier CAS _ RESULT _ COLUMN = new ColumnIdentifier ( " [ applied ] " , false ) ; 
 
 - private static final Logger logger = LoggerFactory . getLogger ( ModificationStatement . class ) ; 
 - 
 - private static boolean loggedCounterTTL = false ; 
 - private static boolean loggedCounterTimestamp = false ; 
 - 
 public static enum StatementType { INSERT , UPDATE , DELETE } 
 public final StatementType type ; 
 
 + private final int boundTerms ; 
 public final CFMetaData cfm ; 
 public final Attributes attrs ; 
 
 private final Map < ColumnIdentifier , Restriction > processedKeys = new HashMap < ColumnIdentifier , Restriction > ( ) ; 
 private final List < Operation > columnOperations = new ArrayList < Operation > ( ) ; 
 
 - private int boundTerms ; 
 / / Separating normal and static conditions makes things somewhat easier 
 private List < ColumnCondition > columnConditions ; 
 private List < ColumnCondition > staticConditions ; 
 @ @ - 80 , 17 + 70 , 18 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 private boolean setsStaticColumns ; 
 private boolean setsRegularColumns ; 
 
 - private final Function < ColumnCondition , ColumnIdentifier > getColumnForCondition = new Function < ColumnCondition , ColumnIdentifier > ( ) 
 + private final Function < ColumnCondition , ColumnDefinition > getColumnForCondition = new Function < ColumnCondition , ColumnDefinition > ( ) 
 { 
 - public ColumnIdentifier apply ( ColumnCondition cond ) 
 + public ColumnDefinition apply ( ColumnCondition cond ) 
 { 
 - return cond . column . name ; 
 + return cond . column ; 
 } 
 } ; 
 
 - public ModificationStatement ( StatementType type , CFMetaData cfm , Attributes attrs ) 
 + public ModificationStatement ( StatementType type , int boundTerms , CFMetaData cfm , Attributes attrs ) 
 { 
 this . type = type ; 
 + this . boundTerms = boundTerms ; 
 this . cfm = cfm ; 
 this . attrs = attrs ; 
 } 
 @ @ - 106 , 7 + 97 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 } 
 
 public abstract boolean requireFullClusteringKey ( ) ; 
 - public abstract void addUpdateForKey ( ColumnFamily updates , ByteBuffer key , ColumnNameBuilder builder , UpdateParameters params ) throws InvalidRequestException ; 
 + public abstract void addUpdateForKey ( ColumnFamily updates , ByteBuffer key , Composite prefix , UpdateParameters params ) throws InvalidRequestException ; 
 
 public int getBoundTerms ( ) 
 { 
 @ @ - 125 , 12 + 116 , 12 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 
 public boolean isCounter ( ) 
 { 
 - return cfm . getDefaultValidator ( ) . isCommutative ( ) ; 
 + return cfm . isCounter ( ) ; 
 } 
 
 - public long getTimestamp ( long now , List < ByteBuffer > variables ) throws InvalidRequestException 
 + public long getTimestamp ( long now , QueryOptions options ) throws InvalidRequestException 
 { 
 - return attrs . getTimestamp ( now , variables ) ; 
 + return attrs . getTimestamp ( now , options ) ; 
 } 
 
 public boolean isTimestampSet ( ) 
 @ @ - 138 , 9 + 129 , 9 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 return attrs . isTimestampSet ( ) ; 
 } 
 
 - public int getTimeToLive ( List < ByteBuffer > variables ) throws InvalidRequestException 
 + public int getTimeToLive ( QueryOptions options ) throws InvalidRequestException 
 { 
 - return attrs . getTimeToLive ( variables ) ; 
 + return attrs . getTimeToLive ( options ) ; 
 } 
 
 public void checkAccess ( ClientState state ) throws InvalidRequestException , UnauthorizedException 
 @ @ - 155 , 31 + 146 , 18 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 public void validate ( ClientState state ) throws InvalidRequestException 
 { 
 if ( hasConditions ( ) & & attrs . isTimestampSet ( ) ) 
 - throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; 
 + throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional updates " ) ; 
 
 - if ( isCounter ( ) ) 
 - { 
 - if ( attrs . isTimestampSet ( ) & & ! loggedCounterTimestamp ) 
 - { 
 - logger . warn ( " Detected use of ' USING TIMESTAMP ' in a counter UPDATE . This is invalid " + 
 - " because counters do not use timestamps , and the timestamp has been ignored . " + 
 - " Such queries will be rejected in Cassandra 2 . 1 + - please fix your queries before then . " ) ; 
 - loggedCounterTimestamp = true ; 
 - } 
 + if ( isCounter ( ) & & attrs . isTimestampSet ( ) ) 
 + throw new InvalidRequestException ( " Cannot provide custom timestamp for counter updates " ) ; 
 
 - if ( attrs . isTimeToLiveSet ( ) & & ! loggedCounterTTL ) 
 - { 
 - logger . warn ( " Detected use of ' USING TTL ' in a counter UPDATE . This is invalid " + 
 - " because counter tables do not support TTL , and the TTL value has been ignored . " + 
 - " Such queries will be rejected in Cassandra 2 . 1 + - please fix your queries before then . " ) ; 
 - loggedCounterTTL = true ; 
 - } 
 - } 
 + if ( isCounter ( ) & & attrs . isTimeToLiveSet ( ) ) 
 + throw new InvalidRequestException ( " Cannot provide custom TTL for counter updates " ) ; 
 } 
 
 public void addOperation ( Operation op ) 
 { 
 - if ( op . isStatic ( cfm ) ) 
 + if ( op . column . isStatic ( ) ) 
 setsStaticColumns = true ; 
 else 
 setsRegularColumns = true ; 
 @ @ - 191 , 19 + 169 , 19 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 return columnOperations ; 
 } 
 
 - public Iterable < ColumnIdentifier > getColumnsWithConditions ( ) 
 + public Iterable < ColumnDefinition > getColumnsWithConditions ( ) 
 { 
 if ( ifNotExists | | ifExists ) 
 return null ; 
 
 - return Iterables . concat ( columnConditions = = null ? Collections . < ColumnIdentifier > emptyList ( ) : Iterables . transform ( columnConditions , getColumnForCondition ) , 
 - staticConditions = = null ? Collections . < ColumnIdentifier > emptyList ( ) : Iterables . transform ( staticConditions , getColumnForCondition ) ) ; 
 + return Iterables . concat ( columnConditions = = null ? Collections . < ColumnDefinition > emptyList ( ) : Iterables . transform ( columnConditions , getColumnForCondition ) , 
 + staticConditions = = null ? Collections . < ColumnDefinition > emptyList ( ) : Iterables . transform ( staticConditions , getColumnForCondition ) ) ; 
 } 
 
 public void addCondition ( ColumnCondition cond ) throws InvalidRequestException 
 { 
 List < ColumnCondition > conds = null ; 
 - if ( cond . column . kind = = CFDefinition . Name . Kind . STATIC ) 
 + if ( cond . column . isStatic ( ) ) 
 { 
 setsStaticColumns = true ; 
 if ( staticConditions = = null ) 
 @ @ - 240 , 45 + 218 , 44 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 return ifExists ; 
 } 
 
 - private void addKeyValues ( CFDefinition . Name name , Restriction values ) throws InvalidRequestException 
 + private void addKeyValues ( ColumnDefinition def , Restriction values ) throws InvalidRequestException 
 { 
 - if ( name . kind = = CFDefinition . Name . Kind . COLUMN _ ALIAS ) 
 + if ( def . kind = = ColumnDefinition . Kind . CLUSTERING _ COLUMN ) 
 hasNoClusteringColumns = false ; 
 - if ( processedKeys . put ( name . name , values ) ! = null ) 
 - throw new InvalidRequestException ( String . format ( " Multiple definitions found for PRIMARY KEY part % s " , name . name ) ) ; 
 + if ( processedKeys . put ( def . name , values ) ! = null ) 
 + throw new InvalidRequestException ( String . format ( " Multiple definitions found for PRIMARY KEY part % s " , def . name ) ) ; 
 } 
 
 - public void addKeyValue ( CFDefinition . Name name , Term value ) throws InvalidRequestException 
 + public void addKeyValue ( ColumnDefinition def , Term value ) throws InvalidRequestException 
 { 
 - addKeyValues ( name , new Restriction . EQ ( value , false ) ) ; 
 + addKeyValues ( def , new Restriction . EQ ( value , false ) ) ; 
 } 
 
 public void processWhereClause ( List < Relation > whereClause , VariableSpecifications names ) throws InvalidRequestException 
 { 
 - CFDefinition cfDef = cfm . getCfDef ( ) ; 
 for ( Relation rel : whereClause ) 
 { 
 - CFDefinition . Name name = cfDef . get ( rel . getEntity ( ) ) ; 
 - if ( name = = null ) 
 + ColumnDefinition def = cfm . getColumnDefinition ( rel . getEntity ( ) ) ; 
 + if ( def = = null ) 
 throw new InvalidRequestException ( String . format ( " Unknown key identifier % s " , rel . getEntity ( ) ) ) ; 
 
 - switch ( name . kind ) 
 + switch ( def . kind ) 
 { 
 - case KEY _ ALIAS : 
 - case COLUMN _ ALIAS : 
 + case PARTITION _ KEY : 
 + case CLUSTERING _ COLUMN : 
 Restriction restriction ; 
 
 if ( rel . operator ( ) = = Relation . Type . EQ ) 
 { 
 - Term t = rel . getValue ( ) . prepare ( name ) ; 
 + Term t = rel . getValue ( ) . prepare ( keyspace ( ) , def ) ; 
 t . collectMarkerSpecification ( names ) ; 
 restriction = new Restriction . EQ ( t , false ) ; 
 } 
 - else if ( name . kind = = CFDefinition . Name . Kind . KEY _ ALIAS & & rel . operator ( ) = = Relation . Type . IN ) 
 + else if ( def . kind = = ColumnDefinition . Kind . PARTITION _ KEY & & rel . operator ( ) = = Relation . Type . IN ) 
 { 
 if ( rel . getValue ( ) ! = null ) 
 { 
 - Term t = rel . getValue ( ) . prepare ( name ) ; 
 + Term t = rel . getValue ( ) . prepare ( keyspace ( ) , def ) ; 
 t . collectMarkerSpecification ( names ) ; 
 restriction = Restriction . IN . create ( t ) ; 
 } 
 @ @ - 287 , 7 + 264 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 List < Term > values = new ArrayList < Term > ( rel . getInValues ( ) . size ( ) ) ; 
 for ( Term . Raw raw : rel . getInValues ( ) ) 
 { 
 - Term t = raw . prepare ( name ) ; 
 + Term t = raw . prepare ( keyspace ( ) , def ) ; 
 t . collectMarkerSpecification ( names ) ; 
 values . add ( t ) ; 
 } 
 @ @ - 296 , 40 + 273 , 37 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 } 
 else 
 { 
 - throw new InvalidRequestException ( String . format ( " Invalid operator % s for PRIMARY KEY part % s " , rel . operator ( ) , name ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Invalid operator % s for PRIMARY KEY part % s " , rel . operator ( ) , def . name ) ) ; 
 } 
 
 - addKeyValues ( name , restriction ) ; 
 + addKeyValues ( def , restriction ) ; 
 break ; 
 - case VALUE _ ALIAS : 
 - case COLUMN _ METADATA : 
 - case STATIC : 
 - throw new InvalidRequestException ( String . format ( " Non PRIMARY KEY % s found in where clause " , name ) ) ; 
 + default : 
 + throw new InvalidRequestException ( String . format ( " Non PRIMARY KEY % s found in where clause " , def . name ) ) ; 
 } 
 } 
 } 
 
 - public List < ByteBuffer > buildPartitionKeyNames ( List < ByteBuffer > variables ) 
 + public List < ByteBuffer > buildPartitionKeyNames ( QueryOptions options ) 
 throws InvalidRequestException 
 { 
 - CFDefinition cfDef = cfm . getCfDef ( ) ; 
 - ColumnNameBuilder keyBuilder = cfDef . getKeyNameBuilder ( ) ; 
 + CBuilder keyBuilder = cfm . getKeyValidatorAsCType ( ) . builder ( ) ; 
 List < ByteBuffer > keys = new ArrayList < ByteBuffer > ( ) ; 
 - for ( CFDefinition . Name name : cfDef . partitionKeys ( ) ) 
 + for ( ColumnDefinition def : cfm . partitionKeyColumns ( ) ) 
 { 
 - Restriction r = processedKeys . get ( name . name ) ; 
 + Restriction r = processedKeys . get ( def . name ) ; 
 if ( r = = null ) 
 - throw new InvalidRequestException ( String . format ( " Missing mandatory PRIMARY KEY part % s " , name ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Missing mandatory PRIMARY KEY part % s " , def . name ) ) ; 
 
 - List < ByteBuffer > values = r . values ( variables ) ; 
 + List < ByteBuffer > values = r . values ( options ) ; 
 
 if ( keyBuilder . remainingCount ( ) = = 1 ) 
 { 
 for ( ByteBuffer val : values ) 
 { 
 if ( val = = null ) 
 - throw new InvalidRequestException ( String . format ( " Invalid null value for partition key part % s " , name ) ) ; 
 - ByteBuffer key = keyBuilder . copy ( ) . add ( val ) . build ( ) ; 
 + throw new InvalidRequestException ( String . format ( " Invalid null value for partition key part % s " , def . name ) ) ; 
 + ByteBuffer key = keyBuilder . buildWith ( val ) . toByteBuffer ( ) ; 
 ThriftValidation . validateKey ( cfm , key ) ; 
 keys . add ( key ) ; 
 } 
 @ @ - 340 , 14 + 314 , 14 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 throw new InvalidRequestException ( " IN is only supported on the last column of the partition key " ) ; 
 ByteBuffer val = values . get ( 0 ) ; 
 if ( val = = null ) 
 - throw new InvalidRequestException ( String . format ( " Invalid null value for partition key part % s " , name ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Invalid null value for partition key part % s " , def . name ) ) ; 
 keyBuilder . add ( val ) ; 
 } 
 } 
 return keys ; 
 } 
 
 - public ColumnNameBuilder createClusteringPrefixBuilder ( List < ByteBuffer > variables ) 
 + public Composite createClusteringPrefix ( QueryOptions options ) 
 throws InvalidRequestException 
 { 
 / / If the only updated / deleted columns are static , then we don ' t need clustering columns . 
 @ @ - 364 , 96 + 338 , 83 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 { 
 / / If we set no non - static columns , then it ' s fine not to have clustering columns 
 if ( hasNoClusteringColumns ) 
 - return cfm . getStaticColumnNameBuilder ( ) ; 
 + return cfm . comparator . staticPrefix ( ) ; 
 
 / / If we do have clustering columns however , then either it ' s an INSERT and the query is valid 
 / / but we still need to build a proper prefix , or it ' s not an INSERT , and then we want to reject 
 / / ( see above ) 
 if ( type ! = StatementType . INSERT ) 
 { 
 - for ( CFDefinition . Name name : cfm . getCfDef ( ) . clusteringColumns ( ) ) 
 - if ( processedKeys . get ( name . name ) ! = null ) 
 - throw new InvalidRequestException ( String . format ( " Invalid restriction on clustering column % s since the % s statement modifies only static columns " , name . name , type ) ) ; 
 + for ( ColumnDefinition def : cfm . clusteringColumns ( ) ) 
 + if ( processedKeys . get ( def . name ) ! = null ) 
 + throw new InvalidRequestException ( String . format ( " Invalid restriction on clustering column % s since the % s statement modifies only static columns " , def . name , type ) ) ; 
 / / we should get there as it contradicts hasNoClusteringColumns = = false 
 throw new AssertionError ( ) ; 
 } 
 } 
 
 - return createClusteringPrefixBuilderInternal ( variables ) ; 
 + return createClusteringPrefixBuilderInternal ( options ) ; 
 } 
 
 - private ColumnNameBuilder updatePrefixFor ( ByteBuffer name , ColumnNameBuilder prefix ) 
 - { 
 - return isStatic ( name ) ? cfm . getStaticColumnNameBuilder ( ) : prefix ; 
 - } 
 - 
 - public boolean isStatic ( ByteBuffer name ) 
 - { 
 - ColumnDefinition def = cfm . getColumnDefinition ( name ) ; 
 - return def ! = null & & def . type = = ColumnDefinition . Type . STATIC ; 
 - } 
 - 
 - private ColumnNameBuilder createClusteringPrefixBuilderInternal ( List < ByteBuffer > variables ) 
 + private Composite createClusteringPrefixBuilderInternal ( QueryOptions options ) 
 throws InvalidRequestException 
 { 
 - CFDefinition cfDef = cfm . getCfDef ( ) ; 
 - ColumnNameBuilder builder = cfDef . getColumnNameBuilder ( ) ; 
 - CFDefinition . Name firstEmptyKey = null ; 
 - for ( CFDefinition . Name name : cfDef . clusteringColumns ( ) ) 
 + CBuilder builder = cfm . comparator . prefixBuilder ( ) ; 
 + ColumnDefinition firstEmptyKey = null ; 
 + for ( ColumnDefinition def : cfm . clusteringColumns ( ) ) 
 { 
 - Restriction r = processedKeys . get ( name . name ) ; 
 + Restriction r = processedKeys . get ( def . name ) ; 
 if ( r = = null ) 
 { 
 - firstEmptyKey = name ; 
 - if ( requireFullClusteringKey ( ) & & cfDef . isComposite & & ! cfDef . isCompact ) 
 - throw new InvalidRequestException ( String . format ( " Missing mandatory PRIMARY KEY part % s " , name ) ) ; 
 + firstEmptyKey = def ; 
 + if ( requireFullClusteringKey ( ) & & ! cfm . comparator . isDense ( ) & & cfm . comparator . isCompound ( ) ) 
 + throw new InvalidRequestException ( String . format ( " Missing mandatory PRIMARY KEY part % s " , def . name ) ) ; 
 } 
 else if ( firstEmptyKey ! = null ) 
 { 
 - throw new InvalidRequestException ( String . format ( " Missing PRIMARY KEY part % s since % s is set " , firstEmptyKey . name , name . name ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Missing PRIMARY KEY part % s since % s is set " , firstEmptyKey . name , def . name ) ) ; 
 } 
 else 
 { 
 - List < ByteBuffer > values = r . values ( variables ) ; 
 + List < ByteBuffer > values = r . values ( options ) ; 
 assert values . size ( ) = = 1 ; / / We only allow IN for row keys so far 
 ByteBuffer val = values . get ( 0 ) ; 
 if ( val = = null ) 
 - throw new InvalidRequestException ( String . format ( " Invalid null value for clustering key part % s " , name ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Invalid null value for clustering key part % s " , def . name ) ) ; 
 builder . add ( val ) ; 
 } 
 } 
 - return builder ; 
 + return builder . build ( ) ; 
 } 
 
 - protected CFDefinition . Name getFirstEmptyKey ( ) 
 + protected ColumnDefinition getFirstEmptyKey ( ) 
 { 
 - for ( CFDefinition . Name name : cfm . getCfDef ( ) . clusteringColumns ( ) ) 
 + for ( ColumnDefinition def : cfm . clusteringColumns ( ) ) 
 { 
 - if ( processedKeys . get ( name . name ) = = null ) 
 - return name ; 
 + if ( processedKeys . get ( def . name ) = = null ) 
 + return def ; 
 } 
 return null ; 
 } 
 
 - protected Map < ByteBuffer , ColumnGroupMap > readRequiredRows ( Collection < ByteBuffer > partitionKeys , ColumnNameBuilder clusteringPrefix , boolean local , ConsistencyLevel cl ) 
 + protected Map < ByteBuffer , CQL3Row > readRequiredRows ( Collection < ByteBuffer > partitionKeys , Composite clusteringPrefix , boolean local , ConsistencyLevel cl ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 / / Lists SET operation incurs a read . 
 - Set < ByteBuffer > toRead = null ; 
 + boolean requiresRead = false ; 
 for ( Operation op : columnOperations ) 
 { 
 if ( op . requiresRead ( ) ) 
 { 
 - if ( toRead = = null ) 
 - toRead = new TreeSet < ByteBuffer > ( UTF8Type . instance ) ; 
 - toRead . add ( op . columnName . key ) ; 
 + requiresRead = true ; 
 + break ; 
 } 
 } 
 
 - return toRead = = null ? null : readRows ( partitionKeys , clusteringPrefix , toRead , ( CompositeType ) cfm . comparator , local , cl ) ; 
 + return requiresRead ? readRows ( partitionKeys , clusteringPrefix , cfm , local , cl ) : null ; 
 } 
 
 - private Map < ByteBuffer , ColumnGroupMap > readRows ( Collection < ByteBuffer > partitionKeys , ColumnNameBuilder clusteringPrefix , Set < ByteBuffer > toRead , CompositeType composite , boolean local , ConsistencyLevel cl ) 
 + protected Map < ByteBuffer , CQL3Row > readRows ( Collection < ByteBuffer > partitionKeys , Composite rowPrefix , CFMetaData cfm , boolean local , ConsistencyLevel cl ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 try 
 @ @ - 465 , 16 + 426 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 throw new InvalidRequestException ( String . format ( " Write operation require a read but consistency % s is not supported on reads " , cl ) ) ; 
 } 
 
 - ColumnSlice [ ] slices = new ColumnSlice [ toRead . size ( ) ] ; 
 - int i = 0 ; 
 - for ( ByteBuffer name : toRead ) 
 - { 
 - ColumnNameBuilder prefix = updatePrefixFor ( name , clusteringPrefix ) ; 
 - ByteBuffer start = prefix . copy ( ) . add ( name ) . build ( ) ; 
 - ByteBuffer finish = prefix . copy ( ) . add ( name ) . buildAsEndOfRange ( ) ; 
 - slices [ i + + ] = new ColumnSlice ( start , finish ) ; 
 - } 
 - 
 + ColumnSlice [ ] slices = new ColumnSlice [ ] { rowPrefix . slice ( ) } ; 
 List < ReadCommand > commands = new ArrayList < ReadCommand > ( partitionKeys . size ( ) ) ; 
 long now = System . currentTimeMillis ( ) ; 
 for ( ByteBuffer key : partitionKeys ) 
 @ @ - 488 , 20 + 440 , 19 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 ? SelectStatement . readLocally ( keyspace ( ) , commands ) 
 : StorageProxy . read ( commands , cl ) ; 
 
 - Map < ByteBuffer , ColumnGroupMap > map = new HashMap < ByteBuffer , ColumnGroupMap > ( ) ; 
 + Map < ByteBuffer , CQL3Row > map = new HashMap < ByteBuffer , CQL3Row > ( ) ; 
 for ( Row row : rows ) 
 { 
 - if ( row . cf = = null | | row . cf . getColumnCount ( ) = = 0 ) 
 + if ( row . cf = = null | | row . cf . isEmpty ( ) ) 
 continue ; 
 
 - ColumnGroupMap . Builder groupBuilder = new ColumnGroupMap . Builder ( composite , true , now ) ; 
 - for ( Column column : row . cf ) 
 - groupBuilder . add ( column ) ; 
 - 
 - List < ColumnGroupMap > groups = groupBuilder . groups ( ) ; 
 - assert groups . isEmpty ( ) | | groups . size ( ) = = 1 ; 
 - if ( ! groups . isEmpty ( ) ) 
 - map . put ( row . key . key , groups . get ( 0 ) ) ; 
 + Iterator < CQL3Row > iter = cfm . comparator . CQL3RowBuilder ( cfm , now ) . group ( row . cf . getSortedColumns ( ) . iterator ( ) ) ; 
 + if ( iter . hasNext ( ) ) 
 + { 
 + map . put ( row . key . getKey ( ) , iter . next ( ) ) ; 
 + / / We can only update one CQ3Row per partition key at a time ( we don ' t allow IN for clustering key ) 
 + assert ! iter . hasNext ( ) ; 
 + } 
 } 
 return map ; 
 } 
 @ @ - 537 , 7 + 488 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 else 
 cl . validateForWrite ( cfm . ksName ) ; 
 
 - Collection < ? extends IMutation > mutations = getMutations ( options . getValues ( ) , false , cl , queryState . getTimestamp ( ) ) ; 
 + Collection < ? extends IMutation > mutations = getMutations ( options , false , options . getTimestamp ( queryState ) ) ; 
 if ( ! mutations . isEmpty ( ) ) 
 StorageProxy . mutateWithTriggers ( mutations , cl , false ) ; 
 
 @ @ - 547 , 18 + 498 , 18 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 public ResultMessage executeWithCondition ( QueryState queryState , QueryOptions options ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 - List < ByteBuffer > variables = options . getValues ( ) ; 
 - List < ByteBuffer > keys = buildPartitionKeyNames ( variables ) ; 
 + List < ByteBuffer > keys = buildPartitionKeyNames ( options ) ; 
 / / We don ' t support IN for CAS operation so far 
 if ( keys . size ( ) > 1 ) 
 throw new InvalidRequestException ( " IN on the partition key is not supported with conditional updates " ) ; 
 
 ByteBuffer key = keys . get ( 0 ) ; 
 
 - CQL3CasConditions conditions = new CQL3CasConditions ( cfm , queryState . getTimestamp ( ) ) ; 
 - ColumnNameBuilder prefix = createClusteringPrefixBuilder ( variables ) ; 
 - ColumnFamily updates = UnsortedColumns . factory . create ( cfm ) ; 
 - addUpdatesAndConditions ( key , prefix , updates , conditions , variables , getTimestamp ( queryState . getTimestamp ( ) , variables ) ) ; 
 + long now = options . getTimestamp ( queryState ) ; 
 + CQL3CasConditions conditions = new CQL3CasConditions ( cfm , now ) ; 
 + Composite prefix = createClusteringPrefix ( options ) ; 
 + ColumnFamily updates = ArrayBackedSortedColumns . factory . create ( cfm ) ; 
 + addUpdatesAndConditions ( key , prefix , updates , conditions , options , getTimestamp ( now , options ) ) ; 
 
 ColumnFamily result = StorageProxy . cas ( keyspace ( ) , 
 columnFamily ( ) , 
 @ @ - 570 , 16 + 521 , 16 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 return new ResultMessage . Rows ( buildCasResultSet ( key , result ) ) ; 
 } 
 
 - public void addUpdatesAndConditions ( ByteBuffer key , ColumnNameBuilder clusteringPrefix , ColumnFamily updates , CQL3CasConditions conditions , List < ByteBuffer > variables , long now ) 
 + public void addUpdatesAndConditions ( ByteBuffer key , Composite clusteringPrefix , ColumnFamily updates , CQL3CasConditions conditions , QueryOptions options , long now ) 
 throws InvalidRequestException 
 { 
 - UpdateParameters updParams = new UpdateParameters ( cfm , variables , now , getTimeToLive ( variables ) , null ) ; 
 + UpdateParameters updParams = new UpdateParameters ( cfm , options , now , getTimeToLive ( options ) , null ) ; 
 addUpdateForKey ( updates , key , clusteringPrefix , updParams ) ; 
 
 if ( ifNotExists ) 
 { 
 / / If we use ifNotExists , if the statement applies to any non static columns , then the condition is on the row of the non - static 
 - / / columns and the prefix should be the rowPrefix . But if only static columns are set , then the ifNotExists apply to the existence 
 + / / columns and the prefix should be the clusteringPrefix . But if only static columns are set , then the ifNotExists apply to the existence 
 / / of any static columns and we should use the prefix for the " static part " of the partition . 
 conditions . addNotExist ( clusteringPrefix ) ; 
 } 
 @ @ - 590 , 9 + 541 , 9 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 else 
 { 
 if ( columnConditions ! = null ) 
 - conditions . addConditions ( clusteringPrefix , columnConditions , variables ) ; 
 + conditions . addConditions ( clusteringPrefix , columnConditions , options ) ; 
 if ( staticConditions ! = null ) 
 - conditions . addConditions ( cfm . getStaticColumnNameBuilder ( ) , staticConditions , variables ) ; 
 + conditions . addConditions ( cfm . comparator . staticPrefix ( ) , staticConditions , options ) ; 
 } 
 } 
 
 @ @ - 601 , 7 + 552 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 return buildCasResultSet ( keyspace ( ) , key , columnFamily ( ) , cf , getColumnsWithConditions ( ) , false ) ; 
 } 
 
 - public static ResultSet buildCasResultSet ( String ksName , ByteBuffer key , String cfName , ColumnFamily cf , Iterable < ColumnIdentifier > columnsWithConditions , boolean isBatch ) 
 + public static ResultSet buildCasResultSet ( String ksName , ByteBuffer key , String cfName , ColumnFamily cf , Iterable < ColumnDefinition > columnsWithConditions , boolean isBatch ) 
 throws InvalidRequestException 
 { 
 boolean success = cf = = null ; 
 @ @ - 637 , 34 + 588 , 33 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 return new ResultSet ( new ResultSet . Metadata ( specs ) , rows ) ; 
 } 
 
 - private static ResultSet buildCasFailureResultSet ( ByteBuffer key , ColumnFamily cf , Iterable < ColumnIdentifier > columnsWithConditions , boolean isBatch ) 
 + private static ResultSet buildCasFailureResultSet ( ByteBuffer key , ColumnFamily cf , Iterable < ColumnDefinition > columnsWithConditions , boolean isBatch ) 
 throws InvalidRequestException 
 { 
 - CFDefinition cfDef = cf . metadata ( ) . getCfDef ( ) ; 
 - 
 + CFMetaData cfm = cf . metadata ( ) ; 
 Selection selection ; 
 if ( columnsWithConditions = = null ) 
 { 
 - selection = Selection . wildcard ( cfDef ) ; 
 + selection = Selection . wildcard ( cfm ) ; 
 } 
 else 
 { 
 - List < CFDefinition . Name > names = new ArrayList < CFDefinition . Name > ( ) ; 
 + List < ColumnDefinition > defs = new ArrayList < > ( ) ; 
 / / Adding the partition key for batches to disambiguate if the conditions span multipe rows ( we don ' t add them outside 
 / / of batches for compatibility sakes ) . 
 if ( isBatch ) 
 { 
 - names . addAll ( cfDef . partitionKeys ( ) ) ; 
 - names . addAll ( cfDef . clusteringColumns ( ) ) ; 
 + defs . addAll ( cfm . partitionKeyColumns ( ) ) ; 
 + defs . addAll ( cfm . clusteringColumns ( ) ) ; 
 } 
 - for ( ColumnIdentifier id : columnsWithConditions ) 
 - names . add ( cfDef . get ( id ) ) ; 
 - selection = Selection . forColumns ( names ) ; 
 + for ( ColumnDefinition def : columnsWithConditions ) 
 + defs . add ( def ) ; 
 + selection = Selection . forColumns ( defs ) ; 
 } 
 
 long now = System . currentTimeMillis ( ) ; 
 Selection . ResultSetBuilder builder = selection . resultSetBuilder ( now ) ; 
 - SelectStatement . forSelection ( cfDef , selection ) . processColumnFamily ( key , cf , Collections . < ByteBuffer > emptyList ( ) , now , builder ) ; 
 + SelectStatement . forSelection ( cfm , selection ) . processColumnFamily ( key , cf , QueryOptions . DEFAULT , now , builder ) ; 
 
 return builder . build ( ) ; 
 } 
 @ @ - 674 , 15 + 624 , 19 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 if ( hasConditions ( ) ) 
 throw new UnsupportedOperationException ( ) ; 
 
 - for ( IMutation mutation : getMutations ( Collections . < ByteBuffer > emptyList ( ) , true , null , queryState . getTimestamp ( ) ) ) 
 - mutation . apply ( ) ; 
 + for ( IMutation mutation : getMutations ( QueryOptions . DEFAULT , true , queryState . getTimestamp ( ) ) ) 
 + { 
 + / / We don ' t use counters internally . 
 + assert mutation instanceof Mutation ; 
 + ( ( Mutation ) mutation ) . apply ( ) ; 
 + } 
 return null ; 
 } 
 
 / * * 
 * Convert statement into a list of mutations to apply on the server 
 * 
 - * @ param variables value for prepared statement markers 
 + * @ param options value for prepared statement markers 
 * @ param local if true , any requests ( for collections ) performed by getMutation should be done locally only . 
 * @ param cl the consistency to use for the potential reads involved in generating the mutations ( for lists set / delete operations ) 
 * @ param now the current timestamp in microseconds to use if no timestamp is user provided . 
 @ @ - 690 , 37 + 644 , 36 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 * @ return list of the mutations 
 * @ throws InvalidRequestException on invalid requests 
 * / 
 - private Collection < ? extends IMutation > getMutations ( List < ByteBuffer > variables , boolean local , ConsistencyLevel cl , long now ) 
 + private Collection < ? extends IMutation > getMutations ( QueryOptions options , boolean local , long now ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 - List < ByteBuffer > keys = buildPartitionKeyNames ( variables ) ; 
 - ColumnNameBuilder clusteringPrefix = createClusteringPrefixBuilder ( variables ) ; 
 + List < ByteBuffer > keys = buildPartitionKeyNames ( options ) ; 
 + Composite clusteringPrefix = createClusteringPrefix ( options ) ; 
 
 - UpdateParameters params = makeUpdateParameters ( keys , clusteringPrefix , variables , local , cl , now ) ; 
 + UpdateParameters params = makeUpdateParameters ( keys , clusteringPrefix , options , local , now ) ; 
 
 Collection < IMutation > mutations = new ArrayList < IMutation > ( ) ; 
 for ( ByteBuffer key : keys ) 
 { 
 ThriftValidation . validateKey ( cfm , key ) ; 
 - ColumnFamily cf = UnsortedColumns . factory . create ( cfm ) ; 
 + ColumnFamily cf = ArrayBackedSortedColumns . factory . create ( cfm ) ; 
 addUpdateForKey ( cf , key , clusteringPrefix , params ) ; 
 - RowMutation rm = new RowMutation ( cfm . ksName , key , cf ) ; 
 - mutations . add ( isCounter ( ) ? new CounterMutation ( rm , cl ) : rm ) ; 
 + Mutation mut = new Mutation ( cfm . ksName , key , cf ) ; 
 + mutations . add ( isCounter ( ) ? new CounterMutation ( mut , options . getConsistency ( ) ) : mut ) ; 
 } 
 return mutations ; 
 } 
 
 public UpdateParameters makeUpdateParameters ( Collection < ByteBuffer > keys , 
 - ColumnNameBuilder prefix , 
 - List < ByteBuffer > variables , 
 + Composite prefix , 
 + QueryOptions options , 
 boolean local , 
 - ConsistencyLevel cl , 
 long now ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 / / Some lists operation requires reading 
 - Map < ByteBuffer , ColumnGroupMap > rows = readRequiredRows ( keys , prefix , local , cl ) ; 
 - return new UpdateParameters ( cfm , variables , getTimestamp ( now , variables ) , getTimeToLive ( variables ) , rows ) ; 
 + Map < ByteBuffer , CQL3Row > rows = readRequiredRows ( keys , prefix , local , options . getConsistency ( ) ) ; 
 + return new UpdateParameters ( cfm , options , getTimestamp ( now , options ) , getTimeToLive ( options ) , rows ) ; 
 } 
 
 public static abstract class Parsed extends CFStatement 
 @ @ - 749 , 16 + 702 , 11 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 public ModificationStatement prepare ( VariableSpecifications boundNames ) throws InvalidRequestException 
 { 
 CFMetaData metadata = ThriftValidation . validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; 
 - CFDefinition cfDef = metadata . getCfDef ( ) ; 
 - 
 - / / The collected count in the beginning of preparation . 
 - / / Will start at non - zero for statements nested inside a BatchStatement ( the second and the further ones ) . 
 - int collected = boundNames . getCollectedCount ( ) ; 
 
 Attributes preparedAttributes = attrs . prepare ( keyspace ( ) , columnFamily ( ) ) ; 
 preparedAttributes . collectMarkerSpecification ( boundNames ) ; 
 
 - ModificationStatement stmt = prepareInternal ( cfDef , boundNames , preparedAttributes ) ; 
 + ModificationStatement stmt = prepareInternal ( metadata , boundNames , preparedAttributes ) ; 
 
 if ( ifNotExists | | ifExists | | ! conditions . isEmpty ( ) ) 
 { 
 @ @ - 766 , 7 + 714 , 7 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; 
 
 if ( attrs . timestamp ! = null ) 
 - throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; 
 + throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional updates " ) ; 
 
 if ( ifNotExists ) 
 { 
 @ @ - 786 , 32 + 734 , 28 @ @ public abstract class ModificationStatement implements CQLStatement , MeasurableF 
 { 
 for ( Pair < ColumnIdentifier , ColumnCondition . Raw > entry : conditions ) 
 { 
 - CFDefinition . Name name = cfDef . get ( entry . left ) ; 
 - if ( name = = null ) 
 + ColumnDefinition def = metadata . getColumnDefinition ( entry . left ) ; 
 + if ( def = = null ) 
 throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; 
 
 - ColumnCondition condition = entry . right . prepare ( name ) ; 
 + ColumnCondition condition = entry . right . prepare ( keyspace ( ) , def ) ; 
 condition . collectMarkerSpecification ( boundNames ) ; 
 
 - switch ( name . kind ) 
 + switch ( def . kind ) 
 { 
 - case KEY _ ALIAS : 
 - case COLUMN _ ALIAS : 
 + case PARTITION _ KEY : 
 + case CLUSTERING _ COLUMN : 
 throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; 
 - case VALUE _ ALIAS : 
 - case COLUMN _ METADATA : 
 - case STATIC : 
 + default : 
 stmt . addCondition ( condition ) ; 
 break ; 
 } 
 } 
 } 
 } 
 - 
 - stmt . boundTerms = boundNames . getCollectedCount ( ) - collected ; 
 return stmt ; 
 } 
 
 - protected abstract ModificationStatement prepareInternal ( CFDefinition cfDef , VariableSpecifications boundNames , Attributes attrs ) throws InvalidRequestException ; 
 + protected abstract ModificationStatement prepareInternal ( CFMetaData cfm , VariableSpecifications boundNames , Attributes attrs ) throws InvalidRequestException ; 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 83eca8a . . 27831ba 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 11 , 6 + 11 , 8 @ @ 
 * synchronize BiMap of bootstrapping tokens ( CASSANDRA - 3417 ) 
 * show index options in CLI ( CASSANDRA - 3809 ) 
 * add optional socket timeout for streaming ( CASSANDRA - 3838 ) 
 + * fix truncate not to leave behind non - CFS backed secondary indexes 
 + ( CASSANDRA - 3844 ) 
 Merged from 0 . 8 : 
 * ( Pig ) fix CassandraStorage to use correct comparator in Super ColumnFamily 
 case ( CASSANDRA - 3251 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 151564c . . 0952ffd 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1939 , 4 + 1939 , 24 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 DataTracker . View view = data . getView ( ) ; 
 return view . sstables . isEmpty ( ) & & view . memtable . getOperations ( ) = = 0 & & view . memtablesPendingFlush . isEmpty ( ) ; 
 } 
 + 
 + / * * 
 + * Discard all SSTables that were created before given timestamp . Caller is responsible to obtain compactionLock . 
 + * 
 + * @ param truncatedAt The timestamp of the truncation 
 + * ( all SSTables before that timestamp are going be marked as compacted ) 
 + * / 
 + public void discardSSTables ( long truncatedAt ) 
 + { 
 + List < SSTableReader > truncatedSSTables = new ArrayList < SSTableReader > ( ) ; 
 + 
 + for ( SSTableReader sstable : getSSTables ( ) ) 
 + { 
 + if ( ! sstable . newSince ( truncatedAt ) ) 
 + truncatedSSTables . add ( sstable ) ; 
 + } 
 + 
 + if ( ! truncatedSSTables . isEmpty ( ) ) 
 + markCompacted ( truncatedSSTables ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index ac25c4b . . caaf6d2 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . db . index . SecondaryIndex ; 
 import org . apache . cassandra . db . index . SecondaryIndexBuilder ; 
 import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . io . sstable . * ; 
 @ @ - 928 , 19 + 929 , 13 @ @ public class CompactionManager implements CompactionManagerMBean 
 public void runMayThrow ( ) throws InterruptedException , IOException 
 { 
 compactionLock . writeLock ( ) . lock ( ) ; 
 + 
 try 
 { 
 - for ( ColumnFamilyStore cfs : main . concatWithIndexes ( ) ) 
 - { 
 - List < SSTableReader > truncatedSSTables = new ArrayList < SSTableReader > ( ) ; 
 - for ( SSTableReader sstable : cfs . getSSTables ( ) ) 
 - { 
 - if ( ! sstable . newSince ( truncatedAt ) ) 
 - truncatedSSTables . add ( sstable ) ; 
 - } 
 - if ( ! truncatedSSTables . isEmpty ( ) ) 
 - cfs . markCompacted ( truncatedSSTables ) ; 
 - } 
 + main . discardSSTables ( truncatedAt ) ; 
 + 
 + for ( SecondaryIndex index : main . indexManager . getIndexes ( ) ) 
 + index . truncate ( truncatedAt ) ; 
 } 
 finally 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndex . java b / src / java / org / apache / cassandra / db / index / SecondaryIndex . java 
 index c2d2318 . . 5006217 100644 
 - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndex . java 
 + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndex . java 
 @ @ - 133 , 7 + 133 , 13 @ @ public abstract class SecondaryIndex 
 * Remove the index and unregisters this index ' s mbean if one exists 
 * / 
 public abstract void invalidate ( ) ; 
 - 
 + 
 + / * * 
 + * Truncate all the data from the current index 
 + * 
 + * @ param truncatedAt The truncation timestamp , all data before that timestamp should be rejected . 
 + * / 
 + public abstract void truncate ( long truncatedAt ) ; 
 
 / * * 
 * Builds the index using the data in the underlying CFS 
 diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 index d5fdd2c . . 77bf954 100644 
 - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 @ @ - 327 , 7 + 327 , 21 @ @ public class SecondaryIndexManager 
 
 return indexList . keySet ( ) ; 
 } 
 - 
 + 
 + / * * 
 + * @ return all of the secondary indexes without distinction to the ( non - ) backed by secondary ColumnFamilyStore . 
 + * / 
 + public Collection < SecondaryIndex > getIndexes ( ) 
 + { 
 + / / we use identity map because per row indexes use same instance across many columns 
 + IdentityHashMap < SecondaryIndex , Object > indexList = new IdentityHashMap < SecondaryIndex , Object > ( ) ; 
 + 
 + for ( Map . Entry < ByteBuffer , SecondaryIndex > entry : indexesByColumn . entrySet ( ) ) 
 + indexList . put ( entry . getValue ( ) , null ) ; 
 + 
 + return indexList . keySet ( ) ; 
 + } 
 + 
 / * * 
 * @ return total current ram size of all indexes 
 * / 
 diff - - git a / src / java / org / apache / cassandra / db / index / keys / KeysIndex . java b / src / java / org / apache / cassandra / db / index / keys / KeysIndex . java 
 index ce26ab3 . . 6ce6242 100644 
 - - - a / src / java / org / apache / cassandra / db / index / keys / KeysIndex . java 
 + + + b / src / java / org / apache / cassandra / db / index / keys / KeysIndex . java 
 @ @ - 133 , 6 + 133 , 11 @ @ public class KeysIndex extends PerColumnSecondaryIndex 
 indexCfs . invalidate ( ) ; 
 } 
 
 + public void truncate ( long truncatedAt ) 
 + { 
 + indexCfs . discardSSTables ( truncatedAt ) ; 
 + } 
 + 
 public ColumnFamilyStore getIndexCfs ( ) 
 { 
 return indexCfs ;
