BLEU SCORE: 0.01683602693167689

TEST MSG: Fix PITR commitlog replay
GENERATED MSG: Revert " Fail to start if commit log replay encounters an exception "

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 481fb80 . . a01e8ed 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 6 <nl> + * Fix PITR commitlog replay ( CASSANDRA - 9195 ) <nl> * GCInspector logs very different times ( CASSANDRA - 9124 ) <nl> * Fix deleting from an empty list ( CASSANDRA - 9198 ) <nl> * Update tuple and collection types that use a user - defined type when that UDT <nl> @ @ - 8 , 6 + 9 , 7 @ @ Merged from 2 . 0 : <nl> * IncomingTcpConnection thread is not named ( CASSANDRA - 9262 ) <nl> * Close incoming connections when MessagingService is stopped ( CASSANDRA - 9238 ) <nl> <nl> + <nl> 2 . 1 . 5 <nl> * Re - add deprecated cold _ reads _ to _ omit param for backwards compat ( CASSANDRA - 9203 ) <nl> * Make anticompaction visible in compactionstats ( CASSANDRA - 9098 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java <nl> index 63afcbc . . 57f4b90 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java <nl> @ @ - 34 , 13 + 34 , 13 @ @ import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . concurrent . Stage ; <nl> import org . apache . cassandra . concurrent . StageManager ; <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . io . util . FastByteArrayInputStream ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . io . util . RandomAccessReader ; <nl> import org . apache . cassandra . utils . * ; <nl> - <nl> import org . cliffc . high _ scale _ lib . NonBlockingHashSet ; <nl> <nl> public class CommitLogReplayer <nl> @ @ - 58 , 6 + 58 , 8 @ @ public class CommitLogReplayer <nl> private final PureJavaCrc32 checksum ; <nl> private byte [ ] buffer ; <nl> <nl> + private final ReplayFilter replayFilter ; <nl> + <nl> public CommitLogReplayer ( ) <nl> { <nl> this . keyspacesRecovered = new NonBlockingHashSet < Keyspace > ( ) ; <nl> @ @ - 68 , 6 + 70 , 8 @ @ public class CommitLogReplayer <nl> this . replayedCount = new AtomicInteger ( ) ; <nl> this . checksum = new PureJavaCrc32 ( ) ; <nl> <nl> + replayFilter = ReplayFilter . create ( ) ; <nl> + <nl> / / compute per - CF and global replay positions <nl> cfPositions = new HashMap < UUID , ReplayPosition > ( ) ; <nl> Ordering < ReplayPosition > replayPositionOrdering = Ordering . from ( ReplayPosition . comparator ) ; <nl> @ @ - 81 , 7 + 85 , 27 @ @ public class CommitLogReplayer <nl> / / but , if we ' ve truncted the cf in question , then we need to need to start replay after the truncation <nl> ReplayPosition truncatedAt = SystemKeyspace . getTruncatedPosition ( cfs . metadata . cfId ) ; <nl> if ( truncatedAt ! = null ) <nl> - rp = replayPositionOrdering . max ( Arrays . asList ( rp , truncatedAt ) ) ; <nl> + { <nl> + / / Point in time restore is taken to mean that the tables need to be recovered even if they were <nl> + / / deleted at a later point in time . Any truncation record after that point must thus be cleared prior <nl> + / / to recovery ( CASSANDRA - 9195 ) . <nl> + long restoreTime = CommitLog . instance . archiver . restorePointInTime ; <nl> + long truncatedTime = SystemKeyspace . getTruncatedAt ( cfs . metadata . cfId ) ; <nl> + if ( truncatedTime > restoreTime ) <nl> + { <nl> + if ( replayFilter . includes ( cfs . metadata ) ) <nl> + { <nl> + logger . info ( " Restore point in time is before latest truncation of table { } . { } . Clearing truncation record . " , <nl> + cfs . metadata . ksName , <nl> + cfs . metadata . cfName ) ; <nl> + SystemKeyspace . removeTruncationRecord ( cfs . metadata . cfId ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + rp = replayPositionOrdering . max ( Arrays . asList ( rp , truncatedAt ) ) ; <nl> + } <nl> + } <nl> <nl> cfPositions . put ( cfs . metadata . cfId , rp ) ; <nl> } <nl> @ @ - 167 , 6 + 191 , 8 @ @ public class CommitLogReplayer <nl> { <nl> public abstract Iterable < ColumnFamily > filter ( Mutation mutation ) ; <nl> <nl> + public abstract boolean includes ( CFMetaData metadata ) ; <nl> + <nl> public static ReplayFilter create ( ) <nl> { <nl> / / If no replaylist is supplied an empty array of strings is used to replay everything . <nl> @ @ - 183 , 7 + 209 , 8 @ @ public class CommitLogReplayer <nl> Keyspace ks = Schema . instance . getKeyspaceInstance ( pair [ 0 ] ) ; <nl> if ( ks = = null ) <nl> throw new IllegalArgumentException ( " Unknown keyspace " + pair [ 0 ] ) ; <nl> - if ( ks . getColumnFamilyStore ( pair [ 1 ] ) = = null ) <nl> + ColumnFamilyStore cfs = ks . getColumnFamilyStore ( pair [ 1 ] ) ; <nl> + if ( cfs = = null ) <nl> throw new IllegalArgumentException ( String . format ( " Unknown table % s . % s " , pair [ 0 ] , pair [ 1 ] ) ) ; <nl> <nl> toReplay . put ( pair [ 0 ] , pair [ 1 ] ) ; <nl> @ @ - 198 , 6 + 225 , 11 @ @ public class CommitLogReplayer <nl> { <nl> return mutation . getColumnFamilies ( ) ; <nl> } <nl> + <nl> + public boolean includes ( CFMetaData metadata ) <nl> + { <nl> + return true ; <nl> + } <nl> } <nl> <nl> private static class CustomReplayFilter extends ReplayFilter <nl> @ @ - 223 , 11 + 255 , 15 @ @ public class CommitLogReplayer <nl> } <nl> } ) ; <nl> } <nl> + <nl> + public boolean includes ( CFMetaData metadata ) <nl> + { <nl> + return toReplay . containsEntry ( metadata . ksName , metadata . cfName ) ; <nl> + } <nl> } <nl> <nl> public void recover ( File file ) throws IOException <nl> { <nl> - final ReplayFilter replayFilter = ReplayFilter . create ( ) ; <nl> logger . info ( " Replaying { } " , file . getPath ( ) ) ; <nl> CommitLogDescriptor desc = CommitLogDescriptor . fromFileName ( file . getName ( ) ) ; <nl> final long segmentId = desc . id ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 481fb80 . . a01e8ed 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 6 
 + * Fix PITR commitlog replay ( CASSANDRA - 9195 ) 
 * GCInspector logs very different times ( CASSANDRA - 9124 ) 
 * Fix deleting from an empty list ( CASSANDRA - 9198 ) 
 * Update tuple and collection types that use a user - defined type when that UDT 
 @ @ - 8 , 6 + 9 , 7 @ @ Merged from 2 . 0 : 
 * IncomingTcpConnection thread is not named ( CASSANDRA - 9262 ) 
 * Close incoming connections when MessagingService is stopped ( CASSANDRA - 9238 ) 
 
 + 
 2 . 1 . 5 
 * Re - add deprecated cold _ reads _ to _ omit param for backwards compat ( CASSANDRA - 9203 ) 
 * Make anticompaction visible in compactionstats ( CASSANDRA - 9098 ) 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java 
 index 63afcbc . . 57f4b90 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java 
 @ @ - 34 , 13 + 34 , 13 @ @ import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . concurrent . Stage ; 
 import org . apache . cassandra . concurrent . StageManager ; 
 + import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . io . util . FastByteArrayInputStream ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . io . util . RandomAccessReader ; 
 import org . apache . cassandra . utils . * ; 
 - 
 import org . cliffc . high _ scale _ lib . NonBlockingHashSet ; 
 
 public class CommitLogReplayer 
 @ @ - 58 , 6 + 58 , 8 @ @ public class CommitLogReplayer 
 private final PureJavaCrc32 checksum ; 
 private byte [ ] buffer ; 
 
 + private final ReplayFilter replayFilter ; 
 + 
 public CommitLogReplayer ( ) 
 { 
 this . keyspacesRecovered = new NonBlockingHashSet < Keyspace > ( ) ; 
 @ @ - 68 , 6 + 70 , 8 @ @ public class CommitLogReplayer 
 this . replayedCount = new AtomicInteger ( ) ; 
 this . checksum = new PureJavaCrc32 ( ) ; 
 
 + replayFilter = ReplayFilter . create ( ) ; 
 + 
 / / compute per - CF and global replay positions 
 cfPositions = new HashMap < UUID , ReplayPosition > ( ) ; 
 Ordering < ReplayPosition > replayPositionOrdering = Ordering . from ( ReplayPosition . comparator ) ; 
 @ @ - 81 , 7 + 85 , 27 @ @ public class CommitLogReplayer 
 / / but , if we ' ve truncted the cf in question , then we need to need to start replay after the truncation 
 ReplayPosition truncatedAt = SystemKeyspace . getTruncatedPosition ( cfs . metadata . cfId ) ; 
 if ( truncatedAt ! = null ) 
 - rp = replayPositionOrdering . max ( Arrays . asList ( rp , truncatedAt ) ) ; 
 + { 
 + / / Point in time restore is taken to mean that the tables need to be recovered even if they were 
 + / / deleted at a later point in time . Any truncation record after that point must thus be cleared prior 
 + / / to recovery ( CASSANDRA - 9195 ) . 
 + long restoreTime = CommitLog . instance . archiver . restorePointInTime ; 
 + long truncatedTime = SystemKeyspace . getTruncatedAt ( cfs . metadata . cfId ) ; 
 + if ( truncatedTime > restoreTime ) 
 + { 
 + if ( replayFilter . includes ( cfs . metadata ) ) 
 + { 
 + logger . info ( " Restore point in time is before latest truncation of table { } . { } . Clearing truncation record . " , 
 + cfs . metadata . ksName , 
 + cfs . metadata . cfName ) ; 
 + SystemKeyspace . removeTruncationRecord ( cfs . metadata . cfId ) ; 
 + } 
 + } 
 + else 
 + { 
 + rp = replayPositionOrdering . max ( Arrays . asList ( rp , truncatedAt ) ) ; 
 + } 
 + } 
 
 cfPositions . put ( cfs . metadata . cfId , rp ) ; 
 } 
 @ @ - 167 , 6 + 191 , 8 @ @ public class CommitLogReplayer 
 { 
 public abstract Iterable < ColumnFamily > filter ( Mutation mutation ) ; 
 
 + public abstract boolean includes ( CFMetaData metadata ) ; 
 + 
 public static ReplayFilter create ( ) 
 { 
 / / If no replaylist is supplied an empty array of strings is used to replay everything . 
 @ @ - 183 , 7 + 209 , 8 @ @ public class CommitLogReplayer 
 Keyspace ks = Schema . instance . getKeyspaceInstance ( pair [ 0 ] ) ; 
 if ( ks = = null ) 
 throw new IllegalArgumentException ( " Unknown keyspace " + pair [ 0 ] ) ; 
 - if ( ks . getColumnFamilyStore ( pair [ 1 ] ) = = null ) 
 + ColumnFamilyStore cfs = ks . getColumnFamilyStore ( pair [ 1 ] ) ; 
 + if ( cfs = = null ) 
 throw new IllegalArgumentException ( String . format ( " Unknown table % s . % s " , pair [ 0 ] , pair [ 1 ] ) ) ; 
 
 toReplay . put ( pair [ 0 ] , pair [ 1 ] ) ; 
 @ @ - 198 , 6 + 225 , 11 @ @ public class CommitLogReplayer 
 { 
 return mutation . getColumnFamilies ( ) ; 
 } 
 + 
 + public boolean includes ( CFMetaData metadata ) 
 + { 
 + return true ; 
 + } 
 } 
 
 private static class CustomReplayFilter extends ReplayFilter 
 @ @ - 223 , 11 + 255 , 15 @ @ public class CommitLogReplayer 
 } 
 } ) ; 
 } 
 + 
 + public boolean includes ( CFMetaData metadata ) 
 + { 
 + return toReplay . containsEntry ( metadata . ksName , metadata . cfName ) ; 
 + } 
 } 
 
 public void recover ( File file ) throws IOException 
 { 
 - final ReplayFilter replayFilter = ReplayFilter . create ( ) ; 
 logger . info ( " Replaying { } " , file . getPath ( ) ) ; 
 CommitLogDescriptor desc = CommitLogDescriptor . fromFileName ( file . getName ( ) ) ; 
 final long segmentId = desc . id ;

NEAREST DIFF:
ELIMINATEDSENTENCE
