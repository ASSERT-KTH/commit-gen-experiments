BLEU SCORE: 1.0

TEST MSG: Track metrics at a keyspace level
GENERATED MSG: Track metrics at a keyspace level

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> new file mode 100644 <nl> index 0000000 . . 4a0980f <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> @ @ - 0 , 0 + 1 , 202 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . metrics ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + <nl> + import com . yammer . metrics . Metrics ; <nl> + import com . yammer . metrics . core . * ; <nl> + import com . yammer . metrics . stats . Snapshot ; <nl> + <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + <nl> + / * * <nl> + * Metrics for { @ link ColumnFamilyStore } . <nl> + * / <nl> + public class KeyspaceMetrics <nl> + { <nl> + / * * Total amount of data stored in the memtable , including column related overhead . * / <nl> + public final Gauge < Long > memtableDataSize ; <nl> + / * * Total amount of data stored in the memtables ( 2i and pending flush memtables included ) . * / <nl> + public final Gauge < Long > allMemtablesDataSize ; <nl> + / * * Total number of columns present in the memtable . * / <nl> + public final Gauge < Long > memtableColumnsCount ; <nl> + / * * Number of times flush has resulted in the memtable being switched out . * / <nl> + public final Gauge < Long > memtableSwitchCount ; <nl> + / * * Estimated number of tasks pending for this column family * / <nl> + public final Gauge < Integer > pendingTasks ; <nl> + / * * Estimate of number of pending compactios for this CF * / <nl> + public final Gauge < Integer > pendingCompactions ; <nl> + / * * Disk space used by SSTables belonging to this CF * / <nl> + public final Gauge < Long > liveDiskSpaceUsed ; <nl> + / * * Total disk space used by SSTables belonging to this CF , including obsolete ones waiting to be GC ' d * / <nl> + public final Gauge < Long > totalDiskSpaceUsed ; <nl> + / * * Disk space used by bloom filter * / <nl> + public final Gauge < Long > bloomFilterDiskSpaceUsed ; <nl> + <nl> + private final MetricNameFactory factory ; <nl> + <nl> + / * * <nl> + * Creates metrics for given { @ link ColumnFamilyStore } . <nl> + * <nl> + * @ param ks Keyspace to measure metrics <nl> + * / <nl> + public KeyspaceMetrics ( final Keyspace ks ) <nl> + { <nl> + factory = new KeyspaceMetricNameFactory ( ks ) ; <nl> + <nl> + memtableColumnsCount = Metrics . newGauge ( factory . createMetricName ( " MemtableColumnsCount " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long total = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + total + = cf . metric . memtableColumnsCount . value ( ) ; <nl> + } <nl> + return total ; <nl> + } <nl> + } ) ; <nl> + memtableDataSize = Metrics . newGauge ( factory . createMetricName ( " MemtableDataSize " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long total = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + total + = cf . metric . memtableDataSize . value ( ) ; <nl> + } <nl> + return total ; <nl> + } <nl> + } ) ; <nl> + allMemtablesDataSize = Metrics . newGauge ( factory . createMetricName ( " AllMemtablesDataSize " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long total = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + total + = cf . metric . allMemtablesDataSize . value ( ) ; <nl> + } <nl> + return total ; <nl> + } <nl> + } ) ; <nl> + memtableSwitchCount = Metrics . newGauge ( factory . createMetricName ( " MemtableSwitchCount " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long sum = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + sum + = cf . metric . memtableSwitchCount . count ( ) ; <nl> + return sum ; <nl> + } <nl> + } ) ; <nl> + pendingCompactions = Metrics . newGauge ( factory . createMetricName ( " PendingCompactions " ) , new Gauge < Integer > ( ) <nl> + { <nl> + public Integer value ( ) <nl> + { <nl> + int sum = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + sum + = cf . metric . pendingCompactions . value ( ) ; <nl> + } <nl> + return sum ; <nl> + } <nl> + } ) ; <nl> + pendingTasks = Metrics . newGauge ( factory . createMetricName ( " PendingTasks " ) , new Gauge < Integer > ( ) <nl> + { <nl> + public Integer value ( ) <nl> + { <nl> + return Keyspace . switchLock . getQueueLength ( ) ; <nl> + } <nl> + } ) ; <nl> + liveDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " LiveDiskSpaceUsed " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long sum = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + sum + = cf . metric . liveDiskSpaceUsed . count ( ) ; <nl> + } <nl> + return sum ; <nl> + } <nl> + } ) ; <nl> + totalDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " TotalDiskSpaceUsed " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long sum = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + sum + = cf . metric . totalDiskSpaceUsed . count ( ) ; <nl> + } <nl> + return sum ; <nl> + } <nl> + } ) ; <nl> + bloomFilterDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " BloomFilterDiskSpaceUsed " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long total = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + total + = cf . metric . bloomFilterDiskSpaceUsed . value ( ) ; <nl> + return total ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Release all associated metrics . <nl> + * / <nl> + public void release ( ) <nl> + { <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " AllMemtablesDataSize " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " MemtableDataSize " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " MemtableSwitchCount " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " PendingTasks " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " LiveDiskSpaceUsed " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " TotalDiskSpaceUsed " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " BloomFilterDiskSpaceUsed " ) ) ; <nl> + } <nl> + <nl> + class KeyspaceMetricNameFactory implements MetricNameFactory <nl> + { <nl> + private final String keyspaceName ; <nl> + <nl> + KeyspaceMetricNameFactory ( Keyspace ks ) <nl> + { <nl> + this . keyspaceName = ks . getName ( ) ; <nl> + } <nl> + <nl> + public MetricName createMetricName ( String metricName ) <nl> + { <nl> + String groupName = ColumnFamilyMetrics . class . getPackage ( ) . getName ( ) ; <nl> + <nl> + StringBuilder mbeanName = new StringBuilder ( ) ; <nl> + mbeanName . append ( groupName ) . append ( " : " ) ; <nl> + mbeanName . append ( " type = Keyspace " ) ; <nl> + mbeanName . append ( " , keyspace = " ) . append ( keyspaceName ) ; <nl> + mbeanName . append ( " , name = " ) . append ( metricName ) ; <nl> + <nl> + return new MetricName ( groupName , " keyspace " , metricName , keyspaceName , mbeanName . toString ( ) ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 new file mode 100644 
 index 0000000 . . 4a0980f 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 @ @ - 0 , 0 + 1 , 202 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . metrics ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + 
 + import com . yammer . metrics . Metrics ; 
 + import com . yammer . metrics . core . * ; 
 + import com . yammer . metrics . stats . Snapshot ; 
 + 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + 
 + / * * 
 + * Metrics for { @ link ColumnFamilyStore } . 
 + * / 
 + public class KeyspaceMetrics 
 + { 
 + / * * Total amount of data stored in the memtable , including column related overhead . * / 
 + public final Gauge < Long > memtableDataSize ; 
 + / * * Total amount of data stored in the memtables ( 2i and pending flush memtables included ) . * / 
 + public final Gauge < Long > allMemtablesDataSize ; 
 + / * * Total number of columns present in the memtable . * / 
 + public final Gauge < Long > memtableColumnsCount ; 
 + / * * Number of times flush has resulted in the memtable being switched out . * / 
 + public final Gauge < Long > memtableSwitchCount ; 
 + / * * Estimated number of tasks pending for this column family * / 
 + public final Gauge < Integer > pendingTasks ; 
 + / * * Estimate of number of pending compactios for this CF * / 
 + public final Gauge < Integer > pendingCompactions ; 
 + / * * Disk space used by SSTables belonging to this CF * / 
 + public final Gauge < Long > liveDiskSpaceUsed ; 
 + / * * Total disk space used by SSTables belonging to this CF , including obsolete ones waiting to be GC ' d * / 
 + public final Gauge < Long > totalDiskSpaceUsed ; 
 + / * * Disk space used by bloom filter * / 
 + public final Gauge < Long > bloomFilterDiskSpaceUsed ; 
 + 
 + private final MetricNameFactory factory ; 
 + 
 + / * * 
 + * Creates metrics for given { @ link ColumnFamilyStore } . 
 + * 
 + * @ param ks Keyspace to measure metrics 
 + * / 
 + public KeyspaceMetrics ( final Keyspace ks ) 
 + { 
 + factory = new KeyspaceMetricNameFactory ( ks ) ; 
 + 
 + memtableColumnsCount = Metrics . newGauge ( factory . createMetricName ( " MemtableColumnsCount " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long total = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + total + = cf . metric . memtableColumnsCount . value ( ) ; 
 + } 
 + return total ; 
 + } 
 + } ) ; 
 + memtableDataSize = Metrics . newGauge ( factory . createMetricName ( " MemtableDataSize " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long total = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + total + = cf . metric . memtableDataSize . value ( ) ; 
 + } 
 + return total ; 
 + } 
 + } ) ; 
 + allMemtablesDataSize = Metrics . newGauge ( factory . createMetricName ( " AllMemtablesDataSize " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long total = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + total + = cf . metric . allMemtablesDataSize . value ( ) ; 
 + } 
 + return total ; 
 + } 
 + } ) ; 
 + memtableSwitchCount = Metrics . newGauge ( factory . createMetricName ( " MemtableSwitchCount " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long sum = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + sum + = cf . metric . memtableSwitchCount . count ( ) ; 
 + return sum ; 
 + } 
 + } ) ; 
 + pendingCompactions = Metrics . newGauge ( factory . createMetricName ( " PendingCompactions " ) , new Gauge < Integer > ( ) 
 + { 
 + public Integer value ( ) 
 + { 
 + int sum = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + sum + = cf . metric . pendingCompactions . value ( ) ; 
 + } 
 + return sum ; 
 + } 
 + } ) ; 
 + pendingTasks = Metrics . newGauge ( factory . createMetricName ( " PendingTasks " ) , new Gauge < Integer > ( ) 
 + { 
 + public Integer value ( ) 
 + { 
 + return Keyspace . switchLock . getQueueLength ( ) ; 
 + } 
 + } ) ; 
 + liveDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " LiveDiskSpaceUsed " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long sum = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + sum + = cf . metric . liveDiskSpaceUsed . count ( ) ; 
 + } 
 + return sum ; 
 + } 
 + } ) ; 
 + totalDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " TotalDiskSpaceUsed " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long sum = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + sum + = cf . metric . totalDiskSpaceUsed . count ( ) ; 
 + } 
 + return sum ; 
 + } 
 + } ) ; 
 + bloomFilterDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " BloomFilterDiskSpaceUsed " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long total = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + total + = cf . metric . bloomFilterDiskSpaceUsed . value ( ) ; 
 + return total ; 
 + } 
 + } ) ; 
 + } 
 + 
 + / * * 
 + * Release all associated metrics . 
 + * / 
 + public void release ( ) 
 + { 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " AllMemtablesDataSize " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " MemtableDataSize " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " MemtableSwitchCount " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " PendingTasks " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " LiveDiskSpaceUsed " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " TotalDiskSpaceUsed " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " BloomFilterDiskSpaceUsed " ) ) ; 
 + } 
 + 
 + class KeyspaceMetricNameFactory implements MetricNameFactory 
 + { 
 + private final String keyspaceName ; 
 + 
 + KeyspaceMetricNameFactory ( Keyspace ks ) 
 + { 
 + this . keyspaceName = ks . getName ( ) ; 
 + } 
 + 
 + public MetricName createMetricName ( String metricName ) 
 + { 
 + String groupName = ColumnFamilyMetrics . class . getPackage ( ) . getName ( ) ; 
 + 
 + StringBuilder mbeanName = new StringBuilder ( ) ; 
 + mbeanName . append ( groupName ) . append ( " : " ) ; 
 + mbeanName . append ( " type = Keyspace " ) ; 
 + mbeanName . append ( " , keyspace = " ) . append ( keyspaceName ) ; 
 + mbeanName . append ( " , name = " ) . append ( metricName ) ; 
 + 
 + return new MetricName ( groupName , " keyspace " , metricName , keyspaceName , mbeanName . toString ( ) ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
