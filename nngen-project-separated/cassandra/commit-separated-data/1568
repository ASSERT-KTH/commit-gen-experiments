BLEU SCORE: 0.037477767366779206

TEST MSG: Add tinyint , smallint , time , date support for UDFs
GENERATED MSG: Accept Java source code for user - defined functions

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 47ed221 . . 43a6cc5 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 <nl> + * Add tinyint , smallint , time , date support for UDFs ( CASSANDRA - 9400 ) <nl> * Deprecates SSTableSimpleWriter and SSTableSimpleUnsortedWriter ( CASSANDRA - 9546 ) <nl> * Empty INITCOND treated as null in aggregate ( CASSANDRA - 9457 ) <nl> * Remove use of Cell in Thrift MapReduce classes ( CASSANDRA - 8609 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / ScriptBasedUDF . java b / src / java / org / apache / cassandra / cql3 / functions / ScriptBasedUDF . java <nl> index 319c948 . . 4d9a79f 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / ScriptBasedUDF . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / ScriptBasedUDF . java <nl> @ @ - 114 , 6 + 114 , 10 @ @ public class ScriptBasedUDF extends UDFunction <nl> Number rNumber = ( Number ) result ; <nl> if ( javaReturnType = = Integer . class ) <nl> result = rNumber . intValue ( ) ; <nl> + else if ( javaReturnType = = Short . class ) <nl> + result = rNumber . shortValue ( ) ; <nl> + else if ( javaReturnType = = Byte . class ) <nl> + result = rNumber . byteValue ( ) ; <nl> else if ( javaReturnType = = Long . class ) <nl> result = rNumber . longValue ( ) ; <nl> else if ( javaReturnType = = Float . class ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java b / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java <nl> index 0bf6078 . . aa6d555 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java <nl> @ @ - 212 , 6 + 212 , 20 @ @ public abstract class UDFunction extends AbstractFunction implements ScalarFunct <nl> } <nl> <nl> / / do not remove - used by generated Java UDFs <nl> + protected byte compose _ byte ( int protocolVersion , int argIndex , ByteBuffer value ) <nl> + { <nl> + assert value ! = null & & value . remaining ( ) > 0 ; <nl> + return ( byte ) DataType . tinyint ( ) . deserialize ( value , ProtocolVersion . fromInt ( protocolVersion ) ) ; <nl> + } <nl> + <nl> + / / do not remove - used by generated Java UDFs <nl> + protected short compose _ short ( int protocolVersion , int argIndex , ByteBuffer value ) <nl> + { <nl> + assert value ! = null & & value . remaining ( ) > 0 ; <nl> + return ( short ) DataType . smallint ( ) . deserialize ( value , ProtocolVersion . fromInt ( protocolVersion ) ) ; <nl> + } <nl> + <nl> + / / do not remove - used by generated Java UDFs <nl> protected int compose _ int ( int protocolVersion , int argIndex , ByteBuffer value ) <nl> { <nl> assert value ! = null & & value . remaining ( ) > 0 ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / UFTest . java b / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> index f041b3a . . db94a4c 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import java . util . Map ; <nl> import java . util . Set ; <nl> import java . util . TreeMap ; <nl> import java . util . TreeSet ; <nl> + import java . util . UUID ; <nl> <nl> import org . junit . Assert ; <nl> import org . junit . Test ; <nl> @ @ - 44 , 6 + 45 , 7 @ @ import org . apache . cassandra . transport . Event ; <nl> import org . apache . cassandra . transport . Server ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . UUIDGen ; <nl> <nl> public class UFTest extends CQLTester <nl> { <nl> @ @ - 1872 , 6 + 1874 , 10 @ @ public class UFTest extends CQLTester <nl> Object [ ] [ ] variations = { <nl> new Object [ ] { " true " , " boolean " , true } , <nl> new Object [ ] { " false " , " boolean " , false } , <nl> + new Object [ ] { " 100 " , " tinyint " , ( byte ) 100 } , <nl> + new Object [ ] { " 100 . " , " tinyint " , ( byte ) 100 } , <nl> + new Object [ ] { " 100 " , " smallint " , ( short ) 100 } , <nl> + new Object [ ] { " 100 . " , " smallint " , ( short ) 100 } , <nl> new Object [ ] { " 100 " , " int " , 100 } , <nl> new Object [ ] { " 100 . " , " int " , 100 } , <nl> new Object [ ] { " 100 " , " double " , 100d } , <nl> @ @ - 1904 , 17 + 1910 , 26 @ @ public class UFTest extends CQLTester <nl> @ Test <nl> public void testScriptParamReturnTypes ( ) throws Throwable <nl> { <nl> - createTable ( " CREATE TABLE % s ( key int primary key , ival int , lval bigint , fval float , dval double , vval varint , ddval decimal ) " ) ; <nl> - execute ( " INSERT INTO % s ( key , ival , lval , fval , dval , vval , ddval ) VALUES ( ? , ? , ? , ? , ? , ? , ? ) " , 1 , <nl> - 1 , 1L , 1f , 1d , BigInteger . valueOf ( 1L ) , BigDecimal . valueOf ( 1d ) ) ; <nl> + UUID ruuid = UUID . randomUUID ( ) ; <nl> + UUID tuuid = UUIDGen . getTimeUUID ( ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( key int primary key , " + <nl> + " tival tinyint , sival smallint , ival int , lval bigint , fval float , dval double , vval varint , ddval decimal , " + <nl> + " timval time , dtval date , tsval timestamp , uval uuid , tuval timeuuid ) " ) ; <nl> + execute ( " INSERT INTO % s ( key , tival , sival , ival , lval , fval , dval , vval , ddval , timval , dtval , tsval , uval , tuval ) VALUES " + <nl> + " ( ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? ) " , 1 , <nl> + ( byte ) 1 , ( short ) 1 , 1 , 1L , 1f , 1d , BigInteger . valueOf ( 1L ) , BigDecimal . valueOf ( 1d ) , 1L , Integer . MAX _ VALUE , new Date ( 1 ) , ruuid , tuuid ) ; <nl> <nl> Object [ ] [ ] variations = { <nl> + new Object [ ] { " tinyint " , " tival " , ( byte ) 1 , ( byte ) 2 } , <nl> + new Object [ ] { " smallint " , " sival " , ( short ) 1 , ( short ) 2 } , <nl> new Object [ ] { " int " , " ival " , 1 , 2 } , <nl> new Object [ ] { " bigint " , " lval " , 1L , 2L } , <nl> new Object [ ] { " float " , " fval " , 1f , 2f } , <nl> new Object [ ] { " double " , " dval " , 1d , 2d } , <nl> new Object [ ] { " varint " , " vval " , BigInteger . valueOf ( 1L ) , BigInteger . valueOf ( 2L ) } , <nl> new Object [ ] { " decimal " , " ddval " , BigDecimal . valueOf ( 1d ) , BigDecimal . valueOf ( 2d ) } , <nl> + new Object [ ] { " time " , " timval " , 1L , 2L } , <nl> } ; <nl> <nl> for ( Object [ ] variation : variations ) <nl> @ @ - 1932 , 81 + 1947 , 162 @ @ public class UFTest extends CQLTester <nl> assertRows ( execute ( " SELECT key , " + col + " , " + fName + ' ( ' + col + " ) FROM % s " ) , <nl> row ( 1 , expected1 , expected2 ) ) ; <nl> } <nl> + <nl> + variations = new Object [ ] [ ] { <nl> + new Object [ ] { " timestamp " , " tsval " , new Date ( 1 ) , new Date ( 1 ) } , <nl> + new Object [ ] { " uuid " , " uval " , ruuid , ruuid } , <nl> + new Object [ ] { " timeuuid " , " tuval " , tuuid , tuuid } , <nl> + new Object [ ] { " date " , " dtval " , Integer . MAX _ VALUE , Integer . MAX _ VALUE } , <nl> + } ; <nl> + <nl> + for ( Object [ ] variation : variations ) <nl> + { <nl> + Object type = variation [ 0 ] ; <nl> + Object col = variation [ 1 ] ; <nl> + Object expected1 = variation [ 2 ] ; <nl> + Object expected2 = variation [ 3 ] ; <nl> + String fName = createFunction ( KEYSPACE , type . toString ( ) , <nl> + " CREATE OR REPLACE FUNCTION % s ( val " + type + " ) " + <nl> + " RETURNS NULL ON NULL INPUT " + <nl> + " RETURNS " + type + ' ' + <nl> + " LANGUAGE javascript " + <nl> + " AS ' val ; ' ; " ) ; <nl> + assertRows ( execute ( " SELECT key , " + col + " , " + fName + ' ( ' + col + " ) FROM % s " ) , <nl> + row ( 1 , expected1 , expected2 ) ) ; <nl> + } <nl> + } <nl> + <nl> + static class TypesTestDef <nl> + { <nl> + final String udfType ; <nl> + final String tableType ; <nl> + final String columnName ; <nl> + final Object referenceValue ; <nl> + <nl> + String fCheckArgAndReturn ; <nl> + <nl> + String fCalledOnNull ; <nl> + String fReturnsNullOnNull ; <nl> + <nl> + TypesTestDef ( String udfType , String tableType , String columnName , Object referenceValue ) <nl> + { <nl> + this . udfType = udfType ; <nl> + this . tableType = tableType ; <nl> + this . columnName = columnName ; <nl> + this . referenceValue = referenceValue ; <nl> + } <nl> } <nl> <nl> @ Test <nl> - public void testNullOnReturnsNullOnNullInput ( ) throws Throwable <nl> + public void testTypesWithAndWithoutNulls ( ) throws Throwable <nl> { <nl> + / / test various combinations of types against UDFs with CALLED ON NULL or RETURNS NULL ON NULL <nl> + <nl> String type = createType ( " CREATE TYPE % s ( txt text , i int ) " ) ; <nl> - createTable ( " CREATE TABLE % s ( key int PRIMARY KEY , i int , b bigint , f float , d double , x boolean , t text , u frozen < " + type + " > , tup frozen < tuple < int , text > > ) " ) ; <nl> - <nl> - execute ( " INSERT INTO % s ( key , i , b , f , d , x , t , u , tup ) VALUES ( 1 , null , null , null , null , null , null , null , null ) " ) ; <nl> - <nl> - String fI = createFunction ( KEYSPACE , <nl> - " int " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val int ) " + <nl> - " RETURNS NULL ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fB = createFunction ( KEYSPACE , <nl> - " bigint " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val bigint ) " + <nl> - " RETURNS NULL ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fF = createFunction ( KEYSPACE , <nl> - " float " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val float ) " + <nl> - " RETURNS NULL ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fD = createFunction ( KEYSPACE , <nl> - " double " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val double ) " + <nl> - " RETURNS NULL ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fX = createFunction ( KEYSPACE , <nl> - " boolean " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val boolean ) " + <nl> - " RETURNS NULL ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fT = createFunction ( KEYSPACE , <nl> - " text " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val text ) " + <nl> - " RETURNS NULL ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fU = createFunction ( KEYSPACE , <nl> - type , <nl> - " CREATE OR REPLACE FUNCTION % s ( val " + type + " ) " + <nl> - " RETURNS NULL ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fTup = createFunction ( KEYSPACE , <nl> - " tuple < int , text > " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val tuple < int , text > ) " + <nl> - " RETURNS NULL ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - <nl> - assertRows ( execute ( " SELECT " + fI + " ( i ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; <nl> - assertRows ( execute ( " SELECT " + fB + " ( b ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; <nl> - assertRows ( execute ( " SELECT " + fF + " ( f ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; <nl> - assertRows ( execute ( " SELECT " + fD + " ( d ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; <nl> - assertRows ( execute ( " SELECT " + fX + " ( x ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; <nl> - assertRows ( execute ( " SELECT " + fT + " ( t ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; <nl> - assertRows ( execute ( " SELECT " + fU + " ( u ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; <nl> - assertRows ( execute ( " SELECT " + fTup + " ( tup ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; <nl> + <nl> + TypesTestDef [ ] typeDefs = <nl> + { <nl> + / / udf type , table type , column , reference value <nl> + new TypesTestDef ( " timestamp " , " timestamp " , " ts " , new Date ( ) ) , <nl> + new TypesTestDef ( " date " , " date " , " dt " , 12345 ) , <nl> + new TypesTestDef ( " time " , " time " , " tim " , 12345L ) , <nl> + new TypesTestDef ( " uuid " , " uuid " , " uu " , UUID . randomUUID ( ) ) , <nl> + new TypesTestDef ( " timeuuid " , " timeuuid " , " tu " , UUIDGen . getTimeUUID ( ) ) , <nl> + new TypesTestDef ( " tinyint " , " tinyint " , " ti " , ( byte ) 42 ) , <nl> + new TypesTestDef ( " smallint " , " smallint " , " si " , ( short ) 43 ) , <nl> + new TypesTestDef ( " int " , " int " , " i " , 44 ) , <nl> + new TypesTestDef ( " bigint " , " bigint " , " b " , 45L ) , <nl> + new TypesTestDef ( " float " , " float " , " f " , 46f ) , <nl> + new TypesTestDef ( " double " , " double " , " d " , 47d ) , <nl> + new TypesTestDef ( " boolean " , " boolean " , " x " , true ) , <nl> + new TypesTestDef ( " ascii " , " ascii " , " a " , " tqbfjutld " ) , <nl> + new TypesTestDef ( " text " , " text " , " t " , " k \ u00f6lsche jung " ) , <nl> + / / new TypesTestDef ( type , " frozen < " + type + ' > ' , " u " , null ) , <nl> + new TypesTestDef ( " tuple < int , text > " , " frozen < tuple < int , text > > " , " tup " , tuple ( 1 , " foo " ) ) <nl> + } ; <nl> + <nl> + String createTableDDL = " CREATE TABLE % s ( key int PRIMARY KEY " ; <nl> + String insertDML = " INSERT INTO % s ( key " ; <nl> + List < Object > values = new ArrayList < > ( ) ; <nl> + for ( TypesTestDef typeDef : typeDefs ) <nl> + { <nl> + createTableDDL + = " , " + typeDef . columnName + ' ' + typeDef . tableType ; <nl> + insertDML + = " , " + typeDef . columnName ; <nl> + String typeName = typeDef . udfType ; <nl> + typeDef . fCheckArgAndReturn = createFunction ( KEYSPACE , <nl> + typeName , <nl> + " CREATE OR REPLACE FUNCTION % s ( val " + typeName + " ) " + <nl> + " CALLED ON NULL INPUT " + <nl> + " RETURNS " + typeName + ' ' + <nl> + " LANGUAGE java \ n " + <nl> + " AS ' return val ; ' ; " ) ; <nl> + typeDef . fCalledOnNull = createFunction ( KEYSPACE , <nl> + typeName , <nl> + " CREATE OR REPLACE FUNCTION % s ( val " + typeName + " ) " + <nl> + " CALLED ON NULL INPUT " + <nl> + " RETURNS text " + <nl> + " LANGUAGE java \ n " + <nl> + " AS ' return \ " called \ " ; ' ; " ) ; <nl> + typeDef . fReturnsNullOnNull = createFunction ( KEYSPACE , <nl> + typeName , <nl> + " CREATE OR REPLACE FUNCTION % s ( val " + typeName + " ) " + <nl> + " RETURNS NULL ON NULL INPUT " + <nl> + " RETURNS text " + <nl> + " LANGUAGE java \ n " + <nl> + " AS ' return \ " called \ " ; ' ; " ) ; <nl> + values . add ( typeDef . referenceValue ) ; <nl> + } <nl> + <nl> + createTableDDL + = ' ) ' ; <nl> + createTable ( createTableDDL ) ; <nl> + <nl> + insertDML + = " ) VALUES ( 1 " ; <nl> + for ( TypesTestDef ignored : typeDefs ) <nl> + insertDML + = " , ? " ; <nl> + insertDML + = ' ) ' ; <nl> + <nl> + execute ( insertDML , values . toArray ( ) ) ; <nl> + <nl> + / / second row with null values <nl> + for ( int i = 0 ; i < values . size ( ) ; i + + ) <nl> + values . set ( i , null ) ; <nl> + execute ( insertDML . replace ( ' 1 ' , ' 2 ' ) , values . toArray ( ) ) ; <nl> + <nl> + / / check argument input + return <nl> + for ( TypesTestDef typeDef : typeDefs ) <nl> + { <nl> + assertRows ( execute ( " SELECT " + typeDef . fCheckArgAndReturn + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 1 " ) , <nl> + row ( new Object [ ] { typeDef . referenceValue } ) ) ; <nl> + } <nl> + <nl> + / / check for CALLED ON NULL INPUT with non - null arguments <nl> + for ( TypesTestDef typeDef : typeDefs ) <nl> + { <nl> + assertRows ( execute ( " SELECT " + typeDef . fCalledOnNull + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 1 " ) , <nl> + row ( new Object [ ] { " called " } ) ) ; <nl> + } <nl> + <nl> + / / check for CALLED ON NULL INPUT with null arguments <nl> + for ( TypesTestDef typeDef : typeDefs ) <nl> + { <nl> + assertRows ( execute ( " SELECT " + typeDef . fCalledOnNull + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 2 " ) , <nl> + row ( new Object [ ] { " called " } ) ) ; <nl> + } <nl> + <nl> + / / check for RETURNS NULL ON NULL INPUT with non - null arguments <nl> + for ( TypesTestDef typeDef : typeDefs ) <nl> + { <nl> + assertRows ( execute ( " SELECT " + typeDef . fReturnsNullOnNull + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 1 " ) , <nl> + row ( new Object [ ] { " called " } ) ) ; <nl> + } <nl> + <nl> + / / check for RETURNS NULL ON NULL INPUT with null arguments <nl> + for ( TypesTestDef typeDef : typeDefs ) <nl> + { <nl> + assertRows ( execute ( " SELECT " + typeDef . fReturnsNullOnNull + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 2 " ) , <nl> + row ( new Object [ ] { null } ) ) ; <nl> + } <nl> + <nl> } <nl> <nl> @ Test <nl> @ @ - 2051 , 81 + 2147 , 6 @ @ public class UFTest extends CQLTester <nl> } <nl> <nl> @ Test <nl> - public void testNullOnCalledOnNullInput ( ) throws Throwable <nl> - { <nl> - String type = createType ( " CREATE TYPE % s ( txt text , i int ) " ) ; <nl> - createTable ( " CREATE TABLE % s ( key int PRIMARY KEY , i int , b bigint , f float , d double , x boolean , t text , u frozen < " + type + " > , tup frozen < tuple < int , text > > ) " ) ; <nl> - <nl> - execute ( " INSERT INTO % s ( key , i , b , f , d , x , t , u , tup ) VALUES ( 1 , null , null , null , null , null , null , null , null ) " ) ; <nl> - <nl> - String fI = createFunction ( KEYSPACE , <nl> - " int " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val int ) " + <nl> - " CALLED ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fB = createFunction ( KEYSPACE , <nl> - " bigint " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val bigint ) " + <nl> - " CALLED ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fF = createFunction ( KEYSPACE , <nl> - " float " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val float ) " + <nl> - " CALLED ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fD = createFunction ( KEYSPACE , <nl> - " double " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val double ) " + <nl> - " CALLED ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fX = createFunction ( KEYSPACE , <nl> - " boolean " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val boolean ) " + <nl> - " CALLED ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fT = createFunction ( KEYSPACE , <nl> - " text " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val text ) " + <nl> - " CALLED ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fU = createFunction ( KEYSPACE , <nl> - type , <nl> - " CREATE OR REPLACE FUNCTION % s ( val " + type + " ) " + <nl> - " CALLED ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - String fTup = createFunction ( KEYSPACE , <nl> - " tuple < int , text > " , <nl> - " CREATE OR REPLACE FUNCTION % s ( val tuple < int , text > ) " + <nl> - " CALLED ON NULL INPUT " + <nl> - " RETURNS text " + <nl> - " LANGUAGE java \ n " + <nl> - " AS ' return \ " foo bar \ " ; ' ; " ) ; <nl> - <nl> - assertRows ( execute ( " SELECT " + fI + " ( i ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; <nl> - assertRows ( execute ( " SELECT " + fB + " ( b ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; <nl> - assertRows ( execute ( " SELECT " + fF + " ( f ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; <nl> - assertRows ( execute ( " SELECT " + fD + " ( d ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; <nl> - assertRows ( execute ( " SELECT " + fX + " ( x ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; <nl> - assertRows ( execute ( " SELECT " + fT + " ( t ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; <nl> - assertRows ( execute ( " SELECT " + fU + " ( u ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; <nl> - assertRows ( execute ( " SELECT " + fTup + " ( tup ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> public void testBrokenFunction ( ) throws Throwable <nl> { <nl> createTable ( " CREATE TABLE % s ( key int primary key , dval double ) " ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 47ed221 . . 43a6cc5 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 
 + * Add tinyint , smallint , time , date support for UDFs ( CASSANDRA - 9400 ) 
 * Deprecates SSTableSimpleWriter and SSTableSimpleUnsortedWriter ( CASSANDRA - 9546 ) 
 * Empty INITCOND treated as null in aggregate ( CASSANDRA - 9457 ) 
 * Remove use of Cell in Thrift MapReduce classes ( CASSANDRA - 8609 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / ScriptBasedUDF . java b / src / java / org / apache / cassandra / cql3 / functions / ScriptBasedUDF . java 
 index 319c948 . . 4d9a79f 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / ScriptBasedUDF . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / ScriptBasedUDF . java 
 @ @ - 114 , 6 + 114 , 10 @ @ public class ScriptBasedUDF extends UDFunction 
 Number rNumber = ( Number ) result ; 
 if ( javaReturnType = = Integer . class ) 
 result = rNumber . intValue ( ) ; 
 + else if ( javaReturnType = = Short . class ) 
 + result = rNumber . shortValue ( ) ; 
 + else if ( javaReturnType = = Byte . class ) 
 + result = rNumber . byteValue ( ) ; 
 else if ( javaReturnType = = Long . class ) 
 result = rNumber . longValue ( ) ; 
 else if ( javaReturnType = = Float . class ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java b / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java 
 index 0bf6078 . . aa6d555 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java 
 @ @ - 212 , 6 + 212 , 20 @ @ public abstract class UDFunction extends AbstractFunction implements ScalarFunct 
 } 
 
 / / do not remove - used by generated Java UDFs 
 + protected byte compose _ byte ( int protocolVersion , int argIndex , ByteBuffer value ) 
 + { 
 + assert value ! = null & & value . remaining ( ) > 0 ; 
 + return ( byte ) DataType . tinyint ( ) . deserialize ( value , ProtocolVersion . fromInt ( protocolVersion ) ) ; 
 + } 
 + 
 + / / do not remove - used by generated Java UDFs 
 + protected short compose _ short ( int protocolVersion , int argIndex , ByteBuffer value ) 
 + { 
 + assert value ! = null & & value . remaining ( ) > 0 ; 
 + return ( short ) DataType . smallint ( ) . deserialize ( value , ProtocolVersion . fromInt ( protocolVersion ) ) ; 
 + } 
 + 
 + / / do not remove - used by generated Java UDFs 
 protected int compose _ int ( int protocolVersion , int argIndex , ByteBuffer value ) 
 { 
 assert value ! = null & & value . remaining ( ) > 0 ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / UFTest . java b / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 index f041b3a . . db94a4c 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import java . util . Map ; 
 import java . util . Set ; 
 import java . util . TreeMap ; 
 import java . util . TreeSet ; 
 + import java . util . UUID ; 
 
 import org . junit . Assert ; 
 import org . junit . Test ; 
 @ @ - 44 , 6 + 45 , 7 @ @ import org . apache . cassandra . transport . Event ; 
 import org . apache . cassandra . transport . Server ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . UUIDGen ; 
 
 public class UFTest extends CQLTester 
 { 
 @ @ - 1872 , 6 + 1874 , 10 @ @ public class UFTest extends CQLTester 
 Object [ ] [ ] variations = { 
 new Object [ ] { " true " , " boolean " , true } , 
 new Object [ ] { " false " , " boolean " , false } , 
 + new Object [ ] { " 100 " , " tinyint " , ( byte ) 100 } , 
 + new Object [ ] { " 100 . " , " tinyint " , ( byte ) 100 } , 
 + new Object [ ] { " 100 " , " smallint " , ( short ) 100 } , 
 + new Object [ ] { " 100 . " , " smallint " , ( short ) 100 } , 
 new Object [ ] { " 100 " , " int " , 100 } , 
 new Object [ ] { " 100 . " , " int " , 100 } , 
 new Object [ ] { " 100 " , " double " , 100d } , 
 @ @ - 1904 , 17 + 1910 , 26 @ @ public class UFTest extends CQLTester 
 @ Test 
 public void testScriptParamReturnTypes ( ) throws Throwable 
 { 
 - createTable ( " CREATE TABLE % s ( key int primary key , ival int , lval bigint , fval float , dval double , vval varint , ddval decimal ) " ) ; 
 - execute ( " INSERT INTO % s ( key , ival , lval , fval , dval , vval , ddval ) VALUES ( ? , ? , ? , ? , ? , ? , ? ) " , 1 , 
 - 1 , 1L , 1f , 1d , BigInteger . valueOf ( 1L ) , BigDecimal . valueOf ( 1d ) ) ; 
 + UUID ruuid = UUID . randomUUID ( ) ; 
 + UUID tuuid = UUIDGen . getTimeUUID ( ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( key int primary key , " + 
 + " tival tinyint , sival smallint , ival int , lval bigint , fval float , dval double , vval varint , ddval decimal , " + 
 + " timval time , dtval date , tsval timestamp , uval uuid , tuval timeuuid ) " ) ; 
 + execute ( " INSERT INTO % s ( key , tival , sival , ival , lval , fval , dval , vval , ddval , timval , dtval , tsval , uval , tuval ) VALUES " + 
 + " ( ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? ) " , 1 , 
 + ( byte ) 1 , ( short ) 1 , 1 , 1L , 1f , 1d , BigInteger . valueOf ( 1L ) , BigDecimal . valueOf ( 1d ) , 1L , Integer . MAX _ VALUE , new Date ( 1 ) , ruuid , tuuid ) ; 
 
 Object [ ] [ ] variations = { 
 + new Object [ ] { " tinyint " , " tival " , ( byte ) 1 , ( byte ) 2 } , 
 + new Object [ ] { " smallint " , " sival " , ( short ) 1 , ( short ) 2 } , 
 new Object [ ] { " int " , " ival " , 1 , 2 } , 
 new Object [ ] { " bigint " , " lval " , 1L , 2L } , 
 new Object [ ] { " float " , " fval " , 1f , 2f } , 
 new Object [ ] { " double " , " dval " , 1d , 2d } , 
 new Object [ ] { " varint " , " vval " , BigInteger . valueOf ( 1L ) , BigInteger . valueOf ( 2L ) } , 
 new Object [ ] { " decimal " , " ddval " , BigDecimal . valueOf ( 1d ) , BigDecimal . valueOf ( 2d ) } , 
 + new Object [ ] { " time " , " timval " , 1L , 2L } , 
 } ; 
 
 for ( Object [ ] variation : variations ) 
 @ @ - 1932 , 81 + 1947 , 162 @ @ public class UFTest extends CQLTester 
 assertRows ( execute ( " SELECT key , " + col + " , " + fName + ' ( ' + col + " ) FROM % s " ) , 
 row ( 1 , expected1 , expected2 ) ) ; 
 } 
 + 
 + variations = new Object [ ] [ ] { 
 + new Object [ ] { " timestamp " , " tsval " , new Date ( 1 ) , new Date ( 1 ) } , 
 + new Object [ ] { " uuid " , " uval " , ruuid , ruuid } , 
 + new Object [ ] { " timeuuid " , " tuval " , tuuid , tuuid } , 
 + new Object [ ] { " date " , " dtval " , Integer . MAX _ VALUE , Integer . MAX _ VALUE } , 
 + } ; 
 + 
 + for ( Object [ ] variation : variations ) 
 + { 
 + Object type = variation [ 0 ] ; 
 + Object col = variation [ 1 ] ; 
 + Object expected1 = variation [ 2 ] ; 
 + Object expected2 = variation [ 3 ] ; 
 + String fName = createFunction ( KEYSPACE , type . toString ( ) , 
 + " CREATE OR REPLACE FUNCTION % s ( val " + type + " ) " + 
 + " RETURNS NULL ON NULL INPUT " + 
 + " RETURNS " + type + ' ' + 
 + " LANGUAGE javascript " + 
 + " AS ' val ; ' ; " ) ; 
 + assertRows ( execute ( " SELECT key , " + col + " , " + fName + ' ( ' + col + " ) FROM % s " ) , 
 + row ( 1 , expected1 , expected2 ) ) ; 
 + } 
 + } 
 + 
 + static class TypesTestDef 
 + { 
 + final String udfType ; 
 + final String tableType ; 
 + final String columnName ; 
 + final Object referenceValue ; 
 + 
 + String fCheckArgAndReturn ; 
 + 
 + String fCalledOnNull ; 
 + String fReturnsNullOnNull ; 
 + 
 + TypesTestDef ( String udfType , String tableType , String columnName , Object referenceValue ) 
 + { 
 + this . udfType = udfType ; 
 + this . tableType = tableType ; 
 + this . columnName = columnName ; 
 + this . referenceValue = referenceValue ; 
 + } 
 } 
 
 @ Test 
 - public void testNullOnReturnsNullOnNullInput ( ) throws Throwable 
 + public void testTypesWithAndWithoutNulls ( ) throws Throwable 
 { 
 + / / test various combinations of types against UDFs with CALLED ON NULL or RETURNS NULL ON NULL 
 + 
 String type = createType ( " CREATE TYPE % s ( txt text , i int ) " ) ; 
 - createTable ( " CREATE TABLE % s ( key int PRIMARY KEY , i int , b bigint , f float , d double , x boolean , t text , u frozen < " + type + " > , tup frozen < tuple < int , text > > ) " ) ; 
 - 
 - execute ( " INSERT INTO % s ( key , i , b , f , d , x , t , u , tup ) VALUES ( 1 , null , null , null , null , null , null , null , null ) " ) ; 
 - 
 - String fI = createFunction ( KEYSPACE , 
 - " int " , 
 - " CREATE OR REPLACE FUNCTION % s ( val int ) " + 
 - " RETURNS NULL ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fB = createFunction ( KEYSPACE , 
 - " bigint " , 
 - " CREATE OR REPLACE FUNCTION % s ( val bigint ) " + 
 - " RETURNS NULL ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fF = createFunction ( KEYSPACE , 
 - " float " , 
 - " CREATE OR REPLACE FUNCTION % s ( val float ) " + 
 - " RETURNS NULL ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fD = createFunction ( KEYSPACE , 
 - " double " , 
 - " CREATE OR REPLACE FUNCTION % s ( val double ) " + 
 - " RETURNS NULL ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fX = createFunction ( KEYSPACE , 
 - " boolean " , 
 - " CREATE OR REPLACE FUNCTION % s ( val boolean ) " + 
 - " RETURNS NULL ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fT = createFunction ( KEYSPACE , 
 - " text " , 
 - " CREATE OR REPLACE FUNCTION % s ( val text ) " + 
 - " RETURNS NULL ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fU = createFunction ( KEYSPACE , 
 - type , 
 - " CREATE OR REPLACE FUNCTION % s ( val " + type + " ) " + 
 - " RETURNS NULL ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fTup = createFunction ( KEYSPACE , 
 - " tuple < int , text > " , 
 - " CREATE OR REPLACE FUNCTION % s ( val tuple < int , text > ) " + 
 - " RETURNS NULL ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - 
 - assertRows ( execute ( " SELECT " + fI + " ( i ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; 
 - assertRows ( execute ( " SELECT " + fB + " ( b ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; 
 - assertRows ( execute ( " SELECT " + fF + " ( f ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; 
 - assertRows ( execute ( " SELECT " + fD + " ( d ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; 
 - assertRows ( execute ( " SELECT " + fX + " ( x ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; 
 - assertRows ( execute ( " SELECT " + fT + " ( t ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; 
 - assertRows ( execute ( " SELECT " + fU + " ( u ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; 
 - assertRows ( execute ( " SELECT " + fTup + " ( tup ) FROM % s WHERE key = 1 " ) , row ( new Object [ ] { null } ) ) ; 
 + 
 + TypesTestDef [ ] typeDefs = 
 + { 
 + / / udf type , table type , column , reference value 
 + new TypesTestDef ( " timestamp " , " timestamp " , " ts " , new Date ( ) ) , 
 + new TypesTestDef ( " date " , " date " , " dt " , 12345 ) , 
 + new TypesTestDef ( " time " , " time " , " tim " , 12345L ) , 
 + new TypesTestDef ( " uuid " , " uuid " , " uu " , UUID . randomUUID ( ) ) , 
 + new TypesTestDef ( " timeuuid " , " timeuuid " , " tu " , UUIDGen . getTimeUUID ( ) ) , 
 + new TypesTestDef ( " tinyint " , " tinyint " , " ti " , ( byte ) 42 ) , 
 + new TypesTestDef ( " smallint " , " smallint " , " si " , ( short ) 43 ) , 
 + new TypesTestDef ( " int " , " int " , " i " , 44 ) , 
 + new TypesTestDef ( " bigint " , " bigint " , " b " , 45L ) , 
 + new TypesTestDef ( " float " , " float " , " f " , 46f ) , 
 + new TypesTestDef ( " double " , " double " , " d " , 47d ) , 
 + new TypesTestDef ( " boolean " , " boolean " , " x " , true ) , 
 + new TypesTestDef ( " ascii " , " ascii " , " a " , " tqbfjutld " ) , 
 + new TypesTestDef ( " text " , " text " , " t " , " k \ u00f6lsche jung " ) , 
 + / / new TypesTestDef ( type , " frozen < " + type + ' > ' , " u " , null ) , 
 + new TypesTestDef ( " tuple < int , text > " , " frozen < tuple < int , text > > " , " tup " , tuple ( 1 , " foo " ) ) 
 + } ; 
 + 
 + String createTableDDL = " CREATE TABLE % s ( key int PRIMARY KEY " ; 
 + String insertDML = " INSERT INTO % s ( key " ; 
 + List < Object > values = new ArrayList < > ( ) ; 
 + for ( TypesTestDef typeDef : typeDefs ) 
 + { 
 + createTableDDL + = " , " + typeDef . columnName + ' ' + typeDef . tableType ; 
 + insertDML + = " , " + typeDef . columnName ; 
 + String typeName = typeDef . udfType ; 
 + typeDef . fCheckArgAndReturn = createFunction ( KEYSPACE , 
 + typeName , 
 + " CREATE OR REPLACE FUNCTION % s ( val " + typeName + " ) " + 
 + " CALLED ON NULL INPUT " + 
 + " RETURNS " + typeName + ' ' + 
 + " LANGUAGE java \ n " + 
 + " AS ' return val ; ' ; " ) ; 
 + typeDef . fCalledOnNull = createFunction ( KEYSPACE , 
 + typeName , 
 + " CREATE OR REPLACE FUNCTION % s ( val " + typeName + " ) " + 
 + " CALLED ON NULL INPUT " + 
 + " RETURNS text " + 
 + " LANGUAGE java \ n " + 
 + " AS ' return \ " called \ " ; ' ; " ) ; 
 + typeDef . fReturnsNullOnNull = createFunction ( KEYSPACE , 
 + typeName , 
 + " CREATE OR REPLACE FUNCTION % s ( val " + typeName + " ) " + 
 + " RETURNS NULL ON NULL INPUT " + 
 + " RETURNS text " + 
 + " LANGUAGE java \ n " + 
 + " AS ' return \ " called \ " ; ' ; " ) ; 
 + values . add ( typeDef . referenceValue ) ; 
 + } 
 + 
 + createTableDDL + = ' ) ' ; 
 + createTable ( createTableDDL ) ; 
 + 
 + insertDML + = " ) VALUES ( 1 " ; 
 + for ( TypesTestDef ignored : typeDefs ) 
 + insertDML + = " , ? " ; 
 + insertDML + = ' ) ' ; 
 + 
 + execute ( insertDML , values . toArray ( ) ) ; 
 + 
 + / / second row with null values 
 + for ( int i = 0 ; i < values . size ( ) ; i + + ) 
 + values . set ( i , null ) ; 
 + execute ( insertDML . replace ( ' 1 ' , ' 2 ' ) , values . toArray ( ) ) ; 
 + 
 + / / check argument input + return 
 + for ( TypesTestDef typeDef : typeDefs ) 
 + { 
 + assertRows ( execute ( " SELECT " + typeDef . fCheckArgAndReturn + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 1 " ) , 
 + row ( new Object [ ] { typeDef . referenceValue } ) ) ; 
 + } 
 + 
 + / / check for CALLED ON NULL INPUT with non - null arguments 
 + for ( TypesTestDef typeDef : typeDefs ) 
 + { 
 + assertRows ( execute ( " SELECT " + typeDef . fCalledOnNull + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 1 " ) , 
 + row ( new Object [ ] { " called " } ) ) ; 
 + } 
 + 
 + / / check for CALLED ON NULL INPUT with null arguments 
 + for ( TypesTestDef typeDef : typeDefs ) 
 + { 
 + assertRows ( execute ( " SELECT " + typeDef . fCalledOnNull + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 2 " ) , 
 + row ( new Object [ ] { " called " } ) ) ; 
 + } 
 + 
 + / / check for RETURNS NULL ON NULL INPUT with non - null arguments 
 + for ( TypesTestDef typeDef : typeDefs ) 
 + { 
 + assertRows ( execute ( " SELECT " + typeDef . fReturnsNullOnNull + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 1 " ) , 
 + row ( new Object [ ] { " called " } ) ) ; 
 + } 
 + 
 + / / check for RETURNS NULL ON NULL INPUT with null arguments 
 + for ( TypesTestDef typeDef : typeDefs ) 
 + { 
 + assertRows ( execute ( " SELECT " + typeDef . fReturnsNullOnNull + ' ( ' + typeDef . columnName + " ) FROM % s WHERE key = 2 " ) , 
 + row ( new Object [ ] { null } ) ) ; 
 + } 
 + 
 } 
 
 @ Test 
 @ @ - 2051 , 81 + 2147 , 6 @ @ public class UFTest extends CQLTester 
 } 
 
 @ Test 
 - public void testNullOnCalledOnNullInput ( ) throws Throwable 
 - { 
 - String type = createType ( " CREATE TYPE % s ( txt text , i int ) " ) ; 
 - createTable ( " CREATE TABLE % s ( key int PRIMARY KEY , i int , b bigint , f float , d double , x boolean , t text , u frozen < " + type + " > , tup frozen < tuple < int , text > > ) " ) ; 
 - 
 - execute ( " INSERT INTO % s ( key , i , b , f , d , x , t , u , tup ) VALUES ( 1 , null , null , null , null , null , null , null , null ) " ) ; 
 - 
 - String fI = createFunction ( KEYSPACE , 
 - " int " , 
 - " CREATE OR REPLACE FUNCTION % s ( val int ) " + 
 - " CALLED ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fB = createFunction ( KEYSPACE , 
 - " bigint " , 
 - " CREATE OR REPLACE FUNCTION % s ( val bigint ) " + 
 - " CALLED ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fF = createFunction ( KEYSPACE , 
 - " float " , 
 - " CREATE OR REPLACE FUNCTION % s ( val float ) " + 
 - " CALLED ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fD = createFunction ( KEYSPACE , 
 - " double " , 
 - " CREATE OR REPLACE FUNCTION % s ( val double ) " + 
 - " CALLED ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fX = createFunction ( KEYSPACE , 
 - " boolean " , 
 - " CREATE OR REPLACE FUNCTION % s ( val boolean ) " + 
 - " CALLED ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fT = createFunction ( KEYSPACE , 
 - " text " , 
 - " CREATE OR REPLACE FUNCTION % s ( val text ) " + 
 - " CALLED ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fU = createFunction ( KEYSPACE , 
 - type , 
 - " CREATE OR REPLACE FUNCTION % s ( val " + type + " ) " + 
 - " CALLED ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - String fTup = createFunction ( KEYSPACE , 
 - " tuple < int , text > " , 
 - " CREATE OR REPLACE FUNCTION % s ( val tuple < int , text > ) " + 
 - " CALLED ON NULL INPUT " + 
 - " RETURNS text " + 
 - " LANGUAGE java \ n " + 
 - " AS ' return \ " foo bar \ " ; ' ; " ) ; 
 - 
 - assertRows ( execute ( " SELECT " + fI + " ( i ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; 
 - assertRows ( execute ( " SELECT " + fB + " ( b ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; 
 - assertRows ( execute ( " SELECT " + fF + " ( f ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; 
 - assertRows ( execute ( " SELECT " + fD + " ( d ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; 
 - assertRows ( execute ( " SELECT " + fX + " ( x ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; 
 - assertRows ( execute ( " SELECT " + fT + " ( t ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; 
 - assertRows ( execute ( " SELECT " + fU + " ( u ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; 
 - assertRows ( execute ( " SELECT " + fTup + " ( tup ) FROM % s WHERE key = 1 " ) , row ( " foo bar " ) ) ; 
 - } 
 - 
 - @ Test 
 public void testBrokenFunction ( ) throws Throwable 
 { 
 createTable ( " CREATE TABLE % s ( key int primary key , dval double ) " ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
