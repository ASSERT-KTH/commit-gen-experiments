BLEU SCORE: 1.0377486186365205E-4

TEST MSG: cleanup
GENERATED MSG: Fix columns expiring in the middle of 2 phase compactions

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / DeletionTime . java b / src / java / org / apache / cassandra / db / DeletionTime . java <nl> index b80422c . . a1b9f17 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DeletionTime . java <nl> + + + b / src / java / org / apache / cassandra / db / DeletionTime . java <nl> @ @ - 122 , 10 + 122 , 9 @ @ public class DeletionTime implements Comparable < DeletionTime > <nl> { <nl> int ldt = in . readInt ( ) ; <nl> long mfda = in . readLong ( ) ; <nl> - if ( mfda = = Long . MIN _ VALUE & & ldt = = Integer . MAX _ VALUE ) <nl> - return LIVE ; <nl> - else <nl> - return new DeletionTime ( mfda , ldt ) ; <nl> + return mfda = = Long . MIN _ VALUE & & ldt = = Integer . MAX _ VALUE <nl> + ? LIVE <nl> + : new DeletionTime ( mfda , ldt ) ; <nl> } <nl> <nl> public long serializedSize ( DeletionTime delTime , TypeSizes typeSizes )
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c9e229c . . c081b45 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 6 + 1 , 7 @ @ <nl> 2 . 0 . 0 - rc1 <nl> * fix potential spurious wakeup in AsyncOneResponse ( CASSANDRA - 5690 ) <nl> * fix schema - related trigger issues ( CASSANDRA - 5774 ) <nl> + * Better validation when accessing CQL3 table from thrift ( CASSANDRA - 5138 ) <nl> <nl> <nl> 2 . 0 . 0 - beta2 <nl> diff - - git a / src / java / org / apache / cassandra / thrift / ThriftValidation . java b / src / java / org / apache / cassandra / thrift / ThriftValidation . java <nl> index 23d21f8 . . ce8fdcb 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / ThriftValidation . java <nl> + + + b / src / java / org / apache / cassandra / thrift / ThriftValidation . java <nl> @ @ - 25 , 13 + 25 , 17 @ @ import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . config . * ; <nl> + import org . apache . cassandra . cql3 . CFDefinition ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . filter . IDiskAtomFilter ; <nl> import org . apache . cassandra . db . filter . NamesQueryFilter ; <nl> import org . apache . cassandra . db . filter . SliceQueryFilter ; <nl> import org . apache . cassandra . db . index . SecondaryIndexManager ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> + import org . apache . cassandra . db . marshal . ColumnToCollectionType ; <nl> import org . apache . cassandra . db . marshal . CompositeType ; <nl> + import org . apache . cassandra . db . marshal . UTF8Type ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . service . StorageService ; <nl> @ @ - 207 , 6 + 211 , 8 @ @ public class ThriftValidation <nl> throw new org . apache . cassandra . exceptions . InvalidRequestException ( " supercolumn specified to ColumnFamily " + metadata . cfName + " containing normal columns " ) ; <nl> } <nl> AbstractType < ? > comparator = SuperColumns . getComparatorFor ( metadata , superColumnName ) ; <nl> + CFDefinition cfDef = metadata . getCfDef ( ) ; <nl> + boolean isCQL3Table = cfDef . isComposite & & ! cfDef . isCompact & & ! metadata . isSuper ( ) ; <nl> for ( ByteBuffer name : column _ names ) <nl> { <nl> if ( name . remaining ( ) > maxNameLength ) <nl> @ @ - 221 , 6 + 227 , 34 @ @ public class ThriftValidation <nl> { <nl> throw new org . apache . cassandra . exceptions . InvalidRequestException ( e . getMessage ( ) ) ; <nl> } <nl> + <nl> + if ( isCQL3Table ) <nl> + { <nl> + / / CQL3 table don ' t support having only part of their composite column names set <nl> + CompositeType composite = ( CompositeType ) comparator ; <nl> + ByteBuffer [ ] components = composite . split ( name ) ; <nl> + int minComponents = composite . types . size ( ) - ( cfDef . hasCollections ? 1 : 0 ) ; <nl> + if ( components . length < minComponents ) <nl> + throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( " Not enough component ( found % d but % d expected ) for column name since % s is a CQL3 table " , <nl> + metadata . cfName , components . length , minComponents ) ) ; <nl> + <nl> + / / Furthermore , the column name must be a declared one . <nl> + int columnIndex = composite . types . size ( ) - ( cfDef . hasCollections ? 2 : 1 ) ; <nl> + ByteBuffer CQL3ColumnName = components [ columnIndex ] ; <nl> + ColumnIdentifier columnId = new ColumnIdentifier ( CQL3ColumnName , composite . types . get ( columnIndex ) ) ; <nl> + if ( cfDef . columns . get ( columnId ) = = null ) <nl> + throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( " Invalid cell for CQL3 table % s . The CQL3 column component ( % s ) does not correspond to a defined CQL3 column " , <nl> + metadata . cfName , columnId ) ) ; <nl> + <nl> + / / On top of that , if we have a collection component , he ( CQL3 ) column must be a collection <nl> + if ( cfDef . hasCollections & & components . length = = composite . types . size ( ) ) <nl> + { <nl> + assert components . length > = 2 ; <nl> + ColumnToCollectionType collectionType = ( ColumnToCollectionType ) composite . types . get ( composite . types . size ( ) - 1 ) ; <nl> + if ( ! collectionType . defined . containsKey ( CQL3ColumnName ) ) <nl> + throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( " Invalid collection component , % s is not a collection " , UTF8Type . instance . getString ( CQL3ColumnName ) ) ) ; <nl> + } <nl> + } <nl> } <nl> } <nl>

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / DeletionTime . java b / src / java / org / apache / cassandra / db / DeletionTime . java 
 index b80422c . . a1b9f17 100644 
 - - - a / src / java / org / apache / cassandra / db / DeletionTime . java 
 + + + b / src / java / org / apache / cassandra / db / DeletionTime . java 
 @ @ - 122 , 10 + 122 , 9 @ @ public class DeletionTime implements Comparable < DeletionTime > 
 { 
 int ldt = in . readInt ( ) ; 
 long mfda = in . readLong ( ) ; 
 - if ( mfda = = Long . MIN _ VALUE & & ldt = = Integer . MAX _ VALUE ) 
 - return LIVE ; 
 - else 
 - return new DeletionTime ( mfda , ldt ) ; 
 + return mfda = = Long . MIN _ VALUE & & ldt = = Integer . MAX _ VALUE 
 + ? LIVE 
 + : new DeletionTime ( mfda , ldt ) ; 
 } 
 
 public long serializedSize ( DeletionTime delTime , TypeSizes typeSizes )

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c9e229c . . c081b45 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 2 . 0 . 0 - rc1 
 * fix potential spurious wakeup in AsyncOneResponse ( CASSANDRA - 5690 ) 
 * fix schema - related trigger issues ( CASSANDRA - 5774 ) 
 + * Better validation when accessing CQL3 table from thrift ( CASSANDRA - 5138 ) 
 
 
 2 . 0 . 0 - beta2 
 diff - - git a / src / java / org / apache / cassandra / thrift / ThriftValidation . java b / src / java / org / apache / cassandra / thrift / ThriftValidation . java 
 index 23d21f8 . . ce8fdcb 100644 
 - - - a / src / java / org / apache / cassandra / thrift / ThriftValidation . java 
 + + + b / src / java / org / apache / cassandra / thrift / ThriftValidation . java 
 @ @ - 25 , 13 + 25 , 17 @ @ import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . config . * ; 
 + import org . apache . cassandra . cql3 . CFDefinition ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . filter . IDiskAtomFilter ; 
 import org . apache . cassandra . db . filter . NamesQueryFilter ; 
 import org . apache . cassandra . db . filter . SliceQueryFilter ; 
 import org . apache . cassandra . db . index . SecondaryIndexManager ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 + import org . apache . cassandra . db . marshal . ColumnToCollectionType ; 
 import org . apache . cassandra . db . marshal . CompositeType ; 
 + import org . apache . cassandra . db . marshal . UTF8Type ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . service . StorageService ; 
 @ @ - 207 , 6 + 211 , 8 @ @ public class ThriftValidation 
 throw new org . apache . cassandra . exceptions . InvalidRequestException ( " supercolumn specified to ColumnFamily " + metadata . cfName + " containing normal columns " ) ; 
 } 
 AbstractType < ? > comparator = SuperColumns . getComparatorFor ( metadata , superColumnName ) ; 
 + CFDefinition cfDef = metadata . getCfDef ( ) ; 
 + boolean isCQL3Table = cfDef . isComposite & & ! cfDef . isCompact & & ! metadata . isSuper ( ) ; 
 for ( ByteBuffer name : column _ names ) 
 { 
 if ( name . remaining ( ) > maxNameLength ) 
 @ @ - 221 , 6 + 227 , 34 @ @ public class ThriftValidation 
 { 
 throw new org . apache . cassandra . exceptions . InvalidRequestException ( e . getMessage ( ) ) ; 
 } 
 + 
 + if ( isCQL3Table ) 
 + { 
 + / / CQL3 table don ' t support having only part of their composite column names set 
 + CompositeType composite = ( CompositeType ) comparator ; 
 + ByteBuffer [ ] components = composite . split ( name ) ; 
 + int minComponents = composite . types . size ( ) - ( cfDef . hasCollections ? 1 : 0 ) ; 
 + if ( components . length < minComponents ) 
 + throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( " Not enough component ( found % d but % d expected ) for column name since % s is a CQL3 table " , 
 + metadata . cfName , components . length , minComponents ) ) ; 
 + 
 + / / Furthermore , the column name must be a declared one . 
 + int columnIndex = composite . types . size ( ) - ( cfDef . hasCollections ? 2 : 1 ) ; 
 + ByteBuffer CQL3ColumnName = components [ columnIndex ] ; 
 + ColumnIdentifier columnId = new ColumnIdentifier ( CQL3ColumnName , composite . types . get ( columnIndex ) ) ; 
 + if ( cfDef . columns . get ( columnId ) = = null ) 
 + throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( " Invalid cell for CQL3 table % s . The CQL3 column component ( % s ) does not correspond to a defined CQL3 column " , 
 + metadata . cfName , columnId ) ) ; 
 + 
 + / / On top of that , if we have a collection component , he ( CQL3 ) column must be a collection 
 + if ( cfDef . hasCollections & & components . length = = composite . types . size ( ) ) 
 + { 
 + assert components . length > = 2 ; 
 + ColumnToCollectionType collectionType = ( ColumnToCollectionType ) composite . types . get ( composite . types . size ( ) - 1 ) ; 
 + if ( ! collectionType . defined . containsKey ( CQL3ColumnName ) ) 
 + throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( " Invalid collection component , % s is not a collection " , UTF8Type . instance . getString ( CQL3ColumnName ) ) ) ; 
 + } 
 + } 
 } 
 } 

