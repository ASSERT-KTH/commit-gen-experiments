BLEU SCORE: 0.03089055318156698

TEST MSG: Fix high memory use due to tracking reads on incrementally opened sstable readers
GENERATED MSG: Reduce SSTableLoader memory usage

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 0b2dd0c . . b6b1953 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 1 <nl> + * Fix high memory use due to tracking reads on incrementally opened sstable readers ( CASSANDRA - 8066 ) <nl> * Fix EXECUTE request with skipMetadata = false returning no metadata <nl> ( CASSANDRA - 8054 ) <nl> * Allow concurrent use of CQLBulkOutputFormat ( CASSANDRA - 7776 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index db7d762 . . a45d1b2 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 2149 , 7 + 2149 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> for ( SSTableReader ssTable : currentView . sstables ) <nl> { <nl> - if ( ssTable . isOpenEarly | | ( predicate ! = null & & ! predicate . apply ( ssTable ) ) ) <nl> + if ( ssTable . openReason = = SSTableReader . OpenReason . EARLY | | ( predicate ! = null & & ! predicate . apply ( ssTable ) ) ) <nl> { <nl> continue ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java b / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java <nl> index e4559d3 . . 785e23b 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java <nl> @ @ - 51 , 7 + 51 , 7 @ @ public class SSTableDeletingTask implements Runnable <nl> public SSTableDeletingTask ( SSTableReader referent ) <nl> { <nl> this . referent = referent ; <nl> - if ( referent . isOpenEarly ) <nl> + if ( referent . openReason = = SSTableReader . OpenReason . EARLY ) <nl> { <nl> this . desc = referent . descriptor . asType ( Descriptor . Type . TEMPLINK ) ; <nl> this . components = Sets . newHashSet ( Component . DATA , Component . PRIMARY _ INDEX ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index 9f2b59d . . 872f7df 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 159 , 7 + 159 , 15 @ @ public class SSTableReader extends SSTable <nl> * The age is in milliseconds since epoc and is local to this host . <nl> * / <nl> public final long maxDataAge ; <nl> - public final boolean isOpenEarly ; <nl> + <nl> + public enum OpenReason <nl> + { <nl> + NORMAL , <nl> + EARLY , <nl> + METADATA _ CHANGE <nl> + } <nl> + <nl> + public final OpenReason openReason ; <nl> <nl> / / indexfile and datafile : might be null before a call to load ( ) <nl> private SegmentedFile ifile ; <nl> @ @ - 338 , 7 + 346 , 7 @ @ public class SSTableReader extends SSTable <nl> partitioner , <nl> System . currentTimeMillis ( ) , <nl> statsMetadata , <nl> - false ) ; <nl> + OpenReason . NORMAL ) ; <nl> <nl> / / special implementation of load to use non - pooled SegmentedFile builders <nl> SegmentedFile . Builder ibuilder = new BufferedSegmentedFile . Builder ( ) ; <nl> @ @ - 387 , 7 + 395 , 7 @ @ public class SSTableReader extends SSTable <nl> partitioner , <nl> System . currentTimeMillis ( ) , <nl> statsMetadata , <nl> - false ) ; <nl> + OpenReason . NORMAL ) ; <nl> <nl> / / load index and filter <nl> long start = System . nanoTime ( ) ; <nl> @ @ - 467 , 7 + 475 , 7 @ @ public class SSTableReader extends SSTable <nl> IFilter bf , <nl> long maxDataAge , <nl> StatsMetadata sstableMetadata , <nl> - boolean isOpenEarly ) <nl> + OpenReason openReason ) <nl> { <nl> assert desc ! = null & & partitioner ! = null & & ifile ! = null & & dfile ! = null & & isummary ! = null & & bf ! = null & & sstableMetadata ! = null ; <nl> return new SSTableReader ( desc , <nl> @ @ - 479 , 7 + 487 , 7 @ @ public class SSTableReader extends SSTable <nl> bf , <nl> maxDataAge , <nl> sstableMetadata , <nl> - isOpenEarly ) ; <nl> + openReason ) ; <nl> } <nl> <nl> <nl> @ @ - 489 , 18 + 497 , 19 @ @ public class SSTableReader extends SSTable <nl> IPartitioner partitioner , <nl> long maxDataAge , <nl> StatsMetadata sstableMetadata , <nl> - boolean isOpenEarly ) <nl> + OpenReason openReason ) <nl> { <nl> super ( desc , components , metadata , partitioner ) ; <nl> this . sstableMetadata = sstableMetadata ; <nl> this . maxDataAge = maxDataAge ; <nl> - this . isOpenEarly = isOpenEarly ; <nl> + this . openReason = openReason ; <nl> <nl> deletingTask = new SSTableDeletingTask ( this ) ; <nl> <nl> / / Don ' t track read rates for tables in the system keyspace and don ' t bother trying to load or persist <nl> - / / the read meter when in client mode <nl> - if ( Keyspace . SYSTEM _ KS . equals ( desc . ksname ) | | Config . isClientMode ( ) ) <nl> + / / the read meter when in client mode . Also don ' t track reads for special operations ( like early open ) <nl> + / / this is to avoid overflowing the executor queue ( see CASSANDRA - 8066 ) <nl> + if ( Keyspace . SYSTEM _ KS . equals ( desc . ksname ) | | Config . isClientMode ( ) | | openReason ! = OpenReason . NORMAL ) <nl> { <nl> readMeter = null ; <nl> readMeterSyncFuture = null ; <nl> @ @ - 532 , 9 + 541 , 9 @ @ public class SSTableReader extends SSTable <nl> IFilter bloomFilter , <nl> long maxDataAge , <nl> StatsMetadata sstableMetadata , <nl> - boolean isOpenEarly ) <nl> + OpenReason openReason ) <nl> { <nl> - this ( desc , components , metadata , partitioner , maxDataAge , sstableMetadata , isOpenEarly ) ; <nl> + this ( desc , components , metadata , partitioner , maxDataAge , sstableMetadata , openReason ) ; <nl> <nl> this . ifile = ifile ; <nl> this . dfile = dfile ; <nl> @ @ - 953 , 9 + 962 , 9 @ @ public class SSTableReader extends SSTable <nl> } <nl> } <nl> <nl> - if ( readMeterSyncFuture ! = null ) <nl> - readMeterSyncFuture . cancel ( false ) ; <nl> - SSTableReader replacement = new SSTableReader ( descriptor , components , metadata , partitioner , ifile , dfile , indexSummary . readOnlyClone ( ) , bf , maxDataAge , sstableMetadata , isOpenEarly ) ; <nl> + SSTableReader replacement = new SSTableReader ( descriptor , components , metadata , partitioner , ifile , dfile , indexSummary . readOnlyClone ( ) , bf , maxDataAge , sstableMetadata , <nl> + openReason = = OpenReason . EARLY ? openReason : OpenReason . METADATA _ CHANGE ) ; <nl> + replacement . readMeterSyncFuture = this . readMeterSyncFuture ; <nl> replacement . readMeter = this . readMeter ; <nl> replacement . first = this . last . compareTo ( newStart ) > 0 ? newStart : this . last ; <nl> replacement . last = this . last ; <nl> @ @ - 1015 , 10 + 1024 , 9 @ @ public class SSTableReader extends SSTable <nl> StorageMetrics . load . inc ( newSize - oldSize ) ; <nl> parent . metric . liveDiskSpaceUsed . inc ( newSize - oldSize ) ; <nl> <nl> - if ( readMeterSyncFuture ! = null ) <nl> - readMeterSyncFuture . cancel ( false ) ; <nl> - <nl> - SSTableReader replacement = new SSTableReader ( descriptor , components , metadata , partitioner , ifile , dfile , newSummary , bf , maxDataAge , sstableMetadata , isOpenEarly ) ; <nl> + SSTableReader replacement = new SSTableReader ( descriptor , components , metadata , partitioner , ifile , dfile , newSummary , bf , maxDataAge , sstableMetadata , <nl> + openReason = = OpenReason . EARLY ? openReason : OpenReason . METADATA _ CHANGE ) ; <nl> + replacement . readMeterSyncFuture = this . readMeterSyncFuture ; <nl> replacement . readMeter = this . readMeter ; <nl> replacement . first = this . first ; <nl> replacement . last = this . last ; <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> index 9e861a1 . . e92803a 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> @ @ - 397 , 7 + 397 , 7 @ @ public class SSTableWriter extends SSTable <nl> components , metadata , <nl> partitioner , ifile , <nl> dfile , iwriter . summary . build ( partitioner , exclusiveUpperBoundOfReadableIndex ) , <nl> - iwriter . bf , maxDataAge , sstableMetadata , true ) ; <nl> + iwriter . bf , maxDataAge , sstableMetadata , SSTableReader . OpenReason . EARLY ) ; <nl> <nl> / / now it ' s open , find the ACTUAL last readable key ( i . e . for which the data file has also been flushed ) <nl> sstable . first = getMinimalKey ( first ) ; <nl> @ @ - 448 , 7 + 448 , 7 @ @ public class SSTableWriter extends SSTable <nl> iwriter . bf , <nl> maxDataAge , <nl> sstableMetadata , <nl> - false ) ; <nl> + SSTableReader . OpenReason . NORMAL ) ; <nl> sstable . first = getMinimalKey ( first ) ; <nl> sstable . last = getMinimalKey ( last ) ; <nl> / / try to save the summaries to disk
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b83b88a . . e4da98d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 57 , 6 + 57 , 7 @ @ <nl> * Support native link w / o JNA in Java7 ( CASSANDRA - 3734 ) <nl> <nl> 1 . 2 . 6 <nl> + * Reduce SSTableLoader memory usage ( CASSANDRA - 5555 ) <nl> * Scale hinted _ handoff _ throttle _ in _ kb to cluster size ( CASSANDRA - 5272 ) <nl> * ( Hadoop ) Fix InputKeyRange in CFIF ( CASSANDRA - 5536 ) <nl> * Fix dealing with ridiculously large max sstable sizes in LCS ( CASSANDRA - 5589 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index dcd7814 . . 4287df6 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 259 , 7 + 259 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> if ( loadSSTables ) <nl> { <nl> Directories . SSTableLister sstableFiles = directories . sstableLister ( ) . skipTemporary ( true ) ; <nl> - Collection < SSTableReader > sstables = SSTableReader . batchOpen ( sstableFiles . list ( ) . entrySet ( ) , metadata , this . partitioner ) ; <nl> + Collection < SSTableReader > sstables = SSTableReader . openAll ( sstableFiles . list ( ) . entrySet ( ) , metadata , this . partitioner ) ; <nl> data . addInitialSSTables ( sstables ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableLoader . java b / src / java / org / apache / cassandra / io / sstable / SSTableLoader . java <nl> index 0cd61e5 . . b1b70e0 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableLoader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableLoader . java <nl> @ @ - 95 , 7 + 95 , 7 @ @ public class SSTableLoader <nl> <nl> try <nl> { <nl> - sstables . add ( SSTableReader . open ( desc , components , null , client . getPartitioner ( ) ) ) ; <nl> + sstables . add ( SSTableReader . openForBatch ( desc , components , client . getPartitioner ( ) ) ) ; <nl> } <nl> catch ( IOException e ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index 2f37d0f . . 8119388 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 155 , 41 + 155 , 33 @ @ public class SSTableReader extends SSTable <nl> return open ( descriptor , components , metadata , partitioner , true ) ; <nl> } <nl> <nl> + public static SSTableReader openForBatch ( Descriptor descriptor , Set < Component > components , IPartitioner partitioner ) throws IOException <nl> + { <nl> + SSTableMetadata sstableMetadata = openMetadata ( descriptor , components , partitioner ) ; <nl> + SSTableReader sstable = new SSTableReader ( descriptor , <nl> + components , <nl> + null , <nl> + partitioner , <nl> + System . currentTimeMillis ( ) , <nl> + sstableMetadata ) ; <nl> + sstable . bf = new AlwaysPresentFilter ( ) ; <nl> + sstable . loadForBatch ( ) ; <nl> + return sstable ; <nl> + } <nl> + <nl> private static SSTableReader open ( Descriptor descriptor , <nl> Set < Component > components , <nl> CFMetaData metadata , <nl> IPartitioner partitioner , <nl> boolean validate ) throws IOException <nl> { <nl> - assert partitioner ! = null ; <nl> - / / Minimum components without which we can ' t do anything <nl> - assert components . contains ( Component . DATA ) : " Data component is missing for sstable " + descriptor ; <nl> - assert components . contains ( Component . PRIMARY _ INDEX ) : " Primary index component is missing for sstable " + descriptor ; <nl> - <nl> long start = System . nanoTime ( ) ; <nl> - logger . info ( " Opening { } ( { } bytes ) " , descriptor , new File ( descriptor . filenameFor ( COMPONENT _ DATA ) ) . length ( ) ) ; <nl> - <nl> - SSTableMetadata sstableMetadata = SSTableMetadata . serializer . deserialize ( descriptor ) ; <nl> - <nl> - / / Check if sstable is created using same partitioner . <nl> - / / Partitioner can be null , which indicates older version of sstable or no stats available . <nl> - / / In that case , we skip the check . <nl> - String partitionerName = partitioner . getClass ( ) . getCanonicalName ( ) ; <nl> - if ( sstableMetadata . partitioner ! = null & & ! partitionerName . equals ( sstableMetadata . partitioner ) ) <nl> - { <nl> - logger . error ( String . format ( " Cannot open % s ; partitioner % s does not match system partitioner % s . Note that the default partitioner starting with Cassandra 1 . 2 is Murmur3Partitioner , so you will need to edit that to match your old partitioner if upgrading . " , <nl> - descriptor , sstableMetadata . partitioner , partitionerName ) ) ; <nl> - System . exit ( 1 ) ; <nl> - } <nl> + SSTableMetadata sstableMetadata = openMetadata ( descriptor , components , partitioner ) ; <nl> <nl> SSTableReader sstable = new SSTableReader ( descriptor , <nl> components , <nl> metadata , <nl> partitioner , <nl> - null , <nl> - null , <nl> - null , <nl> - null , <nl> System . currentTimeMillis ( ) , <nl> sstableMetadata ) ; <nl> <nl> @ @ - 206 , 6 + 198 , 30 @ @ public class SSTableReader extends SSTable <nl> return sstable ; <nl> } <nl> <nl> + private static SSTableMetadata openMetadata ( Descriptor descriptor , Set < Component > components , IPartitioner partitioner ) throws IOException <nl> + { <nl> + assert partitioner ! = null ; <nl> + / / Minimum components without which we can ' t do anything <nl> + assert components . contains ( Component . DATA ) : " Data component is missing for sstable " + descriptor ; <nl> + assert components . contains ( Component . PRIMARY _ INDEX ) : " Primary index component is missing for sstable " + descriptor ; <nl> + <nl> + logger . info ( " Opening { } ( { } bytes ) " , descriptor , new File ( descriptor . filenameFor ( COMPONENT _ DATA ) ) . length ( ) ) ; <nl> + <nl> + SSTableMetadata sstableMetadata = SSTableMetadata . serializer . deserialize ( descriptor ) ; <nl> + <nl> + / / Check if sstable is created using same partitioner . <nl> + / / Partitioner can be null , which indicates older version of sstable or no stats available . <nl> + / / In that case , we skip the check . <nl> + String partitionerName = partitioner . getClass ( ) . getCanonicalName ( ) ; <nl> + if ( sstableMetadata . partitioner ! = null & & ! partitionerName . equals ( sstableMetadata . partitioner ) ) <nl> + { <nl> + logger . error ( String . format ( " Cannot open % s ; partitioner % s does not match system partitioner % s . Note that the default partitioner starting with Cassandra 1 . 2 is Murmur3Partitioner , so you will need to edit that to match your old partitioner if upgrading . " , <nl> + descriptor , sstableMetadata . partitioner , partitionerName ) ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + return sstableMetadata ; <nl> + } <nl> + <nl> public static void logOpenException ( Descriptor descriptor , IOException e ) <nl> { <nl> if ( e instanceof FileNotFoundException ) <nl> @ @ - 214 , 9 + 230 , 9 @ @ public class SSTableReader extends SSTable <nl> logger . error ( " Corrupt sstable " + descriptor + " ; skipped " , e ) ; <nl> } <nl> <nl> - public static Collection < SSTableReader > batchOpen ( Set < Map . Entry < Descriptor , Set < Component > > > entries , <nl> - final CFMetaData metadata , <nl> - final IPartitioner partitioner ) <nl> + public static Collection < SSTableReader > openAll ( Set < Map . Entry < Descriptor , Set < Component > > > entries , <nl> + final CFMetaData metadata , <nl> + final IPartitioner partitioner ) <nl> { <nl> final Collection < SSTableReader > sstables = new LinkedBlockingQueue < SSTableReader > ( ) ; <nl> <nl> @ @ - 287 , 6 + 303 , 20 @ @ public class SSTableReader extends SSTable <nl> Set < Component > components , <nl> CFMetaData metadata , <nl> IPartitioner partitioner , <nl> + long maxDataAge , <nl> + SSTableMetadata sstableMetadata ) <nl> + { <nl> + super ( desc , components , metadata , partitioner ) ; <nl> + this . sstableMetadata = sstableMetadata ; <nl> + this . maxDataAge = maxDataAge ; <nl> + <nl> + this . deletingTask = new SSTableDeletingTask ( this ) ; <nl> + } <nl> + <nl> + private SSTableReader ( Descriptor desc , <nl> + Set < Component > components , <nl> + CFMetaData metadata , <nl> + IPartitioner partitioner , <nl> SegmentedFile ifile , <nl> SegmentedFile dfile , <nl> IndexSummary indexSummary , <nl> @ @ - 294 , 15 + 324 , 12 @ @ public class SSTableReader extends SSTable <nl> long maxDataAge , <nl> SSTableMetadata sstableMetadata ) <nl> { <nl> - super ( desc , components , metadata , partitioner ) ; <nl> - this . sstableMetadata = sstableMetadata ; <nl> - this . maxDataAge = maxDataAge ; <nl> + this ( desc , components , metadata , partitioner , maxDataAge , sstableMetadata ) ; <nl> <nl> this . ifile = ifile ; <nl> this . dfile = dfile ; <nl> this . indexSummary = indexSummary ; <nl> this . bf = bloomFilter ; <nl> - this . deletingTask = new SSTableDeletingTask ( this ) ; <nl> } <nl> <nl> public void setTrackedBy ( DataTracker tracker ) <nl> @ @ - 361 , 16 + 388 , 55 @ @ public class SSTableReader extends SSTable <nl> { <nl> SegmentedFile . Builder ibuilder = SegmentedFile . getBuilder ( DatabaseDescriptor . getIndexAccessMode ( ) ) ; <nl> SegmentedFile . Builder dbuilder = compression <nl> - ? SegmentedFile . getCompressedBuilder ( ) <nl> - : SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) ) ; <nl> + ? SegmentedFile . getCompressedBuilder ( ) <nl> + : SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) ) ; <nl> + <nl> <nl> + boolean summaryLoaded = loadSummary ( this , ibuilder , dbuilder , metadata ) ; <nl> + if ( recreateBloomFilter | | ! summaryLoaded ) <nl> + buildSummary ( recreateBloomFilter , ibuilder , dbuilder , summaryLoaded ) ; <nl> + <nl> + ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; <nl> + dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; <nl> + if ( recreateBloomFilter | | ! summaryLoaded ) / / save summary information to disk <nl> + saveSummary ( this , ibuilder , dbuilder ) ; <nl> + } <nl> + <nl> + / * * <nl> + * A simplified load that creates a minimal partition index <nl> + * / <nl> + private void loadForBatch ( ) throws IOException <nl> + { <nl> + / / force buffered i / o in non - compressed mode so we don ' t need to worry about mmap segments <nl> + SegmentedFile . Builder ibuilder = new BufferedSegmentedFile . Builder ( ) ; <nl> + SegmentedFile . Builder dbuilder = compression <nl> + ? SegmentedFile . getCompressedBuilder ( ) <nl> + : new BufferedSegmentedFile . Builder ( ) ; <nl> + <nl> + / / build a bare - bones IndexSummary <nl> + IndexSummaryBuilder summaryBuilder = new IndexSummaryBuilder ( 1 , 1 ) ; <nl> + RandomAccessReader in = RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ) ; <nl> + try <nl> + { <nl> + first = partitioner . decorateKey ( ByteBufferUtil . readWithShortLength ( in ) ) ; <nl> + summaryBuilder . maybeAddEntry ( first , 0 ) ; <nl> + indexSummary = summaryBuilder . build ( partitioner ) ; <nl> + } <nl> + finally <nl> + { <nl> + FileUtils . closeQuietly ( in ) ; <nl> + } <nl> + <nl> + last = null ; / / shouldn ' t need this for batch operations <nl> + <nl> + ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; <nl> + dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; <nl> + } <nl> + <nl> + private void buildSummary ( boolean recreateBloomFilter , SegmentedFile . Builder ibuilder , SegmentedFile . Builder dbuilder , boolean summaryLoaded ) throws IOException <nl> + { <nl> / / we read the positions in a BRAF so we don ' t have to worry about an entry spanning a mmap boundary . <nl> RandomAccessReader primaryIndex = RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ) ; <nl> - <nl> - / / try to load summaries from the disk and check if we need <nl> - / / to read primary index because we should re - create a BloomFilter or pre - load KeyCache <nl> - final boolean summaryLoaded = loadSummary ( this , ibuilder , dbuilder , metadata ) ; <nl> - final boolean readIndex = recreateBloomFilter | | ! summaryLoaded ; <nl> try <nl> { <nl> long indexSize = primaryIndex . length ( ) ; <nl> @ @ - 387 , 7 + 453 , 7 @ @ public class SSTableReader extends SSTable <nl> summaryBuilder = new IndexSummaryBuilder ( estimatedKeys , metadata . getIndexInterval ( ) ) ; <nl> <nl> long indexPosition ; <nl> - while ( readIndex & & ( indexPosition = primaryIndex . getFilePointer ( ) ) ! = indexSize ) <nl> + while ( ( indexPosition = primaryIndex . getFilePointer ( ) ) ! = indexSize ) <nl> { <nl> ByteBuffer key = ByteBufferUtil . readWithShortLength ( primaryIndex ) ; <nl> RowIndexEntry indexEntry = RowIndexEntry . serializer . deserialize ( primaryIndex , descriptor . version ) ; <nl> @ @ - 418 , 12 + 484 , 6 @ @ public class SSTableReader extends SSTable <nl> <nl> first = getMinimalKey ( first ) ; <nl> last = getMinimalKey ( last ) ; <nl> - / / finalize the load . <nl> - / / finalize the state of the reader <nl> - ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; <nl> - dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; <nl> - if ( readIndex ) / / save summary information to disk <nl> - saveSummary ( this , ibuilder , dbuilder ) ; <nl> } <nl> <nl> public static boolean loadSummary ( SSTableReader reader , SegmentedFile . Builder ibuilder , SegmentedFile . Builder dbuilder , CFMetaData metadata )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 0b2dd0c . . b6b1953 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 1 
 + * Fix high memory use due to tracking reads on incrementally opened sstable readers ( CASSANDRA - 8066 ) 
 * Fix EXECUTE request with skipMetadata = false returning no metadata 
 ( CASSANDRA - 8054 ) 
 * Allow concurrent use of CQLBulkOutputFormat ( CASSANDRA - 7776 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index db7d762 . . a45d1b2 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 2149 , 7 + 2149 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 for ( SSTableReader ssTable : currentView . sstables ) 
 { 
 - if ( ssTable . isOpenEarly | | ( predicate ! = null & & ! predicate . apply ( ssTable ) ) ) 
 + if ( ssTable . openReason = = SSTableReader . OpenReason . EARLY | | ( predicate ! = null & & ! predicate . apply ( ssTable ) ) ) 
 { 
 continue ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java b / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java 
 index e4559d3 . . 785e23b 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java 
 @ @ - 51 , 7 + 51 , 7 @ @ public class SSTableDeletingTask implements Runnable 
 public SSTableDeletingTask ( SSTableReader referent ) 
 { 
 this . referent = referent ; 
 - if ( referent . isOpenEarly ) 
 + if ( referent . openReason = = SSTableReader . OpenReason . EARLY ) 
 { 
 this . desc = referent . descriptor . asType ( Descriptor . Type . TEMPLINK ) ; 
 this . components = Sets . newHashSet ( Component . DATA , Component . PRIMARY _ INDEX ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index 9f2b59d . . 872f7df 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 159 , 7 + 159 , 15 @ @ public class SSTableReader extends SSTable 
 * The age is in milliseconds since epoc and is local to this host . 
 * / 
 public final long maxDataAge ; 
 - public final boolean isOpenEarly ; 
 + 
 + public enum OpenReason 
 + { 
 + NORMAL , 
 + EARLY , 
 + METADATA _ CHANGE 
 + } 
 + 
 + public final OpenReason openReason ; 
 
 / / indexfile and datafile : might be null before a call to load ( ) 
 private SegmentedFile ifile ; 
 @ @ - 338 , 7 + 346 , 7 @ @ public class SSTableReader extends SSTable 
 partitioner , 
 System . currentTimeMillis ( ) , 
 statsMetadata , 
 - false ) ; 
 + OpenReason . NORMAL ) ; 
 
 / / special implementation of load to use non - pooled SegmentedFile builders 
 SegmentedFile . Builder ibuilder = new BufferedSegmentedFile . Builder ( ) ; 
 @ @ - 387 , 7 + 395 , 7 @ @ public class SSTableReader extends SSTable 
 partitioner , 
 System . currentTimeMillis ( ) , 
 statsMetadata , 
 - false ) ; 
 + OpenReason . NORMAL ) ; 
 
 / / load index and filter 
 long start = System . nanoTime ( ) ; 
 @ @ - 467 , 7 + 475 , 7 @ @ public class SSTableReader extends SSTable 
 IFilter bf , 
 long maxDataAge , 
 StatsMetadata sstableMetadata , 
 - boolean isOpenEarly ) 
 + OpenReason openReason ) 
 { 
 assert desc ! = null & & partitioner ! = null & & ifile ! = null & & dfile ! = null & & isummary ! = null & & bf ! = null & & sstableMetadata ! = null ; 
 return new SSTableReader ( desc , 
 @ @ - 479 , 7 + 487 , 7 @ @ public class SSTableReader extends SSTable 
 bf , 
 maxDataAge , 
 sstableMetadata , 
 - isOpenEarly ) ; 
 + openReason ) ; 
 } 
 
 
 @ @ - 489 , 18 + 497 , 19 @ @ public class SSTableReader extends SSTable 
 IPartitioner partitioner , 
 long maxDataAge , 
 StatsMetadata sstableMetadata , 
 - boolean isOpenEarly ) 
 + OpenReason openReason ) 
 { 
 super ( desc , components , metadata , partitioner ) ; 
 this . sstableMetadata = sstableMetadata ; 
 this . maxDataAge = maxDataAge ; 
 - this . isOpenEarly = isOpenEarly ; 
 + this . openReason = openReason ; 
 
 deletingTask = new SSTableDeletingTask ( this ) ; 
 
 / / Don ' t track read rates for tables in the system keyspace and don ' t bother trying to load or persist 
 - / / the read meter when in client mode 
 - if ( Keyspace . SYSTEM _ KS . equals ( desc . ksname ) | | Config . isClientMode ( ) ) 
 + / / the read meter when in client mode . Also don ' t track reads for special operations ( like early open ) 
 + / / this is to avoid overflowing the executor queue ( see CASSANDRA - 8066 ) 
 + if ( Keyspace . SYSTEM _ KS . equals ( desc . ksname ) | | Config . isClientMode ( ) | | openReason ! = OpenReason . NORMAL ) 
 { 
 readMeter = null ; 
 readMeterSyncFuture = null ; 
 @ @ - 532 , 9 + 541 , 9 @ @ public class SSTableReader extends SSTable 
 IFilter bloomFilter , 
 long maxDataAge , 
 StatsMetadata sstableMetadata , 
 - boolean isOpenEarly ) 
 + OpenReason openReason ) 
 { 
 - this ( desc , components , metadata , partitioner , maxDataAge , sstableMetadata , isOpenEarly ) ; 
 + this ( desc , components , metadata , partitioner , maxDataAge , sstableMetadata , openReason ) ; 
 
 this . ifile = ifile ; 
 this . dfile = dfile ; 
 @ @ - 953 , 9 + 962 , 9 @ @ public class SSTableReader extends SSTable 
 } 
 } 
 
 - if ( readMeterSyncFuture ! = null ) 
 - readMeterSyncFuture . cancel ( false ) ; 
 - SSTableReader replacement = new SSTableReader ( descriptor , components , metadata , partitioner , ifile , dfile , indexSummary . readOnlyClone ( ) , bf , maxDataAge , sstableMetadata , isOpenEarly ) ; 
 + SSTableReader replacement = new SSTableReader ( descriptor , components , metadata , partitioner , ifile , dfile , indexSummary . readOnlyClone ( ) , bf , maxDataAge , sstableMetadata , 
 + openReason = = OpenReason . EARLY ? openReason : OpenReason . METADATA _ CHANGE ) ; 
 + replacement . readMeterSyncFuture = this . readMeterSyncFuture ; 
 replacement . readMeter = this . readMeter ; 
 replacement . first = this . last . compareTo ( newStart ) > 0 ? newStart : this . last ; 
 replacement . last = this . last ; 
 @ @ - 1015 , 10 + 1024 , 9 @ @ public class SSTableReader extends SSTable 
 StorageMetrics . load . inc ( newSize - oldSize ) ; 
 parent . metric . liveDiskSpaceUsed . inc ( newSize - oldSize ) ; 
 
 - if ( readMeterSyncFuture ! = null ) 
 - readMeterSyncFuture . cancel ( false ) ; 
 - 
 - SSTableReader replacement = new SSTableReader ( descriptor , components , metadata , partitioner , ifile , dfile , newSummary , bf , maxDataAge , sstableMetadata , isOpenEarly ) ; 
 + SSTableReader replacement = new SSTableReader ( descriptor , components , metadata , partitioner , ifile , dfile , newSummary , bf , maxDataAge , sstableMetadata , 
 + openReason = = OpenReason . EARLY ? openReason : OpenReason . METADATA _ CHANGE ) ; 
 + replacement . readMeterSyncFuture = this . readMeterSyncFuture ; 
 replacement . readMeter = this . readMeter ; 
 replacement . first = this . first ; 
 replacement . last = this . last ; 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 index 9e861a1 . . e92803a 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 @ @ - 397 , 7 + 397 , 7 @ @ public class SSTableWriter extends SSTable 
 components , metadata , 
 partitioner , ifile , 
 dfile , iwriter . summary . build ( partitioner , exclusiveUpperBoundOfReadableIndex ) , 
 - iwriter . bf , maxDataAge , sstableMetadata , true ) ; 
 + iwriter . bf , maxDataAge , sstableMetadata , SSTableReader . OpenReason . EARLY ) ; 
 
 / / now it ' s open , find the ACTUAL last readable key ( i . e . for which the data file has also been flushed ) 
 sstable . first = getMinimalKey ( first ) ; 
 @ @ - 448 , 7 + 448 , 7 @ @ public class SSTableWriter extends SSTable 
 iwriter . bf , 
 maxDataAge , 
 sstableMetadata , 
 - false ) ; 
 + SSTableReader . OpenReason . NORMAL ) ; 
 sstable . first = getMinimalKey ( first ) ; 
 sstable . last = getMinimalKey ( last ) ; 
 / / try to save the summaries to disk

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b83b88a . . e4da98d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 57 , 6 + 57 , 7 @ @ 
 * Support native link w / o JNA in Java7 ( CASSANDRA - 3734 ) 
 
 1 . 2 . 6 
 + * Reduce SSTableLoader memory usage ( CASSANDRA - 5555 ) 
 * Scale hinted _ handoff _ throttle _ in _ kb to cluster size ( CASSANDRA - 5272 ) 
 * ( Hadoop ) Fix InputKeyRange in CFIF ( CASSANDRA - 5536 ) 
 * Fix dealing with ridiculously large max sstable sizes in LCS ( CASSANDRA - 5589 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index dcd7814 . . 4287df6 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 259 , 7 + 259 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 if ( loadSSTables ) 
 { 
 Directories . SSTableLister sstableFiles = directories . sstableLister ( ) . skipTemporary ( true ) ; 
 - Collection < SSTableReader > sstables = SSTableReader . batchOpen ( sstableFiles . list ( ) . entrySet ( ) , metadata , this . partitioner ) ; 
 + Collection < SSTableReader > sstables = SSTableReader . openAll ( sstableFiles . list ( ) . entrySet ( ) , metadata , this . partitioner ) ; 
 data . addInitialSSTables ( sstables ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableLoader . java b / src / java / org / apache / cassandra / io / sstable / SSTableLoader . java 
 index 0cd61e5 . . b1b70e0 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableLoader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableLoader . java 
 @ @ - 95 , 7 + 95 , 7 @ @ public class SSTableLoader 
 
 try 
 { 
 - sstables . add ( SSTableReader . open ( desc , components , null , client . getPartitioner ( ) ) ) ; 
 + sstables . add ( SSTableReader . openForBatch ( desc , components , client . getPartitioner ( ) ) ) ; 
 } 
 catch ( IOException e ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index 2f37d0f . . 8119388 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 155 , 41 + 155 , 33 @ @ public class SSTableReader extends SSTable 
 return open ( descriptor , components , metadata , partitioner , true ) ; 
 } 
 
 + public static SSTableReader openForBatch ( Descriptor descriptor , Set < Component > components , IPartitioner partitioner ) throws IOException 
 + { 
 + SSTableMetadata sstableMetadata = openMetadata ( descriptor , components , partitioner ) ; 
 + SSTableReader sstable = new SSTableReader ( descriptor , 
 + components , 
 + null , 
 + partitioner , 
 + System . currentTimeMillis ( ) , 
 + sstableMetadata ) ; 
 + sstable . bf = new AlwaysPresentFilter ( ) ; 
 + sstable . loadForBatch ( ) ; 
 + return sstable ; 
 + } 
 + 
 private static SSTableReader open ( Descriptor descriptor , 
 Set < Component > components , 
 CFMetaData metadata , 
 IPartitioner partitioner , 
 boolean validate ) throws IOException 
 { 
 - assert partitioner ! = null ; 
 - / / Minimum components without which we can ' t do anything 
 - assert components . contains ( Component . DATA ) : " Data component is missing for sstable " + descriptor ; 
 - assert components . contains ( Component . PRIMARY _ INDEX ) : " Primary index component is missing for sstable " + descriptor ; 
 - 
 long start = System . nanoTime ( ) ; 
 - logger . info ( " Opening { } ( { } bytes ) " , descriptor , new File ( descriptor . filenameFor ( COMPONENT _ DATA ) ) . length ( ) ) ; 
 - 
 - SSTableMetadata sstableMetadata = SSTableMetadata . serializer . deserialize ( descriptor ) ; 
 - 
 - / / Check if sstable is created using same partitioner . 
 - / / Partitioner can be null , which indicates older version of sstable or no stats available . 
 - / / In that case , we skip the check . 
 - String partitionerName = partitioner . getClass ( ) . getCanonicalName ( ) ; 
 - if ( sstableMetadata . partitioner ! = null & & ! partitionerName . equals ( sstableMetadata . partitioner ) ) 
 - { 
 - logger . error ( String . format ( " Cannot open % s ; partitioner % s does not match system partitioner % s . Note that the default partitioner starting with Cassandra 1 . 2 is Murmur3Partitioner , so you will need to edit that to match your old partitioner if upgrading . " , 
 - descriptor , sstableMetadata . partitioner , partitionerName ) ) ; 
 - System . exit ( 1 ) ; 
 - } 
 + SSTableMetadata sstableMetadata = openMetadata ( descriptor , components , partitioner ) ; 
 
 SSTableReader sstable = new SSTableReader ( descriptor , 
 components , 
 metadata , 
 partitioner , 
 - null , 
 - null , 
 - null , 
 - null , 
 System . currentTimeMillis ( ) , 
 sstableMetadata ) ; 
 
 @ @ - 206 , 6 + 198 , 30 @ @ public class SSTableReader extends SSTable 
 return sstable ; 
 } 
 
 + private static SSTableMetadata openMetadata ( Descriptor descriptor , Set < Component > components , IPartitioner partitioner ) throws IOException 
 + { 
 + assert partitioner ! = null ; 
 + / / Minimum components without which we can ' t do anything 
 + assert components . contains ( Component . DATA ) : " Data component is missing for sstable " + descriptor ; 
 + assert components . contains ( Component . PRIMARY _ INDEX ) : " Primary index component is missing for sstable " + descriptor ; 
 + 
 + logger . info ( " Opening { } ( { } bytes ) " , descriptor , new File ( descriptor . filenameFor ( COMPONENT _ DATA ) ) . length ( ) ) ; 
 + 
 + SSTableMetadata sstableMetadata = SSTableMetadata . serializer . deserialize ( descriptor ) ; 
 + 
 + / / Check if sstable is created using same partitioner . 
 + / / Partitioner can be null , which indicates older version of sstable or no stats available . 
 + / / In that case , we skip the check . 
 + String partitionerName = partitioner . getClass ( ) . getCanonicalName ( ) ; 
 + if ( sstableMetadata . partitioner ! = null & & ! partitionerName . equals ( sstableMetadata . partitioner ) ) 
 + { 
 + logger . error ( String . format ( " Cannot open % s ; partitioner % s does not match system partitioner % s . Note that the default partitioner starting with Cassandra 1 . 2 is Murmur3Partitioner , so you will need to edit that to match your old partitioner if upgrading . " , 
 + descriptor , sstableMetadata . partitioner , partitionerName ) ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + return sstableMetadata ; 
 + } 
 + 
 public static void logOpenException ( Descriptor descriptor , IOException e ) 
 { 
 if ( e instanceof FileNotFoundException ) 
 @ @ - 214 , 9 + 230 , 9 @ @ public class SSTableReader extends SSTable 
 logger . error ( " Corrupt sstable " + descriptor + " ; skipped " , e ) ; 
 } 
 
 - public static Collection < SSTableReader > batchOpen ( Set < Map . Entry < Descriptor , Set < Component > > > entries , 
 - final CFMetaData metadata , 
 - final IPartitioner partitioner ) 
 + public static Collection < SSTableReader > openAll ( Set < Map . Entry < Descriptor , Set < Component > > > entries , 
 + final CFMetaData metadata , 
 + final IPartitioner partitioner ) 
 { 
 final Collection < SSTableReader > sstables = new LinkedBlockingQueue < SSTableReader > ( ) ; 
 
 @ @ - 287 , 6 + 303 , 20 @ @ public class SSTableReader extends SSTable 
 Set < Component > components , 
 CFMetaData metadata , 
 IPartitioner partitioner , 
 + long maxDataAge , 
 + SSTableMetadata sstableMetadata ) 
 + { 
 + super ( desc , components , metadata , partitioner ) ; 
 + this . sstableMetadata = sstableMetadata ; 
 + this . maxDataAge = maxDataAge ; 
 + 
 + this . deletingTask = new SSTableDeletingTask ( this ) ; 
 + } 
 + 
 + private SSTableReader ( Descriptor desc , 
 + Set < Component > components , 
 + CFMetaData metadata , 
 + IPartitioner partitioner , 
 SegmentedFile ifile , 
 SegmentedFile dfile , 
 IndexSummary indexSummary , 
 @ @ - 294 , 15 + 324 , 12 @ @ public class SSTableReader extends SSTable 
 long maxDataAge , 
 SSTableMetadata sstableMetadata ) 
 { 
 - super ( desc , components , metadata , partitioner ) ; 
 - this . sstableMetadata = sstableMetadata ; 
 - this . maxDataAge = maxDataAge ; 
 + this ( desc , components , metadata , partitioner , maxDataAge , sstableMetadata ) ; 
 
 this . ifile = ifile ; 
 this . dfile = dfile ; 
 this . indexSummary = indexSummary ; 
 this . bf = bloomFilter ; 
 - this . deletingTask = new SSTableDeletingTask ( this ) ; 
 } 
 
 public void setTrackedBy ( DataTracker tracker ) 
 @ @ - 361 , 16 + 388 , 55 @ @ public class SSTableReader extends SSTable 
 { 
 SegmentedFile . Builder ibuilder = SegmentedFile . getBuilder ( DatabaseDescriptor . getIndexAccessMode ( ) ) ; 
 SegmentedFile . Builder dbuilder = compression 
 - ? SegmentedFile . getCompressedBuilder ( ) 
 - : SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) ) ; 
 + ? SegmentedFile . getCompressedBuilder ( ) 
 + : SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) ) ; 
 + 
 
 + boolean summaryLoaded = loadSummary ( this , ibuilder , dbuilder , metadata ) ; 
 + if ( recreateBloomFilter | | ! summaryLoaded ) 
 + buildSummary ( recreateBloomFilter , ibuilder , dbuilder , summaryLoaded ) ; 
 + 
 + ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; 
 + dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; 
 + if ( recreateBloomFilter | | ! summaryLoaded ) / / save summary information to disk 
 + saveSummary ( this , ibuilder , dbuilder ) ; 
 + } 
 + 
 + / * * 
 + * A simplified load that creates a minimal partition index 
 + * / 
 + private void loadForBatch ( ) throws IOException 
 + { 
 + / / force buffered i / o in non - compressed mode so we don ' t need to worry about mmap segments 
 + SegmentedFile . Builder ibuilder = new BufferedSegmentedFile . Builder ( ) ; 
 + SegmentedFile . Builder dbuilder = compression 
 + ? SegmentedFile . getCompressedBuilder ( ) 
 + : new BufferedSegmentedFile . Builder ( ) ; 
 + 
 + / / build a bare - bones IndexSummary 
 + IndexSummaryBuilder summaryBuilder = new IndexSummaryBuilder ( 1 , 1 ) ; 
 + RandomAccessReader in = RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ) ; 
 + try 
 + { 
 + first = partitioner . decorateKey ( ByteBufferUtil . readWithShortLength ( in ) ) ; 
 + summaryBuilder . maybeAddEntry ( first , 0 ) ; 
 + indexSummary = summaryBuilder . build ( partitioner ) ; 
 + } 
 + finally 
 + { 
 + FileUtils . closeQuietly ( in ) ; 
 + } 
 + 
 + last = null ; / / shouldn ' t need this for batch operations 
 + 
 + ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; 
 + dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; 
 + } 
 + 
 + private void buildSummary ( boolean recreateBloomFilter , SegmentedFile . Builder ibuilder , SegmentedFile . Builder dbuilder , boolean summaryLoaded ) throws IOException 
 + { 
 / / we read the positions in a BRAF so we don ' t have to worry about an entry spanning a mmap boundary . 
 RandomAccessReader primaryIndex = RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ) ; 
 - 
 - / / try to load summaries from the disk and check if we need 
 - / / to read primary index because we should re - create a BloomFilter or pre - load KeyCache 
 - final boolean summaryLoaded = loadSummary ( this , ibuilder , dbuilder , metadata ) ; 
 - final boolean readIndex = recreateBloomFilter | | ! summaryLoaded ; 
 try 
 { 
 long indexSize = primaryIndex . length ( ) ; 
 @ @ - 387 , 7 + 453 , 7 @ @ public class SSTableReader extends SSTable 
 summaryBuilder = new IndexSummaryBuilder ( estimatedKeys , metadata . getIndexInterval ( ) ) ; 
 
 long indexPosition ; 
 - while ( readIndex & & ( indexPosition = primaryIndex . getFilePointer ( ) ) ! = indexSize ) 
 + while ( ( indexPosition = primaryIndex . getFilePointer ( ) ) ! = indexSize ) 
 { 
 ByteBuffer key = ByteBufferUtil . readWithShortLength ( primaryIndex ) ; 
 RowIndexEntry indexEntry = RowIndexEntry . serializer . deserialize ( primaryIndex , descriptor . version ) ; 
 @ @ - 418 , 12 + 484 , 6 @ @ public class SSTableReader extends SSTable 
 
 first = getMinimalKey ( first ) ; 
 last = getMinimalKey ( last ) ; 
 - / / finalize the load . 
 - / / finalize the state of the reader 
 - ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; 
 - dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; 
 - if ( readIndex ) / / save summary information to disk 
 - saveSummary ( this , ibuilder , dbuilder ) ; 
 } 
 
 public static boolean loadSummary ( SSTableReader reader , SegmentedFile . Builder ibuilder , SegmentedFile . Builder dbuilder , CFMetaData metadata )
