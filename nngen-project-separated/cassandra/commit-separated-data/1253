BLEU SCORE: 0.08295193507109855

TEST MSG: ( cqlsh ) allow custom time _ format for COPY TO
GENERATED MSG: cqlsh : add a COPY TO command

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9a82780 . . 1338c6f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 12 <nl> + * ( cqlsh ) allow custom time _ format for COPY TO ( CASSANDRA - 8970 ) <nl> * Don ' t allow startup if the node ' s rack has changed ( CASSANDRA - 10242 ) <nl> * ( cqlsh ) show partial trace if incomplete after max _ trace _ wait ( CASSANDRA - 7645 ) <nl> <nl> diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index 2376d43 . . 21f8ffe 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 409 , 7 + 409 , 7 @ @ def complete _ copy _ column _ names ( ctxt , cqlsh ) : <nl> return set ( colnames [ 1 : ] ) - set ( existcols ) <nl> <nl> <nl> - COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' , ' ENCODING ' , ' NULL ' ) <nl> + COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' , ' ENCODING ' , ' TIMEFORMAT ' , ' NULL ' ) <nl> <nl> <nl> @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optnames ' ) <nl> @ @ - 419 , 6 + 419 , 7 @ @ def complete _ copy _ options ( ctxt , cqlsh ) : <nl> opts = set ( COPY _ OPTIONS ) - set ( optnames ) <nl> if direction = = ' FROM ' : <nl> opts - = ( ' ENCODING ' , ) <nl> + opts - = ( ' TIMEFORMAT ' , ) <nl> return opts <nl> <nl> <nl> @ @ - 1499 , 12 + 1500 , 14 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> Available options and defaults : <nl> <nl> - DELIMITER = ' , ' - character that appears between records <nl> - QUOTE = ' " ' - quoting character to be used to quote fields <nl> - ESCAPE = ' \ ' - character to appear before the QUOTE char when quoted <nl> - HEADER = false - whether to ignore the first line <nl> - NULL = ' ' - string that represents a null value <nl> - ENCODING = ' utf8 ' - encoding for CSV output ( COPY TO only ) <nl> + DELIMITER = ' , ' - character that appears between records <nl> + QUOTE = ' " ' - quoting character to be used to quote fields <nl> + ESCAPE = ' \ ' - character to appear before the QUOTE char when quoted <nl> + HEADER = false - whether to ignore the first line <nl> + NULL = ' ' - string that represents a null value <nl> + ENCODING = ' utf8 ' - encoding for CSV output ( COPY TO only ) <nl> + TIME _ FORMAT = - timestamp strftime format ( COPY TO only ) <nl> + ' % Y - % m - % d % H : % M : % S % z ' defaults to time _ format value in cqlshrc <nl> <nl> When entering CSV data on STDIN , you can use the sequence " \ . " <nl> on a line by itself to end the data input . <nl> @ @ - 1802 , 6 + 1805 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> def perform _ csv _ export ( self , ks , cf , columns , fname , opts ) : <nl> dialect _ options = self . csv _ dialect _ defaults . copy ( ) <nl> + <nl> if ' quote ' in opts : <nl> dialect _ options [ ' quotechar ' ] = opts . pop ( ' quote ' ) <nl> if ' escape ' in opts : <nl> @ @ - 1811 , 6 + 1815 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> encoding = opts . pop ( ' encoding ' , ' utf8 ' ) <nl> nullval = opts . pop ( ' null ' , ' ' ) <nl> header = bool ( opts . pop ( ' header ' , ' ' ) . lower ( ) = = ' true ' ) <nl> + timestamp _ format = opts . pop ( ' time _ format ' , self . display _ timestamp _ format ) <nl> if dialect _ options [ ' quotechar ' ] = = dialect _ options [ ' escapechar ' ] : <nl> dialect _ options [ ' doublequote ' ] = True <nl> del dialect _ options [ ' escapechar ' ] <nl> @ @ - 1833 , 7 + 1838 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> meter = RateMeter ( 10000 ) <nl> try : <nl> - <nl> + dtformats = DateTimeFormat ( timestamp _ format , self . display _ date _ format , self . display _ nanotime _ format ) <nl> dump = self . prep _ export _ dump ( ks , cf , columns ) <nl> writer = csv . writer ( csvdest , * * dialect _ options ) <nl> if header : <nl> @ @ - 1841 , 7 + 1846 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> for row in dump : <nl> fmt = lambda v : \ <nl> format _ value ( v , output _ encoding = encoding , nullval = nullval , <nl> - time _ format = self . display _ time _ format , <nl> + time _ format = dtformats , <nl> float _ precision = self . display _ float _ precision ) . strval <nl> writer . writerow ( map ( fmt , row . values ( ) ) ) <nl> meter . increment ( )
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 979e3ef . . c558c3f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 58 , 6 + 58 , 7 @ @ Merged from 1 . 0 : <nl> * Fix LCS splitting sstable base on uncompressed size ( CASSANDRA - 4419 ) <nl> * Bootstraps that fail are detected upon restart and will retry safely without <nl> needing to delete existing data first ( CASSANDRA - 4427 ) <nl> + * ( cqlsh ) add a COPY TO command to copy a CF to a CSV file ( CASSANDRA - 4434 ) <nl> <nl> <nl> 1 . 1 . 2 <nl> diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index 574d49b . . c67a818 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 224 , 7 + 224 , 8 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' <nl> <nl> < copyCommand > : : = " COPY " cf = < columnFamilyName > <nl> ( " ( " [ colnames ] = < colname > ( " , " [ colnames ] = < colname > ) * " ) " ) ? <nl> - " FROM " ( fname = < stringLiteral > | " STDIN " ) <nl> + ( dir = " FROM " ( fname = < stringLiteral > | " STDIN " ) <nl> + | dir = " TO " ( fname = < stringLiteral > | " STDOUT " ) ) <nl> ( " WITH " < copyOption > ( " AND " < copyOption > ) * ) ? <nl> ; <nl> <nl> @ @ - 303 , 12 + 304 , 16 @ @ def complete _ copy _ column _ names ( ctxt , cqlsh ) : <nl> return [ colnames [ 0 ] ] <nl> return set ( colnames [ 1 : ] ) - set ( existcols ) <nl> <nl> - COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' ) <nl> + COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' , ' ENCODING ' , ' NULL ' ) <nl> <nl> @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optnames ' ) <nl> def complete _ copy _ options ( ctxt , cqlsh ) : <nl> optnames = map ( str . upper , ctxt . get _ binding ( ' optnames ' , ( ) ) ) <nl> - return set ( COPY _ OPTIONS ) - set ( optnames ) <nl> + direction = ctxt . get _ binding ( ' dir ' ) . upper ( ) <nl> + opts = set ( COPY _ OPTIONS ) - set ( optnames ) <nl> + if direction = = ' FROM ' : <nl> + opts - = ( ' ENCODING ' , ' NULL ' ) <nl> + return opts <nl> <nl> @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optvals ' ) <nl> def complete _ copy _ opt _ values ( ctxt , cqlsh ) : <nl> @ @ - 448 , 13 + 453 , 13 @ @ def unix _ time _ from _ uuid1 ( u ) : <nl> return ( u . get _ time ( ) - 0x01B21DD213814000 ) / 10000000 . 0 <nl> <nl> def format _ value ( val , casstype , output _ encoding , addcolor = False , time _ format = ' ' , <nl> - float _ precision = 3 , colormap = DEFAULT _ VALUE _ COLORS ) : <nl> + float _ precision = 3 , colormap = DEFAULT _ VALUE _ COLORS , nullval = ' null ' ) : <nl> color = colormap [ ' default ' ] <nl> coloredval = None <nl> displaywidth = None <nl> <nl> if val is None : <nl> - bval = ' null ' <nl> + bval = nullval <nl> color = colormap [ ' error ' ] <nl> elif isinstance ( val , DecodeError ) : <nl> casstype = ' BytesType ' <nl> @ @ - 727 , 7 + 732 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> def get _ column _ names ( self , ksname , cfname ) : <nl> if ksname is None : <nl> ksname = self . current _ keyspace <nl> - if self . cqlver _ atleast ( 3 ) : <nl> + if ksname ! = ' system ' and self . cqlver _ atleast ( 3 ) : <nl> return self . get _ column _ names _ from _ layout ( ksname , cfname ) <nl> else : <nl> return self . get _ column _ names _ from _ cfdef ( ksname , cfname ) <nl> @ @ - 1433 , 6 + 1438 , 9 @ @ class Shell ( cmd . Cmd ) : <nl> COPY < table _ name > [ ( column [ , . . . ] ) ] <nl> FROM ( ' < filename > ' | STDIN ) <nl> [ WITH < option > = ' value ' [ AND . . . ] ] ; <nl> + COPY < table _ name > [ ( column [ , . . . ] ) ] <nl> + TO ( ' < filename > ' | STDOUT ) <nl> + [ WITH < option > = ' value ' [ AND . . . ] ] ; <nl> <nl> Available options and defaults : <nl> <nl> @ @ - 1440 , 6 + 1448 , 8 @ @ class Shell ( cmd . Cmd ) : <nl> QUOTE = ' " ' - quoting character to be used to quote fields <nl> ESCAPE = ' \ ' - character to appear before the QUOTE char when quoted <nl> HEADER = false - whether to ignore the first line <nl> + ENCODING = ' utf8 ' - encoding for CSV output ( COPY TO only ) <nl> + NULL = ' ' - string that represents a null value ( COPY TO only ) <nl> <nl> When entering CSV data on STDIN , you can use the sequence " \ . " <nl> on a line by itself to end the data input . <nl> @ @ - 1448 , 12 + 1458 , 11 @ @ class Shell ( cmd . Cmd ) : <nl> ks = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) <nl> if ks is None : <nl> ks = self . current _ keyspace <nl> + if ks is None : <nl> + raise NoKeyspaceError ( " Not in any keyspace . " ) <nl> cf = self . cql _ unprotect _ name ( parsed . get _ binding ( ' cfname ' ) ) <nl> columns = parsed . get _ binding ( ' colnames ' , None ) <nl> - if columns is None : <nl> - # default to all known columns <nl> - columns = self . get _ column _ names ( ks , cf ) <nl> - else : <nl> + if columns is not None : <nl> columns = map ( self . cql _ unprotect _ name , columns ) <nl> fname = parsed . get _ binding ( ' fname ' , None ) <nl> if fname is not None : <nl> @ @ - 1462 , 14 + 1471 , 20 @ @ class Shell ( cmd . Cmd ) : <nl> copyoptvals = map ( self . cql _ unprotect _ value , parsed . get _ binding ( ' optvals ' , ( ) ) ) <nl> opts = dict ( zip ( copyoptnames , copyoptvals ) ) <nl> <nl> - # when / if COPY TO is supported , this would be a good place to branch <nl> - # on direction . <nl> - <nl> timestart = time . time ( ) <nl> - rows = self . perform _ csv _ import ( ks , cf , columns , fname , opts ) <nl> - timeend = time . time ( ) <nl> <nl> - print " % d rows imported in % s . " % ( rows , describe _ interval ( timeend - timestart ) ) <nl> + direction = parsed . get _ binding ( ' dir ' ) . upper ( ) <nl> + if direction = = ' FROM ' : <nl> + rows = self . perform _ csv _ import ( ks , cf , columns , fname , opts ) <nl> + verb = ' imported ' <nl> + elif direction = = ' TO ' : <nl> + rows = self . perform _ csv _ export ( ks , cf , columns , fname , opts ) <nl> + verb = ' exported ' <nl> + else : <nl> + raise SyntaxError ( " Unknown direction % s " % direction ) <nl> + <nl> + timeend = time . time ( ) <nl> + print " % d rows % s in % s . " % ( rows , verb , describe _ interval ( timeend - timestart ) ) <nl> <nl> def perform _ csv _ import ( self , ks , cf , columns , fname , opts ) : <nl> dialect _ options = self . csv _ dialect _ defaults . copy ( ) <nl> @ @ - 1483 , 7 + 1498 , 6 @ @ class Shell ( cmd . Cmd ) : <nl> if dialect _ options [ ' quotechar ' ] = = dialect _ options [ ' escapechar ' ] : <nl> dialect _ options [ ' doublequote ' ] = True <nl> del dialect _ options [ ' escapechar ' ] <nl> - <nl> if opts : <nl> self . printerr ( ' Unrecognized COPY FROM options : % s ' <nl> % ' , ' . join ( opts . keys ( ) ) ) <nl> @ @ - 1496 , 15 + 1510 , 15 @ @ class Shell ( cmd . Cmd ) : <nl> else : <nl> do _ close = True <nl> try : <nl> - linesource = open ( fname , ' r ' ) <nl> + linesource = open ( fname , ' rb ' ) <nl> except IOError , e : <nl> self . printerr ( " Can ' t open % r for reading : % s " % ( fname , e ) ) <nl> return 0 <nl> - if header : <nl> - linesource . next ( ) <nl> - <nl> - prepq = self . prep _ import _ insert ( ks , cf , columns ) <nl> try : <nl> + if header : <nl> + linesource . next ( ) <nl> + prepq = self . prep _ import _ insert ( ks , cf , columns ) <nl> + rownum = - 1 <nl> reader = csv . reader ( linesource , * * dialect _ options ) <nl> for rownum , row in enumerate ( reader ) : <nl> if len ( row ) ! = len ( columns ) : <nl> @ @ - 1525 , 6 + 1539 , 10 @ @ class Shell ( cmd . Cmd ) : <nl> return rownum + 1 <nl> <nl> def prep _ import _ insert ( self , ks , cf , columns ) : <nl> + if columns is None : <nl> + # default to all known columns <nl> + columns = self . get _ column _ names ( ks , cf ) <nl> + <nl> # would be nice to be able to use a prepared query here , but in order <nl> # to use that interface , we ' d need to have all the input as native <nl> # values already , reading them from text just like the various <nl> @ @ - 1543 , 6 + 1561 , 70 @ @ class Shell ( cmd . Cmd ) : <nl> print " Import using CQL : % s " % cql <nl> return self . perform _ statement ( cql ) <nl> <nl> + def perform _ csv _ export ( self , ks , cf , columns , fname , opts ) : <nl> + dialect _ options = self . csv _ dialect _ defaults . copy ( ) <nl> + if ' quote ' in opts : <nl> + dialect _ options [ ' quotechar ' ] = opts . pop ( ' quote ' ) <nl> + if ' escape ' in opts : <nl> + dialect _ options [ ' escapechar ' ] = opts . pop ( ' escape ' ) <nl> + if ' delimiter ' in opts : <nl> + dialect _ options [ ' delimiter ' ] = opts . pop ( ' delimiter ' ) <nl> + encoding = opts . pop ( ' encoding ' , ' utf8 ' ) <nl> + nullval = opts . pop ( ' null ' , ' ' ) <nl> + header = bool ( opts . pop ( ' header ' , ' ' ) . lower ( ) = = ' true ' ) <nl> + if dialect _ options [ ' quotechar ' ] = = dialect _ options [ ' escapechar ' ] : <nl> + dialect _ options [ ' doublequote ' ] = True <nl> + del dialect _ options [ ' escapechar ' ] <nl> + <nl> + if opts : <nl> + self . printerr ( ' Unrecognized COPY TO options : % s ' <nl> + % ' , ' . join ( opts . keys ( ) ) ) <nl> + return 0 <nl> + <nl> + if fname is None : <nl> + do _ close = False <nl> + csvdest = sys . stdout <nl> + else : <nl> + do _ close = True <nl> + try : <nl> + csvdest = open ( fname , ' wb ' ) <nl> + except IOError , e : <nl> + self . printerr ( " Can ' t open % r for writing : % s " % ( fname , e ) ) <nl> + return 0 <nl> + try : <nl> + self . prep _ export _ dump ( ks , cf , columns ) <nl> + writer = csv . writer ( csvdest , * * dialect _ options ) <nl> + if header : <nl> + writer . writerow ( [ d [ 0 ] for d in self . cursor . description ] ) <nl> + rows = 0 <nl> + while True : <nl> + row = self . cursor . fetchone ( ) <nl> + if row is None : <nl> + break <nl> + fmt = lambda v , d : \ <nl> + format _ value ( v , d [ 1 ] , output _ encoding = encoding , nullval = nullval , <nl> + time _ format = self . display _ time _ format , <nl> + float _ precision = self . display _ float _ precision ) . strval <nl> + writer . writerow ( map ( fmt , row , self . cursor . description ) ) <nl> + rows + = 1 <nl> + finally : <nl> + if do _ close : <nl> + csvdest . close ( ) <nl> + return rows <nl> + <nl> + def prep _ export _ dump ( self , ks , cf , columns ) : <nl> + if columns is None : <nl> + columnlist = ' * ' <nl> + else : <nl> + columnlist = ' , ' . join ( map ( self . cql _ protect _ name , columns ) ) <nl> + # this limit is pretty awful . would be better to use row - key - paging , so <nl> + # that the dump could be pretty easily aborted if necessary , but that <nl> + # can be kind of tricky with cql3 . Punt for now , until the real cursor <nl> + # API is added in CASSANDRA - 4415 . <nl> + query = ' SELECT % s FROM % s . % s LIMIT 99999999 ' \ <nl> + % ( columnlist , self . cql _ protect _ name ( ks ) , self . cql _ protect _ name ( cf ) ) <nl> + self . cursor . execute ( query ) <nl> + <nl> def do _ show ( self , parsed ) : <nl> " " " <nl> SHOW [ cqlsh only ]

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9a82780 . . 1338c6f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 12 
 + * ( cqlsh ) allow custom time _ format for COPY TO ( CASSANDRA - 8970 ) 
 * Don ' t allow startup if the node ' s rack has changed ( CASSANDRA - 10242 ) 
 * ( cqlsh ) show partial trace if incomplete after max _ trace _ wait ( CASSANDRA - 7645 ) 
 
 diff - - git a / bin / cqlsh b / bin / cqlsh 
 index 2376d43 . . 21f8ffe 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 409 , 7 + 409 , 7 @ @ def complete _ copy _ column _ names ( ctxt , cqlsh ) : 
 return set ( colnames [ 1 : ] ) - set ( existcols ) 
 
 
 - COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' , ' ENCODING ' , ' NULL ' ) 
 + COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' , ' ENCODING ' , ' TIMEFORMAT ' , ' NULL ' ) 
 
 
 @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optnames ' ) 
 @ @ - 419 , 6 + 419 , 7 @ @ def complete _ copy _ options ( ctxt , cqlsh ) : 
 opts = set ( COPY _ OPTIONS ) - set ( optnames ) 
 if direction = = ' FROM ' : 
 opts - = ( ' ENCODING ' , ) 
 + opts - = ( ' TIMEFORMAT ' , ) 
 return opts 
 
 
 @ @ - 1499 , 12 + 1500 , 14 @ @ class Shell ( cmd . Cmd ) : 
 
 Available options and defaults : 
 
 - DELIMITER = ' , ' - character that appears between records 
 - QUOTE = ' " ' - quoting character to be used to quote fields 
 - ESCAPE = ' \ ' - character to appear before the QUOTE char when quoted 
 - HEADER = false - whether to ignore the first line 
 - NULL = ' ' - string that represents a null value 
 - ENCODING = ' utf8 ' - encoding for CSV output ( COPY TO only ) 
 + DELIMITER = ' , ' - character that appears between records 
 + QUOTE = ' " ' - quoting character to be used to quote fields 
 + ESCAPE = ' \ ' - character to appear before the QUOTE char when quoted 
 + HEADER = false - whether to ignore the first line 
 + NULL = ' ' - string that represents a null value 
 + ENCODING = ' utf8 ' - encoding for CSV output ( COPY TO only ) 
 + TIME _ FORMAT = - timestamp strftime format ( COPY TO only ) 
 + ' % Y - % m - % d % H : % M : % S % z ' defaults to time _ format value in cqlshrc 
 
 When entering CSV data on STDIN , you can use the sequence " \ . " 
 on a line by itself to end the data input . 
 @ @ - 1802 , 6 + 1805 , 7 @ @ class Shell ( cmd . Cmd ) : 
 
 def perform _ csv _ export ( self , ks , cf , columns , fname , opts ) : 
 dialect _ options = self . csv _ dialect _ defaults . copy ( ) 
 + 
 if ' quote ' in opts : 
 dialect _ options [ ' quotechar ' ] = opts . pop ( ' quote ' ) 
 if ' escape ' in opts : 
 @ @ - 1811 , 6 + 1815 , 7 @ @ class Shell ( cmd . Cmd ) : 
 encoding = opts . pop ( ' encoding ' , ' utf8 ' ) 
 nullval = opts . pop ( ' null ' , ' ' ) 
 header = bool ( opts . pop ( ' header ' , ' ' ) . lower ( ) = = ' true ' ) 
 + timestamp _ format = opts . pop ( ' time _ format ' , self . display _ timestamp _ format ) 
 if dialect _ options [ ' quotechar ' ] = = dialect _ options [ ' escapechar ' ] : 
 dialect _ options [ ' doublequote ' ] = True 
 del dialect _ options [ ' escapechar ' ] 
 @ @ - 1833 , 7 + 1838 , 7 @ @ class Shell ( cmd . Cmd ) : 
 
 meter = RateMeter ( 10000 ) 
 try : 
 - 
 + dtformats = DateTimeFormat ( timestamp _ format , self . display _ date _ format , self . display _ nanotime _ format ) 
 dump = self . prep _ export _ dump ( ks , cf , columns ) 
 writer = csv . writer ( csvdest , * * dialect _ options ) 
 if header : 
 @ @ - 1841 , 7 + 1846 , 7 @ @ class Shell ( cmd . Cmd ) : 
 for row in dump : 
 fmt = lambda v : \ 
 format _ value ( v , output _ encoding = encoding , nullval = nullval , 
 - time _ format = self . display _ time _ format , 
 + time _ format = dtformats , 
 float _ precision = self . display _ float _ precision ) . strval 
 writer . writerow ( map ( fmt , row . values ( ) ) ) 
 meter . increment ( )

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 979e3ef . . c558c3f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 58 , 6 + 58 , 7 @ @ Merged from 1 . 0 : 
 * Fix LCS splitting sstable base on uncompressed size ( CASSANDRA - 4419 ) 
 * Bootstraps that fail are detected upon restart and will retry safely without 
 needing to delete existing data first ( CASSANDRA - 4427 ) 
 + * ( cqlsh ) add a COPY TO command to copy a CF to a CSV file ( CASSANDRA - 4434 ) 
 
 
 1 . 1 . 2 
 diff - - git a / bin / cqlsh b / bin / cqlsh 
 index 574d49b . . c67a818 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 224 , 7 + 224 , 8 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' 
 
 < copyCommand > : : = " COPY " cf = < columnFamilyName > 
 ( " ( " [ colnames ] = < colname > ( " , " [ colnames ] = < colname > ) * " ) " ) ? 
 - " FROM " ( fname = < stringLiteral > | " STDIN " ) 
 + ( dir = " FROM " ( fname = < stringLiteral > | " STDIN " ) 
 + | dir = " TO " ( fname = < stringLiteral > | " STDOUT " ) ) 
 ( " WITH " < copyOption > ( " AND " < copyOption > ) * ) ? 
 ; 
 
 @ @ - 303 , 12 + 304 , 16 @ @ def complete _ copy _ column _ names ( ctxt , cqlsh ) : 
 return [ colnames [ 0 ] ] 
 return set ( colnames [ 1 : ] ) - set ( existcols ) 
 
 - COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' ) 
 + COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' , ' ENCODING ' , ' NULL ' ) 
 
 @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optnames ' ) 
 def complete _ copy _ options ( ctxt , cqlsh ) : 
 optnames = map ( str . upper , ctxt . get _ binding ( ' optnames ' , ( ) ) ) 
 - return set ( COPY _ OPTIONS ) - set ( optnames ) 
 + direction = ctxt . get _ binding ( ' dir ' ) . upper ( ) 
 + opts = set ( COPY _ OPTIONS ) - set ( optnames ) 
 + if direction = = ' FROM ' : 
 + opts - = ( ' ENCODING ' , ' NULL ' ) 
 + return opts 
 
 @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optvals ' ) 
 def complete _ copy _ opt _ values ( ctxt , cqlsh ) : 
 @ @ - 448 , 13 + 453 , 13 @ @ def unix _ time _ from _ uuid1 ( u ) : 
 return ( u . get _ time ( ) - 0x01B21DD213814000 ) / 10000000 . 0 
 
 def format _ value ( val , casstype , output _ encoding , addcolor = False , time _ format = ' ' , 
 - float _ precision = 3 , colormap = DEFAULT _ VALUE _ COLORS ) : 
 + float _ precision = 3 , colormap = DEFAULT _ VALUE _ COLORS , nullval = ' null ' ) : 
 color = colormap [ ' default ' ] 
 coloredval = None 
 displaywidth = None 
 
 if val is None : 
 - bval = ' null ' 
 + bval = nullval 
 color = colormap [ ' error ' ] 
 elif isinstance ( val , DecodeError ) : 
 casstype = ' BytesType ' 
 @ @ - 727 , 7 + 732 , 7 @ @ class Shell ( cmd . Cmd ) : 
 def get _ column _ names ( self , ksname , cfname ) : 
 if ksname is None : 
 ksname = self . current _ keyspace 
 - if self . cqlver _ atleast ( 3 ) : 
 + if ksname ! = ' system ' and self . cqlver _ atleast ( 3 ) : 
 return self . get _ column _ names _ from _ layout ( ksname , cfname ) 
 else : 
 return self . get _ column _ names _ from _ cfdef ( ksname , cfname ) 
 @ @ - 1433 , 6 + 1438 , 9 @ @ class Shell ( cmd . Cmd ) : 
 COPY < table _ name > [ ( column [ , . . . ] ) ] 
 FROM ( ' < filename > ' | STDIN ) 
 [ WITH < option > = ' value ' [ AND . . . ] ] ; 
 + COPY < table _ name > [ ( column [ , . . . ] ) ] 
 + TO ( ' < filename > ' | STDOUT ) 
 + [ WITH < option > = ' value ' [ AND . . . ] ] ; 
 
 Available options and defaults : 
 
 @ @ - 1440 , 6 + 1448 , 8 @ @ class Shell ( cmd . Cmd ) : 
 QUOTE = ' " ' - quoting character to be used to quote fields 
 ESCAPE = ' \ ' - character to appear before the QUOTE char when quoted 
 HEADER = false - whether to ignore the first line 
 + ENCODING = ' utf8 ' - encoding for CSV output ( COPY TO only ) 
 + NULL = ' ' - string that represents a null value ( COPY TO only ) 
 
 When entering CSV data on STDIN , you can use the sequence " \ . " 
 on a line by itself to end the data input . 
 @ @ - 1448 , 12 + 1458 , 11 @ @ class Shell ( cmd . Cmd ) : 
 ks = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) 
 if ks is None : 
 ks = self . current _ keyspace 
 + if ks is None : 
 + raise NoKeyspaceError ( " Not in any keyspace . " ) 
 cf = self . cql _ unprotect _ name ( parsed . get _ binding ( ' cfname ' ) ) 
 columns = parsed . get _ binding ( ' colnames ' , None ) 
 - if columns is None : 
 - # default to all known columns 
 - columns = self . get _ column _ names ( ks , cf ) 
 - else : 
 + if columns is not None : 
 columns = map ( self . cql _ unprotect _ name , columns ) 
 fname = parsed . get _ binding ( ' fname ' , None ) 
 if fname is not None : 
 @ @ - 1462 , 14 + 1471 , 20 @ @ class Shell ( cmd . Cmd ) : 
 copyoptvals = map ( self . cql _ unprotect _ value , parsed . get _ binding ( ' optvals ' , ( ) ) ) 
 opts = dict ( zip ( copyoptnames , copyoptvals ) ) 
 
 - # when / if COPY TO is supported , this would be a good place to branch 
 - # on direction . 
 - 
 timestart = time . time ( ) 
 - rows = self . perform _ csv _ import ( ks , cf , columns , fname , opts ) 
 - timeend = time . time ( ) 
 
 - print " % d rows imported in % s . " % ( rows , describe _ interval ( timeend - timestart ) ) 
 + direction = parsed . get _ binding ( ' dir ' ) . upper ( ) 
 + if direction = = ' FROM ' : 
 + rows = self . perform _ csv _ import ( ks , cf , columns , fname , opts ) 
 + verb = ' imported ' 
 + elif direction = = ' TO ' : 
 + rows = self . perform _ csv _ export ( ks , cf , columns , fname , opts ) 
 + verb = ' exported ' 
 + else : 
 + raise SyntaxError ( " Unknown direction % s " % direction ) 
 + 
 + timeend = time . time ( ) 
 + print " % d rows % s in % s . " % ( rows , verb , describe _ interval ( timeend - timestart ) ) 
 
 def perform _ csv _ import ( self , ks , cf , columns , fname , opts ) : 
 dialect _ options = self . csv _ dialect _ defaults . copy ( ) 
 @ @ - 1483 , 7 + 1498 , 6 @ @ class Shell ( cmd . Cmd ) : 
 if dialect _ options [ ' quotechar ' ] = = dialect _ options [ ' escapechar ' ] : 
 dialect _ options [ ' doublequote ' ] = True 
 del dialect _ options [ ' escapechar ' ] 
 - 
 if opts : 
 self . printerr ( ' Unrecognized COPY FROM options : % s ' 
 % ' , ' . join ( opts . keys ( ) ) ) 
 @ @ - 1496 , 15 + 1510 , 15 @ @ class Shell ( cmd . Cmd ) : 
 else : 
 do _ close = True 
 try : 
 - linesource = open ( fname , ' r ' ) 
 + linesource = open ( fname , ' rb ' ) 
 except IOError , e : 
 self . printerr ( " Can ' t open % r for reading : % s " % ( fname , e ) ) 
 return 0 
 - if header : 
 - linesource . next ( ) 
 - 
 - prepq = self . prep _ import _ insert ( ks , cf , columns ) 
 try : 
 + if header : 
 + linesource . next ( ) 
 + prepq = self . prep _ import _ insert ( ks , cf , columns ) 
 + rownum = - 1 
 reader = csv . reader ( linesource , * * dialect _ options ) 
 for rownum , row in enumerate ( reader ) : 
 if len ( row ) ! = len ( columns ) : 
 @ @ - 1525 , 6 + 1539 , 10 @ @ class Shell ( cmd . Cmd ) : 
 return rownum + 1 
 
 def prep _ import _ insert ( self , ks , cf , columns ) : 
 + if columns is None : 
 + # default to all known columns 
 + columns = self . get _ column _ names ( ks , cf ) 
 + 
 # would be nice to be able to use a prepared query here , but in order 
 # to use that interface , we ' d need to have all the input as native 
 # values already , reading them from text just like the various 
 @ @ - 1543 , 6 + 1561 , 70 @ @ class Shell ( cmd . Cmd ) : 
 print " Import using CQL : % s " % cql 
 return self . perform _ statement ( cql ) 
 
 + def perform _ csv _ export ( self , ks , cf , columns , fname , opts ) : 
 + dialect _ options = self . csv _ dialect _ defaults . copy ( ) 
 + if ' quote ' in opts : 
 + dialect _ options [ ' quotechar ' ] = opts . pop ( ' quote ' ) 
 + if ' escape ' in opts : 
 + dialect _ options [ ' escapechar ' ] = opts . pop ( ' escape ' ) 
 + if ' delimiter ' in opts : 
 + dialect _ options [ ' delimiter ' ] = opts . pop ( ' delimiter ' ) 
 + encoding = opts . pop ( ' encoding ' , ' utf8 ' ) 
 + nullval = opts . pop ( ' null ' , ' ' ) 
 + header = bool ( opts . pop ( ' header ' , ' ' ) . lower ( ) = = ' true ' ) 
 + if dialect _ options [ ' quotechar ' ] = = dialect _ options [ ' escapechar ' ] : 
 + dialect _ options [ ' doublequote ' ] = True 
 + del dialect _ options [ ' escapechar ' ] 
 + 
 + if opts : 
 + self . printerr ( ' Unrecognized COPY TO options : % s ' 
 + % ' , ' . join ( opts . keys ( ) ) ) 
 + return 0 
 + 
 + if fname is None : 
 + do _ close = False 
 + csvdest = sys . stdout 
 + else : 
 + do _ close = True 
 + try : 
 + csvdest = open ( fname , ' wb ' ) 
 + except IOError , e : 
 + self . printerr ( " Can ' t open % r for writing : % s " % ( fname , e ) ) 
 + return 0 
 + try : 
 + self . prep _ export _ dump ( ks , cf , columns ) 
 + writer = csv . writer ( csvdest , * * dialect _ options ) 
 + if header : 
 + writer . writerow ( [ d [ 0 ] for d in self . cursor . description ] ) 
 + rows = 0 
 + while True : 
 + row = self . cursor . fetchone ( ) 
 + if row is None : 
 + break 
 + fmt = lambda v , d : \ 
 + format _ value ( v , d [ 1 ] , output _ encoding = encoding , nullval = nullval , 
 + time _ format = self . display _ time _ format , 
 + float _ precision = self . display _ float _ precision ) . strval 
 + writer . writerow ( map ( fmt , row , self . cursor . description ) ) 
 + rows + = 1 
 + finally : 
 + if do _ close : 
 + csvdest . close ( ) 
 + return rows 
 + 
 + def prep _ export _ dump ( self , ks , cf , columns ) : 
 + if columns is None : 
 + columnlist = ' * ' 
 + else : 
 + columnlist = ' , ' . join ( map ( self . cql _ protect _ name , columns ) ) 
 + # this limit is pretty awful . would be better to use row - key - paging , so 
 + # that the dump could be pretty easily aborted if necessary , but that 
 + # can be kind of tricky with cql3 . Punt for now , until the real cursor 
 + # API is added in CASSANDRA - 4415 . 
 + query = ' SELECT % s FROM % s . % s LIMIT 99999999 ' \ 
 + % ( columnlist , self . cql _ protect _ name ( ks ) , self . cql _ protect _ name ( cf ) ) 
 + self . cursor . execute ( query ) 
 + 
 def do _ show ( self , parsed ) : 
 " " " 
 SHOW [ cqlsh only ]
