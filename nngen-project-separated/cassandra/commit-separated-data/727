BLEU SCORE: 0.0021412659938840044

TEST MSG: Rerun ReplicationAwareTokenAllocatorTest on failure to avoid flakiness .
GENERATED MSG: add long - test ant target for compaction speed test and larger bloom filter tests [ formerly commented out ] . patch by Stu Hood ; reviewed by Jeremy Hanna for CASSANDRA - 985

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index caecefb . . 8f6997b 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 9 <nl> + * Rerun ReplicationAwareTokenAllocatorTest on failure to avoid flakiness ( CASSANDRA - 12277 ) <nl> * Exception when computing read - repair for range tombstones ( CASSANDRA - 12263 ) <nl> * Lost counter writes in compact table and static columns ( CASSANDRA - 12219 ) <nl> * AssertionError with MVs on updating a row that isn ' t indexed due to a null value ( CASSANDRA - 12247 ) <nl> diff - - git a / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java b / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java <nl> index 0a27e1c . . 1b36c55 100644 <nl> - - - a / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java <nl> + + + b / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . commons . math3 . stat . descriptive . SummaryStatistics ; <nl> <nl> import org . junit . Test ; <nl> <nl> + import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> import org . apache . cassandra . dht . Token ; <nl> <nl> @ @ - 545 , 6 + 546 , 20 @ @ public class ReplicationAwareTokenAllocatorTest <nl> @ Test <nl> public void testNewCluster ( ) <nl> { <nl> + Util . flakyTest ( this : : flakyTestNewCluster , <nl> + 5 , <nl> + " It tends to fail sometimes due to the random selection of the tokens in the first few nodes . " ) ; <nl> + } <nl> + <nl> + public void flakyTestNewCluster ( ) <nl> + { <nl> + / / This test is flaky because the selection of the tokens for the first RF nodes ( which is random , with an <nl> + / / uncontrolled seed ) can sometimes cause a pathological situation where the algorithm will find a ( close to ) <nl> + / / ideal distribution of tokens for some number of nodes , which in turn will inevitably cause it to go into a <nl> + / / bad ( unacceptable to the test criteria ) distribution after adding one more node . <nl> + <nl> + / / This should happen very rarely , unless something is broken in the token allocation code . <nl> + <nl> for ( int rf = 2 ; rf < = 5 ; + + rf ) <nl> { <nl> for ( int perUnitCount = 1 ; perUnitCount < = MAX _ VNODE _ COUNT ; perUnitCount * = 4 ) <nl> diff - - git a / test / unit / org / apache / cassandra / Util . java b / test / unit / org / apache / cassandra / Util . java <nl> index 7ce8f04 . . e7b1ffa 100644 <nl> - - - a / test / unit / org / apache / cassandra / Util . java <nl> + + + b / test / unit / org / apache / cassandra / Util . java <nl> @ @ - 536 , 6 + 536 , 62 @ @ public class Util <nl> thread . join ( 10000 ) ; <nl> } <nl> <nl> + public static AssertionError runCatchingAssertionError ( Runnable test ) <nl> + { <nl> + try <nl> + { <nl> + test . run ( ) ; <nl> + return null ; <nl> + } <nl> + catch ( AssertionError e ) <nl> + { <nl> + return e ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Wrapper function used to run a test that can sometimes flake for uncontrollable reasons . <nl> + * <nl> + * If the given test fails on the first run , it is executed the given number of times again , expecting all secondary <nl> + * runs to succeed . If they do , the failure is understood as a flake and the test is treated as passing . <nl> + * <nl> + * Do not use this if the test is deterministic and its success is not influenced by external factors ( such as time , <nl> + * selection of random seed , network failures , etc . ) . If the test can be made independent of such factors , it is <nl> + * probably preferable to do so rather than use this method . <nl> + * <nl> + * @ param test The test to run . <nl> + * @ param rerunsOnFailure How many times to re - run it if it fails . All reruns must pass . <nl> + * @ param message Message to send to System . err on initial failure . <nl> + * / <nl> + public static void flakyTest ( Runnable test , int rerunsOnFailure , String message ) <nl> + { <nl> + AssertionError e = runCatchingAssertionError ( test ) ; <nl> + if ( e = = null ) <nl> + return ; / / success <nl> + System . err . format ( " Test failed . % s % n " <nl> + + " Re - running % d times to verify it isn ' t failing more often than it should . % n " <nl> + + " Failure was : % s % n " , message , rerunsOnFailure , e ) ; <nl> + e . printStackTrace ( ) ; <nl> + <nl> + int rerunsFailed = 0 ; <nl> + for ( int i = 0 ; i < rerunsOnFailure ; + + i ) <nl> + { <nl> + AssertionError t = runCatchingAssertionError ( test ) ; <nl> + if ( t ! = null ) <nl> + { <nl> + + + rerunsFailed ; <nl> + e . addSuppressed ( t ) ; <nl> + } <nl> + } <nl> + if ( rerunsFailed > 0 ) <nl> + { <nl> + System . err . format ( " Test failed in % d of the % d reruns . % n " , rerunsFailed , rerunsOnFailure ) ; <nl> + throw e ; <nl> + } <nl> + <nl> + System . err . println ( " All reruns succeeded . Failure treated as flake . " ) ; <nl> + } <nl> + <nl> / / for use with Optional in tests , can be used as an argument to orElseThrow <nl> public static Supplier < AssertionError > throwAssert ( final String message ) <nl> {
NEAREST DIFF (one line): diff - - git a / build . xml b / build . xml <nl> index d2fc678 . . 511f52d 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 42 , 6 + 42 , 7 @ @ <nl> < property name = " test . data " value = " $ { test . dir } / data " / > <nl> < property name = " test . name " value = " * Test " / > <nl> < property name = " test . unit . src " value = " $ { test . dir } / unit " / > <nl> + < property name = " test . long . src " value = " $ { test . dir } / long " / > <nl> < property name = " dist . dir " value = " $ { build . dir } / dist " / > <nl> < property name = " version " value = " 0 . 6 . 0 - rc1 " / > <nl> < property name = " final . name " value = " $ { ant . project . name } - $ { version } " / > <nl> @ @ - 348 , 10 + 349 , 10 @ @ <nl> < javac <nl> debug = " true " <nl> debuglevel = " $ { debuglevel } " <nl> - destdir = " $ { test . classes } " <nl> - > <nl> + destdir = " $ { test . classes } " > <nl> < classpath refid = " cassandra . classpath " / > <nl> < src path = " $ { test . unit . src } " / > <nl> + < src path = " $ { test . long . src } " / > <nl> < / javac > <nl> <nl> < ! - - Non - java resources needed by the test suite - - > <nl> @ @ - 360 , 30 + 361 , 42 @ @ <nl> < / copy > <nl> < / target > <nl> <nl> - < target name = " test " depends = " build - test " > <nl> - < echo message = " running tests " / > <nl> - < mkdir dir = " $ { build . test . dir } / cassandra " / > <nl> - < mkdir dir = " $ { build . test . dir } / output " / > <nl> - < junit fork = " on " failureproperty = " testfailed " maxmemory = " 1024m " > <nl> - < sysproperty key = " net . sourceforge . cobertura . datafile " file = " $ { cobertura . datafile } " / > <nl> - < formatter type = " xml " usefile = " true " / > <nl> - < formatter type = " brief " usefile = " false " / > <nl> - < jvmarg value = " - Dstorage - config = $ { test . conf } " / > <nl> - < jvmarg value = " - Dlog4j . configuration = log4j - junit . properties " / > <nl> - < jvmarg value = " - Dlegacy - sstable - root = $ { test . data } / legacy - sstables " / > <nl> - < jvmarg value = " - ea " / > <nl> - < classpath > <nl> - < path refid = " cassandra . classpath " / > <nl> - < pathelement location = " $ { test . classes } " / > <nl> - < pathelement location = " $ { cobertura . dir } / cobertura . jar " / > <nl> - < pathelement location = " $ { test . conf } " / > <nl> - < / classpath > <nl> - < batchtest todir = " $ { build . test . dir } / output " > <nl> - < fileset dir = " $ { test . classes } " includes = " * * / $ { test . name } . class " / > <nl> - < / batchtest > <nl> - < / junit > <nl> + < macrodef name = " testmacro " > <nl> + < attribute name = " suitename " / > <nl> + < attribute name = " inputdir " / > <nl> + < attribute name = " timeout " / > <nl> + < sequential > <nl> + < echo message = " running @ { suitename } tests " / > <nl> + < mkdir dir = " $ { build . test . dir } / cassandra " / > <nl> + < mkdir dir = " $ { build . test . dir } / output " / > <nl> + < junit fork = " on " failureproperty = " testfailed " maxmemory = " 1024m " timeout = " @ { timeout } " > <nl> + < sysproperty key = " net . sourceforge . cobertura . datafile " file = " $ { cobertura . datafile } " / > <nl> + < formatter type = " xml " usefile = " true " / > <nl> + < formatter type = " brief " usefile = " false " / > <nl> + < jvmarg value = " - Dstorage - config = $ { test . conf } " / > <nl> + < jvmarg value = " - Dlog4j . configuration = log4j - junit . properties " / > <nl> + < jvmarg value = " - Dlegacy - sstable - root = $ { test . data } / legacy - sstables " / > <nl> + < jvmarg value = " - ea " / > <nl> + < classpath > <nl> + < path refid = " cassandra . classpath " / > <nl> + < pathelement location = " $ { test . classes } " / > <nl> + < pathelement location = " $ { cobertura . dir } / cobertura . jar " / > <nl> + < pathelement location = " $ { test . conf } " / > <nl> + < / classpath > <nl> + < batchtest todir = " $ { build . test . dir } / output " > <nl> + < fileset dir = " @ { inputdir } " includes = " * * / $ { test . name } . java " / > <nl> + < / batchtest > <nl> + < / junit > <nl> + < fail if = " testfailed " message = " Some @ { suitename } test ( s ) failed . " / > <nl> + < / sequential > <nl> + < / macrodef > <nl> + <nl> + < target name = " test " depends = " build - test " > <nl> + < testmacro suitename = " unit " inputdir = " $ { test . unit . src } " timeout = " 30000 " / > <nl> + < / target > <nl> <nl> - < fail if = " testfailed " message = " Some test ( s ) failed . " / > <nl> + < target name = " long - test " depends = " build - test " > <nl> + < testmacro suitename = " long " inputdir = " $ { test . long . src } " timeout = " 300000 " / > <nl> < / target > <nl> 	 <nl> < ! - - instruments the classes to later create code coverage reports - - > <nl> diff - - git a / test / long / org / apache / cassandra / db / LongCompactionSpeedTest . java b / test / long / org / apache / cassandra / db / LongCompactionSpeedTest . java <nl> new file mode 100644 <nl> index 0000000 . . 0c8cff4 <nl> - - - / dev / null <nl> + + + b / test / long / org / apache / cassandra / db / LongCompactionSpeedTest . java <nl> @ @ - 0 , 0 + 1 , 109 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + package org . apache . cassandra . db ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . net . InetAddress ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + import java . util . concurrent . Future ; <nl> + import java . util . * ; <nl> + <nl> + import org . apache . cassandra . Util ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . io . sstable . SSTableReader ; <nl> + import org . apache . cassandra . io . sstable . SSTableUtils ; <nl> + import org . apache . cassandra . CleanupHelper ; <nl> + import org . apache . cassandra . db . filter . QueryPath ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + import static junit . framework . Assert . assertEquals ; <nl> + <nl> + public class LongCompactionSpeedTest extends CleanupHelper <nl> + { <nl> + public static final String TABLE1 = " Keyspace1 " ; <nl> + public static final InetAddress LOCAL = FBUtilities . getLocalAddress ( ) ; <nl> + <nl> + / * * <nl> + * Test compaction with a very wide row . <nl> + * / <nl> + @ Test <nl> + public void testCompactionWide ( ) throws Exception <nl> + { <nl> + testCompaction ( 2 , 1 , 200000 ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Test compaction with lots of skinny rows . <nl> + * / <nl> + @ Test <nl> + public void testCompactionSlim ( ) throws Exception <nl> + { <nl> + testCompaction ( 2 , 200000 , 1 ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Test compaction with lots of small sstables . <nl> + * / <nl> + @ Test <nl> + public void testCompactionMany ( ) throws Exception <nl> + { <nl> + testCompaction ( 100 , 800 , 5 ) ; <nl> + } <nl> + <nl> + protected void testCompaction ( int sstableCount , int rowsPerSSTable , int colsPerRow ) throws Exception <nl> + { <nl> + CompactionManager . instance . disableAutoCompaction ( ) ; <nl> + <nl> + Table table = Table . open ( TABLE1 ) ; <nl> + ColumnFamilyStore store = table . getColumnFamilyStore ( " Standard1 " ) ; <nl> + <nl> + ArrayList < SSTableReader > sstables = new ArrayList < SSTableReader > ( ) ; <nl> + for ( int k = 0 ; k < sstableCount ; k + + ) <nl> + { <nl> + SortedMap < String , ColumnFamily > rows = new TreeMap < String , ColumnFamily > ( ) ; <nl> + for ( int j = 0 ; j < rowsPerSSTable ; j + + ) <nl> + { <nl> + String key = String . valueOf ( j ) ; <nl> + IColumn [ ] cols = new IColumn [ colsPerRow ] ; <nl> + for ( int i = 0 ; i < colsPerRow ; i + + ) <nl> + { <nl> + / / last sstable has highest timestamps <nl> + cols [ i ] = Util . column ( String . valueOf ( i ) , String . valueOf ( i ) , k ) ; <nl> + } <nl> + rows . put ( key , SSTableUtils . createCF ( Long . MIN _ VALUE , Integer . MIN _ VALUE , cols ) ) ; <nl> + } <nl> + SSTableReader sstable = SSTableUtils . writeSSTable ( rows ) ; <nl> + sstables . add ( sstable ) ; <nl> + store . addSSTable ( sstable ) ; <nl> + } <nl> + <nl> + / / give garbage collection a bit of time to catch up <nl> + Thread . sleep ( 1000 ) ; <nl> + <nl> + long start = System . currentTimeMillis ( ) ; <nl> + CompactionManager . instance . doCompaction ( store , sstables , CompactionManager . getDefaultGCBefore ( ) ) ; <nl> + System . out . println ( String . format ( " % s : sstables = % d rowsper = % d colsper = % d : % d ms " , <nl> + this . getClass ( ) . getName ( ) , <nl> + sstableCount , <nl> + rowsPerSSTable , <nl> + colsPerRow , <nl> + System . currentTimeMillis ( ) - start ) ) ; <nl> + } <nl> + } <nl> diff - - git a / test / long / org / apache / cassandra / utils / LongBloomFilterTest . java b / test / long / org / apache / cassandra / utils / LongBloomFilterTest . java <nl> new file mode 100644 <nl> index 0000000 . . 5320187 <nl> - - - / dev / null <nl> + + + b / test / long / org / apache / cassandra / utils / LongBloomFilterTest . java <nl> @ @ - 0 , 0 + 1 , 62 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . util . Random ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + public class LongBloomFilterTest <nl> + { <nl> + public BloomFilter bf ; <nl> + <nl> + / * * <nl> + * NB : needs to run with - mx1G <nl> + * / <nl> + @ Test <nl> + public void testBigInt ( ) { <nl> + int size = 10 * 1000 * 1000 ; <nl> + bf = BloomFilter . getFilter ( size , FilterTest . spec . bucketsPerElement ) ; <nl> + FilterTest . testFalsePositives ( bf , <nl> + new KeyGenerator . IntGenerator ( size ) , <nl> + new KeyGenerator . IntGenerator ( size , size * 2 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testBigRandom ( ) { <nl> + int size = 10 * 1000 * 1000 ; <nl> + bf = BloomFilter . getFilter ( size , FilterTest . spec . bucketsPerElement ) ; <nl> + FilterTest . testFalsePositives ( bf , <nl> + new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , <nl> + new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void timeit ( ) { <nl> + int size = 300 * FilterTest . ELEMENTS ; <nl> + bf = BloomFilter . getFilter ( size , FilterTest . spec . bucketsPerElement ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) { <nl> + FilterTest . testFalsePositives ( bf , <nl> + new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , <nl> + new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; <nl> + bf . clear ( ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / db / CompactionSpeedTest . java b / test / unit / org / apache / cassandra / db / CompactionSpeedTest . java <nl> deleted file mode 100644 <nl> index c8b4e05 . . 0000000 <nl> - - - a / test / unit / org / apache / cassandra / db / CompactionSpeedTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 109 + 0 , 0 @ @ <nl> - / * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , <nl> - * software distributed under the License is distributed on an <nl> - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> - * KIND , either express or implied . See the License for the <nl> - * specific language governing permissions and limitations <nl> - * under the License . <nl> - * / <nl> - package org . apache . cassandra . db ; <nl> - <nl> - import java . io . IOException ; <nl> - import java . net . InetAddress ; <nl> - import java . util . concurrent . ExecutionException ; <nl> - import java . util . concurrent . Future ; <nl> - import java . util . * ; <nl> - <nl> - import org . apache . cassandra . Util ; <nl> - <nl> - import org . junit . Test ; <nl> - <nl> - import org . apache . cassandra . io . sstable . SSTableReader ; <nl> - import org . apache . cassandra . io . sstable . SSTableUtils ; <nl> - import org . apache . cassandra . CleanupHelper ; <nl> - import org . apache . cassandra . db . filter . QueryPath ; <nl> - import org . apache . cassandra . utils . FBUtilities ; <nl> - import static junit . framework . Assert . assertEquals ; <nl> - <nl> - public class CompactionSpeedTest extends CleanupHelper <nl> - { <nl> - public static final String TABLE1 = " Keyspace1 " ; <nl> - public static final InetAddress LOCAL = FBUtilities . getLocalAddress ( ) ; <nl> - <nl> - / * * <nl> - * Test compaction with a very wide row . <nl> - * / <nl> - @ Test <nl> - public void testCompactionWide ( ) throws Exception <nl> - { <nl> - testCompaction ( 2 , 1 , 200000 ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Test compaction with lots of skinny rows . <nl> - * / <nl> - @ Test <nl> - public void testCompactionSlim ( ) throws Exception <nl> - { <nl> - testCompaction ( 2 , 200000 , 1 ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Test compaction with lots of small sstables . <nl> - * / <nl> - @ Test <nl> - public void testCompactionMany ( ) throws Exception <nl> - { <nl> - testCompaction ( 100 , 800 , 5 ) ; <nl> - } <nl> - <nl> - protected void testCompaction ( int sstableCount , int rowsPerSSTable , int colsPerRow ) throws Exception <nl> - { <nl> - CompactionManager . instance . disableAutoCompaction ( ) ; <nl> - <nl> - Table table = Table . open ( TABLE1 ) ; <nl> - ColumnFamilyStore store = table . getColumnFamilyStore ( " Standard1 " ) ; <nl> - <nl> - ArrayList < SSTableReader > sstables = new ArrayList < SSTableReader > ( ) ; <nl> - for ( int k = 0 ; k < sstableCount ; k + + ) <nl> - { <nl> - SortedMap < String , ColumnFamily > rows = new TreeMap < String , ColumnFamily > ( ) ; <nl> - for ( int j = 0 ; j < rowsPerSSTable ; j + + ) <nl> - { <nl> - String key = String . valueOf ( j ) ; <nl> - IColumn [ ] cols = new IColumn [ colsPerRow ] ; <nl> - for ( int i = 0 ; i < colsPerRow ; i + + ) <nl> - { <nl> - / / last sstable has highest timestamps <nl> - cols [ i ] = Util . column ( String . valueOf ( i ) , String . valueOf ( i ) , k ) ; <nl> - } <nl> - rows . put ( key , SSTableUtils . createCF ( Long . MIN _ VALUE , Integer . MIN _ VALUE , cols ) ) ; <nl> - } <nl> - SSTableReader sstable = SSTableUtils . writeSSTable ( rows ) ; <nl> - sstables . add ( sstable ) ; <nl> - store . addSSTable ( sstable ) ; <nl> - } <nl> - <nl> - / / give garbage collection a bit of time to catch up <nl> - Thread . sleep ( 1000 ) ; <nl> - <nl> - long start = System . currentTimeMillis ( ) ; <nl> - CompactionManager . instance . doCompaction ( store , sstables , CompactionManager . getDefaultGCBefore ( ) ) ; <nl> - System . out . println ( String . format ( " % s : sstables = % d rowsper = % d colsper = % d : % d ms " , <nl> - this . getClass ( ) . getName ( ) , <nl> - sstableCount , <nl> - rowsPerSSTable , <nl> - colsPerRow , <nl> - System . currentTimeMillis ( ) - start ) ) ; <nl> - } <nl> - } <nl> diff - - git a / test / unit / org / apache / cassandra / utils / BloomFilterTest . java b / test / unit / org / apache / cassandra / utils / BloomFilterTest . java <nl> index e10e6d1 . . d044832 100644 <nl> - - - a / test / unit / org / apache / cassandra / utils / BloomFilterTest . java <nl> + + + b / test / unit / org / apache / cassandra / utils / BloomFilterTest . java <nl> @ @ - 90 , 37 + 90 , 4 @ @ public class BloomFilterTest <nl> { <nl> FilterTest . testSerialize ( bf ) ; <nl> } <nl> - <nl> - / * TODO move these into a nightly suite ( they take 5 - 10 minutes each ) <nl> - @ Test <nl> - / / run with - mx1G <nl> - public void testBigInt ( ) { <nl> - int size = 100 * 1000 * 1000 ; <nl> - bf = new BloomFilter ( size , FilterTest . spec . bucketsPerElement ) ; <nl> - FilterTest . testFalsePositives ( bf , <nl> - new KeyGenerator . IntGenerator ( size ) , <nl> - new KeyGenerator . IntGenerator ( size , size * 2 ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void testBigRandom ( ) { <nl> - int size = 100 * 1000 * 1000 ; <nl> - bf = new BloomFilter ( size , FilterTest . spec . bucketsPerElement ) ; <nl> - FilterTest . testFalsePositives ( bf , <nl> - new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , <nl> - new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void timeit ( ) { <nl> - int size = 300 * FilterTest . ELEMENTS ; <nl> - bf = new BloomFilter ( size , FilterTest . spec . bucketsPerElement ) ; <nl> - for ( int i = 0 ; i < 10 ; i + + ) { <nl> - FilterTest . testFalsePositives ( bf , <nl> - new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , <nl> - new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; <nl> - bf . clear ( ) ; <nl> - } <nl> - } <nl> - * / <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index caecefb . . 8f6997b 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 9 
 + * Rerun ReplicationAwareTokenAllocatorTest on failure to avoid flakiness ( CASSANDRA - 12277 ) 
 * Exception when computing read - repair for range tombstones ( CASSANDRA - 12263 ) 
 * Lost counter writes in compact table and static columns ( CASSANDRA - 12219 ) 
 * AssertionError with MVs on updating a row that isn ' t indexed due to a null value ( CASSANDRA - 12247 ) 
 diff - - git a / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java b / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java 
 index 0a27e1c . . 1b36c55 100644 
 - - - a / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java 
 + + + b / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . commons . math3 . stat . descriptive . SummaryStatistics ; 
 
 import org . junit . Test ; 
 
 + import org . apache . cassandra . Util ; 
 import org . apache . cassandra . dht . Murmur3Partitioner ; 
 import org . apache . cassandra . dht . Token ; 
 
 @ @ - 545 , 6 + 546 , 20 @ @ public class ReplicationAwareTokenAllocatorTest 
 @ Test 
 public void testNewCluster ( ) 
 { 
 + Util . flakyTest ( this : : flakyTestNewCluster , 
 + 5 , 
 + " It tends to fail sometimes due to the random selection of the tokens in the first few nodes . " ) ; 
 + } 
 + 
 + public void flakyTestNewCluster ( ) 
 + { 
 + / / This test is flaky because the selection of the tokens for the first RF nodes ( which is random , with an 
 + / / uncontrolled seed ) can sometimes cause a pathological situation where the algorithm will find a ( close to ) 
 + / / ideal distribution of tokens for some number of nodes , which in turn will inevitably cause it to go into a 
 + / / bad ( unacceptable to the test criteria ) distribution after adding one more node . 
 + 
 + / / This should happen very rarely , unless something is broken in the token allocation code . 
 + 
 for ( int rf = 2 ; rf < = 5 ; + + rf ) 
 { 
 for ( int perUnitCount = 1 ; perUnitCount < = MAX _ VNODE _ COUNT ; perUnitCount * = 4 ) 
 diff - - git a / test / unit / org / apache / cassandra / Util . java b / test / unit / org / apache / cassandra / Util . java 
 index 7ce8f04 . . e7b1ffa 100644 
 - - - a / test / unit / org / apache / cassandra / Util . java 
 + + + b / test / unit / org / apache / cassandra / Util . java 
 @ @ - 536 , 6 + 536 , 62 @ @ public class Util 
 thread . join ( 10000 ) ; 
 } 
 
 + public static AssertionError runCatchingAssertionError ( Runnable test ) 
 + { 
 + try 
 + { 
 + test . run ( ) ; 
 + return null ; 
 + } 
 + catch ( AssertionError e ) 
 + { 
 + return e ; 
 + } 
 + } 
 + 
 + / * * 
 + * Wrapper function used to run a test that can sometimes flake for uncontrollable reasons . 
 + * 
 + * If the given test fails on the first run , it is executed the given number of times again , expecting all secondary 
 + * runs to succeed . If they do , the failure is understood as a flake and the test is treated as passing . 
 + * 
 + * Do not use this if the test is deterministic and its success is not influenced by external factors ( such as time , 
 + * selection of random seed , network failures , etc . ) . If the test can be made independent of such factors , it is 
 + * probably preferable to do so rather than use this method . 
 + * 
 + * @ param test The test to run . 
 + * @ param rerunsOnFailure How many times to re - run it if it fails . All reruns must pass . 
 + * @ param message Message to send to System . err on initial failure . 
 + * / 
 + public static void flakyTest ( Runnable test , int rerunsOnFailure , String message ) 
 + { 
 + AssertionError e = runCatchingAssertionError ( test ) ; 
 + if ( e = = null ) 
 + return ; / / success 
 + System . err . format ( " Test failed . % s % n " 
 + + " Re - running % d times to verify it isn ' t failing more often than it should . % n " 
 + + " Failure was : % s % n " , message , rerunsOnFailure , e ) ; 
 + e . printStackTrace ( ) ; 
 + 
 + int rerunsFailed = 0 ; 
 + for ( int i = 0 ; i < rerunsOnFailure ; + + i ) 
 + { 
 + AssertionError t = runCatchingAssertionError ( test ) ; 
 + if ( t ! = null ) 
 + { 
 + + + rerunsFailed ; 
 + e . addSuppressed ( t ) ; 
 + } 
 + } 
 + if ( rerunsFailed > 0 ) 
 + { 
 + System . err . format ( " Test failed in % d of the % d reruns . % n " , rerunsFailed , rerunsOnFailure ) ; 
 + throw e ; 
 + } 
 + 
 + System . err . println ( " All reruns succeeded . Failure treated as flake . " ) ; 
 + } 
 + 
 / / for use with Optional in tests , can be used as an argument to orElseThrow 
 public static Supplier < AssertionError > throwAssert ( final String message ) 
 {

NEAREST DIFF:
diff - - git a / build . xml b / build . xml 
 index d2fc678 . . 511f52d 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 42 , 6 + 42 , 7 @ @ 
 < property name = " test . data " value = " $ { test . dir } / data " / > 
 < property name = " test . name " value = " * Test " / > 
 < property name = " test . unit . src " value = " $ { test . dir } / unit " / > 
 + < property name = " test . long . src " value = " $ { test . dir } / long " / > 
 < property name = " dist . dir " value = " $ { build . dir } / dist " / > 
 < property name = " version " value = " 0 . 6 . 0 - rc1 " / > 
 < property name = " final . name " value = " $ { ant . project . name } - $ { version } " / > 
 @ @ - 348 , 10 + 349 , 10 @ @ 
 < javac 
 debug = " true " 
 debuglevel = " $ { debuglevel } " 
 - destdir = " $ { test . classes } " 
 - > 
 + destdir = " $ { test . classes } " > 
 < classpath refid = " cassandra . classpath " / > 
 < src path = " $ { test . unit . src } " / > 
 + < src path = " $ { test . long . src } " / > 
 < / javac > 
 
 < ! - - Non - java resources needed by the test suite - - > 
 @ @ - 360 , 30 + 361 , 42 @ @ 
 < / copy > 
 < / target > 
 
 - < target name = " test " depends = " build - test " > 
 - < echo message = " running tests " / > 
 - < mkdir dir = " $ { build . test . dir } / cassandra " / > 
 - < mkdir dir = " $ { build . test . dir } / output " / > 
 - < junit fork = " on " failureproperty = " testfailed " maxmemory = " 1024m " > 
 - < sysproperty key = " net . sourceforge . cobertura . datafile " file = " $ { cobertura . datafile } " / > 
 - < formatter type = " xml " usefile = " true " / > 
 - < formatter type = " brief " usefile = " false " / > 
 - < jvmarg value = " - Dstorage - config = $ { test . conf } " / > 
 - < jvmarg value = " - Dlog4j . configuration = log4j - junit . properties " / > 
 - < jvmarg value = " - Dlegacy - sstable - root = $ { test . data } / legacy - sstables " / > 
 - < jvmarg value = " - ea " / > 
 - < classpath > 
 - < path refid = " cassandra . classpath " / > 
 - < pathelement location = " $ { test . classes } " / > 
 - < pathelement location = " $ { cobertura . dir } / cobertura . jar " / > 
 - < pathelement location = " $ { test . conf } " / > 
 - < / classpath > 
 - < batchtest todir = " $ { build . test . dir } / output " > 
 - < fileset dir = " $ { test . classes } " includes = " * * / $ { test . name } . class " / > 
 - < / batchtest > 
 - < / junit > 
 + < macrodef name = " testmacro " > 
 + < attribute name = " suitename " / > 
 + < attribute name = " inputdir " / > 
 + < attribute name = " timeout " / > 
 + < sequential > 
 + < echo message = " running @ { suitename } tests " / > 
 + < mkdir dir = " $ { build . test . dir } / cassandra " / > 
 + < mkdir dir = " $ { build . test . dir } / output " / > 
 + < junit fork = " on " failureproperty = " testfailed " maxmemory = " 1024m " timeout = " @ { timeout } " > 
 + < sysproperty key = " net . sourceforge . cobertura . datafile " file = " $ { cobertura . datafile } " / > 
 + < formatter type = " xml " usefile = " true " / > 
 + < formatter type = " brief " usefile = " false " / > 
 + < jvmarg value = " - Dstorage - config = $ { test . conf } " / > 
 + < jvmarg value = " - Dlog4j . configuration = log4j - junit . properties " / > 
 + < jvmarg value = " - Dlegacy - sstable - root = $ { test . data } / legacy - sstables " / > 
 + < jvmarg value = " - ea " / > 
 + < classpath > 
 + < path refid = " cassandra . classpath " / > 
 + < pathelement location = " $ { test . classes } " / > 
 + < pathelement location = " $ { cobertura . dir } / cobertura . jar " / > 
 + < pathelement location = " $ { test . conf } " / > 
 + < / classpath > 
 + < batchtest todir = " $ { build . test . dir } / output " > 
 + < fileset dir = " @ { inputdir } " includes = " * * / $ { test . name } . java " / > 
 + < / batchtest > 
 + < / junit > 
 + < fail if = " testfailed " message = " Some @ { suitename } test ( s ) failed . " / > 
 + < / sequential > 
 + < / macrodef > 
 + 
 + < target name = " test " depends = " build - test " > 
 + < testmacro suitename = " unit " inputdir = " $ { test . unit . src } " timeout = " 30000 " / > 
 + < / target > 
 
 - < fail if = " testfailed " message = " Some test ( s ) failed . " / > 
 + < target name = " long - test " depends = " build - test " > 
 + < testmacro suitename = " long " inputdir = " $ { test . long . src } " timeout = " 300000 " / > 
 < / target > 
 	 
 < ! - - instruments the classes to later create code coverage reports - - > 
 diff - - git a / test / long / org / apache / cassandra / db / LongCompactionSpeedTest . java b / test / long / org / apache / cassandra / db / LongCompactionSpeedTest . java 
 new file mode 100644 
 index 0000000 . . 0c8cff4 
 - - - / dev / null 
 + + + b / test / long / org / apache / cassandra / db / LongCompactionSpeedTest . java 
 @ @ - 0 , 0 + 1 , 109 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + package org . apache . cassandra . db ; 
 + 
 + import java . io . IOException ; 
 + import java . net . InetAddress ; 
 + import java . util . concurrent . ExecutionException ; 
 + import java . util . concurrent . Future ; 
 + import java . util . * ; 
 + 
 + import org . apache . cassandra . Util ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . io . sstable . SSTableReader ; 
 + import org . apache . cassandra . io . sstable . SSTableUtils ; 
 + import org . apache . cassandra . CleanupHelper ; 
 + import org . apache . cassandra . db . filter . QueryPath ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + import static junit . framework . Assert . assertEquals ; 
 + 
 + public class LongCompactionSpeedTest extends CleanupHelper 
 + { 
 + public static final String TABLE1 = " Keyspace1 " ; 
 + public static final InetAddress LOCAL = FBUtilities . getLocalAddress ( ) ; 
 + 
 + / * * 
 + * Test compaction with a very wide row . 
 + * / 
 + @ Test 
 + public void testCompactionWide ( ) throws Exception 
 + { 
 + testCompaction ( 2 , 1 , 200000 ) ; 
 + } 
 + 
 + / * * 
 + * Test compaction with lots of skinny rows . 
 + * / 
 + @ Test 
 + public void testCompactionSlim ( ) throws Exception 
 + { 
 + testCompaction ( 2 , 200000 , 1 ) ; 
 + } 
 + 
 + / * * 
 + * Test compaction with lots of small sstables . 
 + * / 
 + @ Test 
 + public void testCompactionMany ( ) throws Exception 
 + { 
 + testCompaction ( 100 , 800 , 5 ) ; 
 + } 
 + 
 + protected void testCompaction ( int sstableCount , int rowsPerSSTable , int colsPerRow ) throws Exception 
 + { 
 + CompactionManager . instance . disableAutoCompaction ( ) ; 
 + 
 + Table table = Table . open ( TABLE1 ) ; 
 + ColumnFamilyStore store = table . getColumnFamilyStore ( " Standard1 " ) ; 
 + 
 + ArrayList < SSTableReader > sstables = new ArrayList < SSTableReader > ( ) ; 
 + for ( int k = 0 ; k < sstableCount ; k + + ) 
 + { 
 + SortedMap < String , ColumnFamily > rows = new TreeMap < String , ColumnFamily > ( ) ; 
 + for ( int j = 0 ; j < rowsPerSSTable ; j + + ) 
 + { 
 + String key = String . valueOf ( j ) ; 
 + IColumn [ ] cols = new IColumn [ colsPerRow ] ; 
 + for ( int i = 0 ; i < colsPerRow ; i + + ) 
 + { 
 + / / last sstable has highest timestamps 
 + cols [ i ] = Util . column ( String . valueOf ( i ) , String . valueOf ( i ) , k ) ; 
 + } 
 + rows . put ( key , SSTableUtils . createCF ( Long . MIN _ VALUE , Integer . MIN _ VALUE , cols ) ) ; 
 + } 
 + SSTableReader sstable = SSTableUtils . writeSSTable ( rows ) ; 
 + sstables . add ( sstable ) ; 
 + store . addSSTable ( sstable ) ; 
 + } 
 + 
 + / / give garbage collection a bit of time to catch up 
 + Thread . sleep ( 1000 ) ; 
 + 
 + long start = System . currentTimeMillis ( ) ; 
 + CompactionManager . instance . doCompaction ( store , sstables , CompactionManager . getDefaultGCBefore ( ) ) ; 
 + System . out . println ( String . format ( " % s : sstables = % d rowsper = % d colsper = % d : % d ms " , 
 + this . getClass ( ) . getName ( ) , 
 + sstableCount , 
 + rowsPerSSTable , 
 + colsPerRow , 
 + System . currentTimeMillis ( ) - start ) ) ; 
 + } 
 + } 
 diff - - git a / test / long / org / apache / cassandra / utils / LongBloomFilterTest . java b / test / long / org / apache / cassandra / utils / LongBloomFilterTest . java 
 new file mode 100644 
 index 0000000 . . 5320187 
 - - - / dev / null 
 + + + b / test / long / org / apache / cassandra / utils / LongBloomFilterTest . java 
 @ @ - 0 , 0 + 1 , 62 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . io . IOException ; 
 + import java . util . Random ; 
 + 
 + import org . junit . Test ; 
 + 
 + public class LongBloomFilterTest 
 + { 
 + public BloomFilter bf ; 
 + 
 + / * * 
 + * NB : needs to run with - mx1G 
 + * / 
 + @ Test 
 + public void testBigInt ( ) { 
 + int size = 10 * 1000 * 1000 ; 
 + bf = BloomFilter . getFilter ( size , FilterTest . spec . bucketsPerElement ) ; 
 + FilterTest . testFalsePositives ( bf , 
 + new KeyGenerator . IntGenerator ( size ) , 
 + new KeyGenerator . IntGenerator ( size , size * 2 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testBigRandom ( ) { 
 + int size = 10 * 1000 * 1000 ; 
 + bf = BloomFilter . getFilter ( size , FilterTest . spec . bucketsPerElement ) ; 
 + FilterTest . testFalsePositives ( bf , 
 + new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , 
 + new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; 
 + } 
 + 
 + @ Test 
 + public void timeit ( ) { 
 + int size = 300 * FilterTest . ELEMENTS ; 
 + bf = BloomFilter . getFilter ( size , FilterTest . spec . bucketsPerElement ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) { 
 + FilterTest . testFalsePositives ( bf , 
 + new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , 
 + new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; 
 + bf . clear ( ) ; 
 + } 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / db / CompactionSpeedTest . java b / test / unit / org / apache / cassandra / db / CompactionSpeedTest . java 
 deleted file mode 100644 
 index c8b4e05 . . 0000000 
 - - - a / test / unit / org / apache / cassandra / db / CompactionSpeedTest . java 
 + + + / dev / null 
 @ @ - 1 , 109 + 0 , 0 @ @ 
 - / * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , 
 - * software distributed under the License is distributed on an 
 - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 - * KIND , either express or implied . See the License for the 
 - * specific language governing permissions and limitations 
 - * under the License . 
 - * / 
 - package org . apache . cassandra . db ; 
 - 
 - import java . io . IOException ; 
 - import java . net . InetAddress ; 
 - import java . util . concurrent . ExecutionException ; 
 - import java . util . concurrent . Future ; 
 - import java . util . * ; 
 - 
 - import org . apache . cassandra . Util ; 
 - 
 - import org . junit . Test ; 
 - 
 - import org . apache . cassandra . io . sstable . SSTableReader ; 
 - import org . apache . cassandra . io . sstable . SSTableUtils ; 
 - import org . apache . cassandra . CleanupHelper ; 
 - import org . apache . cassandra . db . filter . QueryPath ; 
 - import org . apache . cassandra . utils . FBUtilities ; 
 - import static junit . framework . Assert . assertEquals ; 
 - 
 - public class CompactionSpeedTest extends CleanupHelper 
 - { 
 - public static final String TABLE1 = " Keyspace1 " ; 
 - public static final InetAddress LOCAL = FBUtilities . getLocalAddress ( ) ; 
 - 
 - / * * 
 - * Test compaction with a very wide row . 
 - * / 
 - @ Test 
 - public void testCompactionWide ( ) throws Exception 
 - { 
 - testCompaction ( 2 , 1 , 200000 ) ; 
 - } 
 - 
 - / * * 
 - * Test compaction with lots of skinny rows . 
 - * / 
 - @ Test 
 - public void testCompactionSlim ( ) throws Exception 
 - { 
 - testCompaction ( 2 , 200000 , 1 ) ; 
 - } 
 - 
 - / * * 
 - * Test compaction with lots of small sstables . 
 - * / 
 - @ Test 
 - public void testCompactionMany ( ) throws Exception 
 - { 
 - testCompaction ( 100 , 800 , 5 ) ; 
 - } 
 - 
 - protected void testCompaction ( int sstableCount , int rowsPerSSTable , int colsPerRow ) throws Exception 
 - { 
 - CompactionManager . instance . disableAutoCompaction ( ) ; 
 - 
 - Table table = Table . open ( TABLE1 ) ; 
 - ColumnFamilyStore store = table . getColumnFamilyStore ( " Standard1 " ) ; 
 - 
 - ArrayList < SSTableReader > sstables = new ArrayList < SSTableReader > ( ) ; 
 - for ( int k = 0 ; k < sstableCount ; k + + ) 
 - { 
 - SortedMap < String , ColumnFamily > rows = new TreeMap < String , ColumnFamily > ( ) ; 
 - for ( int j = 0 ; j < rowsPerSSTable ; j + + ) 
 - { 
 - String key = String . valueOf ( j ) ; 
 - IColumn [ ] cols = new IColumn [ colsPerRow ] ; 
 - for ( int i = 0 ; i < colsPerRow ; i + + ) 
 - { 
 - / / last sstable has highest timestamps 
 - cols [ i ] = Util . column ( String . valueOf ( i ) , String . valueOf ( i ) , k ) ; 
 - } 
 - rows . put ( key , SSTableUtils . createCF ( Long . MIN _ VALUE , Integer . MIN _ VALUE , cols ) ) ; 
 - } 
 - SSTableReader sstable = SSTableUtils . writeSSTable ( rows ) ; 
 - sstables . add ( sstable ) ; 
 - store . addSSTable ( sstable ) ; 
 - } 
 - 
 - / / give garbage collection a bit of time to catch up 
 - Thread . sleep ( 1000 ) ; 
 - 
 - long start = System . currentTimeMillis ( ) ; 
 - CompactionManager . instance . doCompaction ( store , sstables , CompactionManager . getDefaultGCBefore ( ) ) ; 
 - System . out . println ( String . format ( " % s : sstables = % d rowsper = % d colsper = % d : % d ms " , 
 - this . getClass ( ) . getName ( ) , 
 - sstableCount , 
 - rowsPerSSTable , 
 - colsPerRow , 
 - System . currentTimeMillis ( ) - start ) ) ; 
 - } 
 - } 
 diff - - git a / test / unit / org / apache / cassandra / utils / BloomFilterTest . java b / test / unit / org / apache / cassandra / utils / BloomFilterTest . java 
 index e10e6d1 . . d044832 100644 
 - - - a / test / unit / org / apache / cassandra / utils / BloomFilterTest . java 
 + + + b / test / unit / org / apache / cassandra / utils / BloomFilterTest . java 
 @ @ - 90 , 37 + 90 , 4 @ @ public class BloomFilterTest 
 { 
 FilterTest . testSerialize ( bf ) ; 
 } 
 - 
 - / * TODO move these into a nightly suite ( they take 5 - 10 minutes each ) 
 - @ Test 
 - / / run with - mx1G 
 - public void testBigInt ( ) { 
 - int size = 100 * 1000 * 1000 ; 
 - bf = new BloomFilter ( size , FilterTest . spec . bucketsPerElement ) ; 
 - FilterTest . testFalsePositives ( bf , 
 - new KeyGenerator . IntGenerator ( size ) , 
 - new KeyGenerator . IntGenerator ( size , size * 2 ) ) ; 
 - } 
 - 
 - @ Test 
 - public void testBigRandom ( ) { 
 - int size = 100 * 1000 * 1000 ; 
 - bf = new BloomFilter ( size , FilterTest . spec . bucketsPerElement ) ; 
 - FilterTest . testFalsePositives ( bf , 
 - new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , 
 - new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; 
 - } 
 - 
 - @ Test 
 - public void timeit ( ) { 
 - int size = 300 * FilterTest . ELEMENTS ; 
 - bf = new BloomFilter ( size , FilterTest . spec . bucketsPerElement ) ; 
 - for ( int i = 0 ; i < 10 ; i + + ) { 
 - FilterTest . testFalsePositives ( bf , 
 - new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , 
 - new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; 
 - bf . clear ( ) ; 
 - } 
 - } 
 - * / 
 }
