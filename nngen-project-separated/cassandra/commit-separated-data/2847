BLEU SCORE: 0.02955926526467443

TEST MSG: Use Atomic * FieldUpdater to save memory .
GENERATED MSG: Remove errant System . exit from stress so it can reuse keyspaces .

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / AtomicSortedColumns . java b / src / java / org / apache / cassandra / db / AtomicSortedColumns . java <nl> index 6e4fd01 . . b1f1e59 100644 <nl> - - - a / src / java / org / apache / cassandra / db / AtomicSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / AtomicSortedColumns . java <nl> @ @ - 18 , 7 + 18 , 7 @ @ <nl> package org . apache . cassandra . db ; <nl> <nl> import java . util . * ; <nl> - import java . util . concurrent . atomic . AtomicReference ; <nl> + import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; <nl> <nl> import com . google . common . base . Function ; <nl> import com . google . common . collect . Iterables ; <nl> @ @ - 49 , 7 + 49 , 9 @ @ import org . apache . cassandra . utils . Allocator ; <nl> * / <nl> public class AtomicSortedColumns extends ColumnFamily <nl> { <nl> - private final AtomicReference < Holder > ref ; <nl> + private volatile Holder ref ; <nl> + private static final AtomicReferenceFieldUpdater < AtomicSortedColumns , Holder > refUpdater <nl> + = AtomicReferenceFieldUpdater . newUpdater ( AtomicSortedColumns . class , Holder . class , " ref " ) ; <nl> <nl> public static final ColumnFamily . Factory < AtomicSortedColumns > factory = new Factory < AtomicSortedColumns > ( ) <nl> { <nl> @ @ - 67 , 12 + 69 , 12 @ @ public class AtomicSortedColumns extends ColumnFamily <nl> private AtomicSortedColumns ( CFMetaData metadata , Holder holder ) <nl> { <nl> super ( metadata ) ; <nl> - this . ref = new AtomicReference < > ( holder ) ; <nl> + this . ref = holder ; <nl> } <nl> <nl> public CellNameType getComparator ( ) <nl> { <nl> - return ( CellNameType ) ref . get ( ) . map . comparator ( ) ; <nl> + return ( CellNameType ) ref . map . comparator ( ) ; <nl> } <nl> <nl> public ColumnFamily . Factory getFactory ( ) <nl> @ @ - 82 , 12 + 84 , 12 @ @ public class AtomicSortedColumns extends ColumnFamily <nl> <nl> public ColumnFamily cloneMe ( ) <nl> { <nl> - return new AtomicSortedColumns ( metadata , ref . get ( ) . cloneMe ( ) ) ; <nl> + return new AtomicSortedColumns ( metadata , ref . cloneMe ( ) ) ; <nl> } <nl> <nl> public DeletionInfo deletionInfo ( ) <nl> { <nl> - return ref . get ( ) . deletionInfo ; <nl> + return ref . deletionInfo ; <nl> } <nl> <nl> public void delete ( DeletionTime delTime ) <nl> @ @ - 108 , 29 + 110 , 29 @ @ public class AtomicSortedColumns extends ColumnFamily <nl> / / Keeping deletion info for max markedForDeleteAt value <nl> while ( true ) <nl> { <nl> - Holder current = ref . get ( ) ; <nl> + Holder current = ref ; <nl> DeletionInfo newDelInfo = current . deletionInfo . copy ( ) . add ( info ) ; <nl> - if ( ref . compareAndSet ( current , current . with ( newDelInfo ) ) ) <nl> + if ( refUpdater . compareAndSet ( this , current , current . with ( newDelInfo ) ) ) <nl> break ; <nl> } <nl> } <nl> <nl> public void setDeletionInfo ( DeletionInfo newInfo ) <nl> { <nl> - ref . set ( ref . get ( ) . with ( newInfo ) ) ; <nl> + ref = ref . with ( newInfo ) ; <nl> } <nl> <nl> public void purgeTombstones ( int gcBefore ) <nl> { <nl> while ( true ) <nl> { <nl> - Holder current = ref . get ( ) ; <nl> + Holder current = ref ; <nl> if ( ! current . deletionInfo . hasPurgeableTombstones ( gcBefore ) ) <nl> break ; <nl> <nl> DeletionInfo purgedInfo = current . deletionInfo . copy ( ) ; <nl> purgedInfo . purge ( gcBefore ) ; <nl> - if ( ref . compareAndSet ( current , current . with ( purgedInfo ) ) ) <nl> + if ( refUpdater . compareAndSet ( this , current , current . with ( purgedInfo ) ) ) <nl> break ; <nl> } <nl> } <nl> @ @ - 140 , 11 + 142 , 11 @ @ public class AtomicSortedColumns extends ColumnFamily <nl> Holder current , modified ; <nl> do <nl> { <nl> - current = ref . get ( ) ; <nl> + current = ref ; <nl> modified = current . cloneMe ( ) ; <nl> modified . addColumn ( cell , allocator , SecondaryIndexManager . nullUpdater ) ; <nl> } <nl> - while ( ! ref . compareAndSet ( current , modified ) ) ; <nl> + while ( ! refUpdater . compareAndSet ( this , current , modified ) ) ; <nl> } <nl> <nl> public void addAll ( ColumnFamily cm , Allocator allocator , Function < Cell , Cell > transformation ) <nl> @ @ - 177 , 7 + 179 , 7 @ @ public class AtomicSortedColumns extends ColumnFamily <nl> do <nl> { <nl> sizeDelta = 0 ; <nl> - current = ref . get ( ) ; <nl> + current = ref ; <nl> DeletionInfo newDelInfo = current . deletionInfo . copy ( ) . add ( cm . deletionInfo ( ) ) ; <nl> modified = new Holder ( current . map . clone ( ) , newDelInfo ) ; <nl> <nl> @ @ - 194 , 11 + 196 , 11 @ @ public class AtomicSortedColumns extends ColumnFamily <nl> { <nl> sizeDelta + = modified . addColumn ( transformation . apply ( cell ) , allocator , indexer ) ; <nl> / / bail early if we know we ' ve been beaten <nl> - if ( ref . get ( ) ! = current ) <nl> + if ( ref ! = current ) <nl> continue main _ loop ; <nl> } <nl> } <nl> - while ( ! ref . compareAndSet ( current , modified ) ) ; <nl> + while ( ! refUpdater . compareAndSet ( this , current , modified ) ) ; <nl> <nl> indexer . updateRowLevelIndexes ( ) ; <nl> <nl> @ @ - 214 , 11 + 216 , 11 @ @ public class AtomicSortedColumns extends ColumnFamily <nl> boolean replaced ; <nl> do <nl> { <nl> - current = ref . get ( ) ; <nl> + current = ref ; <nl> modified = current . cloneMe ( ) ; <nl> replaced = modified . map . replace ( oldCell . name ( ) , oldCell , newCell ) ; <nl> } <nl> - while ( ! ref . compareAndSet ( current , modified ) ) ; <nl> + while ( ! refUpdater . compareAndSet ( this , current , modified ) ) ; <nl> return replaced ; <nl> } <nl> <nl> @ @ - 227 , 45 + 229 , 45 @ @ public class AtomicSortedColumns extends ColumnFamily <nl> Holder current , modified ; <nl> do <nl> { <nl> - current = ref . get ( ) ; <nl> + current = ref ; <nl> modified = current . clear ( ) ; <nl> } <nl> - while ( ! ref . compareAndSet ( current , modified ) ) ; <nl> + while ( ! refUpdater . compareAndSet ( this , current , modified ) ) ; <nl> } <nl> <nl> public Cell getColumn ( CellName name ) <nl> { <nl> - return ref . get ( ) . map . get ( name ) ; <nl> + return ref . map . get ( name ) ; <nl> } <nl> <nl> public SortedSet < CellName > getColumnNames ( ) <nl> { <nl> - return ref . get ( ) . map . keySet ( ) ; <nl> + return ref . map . keySet ( ) ; <nl> } <nl> <nl> public Collection < Cell > getSortedColumns ( ) <nl> { <nl> - return ref . get ( ) . map . values ( ) ; <nl> + return ref . map . values ( ) ; <nl> } <nl> <nl> public Collection < Cell > getReverseSortedColumns ( ) <nl> { <nl> - return ref . get ( ) . map . descendingMap ( ) . values ( ) ; <nl> + return ref . map . descendingMap ( ) . values ( ) ; <nl> } <nl> <nl> public int getColumnCount ( ) <nl> { <nl> - return ref . get ( ) . map . size ( ) ; <nl> + return ref . map . size ( ) ; <nl> } <nl> <nl> public Iterator < Cell > iterator ( ColumnSlice [ ] slices ) <nl> { <nl> - return new ColumnSlice . NavigableMapIterator ( ref . get ( ) . map , slices ) ; <nl> + return new ColumnSlice . NavigableMapIterator ( ref . map , slices ) ; <nl> } <nl> <nl> public Iterator < Cell > reverseIterator ( ColumnSlice [ ] slices ) <nl> { <nl> - return new ColumnSlice . NavigableMapIterator ( ref . get ( ) . map . descendingMap ( ) , slices ) ; <nl> + return new ColumnSlice . NavigableMapIterator ( ref . map . descendingMap ( ) , slices ) ; <nl> } <nl> <nl> public boolean isInsertReversed ( ) <nl> diff - - git a / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java <nl> index 5530374 . . 96fc96d 100644 <nl> - - - a / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java <nl> @ @ - 50 , 8 + 50 , 7 @ @ public class DatacenterWriteResponseHandler extends WriteResponseHandler <nl> { <nl> if ( message = = null | | DatabaseDescriptor . getLocalDataCenter ( ) . equals ( snitch . getDatacenter ( message . from ) ) ) <nl> { <nl> - if ( responses . decrementAndGet ( ) = = 0 ) <nl> - signal ( ) ; <nl> + super . response ( message ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / ReadCallback . java b / src / java / org / apache / cassandra / service / ReadCallback . java <nl> index d665242 . . ff6a8d4 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ReadCallback . java <nl> + + + b / src / java / org / apache / cassandra / service / ReadCallback . java <nl> @ @ - 21 , 7 + 21 , 7 @ @ import java . net . InetAddress ; <nl> import java . util . Collections ; <nl> import java . util . List ; <nl> import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . atomic . AtomicInteger ; <nl> + import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; <nl> <nl> import org . apache . commons . lang3 . StringUtils ; <nl> import org . slf4j . Logger ; <nl> @ @ - 54 , 7 + 54 , 9 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag <nl> final List < InetAddress > endpoints ; <nl> private final IReadCommand command ; <nl> private final ConsistencyLevel consistencyLevel ; <nl> - private final AtomicInteger received = new AtomicInteger ( 0 ) ; <nl> + private static final AtomicIntegerFieldUpdater < ReadCallback > recievedUpdater <nl> + = AtomicIntegerFieldUpdater . newUpdater ( ReadCallback . class , " received " ) ; <nl> + private volatile int received = 0 ; <nl> private final Keyspace keyspace ; / / TODO push this into ConsistencyLevel ? <nl> <nl> / * * <nl> @ @ - 96 , 10 + 98 , 10 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag <nl> if ( ! await ( command . getTimeout ( ) , TimeUnit . MILLISECONDS ) ) <nl> { <nl> / / Same as for writes , see AbstractWriteResponseHandler <nl> - int acks = received . get ( ) ; <nl> + int acks = received ; <nl> if ( resolver . isDataPresent ( ) & & acks > = blockfor ) <nl> acks = blockfor - 1 ; <nl> - ReadTimeoutException ex = new ReadTimeoutException ( consistencyLevel , received . get ( ) , blockfor , resolver . isDataPresent ( ) ) ; <nl> + ReadTimeoutException ex = new ReadTimeoutException ( consistencyLevel , received , blockfor , resolver . isDataPresent ( ) ) ; <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Read timeout : { } " , ex . toString ( ) ) ; <nl> throw ex ; <nl> @ @ - 112 , 8 + 114 , 8 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag <nl> { <nl> resolver . preprocess ( message ) ; <nl> int n = waitingFor ( message ) <nl> - ? received . incrementAndGet ( ) <nl> - : received . get ( ) ; <nl> + ? recievedUpdater . incrementAndGet ( this ) <nl> + : received ; <nl> if ( n > = blockfor & & resolver . isDataPresent ( ) ) <nl> { <nl> condition . signalAll ( ) ; <nl> @ @ - 136 , 7 + 138 , 7 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag <nl> * / <nl> public int getReceivedCount ( ) <nl> { <nl> - return received . get ( ) ; <nl> + return received ; <nl> } <nl> <nl> public void response ( TMessage result ) <nl> @ @ - 155 , 7 + 157 , 7 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag <nl> * / <nl> protected void maybeResolveForRepair ( ) <nl> { <nl> - if ( blockfor < endpoints . size ( ) & & received . get ( ) = = endpoints . size ( ) ) <nl> + if ( blockfor < endpoints . size ( ) & & received = = endpoints . size ( ) ) <nl> { <nl> assert resolver . isDataPresent ( ) ; <nl> StageManager . getStage ( Stage . READ _ REPAIR ) . execute ( new AsyncRepairRunner ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / WriteResponseHandler . java b / src / java / org / apache / cassandra / service / WriteResponseHandler . java <nl> index 826ae01 . . df23b19 100644 <nl> - - - a / src / java / org / apache / cassandra / service / WriteResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / WriteResponseHandler . java <nl> @ @ - 21 , 7 + 21 , 7 @ @ import java . net . InetAddress ; <nl> import java . util . Arrays ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> - import java . util . concurrent . atomic . AtomicInteger ; <nl> + import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; <nl> <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> @ @ - 38 , 7 + 38 , 9 @ @ public class WriteResponseHandler extends AbstractWriteResponseHandler <nl> { <nl> protected static final Logger logger = LoggerFactory . getLogger ( WriteResponseHandler . class ) ; <nl> <nl> - protected final AtomicInteger responses ; <nl> + protected volatile int responses ; <nl> + private static final AtomicIntegerFieldUpdater < WriteResponseHandler > responsesUpdater <nl> + = AtomicIntegerFieldUpdater . newUpdater ( WriteResponseHandler . class , " responses " ) ; <nl> <nl> public WriteResponseHandler ( Collection < InetAddress > writeEndpoints , <nl> Collection < InetAddress > pendingEndpoints , <nl> @ @ - 48 , 7 + 50 , 7 @ @ public class WriteResponseHandler extends AbstractWriteResponseHandler <nl> WriteType writeType ) <nl> { <nl> super ( keyspace , writeEndpoints , pendingEndpoints , consistencyLevel , callback , writeType ) ; <nl> - responses = new AtomicInteger ( totalBlockFor ( ) ) ; <nl> + responses = totalBlockFor ( ) ; <nl> } <nl> <nl> public WriteResponseHandler ( InetAddress endpoint , WriteType writeType , Runnable callback ) <nl> @ @ - 63 , 13 + 65 , 13 @ @ public class WriteResponseHandler extends AbstractWriteResponseHandler <nl> <nl> public void response ( MessageIn m ) <nl> { <nl> - if ( responses . decrementAndGet ( ) = = 0 ) <nl> + if ( responsesUpdater . decrementAndGet ( this ) = = 0 ) <nl> signal ( ) ; <nl> } <nl> <nl> protected int ackCount ( ) <nl> { <nl> - return totalBlockFor ( ) - responses . get ( ) ; <nl> + return totalBlockFor ( ) - responses ; <nl> } <nl> <nl> public boolean isLatencyForSnitch ( )
NEAREST DIFF (one line): diff - - git a / test / distributed / org / apache / cassandra / TestBase . java b / test / distributed / org / apache / cassandra / TestBase . java <nl> index 54ca631 . . c403204 100644 <nl> - - - a / test / distributed / org / apache / cassandra / TestBase . java <nl> + + + b / test / distributed / org / apache / cassandra / TestBase . java <nl> @ @ - 84 , 12 + 84 , 11 @ @ public abstract class TestBase <nl> Cassandra . Client client = controller . createClient ( hosts . get ( 0 ) ) ; <nl> Map < String , String > stratOptions = new HashMap < String , String > ( ) ; <nl> stratOptions . put ( " replication _ factor " , " " + rf ) ; <nl> - client . system _ add _ keyspace ( <nl> - new KsDef ( <nl> - name , <nl> - " org . apache . cassandra . locator . SimpleStrategy " , <nl> - Arrays . asList ( cfdef ) ) <nl> - . setStrategy _ options ( stratOptions ) ) ; <nl> + client . system _ add _ keyspace ( new KsDef ( name , <nl> + " org . apache . cassandra . locator . SimpleStrategy " , <nl> + Arrays . asList ( cfdef ) ) <nl> + . setStrategy _ options ( stratOptions ) <nl> + . setCf _ defs ( Collections . < CfDef > emptyList ( ) ) ) ; <nl> <nl> / / poll , until KS added <nl> for ( InetAddress host : hosts )

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / AtomicSortedColumns . java b / src / java / org / apache / cassandra / db / AtomicSortedColumns . java 
 index 6e4fd01 . . b1f1e59 100644 
 - - - a / src / java / org / apache / cassandra / db / AtomicSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / AtomicSortedColumns . java 
 @ @ - 18 , 7 + 18 , 7 @ @ 
 package org . apache . cassandra . db ; 
 
 import java . util . * ; 
 - import java . util . concurrent . atomic . AtomicReference ; 
 + import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; 
 
 import com . google . common . base . Function ; 
 import com . google . common . collect . Iterables ; 
 @ @ - 49 , 7 + 49 , 9 @ @ import org . apache . cassandra . utils . Allocator ; 
 * / 
 public class AtomicSortedColumns extends ColumnFamily 
 { 
 - private final AtomicReference < Holder > ref ; 
 + private volatile Holder ref ; 
 + private static final AtomicReferenceFieldUpdater < AtomicSortedColumns , Holder > refUpdater 
 + = AtomicReferenceFieldUpdater . newUpdater ( AtomicSortedColumns . class , Holder . class , " ref " ) ; 
 
 public static final ColumnFamily . Factory < AtomicSortedColumns > factory = new Factory < AtomicSortedColumns > ( ) 
 { 
 @ @ - 67 , 12 + 69 , 12 @ @ public class AtomicSortedColumns extends ColumnFamily 
 private AtomicSortedColumns ( CFMetaData metadata , Holder holder ) 
 { 
 super ( metadata ) ; 
 - this . ref = new AtomicReference < > ( holder ) ; 
 + this . ref = holder ; 
 } 
 
 public CellNameType getComparator ( ) 
 { 
 - return ( CellNameType ) ref . get ( ) . map . comparator ( ) ; 
 + return ( CellNameType ) ref . map . comparator ( ) ; 
 } 
 
 public ColumnFamily . Factory getFactory ( ) 
 @ @ - 82 , 12 + 84 , 12 @ @ public class AtomicSortedColumns extends ColumnFamily 
 
 public ColumnFamily cloneMe ( ) 
 { 
 - return new AtomicSortedColumns ( metadata , ref . get ( ) . cloneMe ( ) ) ; 
 + return new AtomicSortedColumns ( metadata , ref . cloneMe ( ) ) ; 
 } 
 
 public DeletionInfo deletionInfo ( ) 
 { 
 - return ref . get ( ) . deletionInfo ; 
 + return ref . deletionInfo ; 
 } 
 
 public void delete ( DeletionTime delTime ) 
 @ @ - 108 , 29 + 110 , 29 @ @ public class AtomicSortedColumns extends ColumnFamily 
 / / Keeping deletion info for max markedForDeleteAt value 
 while ( true ) 
 { 
 - Holder current = ref . get ( ) ; 
 + Holder current = ref ; 
 DeletionInfo newDelInfo = current . deletionInfo . copy ( ) . add ( info ) ; 
 - if ( ref . compareAndSet ( current , current . with ( newDelInfo ) ) ) 
 + if ( refUpdater . compareAndSet ( this , current , current . with ( newDelInfo ) ) ) 
 break ; 
 } 
 } 
 
 public void setDeletionInfo ( DeletionInfo newInfo ) 
 { 
 - ref . set ( ref . get ( ) . with ( newInfo ) ) ; 
 + ref = ref . with ( newInfo ) ; 
 } 
 
 public void purgeTombstones ( int gcBefore ) 
 { 
 while ( true ) 
 { 
 - Holder current = ref . get ( ) ; 
 + Holder current = ref ; 
 if ( ! current . deletionInfo . hasPurgeableTombstones ( gcBefore ) ) 
 break ; 
 
 DeletionInfo purgedInfo = current . deletionInfo . copy ( ) ; 
 purgedInfo . purge ( gcBefore ) ; 
 - if ( ref . compareAndSet ( current , current . with ( purgedInfo ) ) ) 
 + if ( refUpdater . compareAndSet ( this , current , current . with ( purgedInfo ) ) ) 
 break ; 
 } 
 } 
 @ @ - 140 , 11 + 142 , 11 @ @ public class AtomicSortedColumns extends ColumnFamily 
 Holder current , modified ; 
 do 
 { 
 - current = ref . get ( ) ; 
 + current = ref ; 
 modified = current . cloneMe ( ) ; 
 modified . addColumn ( cell , allocator , SecondaryIndexManager . nullUpdater ) ; 
 } 
 - while ( ! ref . compareAndSet ( current , modified ) ) ; 
 + while ( ! refUpdater . compareAndSet ( this , current , modified ) ) ; 
 } 
 
 public void addAll ( ColumnFamily cm , Allocator allocator , Function < Cell , Cell > transformation ) 
 @ @ - 177 , 7 + 179 , 7 @ @ public class AtomicSortedColumns extends ColumnFamily 
 do 
 { 
 sizeDelta = 0 ; 
 - current = ref . get ( ) ; 
 + current = ref ; 
 DeletionInfo newDelInfo = current . deletionInfo . copy ( ) . add ( cm . deletionInfo ( ) ) ; 
 modified = new Holder ( current . map . clone ( ) , newDelInfo ) ; 
 
 @ @ - 194 , 11 + 196 , 11 @ @ public class AtomicSortedColumns extends ColumnFamily 
 { 
 sizeDelta + = modified . addColumn ( transformation . apply ( cell ) , allocator , indexer ) ; 
 / / bail early if we know we ' ve been beaten 
 - if ( ref . get ( ) ! = current ) 
 + if ( ref ! = current ) 
 continue main _ loop ; 
 } 
 } 
 - while ( ! ref . compareAndSet ( current , modified ) ) ; 
 + while ( ! refUpdater . compareAndSet ( this , current , modified ) ) ; 
 
 indexer . updateRowLevelIndexes ( ) ; 
 
 @ @ - 214 , 11 + 216 , 11 @ @ public class AtomicSortedColumns extends ColumnFamily 
 boolean replaced ; 
 do 
 { 
 - current = ref . get ( ) ; 
 + current = ref ; 
 modified = current . cloneMe ( ) ; 
 replaced = modified . map . replace ( oldCell . name ( ) , oldCell , newCell ) ; 
 } 
 - while ( ! ref . compareAndSet ( current , modified ) ) ; 
 + while ( ! refUpdater . compareAndSet ( this , current , modified ) ) ; 
 return replaced ; 
 } 
 
 @ @ - 227 , 45 + 229 , 45 @ @ public class AtomicSortedColumns extends ColumnFamily 
 Holder current , modified ; 
 do 
 { 
 - current = ref . get ( ) ; 
 + current = ref ; 
 modified = current . clear ( ) ; 
 } 
 - while ( ! ref . compareAndSet ( current , modified ) ) ; 
 + while ( ! refUpdater . compareAndSet ( this , current , modified ) ) ; 
 } 
 
 public Cell getColumn ( CellName name ) 
 { 
 - return ref . get ( ) . map . get ( name ) ; 
 + return ref . map . get ( name ) ; 
 } 
 
 public SortedSet < CellName > getColumnNames ( ) 
 { 
 - return ref . get ( ) . map . keySet ( ) ; 
 + return ref . map . keySet ( ) ; 
 } 
 
 public Collection < Cell > getSortedColumns ( ) 
 { 
 - return ref . get ( ) . map . values ( ) ; 
 + return ref . map . values ( ) ; 
 } 
 
 public Collection < Cell > getReverseSortedColumns ( ) 
 { 
 - return ref . get ( ) . map . descendingMap ( ) . values ( ) ; 
 + return ref . map . descendingMap ( ) . values ( ) ; 
 } 
 
 public int getColumnCount ( ) 
 { 
 - return ref . get ( ) . map . size ( ) ; 
 + return ref . map . size ( ) ; 
 } 
 
 public Iterator < Cell > iterator ( ColumnSlice [ ] slices ) 
 { 
 - return new ColumnSlice . NavigableMapIterator ( ref . get ( ) . map , slices ) ; 
 + return new ColumnSlice . NavigableMapIterator ( ref . map , slices ) ; 
 } 
 
 public Iterator < Cell > reverseIterator ( ColumnSlice [ ] slices ) 
 { 
 - return new ColumnSlice . NavigableMapIterator ( ref . get ( ) . map . descendingMap ( ) , slices ) ; 
 + return new ColumnSlice . NavigableMapIterator ( ref . map . descendingMap ( ) , slices ) ; 
 } 
 
 public boolean isInsertReversed ( ) 
 diff - - git a / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java 
 index 5530374 . . 96fc96d 100644 
 - - - a / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java 
 @ @ - 50 , 8 + 50 , 7 @ @ public class DatacenterWriteResponseHandler extends WriteResponseHandler 
 { 
 if ( message = = null | | DatabaseDescriptor . getLocalDataCenter ( ) . equals ( snitch . getDatacenter ( message . from ) ) ) 
 { 
 - if ( responses . decrementAndGet ( ) = = 0 ) 
 - signal ( ) ; 
 + super . response ( message ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / ReadCallback . java b / src / java / org / apache / cassandra / service / ReadCallback . java 
 index d665242 . . ff6a8d4 100644 
 - - - a / src / java / org / apache / cassandra / service / ReadCallback . java 
 + + + b / src / java / org / apache / cassandra / service / ReadCallback . java 
 @ @ - 21 , 7 + 21 , 7 @ @ import java . net . InetAddress ; 
 import java . util . Collections ; 
 import java . util . List ; 
 import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . atomic . AtomicInteger ; 
 + import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; 
 
 import org . apache . commons . lang3 . StringUtils ; 
 import org . slf4j . Logger ; 
 @ @ - 54 , 7 + 54 , 9 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag 
 final List < InetAddress > endpoints ; 
 private final IReadCommand command ; 
 private final ConsistencyLevel consistencyLevel ; 
 - private final AtomicInteger received = new AtomicInteger ( 0 ) ; 
 + private static final AtomicIntegerFieldUpdater < ReadCallback > recievedUpdater 
 + = AtomicIntegerFieldUpdater . newUpdater ( ReadCallback . class , " received " ) ; 
 + private volatile int received = 0 ; 
 private final Keyspace keyspace ; / / TODO push this into ConsistencyLevel ? 
 
 / * * 
 @ @ - 96 , 10 + 98 , 10 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag 
 if ( ! await ( command . getTimeout ( ) , TimeUnit . MILLISECONDS ) ) 
 { 
 / / Same as for writes , see AbstractWriteResponseHandler 
 - int acks = received . get ( ) ; 
 + int acks = received ; 
 if ( resolver . isDataPresent ( ) & & acks > = blockfor ) 
 acks = blockfor - 1 ; 
 - ReadTimeoutException ex = new ReadTimeoutException ( consistencyLevel , received . get ( ) , blockfor , resolver . isDataPresent ( ) ) ; 
 + ReadTimeoutException ex = new ReadTimeoutException ( consistencyLevel , received , blockfor , resolver . isDataPresent ( ) ) ; 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Read timeout : { } " , ex . toString ( ) ) ; 
 throw ex ; 
 @ @ - 112 , 8 + 114 , 8 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag 
 { 
 resolver . preprocess ( message ) ; 
 int n = waitingFor ( message ) 
 - ? received . incrementAndGet ( ) 
 - : received . get ( ) ; 
 + ? recievedUpdater . incrementAndGet ( this ) 
 + : received ; 
 if ( n > = blockfor & & resolver . isDataPresent ( ) ) 
 { 
 condition . signalAll ( ) ; 
 @ @ - 136 , 7 + 138 , 7 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag 
 * / 
 public int getReceivedCount ( ) 
 { 
 - return received . get ( ) ; 
 + return received ; 
 } 
 
 public void response ( TMessage result ) 
 @ @ - 155 , 7 + 157 , 7 @ @ public class ReadCallback < TMessage , TResolved > implements IAsyncCallback < TMessag 
 * / 
 protected void maybeResolveForRepair ( ) 
 { 
 - if ( blockfor < endpoints . size ( ) & & received . get ( ) = = endpoints . size ( ) ) 
 + if ( blockfor < endpoints . size ( ) & & received = = endpoints . size ( ) ) 
 { 
 assert resolver . isDataPresent ( ) ; 
 StageManager . getStage ( Stage . READ _ REPAIR ) . execute ( new AsyncRepairRunner ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / WriteResponseHandler . java b / src / java / org / apache / cassandra / service / WriteResponseHandler . java 
 index 826ae01 . . df23b19 100644 
 - - - a / src / java / org / apache / cassandra / service / WriteResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / WriteResponseHandler . java 
 @ @ - 21 , 7 + 21 , 7 @ @ import java . net . InetAddress ; 
 import java . util . Arrays ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 - import java . util . concurrent . atomic . AtomicInteger ; 
 + import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; 
 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 @ @ - 38 , 7 + 38 , 9 @ @ public class WriteResponseHandler extends AbstractWriteResponseHandler 
 { 
 protected static final Logger logger = LoggerFactory . getLogger ( WriteResponseHandler . class ) ; 
 
 - protected final AtomicInteger responses ; 
 + protected volatile int responses ; 
 + private static final AtomicIntegerFieldUpdater < WriteResponseHandler > responsesUpdater 
 + = AtomicIntegerFieldUpdater . newUpdater ( WriteResponseHandler . class , " responses " ) ; 
 
 public WriteResponseHandler ( Collection < InetAddress > writeEndpoints , 
 Collection < InetAddress > pendingEndpoints , 
 @ @ - 48 , 7 + 50 , 7 @ @ public class WriteResponseHandler extends AbstractWriteResponseHandler 
 WriteType writeType ) 
 { 
 super ( keyspace , writeEndpoints , pendingEndpoints , consistencyLevel , callback , writeType ) ; 
 - responses = new AtomicInteger ( totalBlockFor ( ) ) ; 
 + responses = totalBlockFor ( ) ; 
 } 
 
 public WriteResponseHandler ( InetAddress endpoint , WriteType writeType , Runnable callback ) 
 @ @ - 63 , 13 + 65 , 13 @ @ public class WriteResponseHandler extends AbstractWriteResponseHandler 
 
 public void response ( MessageIn m ) 
 { 
 - if ( responses . decrementAndGet ( ) = = 0 ) 
 + if ( responsesUpdater . decrementAndGet ( this ) = = 0 ) 
 signal ( ) ; 
 } 
 
 protected int ackCount ( ) 
 { 
 - return totalBlockFor ( ) - responses . get ( ) ; 
 + return totalBlockFor ( ) - responses ; 
 } 
 
 public boolean isLatencyForSnitch ( )

NEAREST DIFF:
diff - - git a / test / distributed / org / apache / cassandra / TestBase . java b / test / distributed / org / apache / cassandra / TestBase . java 
 index 54ca631 . . c403204 100644 
 - - - a / test / distributed / org / apache / cassandra / TestBase . java 
 + + + b / test / distributed / org / apache / cassandra / TestBase . java 
 @ @ - 84 , 12 + 84 , 11 @ @ public abstract class TestBase 
 Cassandra . Client client = controller . createClient ( hosts . get ( 0 ) ) ; 
 Map < String , String > stratOptions = new HashMap < String , String > ( ) ; 
 stratOptions . put ( " replication _ factor " , " " + rf ) ; 
 - client . system _ add _ keyspace ( 
 - new KsDef ( 
 - name , 
 - " org . apache . cassandra . locator . SimpleStrategy " , 
 - Arrays . asList ( cfdef ) ) 
 - . setStrategy _ options ( stratOptions ) ) ; 
 + client . system _ add _ keyspace ( new KsDef ( name , 
 + " org . apache . cassandra . locator . SimpleStrategy " , 
 + Arrays . asList ( cfdef ) ) 
 + . setStrategy _ options ( stratOptions ) 
 + . setCf _ defs ( Collections . < CfDef > emptyList ( ) ) ) ; 
 
 / / poll , until KS added 
 for ( InetAddress host : hosts )
