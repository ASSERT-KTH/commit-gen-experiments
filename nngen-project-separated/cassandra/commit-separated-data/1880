BLEU SCORE: 0.011057717812699017

TEST MSG: ninja add unit test for 7882
GENERATED MSG: r / m RoundRobinSchedulerTest for CASSANDRA - 1279 ; it doesn ' t appear possible to test concurrency usefully

TEST DIFF (one line): diff - - git a / test / unit / org / apache / cassandra / utils / memory / NativeAllocatorTest . java b / test / unit / org / apache / cassandra / utils / memory / NativeAllocatorTest . java <nl> new file mode 100644 <nl> index 0000000 . . 83d6c0c <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / utils / memory / NativeAllocatorTest . java <nl> @ @ - 0 , 0 + 1 , 111 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + package org . apache . cassandra . utils . memory ; <nl> + <nl> + import java . util . concurrent . * ; <nl> + import java . util . concurrent . atomic . AtomicReference ; <nl> + <nl> + import com . google . common . util . concurrent . Uninterruptibles ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import junit . framework . Assert ; <nl> + import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> + <nl> + public class NativeAllocatorTest <nl> + { <nl> + <nl> + @ Test <nl> + public void testBookKeeping ( ) throws ExecutionException , InterruptedException <nl> + { <nl> + { <nl> + final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 2 ) ; <nl> + final OpOrder order = new OpOrder ( ) ; <nl> + final OpOrder . Group group = order . start ( ) ; <nl> + final CountDownLatch canClean = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch isClean = new CountDownLatch ( 1 ) ; <nl> + final AtomicReference < NativeAllocator > allocatorRef = new AtomicReference < > ( ) ; <nl> + final AtomicReference < OpOrder . Barrier > barrier = new AtomicReference < > ( ) ; <nl> + final NativeAllocator allocator = new NativeAllocator ( new NativePool ( 1 , 100 , 0 . 75f , new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + try <nl> + { <nl> + canClean . await ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + if ( isClean . getCount ( ) > 0 ) <nl> + { <nl> + allocatorRef . get ( ) . offHeap ( ) . release ( 80 ) ; <nl> + isClean . countDown ( ) ; <nl> + } <nl> + } <nl> + } ) ) ; <nl> + allocatorRef . set ( allocator ) ; <nl> + final Runnable markBlocking = new Runnable ( ) <nl> + { <nl> + <nl> + public void run ( ) <nl> + { <nl> + barrier . set ( order . newBarrier ( ) ) ; <nl> + barrier . get ( ) . issue ( ) ; <nl> + barrier . get ( ) . markBlocking ( ) ; <nl> + } <nl> + } ; <nl> + final Runnable run = new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + / / allocate normal , check accounted and not cleaned <nl> + allocator . allocate ( 10 , group ) ; <nl> + Assert . assertEquals ( 10 , allocator . offHeap ( ) . owns ( ) ) ; <nl> + Uninterruptibles . sleepUninterruptibly ( 10L , TimeUnit . MILLISECONDS ) ; <nl> + Assert . assertEquals ( 1 , isClean . getCount ( ) ) ; <nl> + <nl> + / / allocate above watermark , check cleaned <nl> + allocator . allocate ( 70 , group ) ; <nl> + Assert . assertEquals ( 80 , allocator . offHeap ( ) . owns ( ) ) ; <nl> + canClean . countDown ( ) ; <nl> + try <nl> + { <nl> + isClean . await ( 10L , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + Assert . assertEquals ( 0 , isClean . getCount ( ) ) ; <nl> + Assert . assertEquals ( 0 , allocator . offHeap ( ) . owns ( ) ) ; <nl> + <nl> + / / allocate above limit , check we block until " marked blocking " <nl> + exec . schedule ( markBlocking , 10L , TimeUnit . MILLISECONDS ) ; <nl> + allocator . allocate ( 110 , group ) ; <nl> + Assert . assertNotNull ( barrier . get ( ) ) ; <nl> + Assert . assertEquals ( 110 , allocator . offHeap ( ) . owns ( ) ) ; <nl> + } <nl> + } ; <nl> + exec . submit ( run ) . get ( ) ; <nl> + } <nl> + } <nl> + <nl> + }
NEAREST DIFF (one line): diff - - git a / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java b / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java <nl> deleted file mode 100644 <nl> index a0c688f . . 0000000 <nl> - - - a / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 153 + 0 , 0 @ @ <nl> - package org . apache . cassandra . scheduler ; <nl> - <nl> - / * <nl> - * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , <nl> - * software distributed under the License is distributed on an <nl> - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> - * KIND , either express or implied . See the License for the <nl> - * specific language governing permissions and limitations <nl> - * under the License . <nl> - * <nl> - * / <nl> - <nl> - import static org . junit . Assert . * ; <nl> - <nl> - import java . util . HashMap ; <nl> - import java . util . Map ; <nl> - import java . util . concurrent . ExecutorService ; <nl> - import java . util . concurrent . SynchronousQueue ; <nl> - import java . util . concurrent . ThreadPoolExecutor ; <nl> - import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . atomic . AtomicInteger ; <nl> - <nl> - import org . apache . cassandra . config . RequestSchedulerOptions ; <nl> - import org . junit . After ; <nl> - import org . junit . Before ; <nl> - import org . junit . Test ; <nl> - <nl> - public class RoundRobinSchedulerTest <nl> - { <nl> - ExecutorService executor ; <nl> - RoundRobinScheduler scheduler ; <nl> - AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> - static final String KS1 = " TestKeyspace " ; <nl> - static final String KS2 = " DevKeyspace " ; <nl> - static final String KS3 = " ProdKeyspace " ; <nl> - <nl> - Map < Integer , Integer > testValues = new HashMap < Integer , Integer > ( ) ; <nl> - <nl> - @ Before <nl> - public void setUp ( ) <nl> - { <nl> - RequestSchedulerOptions options = new RequestSchedulerOptions ( ) ; <nl> - / / Block the scheduler from running initially <nl> - options . throttle _ limit = - 1 ; <nl> - scheduler = new RoundRobinScheduler ( options ) ; <nl> - SynchronousQueue < Runnable > queue = new SynchronousQueue < Runnable > ( ) ; <nl> - <nl> - executor = new ThreadPoolExecutor ( 20 , <nl> - Integer . MAX _ VALUE , <nl> - 60 * 1000 , <nl> - TimeUnit . MILLISECONDS , <nl> - queue ) ; <nl> - / / When there are large no . of threads , the results become <nl> - / / more unpredictable because of the JVM thread scheduling <nl> - / / and that will be very hard to provide a consistent test <nl> - runKs1 ( 1 , 10 ) ; <nl> - runKs2 ( 11 , 13 ) ; <nl> - runKs3 ( 14 , 15 ) ; <nl> - / / Release some tasks for the scheduler to run , now that the requests <nl> - / / are queued in their various buckets , behavior will be more predictable <nl> - scheduler . getTaskCount ( ) . release ( 2 ) ; <nl> - try <nl> - { <nl> - Thread . sleep ( 3000 ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void testScheduling ( ) <nl> - { <nl> - for ( Integer initialValue : testValues . keySet ( ) ) <nl> - { <nl> - / / Makes sure , requests to each keyspace get an equal chance <nl> - / / Requests from one keyspace will not block requests from <nl> - / / another keyspacce <nl> - if ( initialValue > 10 ) <nl> - { <nl> - assertTrue ( initialValue > = testValues . get ( initialValue ) ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - @ After <nl> - public void shutDown ( ) <nl> - { <nl> - executor . shutdown ( ) ; <nl> - } <nl> - <nl> - private void runKs1 ( int start , int end ) <nl> - { <nl> - for ( int i = start ; i < = end ; i + + ) <nl> - { <nl> - executor . execute ( new Worker ( KS1 , i ) ) ; <nl> - } <nl> - } <nl> - <nl> - private void runKs2 ( int start , int end ) <nl> - { <nl> - for ( int i = start ; i < = end ; i + + ) <nl> - { <nl> - executor . execute ( new Worker ( KS2 , i ) ) ; <nl> - } <nl> - } <nl> - <nl> - private void runKs3 ( int start , int end ) <nl> - { <nl> - for ( int i = start ; i < = end ; i + + ) <nl> - { <nl> - executor . execute ( new Worker ( KS3 , i ) ) ; <nl> - } <nl> - } <nl> - <nl> - class Worker implements Runnable <nl> - { <nl> - String id ; <nl> - int initialCount ; <nl> - int runCount ; <nl> - <nl> - public Worker ( String id , int count ) <nl> - { <nl> - this . id = id ; <nl> - initialCount = count ; <nl> - } <nl> - <nl> - public void run ( ) <nl> - { <nl> - scheduler . queue ( Thread . currentThread ( ) , id ) ; <nl> - <nl> - runCount = counter . incrementAndGet ( ) ; <nl> - <nl> - synchronized ( scheduler ) <nl> - { <nl> - testValues . put ( initialCount , runCount ) ; <nl> - } <nl> - scheduler . release ( ) ; <nl> - } <nl> - } <nl> - }

TEST DIFF:
diff - - git a / test / unit / org / apache / cassandra / utils / memory / NativeAllocatorTest . java b / test / unit / org / apache / cassandra / utils / memory / NativeAllocatorTest . java 
 new file mode 100644 
 index 0000000 . . 83d6c0c 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / utils / memory / NativeAllocatorTest . java 
 @ @ - 0 , 0 + 1 , 111 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + package org . apache . cassandra . utils . memory ; 
 + 
 + import java . util . concurrent . * ; 
 + import java . util . concurrent . atomic . AtomicReference ; 
 + 
 + import com . google . common . util . concurrent . Uninterruptibles ; 
 + 
 + import org . junit . Test ; 
 + 
 + import junit . framework . Assert ; 
 + import org . apache . cassandra . utils . concurrent . OpOrder ; 
 + 
 + public class NativeAllocatorTest 
 + { 
 + 
 + @ Test 
 + public void testBookKeeping ( ) throws ExecutionException , InterruptedException 
 + { 
 + { 
 + final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 2 ) ; 
 + final OpOrder order = new OpOrder ( ) ; 
 + final OpOrder . Group group = order . start ( ) ; 
 + final CountDownLatch canClean = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch isClean = new CountDownLatch ( 1 ) ; 
 + final AtomicReference < NativeAllocator > allocatorRef = new AtomicReference < > ( ) ; 
 + final AtomicReference < OpOrder . Barrier > barrier = new AtomicReference < > ( ) ; 
 + final NativeAllocator allocator = new NativeAllocator ( new NativePool ( 1 , 100 , 0 . 75f , new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + try 
 + { 
 + canClean . await ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( ) ; 
 + } 
 + if ( isClean . getCount ( ) > 0 ) 
 + { 
 + allocatorRef . get ( ) . offHeap ( ) . release ( 80 ) ; 
 + isClean . countDown ( ) ; 
 + } 
 + } 
 + } ) ) ; 
 + allocatorRef . set ( allocator ) ; 
 + final Runnable markBlocking = new Runnable ( ) 
 + { 
 + 
 + public void run ( ) 
 + { 
 + barrier . set ( order . newBarrier ( ) ) ; 
 + barrier . get ( ) . issue ( ) ; 
 + barrier . get ( ) . markBlocking ( ) ; 
 + } 
 + } ; 
 + final Runnable run = new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + / / allocate normal , check accounted and not cleaned 
 + allocator . allocate ( 10 , group ) ; 
 + Assert . assertEquals ( 10 , allocator . offHeap ( ) . owns ( ) ) ; 
 + Uninterruptibles . sleepUninterruptibly ( 10L , TimeUnit . MILLISECONDS ) ; 
 + Assert . assertEquals ( 1 , isClean . getCount ( ) ) ; 
 + 
 + / / allocate above watermark , check cleaned 
 + allocator . allocate ( 70 , group ) ; 
 + Assert . assertEquals ( 80 , allocator . offHeap ( ) . owns ( ) ) ; 
 + canClean . countDown ( ) ; 
 + try 
 + { 
 + isClean . await ( 10L , TimeUnit . MILLISECONDS ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( ) ; 
 + } 
 + Assert . assertEquals ( 0 , isClean . getCount ( ) ) ; 
 + Assert . assertEquals ( 0 , allocator . offHeap ( ) . owns ( ) ) ; 
 + 
 + / / allocate above limit , check we block until " marked blocking " 
 + exec . schedule ( markBlocking , 10L , TimeUnit . MILLISECONDS ) ; 
 + allocator . allocate ( 110 , group ) ; 
 + Assert . assertNotNull ( barrier . get ( ) ) ; 
 + Assert . assertEquals ( 110 , allocator . offHeap ( ) . owns ( ) ) ; 
 + } 
 + } ; 
 + exec . submit ( run ) . get ( ) ; 
 + } 
 + } 
 + 
 + }

NEAREST DIFF:
diff - - git a / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java b / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java 
 deleted file mode 100644 
 index a0c688f . . 0000000 
 - - - a / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java 
 + + + / dev / null 
 @ @ - 1 , 153 + 0 , 0 @ @ 
 - package org . apache . cassandra . scheduler ; 
 - 
 - / * 
 - * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , 
 - * software distributed under the License is distributed on an 
 - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 - * KIND , either express or implied . See the License for the 
 - * specific language governing permissions and limitations 
 - * under the License . 
 - * 
 - * / 
 - 
 - import static org . junit . Assert . * ; 
 - 
 - import java . util . HashMap ; 
 - import java . util . Map ; 
 - import java . util . concurrent . ExecutorService ; 
 - import java . util . concurrent . SynchronousQueue ; 
 - import java . util . concurrent . ThreadPoolExecutor ; 
 - import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . atomic . AtomicInteger ; 
 - 
 - import org . apache . cassandra . config . RequestSchedulerOptions ; 
 - import org . junit . After ; 
 - import org . junit . Before ; 
 - import org . junit . Test ; 
 - 
 - public class RoundRobinSchedulerTest 
 - { 
 - ExecutorService executor ; 
 - RoundRobinScheduler scheduler ; 
 - AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 - static final String KS1 = " TestKeyspace " ; 
 - static final String KS2 = " DevKeyspace " ; 
 - static final String KS3 = " ProdKeyspace " ; 
 - 
 - Map < Integer , Integer > testValues = new HashMap < Integer , Integer > ( ) ; 
 - 
 - @ Before 
 - public void setUp ( ) 
 - { 
 - RequestSchedulerOptions options = new RequestSchedulerOptions ( ) ; 
 - / / Block the scheduler from running initially 
 - options . throttle _ limit = - 1 ; 
 - scheduler = new RoundRobinScheduler ( options ) ; 
 - SynchronousQueue < Runnable > queue = new SynchronousQueue < Runnable > ( ) ; 
 - 
 - executor = new ThreadPoolExecutor ( 20 , 
 - Integer . MAX _ VALUE , 
 - 60 * 1000 , 
 - TimeUnit . MILLISECONDS , 
 - queue ) ; 
 - / / When there are large no . of threads , the results become 
 - / / more unpredictable because of the JVM thread scheduling 
 - / / and that will be very hard to provide a consistent test 
 - runKs1 ( 1 , 10 ) ; 
 - runKs2 ( 11 , 13 ) ; 
 - runKs3 ( 14 , 15 ) ; 
 - / / Release some tasks for the scheduler to run , now that the requests 
 - / / are queued in their various buckets , behavior will be more predictable 
 - scheduler . getTaskCount ( ) . release ( 2 ) ; 
 - try 
 - { 
 - Thread . sleep ( 3000 ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 - } 
 - 
 - @ Test 
 - public void testScheduling ( ) 
 - { 
 - for ( Integer initialValue : testValues . keySet ( ) ) 
 - { 
 - / / Makes sure , requests to each keyspace get an equal chance 
 - / / Requests from one keyspace will not block requests from 
 - / / another keyspacce 
 - if ( initialValue > 10 ) 
 - { 
 - assertTrue ( initialValue > = testValues . get ( initialValue ) ) ; 
 - } 
 - } 
 - } 
 - 
 - @ After 
 - public void shutDown ( ) 
 - { 
 - executor . shutdown ( ) ; 
 - } 
 - 
 - private void runKs1 ( int start , int end ) 
 - { 
 - for ( int i = start ; i < = end ; i + + ) 
 - { 
 - executor . execute ( new Worker ( KS1 , i ) ) ; 
 - } 
 - } 
 - 
 - private void runKs2 ( int start , int end ) 
 - { 
 - for ( int i = start ; i < = end ; i + + ) 
 - { 
 - executor . execute ( new Worker ( KS2 , i ) ) ; 
 - } 
 - } 
 - 
 - private void runKs3 ( int start , int end ) 
 - { 
 - for ( int i = start ; i < = end ; i + + ) 
 - { 
 - executor . execute ( new Worker ( KS3 , i ) ) ; 
 - } 
 - } 
 - 
 - class Worker implements Runnable 
 - { 
 - String id ; 
 - int initialCount ; 
 - int runCount ; 
 - 
 - public Worker ( String id , int count ) 
 - { 
 - this . id = id ; 
 - initialCount = count ; 
 - } 
 - 
 - public void run ( ) 
 - { 
 - scheduler . queue ( Thread . currentThread ( ) , id ) ; 
 - 
 - runCount = counter . incrementAndGet ( ) ; 
 - 
 - synchronized ( scheduler ) 
 - { 
 - testValues . put ( initialCount , runCount ) ; 
 - } 
 - scheduler . release ( ) ; 
 - } 
 - } 
 - }
