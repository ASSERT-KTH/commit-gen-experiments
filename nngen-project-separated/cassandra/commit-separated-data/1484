BLEU SCORE: 0.05341087579952926

TEST MSG: Introduce a more efficient MergeIterator
GENERATED MSG: add PBSPredictor consistency modeler

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / utils / MergeIterator . java b / src / java / org / apache / cassandra / utils / MergeIterator . java <nl> index d0f116e . . c903a0f 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / MergeIterator . java <nl> + + + b / src / java / org / apache / cassandra / utils / MergeIterator . java <nl> @ @ - 70 , 28 + 70 , 87 @ @ public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implem <nl> reducer . close ( ) ; <nl> } <nl> <nl> - / * * A MergeIterator that consumes multiple input values per output value . * / <nl> - private static final class ManyToOne < In , Out > extends MergeIterator < In , Out > <nl> + / * * <nl> + * A MergeIterator that consumes multiple input values per output value . <nl> + * <nl> + * The most straightforward way to implement this is to use a { @ code PriorityQueue } of iterators , { @ code poll } it to <nl> + * find the next item to consume , then { @ code add } the iterator back after advancing . This is not very efficient as <nl> + * { @ code poll } and { @ code add } in all cases require at least { @ code log ( size ) } comparisons ( usually more than <nl> + * { @ code 2 * log ( size ) } ) per consumed item , even if the input is suitable for fast iteration . <nl> + * <nl> + * The implementation below makes use of the fact that replacing the top element in a binary heap can be done much <nl> + * more efficiently than separately removing it and placing it back , especially in the cases where the top iterator <nl> + * is to be used again very soon ( e . g . when there are large sections of the output where only a limited number of <nl> + * input iterators overlap , which is normally the case in many practically useful situations , e . g . levelled <nl> + * compaction ) . To further improve this particular scenario , we also use a short sorted section at the start of the <nl> + * queue . <nl> + * <nl> + * The heap is laid out as this ( for { @ code SORTED _ SECTION _ SIZE = = 2 } ) : <nl> + * 0 <nl> + * | <nl> + * 1 <nl> + * | <nl> + * 2 <nl> + * / \ <nl> + * 3 4 <nl> + * / \ / \ <nl> + * 5 6 7 8 <nl> + * . . . . . . . . <nl> + * Where each line is a < = relationship . <nl> + * <nl> + * In the sorted section we can advance with a single comparison per level , while advancing a level within the heap <nl> + * requires two ( so that we can find the lighter element to pop up ) . <nl> + * The sorted section adds a constant overhead when data is uniformly distributed among the iterators , but may up <nl> + * to halve the iteration time when one iterator is dominant over sections of the merged data ( as is the case with <nl> + * non - overlapping iterators ) . <nl> + * <nl> + * The iterator is further complicated by the need to avoid advancing the input iterators until an output is <nl> + * actually requested . To achieve this { @ code consume } walks the heap to find equal items without advancing the <nl> + * iterators , and { @ code advance } moves them and restores the heap structure before any items can be consumed . <nl> + * <nl> + * To avoid having to do additional comparisons in consume to identify the equal items , we keep track of equality <nl> + * between children and their parents in the heap . More precisely , the lines in the diagram above define the <nl> + * following relationship : <nl> + * parent < = child & & ( parent = = child ) = = child . equalParent <nl> + * We can track , make use of and update the equalParent field without any additional comparisons . <nl> + * <nl> + * For more formal definitions and proof of correctness , see CASSANDRA - 8915 . <nl> + * / <nl> + static final class ManyToOne < In , Out > extends MergeIterator < In , Out > <nl> { <nl> - / / a queue for return : all candidates must be open and have at least one item <nl> - protected final PriorityQueue < Candidate < In > > queue ; <nl> - / / a stack of the last consumed candidates , so that we can lazily call ' advance ( ) ' <nl> - / / TODO : if we had our own PriorityQueue implementation we could stash items <nl> - / / at the end of its array , so we wouldn ' t need this storage <nl> - protected final ArrayDeque < Candidate < In > > candidates ; <nl> + protected final Candidate < In > [ ] heap ; <nl> + <nl> + / * * Number of non - exhausted iterators . * / <nl> + int size ; <nl> + <nl> + / * * <nl> + * Position of the deepest , right - most child that needs advancing before we can start consuming . <nl> + * Because advancing changes the values of the items of each iterator , the parent - chain from any position <nl> + * in this range that needs advancing is not in correct order . The trees rooted at any position that does <nl> + * not need advancing , however , retain their prior - held binary heap property . <nl> + * / <nl> + int needingAdvance ; <nl> + <nl> + / * * <nl> + * The number of elements to keep in order before the binary heap starts , exclusive of the top heap element . <nl> + * / <nl> + static final int SORTED _ SECTION _ SIZE = 4 ; <nl> + <nl> public ManyToOne ( List < ? extends Iterator < In > > iters , Comparator < ? super In > comp , Reducer < In , Out > reducer ) <nl> { <nl> super ( iters , reducer ) ; <nl> - this . queue = new PriorityQueue < > ( Math . max ( 1 , iters . size ( ) ) ) ; <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + Candidate < In > [ ] heap = new Candidate [ iters . size ( ) ] ; <nl> + this . heap = heap ; <nl> + size = 0 ; <nl> + <nl> for ( int i = 0 ; i < iters . size ( ) ; i + + ) <nl> { <nl> Candidate < In > candidate = new Candidate < > ( i , iters . get ( i ) , comp ) ; <nl> - if ( ! candidate . advance ( ) ) <nl> - / / was empty <nl> - continue ; <nl> - this . queue . add ( candidate ) ; <nl> + heap [ size + + ] = candidate ; <nl> } <nl> - this . candidates = new ArrayDeque < > ( queue . size ( ) ) ; <nl> + needingAdvance = size ; <nl> } <nl> <nl> protected final Out computeNext ( ) <nl> @ @ - 100 , 30 + 159 , 191 @ @ public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implem <nl> return consume ( ) ; <nl> } <nl> <nl> - / * * Consume values by sending them to the reducer while they are equal . * / <nl> - protected final Out consume ( ) <nl> + / * * <nl> + * Advance all iterators that need to be advanced and place them into suitable positions in the heap . <nl> + * <nl> + * By walking the iterators backwards we know that everything after the point being processed already forms <nl> + * correctly ordered subheaps , thus we can build a subheap rooted at the current position by only sinking down <nl> + * the newly advanced iterator . Because all parents of a consumed iterator are also consumed there is no way <nl> + * that we can process one consumed iterator but skip over its parent . <nl> + * <nl> + * The procedure is the same as the one used for the initial building of a heap in the heapsort algorithm and <nl> + * has a maximum number of comparisons { @ code ( 2 * log ( size ) + SORTED _ SECTION _ SIZE / 2 ) } multiplied by the <nl> + * number of iterators whose items were consumed at the previous step , but is also at most linear in the size of <nl> + * the heap if the number of consumed elements is high ( as it is in the initial heap construction ) . With non - or <nl> + * lightly - overlapping iterators the procedure finishes after just one ( resp . a couple of ) comparisons . <nl> + * / <nl> + private void advance ( ) <nl> { <nl> - reducer . onKeyChange ( ) ; <nl> - Candidate < In > candidate = queue . peek ( ) ; <nl> - if ( candidate = = null ) <nl> - return endOfData ( ) ; <nl> - do <nl> + / / Turn the set of candidates into a heap . <nl> + for ( int i = needingAdvance - 1 ; i > = 0 ; - - i ) <nl> { <nl> - candidate = queue . poll ( ) ; <nl> - candidates . push ( candidate ) ; <nl> - reducer . reduce ( candidate . idx , candidate . item ) ; <nl> + Candidate < In > candidate = heap [ i ] ; <nl> + / * * <nl> + * needingAdvance runs to the maximum index ( and deepest - right node ) that may need advancing ; <nl> + * since the equal items that were consumed at - once may occur in sub - heap " veins " of equality , <nl> + * not all items above this deepest - right position may have been consumed ; these already form <nl> + * valid sub - heaps and can be skipped - over entirely <nl> + * / <nl> + if ( candidate . needsAdvance ( ) ) <nl> + replaceAndSink ( candidate . advance ( ) , i ) ; <nl> } <nl> - while ( queue . peek ( ) ! = null & & queue . peek ( ) . compareTo ( candidate ) = = 0 ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Consume all items that sort like the current top of the heap . As we cannot advance the iterators to let <nl> + * equivalent items pop up , we walk the heap to find them and mark them as needing advance . <nl> + * <nl> + * This relies on the equalParent flag to avoid doing any comparisons . <nl> + * / <nl> + private Out consume ( ) <nl> + { <nl> + if ( size = = 0 ) <nl> + return endOfData ( ) ; <nl> + <nl> + reducer . onKeyChange ( ) ; <nl> + assert ! heap [ 0 ] . equalParent ; <nl> + reducer . reduce ( heap [ 0 ] . idx , heap [ 0 ] . consume ( ) ) ; <nl> + final int size = this . size ; <nl> + final int sortedSectionSize = Math . min ( size , SORTED _ SECTION _ SIZE ) ; <nl> + int i ; <nl> + consume : { <nl> + for ( i = 1 ; i < sortedSectionSize ; + + i ) <nl> + { <nl> + if ( ! heap [ i ] . equalParent ) <nl> + break consume ; <nl> + reducer . reduce ( heap [ i ] . idx , heap [ i ] . consume ( ) ) ; <nl> + } <nl> + i = Math . max ( i , consumeHeap ( i ) + 1 ) ; <nl> + } <nl> + needingAdvance = i ; <nl> return reducer . getReduced ( ) ; <nl> } <nl> <nl> - / * * Advance and re - enqueue all items we consumed in the last iteration . * / <nl> - protected final void advance ( ) <nl> + / * * <nl> + * Recursively consume all items equal to equalItem in the binary subheap rooted at position idx . <nl> + * <nl> + * @ return the largest equal index found in this search . <nl> + * / <nl> + private int consumeHeap ( int idx ) <nl> { <nl> - Candidate < In > candidate ; <nl> - while ( ( candidate = candidates . pollFirst ( ) ) ! = null ) <nl> - if ( candidate . advance ( ) ) <nl> - queue . add ( candidate ) ; <nl> + if ( idx > = size | | ! heap [ idx ] . equalParent ) <nl> + return - 1 ; <nl> + <nl> + reducer . reduce ( heap [ idx ] . idx , heap [ idx ] . consume ( ) ) ; <nl> + int nextIdx = ( idx < < 1 ) - ( SORTED _ SECTION _ SIZE - 1 ) ; <nl> + return Math . max ( idx , Math . max ( consumeHeap ( nextIdx ) , consumeHeap ( nextIdx + 1 ) ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Replace an iterator in the heap with the given position and move it down the heap until it finds its proper <nl> + * position , pulling lighter elements up the heap . <nl> + * <nl> + * Whenever an equality is found between two elements that form a new parent - child relationship , the child ' s <nl> + * equalParent flag is set to true if the elements are equal . <nl> + * / <nl> + private void replaceAndSink ( Candidate < In > candidate , int currIdx ) <nl> + { <nl> + if ( candidate = = null ) <nl> + { <nl> + / / Drop iterator by replacing it with the last one in the heap . <nl> + candidate = heap [ - - size ] ; <nl> + heap [ size ] = null ; / / not necessary but helpful for debugging <nl> + } <nl> + / / The new element will be top of its heap , at this point there is no parent to be equal to . <nl> + candidate . equalParent = false ; <nl> + <nl> + final int size = this . size ; <nl> + final int sortedSectionSize = Math . min ( size - 1 , SORTED _ SECTION _ SIZE ) ; <nl> + <nl> + int nextIdx ; <nl> + <nl> + / / Advance within the sorted section , pulling up items lighter than candidate . <nl> + while ( ( nextIdx = currIdx + 1 ) < = sortedSectionSize ) <nl> + { <nl> + if ( ! heap [ nextIdx ] . equalParent ) / / if we were greater then an ( or were the ) equal parent , we are > = the child <nl> + { <nl> + int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; <nl> + if ( cmp < = 0 ) <nl> + { <nl> + heap [ nextIdx ] . equalParent = cmp = = 0 ; <nl> + heap [ currIdx ] = candidate ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + heap [ currIdx ] = heap [ nextIdx ] ; <nl> + currIdx = nextIdx ; <nl> + } <nl> + / / If size < = SORTED _ SECTION _ SIZE , nextIdx below will be no less than size , <nl> + / / because currIdx = = sortedSectionSize = = size - 1 and nextIdx becomes <nl> + / / ( size - 1 ) * 2 ) - ( size - 1 - 1 ) = = size . <nl> + <nl> + / / Advance in the binary heap , pulling up the lighter element from the two at each level . <nl> + while ( ( nextIdx = ( currIdx * 2 ) - ( sortedSectionSize - 1 ) ) + 1 < size ) <nl> + { <nl> + if ( ! heap [ nextIdx ] . equalParent ) <nl> + { <nl> + if ( ! heap [ nextIdx + 1 ] . equalParent ) <nl> + { <nl> + / / pick the smallest of the two children <nl> + int siblingCmp = heap [ nextIdx + 1 ] . compareTo ( heap [ nextIdx ] ) ; <nl> + if ( siblingCmp < 0 ) <nl> + + + nextIdx ; <nl> + <nl> + / / if we ' re smaller than this , we are done , and must only restore the heap and equalParent properties <nl> + int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; <nl> + if ( cmp < = 0 ) <nl> + { <nl> + if ( cmp = = 0 ) <nl> + { <nl> + heap [ nextIdx ] . equalParent = true ; <nl> + if ( siblingCmp = = 0 ) / / siblingCmp = = 0 = > nextIdx is the left child <nl> + heap [ nextIdx + 1 ] . equalParent = true ; <nl> + } <nl> + <nl> + heap [ currIdx ] = candidate ; <nl> + return ; <nl> + } <nl> + <nl> + if ( siblingCmp = = 0 ) <nl> + { <nl> + / / siblingCmp = = 0 = > nextIdx is still the left child <nl> + / / if the two siblings were equal , and we are inserting something greater , we will <nl> + / / pull up the left one ; this means the right gets an equalParent <nl> + heap [ nextIdx + 1 ] . equalParent = true ; <nl> + } <nl> + } <nl> + else <nl> + + + nextIdx ; / / descend down the path where we found the equal child <nl> + } <nl> + <nl> + heap [ currIdx ] = heap [ nextIdx ] ; <nl> + currIdx = nextIdx ; <nl> + } <nl> + <nl> + / / our loop guard ensures there are always two siblings to process ; typically when we exit the loop we will <nl> + / / be well past the end of the heap and this next condition will match . . . <nl> + if ( nextIdx > = size ) <nl> + { <nl> + heap [ currIdx ] = candidate ; <nl> + return ; <nl> + } <nl> + <nl> + / / . . . but sometimes we will have one last child to compare against , that has no siblings <nl> + if ( ! heap [ nextIdx ] . equalParent ) <nl> + { <nl> + int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; <nl> + if ( cmp < = 0 ) <nl> + { <nl> + heap [ nextIdx ] . equalParent = cmp = = 0 ; <nl> + heap [ currIdx ] = candidate ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + heap [ currIdx ] = heap [ nextIdx ] ; <nl> + heap [ nextIdx ] = candidate ; <nl> } <nl> } <nl> <nl> @ @ - 134 , 6 + 354 , 7 @ @ public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implem <nl> private final Comparator < ? super In > comp ; <nl> private final int idx ; <nl> private In item ; <nl> + boolean equalParent ; <nl> <nl> public Candidate ( int idx , Iterator < ? extends In > iter , Comparator < ? super In > comp ) <nl> { <nl> @ @ - 142 , 19 + 363 , 33 @ @ public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implem <nl> this . idx = idx ; <nl> } <nl> <nl> - / * * @ return True if our iterator had an item , and it is now available * / <nl> - protected boolean advance ( ) <nl> + / * * @ return this if our iterator had an item , and it is now available , otherwise null * / <nl> + protected Candidate < In > advance ( ) <nl> { <nl> if ( ! iter . hasNext ( ) ) <nl> - return false ; <nl> + return null ; <nl> item = iter . next ( ) ; <nl> - return true ; <nl> + return this ; <nl> } <nl> <nl> public int compareTo ( Candidate < In > that ) <nl> { <nl> + assert item ! = null & & that . item ! = null ; <nl> return comp . compare ( this . item , that . item ) ; <nl> } <nl> + <nl> + public In consume ( ) <nl> + { <nl> + In temp = item ; <nl> + item = null ; <nl> + assert temp ! = null ; <nl> + return temp ; <nl> + } <nl> + <nl> + public boolean needsAdvance ( ) <nl> + { <nl> + return item = = null ; <nl> + } <nl> } <nl> <nl> / * * Accumulator that collects values of type A , and outputs a value of type B . * / <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / BTreeSet . java b / src / java / org / apache / cassandra / utils / btree / BTreeSet . java <nl> index d1271fc . . 7646693 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / BTreeSet . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / BTreeSet . java <nl> @ @ - 175 , 7 + 175 , 7 @ @ public class BTreeSet < V > implements NavigableSet < V > , List < V > <nl> @ Override <nl> public BTreeSet < V > descendingSet ( ) <nl> { <nl> - return new BTreeRange < > ( this . tree , this . comparator ) . descendingSet ( ) ; <nl> + return new BTreeRange < V > ( this . tree , this . comparator ) . descendingSet ( ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / test / unit / org / apache / cassandra / utils / MergeIteratorComparisonTest . java b / test / unit / org / apache / cassandra / utils / MergeIteratorComparisonTest . java <nl> new file mode 100644 <nl> index 0000000 . . 6a4bd2b <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / utils / MergeIteratorComparisonTest . java <nl> @ @ - 0 , 0 + 1 , 733 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . * ; <nl> + <nl> + import com . google . common . base . Function ; <nl> + import com . google . common . base . Objects ; <nl> + import com . google . common . collect . AbstractIterator ; <nl> + import com . google . common . collect . ImmutableSet ; <nl> + import com . google . common . collect . Iterators ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Ordering ; <nl> + import com . google . common . collect . Sets ; <nl> + <nl> + import org . junit . Assert ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . db . marshal . AbstractType ; <nl> + import org . apache . cassandra . db . marshal . TimeUUIDType ; <nl> + import org . apache . cassandra . db . marshal . UUIDType ; <nl> + import org . apache . cassandra . utils . MergeIterator . Candidate ; <nl> + import org . apache . cassandra . utils . MergeIterator . Reducer ; <nl> + <nl> + public class MergeIteratorComparisonTest <nl> + { <nl> + private static class CountingComparator < T > implements Comparator < T > <nl> + { <nl> + final Comparator < T > wrapped ; <nl> + int count = 0 ; <nl> + <nl> + protected CountingComparator ( Comparator < T > wrapped ) <nl> + { <nl> + this . wrapped = wrapped ; <nl> + } <nl> + <nl> + public int compare ( T o1 , T o2 ) <nl> + { <nl> + count + + ; <nl> + return wrapped . compare ( o1 , o2 ) ; <nl> + } <nl> + } <nl> + <nl> + static int ITERATOR _ COUNT = 15 ; <nl> + static int LIST _ LENGTH = 15000 ; <nl> + static boolean BENCHMARK = false ; <nl> + <nl> + @ Test <nl> + public void testRandomInts ( ) <nl> + { <nl> + System . out . println ( " testRandomInts " ) ; <nl> + final Random r = new Random ( ) ; <nl> + Reducer < Integer , Counted < Integer > > reducer = new Counter < Integer > ( ) ; <nl> + <nl> + List < List < Integer > > lists = new NaturalListGenerator < Integer > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + @ Override <nl> + public Integer next ( ) <nl> + { <nl> + return r . nextInt ( 5 * LIST _ LENGTH ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNonOverlapInts ( ) <nl> + { <nl> + System . out . println ( " testNonOverlapInts " ) ; <nl> + Reducer < Integer , Counted < Integer > > reducer = new Counter < Integer > ( ) ; <nl> + <nl> + List < List < Integer > > lists = new NaturalListGenerator < Integer > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + int next = 1 ; <nl> + @ Override <nl> + public Integer next ( ) <nl> + { <nl> + return next + + ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCombinationInts ( ) <nl> + { <nl> + System . out . println ( " testCombinationInts " ) ; <nl> + final Random r = new Random ( ) ; <nl> + Reducer < Integer , Counted < Integer > > reducer = new Counter < Integer > ( ) ; <nl> + <nl> + List < List < Integer > > lists = new NaturalListGenerator < Integer > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + int next = 1 ; <nl> + @ Override <nl> + public Integer next ( ) <nl> + { <nl> + return r . nextBoolean ( ) ? r . nextInt ( 5 * LIST _ LENGTH ) : next + + ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testLCSTotalOverlap ( ) <nl> + { <nl> + testLCS ( 2 , LIST _ LENGTH / 100 , 1f ) ; <nl> + testLCS ( 3 , LIST _ LENGTH / 100 , 1f ) ; <nl> + testLCS ( 3 , LIST _ LENGTH / 100 , 1f , 10 , LIST _ LENGTH ) ; <nl> + testLCS ( 4 , LIST _ LENGTH / 100 , 1f ) ; <nl> + testLCS ( 4 , LIST _ LENGTH / 100 , 1f , 10 , LIST _ LENGTH ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testLCSPartialOverlap ( ) <nl> + { <nl> + testLCS ( 2 , LIST _ LENGTH / 100 , 0 . 5f ) ; <nl> + testLCS ( 3 , LIST _ LENGTH / 100 , 0 . 5f ) ; <nl> + testLCS ( 3 , LIST _ LENGTH / 100 , 0 . 5f , 10 , LIST _ LENGTH ) ; <nl> + testLCS ( 4 , LIST _ LENGTH / 100 , 0 . 5f ) ; <nl> + testLCS ( 4 , LIST _ LENGTH / 100 , 0 . 5f , 10 , LIST _ LENGTH ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testLCSNoOverlap ( ) <nl> + { <nl> + testLCS ( 2 , LIST _ LENGTH / 100 , 0f ) ; <nl> + testLCS ( 3 , LIST _ LENGTH / 100 , 0f ) ; <nl> + testLCS ( 3 , LIST _ LENGTH / 100 , 0f , 10 , LIST _ LENGTH ) ; <nl> + testLCS ( 4 , LIST _ LENGTH / 100 , 0f ) ; <nl> + testLCS ( 4 , LIST _ LENGTH / 100 , 0f , 10 , LIST _ LENGTH ) ; <nl> + } <nl> + <nl> + public void testLCS ( int levelCount , int levelMultiplier , float levelOverlap ) <nl> + { <nl> + testLCS ( levelCount , levelMultiplier , levelOverlap , 0 , 0 ) ; <nl> + } <nl> + public void testLCS ( int levelCount , int levelMultiplier , float levelOverlap , int countOfL0 , int sizeOfL0 ) <nl> + { <nl> + System . out . printf ( " testLCS ( lc = % d , lm = % d , o = % . 2f , L0 = % d * % d ) \ n " , levelCount , levelMultiplier , levelOverlap , countOfL0 , countOfL0 = = 0 ? 0 : sizeOfL0 / countOfL0 ) ; <nl> + final Random r = new Random ( ) ; <nl> + Reducer < Integer , Counted < Integer > > reducer = new Counter < Integer > ( ) ; <nl> + List < List < Integer > > lists = new LCSGenerator < Integer > ( Ordering . < Integer > natural ( ) , levelCount , levelMultiplier , levelOverlap ) { <nl> + @ Override <nl> + public Integer newItem ( ) <nl> + { <nl> + return r . nextInt ( ) ; <nl> + } <nl> + } . result ; <nl> + if ( sizeOfL0 > 0 & & countOfL0 > 0 ) <nl> + lists . addAll ( new NaturalListGenerator < Integer > ( countOfL0 , sizeOfL0 / countOfL0 ) <nl> + { <nl> + Integer next ( ) <nl> + { <nl> + return r . nextInt ( ) ; <nl> + } <nl> + } . result ) ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRandomStrings ( ) <nl> + { <nl> + System . out . println ( " testRandomStrings " ) ; <nl> + final Random r = new Random ( ) ; <nl> + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; <nl> + <nl> + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + @ Override <nl> + public String next ( ) <nl> + { <nl> + return " longish _ prefix _ " + r . nextInt ( 5 * LIST _ LENGTH ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNonOverlapStrings ( ) <nl> + { <nl> + System . out . println ( " testNonOverlapStrings " ) ; <nl> + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; <nl> + <nl> + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + int next = 1 ; <nl> + @ Override <nl> + public String next ( ) <nl> + { <nl> + return " longish _ prefix _ " + next + + ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCombinationStrings ( ) <nl> + { <nl> + System . out . println ( " testCombinationStrings " ) ; <nl> + final Random r = new Random ( ) ; <nl> + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; <nl> + <nl> + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + int next = 1 ; <nl> + public String next ( ) <nl> + { <nl> + return " longish _ prefix _ " + ( r . nextBoolean ( ) ? r . nextInt ( 5 * LIST _ LENGTH ) : next + + ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTimeUuids ( ) <nl> + { <nl> + System . out . println ( " testTimeUuids " ) ; <nl> + Reducer < UUID , Counted < UUID > > reducer = new Counter < UUID > ( ) ; <nl> + <nl> + List < List < UUID > > lists = new NaturalListGenerator < UUID > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + @ Override <nl> + public UUID next ( ) <nl> + { <nl> + return UUIDGen . getTimeUUID ( ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRandomUuids ( ) <nl> + { <nl> + System . out . println ( " testRandomUuids " ) ; <nl> + Reducer < UUID , Counted < UUID > > reducer = new Counter < UUID > ( ) ; <nl> + <nl> + List < List < UUID > > lists = new NaturalListGenerator < UUID > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + @ Override <nl> + public UUID next ( ) <nl> + { <nl> + return UUID . randomUUID ( ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTimeUuidType ( ) <nl> + { <nl> + System . out . println ( " testTimeUuidType " ) ; <nl> + final AbstractType < UUID > type = TimeUUIDType . instance ; <nl> + Reducer < ByteBuffer , Counted < ByteBuffer > > reducer = new Counter < ByteBuffer > ( ) ; <nl> + <nl> + List < List < ByteBuffer > > lists = new SimpleListGenerator < ByteBuffer > ( type , ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + @ Override <nl> + public ByteBuffer next ( ) <nl> + { <nl> + return type . decompose ( UUIDGen . getTimeUUID ( ) ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists , type ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testUuidType ( ) <nl> + { <nl> + System . out . println ( " testUuidType " ) ; <nl> + final AbstractType < UUID > type = UUIDType . instance ; <nl> + Reducer < ByteBuffer , Counted < ByteBuffer > > reducer = new Counter < ByteBuffer > ( ) ; <nl> + <nl> + List < List < ByteBuffer > > lists = new SimpleListGenerator < ByteBuffer > ( type , ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + @ Override <nl> + public ByteBuffer next ( ) <nl> + { <nl> + return type . decompose ( UUIDGen . getTimeUUID ( ) ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists , type ) ; <nl> + } <nl> + <nl> + <nl> + @ Test <nl> + public void testSets ( ) <nl> + { <nl> + System . out . println ( " testSets " ) ; <nl> + final Random r = new Random ( ) ; <nl> + <nl> + Reducer < KeyedSet < Integer , UUID > , KeyedSet < Integer , UUID > > reducer = new Union < Integer , UUID > ( ) ; <nl> + <nl> + List < List < KeyedSet < Integer , UUID > > > lists = new NaturalListGenerator < KeyedSet < Integer , UUID > > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + @ Override <nl> + public KeyedSet < Integer , UUID > next ( ) <nl> + { <nl> + return new KeyedSet < > ( r . nextInt ( 5 * LIST _ LENGTH ) , UUIDGen . getTimeUUID ( ) ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + / * * / <nl> + <nl> + @ Test <nl> + public void testLimitedOverlapStrings2 ( ) <nl> + { <nl> + System . out . println ( " testLimitedOverlapStrings2 " ) ; <nl> + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; <nl> + <nl> + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + int next = 0 ; <nl> + @ Override <nl> + public String next ( ) <nl> + { <nl> + + + next ; <nl> + int list = next / LIST _ LENGTH ; <nl> + int id = next % LIST _ LENGTH ; <nl> + return " longish _ prefix _ " + ( id + list * LIST _ LENGTH / 2 ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testLimitedOverlapStrings3 ( ) <nl> + { <nl> + System . out . println ( " testLimitedOverlapStrings3 " ) ; <nl> + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; <nl> + <nl> + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { <nl> + int next = 0 ; <nl> + @ Override <nl> + public String next ( ) <nl> + { <nl> + + + next ; <nl> + int list = next / LIST _ LENGTH ; <nl> + int id = next % LIST _ LENGTH ; <nl> + return " longish _ prefix _ " + ( id + list * LIST _ LENGTH / 3 ) ; <nl> + } <nl> + } . result ; <nl> + testMergeIterator ( reducer , lists ) ; <nl> + } <nl> + <nl> + private static abstract class ListGenerator < T > <nl> + { <nl> + abstract boolean hasMoreItems ( ) ; <nl> + abstract boolean hasMoreLists ( ) ; <nl> + abstract T next ( ) ; <nl> + <nl> + final Comparator < T > comparator ; <nl> + final List < List < T > > result = Lists . newArrayList ( ) ; <nl> + <nl> + protected ListGenerator ( Comparator < T > comparator ) <nl> + { <nl> + this . comparator = comparator ; <nl> + } <nl> + <nl> + void build ( ) <nl> + { <nl> + while ( hasMoreLists ( ) ) <nl> + { <nl> + List < T > l = Lists . newArrayList ( ) ; <nl> + while ( hasMoreItems ( ) ) <nl> + l . add ( next ( ) ) ; <nl> + Collections . sort ( l , comparator ) ; <nl> + result . add ( l ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private static abstract class NaturalListGenerator < T extends Comparable < T > > extends SimpleListGenerator < T > <nl> + { <nl> + private NaturalListGenerator ( int listCount , int perListCount ) <nl> + { <nl> + super ( Ordering . natural ( ) , listCount , perListCount ) ; <nl> + } <nl> + } <nl> + private static abstract class SimpleListGenerator < T > extends ListGenerator < T > <nl> + { <nl> + final int listCount ; <nl> + final int perListCount ; <nl> + <nl> + int listIdx = 0 , itemIdx = 0 ; <nl> + <nl> + private SimpleListGenerator ( Comparator < T > comparator , int listCount , int perListCount ) <nl> + { <nl> + super ( comparator ) ; <nl> + this . listCount = listCount ; <nl> + this . perListCount = perListCount ; <nl> + build ( ) ; <nl> + } <nl> + <nl> + public boolean hasMoreItems ( ) <nl> + { <nl> + return itemIdx + + < perListCount ; <nl> + } <nl> + <nl> + public boolean hasMoreLists ( ) <nl> + { <nl> + itemIdx = 0 ; <nl> + return listIdx + + < listCount ; <nl> + } <nl> + } <nl> + <nl> + private static abstract class LCSGenerator < T > extends ListGenerator < T > <nl> + { <nl> + final int levelCount ; <nl> + final int itemMultiplier ; <nl> + final float levelOverlap ; <nl> + <nl> + int levelIdx , itemIdx ; <nl> + int levelItems , overlapItems , runningTotalItems ; <nl> + final Random random = new Random ( ) ; <nl> + <nl> + public LCSGenerator ( Comparator < T > comparator , int levelCount , int l1Items , float levelOverlap ) <nl> + { <nl> + super ( comparator ) ; <nl> + this . levelCount = levelCount ; <nl> + this . itemMultiplier = l1Items ; <nl> + this . levelOverlap = levelOverlap ; <nl> + build ( ) ; <nl> + } <nl> + <nl> + public boolean hasMoreItems ( ) <nl> + { <nl> + return itemIdx + + < levelItems ; <nl> + } <nl> + <nl> + public boolean hasMoreLists ( ) <nl> + { <nl> + if ( result . size ( ) > 0 ) <nl> + runningTotalItems + = result . get ( result . size ( ) - 1 ) . size ( ) ; <nl> + itemIdx = 0 ; <nl> + levelItems = itemMultiplier * ( int ) Math . pow ( 10 , levelCount - levelIdx ) ; <nl> + overlapItems = levelIdx = = 0 ? 0 : ( int ) ( levelItems * levelOverlap ) ; <nl> + return levelIdx + + < levelCount ; <nl> + } <nl> + <nl> + abstract T newItem ( ) ; <nl> + <nl> + T next ( ) <nl> + { <nl> + if ( itemIdx < overlapItems ) <nl> + { <nl> + int item = random . nextInt ( runningTotalItems ) ; <nl> + for ( List < T > list : result ) <nl> + { <nl> + if ( item < list . size ( ) ) return list . get ( item ) ; <nl> + else item - = list . size ( ) ; <nl> + } <nl> + } <nl> + return newItem ( ) ; <nl> + } <nl> + } <nl> + <nl> + public < T extends Comparable < T > > void testMergeIterator ( Reducer < T , ? > reducer , List < List < T > > lists ) <nl> + { <nl> + testMergeIterator ( reducer , lists , Ordering . natural ( ) ) ; <nl> + } <nl> + public < T > void testMergeIterator ( Reducer < T , ? > reducer , List < List < T > > lists , Comparator < T > comparator ) <nl> + { <nl> + { <nl> + IMergeIterator < T , ? > tested = MergeIterator . get ( closeableIterators ( lists ) , comparator , reducer ) ; <nl> + IMergeIterator < T , ? > base = new MergeIteratorPQ < > ( closeableIterators ( lists ) , comparator , reducer ) ; <nl> + / / If test fails , try the version below for improved reporting : <nl> + Object [ ] basearr = Iterators . toArray ( base , Object . class ) ; <nl> + Assert . assertArrayEquals ( basearr , Iterators . toArray ( tested , Object . class ) ) ; <nl> + / / Assert . assertTrue ( Iterators . elementsEqual ( base , tested ) ) ; <nl> + if ( ! BENCHMARK ) <nl> + return ; <nl> + } <nl> + <nl> + CountingComparator < T > cmp , cmpb ; <nl> + cmp = new CountingComparator < > ( comparator ) ; cmpb = new CountingComparator < > ( comparator ) ; <nl> + System . out . println ( ) ; <nl> + for ( int i = 0 ; i < 10 ; + + i ) { <nl> + benchmarkIterator ( MergeIterator . get ( closeableIterators ( lists ) , cmp , reducer ) , cmp ) ; <nl> + benchmarkIterator ( new MergeIteratorPQ < > ( closeableIterators ( lists ) , cmpb , reducer ) , cmpb ) ; <nl> + } <nl> + System . out . format ( " MI : % . 2f \ n " , cmp . count / ( double ) cmpb . count ) ; <nl> + } <nl> + <nl> + public < T > void benchmarkIterator ( IMergeIterator < T , ? > it , CountingComparator < T > comparator ) <nl> + { <nl> + System . out . format ( " Testing % 30s . . . " , it . getClass ( ) . getSimpleName ( ) ) ; <nl> + long time = System . currentTimeMillis ( ) ; <nl> + Object value = null ; <nl> + while ( it . hasNext ( ) ) <nl> + value = it . next ( ) ; <nl> + time = System . currentTimeMillis ( ) - time ; <nl> + String type = " " ; <nl> + if ( value instanceof Counted < ? > ) <nl> + { <nl> + type = " type " + ( ( Counted < ? > ) value ) . item . getClass ( ) . getSimpleName ( ) ; <nl> + } <nl> + System . out . format ( " % 15s time % 5dms ; comparisons : % d \ n " , type , time , comparator . count ) ; <nl> + } <nl> + <nl> + public < T > List < CloseableIterator < T > > closeableIterators ( List < List < T > > iterators ) <nl> + { <nl> + return Lists . transform ( iterators , new Function < List < T > , CloseableIterator < T > > ( ) { <nl> + <nl> + @ Override <nl> + public CloseableIterator < T > apply ( List < T > arg ) <nl> + { <nl> + return new CLI < T > ( arg . iterator ( ) ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + static class Counted < T > { <nl> + T item ; <nl> + int count ; <nl> + <nl> + Counted ( T item ) { <nl> + this . item = item ; <nl> + count = 0 ; <nl> + } <nl> + <nl> + public boolean equals ( Object obj ) <nl> + { <nl> + if ( obj = = null | | ! ( obj instanceof Counted ) ) <nl> + return false ; <nl> + Counted < ? > c = ( Counted < ? > ) obj ; <nl> + return Objects . equal ( item , c . item ) & & count = = c . count ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + return item . toString ( ) + " x " + count ; <nl> + } <nl> + } <nl> + <nl> + static class Counter < T > extends Reducer < T , Counted < T > > { <nl> + Counted < T > current = null ; <nl> + boolean read = true ; <nl> + <nl> + @ Override <nl> + public void reduce ( int idx , T next ) <nl> + { <nl> + if ( current = = null ) <nl> + current = new Counted < T > ( next ) ; <nl> + assert current . item . equals ( next ) ; <nl> + + + current . count ; <nl> + } <nl> + <nl> + @ Override <nl> + protected void onKeyChange ( ) <nl> + { <nl> + assert read ; <nl> + current = null ; <nl> + read = false ; <nl> + } <nl> + <nl> + @ Override <nl> + protected Counted < T > getReduced ( ) <nl> + { <nl> + assert current ! = null ; <nl> + read = true ; <nl> + return current ; <nl> + } <nl> + } <nl> + <nl> + static class KeyedSet < K extends Comparable < ? super K > , V > extends Pair < K , Set < V > > implements Comparable < KeyedSet < K , V > > <nl> + { <nl> + protected KeyedSet ( K left , V right ) <nl> + { <nl> + super ( left , ImmutableSet . of ( right ) ) ; <nl> + } <nl> + <nl> + protected KeyedSet ( K left , Collection < V > right ) <nl> + { <nl> + super ( left , Sets . newHashSet ( right ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int compareTo ( KeyedSet < K , V > o ) <nl> + { <nl> + return left . compareTo ( o . left ) ; <nl> + } <nl> + } <nl> + <nl> + static class Union < K extends Comparable < K > , V > extends Reducer < KeyedSet < K , V > , KeyedSet < K , V > > { <nl> + KeyedSet < K , V > current = null ; <nl> + boolean read = true ; <nl> + <nl> + @ Override <nl> + public void reduce ( int idx , KeyedSet < K , V > next ) <nl> + { <nl> + if ( current = = null ) <nl> + current = new KeyedSet < > ( next . left , next . right ) ; <nl> + else { <nl> + assert current . left . equals ( next . left ) ; <nl> + current . right . addAll ( next . right ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + protected void onKeyChange ( ) <nl> + { <nl> + assert read ; <nl> + current = null ; <nl> + read = false ; <nl> + } <nl> + <nl> + @ Override <nl> + protected KeyedSet < K , V > getReduced ( ) <nl> + { <nl> + assert current ! = null ; <nl> + read = true ; <nl> + return current ; <nl> + } <nl> + } <nl> + <nl> + / / closeable list iterator <nl> + public static class CLI < E > extends AbstractIterator < E > implements CloseableIterator < E > <nl> + { <nl> + Iterator < E > iter ; <nl> + boolean closed = false ; <nl> + public CLI ( Iterator < E > items ) <nl> + { <nl> + this . iter = items ; <nl> + } <nl> + <nl> + protected E computeNext ( ) <nl> + { <nl> + if ( ! iter . hasNext ( ) ) return endOfData ( ) ; <nl> + return iter . next ( ) ; <nl> + } <nl> + <nl> + public void close ( ) <nl> + { <nl> + assert ! this . closed ; <nl> + this . closed = true ; <nl> + } <nl> + } <nl> + <nl> + / / Old MergeIterator implementation for comparison . <nl> + public class MergeIteratorPQ < In , Out > extends MergeIterator < In , Out > implements IMergeIterator < In , Out > <nl> + { <nl> + / / a queue for return : all candidates must be open and have at least one item <nl> + protected final PriorityQueue < CandidatePQ < In > > queue ; <nl> + / / a stack of the last consumed candidates , so that we can lazily call ' advance ( ) ' <nl> + / / TODO : if we had our own PriorityQueue implementation we could stash items <nl> + / / at the end of its array , so we wouldn ' t need this storage <nl> + protected final ArrayDeque < CandidatePQ < In > > candidates ; <nl> + public MergeIteratorPQ ( List < ? extends Iterator < In > > iters , Comparator < In > comp , Reducer < In , Out > reducer ) <nl> + { <nl> + super ( iters , reducer ) ; <nl> + this . queue = new PriorityQueue < > ( Math . max ( 1 , iters . size ( ) ) ) ; <nl> + for ( int i = 0 ; i < iters . size ( ) ; i + + ) <nl> + { <nl> + CandidatePQ < In > candidate = new CandidatePQ < > ( i , iters . get ( i ) , comp ) ; <nl> + if ( ! candidate . advance ( ) ) <nl> + / / was empty <nl> + continue ; <nl> + this . queue . add ( candidate ) ; <nl> + } <nl> + this . candidates = new ArrayDeque < > ( queue . size ( ) ) ; <nl> + } <nl> + <nl> + protected final Out computeNext ( ) <nl> + { <nl> + advance ( ) ; <nl> + return consume ( ) ; <nl> + } <nl> + <nl> + / * * Consume values by sending them to the reducer while they are equal . * / <nl> + protected final Out consume ( ) <nl> + { <nl> + CandidatePQ < In > candidate = queue . peek ( ) ; <nl> + if ( candidate = = null ) <nl> + return endOfData ( ) ; <nl> + reducer . onKeyChange ( ) ; <nl> + do <nl> + { <nl> + candidate = queue . poll ( ) ; <nl> + candidates . push ( candidate ) ; <nl> + reducer . reduce ( candidate . idx , candidate . item ) ; <nl> + } <nl> + while ( queue . peek ( ) ! = null & & queue . peek ( ) . compareTo ( candidate ) = = 0 ) ; <nl> + return reducer . getReduced ( ) ; <nl> + } <nl> + <nl> + / * * Advance and re - enqueue all items we consumed in the last iteration . * / <nl> + protected final void advance ( ) <nl> + { <nl> + CandidatePQ < In > candidate ; <nl> + while ( ( candidate = candidates . pollFirst ( ) ) ! = null ) <nl> + if ( candidate . advance ( ) ) <nl> + queue . add ( candidate ) ; <nl> + } <nl> + } <nl> + <nl> + / / Holds and is comparable by the head item of an iterator it owns <nl> + protected static final class CandidatePQ < In > implements Comparable < CandidatePQ < In > > <nl> + { <nl> + private final Iterator < ? extends In > iter ; <nl> + private final Comparator < ? super In > comp ; <nl> + private final int idx ; <nl> + private In item ; <nl> + boolean equalParent ; <nl> + <nl> + public CandidatePQ ( int idx , Iterator < ? extends In > iter , Comparator < ? super In > comp ) <nl> + { <nl> + this . iter = iter ; <nl> + this . comp = comp ; <nl> + this . idx = idx ; <nl> + } <nl> + <nl> + / * * @ return true if our iterator had an item , and it is now available * / <nl> + protected boolean advance ( ) <nl> + { <nl> + if ( ! iter . hasNext ( ) ) <nl> + return false ; <nl> + item = iter . next ( ) ; <nl> + return true ; <nl> + } <nl> + <nl> + public int compareTo ( CandidatePQ < In > that ) <nl> + { <nl> + return comp . compare ( this . item , that . item ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e48fbfd . . f598aa2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 11 , 6 + 11 , 7 @ @ <nl> * fix error when using ORDER BY with extended selections ( CASSANDRA - 4689 ) <nl> * ( CQL3 ) Fix validation for IN queries for non - PK cols ( CASSANDRA - 4709 ) <nl> * fix re - created keyspace disappering after 1 . 1 . 5 upgrade ( CASSANDRA - 4698 ) <nl> + * ( CLI ) display elapsed time in 2 fraction digits ( CASSANDRA - 3460 ) <nl> Merged from 1 . 0 : <nl> * Switch from NBHM to CHM in MessagingService ' s callback map , which <nl> prevents OOM in long - running instances ( CASSANDRA - 4708 ) <nl> diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java <nl> index d0fb543 . . b32b0f7 100644 <nl> - - - a / src / java / org / apache / cassandra / cli / CliClient . java <nl> + + + b / src / java / org / apache / cassandra / cli / CliClient . java <nl> @ @ - 461 , 7 + 461 , 7 @ @ public class CliClient <nl> throws InvalidRequestException , UnavailableException , TimedOutException , TException , IllegalAccessException , NotFoundException , InstantiationException , NoSuchFieldException <nl> { <nl> <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> ColumnParent parent = new ColumnParent ( columnFamily ) ; <nl> if ( superColumnName ! = null ) <nl> parent . setSuper _ column ( superColumnName ) ; <nl> @ @ - 565 , 7 + 565 , 7 @ @ public class CliClient <nl> { <nl> if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> return ; <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> Tree columnFamilySpec = statement . getChild ( 0 ) ; <nl> String columnFamily = CliCompiler . getColumnFamily ( columnFamilySpec , keyspacesMap . get ( keySpace ) . cf _ defs ) ; <nl> ByteBuffer key = getKeyAsBytes ( columnFamily , columnFamilySpec . getChild ( 1 ) ) ; <nl> @ @ - 734 , 7 + 734 , 7 @ @ public class CliClient <nl> if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> return ; <nl> <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> <nl> IndexClause clause = new IndexClause ( ) ; <nl> String columnFamily = CliCompiler . getColumnFamily ( statement , keyspacesMap . get ( keySpace ) . cf _ defs ) ; <nl> @ @ - 828 , 7 + 828 , 7 @ @ public class CliClient <nl> if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> return ; <nl> <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> / / ^ ( NODE _ COLUMN _ ACCESS < cf > < key > < column > ) <nl> Tree columnFamilySpec = statement . getChild ( 0 ) ; <nl> Tree keyTree = columnFamilySpec . getChild ( 1 ) ; / / could be a function or regular text <nl> @ @ - 1323 , 7 + 1323 , 7 @ @ public class CliClient <nl> if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> return ; <nl> <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> <nl> / / extract column family <nl> String columnFamily = CliCompiler . getColumnFamily ( statement , keyspacesMap . get ( keySpace ) . cf _ defs ) ; <nl> @ @ - 2968 , 9 + 2968 , 25 @ @ public class CliClient <nl> return false ; <nl> } <nl> <nl> + / * * <nl> + * Print elapsed time . Print 2 fraction digits if eta is under 10 ms . <nl> + * @ param startTime starting time in nanoseconds <nl> + * / <nl> private void elapsedTime ( long startTime ) <nl> { <nl> - sessionState . out . println ( " Elapsed time : " + ( System . currentTimeMillis ( ) - startTime ) + " msec ( s ) . " ) ; <nl> + / * * time elapsed in nanoseconds * / <nl> + long eta = System . nanoTime ( ) - startTime ; <nl> + <nl> + sessionState . out . print ( " Elapsed time : " ) ; <nl> + if ( eta < 10000000 ) <nl> + { <nl> + sessionState . out . print ( Math . round ( eta / 10000 . 0 ) / 100 . 0 ) ; <nl> + } <nl> + else <nl> + { <nl> + sessionState . out . print ( Math . round ( eta / 1000000 . 0 ) ) ; <nl> + } <nl> + sessionState . out . println ( " msec ( s ) . " ) ; <nl> } <nl> <nl> class CfAssumptions

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / utils / MergeIterator . java b / src / java / org / apache / cassandra / utils / MergeIterator . java 
 index d0f116e . . c903a0f 100644 
 - - - a / src / java / org / apache / cassandra / utils / MergeIterator . java 
 + + + b / src / java / org / apache / cassandra / utils / MergeIterator . java 
 @ @ - 70 , 28 + 70 , 87 @ @ public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implem 
 reducer . close ( ) ; 
 } 
 
 - / * * A MergeIterator that consumes multiple input values per output value . * / 
 - private static final class ManyToOne < In , Out > extends MergeIterator < In , Out > 
 + / * * 
 + * A MergeIterator that consumes multiple input values per output value . 
 + * 
 + * The most straightforward way to implement this is to use a { @ code PriorityQueue } of iterators , { @ code poll } it to 
 + * find the next item to consume , then { @ code add } the iterator back after advancing . This is not very efficient as 
 + * { @ code poll } and { @ code add } in all cases require at least { @ code log ( size ) } comparisons ( usually more than 
 + * { @ code 2 * log ( size ) } ) per consumed item , even if the input is suitable for fast iteration . 
 + * 
 + * The implementation below makes use of the fact that replacing the top element in a binary heap can be done much 
 + * more efficiently than separately removing it and placing it back , especially in the cases where the top iterator 
 + * is to be used again very soon ( e . g . when there are large sections of the output where only a limited number of 
 + * input iterators overlap , which is normally the case in many practically useful situations , e . g . levelled 
 + * compaction ) . To further improve this particular scenario , we also use a short sorted section at the start of the 
 + * queue . 
 + * 
 + * The heap is laid out as this ( for { @ code SORTED _ SECTION _ SIZE = = 2 } ) : 
 + * 0 
 + * | 
 + * 1 
 + * | 
 + * 2 
 + * / \ 
 + * 3 4 
 + * / \ / \ 
 + * 5 6 7 8 
 + * . . . . . . . . 
 + * Where each line is a < = relationship . 
 + * 
 + * In the sorted section we can advance with a single comparison per level , while advancing a level within the heap 
 + * requires two ( so that we can find the lighter element to pop up ) . 
 + * The sorted section adds a constant overhead when data is uniformly distributed among the iterators , but may up 
 + * to halve the iteration time when one iterator is dominant over sections of the merged data ( as is the case with 
 + * non - overlapping iterators ) . 
 + * 
 + * The iterator is further complicated by the need to avoid advancing the input iterators until an output is 
 + * actually requested . To achieve this { @ code consume } walks the heap to find equal items without advancing the 
 + * iterators , and { @ code advance } moves them and restores the heap structure before any items can be consumed . 
 + * 
 + * To avoid having to do additional comparisons in consume to identify the equal items , we keep track of equality 
 + * between children and their parents in the heap . More precisely , the lines in the diagram above define the 
 + * following relationship : 
 + * parent < = child & & ( parent = = child ) = = child . equalParent 
 + * We can track , make use of and update the equalParent field without any additional comparisons . 
 + * 
 + * For more formal definitions and proof of correctness , see CASSANDRA - 8915 . 
 + * / 
 + static final class ManyToOne < In , Out > extends MergeIterator < In , Out > 
 { 
 - / / a queue for return : all candidates must be open and have at least one item 
 - protected final PriorityQueue < Candidate < In > > queue ; 
 - / / a stack of the last consumed candidates , so that we can lazily call ' advance ( ) ' 
 - / / TODO : if we had our own PriorityQueue implementation we could stash items 
 - / / at the end of its array , so we wouldn ' t need this storage 
 - protected final ArrayDeque < Candidate < In > > candidates ; 
 + protected final Candidate < In > [ ] heap ; 
 + 
 + / * * Number of non - exhausted iterators . * / 
 + int size ; 
 + 
 + / * * 
 + * Position of the deepest , right - most child that needs advancing before we can start consuming . 
 + * Because advancing changes the values of the items of each iterator , the parent - chain from any position 
 + * in this range that needs advancing is not in correct order . The trees rooted at any position that does 
 + * not need advancing , however , retain their prior - held binary heap property . 
 + * / 
 + int needingAdvance ; 
 + 
 + / * * 
 + * The number of elements to keep in order before the binary heap starts , exclusive of the top heap element . 
 + * / 
 + static final int SORTED _ SECTION _ SIZE = 4 ; 
 + 
 public ManyToOne ( List < ? extends Iterator < In > > iters , Comparator < ? super In > comp , Reducer < In , Out > reducer ) 
 { 
 super ( iters , reducer ) ; 
 - this . queue = new PriorityQueue < > ( Math . max ( 1 , iters . size ( ) ) ) ; 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + Candidate < In > [ ] heap = new Candidate [ iters . size ( ) ] ; 
 + this . heap = heap ; 
 + size = 0 ; 
 + 
 for ( int i = 0 ; i < iters . size ( ) ; i + + ) 
 { 
 Candidate < In > candidate = new Candidate < > ( i , iters . get ( i ) , comp ) ; 
 - if ( ! candidate . advance ( ) ) 
 - / / was empty 
 - continue ; 
 - this . queue . add ( candidate ) ; 
 + heap [ size + + ] = candidate ; 
 } 
 - this . candidates = new ArrayDeque < > ( queue . size ( ) ) ; 
 + needingAdvance = size ; 
 } 
 
 protected final Out computeNext ( ) 
 @ @ - 100 , 30 + 159 , 191 @ @ public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implem 
 return consume ( ) ; 
 } 
 
 - / * * Consume values by sending them to the reducer while they are equal . * / 
 - protected final Out consume ( ) 
 + / * * 
 + * Advance all iterators that need to be advanced and place them into suitable positions in the heap . 
 + * 
 + * By walking the iterators backwards we know that everything after the point being processed already forms 
 + * correctly ordered subheaps , thus we can build a subheap rooted at the current position by only sinking down 
 + * the newly advanced iterator . Because all parents of a consumed iterator are also consumed there is no way 
 + * that we can process one consumed iterator but skip over its parent . 
 + * 
 + * The procedure is the same as the one used for the initial building of a heap in the heapsort algorithm and 
 + * has a maximum number of comparisons { @ code ( 2 * log ( size ) + SORTED _ SECTION _ SIZE / 2 ) } multiplied by the 
 + * number of iterators whose items were consumed at the previous step , but is also at most linear in the size of 
 + * the heap if the number of consumed elements is high ( as it is in the initial heap construction ) . With non - or 
 + * lightly - overlapping iterators the procedure finishes after just one ( resp . a couple of ) comparisons . 
 + * / 
 + private void advance ( ) 
 { 
 - reducer . onKeyChange ( ) ; 
 - Candidate < In > candidate = queue . peek ( ) ; 
 - if ( candidate = = null ) 
 - return endOfData ( ) ; 
 - do 
 + / / Turn the set of candidates into a heap . 
 + for ( int i = needingAdvance - 1 ; i > = 0 ; - - i ) 
 { 
 - candidate = queue . poll ( ) ; 
 - candidates . push ( candidate ) ; 
 - reducer . reduce ( candidate . idx , candidate . item ) ; 
 + Candidate < In > candidate = heap [ i ] ; 
 + / * * 
 + * needingAdvance runs to the maximum index ( and deepest - right node ) that may need advancing ; 
 + * since the equal items that were consumed at - once may occur in sub - heap " veins " of equality , 
 + * not all items above this deepest - right position may have been consumed ; these already form 
 + * valid sub - heaps and can be skipped - over entirely 
 + * / 
 + if ( candidate . needsAdvance ( ) ) 
 + replaceAndSink ( candidate . advance ( ) , i ) ; 
 } 
 - while ( queue . peek ( ) ! = null & & queue . peek ( ) . compareTo ( candidate ) = = 0 ) ; 
 + } 
 + 
 + / * * 
 + * Consume all items that sort like the current top of the heap . As we cannot advance the iterators to let 
 + * equivalent items pop up , we walk the heap to find them and mark them as needing advance . 
 + * 
 + * This relies on the equalParent flag to avoid doing any comparisons . 
 + * / 
 + private Out consume ( ) 
 + { 
 + if ( size = = 0 ) 
 + return endOfData ( ) ; 
 + 
 + reducer . onKeyChange ( ) ; 
 + assert ! heap [ 0 ] . equalParent ; 
 + reducer . reduce ( heap [ 0 ] . idx , heap [ 0 ] . consume ( ) ) ; 
 + final int size = this . size ; 
 + final int sortedSectionSize = Math . min ( size , SORTED _ SECTION _ SIZE ) ; 
 + int i ; 
 + consume : { 
 + for ( i = 1 ; i < sortedSectionSize ; + + i ) 
 + { 
 + if ( ! heap [ i ] . equalParent ) 
 + break consume ; 
 + reducer . reduce ( heap [ i ] . idx , heap [ i ] . consume ( ) ) ; 
 + } 
 + i = Math . max ( i , consumeHeap ( i ) + 1 ) ; 
 + } 
 + needingAdvance = i ; 
 return reducer . getReduced ( ) ; 
 } 
 
 - / * * Advance and re - enqueue all items we consumed in the last iteration . * / 
 - protected final void advance ( ) 
 + / * * 
 + * Recursively consume all items equal to equalItem in the binary subheap rooted at position idx . 
 + * 
 + * @ return the largest equal index found in this search . 
 + * / 
 + private int consumeHeap ( int idx ) 
 { 
 - Candidate < In > candidate ; 
 - while ( ( candidate = candidates . pollFirst ( ) ) ! = null ) 
 - if ( candidate . advance ( ) ) 
 - queue . add ( candidate ) ; 
 + if ( idx > = size | | ! heap [ idx ] . equalParent ) 
 + return - 1 ; 
 + 
 + reducer . reduce ( heap [ idx ] . idx , heap [ idx ] . consume ( ) ) ; 
 + int nextIdx = ( idx < < 1 ) - ( SORTED _ SECTION _ SIZE - 1 ) ; 
 + return Math . max ( idx , Math . max ( consumeHeap ( nextIdx ) , consumeHeap ( nextIdx + 1 ) ) ) ; 
 + } 
 + 
 + / * * 
 + * Replace an iterator in the heap with the given position and move it down the heap until it finds its proper 
 + * position , pulling lighter elements up the heap . 
 + * 
 + * Whenever an equality is found between two elements that form a new parent - child relationship , the child ' s 
 + * equalParent flag is set to true if the elements are equal . 
 + * / 
 + private void replaceAndSink ( Candidate < In > candidate , int currIdx ) 
 + { 
 + if ( candidate = = null ) 
 + { 
 + / / Drop iterator by replacing it with the last one in the heap . 
 + candidate = heap [ - - size ] ; 
 + heap [ size ] = null ; / / not necessary but helpful for debugging 
 + } 
 + / / The new element will be top of its heap , at this point there is no parent to be equal to . 
 + candidate . equalParent = false ; 
 + 
 + final int size = this . size ; 
 + final int sortedSectionSize = Math . min ( size - 1 , SORTED _ SECTION _ SIZE ) ; 
 + 
 + int nextIdx ; 
 + 
 + / / Advance within the sorted section , pulling up items lighter than candidate . 
 + while ( ( nextIdx = currIdx + 1 ) < = sortedSectionSize ) 
 + { 
 + if ( ! heap [ nextIdx ] . equalParent ) / / if we were greater then an ( or were the ) equal parent , we are > = the child 
 + { 
 + int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; 
 + if ( cmp < = 0 ) 
 + { 
 + heap [ nextIdx ] . equalParent = cmp = = 0 ; 
 + heap [ currIdx ] = candidate ; 
 + return ; 
 + } 
 + } 
 + 
 + heap [ currIdx ] = heap [ nextIdx ] ; 
 + currIdx = nextIdx ; 
 + } 
 + / / If size < = SORTED _ SECTION _ SIZE , nextIdx below will be no less than size , 
 + / / because currIdx = = sortedSectionSize = = size - 1 and nextIdx becomes 
 + / / ( size - 1 ) * 2 ) - ( size - 1 - 1 ) = = size . 
 + 
 + / / Advance in the binary heap , pulling up the lighter element from the two at each level . 
 + while ( ( nextIdx = ( currIdx * 2 ) - ( sortedSectionSize - 1 ) ) + 1 < size ) 
 + { 
 + if ( ! heap [ nextIdx ] . equalParent ) 
 + { 
 + if ( ! heap [ nextIdx + 1 ] . equalParent ) 
 + { 
 + / / pick the smallest of the two children 
 + int siblingCmp = heap [ nextIdx + 1 ] . compareTo ( heap [ nextIdx ] ) ; 
 + if ( siblingCmp < 0 ) 
 + + + nextIdx ; 
 + 
 + / / if we ' re smaller than this , we are done , and must only restore the heap and equalParent properties 
 + int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; 
 + if ( cmp < = 0 ) 
 + { 
 + if ( cmp = = 0 ) 
 + { 
 + heap [ nextIdx ] . equalParent = true ; 
 + if ( siblingCmp = = 0 ) / / siblingCmp = = 0 = > nextIdx is the left child 
 + heap [ nextIdx + 1 ] . equalParent = true ; 
 + } 
 + 
 + heap [ currIdx ] = candidate ; 
 + return ; 
 + } 
 + 
 + if ( siblingCmp = = 0 ) 
 + { 
 + / / siblingCmp = = 0 = > nextIdx is still the left child 
 + / / if the two siblings were equal , and we are inserting something greater , we will 
 + / / pull up the left one ; this means the right gets an equalParent 
 + heap [ nextIdx + 1 ] . equalParent = true ; 
 + } 
 + } 
 + else 
 + + + nextIdx ; / / descend down the path where we found the equal child 
 + } 
 + 
 + heap [ currIdx ] = heap [ nextIdx ] ; 
 + currIdx = nextIdx ; 
 + } 
 + 
 + / / our loop guard ensures there are always two siblings to process ; typically when we exit the loop we will 
 + / / be well past the end of the heap and this next condition will match . . . 
 + if ( nextIdx > = size ) 
 + { 
 + heap [ currIdx ] = candidate ; 
 + return ; 
 + } 
 + 
 + / / . . . but sometimes we will have one last child to compare against , that has no siblings 
 + if ( ! heap [ nextIdx ] . equalParent ) 
 + { 
 + int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; 
 + if ( cmp < = 0 ) 
 + { 
 + heap [ nextIdx ] . equalParent = cmp = = 0 ; 
 + heap [ currIdx ] = candidate ; 
 + return ; 
 + } 
 + } 
 + 
 + heap [ currIdx ] = heap [ nextIdx ] ; 
 + heap [ nextIdx ] = candidate ; 
 } 
 } 
 
 @ @ - 134 , 6 + 354 , 7 @ @ public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implem 
 private final Comparator < ? super In > comp ; 
 private final int idx ; 
 private In item ; 
 + boolean equalParent ; 
 
 public Candidate ( int idx , Iterator < ? extends In > iter , Comparator < ? super In > comp ) 
 { 
 @ @ - 142 , 19 + 363 , 33 @ @ public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implem 
 this . idx = idx ; 
 } 
 
 - / * * @ return True if our iterator had an item , and it is now available * / 
 - protected boolean advance ( ) 
 + / * * @ return this if our iterator had an item , and it is now available , otherwise null * / 
 + protected Candidate < In > advance ( ) 
 { 
 if ( ! iter . hasNext ( ) ) 
 - return false ; 
 + return null ; 
 item = iter . next ( ) ; 
 - return true ; 
 + return this ; 
 } 
 
 public int compareTo ( Candidate < In > that ) 
 { 
 + assert item ! = null & & that . item ! = null ; 
 return comp . compare ( this . item , that . item ) ; 
 } 
 + 
 + public In consume ( ) 
 + { 
 + In temp = item ; 
 + item = null ; 
 + assert temp ! = null ; 
 + return temp ; 
 + } 
 + 
 + public boolean needsAdvance ( ) 
 + { 
 + return item = = null ; 
 + } 
 } 
 
 / * * Accumulator that collects values of type A , and outputs a value of type B . * / 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / BTreeSet . java b / src / java / org / apache / cassandra / utils / btree / BTreeSet . java 
 index d1271fc . . 7646693 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / BTreeSet . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / BTreeSet . java 
 @ @ - 175 , 7 + 175 , 7 @ @ public class BTreeSet < V > implements NavigableSet < V > , List < V > 
 @ Override 
 public BTreeSet < V > descendingSet ( ) 
 { 
 - return new BTreeRange < > ( this . tree , this . comparator ) . descendingSet ( ) ; 
 + return new BTreeRange < V > ( this . tree , this . comparator ) . descendingSet ( ) ; 
 } 
 
 @ Override 
 diff - - git a / test / unit / org / apache / cassandra / utils / MergeIteratorComparisonTest . java b / test / unit / org / apache / cassandra / utils / MergeIteratorComparisonTest . java 
 new file mode 100644 
 index 0000000 . . 6a4bd2b 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / utils / MergeIteratorComparisonTest . java 
 @ @ - 0 , 0 + 1 , 733 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . util . * ; 
 + 
 + import com . google . common . base . Function ; 
 + import com . google . common . base . Objects ; 
 + import com . google . common . collect . AbstractIterator ; 
 + import com . google . common . collect . ImmutableSet ; 
 + import com . google . common . collect . Iterators ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Ordering ; 
 + import com . google . common . collect . Sets ; 
 + 
 + import org . junit . Assert ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . db . marshal . AbstractType ; 
 + import org . apache . cassandra . db . marshal . TimeUUIDType ; 
 + import org . apache . cassandra . db . marshal . UUIDType ; 
 + import org . apache . cassandra . utils . MergeIterator . Candidate ; 
 + import org . apache . cassandra . utils . MergeIterator . Reducer ; 
 + 
 + public class MergeIteratorComparisonTest 
 + { 
 + private static class CountingComparator < T > implements Comparator < T > 
 + { 
 + final Comparator < T > wrapped ; 
 + int count = 0 ; 
 + 
 + protected CountingComparator ( Comparator < T > wrapped ) 
 + { 
 + this . wrapped = wrapped ; 
 + } 
 + 
 + public int compare ( T o1 , T o2 ) 
 + { 
 + count + + ; 
 + return wrapped . compare ( o1 , o2 ) ; 
 + } 
 + } 
 + 
 + static int ITERATOR _ COUNT = 15 ; 
 + static int LIST _ LENGTH = 15000 ; 
 + static boolean BENCHMARK = false ; 
 + 
 + @ Test 
 + public void testRandomInts ( ) 
 + { 
 + System . out . println ( " testRandomInts " ) ; 
 + final Random r = new Random ( ) ; 
 + Reducer < Integer , Counted < Integer > > reducer = new Counter < Integer > ( ) ; 
 + 
 + List < List < Integer > > lists = new NaturalListGenerator < Integer > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + @ Override 
 + public Integer next ( ) 
 + { 
 + return r . nextInt ( 5 * LIST _ LENGTH ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testNonOverlapInts ( ) 
 + { 
 + System . out . println ( " testNonOverlapInts " ) ; 
 + Reducer < Integer , Counted < Integer > > reducer = new Counter < Integer > ( ) ; 
 + 
 + List < List < Integer > > lists = new NaturalListGenerator < Integer > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + int next = 1 ; 
 + @ Override 
 + public Integer next ( ) 
 + { 
 + return next + + ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testCombinationInts ( ) 
 + { 
 + System . out . println ( " testCombinationInts " ) ; 
 + final Random r = new Random ( ) ; 
 + Reducer < Integer , Counted < Integer > > reducer = new Counter < Integer > ( ) ; 
 + 
 + List < List < Integer > > lists = new NaturalListGenerator < Integer > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + int next = 1 ; 
 + @ Override 
 + public Integer next ( ) 
 + { 
 + return r . nextBoolean ( ) ? r . nextInt ( 5 * LIST _ LENGTH ) : next + + ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testLCSTotalOverlap ( ) 
 + { 
 + testLCS ( 2 , LIST _ LENGTH / 100 , 1f ) ; 
 + testLCS ( 3 , LIST _ LENGTH / 100 , 1f ) ; 
 + testLCS ( 3 , LIST _ LENGTH / 100 , 1f , 10 , LIST _ LENGTH ) ; 
 + testLCS ( 4 , LIST _ LENGTH / 100 , 1f ) ; 
 + testLCS ( 4 , LIST _ LENGTH / 100 , 1f , 10 , LIST _ LENGTH ) ; 
 + } 
 + 
 + @ Test 
 + public void testLCSPartialOverlap ( ) 
 + { 
 + testLCS ( 2 , LIST _ LENGTH / 100 , 0 . 5f ) ; 
 + testLCS ( 3 , LIST _ LENGTH / 100 , 0 . 5f ) ; 
 + testLCS ( 3 , LIST _ LENGTH / 100 , 0 . 5f , 10 , LIST _ LENGTH ) ; 
 + testLCS ( 4 , LIST _ LENGTH / 100 , 0 . 5f ) ; 
 + testLCS ( 4 , LIST _ LENGTH / 100 , 0 . 5f , 10 , LIST _ LENGTH ) ; 
 + } 
 + 
 + @ Test 
 + public void testLCSNoOverlap ( ) 
 + { 
 + testLCS ( 2 , LIST _ LENGTH / 100 , 0f ) ; 
 + testLCS ( 3 , LIST _ LENGTH / 100 , 0f ) ; 
 + testLCS ( 3 , LIST _ LENGTH / 100 , 0f , 10 , LIST _ LENGTH ) ; 
 + testLCS ( 4 , LIST _ LENGTH / 100 , 0f ) ; 
 + testLCS ( 4 , LIST _ LENGTH / 100 , 0f , 10 , LIST _ LENGTH ) ; 
 + } 
 + 
 + public void testLCS ( int levelCount , int levelMultiplier , float levelOverlap ) 
 + { 
 + testLCS ( levelCount , levelMultiplier , levelOverlap , 0 , 0 ) ; 
 + } 
 + public void testLCS ( int levelCount , int levelMultiplier , float levelOverlap , int countOfL0 , int sizeOfL0 ) 
 + { 
 + System . out . printf ( " testLCS ( lc = % d , lm = % d , o = % . 2f , L0 = % d * % d ) \ n " , levelCount , levelMultiplier , levelOverlap , countOfL0 , countOfL0 = = 0 ? 0 : sizeOfL0 / countOfL0 ) ; 
 + final Random r = new Random ( ) ; 
 + Reducer < Integer , Counted < Integer > > reducer = new Counter < Integer > ( ) ; 
 + List < List < Integer > > lists = new LCSGenerator < Integer > ( Ordering . < Integer > natural ( ) , levelCount , levelMultiplier , levelOverlap ) { 
 + @ Override 
 + public Integer newItem ( ) 
 + { 
 + return r . nextInt ( ) ; 
 + } 
 + } . result ; 
 + if ( sizeOfL0 > 0 & & countOfL0 > 0 ) 
 + lists . addAll ( new NaturalListGenerator < Integer > ( countOfL0 , sizeOfL0 / countOfL0 ) 
 + { 
 + Integer next ( ) 
 + { 
 + return r . nextInt ( ) ; 
 + } 
 + } . result ) ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testRandomStrings ( ) 
 + { 
 + System . out . println ( " testRandomStrings " ) ; 
 + final Random r = new Random ( ) ; 
 + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; 
 + 
 + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + @ Override 
 + public String next ( ) 
 + { 
 + return " longish _ prefix _ " + r . nextInt ( 5 * LIST _ LENGTH ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testNonOverlapStrings ( ) 
 + { 
 + System . out . println ( " testNonOverlapStrings " ) ; 
 + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; 
 + 
 + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + int next = 1 ; 
 + @ Override 
 + public String next ( ) 
 + { 
 + return " longish _ prefix _ " + next + + ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testCombinationStrings ( ) 
 + { 
 + System . out . println ( " testCombinationStrings " ) ; 
 + final Random r = new Random ( ) ; 
 + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; 
 + 
 + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + int next = 1 ; 
 + public String next ( ) 
 + { 
 + return " longish _ prefix _ " + ( r . nextBoolean ( ) ? r . nextInt ( 5 * LIST _ LENGTH ) : next + + ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testTimeUuids ( ) 
 + { 
 + System . out . println ( " testTimeUuids " ) ; 
 + Reducer < UUID , Counted < UUID > > reducer = new Counter < UUID > ( ) ; 
 + 
 + List < List < UUID > > lists = new NaturalListGenerator < UUID > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + @ Override 
 + public UUID next ( ) 
 + { 
 + return UUIDGen . getTimeUUID ( ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testRandomUuids ( ) 
 + { 
 + System . out . println ( " testRandomUuids " ) ; 
 + Reducer < UUID , Counted < UUID > > reducer = new Counter < UUID > ( ) ; 
 + 
 + List < List < UUID > > lists = new NaturalListGenerator < UUID > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + @ Override 
 + public UUID next ( ) 
 + { 
 + return UUID . randomUUID ( ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testTimeUuidType ( ) 
 + { 
 + System . out . println ( " testTimeUuidType " ) ; 
 + final AbstractType < UUID > type = TimeUUIDType . instance ; 
 + Reducer < ByteBuffer , Counted < ByteBuffer > > reducer = new Counter < ByteBuffer > ( ) ; 
 + 
 + List < List < ByteBuffer > > lists = new SimpleListGenerator < ByteBuffer > ( type , ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + @ Override 
 + public ByteBuffer next ( ) 
 + { 
 + return type . decompose ( UUIDGen . getTimeUUID ( ) ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists , type ) ; 
 + } 
 + 
 + @ Test 
 + public void testUuidType ( ) 
 + { 
 + System . out . println ( " testUuidType " ) ; 
 + final AbstractType < UUID > type = UUIDType . instance ; 
 + Reducer < ByteBuffer , Counted < ByteBuffer > > reducer = new Counter < ByteBuffer > ( ) ; 
 + 
 + List < List < ByteBuffer > > lists = new SimpleListGenerator < ByteBuffer > ( type , ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + @ Override 
 + public ByteBuffer next ( ) 
 + { 
 + return type . decompose ( UUIDGen . getTimeUUID ( ) ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists , type ) ; 
 + } 
 + 
 + 
 + @ Test 
 + public void testSets ( ) 
 + { 
 + System . out . println ( " testSets " ) ; 
 + final Random r = new Random ( ) ; 
 + 
 + Reducer < KeyedSet < Integer , UUID > , KeyedSet < Integer , UUID > > reducer = new Union < Integer , UUID > ( ) ; 
 + 
 + List < List < KeyedSet < Integer , UUID > > > lists = new NaturalListGenerator < KeyedSet < Integer , UUID > > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + @ Override 
 + public KeyedSet < Integer , UUID > next ( ) 
 + { 
 + return new KeyedSet < > ( r . nextInt ( 5 * LIST _ LENGTH ) , UUIDGen . getTimeUUID ( ) ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + / * * / 
 + 
 + @ Test 
 + public void testLimitedOverlapStrings2 ( ) 
 + { 
 + System . out . println ( " testLimitedOverlapStrings2 " ) ; 
 + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; 
 + 
 + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + int next = 0 ; 
 + @ Override 
 + public String next ( ) 
 + { 
 + + + next ; 
 + int list = next / LIST _ LENGTH ; 
 + int id = next % LIST _ LENGTH ; 
 + return " longish _ prefix _ " + ( id + list * LIST _ LENGTH / 2 ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + @ Test 
 + public void testLimitedOverlapStrings3 ( ) 
 + { 
 + System . out . println ( " testLimitedOverlapStrings3 " ) ; 
 + Reducer < String , Counted < String > > reducer = new Counter < String > ( ) ; 
 + 
 + List < List < String > > lists = new NaturalListGenerator < String > ( ITERATOR _ COUNT , LIST _ LENGTH ) { 
 + int next = 0 ; 
 + @ Override 
 + public String next ( ) 
 + { 
 + + + next ; 
 + int list = next / LIST _ LENGTH ; 
 + int id = next % LIST _ LENGTH ; 
 + return " longish _ prefix _ " + ( id + list * LIST _ LENGTH / 3 ) ; 
 + } 
 + } . result ; 
 + testMergeIterator ( reducer , lists ) ; 
 + } 
 + 
 + private static abstract class ListGenerator < T > 
 + { 
 + abstract boolean hasMoreItems ( ) ; 
 + abstract boolean hasMoreLists ( ) ; 
 + abstract T next ( ) ; 
 + 
 + final Comparator < T > comparator ; 
 + final List < List < T > > result = Lists . newArrayList ( ) ; 
 + 
 + protected ListGenerator ( Comparator < T > comparator ) 
 + { 
 + this . comparator = comparator ; 
 + } 
 + 
 + void build ( ) 
 + { 
 + while ( hasMoreLists ( ) ) 
 + { 
 + List < T > l = Lists . newArrayList ( ) ; 
 + while ( hasMoreItems ( ) ) 
 + l . add ( next ( ) ) ; 
 + Collections . sort ( l , comparator ) ; 
 + result . add ( l ) ; 
 + } 
 + } 
 + } 
 + 
 + private static abstract class NaturalListGenerator < T extends Comparable < T > > extends SimpleListGenerator < T > 
 + { 
 + private NaturalListGenerator ( int listCount , int perListCount ) 
 + { 
 + super ( Ordering . natural ( ) , listCount , perListCount ) ; 
 + } 
 + } 
 + private static abstract class SimpleListGenerator < T > extends ListGenerator < T > 
 + { 
 + final int listCount ; 
 + final int perListCount ; 
 + 
 + int listIdx = 0 , itemIdx = 0 ; 
 + 
 + private SimpleListGenerator ( Comparator < T > comparator , int listCount , int perListCount ) 
 + { 
 + super ( comparator ) ; 
 + this . listCount = listCount ; 
 + this . perListCount = perListCount ; 
 + build ( ) ; 
 + } 
 + 
 + public boolean hasMoreItems ( ) 
 + { 
 + return itemIdx + + < perListCount ; 
 + } 
 + 
 + public boolean hasMoreLists ( ) 
 + { 
 + itemIdx = 0 ; 
 + return listIdx + + < listCount ; 
 + } 
 + } 
 + 
 + private static abstract class LCSGenerator < T > extends ListGenerator < T > 
 + { 
 + final int levelCount ; 
 + final int itemMultiplier ; 
 + final float levelOverlap ; 
 + 
 + int levelIdx , itemIdx ; 
 + int levelItems , overlapItems , runningTotalItems ; 
 + final Random random = new Random ( ) ; 
 + 
 + public LCSGenerator ( Comparator < T > comparator , int levelCount , int l1Items , float levelOverlap ) 
 + { 
 + super ( comparator ) ; 
 + this . levelCount = levelCount ; 
 + this . itemMultiplier = l1Items ; 
 + this . levelOverlap = levelOverlap ; 
 + build ( ) ; 
 + } 
 + 
 + public boolean hasMoreItems ( ) 
 + { 
 + return itemIdx + + < levelItems ; 
 + } 
 + 
 + public boolean hasMoreLists ( ) 
 + { 
 + if ( result . size ( ) > 0 ) 
 + runningTotalItems + = result . get ( result . size ( ) - 1 ) . size ( ) ; 
 + itemIdx = 0 ; 
 + levelItems = itemMultiplier * ( int ) Math . pow ( 10 , levelCount - levelIdx ) ; 
 + overlapItems = levelIdx = = 0 ? 0 : ( int ) ( levelItems * levelOverlap ) ; 
 + return levelIdx + + < levelCount ; 
 + } 
 + 
 + abstract T newItem ( ) ; 
 + 
 + T next ( ) 
 + { 
 + if ( itemIdx < overlapItems ) 
 + { 
 + int item = random . nextInt ( runningTotalItems ) ; 
 + for ( List < T > list : result ) 
 + { 
 + if ( item < list . size ( ) ) return list . get ( item ) ; 
 + else item - = list . size ( ) ; 
 + } 
 + } 
 + return newItem ( ) ; 
 + } 
 + } 
 + 
 + public < T extends Comparable < T > > void testMergeIterator ( Reducer < T , ? > reducer , List < List < T > > lists ) 
 + { 
 + testMergeIterator ( reducer , lists , Ordering . natural ( ) ) ; 
 + } 
 + public < T > void testMergeIterator ( Reducer < T , ? > reducer , List < List < T > > lists , Comparator < T > comparator ) 
 + { 
 + { 
 + IMergeIterator < T , ? > tested = MergeIterator . get ( closeableIterators ( lists ) , comparator , reducer ) ; 
 + IMergeIterator < T , ? > base = new MergeIteratorPQ < > ( closeableIterators ( lists ) , comparator , reducer ) ; 
 + / / If test fails , try the version below for improved reporting : 
 + Object [ ] basearr = Iterators . toArray ( base , Object . class ) ; 
 + Assert . assertArrayEquals ( basearr , Iterators . toArray ( tested , Object . class ) ) ; 
 + / / Assert . assertTrue ( Iterators . elementsEqual ( base , tested ) ) ; 
 + if ( ! BENCHMARK ) 
 + return ; 
 + } 
 + 
 + CountingComparator < T > cmp , cmpb ; 
 + cmp = new CountingComparator < > ( comparator ) ; cmpb = new CountingComparator < > ( comparator ) ; 
 + System . out . println ( ) ; 
 + for ( int i = 0 ; i < 10 ; + + i ) { 
 + benchmarkIterator ( MergeIterator . get ( closeableIterators ( lists ) , cmp , reducer ) , cmp ) ; 
 + benchmarkIterator ( new MergeIteratorPQ < > ( closeableIterators ( lists ) , cmpb , reducer ) , cmpb ) ; 
 + } 
 + System . out . format ( " MI : % . 2f \ n " , cmp . count / ( double ) cmpb . count ) ; 
 + } 
 + 
 + public < T > void benchmarkIterator ( IMergeIterator < T , ? > it , CountingComparator < T > comparator ) 
 + { 
 + System . out . format ( " Testing % 30s . . . " , it . getClass ( ) . getSimpleName ( ) ) ; 
 + long time = System . currentTimeMillis ( ) ; 
 + Object value = null ; 
 + while ( it . hasNext ( ) ) 
 + value = it . next ( ) ; 
 + time = System . currentTimeMillis ( ) - time ; 
 + String type = " " ; 
 + if ( value instanceof Counted < ? > ) 
 + { 
 + type = " type " + ( ( Counted < ? > ) value ) . item . getClass ( ) . getSimpleName ( ) ; 
 + } 
 + System . out . format ( " % 15s time % 5dms ; comparisons : % d \ n " , type , time , comparator . count ) ; 
 + } 
 + 
 + public < T > List < CloseableIterator < T > > closeableIterators ( List < List < T > > iterators ) 
 + { 
 + return Lists . transform ( iterators , new Function < List < T > , CloseableIterator < T > > ( ) { 
 + 
 + @ Override 
 + public CloseableIterator < T > apply ( List < T > arg ) 
 + { 
 + return new CLI < T > ( arg . iterator ( ) ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + static class Counted < T > { 
 + T item ; 
 + int count ; 
 + 
 + Counted ( T item ) { 
 + this . item = item ; 
 + count = 0 ; 
 + } 
 + 
 + public boolean equals ( Object obj ) 
 + { 
 + if ( obj = = null | | ! ( obj instanceof Counted ) ) 
 + return false ; 
 + Counted < ? > c = ( Counted < ? > ) obj ; 
 + return Objects . equal ( item , c . item ) & & count = = c . count ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) 
 + { 
 + return item . toString ( ) + " x " + count ; 
 + } 
 + } 
 + 
 + static class Counter < T > extends Reducer < T , Counted < T > > { 
 + Counted < T > current = null ; 
 + boolean read = true ; 
 + 
 + @ Override 
 + public void reduce ( int idx , T next ) 
 + { 
 + if ( current = = null ) 
 + current = new Counted < T > ( next ) ; 
 + assert current . item . equals ( next ) ; 
 + + + current . count ; 
 + } 
 + 
 + @ Override 
 + protected void onKeyChange ( ) 
 + { 
 + assert read ; 
 + current = null ; 
 + read = false ; 
 + } 
 + 
 + @ Override 
 + protected Counted < T > getReduced ( ) 
 + { 
 + assert current ! = null ; 
 + read = true ; 
 + return current ; 
 + } 
 + } 
 + 
 + static class KeyedSet < K extends Comparable < ? super K > , V > extends Pair < K , Set < V > > implements Comparable < KeyedSet < K , V > > 
 + { 
 + protected KeyedSet ( K left , V right ) 
 + { 
 + super ( left , ImmutableSet . of ( right ) ) ; 
 + } 
 + 
 + protected KeyedSet ( K left , Collection < V > right ) 
 + { 
 + super ( left , Sets . newHashSet ( right ) ) ; 
 + } 
 + 
 + @ Override 
 + public int compareTo ( KeyedSet < K , V > o ) 
 + { 
 + return left . compareTo ( o . left ) ; 
 + } 
 + } 
 + 
 + static class Union < K extends Comparable < K > , V > extends Reducer < KeyedSet < K , V > , KeyedSet < K , V > > { 
 + KeyedSet < K , V > current = null ; 
 + boolean read = true ; 
 + 
 + @ Override 
 + public void reduce ( int idx , KeyedSet < K , V > next ) 
 + { 
 + if ( current = = null ) 
 + current = new KeyedSet < > ( next . left , next . right ) ; 
 + else { 
 + assert current . left . equals ( next . left ) ; 
 + current . right . addAll ( next . right ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + protected void onKeyChange ( ) 
 + { 
 + assert read ; 
 + current = null ; 
 + read = false ; 
 + } 
 + 
 + @ Override 
 + protected KeyedSet < K , V > getReduced ( ) 
 + { 
 + assert current ! = null ; 
 + read = true ; 
 + return current ; 
 + } 
 + } 
 + 
 + / / closeable list iterator 
 + public static class CLI < E > extends AbstractIterator < E > implements CloseableIterator < E > 
 + { 
 + Iterator < E > iter ; 
 + boolean closed = false ; 
 + public CLI ( Iterator < E > items ) 
 + { 
 + this . iter = items ; 
 + } 
 + 
 + protected E computeNext ( ) 
 + { 
 + if ( ! iter . hasNext ( ) ) return endOfData ( ) ; 
 + return iter . next ( ) ; 
 + } 
 + 
 + public void close ( ) 
 + { 
 + assert ! this . closed ; 
 + this . closed = true ; 
 + } 
 + } 
 + 
 + / / Old MergeIterator implementation for comparison . 
 + public class MergeIteratorPQ < In , Out > extends MergeIterator < In , Out > implements IMergeIterator < In , Out > 
 + { 
 + / / a queue for return : all candidates must be open and have at least one item 
 + protected final PriorityQueue < CandidatePQ < In > > queue ; 
 + / / a stack of the last consumed candidates , so that we can lazily call ' advance ( ) ' 
 + / / TODO : if we had our own PriorityQueue implementation we could stash items 
 + / / at the end of its array , so we wouldn ' t need this storage 
 + protected final ArrayDeque < CandidatePQ < In > > candidates ; 
 + public MergeIteratorPQ ( List < ? extends Iterator < In > > iters , Comparator < In > comp , Reducer < In , Out > reducer ) 
 + { 
 + super ( iters , reducer ) ; 
 + this . queue = new PriorityQueue < > ( Math . max ( 1 , iters . size ( ) ) ) ; 
 + for ( int i = 0 ; i < iters . size ( ) ; i + + ) 
 + { 
 + CandidatePQ < In > candidate = new CandidatePQ < > ( i , iters . get ( i ) , comp ) ; 
 + if ( ! candidate . advance ( ) ) 
 + / / was empty 
 + continue ; 
 + this . queue . add ( candidate ) ; 
 + } 
 + this . candidates = new ArrayDeque < > ( queue . size ( ) ) ; 
 + } 
 + 
 + protected final Out computeNext ( ) 
 + { 
 + advance ( ) ; 
 + return consume ( ) ; 
 + } 
 + 
 + / * * Consume values by sending them to the reducer while they are equal . * / 
 + protected final Out consume ( ) 
 + { 
 + CandidatePQ < In > candidate = queue . peek ( ) ; 
 + if ( candidate = = null ) 
 + return endOfData ( ) ; 
 + reducer . onKeyChange ( ) ; 
 + do 
 + { 
 + candidate = queue . poll ( ) ; 
 + candidates . push ( candidate ) ; 
 + reducer . reduce ( candidate . idx , candidate . item ) ; 
 + } 
 + while ( queue . peek ( ) ! = null & & queue . peek ( ) . compareTo ( candidate ) = = 0 ) ; 
 + return reducer . getReduced ( ) ; 
 + } 
 + 
 + / * * Advance and re - enqueue all items we consumed in the last iteration . * / 
 + protected final void advance ( ) 
 + { 
 + CandidatePQ < In > candidate ; 
 + while ( ( candidate = candidates . pollFirst ( ) ) ! = null ) 
 + if ( candidate . advance ( ) ) 
 + queue . add ( candidate ) ; 
 + } 
 + } 
 + 
 + / / Holds and is comparable by the head item of an iterator it owns 
 + protected static final class CandidatePQ < In > implements Comparable < CandidatePQ < In > > 
 + { 
 + private final Iterator < ? extends In > iter ; 
 + private final Comparator < ? super In > comp ; 
 + private final int idx ; 
 + private In item ; 
 + boolean equalParent ; 
 + 
 + public CandidatePQ ( int idx , Iterator < ? extends In > iter , Comparator < ? super In > comp ) 
 + { 
 + this . iter = iter ; 
 + this . comp = comp ; 
 + this . idx = idx ; 
 + } 
 + 
 + / * * @ return true if our iterator had an item , and it is now available * / 
 + protected boolean advance ( ) 
 + { 
 + if ( ! iter . hasNext ( ) ) 
 + return false ; 
 + item = iter . next ( ) ; 
 + return true ; 
 + } 
 + 
 + public int compareTo ( CandidatePQ < In > that ) 
 + { 
 + return comp . compare ( this . item , that . item ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e48fbfd . . f598aa2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 11 , 6 + 11 , 7 @ @ 
 * fix error when using ORDER BY with extended selections ( CASSANDRA - 4689 ) 
 * ( CQL3 ) Fix validation for IN queries for non - PK cols ( CASSANDRA - 4709 ) 
 * fix re - created keyspace disappering after 1 . 1 . 5 upgrade ( CASSANDRA - 4698 ) 
 + * ( CLI ) display elapsed time in 2 fraction digits ( CASSANDRA - 3460 ) 
 Merged from 1 . 0 : 
 * Switch from NBHM to CHM in MessagingService ' s callback map , which 
 prevents OOM in long - running instances ( CASSANDRA - 4708 ) 
 diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java 
 index d0fb543 . . b32b0f7 100644 
 - - - a / src / java / org / apache / cassandra / cli / CliClient . java 
 + + + b / src / java / org / apache / cassandra / cli / CliClient . java 
 @ @ - 461 , 7 + 461 , 7 @ @ public class CliClient 
 throws InvalidRequestException , UnavailableException , TimedOutException , TException , IllegalAccessException , NotFoundException , InstantiationException , NoSuchFieldException 
 { 
 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 ColumnParent parent = new ColumnParent ( columnFamily ) ; 
 if ( superColumnName ! = null ) 
 parent . setSuper _ column ( superColumnName ) ; 
 @ @ - 565 , 7 + 565 , 7 @ @ public class CliClient 
 { 
 if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 return ; 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 Tree columnFamilySpec = statement . getChild ( 0 ) ; 
 String columnFamily = CliCompiler . getColumnFamily ( columnFamilySpec , keyspacesMap . get ( keySpace ) . cf _ defs ) ; 
 ByteBuffer key = getKeyAsBytes ( columnFamily , columnFamilySpec . getChild ( 1 ) ) ; 
 @ @ - 734 , 7 + 734 , 7 @ @ public class CliClient 
 if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 return ; 
 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 
 IndexClause clause = new IndexClause ( ) ; 
 String columnFamily = CliCompiler . getColumnFamily ( statement , keyspacesMap . get ( keySpace ) . cf _ defs ) ; 
 @ @ - 828 , 7 + 828 , 7 @ @ public class CliClient 
 if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 return ; 
 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 / / ^ ( NODE _ COLUMN _ ACCESS < cf > < key > < column > ) 
 Tree columnFamilySpec = statement . getChild ( 0 ) ; 
 Tree keyTree = columnFamilySpec . getChild ( 1 ) ; / / could be a function or regular text 
 @ @ - 1323 , 7 + 1323 , 7 @ @ public class CliClient 
 if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 return ; 
 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 
 / / extract column family 
 String columnFamily = CliCompiler . getColumnFamily ( statement , keyspacesMap . get ( keySpace ) . cf _ defs ) ; 
 @ @ - 2968 , 9 + 2968 , 25 @ @ public class CliClient 
 return false ; 
 } 
 
 + / * * 
 + * Print elapsed time . Print 2 fraction digits if eta is under 10 ms . 
 + * @ param startTime starting time in nanoseconds 
 + * / 
 private void elapsedTime ( long startTime ) 
 { 
 - sessionState . out . println ( " Elapsed time : " + ( System . currentTimeMillis ( ) - startTime ) + " msec ( s ) . " ) ; 
 + / * * time elapsed in nanoseconds * / 
 + long eta = System . nanoTime ( ) - startTime ; 
 + 
 + sessionState . out . print ( " Elapsed time : " ) ; 
 + if ( eta < 10000000 ) 
 + { 
 + sessionState . out . print ( Math . round ( eta / 10000 . 0 ) / 100 . 0 ) ; 
 + } 
 + else 
 + { 
 + sessionState . out . print ( Math . round ( eta / 1000000 . 0 ) ) ; 
 + } 
 + sessionState . out . println ( " msec ( s ) . " ) ; 
 } 
 
 class CfAssumptions
