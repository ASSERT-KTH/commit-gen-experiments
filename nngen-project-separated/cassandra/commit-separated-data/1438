BLEU SCORE: 0.037954847898457066

TEST MSG: Fix incorrect return code on SSTableVerify . bat
GENERATED MSG: fix starting up on Windows when CASSANDRA _ HOME contains whitespace

TEST DIFF (one line): diff - - git a / bin / cassandra . in . bat b / bin / cassandra . in . bat <nl> index 1b4e38e . . 83b7472 100644 <nl> - - - a / bin / cassandra . in . bat <nl> + + + b / bin / cassandra . in . bat <nl> @ @ - 31 , 7 + 31 , 7 @ @ REM set JAVA _ HOME = " < directory > " <nl> REM * * * * * CLASSPATH library setting * * * * * <nl> <nl> REM Ensure that any user defined CLASSPATH variables are not used on startup <nl> - set CLASSPATH = " % CASSANDRA _ HOME % \ conf " <nl> + set CLASSPATH = " % CASSANDRA _ CONF % " <nl> <nl> REM For each jar in the CASSANDRA _ HOME lib directory call append to build the CLASSPATH variable . <nl> for % % i in ( " % CASSANDRA _ HOME % \ lib \ * . jar " ) do call : append " % % i " <nl> diff - - git a / bin / sstableverify . bat b / bin / sstableverify . bat <nl> index aa08826 . . eb2629f 100644 <nl> - - - a / bin / sstableverify . bat <nl> + + + b / bin / sstableverify . bat <nl> @ @ - 34 , 8 + 34 , 15 @ @ goto finally <nl> <nl> : err <nl> echo JAVA _ HOME environment variable must be set ! <nl> + set ERRORLEVEL = 1 <nl> pause <nl> <nl> : finally <nl> + ENDLOCAL & set RC = % ERRORLEVEL % <nl> + goto : exit _ with _ code <nl> <nl> - ENDLOCAL <nl> + : returncode <nl> + exit / B % RC % <nl> + <nl> + : exit _ with _ code <nl> + call : returncode % RC %
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index e581967 . . 561f7ea 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 410 , 7 + 410 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> long count = 0 ; <nl> for ( SSTableReader sstable : ssTables ) <nl> { <nl> - sum + = sstable . getEstimatedRowSize ( ) . median ( ) ; <nl> + sum + = sstable . getEstimatedRowSize ( ) . mean ( ) ; <nl> count + + ; <nl> } <nl> return count > 0 ? sum / count : 0 ; <nl> @ @ - 422 , 7 + 422 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> int count = 0 ; <nl> for ( SSTableReader sstable : ssTables ) <nl> { <nl> - sum + = sstable . getEstimatedColumnCount ( ) . median ( ) ; <nl> + sum + = sstable . getEstimatedColumnCount ( ) . mean ( ) ; <nl> count + + ; <nl> } <nl> return count > 0 ? ( int ) ( sum / count ) : 0 ; <nl> @ @ - 1023 , 12 + 1023 , 12 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> public long [ ] getRecentSSTablesPerReadHistogram ( ) <nl> { <nl> - return recentSSTablesPerRead . get ( true ) ; <nl> + return recentSSTablesPerRead . getBuckets ( true ) ; <nl> } <nl> <nl> public long [ ] getSSTablesPerReadHistogram ( ) <nl> { <nl> - return sstablesPerRead . get ( false ) ; <nl> + return sstablesPerRead . getBuckets ( false ) ; <nl> } <nl> <nl> public long getReadCount ( ) <nl> @ @ - 1984 , 7 + 1984 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> for ( SSTableReader sstable : ssTables ) <nl> { <nl> - long [ ] rowSize = sstable . getEstimatedRowSize ( ) . get ( false ) ; <nl> + long [ ] rowSize = sstable . getEstimatedRowSize ( ) . getBuckets ( false ) ; <nl> <nl> for ( int i = 0 ; i < histogram . length ; i + + ) <nl> histogram [ i ] + = rowSize [ i ] ; <nl> @ @ - 1999 , 7 + 1999 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> for ( SSTableReader sstable : ssTables ) <nl> { <nl> - long [ ] columnSize = sstable . getEstimatedColumnCount ( ) . get ( false ) ; <nl> + long [ ] columnSize = sstable . getEstimatedColumnCount ( ) . getBuckets ( false ) ; <nl> <nl> for ( int i = 0 ; i < histogram . length ; i + + ) <nl> histogram [ i ] + = columnSize [ i ] ; <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index 1f142e6 . . c1ddbd6 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 441 , 7 + 441 , 7 @ @ public class NodeCmd { <nl> ColumnFamilyStoreMBean store = this . probe . getCfsProxy ( keySpace , columnFamily ) ; <nl> <nl> / / default is 90 offsets <nl> - long [ ] offsets = new EstimatedHistogram ( 90 ) . getBucketOffsets ( ) ; <nl> + long [ ] offsets = new EstimatedHistogram ( ) . getBucketOffsets ( ) ; <nl> <nl> long [ ] rrlh = store . getRecentReadLatencyHistogramMicros ( ) ; <nl> long [ ] rwlh = store . getRecentWriteLatencyHistogramMicros ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / utils / EstimatedHistogram . java b / src / java / org / apache / cassandra / utils / EstimatedHistogram . java <nl> index 7056d4b . . 2374dd4 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / EstimatedHistogram . java <nl> + + + b / src / java / org / apache / cassandra / utils / EstimatedHistogram . java <nl> @ @ - 28 , 23 + 28 , 24 @ @ import org . apache . cassandra . io . ICompactSerializer ; <nl> <nl> public class EstimatedHistogram <nl> { <nl> + public static EstimatedHistogramSerializer serializer = new EstimatedHistogramSerializer ( ) ; <nl> <nl> / * * <nl> * The series of values to which the counts in ` buckets ` correspond : <nl> - * 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 10 , 12 , 15 , 18 , 22 , etc . <nl> + * 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 10 , 12 , 14 , 17 , 20 , etc . <nl> * Thus , a ` buckets ` of [ 0 , 0 , 1 , 10 ] would mean we had seen one value of 3 and 10 values of 4 . <nl> * <nl> * The series starts at 1 and grows by 1 . 2 each time ( rounding and removing duplicates ) . It goes from 1 <nl> * to around 36M by default ( creating 90 + 1 buckets ) , which will give us timing resolution from microseconds to <nl> * 36 seconds , with less precision as the numbers get larger . <nl> + * <nl> + * Each bucket represents values from ( previous bucket offset , current offset ] . <nl> * / <nl> private long [ ] bucketOffsets ; <nl> - private int numBuckets ; <nl> <nl> + / / buckets is one element longer than bucketOffsets - - the last element is values greater than the last offset <nl> final AtomicLongArray buckets ; <nl> <nl> - public static EstimatedHistogramSerializer serializer = new EstimatedHistogramSerializer ( ) ; <nl> - <nl> public EstimatedHistogram ( ) <nl> { <nl> this ( 90 ) ; <nl> @ @ - 53 , 7 + 54 , 7 @ @ public class EstimatedHistogram <nl> public EstimatedHistogram ( int bucketCount ) <nl> { <nl> makeOffsets ( bucketCount ) ; <nl> - buckets = new AtomicLongArray ( numBuckets ) ; <nl> + buckets = new AtomicLongArray ( bucketOffsets . length + 1 ) ; <nl> } <nl> <nl> public EstimatedHistogram ( long [ ] offsets , long [ ] bucketData ) <nl> @ @ - 61 , 7 + 62 , 6 @ @ public class EstimatedHistogram <nl> assert bucketData . length = = offsets . length + 1 ; <nl> bucketOffsets = offsets ; <nl> buckets = new AtomicLongArray ( bucketData ) ; <nl> - numBuckets = bucketData . length ; <nl> } <nl> <nl> private void makeOffsets ( int size ) <nl> @ @ - 69 , 7 + 69 , 7 @ @ public class EstimatedHistogram <nl> bucketOffsets = new long [ size ] ; <nl> long last = 1 ; <nl> bucketOffsets [ 0 ] = last ; <nl> - for ( int i = 1 ; i < size ; i + + ) <nl> + for ( int i = 1 ; i < size ; i + + ) <nl> { <nl> long next = Math . round ( last * 1 . 2 ) ; <nl> if ( next = = last ) <nl> @ @ - 77 , 58 + 77 , 79 @ @ public class EstimatedHistogram <nl> bucketOffsets [ i ] = next ; <nl> last = next ; <nl> } <nl> - numBuckets = bucketOffsets . length + 1 ; <nl> } <nl> <nl> + / * * <nl> + * @ return the histogram values corresponding to each bucket index <nl> + * / <nl> public long [ ] getBucketOffsets ( ) <nl> { <nl> return bucketOffsets ; <nl> } <nl> - <nl> + <nl> + / * * <nl> + * Increments the count of the bucket closest to n , rounding UP . <nl> + * @ param n <nl> + * / <nl> public void add ( long n ) <nl> { <nl> int index = Arrays . binarySearch ( bucketOffsets , n ) ; <nl> if ( index < 0 ) <nl> { <nl> - / / inexact match , find closest bucket <nl> + / / inexact match , take the first bucket higher than n <nl> index = - index - 1 ; <nl> } <nl> - else <nl> - { <nl> - / / exact match , so we want the next highest one <nl> - index + = 1 ; <nl> - } <nl> + / / else exact match ; we ' re good <nl> buckets . incrementAndGet ( index ) ; <nl> } <nl> <nl> - public long [ ] get ( boolean reset ) <nl> + / * * <nl> + * @ return the count in the given bucket <nl> + * / <nl> + long get ( int bucket ) <nl> + { <nl> + return buckets . get ( bucket ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ param reset : zero out buckets afterwards if true <nl> + * @ return a long [ ] containing the current histogram buckets <nl> + * / <nl> + public long [ ] getBuckets ( boolean reset ) <nl> { <nl> - long [ ] rv = new long [ numBuckets ] ; <nl> - for ( int i = 0 ; i < numBuckets ; i + + ) <nl> + long [ ] rv = new long [ buckets . length ( ) ] ; <nl> + for ( int i = 0 ; i < buckets . length ( ) ; i + + ) <nl> rv [ i ] = buckets . get ( i ) ; <nl> <nl> if ( reset ) <nl> - for ( int i = 0 ; i < numBuckets ; i + + ) <nl> + for ( int i = 0 ; i < buckets . length ( ) ; i + + ) <nl> buckets . set ( i , 0L ) ; <nl> <nl> return rv ; <nl> } <nl> <nl> + / * * <nl> + * @ return the smallest value that could have been added to this histogram <nl> + * / <nl> public long min ( ) <nl> { <nl> - for ( int i = 0 ; i < numBuckets ; i + + ) <nl> + for ( int i = 0 ; i < buckets . length ( ) ; i + + ) <nl> { <nl> if ( buckets . get ( i ) > 0 ) <nl> - return bucketOffsets [ i = = 0 ? 0 : i - 1 ] ; <nl> + return i = = 0 ? 0 : 1 + bucketOffsets [ i - 1 ] ; <nl> } <nl> return 0 ; <nl> } <nl> <nl> + / * * <nl> + * @ return the largest value that could have been added to this histogram . If the histogram <nl> + * overflowed , returns Long . MAX _ VALUE . <nl> + * / <nl> public long max ( ) <nl> { <nl> - int lastBucket = numBuckets - 1 ; <nl> + int lastBucket = buckets . length ( ) - 1 ; <nl> if ( buckets . get ( lastBucket ) > 0 ) <nl> - throw new IllegalStateException ( " Unable to compute ceiling for max when all buckets are full " ) ; <nl> + return Long . MAX _ VALUE ; <nl> <nl> for ( int i = lastBucket - 1 ; i > = 0 ; i - - ) <nl> { <nl> @ @ - 138 , 20 + 159 , 33 @ @ public class EstimatedHistogram <nl> return 0 ; <nl> } <nl> <nl> - public long median ( ) <nl> + / * * <nl> + * @ return the mean histogram value ( average of bucket offsets , weighted by count ) <nl> + * @ throws IllegalStateException if any values were greater than the largest bucket threshold <nl> + * / <nl> + public long mean ( ) <nl> { <nl> - long max = 0 ; <nl> - long median = 0 ; <nl> - for ( int i = 0 ; i < numBuckets ; i + + ) <nl> + int lastBucket = buckets . length ( ) - 1 ; <nl> + if ( buckets . get ( lastBucket ) > 0 ) <nl> + throw new IllegalStateException ( " Unable to compute ceiling for max when histogram overflowed " ) ; <nl> + <nl> + long elements = 0 ; <nl> + long sum = 0 ; <nl> + for ( int i = 0 ; i < lastBucket ; i + + ) <nl> { <nl> - if ( max < 1 | | buckets . get ( i ) > max ) <nl> - { <nl> - max = buckets . get ( i ) ; <nl> - if ( max > 0 ) <nl> - median = bucketOffsets [ i = = 0 ? 0 : i - 1 ] ; <nl> - } <nl> + elements + = buckets . get ( i ) ; <nl> + sum + = buckets . get ( i ) * bucketOffsets [ i ] ; <nl> } <nl> - return median ; <nl> + <nl> + return ( long ) Math . ceil ( ( double ) sum / elements ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ return true if this histogram has overflowed - - that is , a value larger than our largest bucket could bound was added <nl> + * / <nl> + public boolean isOverflowed ( ) <nl> + { <nl> + return buckets . get ( buckets . length ( ) - 1 ) > 0 ; <nl> } <nl> <nl> public static class EstimatedHistogramSerializer implements ICompactSerializer < EstimatedHistogram > <nl> @ @ - 159 , 7 + 193 , 7 @ @ public class EstimatedHistogram <nl> public void serialize ( EstimatedHistogram eh , DataOutputStream dos ) throws IOException <nl> { <nl> long [ ] offsets = eh . getBucketOffsets ( ) ; <nl> - long [ ] buckets = eh . get ( false ) ; <nl> + long [ ] buckets = eh . getBuckets ( false ) ; <nl> dos . writeInt ( buckets . length ) ; <nl> for ( int i = 0 ; i < buckets . length ; i + + ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / utils / LatencyTracker . java b / src / java / org / apache / cassandra / utils / LatencyTracker . java <nl> index b4a9973 . . cbca681 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / LatencyTracker . java <nl> + + + b / src / java / org / apache / cassandra / utils / LatencyTracker . java <nl> @ @ - 76 , 11 + 76 , 11 @ @ public class LatencyTracker <nl> <nl> public long [ ] getTotalLatencyHistogramMicros ( ) <nl> { <nl> - return totalHistogram . get ( false ) ; <nl> + return totalHistogram . getBuckets ( false ) ; <nl> } <nl> <nl> public long [ ] getRecentLatencyHistogramMicros ( ) <nl> { <nl> - return recentHistogram . get ( true ) ; <nl> + return recentHistogram . getBuckets ( true ) ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java b / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java <nl> index 4bb1652 . . c3826d1 100644 <nl> - - - a / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java <nl> + + + b / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java <nl> @ @ - 26 , 28 + 26 , 49 @ @ import static org . junit . Assert . * ; <nl> public class EstimatedHistogramTest <nl> { <nl> @ Test <nl> - public void testFindingCorrectBuckets ( ) <nl> + public void testSimple ( ) <nl> { <nl> + / / 0 and 1 map to the same , first bucket <nl> EstimatedHistogram histogram = new EstimatedHistogram ( ) ; <nl> + histogram . add ( 0 ) ; <nl> + assertEquals ( 1 , histogram . get ( 0 ) ) ; <nl> + histogram . add ( 1 ) ; <nl> + assertEquals ( 2 , histogram . get ( 0 ) ) ; <nl> + } <nl> <nl> - histogram . add ( 0L ) ; <nl> - assertEquals ( 1 , histogram . get ( false ) [ 0 ] ) ; <nl> + @ Test <nl> + public void testOverflow ( ) <nl> + { <nl> + EstimatedHistogram histogram = new EstimatedHistogram ( 1 ) ; <nl> + histogram . add ( 100 ) ; <nl> + assert histogram . isOverflowed ( ) ; <nl> + assertEquals ( Long . MAX _ VALUE , histogram . max ( ) ) ; <nl> + } <nl> <nl> - histogram . add ( 23282687 ) ; <nl> - assertEquals ( 1 , histogram . get ( false ) [ histogram . buckets . length ( ) - 2 ] ) ; <nl> + @ Test <nl> + public void testMinMax ( ) <nl> + { <nl> + EstimatedHistogram histogram = new EstimatedHistogram ( ) ; <nl> + histogram . add ( 16 ) ; <nl> + assertEquals ( 15 , histogram . min ( ) ) ; <nl> + assertEquals ( 17 , histogram . max ( ) ) ; <nl> + } <nl> <nl> - histogram . add ( 1 ) ; <nl> - assertEquals ( 1 , histogram . get ( false ) [ 1 ] ) ; <nl> + @ Test <nl> + public void testFindingCorrectBuckets ( ) <nl> + { <nl> + EstimatedHistogram histogram = new EstimatedHistogram ( ) ; <nl> + histogram . add ( 23282687 ) ; <nl> + assert ! histogram . isOverflowed ( ) ; <nl> + assertEquals ( 1 , histogram . getBuckets ( false ) [ histogram . buckets . length ( ) - 2 ] ) ; <nl> <nl> histogram . add ( 9 ) ; <nl> - assertEquals ( 1 , histogram . get ( false ) [ 8 ] ) ; <nl> + assertEquals ( 1 , histogram . getBuckets ( false ) [ 8 ] ) ; <nl> <nl> histogram . add ( 20 ) ; <nl> histogram . add ( 21 ) ; <nl> histogram . add ( 22 ) ; <nl> - assertEquals ( 3 , histogram . get ( false ) [ 13 ] ) ; <nl> - assertEquals ( 1 , histogram . min ( ) ) ; <nl> - assertEquals ( 25109160 , histogram . max ( ) ) ; <nl> - assertEquals ( 20 , histogram . median ( ) ) ; <nl> + assertEquals ( 2 , histogram . getBuckets ( false ) [ 13 ] ) ; <nl> + assertEquals ( 5021848 , histogram . mean ( ) ) ; <nl> } <nl> }

TEST DIFF:
diff - - git a / bin / cassandra . in . bat b / bin / cassandra . in . bat 
 index 1b4e38e . . 83b7472 100644 
 - - - a / bin / cassandra . in . bat 
 + + + b / bin / cassandra . in . bat 
 @ @ - 31 , 7 + 31 , 7 @ @ REM set JAVA _ HOME = " < directory > " 
 REM * * * * * CLASSPATH library setting * * * * * 
 
 REM Ensure that any user defined CLASSPATH variables are not used on startup 
 - set CLASSPATH = " % CASSANDRA _ HOME % \ conf " 
 + set CLASSPATH = " % CASSANDRA _ CONF % " 
 
 REM For each jar in the CASSANDRA _ HOME lib directory call append to build the CLASSPATH variable . 
 for % % i in ( " % CASSANDRA _ HOME % \ lib \ * . jar " ) do call : append " % % i " 
 diff - - git a / bin / sstableverify . bat b / bin / sstableverify . bat 
 index aa08826 . . eb2629f 100644 
 - - - a / bin / sstableverify . bat 
 + + + b / bin / sstableverify . bat 
 @ @ - 34 , 8 + 34 , 15 @ @ goto finally 
 
 : err 
 echo JAVA _ HOME environment variable must be set ! 
 + set ERRORLEVEL = 1 
 pause 
 
 : finally 
 + ENDLOCAL & set RC = % ERRORLEVEL % 
 + goto : exit _ with _ code 
 
 - ENDLOCAL 
 + : returncode 
 + exit / B % RC % 
 + 
 + : exit _ with _ code 
 + call : returncode % RC %

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index e581967 . . 561f7ea 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 410 , 7 + 410 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 long count = 0 ; 
 for ( SSTableReader sstable : ssTables ) 
 { 
 - sum + = sstable . getEstimatedRowSize ( ) . median ( ) ; 
 + sum + = sstable . getEstimatedRowSize ( ) . mean ( ) ; 
 count + + ; 
 } 
 return count > 0 ? sum / count : 0 ; 
 @ @ - 422 , 7 + 422 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 int count = 0 ; 
 for ( SSTableReader sstable : ssTables ) 
 { 
 - sum + = sstable . getEstimatedColumnCount ( ) . median ( ) ; 
 + sum + = sstable . getEstimatedColumnCount ( ) . mean ( ) ; 
 count + + ; 
 } 
 return count > 0 ? ( int ) ( sum / count ) : 0 ; 
 @ @ - 1023 , 12 + 1023 , 12 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 public long [ ] getRecentSSTablesPerReadHistogram ( ) 
 { 
 - return recentSSTablesPerRead . get ( true ) ; 
 + return recentSSTablesPerRead . getBuckets ( true ) ; 
 } 
 
 public long [ ] getSSTablesPerReadHistogram ( ) 
 { 
 - return sstablesPerRead . get ( false ) ; 
 + return sstablesPerRead . getBuckets ( false ) ; 
 } 
 
 public long getReadCount ( ) 
 @ @ - 1984 , 7 + 1984 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 for ( SSTableReader sstable : ssTables ) 
 { 
 - long [ ] rowSize = sstable . getEstimatedRowSize ( ) . get ( false ) ; 
 + long [ ] rowSize = sstable . getEstimatedRowSize ( ) . getBuckets ( false ) ; 
 
 for ( int i = 0 ; i < histogram . length ; i + + ) 
 histogram [ i ] + = rowSize [ i ] ; 
 @ @ - 1999 , 7 + 1999 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 for ( SSTableReader sstable : ssTables ) 
 { 
 - long [ ] columnSize = sstable . getEstimatedColumnCount ( ) . get ( false ) ; 
 + long [ ] columnSize = sstable . getEstimatedColumnCount ( ) . getBuckets ( false ) ; 
 
 for ( int i = 0 ; i < histogram . length ; i + + ) 
 histogram [ i ] + = columnSize [ i ] ; 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index 1f142e6 . . c1ddbd6 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 441 , 7 + 441 , 7 @ @ public class NodeCmd { 
 ColumnFamilyStoreMBean store = this . probe . getCfsProxy ( keySpace , columnFamily ) ; 
 
 / / default is 90 offsets 
 - long [ ] offsets = new EstimatedHistogram ( 90 ) . getBucketOffsets ( ) ; 
 + long [ ] offsets = new EstimatedHistogram ( ) . getBucketOffsets ( ) ; 
 
 long [ ] rrlh = store . getRecentReadLatencyHistogramMicros ( ) ; 
 long [ ] rwlh = store . getRecentWriteLatencyHistogramMicros ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / utils / EstimatedHistogram . java b / src / java / org / apache / cassandra / utils / EstimatedHistogram . java 
 index 7056d4b . . 2374dd4 100644 
 - - - a / src / java / org / apache / cassandra / utils / EstimatedHistogram . java 
 + + + b / src / java / org / apache / cassandra / utils / EstimatedHistogram . java 
 @ @ - 28 , 23 + 28 , 24 @ @ import org . apache . cassandra . io . ICompactSerializer ; 
 
 public class EstimatedHistogram 
 { 
 + public static EstimatedHistogramSerializer serializer = new EstimatedHistogramSerializer ( ) ; 
 
 / * * 
 * The series of values to which the counts in ` buckets ` correspond : 
 - * 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 10 , 12 , 15 , 18 , 22 , etc . 
 + * 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 10 , 12 , 14 , 17 , 20 , etc . 
 * Thus , a ` buckets ` of [ 0 , 0 , 1 , 10 ] would mean we had seen one value of 3 and 10 values of 4 . 
 * 
 * The series starts at 1 and grows by 1 . 2 each time ( rounding and removing duplicates ) . It goes from 1 
 * to around 36M by default ( creating 90 + 1 buckets ) , which will give us timing resolution from microseconds to 
 * 36 seconds , with less precision as the numbers get larger . 
 + * 
 + * Each bucket represents values from ( previous bucket offset , current offset ] . 
 * / 
 private long [ ] bucketOffsets ; 
 - private int numBuckets ; 
 
 + / / buckets is one element longer than bucketOffsets - - the last element is values greater than the last offset 
 final AtomicLongArray buckets ; 
 
 - public static EstimatedHistogramSerializer serializer = new EstimatedHistogramSerializer ( ) ; 
 - 
 public EstimatedHistogram ( ) 
 { 
 this ( 90 ) ; 
 @ @ - 53 , 7 + 54 , 7 @ @ public class EstimatedHistogram 
 public EstimatedHistogram ( int bucketCount ) 
 { 
 makeOffsets ( bucketCount ) ; 
 - buckets = new AtomicLongArray ( numBuckets ) ; 
 + buckets = new AtomicLongArray ( bucketOffsets . length + 1 ) ; 
 } 
 
 public EstimatedHistogram ( long [ ] offsets , long [ ] bucketData ) 
 @ @ - 61 , 7 + 62 , 6 @ @ public class EstimatedHistogram 
 assert bucketData . length = = offsets . length + 1 ; 
 bucketOffsets = offsets ; 
 buckets = new AtomicLongArray ( bucketData ) ; 
 - numBuckets = bucketData . length ; 
 } 
 
 private void makeOffsets ( int size ) 
 @ @ - 69 , 7 + 69 , 7 @ @ public class EstimatedHistogram 
 bucketOffsets = new long [ size ] ; 
 long last = 1 ; 
 bucketOffsets [ 0 ] = last ; 
 - for ( int i = 1 ; i < size ; i + + ) 
 + for ( int i = 1 ; i < size ; i + + ) 
 { 
 long next = Math . round ( last * 1 . 2 ) ; 
 if ( next = = last ) 
 @ @ - 77 , 58 + 77 , 79 @ @ public class EstimatedHistogram 
 bucketOffsets [ i ] = next ; 
 last = next ; 
 } 
 - numBuckets = bucketOffsets . length + 1 ; 
 } 
 
 + / * * 
 + * @ return the histogram values corresponding to each bucket index 
 + * / 
 public long [ ] getBucketOffsets ( ) 
 { 
 return bucketOffsets ; 
 } 
 - 
 + 
 + / * * 
 + * Increments the count of the bucket closest to n , rounding UP . 
 + * @ param n 
 + * / 
 public void add ( long n ) 
 { 
 int index = Arrays . binarySearch ( bucketOffsets , n ) ; 
 if ( index < 0 ) 
 { 
 - / / inexact match , find closest bucket 
 + / / inexact match , take the first bucket higher than n 
 index = - index - 1 ; 
 } 
 - else 
 - { 
 - / / exact match , so we want the next highest one 
 - index + = 1 ; 
 - } 
 + / / else exact match ; we ' re good 
 buckets . incrementAndGet ( index ) ; 
 } 
 
 - public long [ ] get ( boolean reset ) 
 + / * * 
 + * @ return the count in the given bucket 
 + * / 
 + long get ( int bucket ) 
 + { 
 + return buckets . get ( bucket ) ; 
 + } 
 + 
 + / * * 
 + * @ param reset : zero out buckets afterwards if true 
 + * @ return a long [ ] containing the current histogram buckets 
 + * / 
 + public long [ ] getBuckets ( boolean reset ) 
 { 
 - long [ ] rv = new long [ numBuckets ] ; 
 - for ( int i = 0 ; i < numBuckets ; i + + ) 
 + long [ ] rv = new long [ buckets . length ( ) ] ; 
 + for ( int i = 0 ; i < buckets . length ( ) ; i + + ) 
 rv [ i ] = buckets . get ( i ) ; 
 
 if ( reset ) 
 - for ( int i = 0 ; i < numBuckets ; i + + ) 
 + for ( int i = 0 ; i < buckets . length ( ) ; i + + ) 
 buckets . set ( i , 0L ) ; 
 
 return rv ; 
 } 
 
 + / * * 
 + * @ return the smallest value that could have been added to this histogram 
 + * / 
 public long min ( ) 
 { 
 - for ( int i = 0 ; i < numBuckets ; i + + ) 
 + for ( int i = 0 ; i < buckets . length ( ) ; i + + ) 
 { 
 if ( buckets . get ( i ) > 0 ) 
 - return bucketOffsets [ i = = 0 ? 0 : i - 1 ] ; 
 + return i = = 0 ? 0 : 1 + bucketOffsets [ i - 1 ] ; 
 } 
 return 0 ; 
 } 
 
 + / * * 
 + * @ return the largest value that could have been added to this histogram . If the histogram 
 + * overflowed , returns Long . MAX _ VALUE . 
 + * / 
 public long max ( ) 
 { 
 - int lastBucket = numBuckets - 1 ; 
 + int lastBucket = buckets . length ( ) - 1 ; 
 if ( buckets . get ( lastBucket ) > 0 ) 
 - throw new IllegalStateException ( " Unable to compute ceiling for max when all buckets are full " ) ; 
 + return Long . MAX _ VALUE ; 
 
 for ( int i = lastBucket - 1 ; i > = 0 ; i - - ) 
 { 
 @ @ - 138 , 20 + 159 , 33 @ @ public class EstimatedHistogram 
 return 0 ; 
 } 
 
 - public long median ( ) 
 + / * * 
 + * @ return the mean histogram value ( average of bucket offsets , weighted by count ) 
 + * @ throws IllegalStateException if any values were greater than the largest bucket threshold 
 + * / 
 + public long mean ( ) 
 { 
 - long max = 0 ; 
 - long median = 0 ; 
 - for ( int i = 0 ; i < numBuckets ; i + + ) 
 + int lastBucket = buckets . length ( ) - 1 ; 
 + if ( buckets . get ( lastBucket ) > 0 ) 
 + throw new IllegalStateException ( " Unable to compute ceiling for max when histogram overflowed " ) ; 
 + 
 + long elements = 0 ; 
 + long sum = 0 ; 
 + for ( int i = 0 ; i < lastBucket ; i + + ) 
 { 
 - if ( max < 1 | | buckets . get ( i ) > max ) 
 - { 
 - max = buckets . get ( i ) ; 
 - if ( max > 0 ) 
 - median = bucketOffsets [ i = = 0 ? 0 : i - 1 ] ; 
 - } 
 + elements + = buckets . get ( i ) ; 
 + sum + = buckets . get ( i ) * bucketOffsets [ i ] ; 
 } 
 - return median ; 
 + 
 + return ( long ) Math . ceil ( ( double ) sum / elements ) ; 
 + } 
 + 
 + / * * 
 + * @ return true if this histogram has overflowed - - that is , a value larger than our largest bucket could bound was added 
 + * / 
 + public boolean isOverflowed ( ) 
 + { 
 + return buckets . get ( buckets . length ( ) - 1 ) > 0 ; 
 } 
 
 public static class EstimatedHistogramSerializer implements ICompactSerializer < EstimatedHistogram > 
 @ @ - 159 , 7 + 193 , 7 @ @ public class EstimatedHistogram 
 public void serialize ( EstimatedHistogram eh , DataOutputStream dos ) throws IOException 
 { 
 long [ ] offsets = eh . getBucketOffsets ( ) ; 
 - long [ ] buckets = eh . get ( false ) ; 
 + long [ ] buckets = eh . getBuckets ( false ) ; 
 dos . writeInt ( buckets . length ) ; 
 for ( int i = 0 ; i < buckets . length ; i + + ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / utils / LatencyTracker . java b / src / java / org / apache / cassandra / utils / LatencyTracker . java 
 index b4a9973 . . cbca681 100644 
 - - - a / src / java / org / apache / cassandra / utils / LatencyTracker . java 
 + + + b / src / java / org / apache / cassandra / utils / LatencyTracker . java 
 @ @ - 76 , 11 + 76 , 11 @ @ public class LatencyTracker 
 
 public long [ ] getTotalLatencyHistogramMicros ( ) 
 { 
 - return totalHistogram . get ( false ) ; 
 + return totalHistogram . getBuckets ( false ) ; 
 } 
 
 public long [ ] getRecentLatencyHistogramMicros ( ) 
 { 
 - return recentHistogram . get ( true ) ; 
 + return recentHistogram . getBuckets ( true ) ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java b / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java 
 index 4bb1652 . . c3826d1 100644 
 - - - a / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java 
 + + + b / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java 
 @ @ - 26 , 28 + 26 , 49 @ @ import static org . junit . Assert . * ; 
 public class EstimatedHistogramTest 
 { 
 @ Test 
 - public void testFindingCorrectBuckets ( ) 
 + public void testSimple ( ) 
 { 
 + / / 0 and 1 map to the same , first bucket 
 EstimatedHistogram histogram = new EstimatedHistogram ( ) ; 
 + histogram . add ( 0 ) ; 
 + assertEquals ( 1 , histogram . get ( 0 ) ) ; 
 + histogram . add ( 1 ) ; 
 + assertEquals ( 2 , histogram . get ( 0 ) ) ; 
 + } 
 
 - histogram . add ( 0L ) ; 
 - assertEquals ( 1 , histogram . get ( false ) [ 0 ] ) ; 
 + @ Test 
 + public void testOverflow ( ) 
 + { 
 + EstimatedHistogram histogram = new EstimatedHistogram ( 1 ) ; 
 + histogram . add ( 100 ) ; 
 + assert histogram . isOverflowed ( ) ; 
 + assertEquals ( Long . MAX _ VALUE , histogram . max ( ) ) ; 
 + } 
 
 - histogram . add ( 23282687 ) ; 
 - assertEquals ( 1 , histogram . get ( false ) [ histogram . buckets . length ( ) - 2 ] ) ; 
 + @ Test 
 + public void testMinMax ( ) 
 + { 
 + EstimatedHistogram histogram = new EstimatedHistogram ( ) ; 
 + histogram . add ( 16 ) ; 
 + assertEquals ( 15 , histogram . min ( ) ) ; 
 + assertEquals ( 17 , histogram . max ( ) ) ; 
 + } 
 
 - histogram . add ( 1 ) ; 
 - assertEquals ( 1 , histogram . get ( false ) [ 1 ] ) ; 
 + @ Test 
 + public void testFindingCorrectBuckets ( ) 
 + { 
 + EstimatedHistogram histogram = new EstimatedHistogram ( ) ; 
 + histogram . add ( 23282687 ) ; 
 + assert ! histogram . isOverflowed ( ) ; 
 + assertEquals ( 1 , histogram . getBuckets ( false ) [ histogram . buckets . length ( ) - 2 ] ) ; 
 
 histogram . add ( 9 ) ; 
 - assertEquals ( 1 , histogram . get ( false ) [ 8 ] ) ; 
 + assertEquals ( 1 , histogram . getBuckets ( false ) [ 8 ] ) ; 
 
 histogram . add ( 20 ) ; 
 histogram . add ( 21 ) ; 
 histogram . add ( 22 ) ; 
 - assertEquals ( 3 , histogram . get ( false ) [ 13 ] ) ; 
 - assertEquals ( 1 , histogram . min ( ) ) ; 
 - assertEquals ( 25109160 , histogram . max ( ) ) ; 
 - assertEquals ( 20 , histogram . median ( ) ) ; 
 + assertEquals ( 2 , histogram . getBuckets ( false ) [ 13 ] ) ; 
 + assertEquals ( 5021848 , histogram . mean ( ) ) ; 
 } 
 }
