BLEU SCORE: 0.03283637368030199

TEST MSG: Handle overlapping multislices in thrift and cql
GENERATED MSG: range query support

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a7cc872 . . 8e0dead 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 26 , 6 + 26 , 7 @ @ <nl> * Fix IllegalArgumentException in CqlStorage ( CASSANDRA - 7287 ) <nl> * Allow nulls / non - existant fields in UDT ( CASSANDRA - 7206 ) <nl> * Backport Thrift MultiSliceRequest ( CASSANDRA - 7027 ) <nl> + * Handle overlapping MultiSlices ( CASSANDRA - 7279 ) <nl> Merged from 2 . 0 : <nl> * Copy compaction options to make sure they are reloaded ( CASSANDRA - 7290 ) <nl> * Add option to do more aggressive tombstone compactions ( CASSANDRA - 6563 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java <nl> index b06b2ee . . 8b5a403 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java <nl> @ @ - 98 , 6 + 98 , 7 @ @ public class CQL3CasConditions implements CASConditions <nl> slices [ i + + ] = prefix . slice ( ) ; <nl> <nl> int toGroup = cfm . comparator . isDense ( ) ? - 1 : cfm . clusteringColumns ( ) . size ( ) ; <nl> + assert ColumnSlice . validateSlices ( slices , cfm . comparator , false ) ; <nl> return new SliceQueryFilter ( slices , false , slices . length , toGroup ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 501ef45 . . d484c5f 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 533 , 6 + 533 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> <nl> private SliceQueryFilter sliceFilter ( ColumnSlice [ ] slices , int limit , int toGroup ) <nl> { <nl> + assert ColumnSlice . validateSlices ( slices , cfm . comparator , isReversed ) : String . format ( " Invalid slices : " + Arrays . toString ( slices ) + ( isReversed ? " ( reversed ) " : " " ) ) ; <nl> return new SliceQueryFilter ( slices , isReversed , limit , toGroup ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / composites / AbstractCType . java b / src / java / org / apache / cassandra / db / composites / AbstractCType . java <nl> index 0e73397 . . e299e42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / composites / AbstractCType . java <nl> + + + b / src / java / org / apache / cassandra / db / composites / AbstractCType . java <nl> @ @ - 60 , 6 + 60 , 11 @ @ public abstract class AbstractCType implements CType <nl> { <nl> public int compare ( Composite c1 , Composite c2 ) <nl> { <nl> + if ( c1 . isEmpty ( ) ) <nl> + return c2 . isEmpty ( ) ? 0 : - 1 ; <nl> + if ( c2 . isEmpty ( ) ) <nl> + return 1 ; <nl> + <nl> return AbstractCType . this . compare ( c2 , c1 ) ; <nl> } <nl> } ; <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> index a945114 . . bca4743 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> @ @ - 19 , 6 + 19 , 8 @ @ package org . apache . cassandra . db . filter ; <nl> <nl> import java . io . * ; <nl> import java . nio . ByteBuffer ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Arrays ; <nl> import java . util . Comparator ; <nl> import java . util . List ; <nl> <nl> @ @ - 108 , 6 + 110 , 101 @ @ public class ColumnSlice <nl> return 0 ; <nl> } <nl> <nl> + / * * <nl> + * Validates that the provided slice array contains only non - overlapped slices valid for a query { @ code reversed } <nl> + * or not on a table using { @ code comparator } . <nl> + * / <nl> + public static boolean validateSlices ( ColumnSlice [ ] slices , CellNameType comparator , boolean reversed ) <nl> + { <nl> + return validateSlices ( slices , reversed ? comparator . reverseComparator ( ) : comparator ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Validates that the provided slice array contains only non - overlapped slices in { @ code comparator } order . <nl> + * / <nl> + public static boolean validateSlices ( ColumnSlice [ ] slices , Comparator < Composite > comparator ) <nl> + { <nl> + for ( int i = 0 ; i < slices . length ; i + + ) <nl> + { <nl> + if ( i > 0 & & comparator . compare ( slices [ i - 1 ] . finish , slices [ i ] . start ) > = 0 ) <nl> + return false ; <nl> + <nl> + if ( slices [ i ] . finish . isEmpty ( ) ) <nl> + return i = = slices . length - 1 ; <nl> + <nl> + if ( comparator . compare ( slices [ i ] . start , slices [ i ] . finish ) > 0 ) <nl> + return false ; <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> + / * * <nl> + * Takes an array of slices ( potentially overlapping and in any order , though each individual slice must have <nl> + * its start before or equal its end in { @ code comparator } orde ) and return an equivalent array of non - overlapping <nl> + * slices in { @ code comparator order } . <nl> + * <nl> + * @ param slices an array of slices . This may be modified by this method . <nl> + * @ param comparator the order in which to sort the slices . <nl> + * @ return the smallest possible array of non - overlapping slices in { @ code compator } order . If the original <nl> + * slices are already non - overlapping and in comparator order , this may or may not return the provided slices <nl> + * directly . <nl> + * / <nl> + public static ColumnSlice [ ] deoverlapSlices ( ColumnSlice [ ] slices , final Comparator < Composite > comparator ) <nl> + { <nl> + if ( slices . length < = 1 ) <nl> + return slices ; <nl> + <nl> + Arrays . sort ( slices , new Comparator < ColumnSlice > ( ) <nl> + { <nl> + @ Override <nl> + public int compare ( ColumnSlice s1 , ColumnSlice s2 ) <nl> + { <nl> + int c = comparator . compare ( s1 . start , s2 . start ) ; <nl> + if ( c ! = 0 ) <nl> + return c ; <nl> + <nl> + / / For the finish , empty always means greater <nl> + return s1 . finish . isEmpty ( ) | | s2 . finish . isEmpty ( ) <nl> + ? s1 . finish . isEmpty ( ) ? 1 : s2 . finish . isEmpty ( ) ? - 1 : 0 <nl> + : comparator . compare ( s1 . finish , s2 . finish ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + List < ColumnSlice > slicesCopy = new ArrayList < > ( slices . length ) ; <nl> + <nl> + ColumnSlice last = slices [ 0 ] ; <nl> + <nl> + for ( int i = 1 ; i < slices . length ; i + + ) <nl> + { <nl> + ColumnSlice s2 = slices [ i ] ; <nl> + <nl> + boolean includesStart = last . includes ( comparator , s2 . start ) ; <nl> + boolean includesFinish = s2 . finish . isEmpty ( ) ? last . finish . isEmpty ( ) : last . includes ( comparator , s2 . finish ) ; <nl> + <nl> + if ( includesStart & & includesFinish ) <nl> + continue ; <nl> + <nl> + if ( ! includesStart & & ! includesFinish ) <nl> + { <nl> + slicesCopy . add ( last ) ; <nl> + last = s2 ; <nl> + continue ; <nl> + } <nl> + <nl> + if ( includesStart ) <nl> + { <nl> + last = new ColumnSlice ( last . start , s2 . finish ) ; <nl> + continue ; <nl> + } <nl> + <nl> + assert ! includesFinish ; <nl> + } <nl> + <nl> + slicesCopy . add ( last ) ; <nl> + <nl> + return slicesCopy . toArray ( new ColumnSlice [ slicesCopy . size ( ) ] ) ; <nl> + } <nl> + <nl> @ Override <nl> public final int hashCode ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / thrift / CassandraServer . java b / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> index 917e4cb . . 1a77ffa 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> + + + b / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> @ @ - 2065 , 7 + 2065 , 7 @ @ public class CassandraServer implements Cassandra . Iface <nl> org . apache . cassandra . db . ConsistencyLevel consistencyLevel = ThriftConversion . fromThrift ( request . getConsistency _ level ( ) ) ; <nl> consistencyLevel . validateForRead ( keyspace ) ; <nl> List < ReadCommand > commands = new ArrayList < > ( 1 ) ; <nl> - ColumnSlice [ ] slices = new ColumnSlice [ request . getColumn _ slices ( ) . size ( ) ] ; <nl> + ColumnSlice [ ] slices = new ColumnSlice [ request . getColumn _ slices ( ) . size ( ) ] ; <nl> for ( int i = 0 ; i < request . getColumn _ slices ( ) . size ( ) ; i + + ) <nl> { <nl> fixOptionalSliceParameters ( request . getColumn _ slices ( ) . get ( i ) ) ; <nl> @ @ - 2078 , 7 + 2078 , 9 @ @ public class CassandraServer implements Cassandra . Iface <nl> throw new InvalidRequestException ( String . format ( " Reversed column slice at index % d had start less than finish " , i ) ) ; <nl> slices [ i ] = new ColumnSlice ( start , finish ) ; <nl> } <nl> - SliceQueryFilter filter = new SliceQueryFilter ( slices , request . reversed , request . count ) ; <nl> + <nl> + ColumnSlice [ ] deoverlapped = ColumnSlice . deoverlapSlices ( slices , request . reversed ? metadata . comparator . reverseComparator ( ) : metadata . comparator ) ; <nl> + SliceQueryFilter filter = new SliceQueryFilter ( deoverlapped , request . reversed , request . count ) ; <nl> ThriftValidation . validateKey ( metadata , request . key ) ; <nl> commands . add ( ReadCommand . create ( keyspace , request . key , request . column _ parent . getColumn _ family ( ) , System . currentTimeMillis ( ) , filter ) ) ; <nl> return getSlice ( commands , request . column _ parent . isSetSuper _ column ( ) , consistencyLevel ) . entrySet ( ) . iterator ( ) . next ( ) . getValue ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java b / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java <nl> index 6553de5 . . 2dc3744 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java <nl> @ @ - 18 , 22 + 18 , 23 @ @ <nl> * * / <nl> package org . apache . cassandra . db . filter ; <nl> <nl> - import org . apache . cassandra . db . composites . Composite ; <nl> - import org . apache . cassandra . db . composites . CompoundDenseCellNameType ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . * ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . db . composites . * ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . db . marshal . Int32Type ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> - import org . junit . Test ; <nl> <nl> - import java . nio . ByteBuffer ; <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> - <nl> - import static org . junit . Assert . assertFalse ; <nl> - import static org . junit . Assert . assertTrue ; <nl> + import static org . junit . Assert . * ; <nl> <nl> public class ColumnSliceTest <nl> { <nl> + private static final CellNameType simpleIntType = new SimpleDenseCellNameType ( Int32Type . instance ) ; <nl> + <nl> @ Test <nl> public void testIntersectsSingleSlice ( ) <nl> { <nl> @ @ - 278 , 6 + 279 , 65 @ @ public class ColumnSliceTest <nl> assertTrue ( slice . intersects ( columnNames ( 1 , 0 , 0 ) , columnNames ( 2 , 2 , 2 ) , nameType , true ) ) ; <nl> } <nl> <nl> + @ Test <nl> + public void testDeoverlapSlices ( ) <nl> + { <nl> + ColumnSlice [ ] slices ; <nl> + ColumnSlice [ ] deoverlapped ; <nl> + <nl> + / / Preserve correct slices <nl> + slices = slices ( s ( 0 , 3 ) , s ( 4 , 5 ) , s ( 6 , 9 ) ) ; <nl> + assertSlicesValid ( slices ) ; <nl> + assertSlicesEquals ( slices , deoverlapSlices ( slices ) ) ; <nl> + <nl> + / / Simple overlap <nl> + slices = slices ( s ( 0 , 3 ) , s ( 2 , 5 ) , s ( 8 , 9 ) ) ; <nl> + assertSlicesInvalid ( slices ) ; <nl> + assertSlicesEquals ( slices ( s ( 0 , 5 ) , s ( 8 , 9 ) ) , deoverlapSlices ( slices ) ) ; <nl> + <nl> + / / Slice overlaps others fully <nl> + slices = slices ( s ( 0 , 10 ) , s ( 2 , 5 ) , s ( 8 , 9 ) ) ; <nl> + assertSlicesInvalid ( slices ) ; <nl> + assertSlicesEquals ( slices ( s ( 0 , 10 ) ) , deoverlapSlices ( slices ) ) ; <nl> + <nl> + / / Slice with empty end overlaps others fully <nl> + slices = slices ( s ( 0 , - 1 ) , s ( 2 , 5 ) , s ( 8 , 9 ) ) ; <nl> + assertSlicesInvalid ( slices ) ; <nl> + assertSlicesEquals ( slices ( s ( 0 , - 1 ) ) , deoverlapSlices ( slices ) ) ; <nl> + <nl> + / / Overlap with slices selecting only one element <nl> + slices = slices ( s ( 0 , 4 ) , s ( 4 , 4 ) , s ( 4 , 8 ) ) ; <nl> + assertSlicesInvalid ( slices ) ; <nl> + assertSlicesEquals ( slices ( s ( 0 , 8 ) ) , deoverlapSlices ( slices ) ) ; <nl> + <nl> + / / Unordered slices ( without overlap ) <nl> + slices = slices ( s ( 4 , 8 ) , s ( 0 , 3 ) , s ( 9 , 9 ) ) ; <nl> + assertSlicesInvalid ( slices ) ; <nl> + assertSlicesEquals ( slices ( s ( 0 , 3 ) , s ( 4 , 8 ) , s ( 9 , 9 ) ) , deoverlapSlices ( slices ) ) ; <nl> + <nl> + / / All range select but not by a single slice <nl> + slices = slices ( s ( 5 , - 1 ) , s ( 2 , 5 ) , s ( - 1 , 2 ) ) ; <nl> + assertSlicesInvalid ( slices ) ; <nl> + assertSlicesEquals ( slices ( s ( - 1 , - 1 ) ) , deoverlapSlices ( slices ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testValidateSlices ( ) <nl> + { <nl> + assertSlicesValid ( slices ( s ( 0 , 3 ) ) ) ; <nl> + assertSlicesValid ( slices ( s ( 3 , 3 ) ) ) ; <nl> + assertSlicesValid ( slices ( s ( 3 , 3 ) , s ( 4 , 4 ) ) ) ; <nl> + assertSlicesValid ( slices ( s ( 0 , 3 ) , s ( 4 , 5 ) , s ( 6 , 9 ) ) ) ; <nl> + assertSlicesValid ( slices ( s ( - 1 , - 1 ) ) ) ; <nl> + assertSlicesValid ( slices ( s ( - 1 , 3 ) , s ( 4 , - 1 ) ) ) ; <nl> + <nl> + assertSlicesInvalid ( slices ( s ( 3 , 0 ) ) ) ; <nl> + assertSlicesInvalid ( slices ( s ( 0 , 2 ) , s ( 2 , 4 ) ) ) ; <nl> + assertSlicesInvalid ( slices ( s ( 0 , 2 ) , s ( 1 , 4 ) ) ) ; <nl> + assertSlicesInvalid ( slices ( s ( 0 , 2 ) , s ( 3 , 4 ) , s ( 3 , 4 ) ) ) ; <nl> + assertSlicesInvalid ( slices ( s ( - 1 , 2 ) , s ( 3 , - 1 ) , s ( 5 , 9 ) ) ) ; <nl> + } <nl> + <nl> private static Composite composite ( Integer . . . components ) <nl> { <nl> List < AbstractType < ? > > types = new ArrayList < > ( ) ; <nl> @ @ - 295 , 4 + 355 , 61 @ @ public class ColumnSliceTest <nl> names . add ( ByteBufferUtil . bytes ( component ) ) ; <nl> return names ; <nl> } <nl> - } <nl> \ No newline at end of file <nl> + <nl> + private static Composite simpleComposite ( int i ) <nl> + { <nl> + / / We special negative values to mean EMPTY for convenience sake <nl> + if ( i < 0 ) <nl> + return Composites . EMPTY ; <nl> + <nl> + return simpleIntType . make ( i ) ; <nl> + } <nl> + <nl> + private static ColumnSlice s ( int start , int finish ) <nl> + { <nl> + return new ColumnSlice ( simpleComposite ( start ) , simpleComposite ( finish ) ) ; <nl> + } <nl> + <nl> + private static ColumnSlice [ ] slices ( ColumnSlice . . . slices ) <nl> + { <nl> + return slices ; <nl> + } <nl> + <nl> + private static ColumnSlice [ ] deoverlapSlices ( ColumnSlice [ ] slices ) <nl> + { <nl> + return ColumnSlice . deoverlapSlices ( slices , simpleIntType ) ; <nl> + } <nl> + <nl> + private static void assertSlicesValid ( ColumnSlice [ ] slices ) <nl> + { <nl> + assertTrue ( " Slices " + toString ( slices ) + " should be valid " , ColumnSlice . validateSlices ( slices , simpleIntType ) ) ; <nl> + } <nl> + <nl> + private static void assertSlicesInvalid ( ColumnSlice [ ] slices ) <nl> + { <nl> + assertFalse ( " Slices " + toString ( slices ) + " shouldn ' t be valid " , ColumnSlice . validateSlices ( slices , simpleIntType ) ) ; <nl> + } <nl> + <nl> + private static void assertSlicesEquals ( ColumnSlice [ ] expected , ColumnSlice [ ] actual ) <nl> + { <nl> + assertTrue ( " Expected " + toString ( expected ) + " but got " + toString ( actual ) , Arrays . equals ( expected , actual ) ) ; <nl> + } <nl> + <nl> + private static String toString ( ColumnSlice [ ] slices ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( ) . append ( " [ " ) ; <nl> + for ( int i = 0 ; i < slices . length ; i + + ) <nl> + { <nl> + if ( i > 0 ) <nl> + sb . append ( " , " ) ; <nl> + <nl> + ColumnSlice slice = slices [ i ] ; <nl> + sb . append ( " ( " ) ; <nl> + sb . append ( slice . start . isEmpty ( ) ? " - 1 " : simpleIntType . getString ( slice . start ) ) ; <nl> + sb . append ( " , " ) ; <nl> + sb . append ( slice . finish . isEmpty ( ) ? " - 1 " : simpleIntType . getString ( slice . finish ) ) ; <nl> + sb . append ( " ) " ) ; <nl> + } <nl> + return sb . append ( " ] " ) . toString ( ) ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / thrift / MultiSliceTest . java b / test / unit / org / apache / cassandra / thrift / MultiSliceTest . java <nl> index d1c913b . . 9193258 100644 <nl> - - - a / test / unit / org / apache / cassandra / thrift / MultiSliceTest . java <nl> + + + b / test / unit / org / apache / cassandra / thrift / MultiSliceTest . java <nl> @ @ - 114 , 9 + 114 , 21 @ @ public class MultiSliceTest extends SchemaLoader <nl> req . setCount ( 6 ) ; <nl> req . reversed = true ; <nl> req . setColumn _ slices ( Arrays . asList ( columnSliceFrom ( " e " , " a " ) , columnSliceFrom ( " g " , " d " ) ) ) ; <nl> - assertColumnNameMatches ( Arrays . asList ( " g " , " e " , " d " , " c " , " b " , " a " ) , server . get _ multi _ slice ( req ) ) ; <nl> + assertColumnNameMatches ( Arrays . asList ( " g " , " f " , " e " , " d " , " c " , " b " ) , server . get _ multi _ slice ( req ) ) ; <nl> } <nl> - <nl> + <nl> + @ Test <nl> + public void test _ with _ overlap _ with _ count ( ) throws TException <nl> + { <nl> + ColumnParent cp = new ColumnParent ( " Standard1 " ) ; <nl> + ByteBuffer key = ByteBuffer . wrap ( " overlap _ reversed _ count " . getBytes ( ) ) ; <nl> + addTheAlphabetToRow ( key , cp ) ; <nl> + MultiSliceRequest req = makeMultiSliceRequest ( key ) ; <nl> + req . setCount ( 6 ) ; <nl> + req . setColumn _ slices ( Arrays . asList ( columnSliceFrom ( " a " , " e " ) , columnSliceFrom ( " d " , " g " ) , columnSliceFrom ( " d " , " g " ) ) ) ; <nl> + assertColumnNameMatches ( Arrays . asList ( " a " , " b " , " c " , " d " , " e " , " f " ) , server . get _ multi _ slice ( req ) ) ; <nl> + } <nl> + <nl> private static void addTheAlphabetToRow ( ByteBuffer key , ColumnParent parent ) <nl> throws InvalidRequestException , UnavailableException , TimedOutException <nl> { <nl> @ @ - 135 , 7 + 147 , 7 @ @ public class MultiSliceTest extends SchemaLoader <nl> for ( int i = 0 ; i < expected . size ( ) ; i + + ) <nl> { <nl> Assert . assertEquals ( actual . get ( i ) + " did not equal " + expected . get ( i ) , <nl> - new String ( actual . get ( i ) . getColumn ( ) . getName ( ) ) , expected . get ( i ) ) ; <nl> + expected . get ( i ) , new String ( actual . get ( i ) . getColumn ( ) . getName ( ) ) ) ; <nl> } <nl> } <nl> <nl> @ @ - 146 , 4 + 158 , 4 @ @ public class MultiSliceTest extends SchemaLoader <nl> cs . setFinish ( ByteBufferUtil . bytes ( endInclusive ) ) ; <nl> return cs ; <nl> } <nl> - } <nl> \ No newline at end of file <nl> + }
NEAREST DIFF (one line): diff - - git a / src / org / apache / cassandra / config / DatabaseDescriptor . java b / src / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 683009c . . 73cf3a6 100644 <nl> - - - a / src / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 18 , 21 + 18 , 24 @ @ <nl> <nl> package org . apache . cassandra . config ; <nl> <nl> - import java . util . * ; <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + import java . util . ArrayList ; <nl> + import java . util . HashMap ; <nl> + import java . util . HashSet ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> - import java . io . * ; <nl> <nl> import org . apache . cassandra . db . ColumnFamily ; <nl> + import org . apache . cassandra . db . SystemTable ; <nl> import org . apache . cassandra . db . Table ; <nl> import org . apache . cassandra . db . TypeInfo ; <nl> - import org . apache . cassandra . db . DBManager ; <nl> - import org . apache . cassandra . db . SystemTable ; <nl> - import org . apache . cassandra . db . Table . TableMetadata ; <nl> import org . apache . cassandra . utils . FileUtils ; <nl> import org . apache . cassandra . utils . XMLUtils ; <nl> import org . w3c . dom . Node ; <nl> import org . w3c . dom . NodeList ; <nl> - import org . apache . cassandra . io . * ; <nl> <nl> <nl> / * * <nl> @ @ - 306 , 6 + 309 , 9 @ @ public class DatabaseDescriptor <nl> / * Read the table related stuff from config * / <nl> NodeList tables = xmlUtils . getRequestedNodeList ( " / Storage / Tables / Table " ) ; <nl> int size = tables . getLength ( ) ; <nl> + if ( size = = 0 ) { <nl> + throw new UnsupportedOperationException ( " A Table must be configured " ) ; <nl> + } <nl> for ( int i = 0 ; i < size ; + + i ) <nl> { <nl> Node table = tables . item ( i ) ; <nl> @ @ - 785 , 4 + 791 , 9 @ @ public class DatabaseDescriptor <nl> { <nl> return tableToCFMetaDataMap _ ; <nl> } <nl> + <nl> + public static String getTableName ( ) <nl> + { <nl> + return tables _ . get ( 0 ) ; <nl> + } <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / ColumnFamily . java b / src / org / apache / cassandra / db / ColumnFamily . java <nl> index 51ac744 . . a2ac3a2 100644 <nl> - - - a / src / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 288 , 7 + 288 , 7 @ @ public final class ColumnFamily <nl> return columns _ . getSortedColumns ( ) ; <nl> } <nl> <nl> - Map < String , IColumn > getColumns ( ) <nl> + public Map < String , IColumn > getColumns ( ) <nl> { <nl> return columns _ . getColumns ( ) ; <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / ColumnFamilyStore . java b / src / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index be7c245 . . 28bb3f7 100644 <nl> - - - a / src / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1384 , 4 + 1384 , 14 @ @ public class ColumnFamilyStore <nl> { <nl> memtable _ . get ( ) . flushOnRecovery ( ) ; <nl> } <nl> + <nl> + public Object getMemtable ( ) <nl> + { <nl> + return memtable _ . get ( ) ; <nl> + } <nl> + <nl> + public Set < String > getSSTableFilenames ( ) <nl> + { <nl> + return Collections . unmodifiableSet ( ssTables _ ) ; <nl> + } <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / Memtable . java b / src / org / apache / cassandra / db / Memtable . java <nl> index 2bdad37 . . 567b829 100644 <nl> - - - a / src / org / apache / cassandra / db / Memtable . java <nl> + + + b / src / org / apache / cassandra / db / Memtable . java <nl> @ @ - 26 , 6 + 26 , 8 @ @ import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . Set ; <nl> + import java . util . Iterator ; <nl> + import java . util . PriorityQueue ; <nl> import java . util . concurrent . Callable ; <nl> import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . ExecutorService ; <nl> @ @ - 45 , 6 + 47 , 7 @ @ import org . apache . cassandra . io . DataOutputBuffer ; <nl> import org . apache . cassandra . io . SSTable ; <nl> import org . apache . cassandra . utils . BloomFilter ; <nl> import org . apache . cassandra . utils . LogUtil ; <nl> + import org . apache . cassandra . utils . DestructivePQIterator ; <nl> <nl> / * * <nl> * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) <nl> @ @ - 419 , 4 + 422 , 9 @ @ public class Memtable implements MemtableMBean , Comparable < Memtable > <nl> columnFamilies _ . clear ( ) ; <nl> } <nl> <nl> + public Iterator < String > sortedKeyIterator ( ) <nl> + { <nl> + return new DestructivePQIterator < String > ( new PriorityQueue < String > ( columnFamilies _ . keySet ( ) ) ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / MemtableManager . java b / src / org / apache / cassandra / db / MemtableManager . java <nl> index 997bbd3 . . 54242d1 100644 <nl> - - - a / src / org / apache / cassandra / db / MemtableManager . java <nl> + + + b / src / org / apache / cassandra / db / MemtableManager . java <nl> @ @ - 40 , 7 + 40 , 7 @ @ public class MemtableManager <nl> private static Lock lock _ = new ReentrantLock ( ) ; <nl> private static Logger logger _ = Logger . getLogger ( MemtableManager . class ) ; <nl> private ReentrantReadWriteLock rwLock _ = new ReentrantReadWriteLock ( true ) ; <nl> - static MemtableManager instance ( ) <nl> + public static MemtableManager instance ( ) <nl> { <nl> if ( instance _ = = null ) <nl> { <nl> @ @ - 157 , 7 + 157 , 22 @ @ public class MemtableManager <nl> 	 } <nl> } <nl> <nl> - <nl> - <nl> + public List < Memtable > getUnflushedMemtables ( String cfName ) <nl> + { <nl> + rwLock _ . readLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + List < Memtable > memtables = history _ . get ( cfName ) ; <nl> + if ( memtables ! = null ) <nl> + { <nl> + return new ArrayList < Memtable > ( memtables ) ; <nl> + } <nl> + return Arrays . asList ( new Memtable [ 0 ] ) ; <nl> + } <nl> + finally <nl> + { <nl> + rwLock _ . readLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / Table . java b / src / org / apache / cassandra / db / Table . java <nl> index 9c84b42 . . f1b260a 100644 <nl> - - - a / src / org / apache / cassandra / db / Table . java <nl> + + + b / src / org / apache / cassandra / db / Table . java <nl> @ @ - 60 , 7 + 60 , 7 @ @ public class Table <nl> * is basically the column family name and the ID associated with <nl> * this column family . We use this ID in the Commit Log header to <nl> * determine when a log file that has been rolled can be deleted . <nl> - * / <nl> + * / <nl> public static class TableMetadata <nl> { <nl> / * Name of the column family * / <nl> @ @ - 454 , 7 + 454 , 7 @ @ public class Table <nl> return columnFamilyStores _ ; <nl> } <nl> <nl> - ColumnFamilyStore getColumnFamilyStore ( String cfName ) <nl> + public ColumnFamilyStore getColumnFamilyStore ( String cfName ) <nl> { <nl> return columnFamilyStores _ . get ( cfName ) ; <nl> } <nl> @ @ - 875 , 4 + 875 , 17 @ @ public class Table <nl> long timeTaken = System . currentTimeMillis ( ) - start ; <nl> dbAnalyticsSource _ . updateWriteStatistics ( timeTaken ) ; <nl> } <nl> + <nl> + public Set < String > getApplicationColumnFamilies ( ) <nl> + { <nl> + Set < String > set = new HashSet < String > ( ) ; <nl> + for ( String cfName : getColumnFamilies ( ) ) <nl> + { <nl> + if ( DatabaseDescriptor . isApplicationColumnFamily ( cfName ) ) <nl> + { <nl> + set . add ( cfName ) ; <nl> + } <nl> + } <nl> + return set ; <nl> + } <nl> } <nl> diff - - git a / src / org / apache / cassandra / service / CassandraServer . java b / src / org / apache / cassandra / service / CassandraServer . java <nl> index 93b62e7 . . c2d5f66 100644 <nl> - - - a / src / org / apache / cassandra / service / CassandraServer . java <nl> + + + b / src / org / apache / cassandra / service / CassandraServer . java <nl> @ @ - 817 , 6 + 817 , 71 @ @ public class CassandraServer extends FacebookBase implements <nl> return result ; <nl> } <nl> <nl> + public List < String > get _ range ( String tablename , final String startkey ) throws CassandraException <nl> + { <nl> + logger _ . debug ( " get _ range " ) ; <nl> + <nl> + / / send request <nl> + Message message ; <nl> + DataOutputBuffer dob = new DataOutputBuffer ( ) ; <nl> + try <nl> + { <nl> + dob . writeUTF ( startkey ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + logger _ . error ( " unable to write startkey " , e ) ; <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + byte [ ] messageBody = Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ; <nl> + message = new Message ( StorageService . getLocalStorageEndPoint ( ) , <nl> + StorageService . readStage _ , <nl> + StorageService . rangeVerbHandler _ , <nl> + messageBody ) ; <nl> + EndPoint endPoint ; <nl> + try <nl> + { <nl> + endPoint = StorageService . instance ( ) . findSuitableEndPoint ( startkey ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new CassandraException ( " Unable to find endpoint for " + startkey ) ; <nl> + } <nl> + IAsyncResult iar = MessagingService . getMessagingInstance ( ) . sendRR ( message , endPoint ) ; <nl> + <nl> + / / read response <nl> + / / TODO send more requests if we need to span multiple nodes ( or can we just let client worry about that , <nl> + / / since they have to handle multiple requests anyway ? ) <nl> + byte [ ] responseBody ; <nl> + try <nl> + { <nl> + responseBody = ( byte [ ] ) iar . get ( 2 * DatabaseDescriptor . getRpcTimeout ( ) , TimeUnit . MILLISECONDS ) [ 0 ] ; <nl> + } <nl> + catch ( TimeoutException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + DataInputBuffer bufIn = new DataInputBuffer ( ) ; <nl> + bufIn . reset ( responseBody , responseBody . length ) ; <nl> + <nl> + / / turn into List <nl> + List < String > keys = new ArrayList < String > ( ) ; <nl> + while ( bufIn . getPosition ( ) < responseBody . length ) <nl> + { <nl> + try <nl> + { <nl> + keys . add ( bufIn . readUTF ( ) ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + logger _ . error ( " bad utf " , e ) ; <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + return keys ; <nl> + } <nl> + <nl> / * <nl> * This method is used to ensure that all keys <nl> * prior to the specified key , as dtermined by <nl> diff - - git a / src / org / apache / cassandra / service / RangeVerbHandler . java b / src / org / apache / cassandra / service / RangeVerbHandler . java <nl> new file mode 100644 <nl> index 0000000 . . 3587907 <nl> - - - / dev / null <nl> + + + b / src / org / apache / cassandra / service / RangeVerbHandler . java <nl> @ @ - 0 , 0 + 1 , 152 @ @ <nl> + package org . apache . cassandra . service ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + import java . util . Iterator ; <nl> + import java . util . Comparator ; <nl> + import java . util . Arrays ; <nl> + import java . io . FileNotFoundException ; <nl> + import java . io . IOException ; <nl> + <nl> + import org . apache . commons . collections . IteratorUtils ; <nl> + import org . apache . commons . collections . Predicate ; <nl> + <nl> + import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . net . IVerbHandler ; <nl> + import org . apache . cassandra . net . Message ; <nl> + import org . apache . cassandra . db . IdentityFilter ; <nl> + import org . apache . cassandra . db . ColumnFamily ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . FileStruct ; <nl> + import org . apache . cassandra . db . Table ; <nl> + import org . apache . cassandra . db . Memtable ; <nl> + import org . apache . cassandra . db . MemtableManager ; <nl> + import org . apache . cassandra . io . SequenceFile ; <nl> + import org . apache . cassandra . io . DataInputBuffer ; <nl> + import org . apache . cassandra . io . DataOutputBuffer ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + <nl> + public class RangeVerbHandler implements IVerbHandler <nl> + { <nl> + public static final Comparator < String > STRING _ COMPARATOR = new Comparator < String > ( ) <nl> + { <nl> + public int compare ( String o1 , String o2 ) <nl> + { <nl> + return o1 . compareTo ( o2 ) ; <nl> + } <nl> + } ; <nl> + <nl> + public void doVerb ( Message message ) <nl> + { <nl> + byte [ ] bytes = ( byte [ ] ) message . getMessageBody ( ) [ 0 ] ; <nl> + final String startkey ; <nl> + if ( bytes . length = = 0 ) <nl> + { <nl> + startkey = " " ; <nl> + } <nl> + else <nl> + { <nl> + DataInputBuffer dib = new DataInputBuffer ( ) ; <nl> + dib . reset ( bytes , bytes . length ) ; <nl> + try <nl> + { <nl> + startkey = dib . readUTF ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + List < Iterator < String > > iterators = new ArrayList < Iterator < String > > ( ) ; <nl> + Table table = Table . open ( DatabaseDescriptor . getTableName ( ) ) ; <nl> + for ( String cfName : table . getApplicationColumnFamilies ( ) ) <nl> + { <nl> + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; <nl> + <nl> + / / memtable keys : current and historical <nl> + Iterator < Memtable > it = ( Iterator < Memtable > ) IteratorUtils . chainedIterator ( <nl> + IteratorUtils . singletonIterator ( cfs . getMemtable ( ) ) , <nl> + MemtableManager . instance ( ) . getUnflushedMemtables ( cfName ) . iterator ( ) ) ; <nl> + while ( it . hasNext ( ) ) <nl> + { <nl> + iterators . add ( IteratorUtils . filteredIterator ( it . next ( ) . sortedKeyIterator ( ) , new Predicate ( ) <nl> + { <nl> + public boolean evaluate ( Object key ) <nl> + { <nl> + return ( ( String ) key ) . compareTo ( startkey ) > = 0 ; <nl> + } <nl> + } ) ) ; <nl> + } <nl> + <nl> + / / sstables <nl> + for ( String filename : cfs . getSSTableFilenames ( ) ) <nl> + { <nl> + try <nl> + { <nl> + FileStruct fs = new FileStruct ( SequenceFile . reader ( filename ) ) ; <nl> + fs . seekTo ( startkey ) ; <nl> + iterators . add ( fs . iterator ( ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + Iterator < String > iter = IteratorUtils . collatedIterator ( STRING _ COMPARATOR , iterators ) ; <nl> + List < String > keys = new ArrayList < String > ( ) ; <nl> + String last = null , current = null ; <nl> + <nl> + while ( keys . size ( ) < 1000 ) <nl> + { <nl> + if ( ! iter . hasNext ( ) ) <nl> + { <nl> + break ; <nl> + } <nl> + current = iter . next ( ) ; <nl> + if ( ! current . equals ( last ) ) <nl> + { <nl> + last = current ; <nl> + for ( String cfName : table . getApplicationColumnFamilies ( ) ) <nl> + { <nl> + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; <nl> + try <nl> + { <nl> + ColumnFamily cf = cfs . getColumnFamily ( current , cfName , new IdentityFilter ( ) ) ; <nl> + if ( cf ! = null & & cf . getColumns ( ) . size ( ) > 0 ) <nl> + { <nl> + keys . add ( current ) ; <nl> + break ; <nl> + } <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + DataOutputBuffer dob = new DataOutputBuffer ( ) ; <nl> + for ( String key : keys ) <nl> + { <nl> + try <nl> + { <nl> + dob . writeUTF ( key ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + byte [ ] data = Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ; <nl> + Message response = message . getReply ( StorageService . getLocalStorageEndPoint ( ) , data ) ; <nl> + MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; <nl> + } <nl> + } <nl> diff - - git a / src / org / apache / cassandra / service / StorageService . java b / src / org / apache / cassandra / service / StorageService . java <nl> index 409cd5f . . 95de5c6 100644 <nl> - - - a / src / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / org / apache / cassandra / service / StorageService . java <nl> @ @ - 138 , 6 + 138 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> public final static String bsMetadataVerbHandler _ = " BS - METADATA - VERB - HANDLER " ; <nl> public final static String calloutDeployVerbHandler _ = " CALLOUT - DEPLOY - VERB - HANDLER " ; <nl> public final static String touchVerbHandler _ = " TOUCH - VERB - HANDLER " ; <nl> + public static String rangeVerbHandler _ = " RANGE - VERB - HANDLER " ; <nl> <nl> public static enum ConsistencyLevel <nl> { <nl> diff - - git a / src / org / apache / cassandra / utils / DestructivePQIterator . java b / src / org / apache / cassandra / utils / DestructivePQIterator . java <nl> new file mode 100644 <nl> index 0000000 . . 0ed96f8 <nl> - - - / dev / null <nl> + + + b / src / org / apache / cassandra / utils / DestructivePQIterator . java <nl> @ @ - 0 , 0 + 1 , 25 @ @ <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . Iterator ; <nl> + import java . util . PriorityQueue ; <nl> + <nl> + public class DestructivePQIterator < T > implements Iterator < T > { <nl> + private PriorityQueue < T > pq ; <nl> + <nl> + public DestructivePQIterator ( PriorityQueue < T > pq ) { <nl> + this . pq = pq ; <nl> + } <nl> + <nl> + public boolean hasNext ( ) { <nl> + return pq . size ( ) > 0 ; <nl> + } <nl> + <nl> + public T next ( ) { <nl> + return pq . poll ( ) ; <nl> + } <nl> + <nl> + public void remove ( ) { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + } <nl> + <nl> diff - - git a / test / org / apache / cassandra / service / CassandraServerTest . java b / test / org / apache / cassandra / service / CassandraServerTest . java <nl> index 07c7dfe . . 762bbb5 100644 <nl> - - - a / test / org / apache / cassandra / service / CassandraServerTest . java <nl> + + + b / test / org / apache / cassandra / service / CassandraServerTest . java <nl> @ @ - 9 , 8 + 9 , 50 @ @ import org . testng . annotations . Test ; <nl> import java . io . IOException ; <nl> import java . util . * ; <nl> <nl> + import com . facebook . thrift . TException ; <nl> + <nl> public class CassandraServerTest extends ServerTest { <nl> / * <nl> + TODO fix resetting server so this works <nl> + @ Test <nl> + public void test _ get _ range _ empty ( ) throws IOException , TException { <nl> + CassandraServer server = new CassandraServer ( ) ; <nl> + server . start ( ) ; <nl> + <nl> + assert CollectionUtils . EMPTY _ COLLECTION . equals ( server . get _ range ( DatabaseDescriptor . getTableName ( ) , " " ) ) ; <nl> + } <nl> + * / <nl> + <nl> + / * <nl> + @ Test <nl> + public void test _ get _ range ( ) throws IOException , TException , CassandraException <nl> + { <nl> + CassandraServer server = new CassandraServer ( ) ; <nl> + try <nl> + { <nl> + server . start ( ) ; <nl> + } <nl> + catch ( Throwable throwable ) <nl> + { <nl> + throw new RuntimeException ( throwable ) ; <nl> + } <nl> + <nl> + / / TODO insert some data <nl> + try { <nl> + String last = null ; <nl> + for ( String key : server . get _ range ( DatabaseDescriptor . getTableName ( ) , " key1 " ) ) { <nl> + if ( last ! = null ) { <nl> + assert last . compareTo ( key ) < 0 ; <nl> + } <nl> + last = key ; <nl> + } <nl> + } finally { <nl> + server . shutdown ( ) ; <nl> + } <nl> + } <nl> + * / <nl> + <nl> + / * <nl> @ Test <nl> public void test _ get _ column ( ) throws Throwable { <nl> CassandraServer server = new CassandraServer ( ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a7cc872 . . 8e0dead 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 26 , 6 + 26 , 7 @ @ 
 * Fix IllegalArgumentException in CqlStorage ( CASSANDRA - 7287 ) 
 * Allow nulls / non - existant fields in UDT ( CASSANDRA - 7206 ) 
 * Backport Thrift MultiSliceRequest ( CASSANDRA - 7027 ) 
 + * Handle overlapping MultiSlices ( CASSANDRA - 7279 ) 
 Merged from 2 . 0 : 
 * Copy compaction options to make sure they are reloaded ( CASSANDRA - 7290 ) 
 * Add option to do more aggressive tombstone compactions ( CASSANDRA - 6563 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java 
 index b06b2ee . . 8b5a403 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java 
 @ @ - 98 , 6 + 98 , 7 @ @ public class CQL3CasConditions implements CASConditions 
 slices [ i + + ] = prefix . slice ( ) ; 
 
 int toGroup = cfm . comparator . isDense ( ) ? - 1 : cfm . clusteringColumns ( ) . size ( ) ; 
 + assert ColumnSlice . validateSlices ( slices , cfm . comparator , false ) ; 
 return new SliceQueryFilter ( slices , false , slices . length , toGroup ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 501ef45 . . d484c5f 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 533 , 6 + 533 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 
 private SliceQueryFilter sliceFilter ( ColumnSlice [ ] slices , int limit , int toGroup ) 
 { 
 + assert ColumnSlice . validateSlices ( slices , cfm . comparator , isReversed ) : String . format ( " Invalid slices : " + Arrays . toString ( slices ) + ( isReversed ? " ( reversed ) " : " " ) ) ; 
 return new SliceQueryFilter ( slices , isReversed , limit , toGroup ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / composites / AbstractCType . java b / src / java / org / apache / cassandra / db / composites / AbstractCType . java 
 index 0e73397 . . e299e42 100644 
 - - - a / src / java / org / apache / cassandra / db / composites / AbstractCType . java 
 + + + b / src / java / org / apache / cassandra / db / composites / AbstractCType . java 
 @ @ - 60 , 6 + 60 , 11 @ @ public abstract class AbstractCType implements CType 
 { 
 public int compare ( Composite c1 , Composite c2 ) 
 { 
 + if ( c1 . isEmpty ( ) ) 
 + return c2 . isEmpty ( ) ? 0 : - 1 ; 
 + if ( c2 . isEmpty ( ) ) 
 + return 1 ; 
 + 
 return AbstractCType . this . compare ( c2 , c1 ) ; 
 } 
 } ; 
 diff - - git a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 index a945114 . . bca4743 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 + + + b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 @ @ - 19 , 6 + 19 , 8 @ @ package org . apache . cassandra . db . filter ; 
 
 import java . io . * ; 
 import java . nio . ByteBuffer ; 
 + import java . util . ArrayList ; 
 + import java . util . Arrays ; 
 import java . util . Comparator ; 
 import java . util . List ; 
 
 @ @ - 108 , 6 + 110 , 101 @ @ public class ColumnSlice 
 return 0 ; 
 } 
 
 + / * * 
 + * Validates that the provided slice array contains only non - overlapped slices valid for a query { @ code reversed } 
 + * or not on a table using { @ code comparator } . 
 + * / 
 + public static boolean validateSlices ( ColumnSlice [ ] slices , CellNameType comparator , boolean reversed ) 
 + { 
 + return validateSlices ( slices , reversed ? comparator . reverseComparator ( ) : comparator ) ; 
 + } 
 + 
 + / * * 
 + * Validates that the provided slice array contains only non - overlapped slices in { @ code comparator } order . 
 + * / 
 + public static boolean validateSlices ( ColumnSlice [ ] slices , Comparator < Composite > comparator ) 
 + { 
 + for ( int i = 0 ; i < slices . length ; i + + ) 
 + { 
 + if ( i > 0 & & comparator . compare ( slices [ i - 1 ] . finish , slices [ i ] . start ) > = 0 ) 
 + return false ; 
 + 
 + if ( slices [ i ] . finish . isEmpty ( ) ) 
 + return i = = slices . length - 1 ; 
 + 
 + if ( comparator . compare ( slices [ i ] . start , slices [ i ] . finish ) > 0 ) 
 + return false ; 
 + } 
 + return true ; 
 + } 
 + 
 + / * * 
 + * Takes an array of slices ( potentially overlapping and in any order , though each individual slice must have 
 + * its start before or equal its end in { @ code comparator } orde ) and return an equivalent array of non - overlapping 
 + * slices in { @ code comparator order } . 
 + * 
 + * @ param slices an array of slices . This may be modified by this method . 
 + * @ param comparator the order in which to sort the slices . 
 + * @ return the smallest possible array of non - overlapping slices in { @ code compator } order . If the original 
 + * slices are already non - overlapping and in comparator order , this may or may not return the provided slices 
 + * directly . 
 + * / 
 + public static ColumnSlice [ ] deoverlapSlices ( ColumnSlice [ ] slices , final Comparator < Composite > comparator ) 
 + { 
 + if ( slices . length < = 1 ) 
 + return slices ; 
 + 
 + Arrays . sort ( slices , new Comparator < ColumnSlice > ( ) 
 + { 
 + @ Override 
 + public int compare ( ColumnSlice s1 , ColumnSlice s2 ) 
 + { 
 + int c = comparator . compare ( s1 . start , s2 . start ) ; 
 + if ( c ! = 0 ) 
 + return c ; 
 + 
 + / / For the finish , empty always means greater 
 + return s1 . finish . isEmpty ( ) | | s2 . finish . isEmpty ( ) 
 + ? s1 . finish . isEmpty ( ) ? 1 : s2 . finish . isEmpty ( ) ? - 1 : 0 
 + : comparator . compare ( s1 . finish , s2 . finish ) ; 
 + } 
 + } ) ; 
 + 
 + List < ColumnSlice > slicesCopy = new ArrayList < > ( slices . length ) ; 
 + 
 + ColumnSlice last = slices [ 0 ] ; 
 + 
 + for ( int i = 1 ; i < slices . length ; i + + ) 
 + { 
 + ColumnSlice s2 = slices [ i ] ; 
 + 
 + boolean includesStart = last . includes ( comparator , s2 . start ) ; 
 + boolean includesFinish = s2 . finish . isEmpty ( ) ? last . finish . isEmpty ( ) : last . includes ( comparator , s2 . finish ) ; 
 + 
 + if ( includesStart & & includesFinish ) 
 + continue ; 
 + 
 + if ( ! includesStart & & ! includesFinish ) 
 + { 
 + slicesCopy . add ( last ) ; 
 + last = s2 ; 
 + continue ; 
 + } 
 + 
 + if ( includesStart ) 
 + { 
 + last = new ColumnSlice ( last . start , s2 . finish ) ; 
 + continue ; 
 + } 
 + 
 + assert ! includesFinish ; 
 + } 
 + 
 + slicesCopy . add ( last ) ; 
 + 
 + return slicesCopy . toArray ( new ColumnSlice [ slicesCopy . size ( ) ] ) ; 
 + } 
 + 
 @ Override 
 public final int hashCode ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / thrift / CassandraServer . java b / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 index 917e4cb . . 1a77ffa 100644 
 - - - a / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 + + + b / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 @ @ - 2065 , 7 + 2065 , 7 @ @ public class CassandraServer implements Cassandra . Iface 
 org . apache . cassandra . db . ConsistencyLevel consistencyLevel = ThriftConversion . fromThrift ( request . getConsistency _ level ( ) ) ; 
 consistencyLevel . validateForRead ( keyspace ) ; 
 List < ReadCommand > commands = new ArrayList < > ( 1 ) ; 
 - ColumnSlice [ ] slices = new ColumnSlice [ request . getColumn _ slices ( ) . size ( ) ] ; 
 + ColumnSlice [ ] slices = new ColumnSlice [ request . getColumn _ slices ( ) . size ( ) ] ; 
 for ( int i = 0 ; i < request . getColumn _ slices ( ) . size ( ) ; i + + ) 
 { 
 fixOptionalSliceParameters ( request . getColumn _ slices ( ) . get ( i ) ) ; 
 @ @ - 2078 , 7 + 2078 , 9 @ @ public class CassandraServer implements Cassandra . Iface 
 throw new InvalidRequestException ( String . format ( " Reversed column slice at index % d had start less than finish " , i ) ) ; 
 slices [ i ] = new ColumnSlice ( start , finish ) ; 
 } 
 - SliceQueryFilter filter = new SliceQueryFilter ( slices , request . reversed , request . count ) ; 
 + 
 + ColumnSlice [ ] deoverlapped = ColumnSlice . deoverlapSlices ( slices , request . reversed ? metadata . comparator . reverseComparator ( ) : metadata . comparator ) ; 
 + SliceQueryFilter filter = new SliceQueryFilter ( deoverlapped , request . reversed , request . count ) ; 
 ThriftValidation . validateKey ( metadata , request . key ) ; 
 commands . add ( ReadCommand . create ( keyspace , request . key , request . column _ parent . getColumn _ family ( ) , System . currentTimeMillis ( ) , filter ) ) ; 
 return getSlice ( commands , request . column _ parent . isSetSuper _ column ( ) , consistencyLevel ) . entrySet ( ) . iterator ( ) . next ( ) . getValue ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java b / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java 
 index 6553de5 . . 2dc3744 100644 
 - - - a / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java 
 + + + b / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java 
 @ @ - 18 , 22 + 18 , 23 @ @ 
 * * / 
 package org . apache . cassandra . db . filter ; 
 
 - import org . apache . cassandra . db . composites . Composite ; 
 - import org . apache . cassandra . db . composites . CompoundDenseCellNameType ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . util . * ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . db . composites . * ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . db . marshal . Int32Type ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 - import org . junit . Test ; 
 
 - import java . nio . ByteBuffer ; 
 - import java . util . ArrayList ; 
 - import java . util . List ; 
 - 
 - import static org . junit . Assert . assertFalse ; 
 - import static org . junit . Assert . assertTrue ; 
 + import static org . junit . Assert . * ; 
 
 public class ColumnSliceTest 
 { 
 + private static final CellNameType simpleIntType = new SimpleDenseCellNameType ( Int32Type . instance ) ; 
 + 
 @ Test 
 public void testIntersectsSingleSlice ( ) 
 { 
 @ @ - 278 , 6 + 279 , 65 @ @ public class ColumnSliceTest 
 assertTrue ( slice . intersects ( columnNames ( 1 , 0 , 0 ) , columnNames ( 2 , 2 , 2 ) , nameType , true ) ) ; 
 } 
 
 + @ Test 
 + public void testDeoverlapSlices ( ) 
 + { 
 + ColumnSlice [ ] slices ; 
 + ColumnSlice [ ] deoverlapped ; 
 + 
 + / / Preserve correct slices 
 + slices = slices ( s ( 0 , 3 ) , s ( 4 , 5 ) , s ( 6 , 9 ) ) ; 
 + assertSlicesValid ( slices ) ; 
 + assertSlicesEquals ( slices , deoverlapSlices ( slices ) ) ; 
 + 
 + / / Simple overlap 
 + slices = slices ( s ( 0 , 3 ) , s ( 2 , 5 ) , s ( 8 , 9 ) ) ; 
 + assertSlicesInvalid ( slices ) ; 
 + assertSlicesEquals ( slices ( s ( 0 , 5 ) , s ( 8 , 9 ) ) , deoverlapSlices ( slices ) ) ; 
 + 
 + / / Slice overlaps others fully 
 + slices = slices ( s ( 0 , 10 ) , s ( 2 , 5 ) , s ( 8 , 9 ) ) ; 
 + assertSlicesInvalid ( slices ) ; 
 + assertSlicesEquals ( slices ( s ( 0 , 10 ) ) , deoverlapSlices ( slices ) ) ; 
 + 
 + / / Slice with empty end overlaps others fully 
 + slices = slices ( s ( 0 , - 1 ) , s ( 2 , 5 ) , s ( 8 , 9 ) ) ; 
 + assertSlicesInvalid ( slices ) ; 
 + assertSlicesEquals ( slices ( s ( 0 , - 1 ) ) , deoverlapSlices ( slices ) ) ; 
 + 
 + / / Overlap with slices selecting only one element 
 + slices = slices ( s ( 0 , 4 ) , s ( 4 , 4 ) , s ( 4 , 8 ) ) ; 
 + assertSlicesInvalid ( slices ) ; 
 + assertSlicesEquals ( slices ( s ( 0 , 8 ) ) , deoverlapSlices ( slices ) ) ; 
 + 
 + / / Unordered slices ( without overlap ) 
 + slices = slices ( s ( 4 , 8 ) , s ( 0 , 3 ) , s ( 9 , 9 ) ) ; 
 + assertSlicesInvalid ( slices ) ; 
 + assertSlicesEquals ( slices ( s ( 0 , 3 ) , s ( 4 , 8 ) , s ( 9 , 9 ) ) , deoverlapSlices ( slices ) ) ; 
 + 
 + / / All range select but not by a single slice 
 + slices = slices ( s ( 5 , - 1 ) , s ( 2 , 5 ) , s ( - 1 , 2 ) ) ; 
 + assertSlicesInvalid ( slices ) ; 
 + assertSlicesEquals ( slices ( s ( - 1 , - 1 ) ) , deoverlapSlices ( slices ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testValidateSlices ( ) 
 + { 
 + assertSlicesValid ( slices ( s ( 0 , 3 ) ) ) ; 
 + assertSlicesValid ( slices ( s ( 3 , 3 ) ) ) ; 
 + assertSlicesValid ( slices ( s ( 3 , 3 ) , s ( 4 , 4 ) ) ) ; 
 + assertSlicesValid ( slices ( s ( 0 , 3 ) , s ( 4 , 5 ) , s ( 6 , 9 ) ) ) ; 
 + assertSlicesValid ( slices ( s ( - 1 , - 1 ) ) ) ; 
 + assertSlicesValid ( slices ( s ( - 1 , 3 ) , s ( 4 , - 1 ) ) ) ; 
 + 
 + assertSlicesInvalid ( slices ( s ( 3 , 0 ) ) ) ; 
 + assertSlicesInvalid ( slices ( s ( 0 , 2 ) , s ( 2 , 4 ) ) ) ; 
 + assertSlicesInvalid ( slices ( s ( 0 , 2 ) , s ( 1 , 4 ) ) ) ; 
 + assertSlicesInvalid ( slices ( s ( 0 , 2 ) , s ( 3 , 4 ) , s ( 3 , 4 ) ) ) ; 
 + assertSlicesInvalid ( slices ( s ( - 1 , 2 ) , s ( 3 , - 1 ) , s ( 5 , 9 ) ) ) ; 
 + } 
 + 
 private static Composite composite ( Integer . . . components ) 
 { 
 List < AbstractType < ? > > types = new ArrayList < > ( ) ; 
 @ @ - 295 , 4 + 355 , 61 @ @ public class ColumnSliceTest 
 names . add ( ByteBufferUtil . bytes ( component ) ) ; 
 return names ; 
 } 
 - } 
 \ No newline at end of file 
 + 
 + private static Composite simpleComposite ( int i ) 
 + { 
 + / / We special negative values to mean EMPTY for convenience sake 
 + if ( i < 0 ) 
 + return Composites . EMPTY ; 
 + 
 + return simpleIntType . make ( i ) ; 
 + } 
 + 
 + private static ColumnSlice s ( int start , int finish ) 
 + { 
 + return new ColumnSlice ( simpleComposite ( start ) , simpleComposite ( finish ) ) ; 
 + } 
 + 
 + private static ColumnSlice [ ] slices ( ColumnSlice . . . slices ) 
 + { 
 + return slices ; 
 + } 
 + 
 + private static ColumnSlice [ ] deoverlapSlices ( ColumnSlice [ ] slices ) 
 + { 
 + return ColumnSlice . deoverlapSlices ( slices , simpleIntType ) ; 
 + } 
 + 
 + private static void assertSlicesValid ( ColumnSlice [ ] slices ) 
 + { 
 + assertTrue ( " Slices " + toString ( slices ) + " should be valid " , ColumnSlice . validateSlices ( slices , simpleIntType ) ) ; 
 + } 
 + 
 + private static void assertSlicesInvalid ( ColumnSlice [ ] slices ) 
 + { 
 + assertFalse ( " Slices " + toString ( slices ) + " shouldn ' t be valid " , ColumnSlice . validateSlices ( slices , simpleIntType ) ) ; 
 + } 
 + 
 + private static void assertSlicesEquals ( ColumnSlice [ ] expected , ColumnSlice [ ] actual ) 
 + { 
 + assertTrue ( " Expected " + toString ( expected ) + " but got " + toString ( actual ) , Arrays . equals ( expected , actual ) ) ; 
 + } 
 + 
 + private static String toString ( ColumnSlice [ ] slices ) 
 + { 
 + StringBuilder sb = new StringBuilder ( ) . append ( " [ " ) ; 
 + for ( int i = 0 ; i < slices . length ; i + + ) 
 + { 
 + if ( i > 0 ) 
 + sb . append ( " , " ) ; 
 + 
 + ColumnSlice slice = slices [ i ] ; 
 + sb . append ( " ( " ) ; 
 + sb . append ( slice . start . isEmpty ( ) ? " - 1 " : simpleIntType . getString ( slice . start ) ) ; 
 + sb . append ( " , " ) ; 
 + sb . append ( slice . finish . isEmpty ( ) ? " - 1 " : simpleIntType . getString ( slice . finish ) ) ; 
 + sb . append ( " ) " ) ; 
 + } 
 + return sb . append ( " ] " ) . toString ( ) ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / thrift / MultiSliceTest . java b / test / unit / org / apache / cassandra / thrift / MultiSliceTest . java 
 index d1c913b . . 9193258 100644 
 - - - a / test / unit / org / apache / cassandra / thrift / MultiSliceTest . java 
 + + + b / test / unit / org / apache / cassandra / thrift / MultiSliceTest . java 
 @ @ - 114 , 9 + 114 , 21 @ @ public class MultiSliceTest extends SchemaLoader 
 req . setCount ( 6 ) ; 
 req . reversed = true ; 
 req . setColumn _ slices ( Arrays . asList ( columnSliceFrom ( " e " , " a " ) , columnSliceFrom ( " g " , " d " ) ) ) ; 
 - assertColumnNameMatches ( Arrays . asList ( " g " , " e " , " d " , " c " , " b " , " a " ) , server . get _ multi _ slice ( req ) ) ; 
 + assertColumnNameMatches ( Arrays . asList ( " g " , " f " , " e " , " d " , " c " , " b " ) , server . get _ multi _ slice ( req ) ) ; 
 } 
 - 
 + 
 + @ Test 
 + public void test _ with _ overlap _ with _ count ( ) throws TException 
 + { 
 + ColumnParent cp = new ColumnParent ( " Standard1 " ) ; 
 + ByteBuffer key = ByteBuffer . wrap ( " overlap _ reversed _ count " . getBytes ( ) ) ; 
 + addTheAlphabetToRow ( key , cp ) ; 
 + MultiSliceRequest req = makeMultiSliceRequest ( key ) ; 
 + req . setCount ( 6 ) ; 
 + req . setColumn _ slices ( Arrays . asList ( columnSliceFrom ( " a " , " e " ) , columnSliceFrom ( " d " , " g " ) , columnSliceFrom ( " d " , " g " ) ) ) ; 
 + assertColumnNameMatches ( Arrays . asList ( " a " , " b " , " c " , " d " , " e " , " f " ) , server . get _ multi _ slice ( req ) ) ; 
 + } 
 + 
 private static void addTheAlphabetToRow ( ByteBuffer key , ColumnParent parent ) 
 throws InvalidRequestException , UnavailableException , TimedOutException 
 { 
 @ @ - 135 , 7 + 147 , 7 @ @ public class MultiSliceTest extends SchemaLoader 
 for ( int i = 0 ; i < expected . size ( ) ; i + + ) 
 { 
 Assert . assertEquals ( actual . get ( i ) + " did not equal " + expected . get ( i ) , 
 - new String ( actual . get ( i ) . getColumn ( ) . getName ( ) ) , expected . get ( i ) ) ; 
 + expected . get ( i ) , new String ( actual . get ( i ) . getColumn ( ) . getName ( ) ) ) ; 
 } 
 } 
 
 @ @ - 146 , 4 + 158 , 4 @ @ public class MultiSliceTest extends SchemaLoader 
 cs . setFinish ( ByteBufferUtil . bytes ( endInclusive ) ) ; 
 return cs ; 
 } 
 - } 
 \ No newline at end of file 
 + }

NEAREST DIFF:
diff - - git a / src / org / apache / cassandra / config / DatabaseDescriptor . java b / src / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 683009c . . 73cf3a6 100644 
 - - - a / src / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 18 , 21 + 18 , 24 @ @ 
 
 package org . apache . cassandra . config ; 
 
 - import java . util . * ; 
 + import java . io . File ; 
 + import java . io . IOException ; 
 + import java . util . ArrayList ; 
 + import java . util . HashMap ; 
 + import java . util . HashSet ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 - import java . io . * ; 
 
 import org . apache . cassandra . db . ColumnFamily ; 
 + import org . apache . cassandra . db . SystemTable ; 
 import org . apache . cassandra . db . Table ; 
 import org . apache . cassandra . db . TypeInfo ; 
 - import org . apache . cassandra . db . DBManager ; 
 - import org . apache . cassandra . db . SystemTable ; 
 - import org . apache . cassandra . db . Table . TableMetadata ; 
 import org . apache . cassandra . utils . FileUtils ; 
 import org . apache . cassandra . utils . XMLUtils ; 
 import org . w3c . dom . Node ; 
 import org . w3c . dom . NodeList ; 
 - import org . apache . cassandra . io . * ; 
 
 
 / * * 
 @ @ - 306 , 6 + 309 , 9 @ @ public class DatabaseDescriptor 
 / * Read the table related stuff from config * / 
 NodeList tables = xmlUtils . getRequestedNodeList ( " / Storage / Tables / Table " ) ; 
 int size = tables . getLength ( ) ; 
 + if ( size = = 0 ) { 
 + throw new UnsupportedOperationException ( " A Table must be configured " ) ; 
 + } 
 for ( int i = 0 ; i < size ; + + i ) 
 { 
 Node table = tables . item ( i ) ; 
 @ @ - 785 , 4 + 791 , 9 @ @ public class DatabaseDescriptor 
 { 
 return tableToCFMetaDataMap _ ; 
 } 
 + 
 + public static String getTableName ( ) 
 + { 
 + return tables _ . get ( 0 ) ; 
 + } 
 } 
 diff - - git a / src / org / apache / cassandra / db / ColumnFamily . java b / src / org / apache / cassandra / db / ColumnFamily . java 
 index 51ac744 . . a2ac3a2 100644 
 - - - a / src / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 288 , 7 + 288 , 7 @ @ public final class ColumnFamily 
 return columns _ . getSortedColumns ( ) ; 
 } 
 
 - Map < String , IColumn > getColumns ( ) 
 + public Map < String , IColumn > getColumns ( ) 
 { 
 return columns _ . getColumns ( ) ; 
 } 
 diff - - git a / src / org / apache / cassandra / db / ColumnFamilyStore . java b / src / org / apache / cassandra / db / ColumnFamilyStore . java 
 index be7c245 . . 28bb3f7 100644 
 - - - a / src / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1384 , 4 + 1384 , 14 @ @ public class ColumnFamilyStore 
 { 
 memtable _ . get ( ) . flushOnRecovery ( ) ; 
 } 
 + 
 + public Object getMemtable ( ) 
 + { 
 + return memtable _ . get ( ) ; 
 + } 
 + 
 + public Set < String > getSSTableFilenames ( ) 
 + { 
 + return Collections . unmodifiableSet ( ssTables _ ) ; 
 + } 
 } 
 diff - - git a / src / org / apache / cassandra / db / Memtable . java b / src / org / apache / cassandra / db / Memtable . java 
 index 2bdad37 . . 567b829 100644 
 - - - a / src / org / apache / cassandra / db / Memtable . java 
 + + + b / src / org / apache / cassandra / db / Memtable . java 
 @ @ - 26 , 6 + 26 , 8 @ @ import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 import java . util . Set ; 
 + import java . util . Iterator ; 
 + import java . util . PriorityQueue ; 
 import java . util . concurrent . Callable ; 
 import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . ExecutorService ; 
 @ @ - 45 , 6 + 47 , 7 @ @ import org . apache . cassandra . io . DataOutputBuffer ; 
 import org . apache . cassandra . io . SSTable ; 
 import org . apache . cassandra . utils . BloomFilter ; 
 import org . apache . cassandra . utils . LogUtil ; 
 + import org . apache . cassandra . utils . DestructivePQIterator ; 
 
 / * * 
 * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) 
 @ @ - 419 , 4 + 422 , 9 @ @ public class Memtable implements MemtableMBean , Comparable < Memtable > 
 columnFamilies _ . clear ( ) ; 
 } 
 
 + public Iterator < String > sortedKeyIterator ( ) 
 + { 
 + return new DestructivePQIterator < String > ( new PriorityQueue < String > ( columnFamilies _ . keySet ( ) ) ) ; 
 + } 
 + 
 } 
 diff - - git a / src / org / apache / cassandra / db / MemtableManager . java b / src / org / apache / cassandra / db / MemtableManager . java 
 index 997bbd3 . . 54242d1 100644 
 - - - a / src / org / apache / cassandra / db / MemtableManager . java 
 + + + b / src / org / apache / cassandra / db / MemtableManager . java 
 @ @ - 40 , 7 + 40 , 7 @ @ public class MemtableManager 
 private static Lock lock _ = new ReentrantLock ( ) ; 
 private static Logger logger _ = Logger . getLogger ( MemtableManager . class ) ; 
 private ReentrantReadWriteLock rwLock _ = new ReentrantReadWriteLock ( true ) ; 
 - static MemtableManager instance ( ) 
 + public static MemtableManager instance ( ) 
 { 
 if ( instance _ = = null ) 
 { 
 @ @ - 157 , 7 + 157 , 22 @ @ public class MemtableManager 
 	 } 
 } 
 
 - 
 - 
 + public List < Memtable > getUnflushedMemtables ( String cfName ) 
 + { 
 + rwLock _ . readLock ( ) . lock ( ) ; 
 + try 
 + { 
 + List < Memtable > memtables = history _ . get ( cfName ) ; 
 + if ( memtables ! = null ) 
 + { 
 + return new ArrayList < Memtable > ( memtables ) ; 
 + } 
 + return Arrays . asList ( new Memtable [ 0 ] ) ; 
 + } 
 + finally 
 + { 
 + rwLock _ . readLock ( ) . unlock ( ) ; 
 + } 
 + } 
 
 } 
 diff - - git a / src / org / apache / cassandra / db / Table . java b / src / org / apache / cassandra / db / Table . java 
 index 9c84b42 . . f1b260a 100644 
 - - - a / src / org / apache / cassandra / db / Table . java 
 + + + b / src / org / apache / cassandra / db / Table . java 
 @ @ - 60 , 7 + 60 , 7 @ @ public class Table 
 * is basically the column family name and the ID associated with 
 * this column family . We use this ID in the Commit Log header to 
 * determine when a log file that has been rolled can be deleted . 
 - * / 
 + * / 
 public static class TableMetadata 
 { 
 / * Name of the column family * / 
 @ @ - 454 , 7 + 454 , 7 @ @ public class Table 
 return columnFamilyStores _ ; 
 } 
 
 - ColumnFamilyStore getColumnFamilyStore ( String cfName ) 
 + public ColumnFamilyStore getColumnFamilyStore ( String cfName ) 
 { 
 return columnFamilyStores _ . get ( cfName ) ; 
 } 
 @ @ - 875 , 4 + 875 , 17 @ @ public class Table 
 long timeTaken = System . currentTimeMillis ( ) - start ; 
 dbAnalyticsSource _ . updateWriteStatistics ( timeTaken ) ; 
 } 
 + 
 + public Set < String > getApplicationColumnFamilies ( ) 
 + { 
 + Set < String > set = new HashSet < String > ( ) ; 
 + for ( String cfName : getColumnFamilies ( ) ) 
 + { 
 + if ( DatabaseDescriptor . isApplicationColumnFamily ( cfName ) ) 
 + { 
 + set . add ( cfName ) ; 
 + } 
 + } 
 + return set ; 
 + } 
 } 
 diff - - git a / src / org / apache / cassandra / service / CassandraServer . java b / src / org / apache / cassandra / service / CassandraServer . java 
 index 93b62e7 . . c2d5f66 100644 
 - - - a / src / org / apache / cassandra / service / CassandraServer . java 
 + + + b / src / org / apache / cassandra / service / CassandraServer . java 
 @ @ - 817 , 6 + 817 , 71 @ @ public class CassandraServer extends FacebookBase implements 
 return result ; 
 } 
 
 + public List < String > get _ range ( String tablename , final String startkey ) throws CassandraException 
 + { 
 + logger _ . debug ( " get _ range " ) ; 
 + 
 + / / send request 
 + Message message ; 
 + DataOutputBuffer dob = new DataOutputBuffer ( ) ; 
 + try 
 + { 
 + dob . writeUTF ( startkey ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + logger _ . error ( " unable to write startkey " , e ) ; 
 + throw new RuntimeException ( e ) ; 
 + } 
 + byte [ ] messageBody = Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ; 
 + message = new Message ( StorageService . getLocalStorageEndPoint ( ) , 
 + StorageService . readStage _ , 
 + StorageService . rangeVerbHandler _ , 
 + messageBody ) ; 
 + EndPoint endPoint ; 
 + try 
 + { 
 + endPoint = StorageService . instance ( ) . findSuitableEndPoint ( startkey ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new CassandraException ( " Unable to find endpoint for " + startkey ) ; 
 + } 
 + IAsyncResult iar = MessagingService . getMessagingInstance ( ) . sendRR ( message , endPoint ) ; 
 + 
 + / / read response 
 + / / TODO send more requests if we need to span multiple nodes ( or can we just let client worry about that , 
 + / / since they have to handle multiple requests anyway ? ) 
 + byte [ ] responseBody ; 
 + try 
 + { 
 + responseBody = ( byte [ ] ) iar . get ( 2 * DatabaseDescriptor . getRpcTimeout ( ) , TimeUnit . MILLISECONDS ) [ 0 ] ; 
 + } 
 + catch ( TimeoutException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + DataInputBuffer bufIn = new DataInputBuffer ( ) ; 
 + bufIn . reset ( responseBody , responseBody . length ) ; 
 + 
 + / / turn into List 
 + List < String > keys = new ArrayList < String > ( ) ; 
 + while ( bufIn . getPosition ( ) < responseBody . length ) 
 + { 
 + try 
 + { 
 + keys . add ( bufIn . readUTF ( ) ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + logger _ . error ( " bad utf " , e ) ; 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + return keys ; 
 + } 
 + 
 / * 
 * This method is used to ensure that all keys 
 * prior to the specified key , as dtermined by 
 diff - - git a / src / org / apache / cassandra / service / RangeVerbHandler . java b / src / org / apache / cassandra / service / RangeVerbHandler . java 
 new file mode 100644 
 index 0000000 . . 3587907 
 - - - / dev / null 
 + + + b / src / org / apache / cassandra / service / RangeVerbHandler . java 
 @ @ - 0 , 0 + 1 , 152 @ @ 
 + package org . apache . cassandra . service ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + import java . util . Iterator ; 
 + import java . util . Comparator ; 
 + import java . util . Arrays ; 
 + import java . io . FileNotFoundException ; 
 + import java . io . IOException ; 
 + 
 + import org . apache . commons . collections . IteratorUtils ; 
 + import org . apache . commons . collections . Predicate ; 
 + 
 + import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . net . IVerbHandler ; 
 + import org . apache . cassandra . net . Message ; 
 + import org . apache . cassandra . db . IdentityFilter ; 
 + import org . apache . cassandra . db . ColumnFamily ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . FileStruct ; 
 + import org . apache . cassandra . db . Table ; 
 + import org . apache . cassandra . db . Memtable ; 
 + import org . apache . cassandra . db . MemtableManager ; 
 + import org . apache . cassandra . io . SequenceFile ; 
 + import org . apache . cassandra . io . DataInputBuffer ; 
 + import org . apache . cassandra . io . DataOutputBuffer ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + 
 + public class RangeVerbHandler implements IVerbHandler 
 + { 
 + public static final Comparator < String > STRING _ COMPARATOR = new Comparator < String > ( ) 
 + { 
 + public int compare ( String o1 , String o2 ) 
 + { 
 + return o1 . compareTo ( o2 ) ; 
 + } 
 + } ; 
 + 
 + public void doVerb ( Message message ) 
 + { 
 + byte [ ] bytes = ( byte [ ] ) message . getMessageBody ( ) [ 0 ] ; 
 + final String startkey ; 
 + if ( bytes . length = = 0 ) 
 + { 
 + startkey = " " ; 
 + } 
 + else 
 + { 
 + DataInputBuffer dib = new DataInputBuffer ( ) ; 
 + dib . reset ( bytes , bytes . length ) ; 
 + try 
 + { 
 + startkey = dib . readUTF ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + List < Iterator < String > > iterators = new ArrayList < Iterator < String > > ( ) ; 
 + Table table = Table . open ( DatabaseDescriptor . getTableName ( ) ) ; 
 + for ( String cfName : table . getApplicationColumnFamilies ( ) ) 
 + { 
 + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; 
 + 
 + / / memtable keys : current and historical 
 + Iterator < Memtable > it = ( Iterator < Memtable > ) IteratorUtils . chainedIterator ( 
 + IteratorUtils . singletonIterator ( cfs . getMemtable ( ) ) , 
 + MemtableManager . instance ( ) . getUnflushedMemtables ( cfName ) . iterator ( ) ) ; 
 + while ( it . hasNext ( ) ) 
 + { 
 + iterators . add ( IteratorUtils . filteredIterator ( it . next ( ) . sortedKeyIterator ( ) , new Predicate ( ) 
 + { 
 + public boolean evaluate ( Object key ) 
 + { 
 + return ( ( String ) key ) . compareTo ( startkey ) > = 0 ; 
 + } 
 + } ) ) ; 
 + } 
 + 
 + / / sstables 
 + for ( String filename : cfs . getSSTableFilenames ( ) ) 
 + { 
 + try 
 + { 
 + FileStruct fs = new FileStruct ( SequenceFile . reader ( filename ) ) ; 
 + fs . seekTo ( startkey ) ; 
 + iterators . add ( fs . iterator ( ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + } 
 + 
 + Iterator < String > iter = IteratorUtils . collatedIterator ( STRING _ COMPARATOR , iterators ) ; 
 + List < String > keys = new ArrayList < String > ( ) ; 
 + String last = null , current = null ; 
 + 
 + while ( keys . size ( ) < 1000 ) 
 + { 
 + if ( ! iter . hasNext ( ) ) 
 + { 
 + break ; 
 + } 
 + current = iter . next ( ) ; 
 + if ( ! current . equals ( last ) ) 
 + { 
 + last = current ; 
 + for ( String cfName : table . getApplicationColumnFamilies ( ) ) 
 + { 
 + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; 
 + try 
 + { 
 + ColumnFamily cf = cfs . getColumnFamily ( current , cfName , new IdentityFilter ( ) ) ; 
 + if ( cf ! = null & & cf . getColumns ( ) . size ( ) > 0 ) 
 + { 
 + keys . add ( current ) ; 
 + break ; 
 + } 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + DataOutputBuffer dob = new DataOutputBuffer ( ) ; 
 + for ( String key : keys ) 
 + { 
 + try 
 + { 
 + dob . writeUTF ( key ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + byte [ ] data = Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ; 
 + Message response = message . getReply ( StorageService . getLocalStorageEndPoint ( ) , data ) ; 
 + MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; 
 + } 
 + } 
 diff - - git a / src / org / apache / cassandra / service / StorageService . java b / src / org / apache / cassandra / service / StorageService . java 
 index 409cd5f . . 95de5c6 100644 
 - - - a / src / org / apache / cassandra / service / StorageService . java 
 + + + b / src / org / apache / cassandra / service / StorageService . java 
 @ @ - 138 , 6 + 138 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 public final static String bsMetadataVerbHandler _ = " BS - METADATA - VERB - HANDLER " ; 
 public final static String calloutDeployVerbHandler _ = " CALLOUT - DEPLOY - VERB - HANDLER " ; 
 public final static String touchVerbHandler _ = " TOUCH - VERB - HANDLER " ; 
 + public static String rangeVerbHandler _ = " RANGE - VERB - HANDLER " ; 
 
 public static enum ConsistencyLevel 
 { 
 diff - - git a / src / org / apache / cassandra / utils / DestructivePQIterator . java b / src / org / apache / cassandra / utils / DestructivePQIterator . java 
 new file mode 100644 
 index 0000000 . . 0ed96f8 
 - - - / dev / null 
 + + + b / src / org / apache / cassandra / utils / DestructivePQIterator . java 
 @ @ - 0 , 0 + 1 , 25 @ @ 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . Iterator ; 
 + import java . util . PriorityQueue ; 
 + 
 + public class DestructivePQIterator < T > implements Iterator < T > { 
 + private PriorityQueue < T > pq ; 
 + 
 + public DestructivePQIterator ( PriorityQueue < T > pq ) { 
 + this . pq = pq ; 
 + } 
 + 
 + public boolean hasNext ( ) { 
 + return pq . size ( ) > 0 ; 
 + } 
 + 
 + public T next ( ) { 
 + return pq . poll ( ) ; 
 + } 
 + 
 + public void remove ( ) { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + } 
 + 
 diff - - git a / test / org / apache / cassandra / service / CassandraServerTest . java b / test / org / apache / cassandra / service / CassandraServerTest . java 
 index 07c7dfe . . 762bbb5 100644 
 - - - a / test / org / apache / cassandra / service / CassandraServerTest . java 
 + + + b / test / org / apache / cassandra / service / CassandraServerTest . java 
 @ @ - 9 , 8 + 9 , 50 @ @ import org . testng . annotations . Test ; 
 import java . io . IOException ; 
 import java . util . * ; 
 
 + import com . facebook . thrift . TException ; 
 + 
 public class CassandraServerTest extends ServerTest { 
 / * 
 + TODO fix resetting server so this works 
 + @ Test 
 + public void test _ get _ range _ empty ( ) throws IOException , TException { 
 + CassandraServer server = new CassandraServer ( ) ; 
 + server . start ( ) ; 
 + 
 + assert CollectionUtils . EMPTY _ COLLECTION . equals ( server . get _ range ( DatabaseDescriptor . getTableName ( ) , " " ) ) ; 
 + } 
 + * / 
 + 
 + / * 
 + @ Test 
 + public void test _ get _ range ( ) throws IOException , TException , CassandraException 
 + { 
 + CassandraServer server = new CassandraServer ( ) ; 
 + try 
 + { 
 + server . start ( ) ; 
 + } 
 + catch ( Throwable throwable ) 
 + { 
 + throw new RuntimeException ( throwable ) ; 
 + } 
 + 
 + / / TODO insert some data 
 + try { 
 + String last = null ; 
 + for ( String key : server . get _ range ( DatabaseDescriptor . getTableName ( ) , " key1 " ) ) { 
 + if ( last ! = null ) { 
 + assert last . compareTo ( key ) < 0 ; 
 + } 
 + last = key ; 
 + } 
 + } finally { 
 + server . shutdown ( ) ; 
 + } 
 + } 
 + * / 
 + 
 + / * 
 @ Test 
 public void test _ get _ column ( ) throws Throwable { 
 CassandraServer server = new CassandraServer ( ) ;
