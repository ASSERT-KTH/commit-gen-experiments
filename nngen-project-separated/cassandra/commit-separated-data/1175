BLEU SCORE: 0.058544976940240155

TEST MSG: Limit size of windows with DTCS
GENERATED MSG: Do size tiered compaction in date tiered compaction windows

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 94a9ae2 . . 66423c7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 12 <nl> + * Limit window size in DTCS ( CASSANDRA - 10280 ) <nl> * sstableloader does not use MAX _ HEAP _ SIZE env parameter ( CASSANDRA - 10188 ) <nl> * ( cqlsh ) Improve COPY TO performance and error handling ( CASSANDRA - 9304 ) <nl> * Don ' t remove level info when running upgradesstables ( CASSANDRA - 10692 ) <nl> diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index 49970e4 . . 38f118f 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 472 , 6 + 472 , 7 @ @ def cf _ prop _ val _ mapkey _ completer ( ctxt , cass ) : <nl> opts . add ( ' max _ sstable _ age _ days ' ) <nl> opts . add ( ' timestamp _ resolution ' ) <nl> opts . add ( ' min _ threshold ' ) <nl> + opts . add ( ' max _ window _ size _ seconds ' ) <nl> return map ( escape _ value , opts ) <nl> return ( ) <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> index ece596f . . ae684ec 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> @ @ - 131 , 7 + 131 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> { <nl> Iterable < SSTableReader > candidates = filterOldSSTables ( Lists . newArrayList ( candidateSSTables ) , options . maxSSTableAge , now ) ; <nl> <nl> - List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndMinTimestampPairs ( candidates ) , options . baseTime , base , now ) ; <nl> + List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndMinTimestampPairs ( candidates ) , options . baseTime , base , now , options . maxWindowSize ) ; <nl> logger . debug ( " Compaction buckets are { } " , buckets ) ; <nl> updateEstimatedCompactionsByTasks ( buckets ) ; <nl> List < SSTableReader > mostInteresting = newestBucket ( buckets , <nl> @ @ - 139 , 6 + 139 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> cfs . getMaximumCompactionThreshold ( ) , <nl> now , <nl> options . baseTime , <nl> + options . maxWindowSize , <nl> stcsOptions ) ; <nl> if ( ! mostInteresting . isEmpty ( ) ) <nl> return mostInteresting ; <nl> @ @ - 217 , 10 + 218 , 13 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> / / A timestamp t hits the target iff t / size = = divPosition . <nl> public final long divPosition ; <nl> <nl> - public Target ( long size , long divPosition ) <nl> + public final long maxWindowSize ; <nl> + <nl> + public Target ( long size , long divPosition , long maxWindowSize ) <nl> { <nl> this . size = size ; <nl> this . divPosition = divPosition ; <nl> + this . maxWindowSize = maxWindowSize ; <nl> } <nl> <nl> / * * <nl> @ @ - 250 , 10 + 254 , 10 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> * / <nl> public Target nextTarget ( int base ) <nl> { <nl> - if ( divPosition % base > 0 ) <nl> - return new Target ( size , divPosition - 1 ) ; <nl> + if ( divPosition % base > 0 | | size * base > maxWindowSize ) <nl> + return new Target ( size , divPosition - 1 , maxWindowSize ) ; <nl> else <nl> - return new Target ( size * base , divPosition / base - 1 ) ; <nl> + return new Target ( size * base , divPosition / base - 1 , maxWindowSize ) ; <nl> } <nl> } <nl> <nl> @ @ - 270 , 7 + 274 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> * Each bucket is also a list of files ordered from newest to oldest . <nl> * / <nl> @ VisibleForTesting <nl> - static < T > List < List < T > > getBuckets ( Collection < Pair < T , Long > > files , long timeUnit , int base , long now ) <nl> + static < T > List < List < T > > getBuckets ( Collection < Pair < T , Long > > files , long timeUnit , int base , long now , long maxWindowSize ) <nl> { <nl> / / Sort files by age . Newest first . <nl> final List < Pair < T , Long > > sortedFiles = Lists . newArrayList ( files ) ; <nl> @ @ - 283 , 7 + 287 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> } ) ) ; <nl> <nl> List < List < T > > buckets = Lists . newArrayList ( ) ; <nl> - Target target = getInitialTarget ( now , timeUnit ) ; <nl> + Target target = getInitialTarget ( now , timeUnit , maxWindowSize ) ; <nl> PeekingIterator < Pair < T , Long > > it = Iterators . peekingIterator ( sortedFiles . iterator ( ) ) ; <nl> <nl> outerLoop : <nl> @ @ - 302 , 7 + 306 , 6 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> else / / If the file is too old for the target , switch targets . <nl> target = target . nextTarget ( base ) ; <nl> } <nl> - <nl> List < T > bucket = Lists . newArrayList ( ) ; <nl> while ( target . onTarget ( it . peek ( ) . right ) ) <nl> { <nl> @ @ - 318 , 9 + 321 , 9 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> } <nl> <nl> @ VisibleForTesting <nl> - static Target getInitialTarget ( long now , long timeUnit ) <nl> + static Target getInitialTarget ( long now , long timeUnit , long maxWindowSize ) <nl> { <nl> - return new Target ( timeUnit , now / timeUnit ) ; <nl> + return new Target ( timeUnit , now / timeUnit , maxWindowSize ) ; <nl> } <nl> <nl> <nl> @ @ - 329 , 8 + 332 , 9 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> int n = 0 ; <nl> for ( List < SSTableReader > bucket : tasks ) <nl> { <nl> - if ( bucket . size ( ) > = cfs . getMinimumCompactionThreshold ( ) ) <nl> - n + = getSTCSBuckets ( bucket , stcsOptions ) . size ( ) ; <nl> + for ( List < SSTableReader > stcsBucket : getSTCSBuckets ( bucket , stcsOptions ) ) <nl> + if ( stcsBucket . size ( ) > = cfs . getMinimumCompactionThreshold ( ) ) <nl> + n + = Math . ceil ( ( double ) stcsBucket . size ( ) / cfs . getMaximumCompactionThreshold ( ) ) ; <nl> } <nl> estimatedRemainingTasks = n ; <nl> } <nl> @ @ - 343 , 12 + 347 , 12 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> * @ return a bucket ( list ) of sstables to compact . <nl> * / <nl> @ VisibleForTesting <nl> - static List < SSTableReader > newestBucket ( List < List < SSTableReader > > buckets , int minThreshold , int maxThreshold , long now , long baseTime , SizeTieredCompactionStrategyOptions stcsOptions ) <nl> + static List < SSTableReader > newestBucket ( List < List < SSTableReader > > buckets , int minThreshold , int maxThreshold , long now , long baseTime , long maxWindowSize , SizeTieredCompactionStrategyOptions stcsOptions ) <nl> { <nl> / / If the " incoming window " has at least minThreshold SSTables , choose that one . <nl> / / For any other bucket , at least 2 SSTables is enough . <nl> / / In any case , limit to maxThreshold SSTables . <nl> - Target incomingWindow = getInitialTarget ( now , baseTime ) ; <nl> + Target incomingWindow = getInitialTarget ( now , baseTime , maxWindowSize ) ; <nl> for ( List < SSTableReader > bucket : buckets ) <nl> { <nl> boolean inFirstWindow = incomingWindow . onTarget ( bucket . get ( 0 ) . getMinTimestamp ( ) ) ; <nl> @ @ - 412 , 7 + 416 , 6 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> return Long . MAX _ VALUE ; <nl> } <nl> <nl> - <nl> public static Map < String , String > validateOptions ( Map < String , String > options ) throws ConfigurationException <nl> { <nl> Map < String , String > uncheckedOptions = AbstractCompactionStrategy . validateOptions ( options ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyOptions . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyOptions . java <nl> index 0cbf90e . . 5803115 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyOptions . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyOptions . java <nl> @ @ - 25 , 17 + 25 , 24 @ @ import org . apache . cassandra . exceptions . ConfigurationException ; <nl> public final class DateTieredCompactionStrategyOptions <nl> { <nl> protected static final TimeUnit DEFAULT _ TIMESTAMP _ RESOLUTION = TimeUnit . MICROSECONDS ; <nl> - protected static final double DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS = 365 ; <nl> + @ Deprecated <nl> + protected static final double DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS = 365 * 1000 ; <nl> protected static final long DEFAULT _ BASE _ TIME _ SECONDS = 60 ; <nl> + protected static final long DEFAULT _ MAX _ WINDOW _ SIZE _ SECONDS = TimeUnit . SECONDS . convert ( 1 , TimeUnit . DAYS ) ; <nl> + <nl> protected static final int DEFAULT _ EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS = 60 * 10 ; <nl> protected static final String TIMESTAMP _ RESOLUTION _ KEY = " timestamp _ resolution " ; <nl> + @ Deprecated <nl> protected static final String MAX _ SSTABLE _ AGE _ KEY = " max _ sstable _ age _ days " ; <nl> protected static final String BASE _ TIME _ KEY = " base _ time _ seconds " ; <nl> protected static final String EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS _ KEY = " expired _ sstable _ check _ frequency _ seconds " ; <nl> + protected static final String MAX _ WINDOW _ SIZE _ KEY = " max _ window _ size _ seconds " ; <nl> <nl> + @ Deprecated <nl> protected final long maxSSTableAge ; <nl> protected final long baseTime ; <nl> protected final long expiredSSTableCheckFrequency ; <nl> + protected final long maxWindowSize ; <nl> <nl> public DateTieredCompactionStrategyOptions ( Map < String , String > options ) <nl> { <nl> @ @ - 48 , 13 + 55 , 16 @ @ public final class DateTieredCompactionStrategyOptions <nl> baseTime = timestampResolution . convert ( optionValue = = null ? DEFAULT _ BASE _ TIME _ SECONDS : Long . parseLong ( optionValue ) , TimeUnit . SECONDS ) ; <nl> optionValue = options . get ( EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS _ KEY ) ; <nl> expiredSSTableCheckFrequency = TimeUnit . MILLISECONDS . convert ( optionValue = = null ? DEFAULT _ EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS : Long . parseLong ( optionValue ) , TimeUnit . SECONDS ) ; <nl> + optionValue = options . get ( MAX _ WINDOW _ SIZE _ KEY ) ; <nl> + maxWindowSize = timestampResolution . convert ( optionValue = = null ? DEFAULT _ MAX _ WINDOW _ SIZE _ SECONDS : Long . parseLong ( optionValue ) , TimeUnit . SECONDS ) ; <nl> } <nl> <nl> public DateTieredCompactionStrategyOptions ( ) <nl> { <nl> - maxSSTableAge = Math . round ( DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS * DEFAULT _ TIMESTAMP _ RESOLUTION . convert ( 1 , TimeUnit . DAYS ) ) ; <nl> + maxSSTableAge = Math . round ( DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS * DEFAULT _ TIMESTAMP _ RESOLUTION . convert ( ( long ) DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS , TimeUnit . DAYS ) ) ; <nl> baseTime = DEFAULT _ TIMESTAMP _ RESOLUTION . convert ( DEFAULT _ BASE _ TIME _ SECONDS , TimeUnit . SECONDS ) ; <nl> expiredSSTableCheckFrequency = TimeUnit . MILLISECONDS . convert ( DEFAULT _ EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS , TimeUnit . SECONDS ) ; <nl> + maxWindowSize = DEFAULT _ TIMESTAMP _ RESOLUTION . convert ( 1 , TimeUnit . DAYS ) ; <nl> } <nl> <nl> public static Map < String , String > validateOptions ( Map < String , String > options , Map < String , String > uncheckedOptions ) throws ConfigurationException <nl> @ @ - 112 , 10 + 122 , 26 @ @ public final class DateTieredCompactionStrategyOptions <nl> throw new ConfigurationException ( String . format ( " % s is not a parsable int ( base10 ) for % s " , optionValue , EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS _ KEY ) , e ) ; <nl> } <nl> <nl> + optionValue = options . get ( MAX _ WINDOW _ SIZE _ KEY ) ; <nl> + try <nl> + { <nl> + long maxWindowSize = optionValue = = null ? DEFAULT _ MAX _ WINDOW _ SIZE _ SECONDS : Long . parseLong ( optionValue ) ; <nl> + if ( maxWindowSize < 0 ) <nl> + { <nl> + throw new ConfigurationException ( String . format ( " % s must not be negative , but was % d " , MAX _ WINDOW _ SIZE _ KEY , maxWindowSize ) ) ; <nl> + } <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new ConfigurationException ( String . format ( " % s is not a parsable int ( base10 ) for % s " , optionValue , MAX _ WINDOW _ SIZE _ KEY ) , e ) ; <nl> + } <nl> + <nl> + <nl> uncheckedOptions . remove ( MAX _ SSTABLE _ AGE _ KEY ) ; <nl> uncheckedOptions . remove ( BASE _ TIME _ KEY ) ; <nl> uncheckedOptions . remove ( TIMESTAMP _ RESOLUTION _ KEY ) ; <nl> uncheckedOptions . remove ( EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS _ KEY ) ; <nl> + uncheckedOptions . remove ( MAX _ WINDOW _ SIZE _ KEY ) ; <nl> <nl> return uncheckedOptions ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyTest . java b / test / unit / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyTest . java <nl> index 368101d . . 5afd575 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyTest . java <nl> @ @ - 88 , 6 + 88 , 17 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> options . put ( DateTieredCompactionStrategyOptions . MAX _ SSTABLE _ AGE _ KEY , " 0 " ) ; <nl> } <nl> <nl> + try <nl> + { <nl> + options . put ( DateTieredCompactionStrategyOptions . MAX _ WINDOW _ SIZE _ KEY , " - 1 " ) ; <nl> + validateOptions ( options ) ; <nl> + fail ( String . format ( " Negative % s should be rejected " , DateTieredCompactionStrategyOptions . MAX _ WINDOW _ SIZE _ KEY ) ) ; <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + options . put ( DateTieredCompactionStrategyOptions . MAX _ WINDOW _ SIZE _ KEY , " 0 " ) ; <nl> + } <nl> + <nl> options . put ( " bad _ option " , " 1 . 0 " ) ; <nl> unvalidated = validateOptions ( options ) ; <nl> assertTrue ( unvalidated . containsKey ( " bad _ option " ) ) ; <nl> @ @ - 101 , 11 + 112 , 11 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP _ RESOLUTION _ KEY , " SECONDS " ) ; <nl> <nl> DateTieredCompactionStrategyOptions opts = new DateTieredCompactionStrategyOptions ( options ) ; <nl> - assertEquals ( opts . maxSSTableAge , TimeUnit . SECONDS . convert ( 365 , TimeUnit . DAYS ) ) ; <nl> + assertEquals ( opts . maxSSTableAge , TimeUnit . SECONDS . convert ( 365 * 1000 , TimeUnit . DAYS ) ) ; <nl> <nl> options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP _ RESOLUTION _ KEY , " MILLISECONDS " ) ; <nl> opts = new DateTieredCompactionStrategyOptions ( options ) ; <nl> - assertEquals ( opts . maxSSTableAge , TimeUnit . MILLISECONDS . convert ( 365 , TimeUnit . DAYS ) ) ; <nl> + assertEquals ( opts . maxSSTableAge , TimeUnit . MILLISECONDS . convert ( 365 * 1000 , TimeUnit . DAYS ) ) ; <nl> <nl> options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP _ RESOLUTION _ KEY , " MICROSECONDS " ) ; <nl> options . put ( DateTieredCompactionStrategyOptions . MAX _ SSTABLE _ AGE _ KEY , " 10 " ) ; <nl> @ @ - 132 , 7 + 143 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> Pair . create ( " a " , 1L ) , <nl> Pair . create ( " b " , 201L ) <nl> ) ; <nl> - List < List < String > > buckets = getBuckets ( pairs , 100L , 2 , 200L ) ; <nl> + List < List < String > > buckets = getBuckets ( pairs , 100L , 2 , 200L , Long . MAX _ VALUE ) ; <nl> assertEquals ( 2 , buckets . size ( ) ) ; <nl> <nl> for ( List < String > bucket : buckets ) <nl> @ @ - 151 , 7 + 162 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> Pair . create ( " b " , 3899L ) , <nl> Pair . create ( " c " , 3900L ) <nl> ) ; <nl> - buckets = getBuckets ( pairs , 100L , 3 , 4050L ) ; <nl> + buckets = getBuckets ( pairs , 100L , 3 , 4050L , Long . MAX _ VALUE ) ; <nl> / / targets ( divPosition , size ) : ( 40 , 100 ) , ( 39 , 100 ) , ( 12 , 300 ) , ( 3 , 900 ) , ( 0 , 2700 ) <nl> / / in other words : 0 - 2699 , 2700 - 3599 , 3600 - 3899 , 3900 - 3999 , 4000 - 4099 <nl> assertEquals ( 3 , buckets . size ( ) ) ; <nl> @ @ - 177 , 7 + 188 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> Pair . create ( " e " , 3950L ) , <nl> Pair . create ( " too new " , 4125L ) <nl> ) ; <nl> - buckets = getBuckets ( pairs , 100L , 1 , 4050L ) ; <nl> + buckets = getBuckets ( pairs , 100L , 1 , 4050L , Long . MAX _ VALUE ) ; <nl> <nl> assertEquals ( 5 , buckets . size ( ) ) ; <nl> <nl> @ @ - 193 , 7 + 204 , 6 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> { <nl> Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; <nl> ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF _ STANDARD1 ) ; <nl> - cfs . truncateBlocking ( ) ; <nl> cfs . disableAutoCompaction ( ) ; <nl> <nl> ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; <nl> @ @ - 212 , 15 + 222 , 16 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> <nl> List < SSTableReader > sstrs = new ArrayList < > ( cfs . getSSTables ( ) ) ; <nl> <nl> - List < SSTableReader > newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( 0 , 2 ) ) , 4 , 32 , 9 , 10 , new SizeTieredCompactionStrategyOptions ( ) ) ; <nl> + List < SSTableReader > newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( 0 , 2 ) ) , 4 , 32 , 9 , 10 , Long . MAX _ VALUE , new SizeTieredCompactionStrategyOptions ( ) ) ; <nl> assertTrue ( " incoming bucket should not be accepted when it has below the min threshold SSTables " , newBucket . isEmpty ( ) ) ; <nl> <nl> - newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( 0 , 2 ) ) , 4 , 32 , 10 , 10 , new SizeTieredCompactionStrategyOptions ( ) ) ; <nl> + newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( 0 , 2 ) ) , 4 , 32 , 10 , 10 , Long . MAX _ VALUE , new SizeTieredCompactionStrategyOptions ( ) ) ; <nl> assertFalse ( " non - incoming bucket should be accepted when it has at least 2 SSTables " , newBucket . isEmpty ( ) ) ; <nl> <nl> assertEquals ( " an sstable with a single value should have equal min / max timestamps " , sstrs . get ( 0 ) . getMinTimestamp ( ) , sstrs . get ( 0 ) . getMaxTimestamp ( ) ) ; <nl> assertEquals ( " an sstable with a single value should have equal min / max timestamps " , sstrs . get ( 1 ) . getMinTimestamp ( ) , sstrs . get ( 1 ) . getMaxTimestamp ( ) ) ; <nl> assertEquals ( " an sstable with a single value should have equal min / max timestamps " , sstrs . get ( 2 ) . getMinTimestamp ( ) , sstrs . get ( 2 ) . getMaxTimestamp ( ) ) ; <nl> + cfs . truncateBlocking ( ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 228 , 7 + 239 , 6 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> { <nl> Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; <nl> ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF _ STANDARD1 ) ; <nl> - cfs . truncateBlocking ( ) ; <nl> cfs . disableAutoCompaction ( ) ; <nl> <nl> ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; <nl> @ @ - 259 , 6 + 269 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> <nl> filtered = filterOldSSTables ( sstrs , 1 , 4 ) ; <nl> assertEquals ( " no sstables should remain when all are too old " , 0 , Iterables . size ( filtered ) ) ; <nl> + cfs . truncateBlocking ( ) ; <nl> } <nl> <nl> <nl> @ @ - 267 , 7 + 278 , 6 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> { <nl> Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; <nl> ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF _ STANDARD1 ) ; <nl> - cfs . truncateBlocking ( ) ; <nl> cfs . disableAutoCompaction ( ) ; <nl> <nl> ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; <nl> @ @ - 305 , 6 + 315 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> SSTableReader sstable = t . sstables . iterator ( ) . next ( ) ; <nl> assertEquals ( sstable , expiredSSTable ) ; <nl> cfs . getDataTracker ( ) . unmarkCompacting ( cfs . getSSTables ( ) ) ; <nl> + cfs . truncateBlocking ( ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 312 , 7 + 323 , 6 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> { <nl> Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; <nl> ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF _ STANDARD1 ) ; <nl> - cfs . truncateBlocking ( ) ; <nl> cfs . disableAutoCompaction ( ) ; <nl> ByteBuffer bigValue = ByteBuffer . wrap ( new byte [ 10000 ] ) ; <nl> ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; <nl> @ @ - 344 , 7 + 354 , 9 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader <nl> DateTieredCompactionStrategy dtcs = new DateTieredCompactionStrategy ( cfs , options ) ; <nl> for ( SSTableReader sstable : cfs . getSSTables ( ) ) <nl> dtcs . addSSTable ( sstable ) ; <nl> - assertEquals ( 20 , dtcs . getNextBackgroundTask ( 0 ) . sstables . size ( ) ) ; <nl> + AbstractCompactionTask task = dtcs . getNextBackgroundTask ( 0 ) ; <nl> + assertEquals ( 20 , task . sstables . size ( ) ) ; <nl> + cfs . getDataTracker ( ) . unmarkCompacting ( task . sstables ) ; <nl> + cfs . truncateBlocking ( ) ; <nl> } <nl> - <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 94a9ae2 . . 66423c7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 12 
 + * Limit window size in DTCS ( CASSANDRA - 10280 ) 
 * sstableloader does not use MAX _ HEAP _ SIZE env parameter ( CASSANDRA - 10188 ) 
 * ( cqlsh ) Improve COPY TO performance and error handling ( CASSANDRA - 9304 ) 
 * Don ' t remove level info when running upgradesstables ( CASSANDRA - 10692 ) 
 diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index 49970e4 . . 38f118f 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 472 , 6 + 472 , 7 @ @ def cf _ prop _ val _ mapkey _ completer ( ctxt , cass ) : 
 opts . add ( ' max _ sstable _ age _ days ' ) 
 opts . add ( ' timestamp _ resolution ' ) 
 opts . add ( ' min _ threshold ' ) 
 + opts . add ( ' max _ window _ size _ seconds ' ) 
 return map ( escape _ value , opts ) 
 return ( ) 
 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 index ece596f . . ae684ec 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 @ @ - 131 , 7 + 131 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 { 
 Iterable < SSTableReader > candidates = filterOldSSTables ( Lists . newArrayList ( candidateSSTables ) , options . maxSSTableAge , now ) ; 
 
 - List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndMinTimestampPairs ( candidates ) , options . baseTime , base , now ) ; 
 + List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndMinTimestampPairs ( candidates ) , options . baseTime , base , now , options . maxWindowSize ) ; 
 logger . debug ( " Compaction buckets are { } " , buckets ) ; 
 updateEstimatedCompactionsByTasks ( buckets ) ; 
 List < SSTableReader > mostInteresting = newestBucket ( buckets , 
 @ @ - 139 , 6 + 139 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 cfs . getMaximumCompactionThreshold ( ) , 
 now , 
 options . baseTime , 
 + options . maxWindowSize , 
 stcsOptions ) ; 
 if ( ! mostInteresting . isEmpty ( ) ) 
 return mostInteresting ; 
 @ @ - 217 , 10 + 218 , 13 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 / / A timestamp t hits the target iff t / size = = divPosition . 
 public final long divPosition ; 
 
 - public Target ( long size , long divPosition ) 
 + public final long maxWindowSize ; 
 + 
 + public Target ( long size , long divPosition , long maxWindowSize ) 
 { 
 this . size = size ; 
 this . divPosition = divPosition ; 
 + this . maxWindowSize = maxWindowSize ; 
 } 
 
 / * * 
 @ @ - 250 , 10 + 254 , 10 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 * / 
 public Target nextTarget ( int base ) 
 { 
 - if ( divPosition % base > 0 ) 
 - return new Target ( size , divPosition - 1 ) ; 
 + if ( divPosition % base > 0 | | size * base > maxWindowSize ) 
 + return new Target ( size , divPosition - 1 , maxWindowSize ) ; 
 else 
 - return new Target ( size * base , divPosition / base - 1 ) ; 
 + return new Target ( size * base , divPosition / base - 1 , maxWindowSize ) ; 
 } 
 } 
 
 @ @ - 270 , 7 + 274 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 * Each bucket is also a list of files ordered from newest to oldest . 
 * / 
 @ VisibleForTesting 
 - static < T > List < List < T > > getBuckets ( Collection < Pair < T , Long > > files , long timeUnit , int base , long now ) 
 + static < T > List < List < T > > getBuckets ( Collection < Pair < T , Long > > files , long timeUnit , int base , long now , long maxWindowSize ) 
 { 
 / / Sort files by age . Newest first . 
 final List < Pair < T , Long > > sortedFiles = Lists . newArrayList ( files ) ; 
 @ @ - 283 , 7 + 287 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 } ) ) ; 
 
 List < List < T > > buckets = Lists . newArrayList ( ) ; 
 - Target target = getInitialTarget ( now , timeUnit ) ; 
 + Target target = getInitialTarget ( now , timeUnit , maxWindowSize ) ; 
 PeekingIterator < Pair < T , Long > > it = Iterators . peekingIterator ( sortedFiles . iterator ( ) ) ; 
 
 outerLoop : 
 @ @ - 302 , 7 + 306 , 6 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 else / / If the file is too old for the target , switch targets . 
 target = target . nextTarget ( base ) ; 
 } 
 - 
 List < T > bucket = Lists . newArrayList ( ) ; 
 while ( target . onTarget ( it . peek ( ) . right ) ) 
 { 
 @ @ - 318 , 9 + 321 , 9 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 } 
 
 @ VisibleForTesting 
 - static Target getInitialTarget ( long now , long timeUnit ) 
 + static Target getInitialTarget ( long now , long timeUnit , long maxWindowSize ) 
 { 
 - return new Target ( timeUnit , now / timeUnit ) ; 
 + return new Target ( timeUnit , now / timeUnit , maxWindowSize ) ; 
 } 
 
 
 @ @ - 329 , 8 + 332 , 9 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 int n = 0 ; 
 for ( List < SSTableReader > bucket : tasks ) 
 { 
 - if ( bucket . size ( ) > = cfs . getMinimumCompactionThreshold ( ) ) 
 - n + = getSTCSBuckets ( bucket , stcsOptions ) . size ( ) ; 
 + for ( List < SSTableReader > stcsBucket : getSTCSBuckets ( bucket , stcsOptions ) ) 
 + if ( stcsBucket . size ( ) > = cfs . getMinimumCompactionThreshold ( ) ) 
 + n + = Math . ceil ( ( double ) stcsBucket . size ( ) / cfs . getMaximumCompactionThreshold ( ) ) ; 
 } 
 estimatedRemainingTasks = n ; 
 } 
 @ @ - 343 , 12 + 347 , 12 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 * @ return a bucket ( list ) of sstables to compact . 
 * / 
 @ VisibleForTesting 
 - static List < SSTableReader > newestBucket ( List < List < SSTableReader > > buckets , int minThreshold , int maxThreshold , long now , long baseTime , SizeTieredCompactionStrategyOptions stcsOptions ) 
 + static List < SSTableReader > newestBucket ( List < List < SSTableReader > > buckets , int minThreshold , int maxThreshold , long now , long baseTime , long maxWindowSize , SizeTieredCompactionStrategyOptions stcsOptions ) 
 { 
 / / If the " incoming window " has at least minThreshold SSTables , choose that one . 
 / / For any other bucket , at least 2 SSTables is enough . 
 / / In any case , limit to maxThreshold SSTables . 
 - Target incomingWindow = getInitialTarget ( now , baseTime ) ; 
 + Target incomingWindow = getInitialTarget ( now , baseTime , maxWindowSize ) ; 
 for ( List < SSTableReader > bucket : buckets ) 
 { 
 boolean inFirstWindow = incomingWindow . onTarget ( bucket . get ( 0 ) . getMinTimestamp ( ) ) ; 
 @ @ - 412 , 7 + 416 , 6 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 return Long . MAX _ VALUE ; 
 } 
 
 - 
 public static Map < String , String > validateOptions ( Map < String , String > options ) throws ConfigurationException 
 { 
 Map < String , String > uncheckedOptions = AbstractCompactionStrategy . validateOptions ( options ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyOptions . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyOptions . java 
 index 0cbf90e . . 5803115 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyOptions . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyOptions . java 
 @ @ - 25 , 17 + 25 , 24 @ @ import org . apache . cassandra . exceptions . ConfigurationException ; 
 public final class DateTieredCompactionStrategyOptions 
 { 
 protected static final TimeUnit DEFAULT _ TIMESTAMP _ RESOLUTION = TimeUnit . MICROSECONDS ; 
 - protected static final double DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS = 365 ; 
 + @ Deprecated 
 + protected static final double DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS = 365 * 1000 ; 
 protected static final long DEFAULT _ BASE _ TIME _ SECONDS = 60 ; 
 + protected static final long DEFAULT _ MAX _ WINDOW _ SIZE _ SECONDS = TimeUnit . SECONDS . convert ( 1 , TimeUnit . DAYS ) ; 
 + 
 protected static final int DEFAULT _ EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS = 60 * 10 ; 
 protected static final String TIMESTAMP _ RESOLUTION _ KEY = " timestamp _ resolution " ; 
 + @ Deprecated 
 protected static final String MAX _ SSTABLE _ AGE _ KEY = " max _ sstable _ age _ days " ; 
 protected static final String BASE _ TIME _ KEY = " base _ time _ seconds " ; 
 protected static final String EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS _ KEY = " expired _ sstable _ check _ frequency _ seconds " ; 
 + protected static final String MAX _ WINDOW _ SIZE _ KEY = " max _ window _ size _ seconds " ; 
 
 + @ Deprecated 
 protected final long maxSSTableAge ; 
 protected final long baseTime ; 
 protected final long expiredSSTableCheckFrequency ; 
 + protected final long maxWindowSize ; 
 
 public DateTieredCompactionStrategyOptions ( Map < String , String > options ) 
 { 
 @ @ - 48 , 13 + 55 , 16 @ @ public final class DateTieredCompactionStrategyOptions 
 baseTime = timestampResolution . convert ( optionValue = = null ? DEFAULT _ BASE _ TIME _ SECONDS : Long . parseLong ( optionValue ) , TimeUnit . SECONDS ) ; 
 optionValue = options . get ( EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS _ KEY ) ; 
 expiredSSTableCheckFrequency = TimeUnit . MILLISECONDS . convert ( optionValue = = null ? DEFAULT _ EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS : Long . parseLong ( optionValue ) , TimeUnit . SECONDS ) ; 
 + optionValue = options . get ( MAX _ WINDOW _ SIZE _ KEY ) ; 
 + maxWindowSize = timestampResolution . convert ( optionValue = = null ? DEFAULT _ MAX _ WINDOW _ SIZE _ SECONDS : Long . parseLong ( optionValue ) , TimeUnit . SECONDS ) ; 
 } 
 
 public DateTieredCompactionStrategyOptions ( ) 
 { 
 - maxSSTableAge = Math . round ( DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS * DEFAULT _ TIMESTAMP _ RESOLUTION . convert ( 1 , TimeUnit . DAYS ) ) ; 
 + maxSSTableAge = Math . round ( DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS * DEFAULT _ TIMESTAMP _ RESOLUTION . convert ( ( long ) DEFAULT _ MAX _ SSTABLE _ AGE _ DAYS , TimeUnit . DAYS ) ) ; 
 baseTime = DEFAULT _ TIMESTAMP _ RESOLUTION . convert ( DEFAULT _ BASE _ TIME _ SECONDS , TimeUnit . SECONDS ) ; 
 expiredSSTableCheckFrequency = TimeUnit . MILLISECONDS . convert ( DEFAULT _ EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS , TimeUnit . SECONDS ) ; 
 + maxWindowSize = DEFAULT _ TIMESTAMP _ RESOLUTION . convert ( 1 , TimeUnit . DAYS ) ; 
 } 
 
 public static Map < String , String > validateOptions ( Map < String , String > options , Map < String , String > uncheckedOptions ) throws ConfigurationException 
 @ @ - 112 , 10 + 122 , 26 @ @ public final class DateTieredCompactionStrategyOptions 
 throw new ConfigurationException ( String . format ( " % s is not a parsable int ( base10 ) for % s " , optionValue , EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS _ KEY ) , e ) ; 
 } 
 
 + optionValue = options . get ( MAX _ WINDOW _ SIZE _ KEY ) ; 
 + try 
 + { 
 + long maxWindowSize = optionValue = = null ? DEFAULT _ MAX _ WINDOW _ SIZE _ SECONDS : Long . parseLong ( optionValue ) ; 
 + if ( maxWindowSize < 0 ) 
 + { 
 + throw new ConfigurationException ( String . format ( " % s must not be negative , but was % d " , MAX _ WINDOW _ SIZE _ KEY , maxWindowSize ) ) ; 
 + } 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new ConfigurationException ( String . format ( " % s is not a parsable int ( base10 ) for % s " , optionValue , MAX _ WINDOW _ SIZE _ KEY ) , e ) ; 
 + } 
 + 
 + 
 uncheckedOptions . remove ( MAX _ SSTABLE _ AGE _ KEY ) ; 
 uncheckedOptions . remove ( BASE _ TIME _ KEY ) ; 
 uncheckedOptions . remove ( TIMESTAMP _ RESOLUTION _ KEY ) ; 
 uncheckedOptions . remove ( EXPIRED _ SSTABLE _ CHECK _ FREQUENCY _ SECONDS _ KEY ) ; 
 + uncheckedOptions . remove ( MAX _ WINDOW _ SIZE _ KEY ) ; 
 
 return uncheckedOptions ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyTest . java b / test / unit / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyTest . java 
 index 368101d . . 5afd575 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / DateTieredCompactionStrategyTest . java 
 @ @ - 88 , 6 + 88 , 17 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 options . put ( DateTieredCompactionStrategyOptions . MAX _ SSTABLE _ AGE _ KEY , " 0 " ) ; 
 } 
 
 + try 
 + { 
 + options . put ( DateTieredCompactionStrategyOptions . MAX _ WINDOW _ SIZE _ KEY , " - 1 " ) ; 
 + validateOptions ( options ) ; 
 + fail ( String . format ( " Negative % s should be rejected " , DateTieredCompactionStrategyOptions . MAX _ WINDOW _ SIZE _ KEY ) ) ; 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + options . put ( DateTieredCompactionStrategyOptions . MAX _ WINDOW _ SIZE _ KEY , " 0 " ) ; 
 + } 
 + 
 options . put ( " bad _ option " , " 1 . 0 " ) ; 
 unvalidated = validateOptions ( options ) ; 
 assertTrue ( unvalidated . containsKey ( " bad _ option " ) ) ; 
 @ @ - 101 , 11 + 112 , 11 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP _ RESOLUTION _ KEY , " SECONDS " ) ; 
 
 DateTieredCompactionStrategyOptions opts = new DateTieredCompactionStrategyOptions ( options ) ; 
 - assertEquals ( opts . maxSSTableAge , TimeUnit . SECONDS . convert ( 365 , TimeUnit . DAYS ) ) ; 
 + assertEquals ( opts . maxSSTableAge , TimeUnit . SECONDS . convert ( 365 * 1000 , TimeUnit . DAYS ) ) ; 
 
 options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP _ RESOLUTION _ KEY , " MILLISECONDS " ) ; 
 opts = new DateTieredCompactionStrategyOptions ( options ) ; 
 - assertEquals ( opts . maxSSTableAge , TimeUnit . MILLISECONDS . convert ( 365 , TimeUnit . DAYS ) ) ; 
 + assertEquals ( opts . maxSSTableAge , TimeUnit . MILLISECONDS . convert ( 365 * 1000 , TimeUnit . DAYS ) ) ; 
 
 options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP _ RESOLUTION _ KEY , " MICROSECONDS " ) ; 
 options . put ( DateTieredCompactionStrategyOptions . MAX _ SSTABLE _ AGE _ KEY , " 10 " ) ; 
 @ @ - 132 , 7 + 143 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 Pair . create ( " a " , 1L ) , 
 Pair . create ( " b " , 201L ) 
 ) ; 
 - List < List < String > > buckets = getBuckets ( pairs , 100L , 2 , 200L ) ; 
 + List < List < String > > buckets = getBuckets ( pairs , 100L , 2 , 200L , Long . MAX _ VALUE ) ; 
 assertEquals ( 2 , buckets . size ( ) ) ; 
 
 for ( List < String > bucket : buckets ) 
 @ @ - 151 , 7 + 162 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 Pair . create ( " b " , 3899L ) , 
 Pair . create ( " c " , 3900L ) 
 ) ; 
 - buckets = getBuckets ( pairs , 100L , 3 , 4050L ) ; 
 + buckets = getBuckets ( pairs , 100L , 3 , 4050L , Long . MAX _ VALUE ) ; 
 / / targets ( divPosition , size ) : ( 40 , 100 ) , ( 39 , 100 ) , ( 12 , 300 ) , ( 3 , 900 ) , ( 0 , 2700 ) 
 / / in other words : 0 - 2699 , 2700 - 3599 , 3600 - 3899 , 3900 - 3999 , 4000 - 4099 
 assertEquals ( 3 , buckets . size ( ) ) ; 
 @ @ - 177 , 7 + 188 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 Pair . create ( " e " , 3950L ) , 
 Pair . create ( " too new " , 4125L ) 
 ) ; 
 - buckets = getBuckets ( pairs , 100L , 1 , 4050L ) ; 
 + buckets = getBuckets ( pairs , 100L , 1 , 4050L , Long . MAX _ VALUE ) ; 
 
 assertEquals ( 5 , buckets . size ( ) ) ; 
 
 @ @ - 193 , 7 + 204 , 6 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 { 
 Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; 
 ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF _ STANDARD1 ) ; 
 - cfs . truncateBlocking ( ) ; 
 cfs . disableAutoCompaction ( ) ; 
 
 ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; 
 @ @ - 212 , 15 + 222 , 16 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 
 List < SSTableReader > sstrs = new ArrayList < > ( cfs . getSSTables ( ) ) ; 
 
 - List < SSTableReader > newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( 0 , 2 ) ) , 4 , 32 , 9 , 10 , new SizeTieredCompactionStrategyOptions ( ) ) ; 
 + List < SSTableReader > newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( 0 , 2 ) ) , 4 , 32 , 9 , 10 , Long . MAX _ VALUE , new SizeTieredCompactionStrategyOptions ( ) ) ; 
 assertTrue ( " incoming bucket should not be accepted when it has below the min threshold SSTables " , newBucket . isEmpty ( ) ) ; 
 
 - newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( 0 , 2 ) ) , 4 , 32 , 10 , 10 , new SizeTieredCompactionStrategyOptions ( ) ) ; 
 + newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( 0 , 2 ) ) , 4 , 32 , 10 , 10 , Long . MAX _ VALUE , new SizeTieredCompactionStrategyOptions ( ) ) ; 
 assertFalse ( " non - incoming bucket should be accepted when it has at least 2 SSTables " , newBucket . isEmpty ( ) ) ; 
 
 assertEquals ( " an sstable with a single value should have equal min / max timestamps " , sstrs . get ( 0 ) . getMinTimestamp ( ) , sstrs . get ( 0 ) . getMaxTimestamp ( ) ) ; 
 assertEquals ( " an sstable with a single value should have equal min / max timestamps " , sstrs . get ( 1 ) . getMinTimestamp ( ) , sstrs . get ( 1 ) . getMaxTimestamp ( ) ) ; 
 assertEquals ( " an sstable with a single value should have equal min / max timestamps " , sstrs . get ( 2 ) . getMinTimestamp ( ) , sstrs . get ( 2 ) . getMaxTimestamp ( ) ) ; 
 + cfs . truncateBlocking ( ) ; 
 } 
 
 @ Test 
 @ @ - 228 , 7 + 239 , 6 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 { 
 Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; 
 ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF _ STANDARD1 ) ; 
 - cfs . truncateBlocking ( ) ; 
 cfs . disableAutoCompaction ( ) ; 
 
 ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; 
 @ @ - 259 , 6 + 269 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 
 filtered = filterOldSSTables ( sstrs , 1 , 4 ) ; 
 assertEquals ( " no sstables should remain when all are too old " , 0 , Iterables . size ( filtered ) ) ; 
 + cfs . truncateBlocking ( ) ; 
 } 
 
 
 @ @ - 267 , 7 + 278 , 6 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 { 
 Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; 
 ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF _ STANDARD1 ) ; 
 - cfs . truncateBlocking ( ) ; 
 cfs . disableAutoCompaction ( ) ; 
 
 ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; 
 @ @ - 305 , 6 + 315 , 7 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 SSTableReader sstable = t . sstables . iterator ( ) . next ( ) ; 
 assertEquals ( sstable , expiredSSTable ) ; 
 cfs . getDataTracker ( ) . unmarkCompacting ( cfs . getSSTables ( ) ) ; 
 + cfs . truncateBlocking ( ) ; 
 } 
 
 @ Test 
 @ @ - 312 , 7 + 323 , 6 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 { 
 Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; 
 ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF _ STANDARD1 ) ; 
 - cfs . truncateBlocking ( ) ; 
 cfs . disableAutoCompaction ( ) ; 
 ByteBuffer bigValue = ByteBuffer . wrap ( new byte [ 10000 ] ) ; 
 ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; 
 @ @ - 344 , 7 + 354 , 9 @ @ public class DateTieredCompactionStrategyTest extends SchemaLoader 
 DateTieredCompactionStrategy dtcs = new DateTieredCompactionStrategy ( cfs , options ) ; 
 for ( SSTableReader sstable : cfs . getSSTables ( ) ) 
 dtcs . addSSTable ( sstable ) ; 
 - assertEquals ( 20 , dtcs . getNextBackgroundTask ( 0 ) . sstables . size ( ) ) ; 
 + AbstractCompactionTask task = dtcs . getNextBackgroundTask ( 0 ) ; 
 + assertEquals ( 20 , task . sstables . size ( ) ) ; 
 + cfs . getDataTracker ( ) . unmarkCompacting ( task . sstables ) ; 
 + cfs . truncateBlocking ( ) ; 
 } 
 - 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
