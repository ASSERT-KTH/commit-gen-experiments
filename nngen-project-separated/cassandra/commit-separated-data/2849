BLEU SCORE: 0.018543295278285157

TEST MSG: Allow nodetool to optionally resolve hostnames .
GENERATED MSG: Don ' t include original exception class name in CQL message

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index f1e7c73 . . 0cc7320 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 73 , 6 + 73 , 7 @ @ public class NodeCmd <nl> private static final Pair < String , String > UPGRADE _ ALL _ SSTABLE _ OPT = Pair . create ( " a " , " include - all - sstables " ) ; <nl> private static final Pair < String , String > NO _ SNAPSHOT = Pair . create ( " ns " , " no - snapshot " ) ; <nl> private static final Pair < String , String > CFSTATS _ IGNORE _ OPT = Pair . create ( " i " , " ignore " ) ; <nl> + private static final Pair < String , String > RESOLVE _ IP = Pair . create ( " r " , " resolve - ip " ) ; <nl> <nl> private static final String DEFAULT _ HOST = " 127 . 0 . 0 . 1 " ; <nl> private static final int DEFAULT _ PORT = 7199 ; <nl> @ @ - 99 , 6 + 100 , 7 @ @ public class NodeCmd <nl> options . addOption ( UPGRADE _ ALL _ SSTABLE _ OPT , false , " includes sstables that are already on the most recent version during upgradesstables " ) ; <nl> options . addOption ( NO _ SNAPSHOT , false , " disables snapshot creation for scrub " ) ; <nl> options . addOption ( CFSTATS _ IGNORE _ OPT , false , " ignore the supplied list of keyspace . columnfamiles in statistics " ) ; <nl> + options . addOption ( RESOLVE _ IP , false , " show node domain names instead of IPs " ) ; <nl> } <nl> <nl> public NodeCmd ( NodeProbe probe ) <nl> @ @ - 373 , 11 + 375 , 13 @ @ public class NodeCmd <nl> Map < String , String > loadMap , hostIDMap , tokensToEndpoints ; <nl> EndpointSnitchInfoMBean epSnitchInfo ; <nl> PrintStream outs ; <nl> + private final boolean resolveIp ; <nl> <nl> - ClusterStatus ( PrintStream outs , String kSpace ) <nl> + ClusterStatus ( PrintStream outs , String kSpace , boolean resolveIp ) <nl> { <nl> this . kSpace = kSpace ; <nl> this . outs = outs ; <nl> + this . resolveIp = resolveIp ; <nl> joiningNodes = probe . getJoiningNodes ( ) ; <nl> leavingNodes = probe . getLeavingNodes ( ) ; <nl> movingNodes = probe . getMovingNodes ( ) ; <nl> @ @ - 395 , 18 + 399 , 58 @ @ public class NodeCmd <nl> outs . println ( " | / State = Normal / Leaving / Joining / Moving " ) ; <nl> } <nl> <nl> - private Map < String , Map < InetAddress , Float > > getOwnershipByDc ( Map < InetAddress , Float > ownerships ) <nl> + class SetHostStat implements Iterable < HostStat > { <nl> + final List < HostStat > hostStats = new ArrayList < HostStat > ( ) ; <nl> + <nl> + public SetHostStat ( ) { } <nl> + <nl> + public SetHostStat ( Map < InetAddress , Float > ownerships ) { <nl> + for ( Map . Entry < InetAddress , Float > entry : ownerships . entrySet ( ) ) { <nl> + hostStats . add ( new HostStat ( entry ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public Iterator < HostStat > iterator ( ) { <nl> + return hostStats . iterator ( ) ; <nl> + } <nl> + <nl> + public void add ( HostStat entry ) { <nl> + hostStats . add ( entry ) ; <nl> + } <nl> + } <nl> + <nl> + class HostStat { <nl> + public final String ip ; <nl> + public final String dns ; <nl> + public final Float owns ; <nl> + <nl> + public HostStat ( Map . Entry < InetAddress , Float > ownership ) { <nl> + this . ip = ownership . getKey ( ) . getHostAddress ( ) ; <nl> + this . dns = ownership . getKey ( ) . getHostName ( ) ; <nl> + this . owns = ownership . getValue ( ) ; <nl> + } <nl> + <nl> + public String ipOrDns ( ) { <nl> + if ( resolveIp ) { <nl> + return dns ; <nl> + } <nl> + return ip ; <nl> + } <nl> + } <nl> + <nl> + private Map < String , SetHostStat > getOwnershipByDc ( SetHostStat ownerships ) <nl> throws UnknownHostException <nl> { <nl> - Map < String , Map < InetAddress , Float > > ownershipByDc = Maps . newLinkedHashMap ( ) ; <nl> + Map < String , SetHostStat > ownershipByDc = Maps . newLinkedHashMap ( ) ; <nl> EndpointSnitchInfoMBean epSnitchInfo = probe . getEndpointSnitchInfoProxy ( ) ; <nl> <nl> - for ( Map . Entry < InetAddress , Float > ownership : ownerships . entrySet ( ) ) <nl> + for ( HostStat ownership : ownerships ) <nl> { <nl> - String dc = epSnitchInfo . getDatacenter ( ownership . getKey ( ) . getHostAddress ( ) ) ; <nl> + String dc = epSnitchInfo . getDatacenter ( ownership . ip ) ; <nl> if ( ! ownershipByDc . containsKey ( dc ) ) <nl> - ownershipByDc . put ( dc , new LinkedHashMap < InetAddress , Float > ( ) ) ; <nl> - ownershipByDc . get ( dc ) . put ( ownership . getKey ( ) , ownership . getValue ( ) ) ; <nl> + ownershipByDc . put ( dc , new SetHostStat ( ) ) ; <nl> + ownershipByDc . get ( dc ) . add ( ownership ) ; <nl> } <nl> <nl> return ownershipByDc ; <nl> @ @ - 434 , 12 + 478 , 12 @ @ public class NodeCmd <nl> return format ; <nl> } <nl> <nl> - private void printNode ( String endpoint , Float owns , Map < InetAddress , Float > ownerships , <nl> + private void printNode ( HostStat hostStat , <nl> boolean hasEffectiveOwns , boolean isTokenPerNode ) throws UnknownHostException <nl> { <nl> String status , state , load , strOwns , hostID , rack , fmt ; <nl> fmt = getFormat ( hasEffectiveOwns , isTokenPerNode ) ; <nl> - <nl> + String endpoint = hostStat . ip ; <nl> if ( liveNodes . contains ( endpoint ) ) status = " U " ; <nl> else if ( unreachableNodes . contains ( endpoint ) ) status = " D " ; <nl> else status = " ? " ; <nl> @ @ - 449 , 18 + 493 , 18 @ @ public class NodeCmd <nl> else state = " N " ; <nl> <nl> load = loadMap . containsKey ( endpoint ) ? loadMap . get ( endpoint ) : " ? " ; <nl> - strOwns = new DecimalFormat ( " # # 0 . 0 % " ) . format ( ownerships . get ( InetAddress . getByName ( endpoint ) ) ) ; <nl> + strOwns = new DecimalFormat ( " # # 0 . 0 % " ) . format ( hostStat . owns ) ; <nl> hostID = hostIDMap . get ( endpoint ) ; <nl> rack = epSnitchInfo . getRack ( endpoint ) ; <nl> <nl> if ( isTokenPerNode ) <nl> { <nl> - outs . printf ( fmt , status , state , endpoint , load , strOwns , hostID , probe . getTokens ( endpoint ) . get ( 0 ) , rack ) ; <nl> + outs . printf ( fmt , status , state , hostStat . ipOrDns ( ) , load , strOwns , hostID , probe . getTokens ( endpoint ) . get ( 0 ) , rack ) ; <nl> } <nl> else <nl> { <nl> int tokens = probe . getTokens ( endpoint ) . size ( ) ; <nl> - outs . printf ( fmt , status , state , endpoint , load , tokens , strOwns , hostID , rack ) ; <nl> + outs . printf ( fmt , status , state , hostStat . ipOrDns ( ) , load , tokens , strOwns , hostID , rack ) ; <nl> } <nl> } <nl> <nl> @ @ - 475 , 42 + 519 , 41 @ @ public class NodeCmd <nl> outs . printf ( fmt , " - " , " - " , " Address " , " Load " , " Tokens " , owns , " Host ID " , " Rack " ) ; <nl> } <nl> <nl> + void findMaxAddressLength ( Map < String , SetHostStat > dcs ) { <nl> + maxAddressLength = 0 ; <nl> + for ( Map . Entry < String , SetHostStat > dc : dcs . entrySet ( ) ) <nl> + { <nl> + for ( HostStat stat : dc . getValue ( ) ) { <nl> + maxAddressLength = Math . max ( maxAddressLength , stat . ipOrDns ( ) . length ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> void print ( ) throws UnknownHostException <nl> { <nl> - Map < InetAddress , Float > ownerships ; <nl> + SetHostStat ownerships ; <nl> boolean hasEffectiveOwns = false , isTokenPerNode = true ; <nl> <nl> try <nl> { <nl> - ownerships = probe . effectiveOwnership ( kSpace ) ; <nl> + ownerships = new SetHostStat ( probe . effectiveOwnership ( kSpace ) ) ; <nl> hasEffectiveOwns = true ; <nl> } <nl> catch ( IllegalStateException e ) <nl> { <nl> - ownerships = probe . getOwnership ( ) ; <nl> + ownerships = new SetHostStat ( probe . getOwnership ( ) ) ; <nl> } <nl> <nl> / / More tokens then nodes ( aka vnodes ) ? <nl> if ( new HashSet < String > ( tokensToEndpoints . values ( ) ) . size ( ) < tokensToEndpoints . keySet ( ) . size ( ) ) <nl> isTokenPerNode = false ; <nl> <nl> - maxAddressLength = 0 ; <nl> - for ( Map . Entry < String , Map < InetAddress , Float > > dc : getOwnershipByDc ( ownerships ) . entrySet ( ) ) <nl> - { <nl> - int dcMaxAddressLength = Collections . max ( dc . getValue ( ) . keySet ( ) , new Comparator < InetAddress > ( ) { <nl> - @ Override <nl> - public int compare ( InetAddress first , InetAddress second ) <nl> - { <nl> - return ( ( Integer ) first . getHostAddress ( ) . length ( ) ) . compareTo ( ( Integer ) second . getHostAddress ( ) . length ( ) ) ; <nl> - } <nl> - } ) . getHostAddress ( ) . length ( ) ; <nl> + Map < String , SetHostStat > dcs = getOwnershipByDc ( ownerships ) ; <nl> <nl> - if ( dcMaxAddressLength > maxAddressLength ) <nl> - maxAddressLength = dcMaxAddressLength ; <nl> - } <nl> + findMaxAddressLength ( dcs ) ; <nl> <nl> / / Datacenters <nl> - for ( Map . Entry < String , Map < InetAddress , Float > > dc : getOwnershipByDc ( ownerships ) . entrySet ( ) ) <nl> + for ( Map . Entry < String , SetHostStat > dc : dcs . entrySet ( ) ) <nl> { <nl> String dcHeader = String . format ( " Datacenter : % s % n " , dc . getKey ( ) ) ; <nl> outs . printf ( dcHeader ) ; <nl> @ @ - 521 , 21 + 564 , 17 @ @ public class NodeCmd <nl> printNodesHeader ( hasEffectiveOwns , isTokenPerNode ) ; <nl> <nl> / / Nodes <nl> - for ( Map . Entry < InetAddress , Float > entry : dc . getValue ( ) . entrySet ( ) ) <nl> - printNode ( entry . getKey ( ) . getHostAddress ( ) , <nl> - entry . getValue ( ) , <nl> - ownerships , <nl> - hasEffectiveOwns , <nl> - isTokenPerNode ) ; <nl> + for ( HostStat entry : dc . getValue ( ) ) <nl> + printNode ( entry , hasEffectiveOwns , isTokenPerNode ) ; <nl> } <nl> } <nl> } <nl> <nl> / * * Writes a keyspaceName of cluster - wide node information to a PrintStream <nl> * @ throws UnknownHostException * / <nl> - public void printClusterStatus ( PrintStream outs , String keyspace ) throws UnknownHostException <nl> + public void printClusterStatus ( PrintStream outs , String keyspace , boolean resolveIp ) throws UnknownHostException <nl> { <nl> - new ClusterStatus ( outs , keyspace ) . print ( ) ; <nl> + new ClusterStatus ( outs , keyspace , resolveIp ) . print ( ) ; <nl> } <nl> <nl> public void printThreadPoolStats ( PrintStream outs ) <nl> @ @ - 1125 , 8 + 1164 , 9 @ @ public class NodeCmd <nl> break ; <nl> <nl> case STATUS : <nl> - if ( arguments . length > 0 ) nodeCmd . printClusterStatus ( System . out , arguments [ 0 ] ) ; <nl> - else nodeCmd . printClusterStatus ( System . out , null ) ; <nl> + boolean resolveIp = cmd . hasOption ( RESOLVE _ IP . left ) ; <nl> + if ( arguments . length > 0 ) nodeCmd . printClusterStatus ( System . out , arguments [ 0 ] , resolveIp ) ; <nl> + else nodeCmd . printClusterStatus ( System . out , null , resolveIp ) ; <nl> break ; <nl> <nl> case DECOMMISSION :
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java <nl> index ab48b51 . . 1f54b5b 100644 <nl> - - - a / src / java / org / apache / cassandra / cli / CliClient . java <nl> + + + b / src / java / org / apache / cassandra / cli / CliClient . java <nl> @ @ - 1154 , 7 + 1154 , 7 @ @ public class CliClient <nl> { <nl> SimpleSnitch snitch = new SimpleSnitch ( ) ; <nl> Map < String , String > options = new HashMap < String , String > ( ) ; <nl> - options . put ( snitch . getDatacenter ( FBUtilities . getBroadcastAddress ( ) ) , " 1 " ) ; <nl> + options . put ( snitch . getDatacenter ( InetAddress . getLocalHost ( ) ) , " 1 " ) ; <nl> <nl> ksDef . setStrategy _ options ( options ) ; <nl> }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index f1e7c73 . . 0cc7320 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 73 , 6 + 73 , 7 @ @ public class NodeCmd 
 private static final Pair < String , String > UPGRADE _ ALL _ SSTABLE _ OPT = Pair . create ( " a " , " include - all - sstables " ) ; 
 private static final Pair < String , String > NO _ SNAPSHOT = Pair . create ( " ns " , " no - snapshot " ) ; 
 private static final Pair < String , String > CFSTATS _ IGNORE _ OPT = Pair . create ( " i " , " ignore " ) ; 
 + private static final Pair < String , String > RESOLVE _ IP = Pair . create ( " r " , " resolve - ip " ) ; 
 
 private static final String DEFAULT _ HOST = " 127 . 0 . 0 . 1 " ; 
 private static final int DEFAULT _ PORT = 7199 ; 
 @ @ - 99 , 6 + 100 , 7 @ @ public class NodeCmd 
 options . addOption ( UPGRADE _ ALL _ SSTABLE _ OPT , false , " includes sstables that are already on the most recent version during upgradesstables " ) ; 
 options . addOption ( NO _ SNAPSHOT , false , " disables snapshot creation for scrub " ) ; 
 options . addOption ( CFSTATS _ IGNORE _ OPT , false , " ignore the supplied list of keyspace . columnfamiles in statistics " ) ; 
 + options . addOption ( RESOLVE _ IP , false , " show node domain names instead of IPs " ) ; 
 } 
 
 public NodeCmd ( NodeProbe probe ) 
 @ @ - 373 , 11 + 375 , 13 @ @ public class NodeCmd 
 Map < String , String > loadMap , hostIDMap , tokensToEndpoints ; 
 EndpointSnitchInfoMBean epSnitchInfo ; 
 PrintStream outs ; 
 + private final boolean resolveIp ; 
 
 - ClusterStatus ( PrintStream outs , String kSpace ) 
 + ClusterStatus ( PrintStream outs , String kSpace , boolean resolveIp ) 
 { 
 this . kSpace = kSpace ; 
 this . outs = outs ; 
 + this . resolveIp = resolveIp ; 
 joiningNodes = probe . getJoiningNodes ( ) ; 
 leavingNodes = probe . getLeavingNodes ( ) ; 
 movingNodes = probe . getMovingNodes ( ) ; 
 @ @ - 395 , 18 + 399 , 58 @ @ public class NodeCmd 
 outs . println ( " | / State = Normal / Leaving / Joining / Moving " ) ; 
 } 
 
 - private Map < String , Map < InetAddress , Float > > getOwnershipByDc ( Map < InetAddress , Float > ownerships ) 
 + class SetHostStat implements Iterable < HostStat > { 
 + final List < HostStat > hostStats = new ArrayList < HostStat > ( ) ; 
 + 
 + public SetHostStat ( ) { } 
 + 
 + public SetHostStat ( Map < InetAddress , Float > ownerships ) { 
 + for ( Map . Entry < InetAddress , Float > entry : ownerships . entrySet ( ) ) { 
 + hostStats . add ( new HostStat ( entry ) ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public Iterator < HostStat > iterator ( ) { 
 + return hostStats . iterator ( ) ; 
 + } 
 + 
 + public void add ( HostStat entry ) { 
 + hostStats . add ( entry ) ; 
 + } 
 + } 
 + 
 + class HostStat { 
 + public final String ip ; 
 + public final String dns ; 
 + public final Float owns ; 
 + 
 + public HostStat ( Map . Entry < InetAddress , Float > ownership ) { 
 + this . ip = ownership . getKey ( ) . getHostAddress ( ) ; 
 + this . dns = ownership . getKey ( ) . getHostName ( ) ; 
 + this . owns = ownership . getValue ( ) ; 
 + } 
 + 
 + public String ipOrDns ( ) { 
 + if ( resolveIp ) { 
 + return dns ; 
 + } 
 + return ip ; 
 + } 
 + } 
 + 
 + private Map < String , SetHostStat > getOwnershipByDc ( SetHostStat ownerships ) 
 throws UnknownHostException 
 { 
 - Map < String , Map < InetAddress , Float > > ownershipByDc = Maps . newLinkedHashMap ( ) ; 
 + Map < String , SetHostStat > ownershipByDc = Maps . newLinkedHashMap ( ) ; 
 EndpointSnitchInfoMBean epSnitchInfo = probe . getEndpointSnitchInfoProxy ( ) ; 
 
 - for ( Map . Entry < InetAddress , Float > ownership : ownerships . entrySet ( ) ) 
 + for ( HostStat ownership : ownerships ) 
 { 
 - String dc = epSnitchInfo . getDatacenter ( ownership . getKey ( ) . getHostAddress ( ) ) ; 
 + String dc = epSnitchInfo . getDatacenter ( ownership . ip ) ; 
 if ( ! ownershipByDc . containsKey ( dc ) ) 
 - ownershipByDc . put ( dc , new LinkedHashMap < InetAddress , Float > ( ) ) ; 
 - ownershipByDc . get ( dc ) . put ( ownership . getKey ( ) , ownership . getValue ( ) ) ; 
 + ownershipByDc . put ( dc , new SetHostStat ( ) ) ; 
 + ownershipByDc . get ( dc ) . add ( ownership ) ; 
 } 
 
 return ownershipByDc ; 
 @ @ - 434 , 12 + 478 , 12 @ @ public class NodeCmd 
 return format ; 
 } 
 
 - private void printNode ( String endpoint , Float owns , Map < InetAddress , Float > ownerships , 
 + private void printNode ( HostStat hostStat , 
 boolean hasEffectiveOwns , boolean isTokenPerNode ) throws UnknownHostException 
 { 
 String status , state , load , strOwns , hostID , rack , fmt ; 
 fmt = getFormat ( hasEffectiveOwns , isTokenPerNode ) ; 
 - 
 + String endpoint = hostStat . ip ; 
 if ( liveNodes . contains ( endpoint ) ) status = " U " ; 
 else if ( unreachableNodes . contains ( endpoint ) ) status = " D " ; 
 else status = " ? " ; 
 @ @ - 449 , 18 + 493 , 18 @ @ public class NodeCmd 
 else state = " N " ; 
 
 load = loadMap . containsKey ( endpoint ) ? loadMap . get ( endpoint ) : " ? " ; 
 - strOwns = new DecimalFormat ( " # # 0 . 0 % " ) . format ( ownerships . get ( InetAddress . getByName ( endpoint ) ) ) ; 
 + strOwns = new DecimalFormat ( " # # 0 . 0 % " ) . format ( hostStat . owns ) ; 
 hostID = hostIDMap . get ( endpoint ) ; 
 rack = epSnitchInfo . getRack ( endpoint ) ; 
 
 if ( isTokenPerNode ) 
 { 
 - outs . printf ( fmt , status , state , endpoint , load , strOwns , hostID , probe . getTokens ( endpoint ) . get ( 0 ) , rack ) ; 
 + outs . printf ( fmt , status , state , hostStat . ipOrDns ( ) , load , strOwns , hostID , probe . getTokens ( endpoint ) . get ( 0 ) , rack ) ; 
 } 
 else 
 { 
 int tokens = probe . getTokens ( endpoint ) . size ( ) ; 
 - outs . printf ( fmt , status , state , endpoint , load , tokens , strOwns , hostID , rack ) ; 
 + outs . printf ( fmt , status , state , hostStat . ipOrDns ( ) , load , tokens , strOwns , hostID , rack ) ; 
 } 
 } 
 
 @ @ - 475 , 42 + 519 , 41 @ @ public class NodeCmd 
 outs . printf ( fmt , " - " , " - " , " Address " , " Load " , " Tokens " , owns , " Host ID " , " Rack " ) ; 
 } 
 
 + void findMaxAddressLength ( Map < String , SetHostStat > dcs ) { 
 + maxAddressLength = 0 ; 
 + for ( Map . Entry < String , SetHostStat > dc : dcs . entrySet ( ) ) 
 + { 
 + for ( HostStat stat : dc . getValue ( ) ) { 
 + maxAddressLength = Math . max ( maxAddressLength , stat . ipOrDns ( ) . length ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 void print ( ) throws UnknownHostException 
 { 
 - Map < InetAddress , Float > ownerships ; 
 + SetHostStat ownerships ; 
 boolean hasEffectiveOwns = false , isTokenPerNode = true ; 
 
 try 
 { 
 - ownerships = probe . effectiveOwnership ( kSpace ) ; 
 + ownerships = new SetHostStat ( probe . effectiveOwnership ( kSpace ) ) ; 
 hasEffectiveOwns = true ; 
 } 
 catch ( IllegalStateException e ) 
 { 
 - ownerships = probe . getOwnership ( ) ; 
 + ownerships = new SetHostStat ( probe . getOwnership ( ) ) ; 
 } 
 
 / / More tokens then nodes ( aka vnodes ) ? 
 if ( new HashSet < String > ( tokensToEndpoints . values ( ) ) . size ( ) < tokensToEndpoints . keySet ( ) . size ( ) ) 
 isTokenPerNode = false ; 
 
 - maxAddressLength = 0 ; 
 - for ( Map . Entry < String , Map < InetAddress , Float > > dc : getOwnershipByDc ( ownerships ) . entrySet ( ) ) 
 - { 
 - int dcMaxAddressLength = Collections . max ( dc . getValue ( ) . keySet ( ) , new Comparator < InetAddress > ( ) { 
 - @ Override 
 - public int compare ( InetAddress first , InetAddress second ) 
 - { 
 - return ( ( Integer ) first . getHostAddress ( ) . length ( ) ) . compareTo ( ( Integer ) second . getHostAddress ( ) . length ( ) ) ; 
 - } 
 - } ) . getHostAddress ( ) . length ( ) ; 
 + Map < String , SetHostStat > dcs = getOwnershipByDc ( ownerships ) ; 
 
 - if ( dcMaxAddressLength > maxAddressLength ) 
 - maxAddressLength = dcMaxAddressLength ; 
 - } 
 + findMaxAddressLength ( dcs ) ; 
 
 / / Datacenters 
 - for ( Map . Entry < String , Map < InetAddress , Float > > dc : getOwnershipByDc ( ownerships ) . entrySet ( ) ) 
 + for ( Map . Entry < String , SetHostStat > dc : dcs . entrySet ( ) ) 
 { 
 String dcHeader = String . format ( " Datacenter : % s % n " , dc . getKey ( ) ) ; 
 outs . printf ( dcHeader ) ; 
 @ @ - 521 , 21 + 564 , 17 @ @ public class NodeCmd 
 printNodesHeader ( hasEffectiveOwns , isTokenPerNode ) ; 
 
 / / Nodes 
 - for ( Map . Entry < InetAddress , Float > entry : dc . getValue ( ) . entrySet ( ) ) 
 - printNode ( entry . getKey ( ) . getHostAddress ( ) , 
 - entry . getValue ( ) , 
 - ownerships , 
 - hasEffectiveOwns , 
 - isTokenPerNode ) ; 
 + for ( HostStat entry : dc . getValue ( ) ) 
 + printNode ( entry , hasEffectiveOwns , isTokenPerNode ) ; 
 } 
 } 
 } 
 
 / * * Writes a keyspaceName of cluster - wide node information to a PrintStream 
 * @ throws UnknownHostException * / 
 - public void printClusterStatus ( PrintStream outs , String keyspace ) throws UnknownHostException 
 + public void printClusterStatus ( PrintStream outs , String keyspace , boolean resolveIp ) throws UnknownHostException 
 { 
 - new ClusterStatus ( outs , keyspace ) . print ( ) ; 
 + new ClusterStatus ( outs , keyspace , resolveIp ) . print ( ) ; 
 } 
 
 public void printThreadPoolStats ( PrintStream outs ) 
 @ @ - 1125 , 8 + 1164 , 9 @ @ public class NodeCmd 
 break ; 
 
 case STATUS : 
 - if ( arguments . length > 0 ) nodeCmd . printClusterStatus ( System . out , arguments [ 0 ] ) ; 
 - else nodeCmd . printClusterStatus ( System . out , null ) ; 
 + boolean resolveIp = cmd . hasOption ( RESOLVE _ IP . left ) ; 
 + if ( arguments . length > 0 ) nodeCmd . printClusterStatus ( System . out , arguments [ 0 ] , resolveIp ) ; 
 + else nodeCmd . printClusterStatus ( System . out , null , resolveIp ) ; 
 break ; 
 
 case DECOMMISSION :

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java 
 index ab48b51 . . 1f54b5b 100644 
 - - - a / src / java / org / apache / cassandra / cli / CliClient . java 
 + + + b / src / java / org / apache / cassandra / cli / CliClient . java 
 @ @ - 1154 , 7 + 1154 , 7 @ @ public class CliClient 
 { 
 SimpleSnitch snitch = new SimpleSnitch ( ) ; 
 Map < String , String > options = new HashMap < String , String > ( ) ; 
 - options . put ( snitch . getDatacenter ( FBUtilities . getBroadcastAddress ( ) ) , " 1 " ) ; 
 + options . put ( snitch . getDatacenter ( InetAddress . getLocalHost ( ) ) , " 1 " ) ; 
 
 ksDef . setStrategy _ options ( options ) ; 
 }
