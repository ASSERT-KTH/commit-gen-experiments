BLEU SCORE: 0.028465126651392333

TEST MSG: ninja fix bad merges for unit test
GENERATED MSG: Remove mentions of transient replication from repair path

TEST DIFF (one line): diff - - git a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java <nl> index a3f13c2 . . 2c186ba 100644 <nl> - - - a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java <nl> + + + b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java <nl> @ @ - 214 , 6 + 214 , 7 @ @ public class WriteResponseHandlerTest <nl> @ Test <nl> public void failedIdealCLIncrementsStat ( ) throws Throwable <nl> { <nl> + ks . metric . idealCLWriteLatency . totalLatency . dec ( ks . metric . idealCLWriteLatency . totalLatency . getCount ( ) ) ; <nl> AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . LOCAL _ QUORUM , ConsistencyLevel . EACH _ QUORUM ) ; <nl> <nl> / / Succeed in local DC <nl> diff - - git a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTransientTest . java b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTransientTest . java <nl> index b6c95dd . . d31d3f1 100644 <nl> - - - a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTransientTest . java <nl> + + + b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTransientTest . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import java . util . Set ; <nl> import java . util . UUID ; <nl> import java . util . function . Predicate ; <nl> <nl> + import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Sets ; <nl> <nl> import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> @ @ - 153 , 7 + 154 , 8 @ @ public class WriteResponseHandlerTransientTest <nl> ReplicaLayout . ForTokenWrite layout = new ReplicaLayout . ForTokenWrite ( natural , pending ) ; <nl> ReplicaPlan . ForTokenWrite replicaPlan = ReplicaPlans . forWrite ( ks , ConsistencyLevel . QUORUM , layout , layout , ReplicaPlans . writeAll ) ; <nl> <nl> - Assert . assertEquals ( EndpointsForRange . of ( full ( EP4 ) , trans ( EP6 ) ) , replicaPlan . pending ( ) ) ; <nl> + Assert . assertTrue ( Iterables . elementsEqual ( EndpointsForRange . of ( full ( EP4 ) , trans ( EP6 ) ) , <nl> + replicaPlan . pending ( ) ) ) ; <nl> } <nl> <nl> private static ReplicaPlan . ForTokenWrite expected ( EndpointsForToken natural , EndpointsForToken selected ) <nl> @ @ - 171 , 9 + 173 , 9 @ @ public class WriteResponseHandlerTransientTest <nl> private static void assertSpeculationReplicas ( ReplicaPlan . ForTokenWrite expected , EndpointsForToken replicas , Predicate < InetAddressAndPort > livePredicate ) <nl> { <nl> ReplicaPlan . ForTokenWrite actual = getSpeculationContext ( replicas , livePredicate ) ; <nl> - Assert . assertEquals ( expected . pending ( ) , actual . pending ( ) ) ; <nl> - Assert . assertEquals ( expected . live ( ) , actual . live ( ) ) ; <nl> - Assert . assertEquals ( expected . contacts ( ) , actual . contacts ( ) ) ; <nl> + Assert . assertTrue ( Iterables . elementsEqual ( expected . pending ( ) , actual . pending ( ) ) ) ; <nl> + Assert . assertTrue ( Iterables . elementsEqual ( expected . live ( ) , actual . live ( ) ) ) ; <nl> + Assert . assertTrue ( Iterables . elementsEqual ( expected . contacts ( ) , actual . contacts ( ) ) ) ; <nl> } <nl> <nl> private static Predicate < InetAddressAndPort > dead ( InetAddressAndPort . . . endpoints ) <nl> diff - - git a / test / unit / org / apache / cassandra / service / reads / DataResolverTransientTest . java b / test / unit / org / apache / cassandra / service / reads / DataResolverTransientTest . java <nl> deleted file mode 100644 <nl> index 456cec4 . . 0000000 <nl> - - - a / test / unit / org / apache / cassandra / service / reads / DataResolverTransientTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 227 + 0 , 0 @ @ <nl> - / * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . service . reads ; <nl> - <nl> - import java . util . concurrent . TimeUnit ; <nl> - <nl> - import com . google . common . primitives . Ints ; <nl> - <nl> - import org . apache . cassandra . Util ; <nl> - import org . apache . cassandra . db . DecoratedKey ; <nl> - import org . apache . cassandra . locator . ReplicaPlan ; <nl> - import org . junit . Assert ; <nl> - import org . junit . Before ; <nl> - import org . junit . Test ; <nl> - <nl> - import org . apache . cassandra . db . Clustering ; <nl> - import org . apache . cassandra . db . ConsistencyLevel ; <nl> - import org . apache . cassandra . db . DeletionTime ; <nl> - import org . apache . cassandra . db . EmptyIterators ; <nl> - import org . apache . cassandra . db . RangeTombstone ; <nl> - import org . apache . cassandra . db . SimpleBuilders ; <nl> - import org . apache . cassandra . db . SinglePartitionReadCommand ; <nl> - import org . apache . cassandra . db . Slice ; <nl> - import org . apache . cassandra . db . partitions . PartitionUpdate ; <nl> - import org . apache . cassandra . db . rows . BTreeRow ; <nl> - import org . apache . cassandra . db . rows . Row ; <nl> - import org . apache . cassandra . locator . EndpointsForToken ; <nl> - import org . apache . cassandra . locator . ReplicaLayout ; <nl> - import org . apache . cassandra . schema . TableMetadata ; <nl> - import org . apache . cassandra . service . reads . repair . TestableReadRepair ; <nl> - import org . apache . cassandra . utils . ByteBufferUtil ; <nl> - <nl> - import static org . apache . cassandra . db . ConsistencyLevel . QUORUM ; <nl> - import static org . apache . cassandra . locator . Replica . fullReplica ; <nl> - import static org . apache . cassandra . locator . Replica . transientReplica ; <nl> - import static org . apache . cassandra . locator . ReplicaUtils . full ; <nl> - import static org . apache . cassandra . locator . ReplicaUtils . trans ; <nl> - <nl> - / * * <nl> - * Tests DataResolvers handing of transient replicas <nl> - * / <nl> - public class DataResolverTransientTest extends AbstractReadResponseTest <nl> - { <nl> - private static DecoratedKey key ; <nl> - <nl> - @ Before <nl> - public void setUp ( ) <nl> - { <nl> - key = Util . dk ( " key1 " ) ; <nl> - } <nl> - <nl> - private static PartitionUpdate . Builder update ( TableMetadata metadata , String key , Row . . . rows ) <nl> - { <nl> - PartitionUpdate . Builder builder = new PartitionUpdate . Builder ( metadata , dk ( key ) , metadata . regularAndStaticColumns ( ) , rows . length , false ) ; <nl> - for ( Row row : rows ) <nl> - { <nl> - builder . add ( row ) ; <nl> - } <nl> - return builder ; <nl> - } <nl> - <nl> - private static PartitionUpdate . Builder update ( Row . . . rows ) <nl> - { <nl> - return update ( cfm , " key1 " , rows ) ; <nl> - } <nl> - <nl> - private static Row . SimpleBuilder rowBuilder ( int clustering ) <nl> - { <nl> - return new SimpleBuilders . RowBuilder ( cfm , Integer . toString ( clustering ) ) ; <nl> - } <nl> - <nl> - private static Row row ( long timestamp , int clustering , int value ) <nl> - { <nl> - return rowBuilder ( clustering ) . timestamp ( timestamp ) . add ( " c1 " , Integer . toString ( value ) ) . build ( ) ; <nl> - } <nl> - <nl> - private static DeletionTime deletion ( long timeMillis ) <nl> - { <nl> - TimeUnit MILLIS = TimeUnit . MILLISECONDS ; <nl> - return new DeletionTime ( MILLIS . toMicros ( timeMillis ) , Ints . checkedCast ( MILLIS . toSeconds ( timeMillis ) ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Tests that the given update doesn ' t cause data resolver to attempt to repair a transient replica <nl> - * / <nl> - private void assertNoTransientRepairs ( PartitionUpdate update ) <nl> - { <nl> - SinglePartitionReadCommand command = SinglePartitionReadCommand . fullPartitionRead ( update . metadata ( ) , nowInSec , key ) ; <nl> - EndpointsForToken targetReplicas = EndpointsForToken . of ( key . getToken ( ) , full ( EP1 ) , full ( EP2 ) , trans ( EP3 ) ) ; <nl> - TestableReadRepair repair = new TestableReadRepair ( command ) ; <nl> - DataResolver resolver = new DataResolver ( command , plan ( targetReplicas , ConsistencyLevel . QUORUM ) , repair , 0 ) ; <nl> - <nl> - Assert . assertFalse ( resolver . isDataPresent ( ) ) ; <nl> - resolver . preprocess ( response ( command , EP1 , iter ( update ) , false ) ) ; <nl> - resolver . preprocess ( response ( command , EP2 , iter ( update ) , false ) ) ; <nl> - resolver . preprocess ( response ( command , EP3 , EmptyIterators . unfilteredPartition ( update . metadata ( ) ) , false ) ) ; <nl> - <nl> - Assert . assertFalse ( repair . dataWasConsumed ( ) ) ; <nl> - assertPartitionsEqual ( filter ( iter ( update ) ) , resolver . resolve ( ) ) ; <nl> - Assert . assertTrue ( repair . dataWasConsumed ( ) ) ; <nl> - Assert . assertTrue ( repair . sent . toString ( ) , repair . sent . isEmpty ( ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void emptyRowRepair ( ) <nl> - { <nl> - assertNoTransientRepairs ( update ( row ( 1000 , 4 , 4 ) , row ( 1000 , 5 , 5 ) ) . build ( ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void emptyPartitionDeletionRepairs ( ) <nl> - { <nl> - PartitionUpdate . Builder builder = update ( ) ; <nl> - builder . addPartitionDeletion ( deletion ( 1999 ) ) ; <nl> - assertNoTransientRepairs ( builder . build ( ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Partition level deletion responses shouldn ' t sent data to a transient replica <nl> - * / <nl> - @ Test <nl> - public void emptyRowDeletionRepairs ( ) <nl> - { <nl> - PartitionUpdate . Builder builder = update ( ) ; <nl> - builder . add ( rowBuilder ( 1 ) . timestamp ( 1999 ) . delete ( ) . build ( ) ) ; <nl> - assertNoTransientRepairs ( builder . build ( ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void emptyComplexDeletionRepair ( ) <nl> - { <nl> - <nl> - long [ ] ts = { 1000 , 2000 } ; <nl> - <nl> - Row . Builder builder = BTreeRow . unsortedBuilder ( ) ; <nl> - builder . newRow ( Clustering . EMPTY ) ; <nl> - builder . addComplexDeletion ( m , new DeletionTime ( ts [ 0 ] - 1 , nowInSec ) ) ; <nl> - assertNoTransientRepairs ( update ( cfm2 , " key " , builder . build ( ) ) . build ( ) ) ; <nl> - <nl> - } <nl> - <nl> - @ Test <nl> - public void emptyRangeTombstoneRepairs ( ) <nl> - { <nl> - Slice slice = Slice . make ( Clustering . make ( ByteBufferUtil . bytes ( " a " ) ) , Clustering . make ( ByteBufferUtil . bytes ( " b " ) ) ) ; <nl> - PartitionUpdate . Builder builder = update ( ) ; <nl> - builder . add ( new RangeTombstone ( slice , deletion ( 2000 ) ) ) ; <nl> - assertNoTransientRepairs ( builder . build ( ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * If the full replicas need to repair each other , repairs shouldn ' t be sent to transient replicas <nl> - * / <nl> - @ Test <nl> - public void fullRepairsIgnoreTransientReplicas ( ) <nl> - { <nl> - SinglePartitionReadCommand command = SinglePartitionReadCommand . fullPartitionRead ( cfm , nowInSec , dk ( 5 ) ) ; <nl> - EndpointsForToken targetReplicas = EndpointsForToken . of ( key . getToken ( ) , full ( EP1 ) , full ( EP2 ) , trans ( EP3 ) ) ; <nl> - TestableReadRepair repair = new TestableReadRepair ( command ) ; <nl> - DataResolver resolver = new DataResolver ( command , plan ( targetReplicas , QUORUM ) , repair , 0 ) ; <nl> - <nl> - Assert . assertFalse ( resolver . isDataPresent ( ) ) ; <nl> - resolver . preprocess ( response ( command , EP1 , iter ( update ( row ( 1000 , 5 , 5 ) ) . build ( ) ) , false ) ) ; <nl> - resolver . preprocess ( response ( command , EP2 , iter ( update ( row ( 2000 , 4 , 4 ) ) . build ( ) ) , false ) ) ; <nl> - resolver . preprocess ( response ( command , EP3 , EmptyIterators . unfilteredPartition ( cfm ) , false ) ) ; <nl> - <nl> - Assert . assertFalse ( repair . dataWasConsumed ( ) ) ; <nl> - <nl> - consume ( resolver . resolve ( ) ) ; <nl> - <nl> - Assert . assertTrue ( repair . dataWasConsumed ( ) ) ; <nl> - <nl> - Assert . assertTrue ( repair . sent . containsKey ( EP1 ) ) ; <nl> - Assert . assertTrue ( repair . sent . containsKey ( EP2 ) ) ; <nl> - Assert . assertFalse ( repair . sent . containsKey ( EP3 ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * If the transient replica has new data , the full replicas shoould be repaired , the transient one should not <nl> - * / <nl> - @ Test <nl> - public void transientMismatchesRepairFullReplicas ( ) <nl> - { <nl> - SinglePartitionReadCommand command = SinglePartitionReadCommand . fullPartitionRead ( cfm , nowInSec , dk ( 5 ) ) ; <nl> - EndpointsForToken targetReplicas = EndpointsForToken . of ( key . getToken ( ) , full ( EP1 ) , full ( EP2 ) , trans ( EP3 ) ) ; <nl> - TestableReadRepair < ? , ? > repair = new TestableReadRepair ( command ) ; <nl> - DataResolver resolver = new DataResolver ( command , plan ( targetReplicas , QUORUM ) , repair , 0 ) ; <nl> - <nl> - Assert . assertFalse ( resolver . isDataPresent ( ) ) ; <nl> - PartitionUpdate transData = update ( row ( 1000 , 5 , 5 ) ) . build ( ) ; <nl> - resolver . preprocess ( response ( command , EP1 , EmptyIterators . unfilteredPartition ( cfm ) , false ) ) ; <nl> - resolver . preprocess ( response ( command , EP2 , EmptyIterators . unfilteredPartition ( cfm ) , false ) ) ; <nl> - resolver . preprocess ( response ( command , EP3 , iter ( transData ) , false ) ) ; <nl> - <nl> - Assert . assertFalse ( repair . dataWasConsumed ( ) ) ; <nl> - <nl> - assertPartitionsEqual ( filter ( iter ( transData ) ) , resolver . resolve ( ) ) ; <nl> - <nl> - Assert . assertTrue ( repair . dataWasConsumed ( ) ) ; <nl> - <nl> - assertPartitionsEqual ( filter ( iter ( transData ) ) , filter ( iter ( repair . sent . get ( EP1 ) . getPartitionUpdate ( cfm ) ) ) ) ; <nl> - assertPartitionsEqual ( filter ( iter ( transData ) ) , filter ( iter ( repair . sent . get ( EP2 ) . getPartitionUpdate ( cfm ) ) ) ) ; <nl> - Assert . assertFalse ( repair . sent . containsKey ( EP3 ) ) ; <nl> - <nl> - } <nl> - <nl> - private ReplicaPlan . SharedForTokenRead plan ( EndpointsForToken replicas , ConsistencyLevel consistencyLevel ) <nl> - { <nl> - return ReplicaPlan . shared ( new ReplicaPlan . ForTokenRead ( ks , consistencyLevel , replicas , replicas ) ) ; <nl> - } <nl> - }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java 
 index a3f13c2 . . 2c186ba 100644 
 - - - a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java 
 + + + b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java 
 @ @ - 214 , 6 + 214 , 7 @ @ public class WriteResponseHandlerTest 
 @ Test 
 public void failedIdealCLIncrementsStat ( ) throws Throwable 
 { 
 + ks . metric . idealCLWriteLatency . totalLatency . dec ( ks . metric . idealCLWriteLatency . totalLatency . getCount ( ) ) ; 
 AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . LOCAL _ QUORUM , ConsistencyLevel . EACH _ QUORUM ) ; 
 
 / / Succeed in local DC 
 diff - - git a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTransientTest . java b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTransientTest . java 
 index b6c95dd . . d31d3f1 100644 
 - - - a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTransientTest . java 
 + + + b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTransientTest . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import java . util . Set ; 
 import java . util . UUID ; 
 import java . util . function . Predicate ; 
 
 + import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Sets ; 
 
 import org . apache . cassandra . dht . Murmur3Partitioner ; 
 @ @ - 153 , 7 + 154 , 8 @ @ public class WriteResponseHandlerTransientTest 
 ReplicaLayout . ForTokenWrite layout = new ReplicaLayout . ForTokenWrite ( natural , pending ) ; 
 ReplicaPlan . ForTokenWrite replicaPlan = ReplicaPlans . forWrite ( ks , ConsistencyLevel . QUORUM , layout , layout , ReplicaPlans . writeAll ) ; 
 
 - Assert . assertEquals ( EndpointsForRange . of ( full ( EP4 ) , trans ( EP6 ) ) , replicaPlan . pending ( ) ) ; 
 + Assert . assertTrue ( Iterables . elementsEqual ( EndpointsForRange . of ( full ( EP4 ) , trans ( EP6 ) ) , 
 + replicaPlan . pending ( ) ) ) ; 
 } 
 
 private static ReplicaPlan . ForTokenWrite expected ( EndpointsForToken natural , EndpointsForToken selected ) 
 @ @ - 171 , 9 + 173 , 9 @ @ public class WriteResponseHandlerTransientTest 
 private static void assertSpeculationReplicas ( ReplicaPlan . ForTokenWrite expected , EndpointsForToken replicas , Predicate < InetAddressAndPort > livePredicate ) 
 { 
 ReplicaPlan . ForTokenWrite actual = getSpeculationContext ( replicas , livePredicate ) ; 
 - Assert . assertEquals ( expected . pending ( ) , actual . pending ( ) ) ; 
 - Assert . assertEquals ( expected . live ( ) , actual . live ( ) ) ; 
 - Assert . assertEquals ( expected . contacts ( ) , actual . contacts ( ) ) ; 
 + Assert . assertTrue ( Iterables . elementsEqual ( expected . pending ( ) , actual . pending ( ) ) ) ; 
 + Assert . assertTrue ( Iterables . elementsEqual ( expected . live ( ) , actual . live ( ) ) ) ; 
 + Assert . assertTrue ( Iterables . elementsEqual ( expected . contacts ( ) , actual . contacts ( ) ) ) ; 
 } 
 
 private static Predicate < InetAddressAndPort > dead ( InetAddressAndPort . . . endpoints ) 
 diff - - git a / test / unit / org / apache / cassandra / service / reads / DataResolverTransientTest . java b / test / unit / org / apache / cassandra / service / reads / DataResolverTransientTest . java 
 deleted file mode 100644 
 index 456cec4 . . 0000000 
 - - - a / test / unit / org / apache / cassandra / service / reads / DataResolverTransientTest . java 
 + + + / dev / null 
 @ @ - 1 , 227 + 0 , 0 @ @ 
 - / * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . service . reads ; 
 - 
 - import java . util . concurrent . TimeUnit ; 
 - 
 - import com . google . common . primitives . Ints ; 
 - 
 - import org . apache . cassandra . Util ; 
 - import org . apache . cassandra . db . DecoratedKey ; 
 - import org . apache . cassandra . locator . ReplicaPlan ; 
 - import org . junit . Assert ; 
 - import org . junit . Before ; 
 - import org . junit . Test ; 
 - 
 - import org . apache . cassandra . db . Clustering ; 
 - import org . apache . cassandra . db . ConsistencyLevel ; 
 - import org . apache . cassandra . db . DeletionTime ; 
 - import org . apache . cassandra . db . EmptyIterators ; 
 - import org . apache . cassandra . db . RangeTombstone ; 
 - import org . apache . cassandra . db . SimpleBuilders ; 
 - import org . apache . cassandra . db . SinglePartitionReadCommand ; 
 - import org . apache . cassandra . db . Slice ; 
 - import org . apache . cassandra . db . partitions . PartitionUpdate ; 
 - import org . apache . cassandra . db . rows . BTreeRow ; 
 - import org . apache . cassandra . db . rows . Row ; 
 - import org . apache . cassandra . locator . EndpointsForToken ; 
 - import org . apache . cassandra . locator . ReplicaLayout ; 
 - import org . apache . cassandra . schema . TableMetadata ; 
 - import org . apache . cassandra . service . reads . repair . TestableReadRepair ; 
 - import org . apache . cassandra . utils . ByteBufferUtil ; 
 - 
 - import static org . apache . cassandra . db . ConsistencyLevel . QUORUM ; 
 - import static org . apache . cassandra . locator . Replica . fullReplica ; 
 - import static org . apache . cassandra . locator . Replica . transientReplica ; 
 - import static org . apache . cassandra . locator . ReplicaUtils . full ; 
 - import static org . apache . cassandra . locator . ReplicaUtils . trans ; 
 - 
 - / * * 
 - * Tests DataResolvers handing of transient replicas 
 - * / 
 - public class DataResolverTransientTest extends AbstractReadResponseTest 
 - { 
 - private static DecoratedKey key ; 
 - 
 - @ Before 
 - public void setUp ( ) 
 - { 
 - key = Util . dk ( " key1 " ) ; 
 - } 
 - 
 - private static PartitionUpdate . Builder update ( TableMetadata metadata , String key , Row . . . rows ) 
 - { 
 - PartitionUpdate . Builder builder = new PartitionUpdate . Builder ( metadata , dk ( key ) , metadata . regularAndStaticColumns ( ) , rows . length , false ) ; 
 - for ( Row row : rows ) 
 - { 
 - builder . add ( row ) ; 
 - } 
 - return builder ; 
 - } 
 - 
 - private static PartitionUpdate . Builder update ( Row . . . rows ) 
 - { 
 - return update ( cfm , " key1 " , rows ) ; 
 - } 
 - 
 - private static Row . SimpleBuilder rowBuilder ( int clustering ) 
 - { 
 - return new SimpleBuilders . RowBuilder ( cfm , Integer . toString ( clustering ) ) ; 
 - } 
 - 
 - private static Row row ( long timestamp , int clustering , int value ) 
 - { 
 - return rowBuilder ( clustering ) . timestamp ( timestamp ) . add ( " c1 " , Integer . toString ( value ) ) . build ( ) ; 
 - } 
 - 
 - private static DeletionTime deletion ( long timeMillis ) 
 - { 
 - TimeUnit MILLIS = TimeUnit . MILLISECONDS ; 
 - return new DeletionTime ( MILLIS . toMicros ( timeMillis ) , Ints . checkedCast ( MILLIS . toSeconds ( timeMillis ) ) ) ; 
 - } 
 - 
 - / * * 
 - * Tests that the given update doesn ' t cause data resolver to attempt to repair a transient replica 
 - * / 
 - private void assertNoTransientRepairs ( PartitionUpdate update ) 
 - { 
 - SinglePartitionReadCommand command = SinglePartitionReadCommand . fullPartitionRead ( update . metadata ( ) , nowInSec , key ) ; 
 - EndpointsForToken targetReplicas = EndpointsForToken . of ( key . getToken ( ) , full ( EP1 ) , full ( EP2 ) , trans ( EP3 ) ) ; 
 - TestableReadRepair repair = new TestableReadRepair ( command ) ; 
 - DataResolver resolver = new DataResolver ( command , plan ( targetReplicas , ConsistencyLevel . QUORUM ) , repair , 0 ) ; 
 - 
 - Assert . assertFalse ( resolver . isDataPresent ( ) ) ; 
 - resolver . preprocess ( response ( command , EP1 , iter ( update ) , false ) ) ; 
 - resolver . preprocess ( response ( command , EP2 , iter ( update ) , false ) ) ; 
 - resolver . preprocess ( response ( command , EP3 , EmptyIterators . unfilteredPartition ( update . metadata ( ) ) , false ) ) ; 
 - 
 - Assert . assertFalse ( repair . dataWasConsumed ( ) ) ; 
 - assertPartitionsEqual ( filter ( iter ( update ) ) , resolver . resolve ( ) ) ; 
 - Assert . assertTrue ( repair . dataWasConsumed ( ) ) ; 
 - Assert . assertTrue ( repair . sent . toString ( ) , repair . sent . isEmpty ( ) ) ; 
 - } 
 - 
 - @ Test 
 - public void emptyRowRepair ( ) 
 - { 
 - assertNoTransientRepairs ( update ( row ( 1000 , 4 , 4 ) , row ( 1000 , 5 , 5 ) ) . build ( ) ) ; 
 - } 
 - 
 - @ Test 
 - public void emptyPartitionDeletionRepairs ( ) 
 - { 
 - PartitionUpdate . Builder builder = update ( ) ; 
 - builder . addPartitionDeletion ( deletion ( 1999 ) ) ; 
 - assertNoTransientRepairs ( builder . build ( ) ) ; 
 - } 
 - 
 - / * * 
 - * Partition level deletion responses shouldn ' t sent data to a transient replica 
 - * / 
 - @ Test 
 - public void emptyRowDeletionRepairs ( ) 
 - { 
 - PartitionUpdate . Builder builder = update ( ) ; 
 - builder . add ( rowBuilder ( 1 ) . timestamp ( 1999 ) . delete ( ) . build ( ) ) ; 
 - assertNoTransientRepairs ( builder . build ( ) ) ; 
 - } 
 - 
 - @ Test 
 - public void emptyComplexDeletionRepair ( ) 
 - { 
 - 
 - long [ ] ts = { 1000 , 2000 } ; 
 - 
 - Row . Builder builder = BTreeRow . unsortedBuilder ( ) ; 
 - builder . newRow ( Clustering . EMPTY ) ; 
 - builder . addComplexDeletion ( m , new DeletionTime ( ts [ 0 ] - 1 , nowInSec ) ) ; 
 - assertNoTransientRepairs ( update ( cfm2 , " key " , builder . build ( ) ) . build ( ) ) ; 
 - 
 - } 
 - 
 - @ Test 
 - public void emptyRangeTombstoneRepairs ( ) 
 - { 
 - Slice slice = Slice . make ( Clustering . make ( ByteBufferUtil . bytes ( " a " ) ) , Clustering . make ( ByteBufferUtil . bytes ( " b " ) ) ) ; 
 - PartitionUpdate . Builder builder = update ( ) ; 
 - builder . add ( new RangeTombstone ( slice , deletion ( 2000 ) ) ) ; 
 - assertNoTransientRepairs ( builder . build ( ) ) ; 
 - } 
 - 
 - / * * 
 - * If the full replicas need to repair each other , repairs shouldn ' t be sent to transient replicas 
 - * / 
 - @ Test 
 - public void fullRepairsIgnoreTransientReplicas ( ) 
 - { 
 - SinglePartitionReadCommand command = SinglePartitionReadCommand . fullPartitionRead ( cfm , nowInSec , dk ( 5 ) ) ; 
 - EndpointsForToken targetReplicas = EndpointsForToken . of ( key . getToken ( ) , full ( EP1 ) , full ( EP2 ) , trans ( EP3 ) ) ; 
 - TestableReadRepair repair = new TestableReadRepair ( command ) ; 
 - DataResolver resolver = new DataResolver ( command , plan ( targetReplicas , QUORUM ) , repair , 0 ) ; 
 - 
 - Assert . assertFalse ( resolver . isDataPresent ( ) ) ; 
 - resolver . preprocess ( response ( command , EP1 , iter ( update ( row ( 1000 , 5 , 5 ) ) . build ( ) ) , false ) ) ; 
 - resolver . preprocess ( response ( command , EP2 , iter ( update ( row ( 2000 , 4 , 4 ) ) . build ( ) ) , false ) ) ; 
 - resolver . preprocess ( response ( command , EP3 , EmptyIterators . unfilteredPartition ( cfm ) , false ) ) ; 
 - 
 - Assert . assertFalse ( repair . dataWasConsumed ( ) ) ; 
 - 
 - consume ( resolver . resolve ( ) ) ; 
 - 
 - Assert . assertTrue ( repair . dataWasConsumed ( ) ) ; 
 - 
 - Assert . assertTrue ( repair . sent . containsKey ( EP1 ) ) ; 
 - Assert . assertTrue ( repair . sent . containsKey ( EP2 ) ) ; 
 - Assert . assertFalse ( repair . sent . containsKey ( EP3 ) ) ; 
 - } 
 - 
 - / * * 
 - * If the transient replica has new data , the full replicas shoould be repaired , the transient one should not 
 - * / 
 - @ Test 
 - public void transientMismatchesRepairFullReplicas ( ) 
 - { 
 - SinglePartitionReadCommand command = SinglePartitionReadCommand . fullPartitionRead ( cfm , nowInSec , dk ( 5 ) ) ; 
 - EndpointsForToken targetReplicas = EndpointsForToken . of ( key . getToken ( ) , full ( EP1 ) , full ( EP2 ) , trans ( EP3 ) ) ; 
 - TestableReadRepair < ? , ? > repair = new TestableReadRepair ( command ) ; 
 - DataResolver resolver = new DataResolver ( command , plan ( targetReplicas , QUORUM ) , repair , 0 ) ; 
 - 
 - Assert . assertFalse ( resolver . isDataPresent ( ) ) ; 
 - PartitionUpdate transData = update ( row ( 1000 , 5 , 5 ) ) . build ( ) ; 
 - resolver . preprocess ( response ( command , EP1 , EmptyIterators . unfilteredPartition ( cfm ) , false ) ) ; 
 - resolver . preprocess ( response ( command , EP2 , EmptyIterators . unfilteredPartition ( cfm ) , false ) ) ; 
 - resolver . preprocess ( response ( command , EP3 , iter ( transData ) , false ) ) ; 
 - 
 - Assert . assertFalse ( repair . dataWasConsumed ( ) ) ; 
 - 
 - assertPartitionsEqual ( filter ( iter ( transData ) ) , resolver . resolve ( ) ) ; 
 - 
 - Assert . assertTrue ( repair . dataWasConsumed ( ) ) ; 
 - 
 - assertPartitionsEqual ( filter ( iter ( transData ) ) , filter ( iter ( repair . sent . get ( EP1 ) . getPartitionUpdate ( cfm ) ) ) ) ; 
 - assertPartitionsEqual ( filter ( iter ( transData ) ) , filter ( iter ( repair . sent . get ( EP2 ) . getPartitionUpdate ( cfm ) ) ) ) ; 
 - Assert . assertFalse ( repair . sent . containsKey ( EP3 ) ) ; 
 - 
 - } 
 - 
 - private ReplicaPlan . SharedForTokenRead plan ( EndpointsForToken replicas , ConsistencyLevel consistencyLevel ) 
 - { 
 - return ReplicaPlan . shared ( new ReplicaPlan . ForTokenRead ( ks , consistencyLevel , replicas , replicas ) ) ; 
 - } 
 - }

NEAREST DIFF:
ELIMINATEDSENTENCE
