BLEU SCORE: 0.016932492841722675

TEST MSG: Fix direct Memory on architectures that do not support unaligned long access
GENERATED MSG: r / m retrieveKeysForThriftTables since it is unneeded in 2 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 4440942 . . b1fade1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 0 . 6 <nl> + * Fix direct Memory on architectures that do not support unaligned long access <nl> + ( CASSANDRA - 6628 ) <nl> * Let scrub optionally skip broken counter partitions ( CASSANDRA - 5930 ) <nl> <nl> <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 44d9d3a . . bd5db69 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 172 , 12 + 172 , 12 @ @ public class DatabaseDescriptor <nl> } <nl> <nl> if ( conf . commitlog _ total _ space _ in _ mb = = null ) <nl> - conf . commitlog _ total _ space _ in _ mb = System . getProperty ( " os . arch " ) . contains ( " 64 " ) ? 1024 : 32 ; <nl> + conf . commitlog _ total _ space _ in _ mb = hasLargeAddressSpace ( ) ? 1024 : 32 ; <nl> <nl> / * evaluate the DiskAccessMode Config directive , which also affects indexAccessMode selection * / <nl> if ( conf . disk _ access _ mode = = Config . DiskAccessMode . auto ) <nl> { <nl> - conf . disk _ access _ mode = System . getProperty ( " os . arch " ) . contains ( " 64 " ) ? Config . DiskAccessMode . mmap : Config . DiskAccessMode . standard ; <nl> + conf . disk _ access _ mode = hasLargeAddressSpace ( ) ? Config . DiskAccessMode . mmap : Config . DiskAccessMode . standard ; <nl> indexAccessMode = conf . disk _ access _ mode ; <nl> logger . info ( " DiskAccessMode ' auto ' determined to be " + conf . disk _ access _ mode + " , indexAccessMode is " + indexAccessMode ) ; <nl> } <nl> @ @ - 1323 , 4 + 1323 , 20 @ @ public class DatabaseDescriptor <nl> throw new RuntimeException ( e ) ; <nl> } <nl> } <nl> + <nl> + public static boolean hasLargeAddressSpace ( ) <nl> + { <nl> + / / currently we just check if it ' s a 64bit arch , but any we only really care if the address space is large <nl> + String datamodel = System . getProperty ( " sun . arch . data . model " ) ; <nl> + if ( datamodel ! = null ) <nl> + { <nl> + switch ( datamodel ) <nl> + { <nl> + case " 64 " : return true ; <nl> + case " 32 " : return false ; <nl> + } <nl> + } <nl> + String arch = System . getProperty ( " os . arch " ) ; <nl> + return arch . contains ( " 64 " ) | | arch . contains ( " sparcv9 " ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / util / Memory . java b / src / java / org / apache / cassandra / io / util / Memory . java <nl> index f276190 . . 263205b 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / Memory . java <nl> + + + b / src / java / org / apache / cassandra / io / util / Memory . java <nl> @ @ - 17 , 9 + 17 , 10 @ @ <nl> * / <nl> package org . apache . cassandra . io . util ; <nl> <nl> - import sun . misc . Unsafe ; <nl> + import java . nio . ByteOrder ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import sun . misc . Unsafe ; <nl> <nl> / * * <nl> * An off - heap region of memory that must be manually free ' d when no longer needed . <nl> @ @ - 30 , 6 + 31 , 16 @ @ public class Memory <nl> private static final IAllocator allocator = DatabaseDescriptor . getoffHeapMemoryAllocator ( ) ; <nl> private static final long BYTE _ ARRAY _ BASE _ OFFSET = unsafe . arrayBaseOffset ( byte [ ] . class ) ; <nl> <nl> + private static final boolean bigEndian = ByteOrder . nativeOrder ( ) . equals ( ByteOrder . BIG _ ENDIAN ) ; <nl> + private static final boolean unaligned ; <nl> + <nl> + static <nl> + { <nl> + String arch = System . getProperty ( " os . arch " ) ; <nl> + unaligned = arch . equals ( " i386 " ) | | arch . equals ( " x86 " ) <nl> + | | arch . equals ( " amd64 " ) | | arch . equals ( " x86 _ 64 " ) ; <nl> + } <nl> + <nl> protected long peer ; <nl> / / size of the memory region <nl> private final long size ; <nl> @ @ - 64 , 13 + 75 , 71 @ @ public class Memory <nl> public void setLong ( long offset , long l ) <nl> { <nl> checkPosition ( offset ) ; <nl> - unsafe . putLong ( peer + offset , l ) ; <nl> + if ( unaligned ) <nl> + { <nl> + unsafe . putLong ( peer + offset , l ) ; <nl> + } <nl> + else <nl> + { <nl> + putLongByByte ( peer + offset , l ) ; <nl> + } <nl> + } <nl> + <nl> + private void putLongByByte ( long address , long value ) <nl> + { <nl> + if ( bigEndian ) <nl> + { <nl> + unsafe . putByte ( address , ( byte ) ( value > > 56 ) ) ; <nl> + unsafe . putByte ( address + 1 , ( byte ) ( value > > 48 ) ) ; <nl> + unsafe . putByte ( address + 2 , ( byte ) ( value > > 40 ) ) ; <nl> + unsafe . putByte ( address + 3 , ( byte ) ( value > > 32 ) ) ; <nl> + unsafe . putByte ( address + 4 , ( byte ) ( value > > 24 ) ) ; <nl> + unsafe . putByte ( address + 5 , ( byte ) ( value > > 16 ) ) ; <nl> + unsafe . putByte ( address + 6 , ( byte ) ( value > > 8 ) ) ; <nl> + unsafe . putByte ( address + 7 , ( byte ) ( value ) ) ; <nl> + } <nl> + else <nl> + { <nl> + unsafe . putByte ( address + 7 , ( byte ) ( value > > 56 ) ) ; <nl> + unsafe . putByte ( address + 6 , ( byte ) ( value > > 48 ) ) ; <nl> + unsafe . putByte ( address + 5 , ( byte ) ( value > > 40 ) ) ; <nl> + unsafe . putByte ( address + 4 , ( byte ) ( value > > 32 ) ) ; <nl> + unsafe . putByte ( address + 3 , ( byte ) ( value > > 24 ) ) ; <nl> + unsafe . putByte ( address + 2 , ( byte ) ( value > > 16 ) ) ; <nl> + unsafe . putByte ( address + 1 , ( byte ) ( value > > 8 ) ) ; <nl> + unsafe . putByte ( address , ( byte ) ( value ) ) ; <nl> + } <nl> } <nl> <nl> public void setInt ( long offset , int l ) <nl> { <nl> checkPosition ( offset ) ; <nl> - unsafe . putInt ( peer + offset , l ) ; <nl> + if ( unaligned ) <nl> + { <nl> + unsafe . putInt ( peer + offset , l ) ; <nl> + } <nl> + else <nl> + { <nl> + putIntByByte ( peer + offset , l ) ; <nl> + } <nl> + } <nl> + <nl> + private void putIntByByte ( long address , int value ) <nl> + { <nl> + if ( bigEndian ) <nl> + { <nl> + unsafe . putByte ( address , ( byte ) ( value > > 24 ) ) ; <nl> + unsafe . putByte ( address + 1 , ( byte ) ( value > > 16 ) ) ; <nl> + unsafe . putByte ( address + 2 , ( byte ) ( value > > 8 ) ) ; <nl> + unsafe . putByte ( address + 3 , ( byte ) ( value ) ) ; <nl> + } <nl> + else <nl> + { <nl> + unsafe . putByte ( address + 3 , ( byte ) ( value > > 24 ) ) ; <nl> + unsafe . putByte ( address + 2 , ( byte ) ( value > > 16 ) ) ; <nl> + unsafe . putByte ( address + 1 , ( byte ) ( value > > 8 ) ) ; <nl> + unsafe . putByte ( address , ( byte ) ( value ) ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> @ @ - 108 , 13 + 177 , 57 @ @ public class Memory <nl> public long getLong ( long offset ) <nl> { <nl> checkPosition ( offset ) ; <nl> - return unsafe . getLong ( peer + offset ) ; <nl> + if ( unaligned ) { <nl> + return unsafe . getLong ( peer + offset ) ; <nl> + } else { <nl> + return getLongByByte ( peer + offset ) ; <nl> + } <nl> + } <nl> + <nl> + private long getLongByByte ( long address ) { <nl> + if ( bigEndian ) { <nl> + return ( ( ( long ) unsafe . getByte ( address ) ) < < 56 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 1 ) & 0xff ) < < 48 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 2 ) & 0xff ) < < 40 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 3 ) & 0xff ) < < 32 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 4 ) & 0xff ) < < 24 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 5 ) & 0xff ) < < 16 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 6 ) & 0xff ) < < 8 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 7 ) & 0xff ) ) ; <nl> + } else { <nl> + return ( ( ( long ) unsafe . getByte ( address + 7 ) ) < < 56 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 6 ) & 0xff ) < < 48 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 5 ) & 0xff ) < < 40 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 4 ) & 0xff ) < < 32 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 3 ) & 0xff ) < < 24 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 2 ) & 0xff ) < < 16 ) | <nl> + ( ( ( long ) unsafe . getByte ( address + 1 ) & 0xff ) < < 8 ) | <nl> + ( ( ( long ) unsafe . getByte ( address ) & 0xff ) ) ; <nl> + } <nl> } <nl> <nl> public int getInt ( long offset ) <nl> { <nl> checkPosition ( offset ) ; <nl> - return unsafe . getInt ( peer + offset ) ; <nl> + if ( unaligned ) { <nl> + return unsafe . getInt ( peer + offset ) ; <nl> + } else { <nl> + return getIntByByte ( peer + offset ) ; <nl> + } <nl> + } <nl> + <nl> + private int getIntByByte ( long address ) { <nl> + if ( bigEndian ) { <nl> + return ( ( ( int ) unsafe . getByte ( address ) ) < < 24 ) | <nl> + ( ( ( int ) unsafe . getByte ( address + 1 ) & 0xff ) < < 16 ) | <nl> + ( ( ( int ) unsafe . getByte ( address + 2 ) & 0xff ) < < 8 ) | <nl> + ( ( ( int ) unsafe . getByte ( address + 3 ) & 0xff ) ) ; <nl> + } else { <nl> + return ( ( ( int ) unsafe . getByte ( address + 3 ) ) < < 24 ) | <nl> + ( ( ( int ) unsafe . getByte ( address + 2 ) & 0xff ) < < 16 ) | <nl> + ( ( ( int ) unsafe . getByte ( address + 1 ) & 0xff ) < < 8 ) | <nl> + ( ( ( int ) unsafe . getByte ( address ) & 0xff ) ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index 60e9c25 . . 9e63c05 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 148 , 7 + 148 , 7 @ @ public class CassandraDaemon <nl> protected void setup ( ) <nl> { <nl> / / log warnings for different kinds of sub - optimal JVMs . tldr use 64 - bit Oracle > = 1 . 6u32 <nl> - if ( ! System . getProperty ( " os . arch " ) . contains ( " 64 " ) ) <nl> + if ( ! DatabaseDescriptor . hasLargeAddressSpace ( ) ) <nl> logger . info ( " 32bit JVM detected . It is recommended to run Cassandra on a 64bit JVM for better performance . " ) ; <nl> String javaVersion = System . getProperty ( " java . version " ) ; <nl> String javaVmName = System . getProperty ( " java . vm . name " ) ; <nl> diff - - git a / src / java / org / apache / cassandra / utils / FastByteComparisons . java b / src / java / org / apache / cassandra / utils / FastByteComparisons . java <nl> index c135a01 . . 4be6cd4 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / FastByteComparisons . java <nl> + + + b / src / java / org / apache / cassandra / utils / FastByteComparisons . java <nl> @ @ - 69 , 6 + 69 , 11 @ @ abstract class FastByteComparisons { <nl> * implementation if unable to do so . <nl> * / <nl> static Comparer < byte [ ] > getBestComparer ( ) { <nl> + String arch = System . getProperty ( " os . arch " ) ; <nl> + boolean unaligned = arch . equals ( " i386 " ) | | arch . equals ( " x86 " ) <nl> + | | arch . equals ( " amd64 " ) | | arch . equals ( " x86 _ 64 " ) ; <nl> + if ( ! unaligned ) <nl> + return lexicographicalComparerJavaImpl ( ) ; <nl> try { <nl> Class < ? > theClass = Class . forName ( UNSAFE _ COMPARER _ NAME ) ; <nl> <nl> @ @ - 229 , 6 + 234 , 7 @ @ abstract class FastByteComparisons { <nl> } <nl> return length1 - length2 ; <nl> } <nl> + <nl> } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlPagingRecordReader . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlPagingRecordReader . java <nl> index db77c9e . . c6eb46d 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlPagingRecordReader . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlPagingRecordReader . java <nl> @ @ - 674 , 7 + 674 , 7 @ @ public class CqlPagingRecordReader extends RecordReader < Map < String , ByteBuffer > , <nl> <nl> for ( String key : keys ) <nl> partitionBoundColumns . add ( new BoundColumn ( key ) ) ; <nl> - if ( partitionBoundColumns . size ( ) = = 0 ) <nl> + if ( partitionBoundColumns . isEmpty ( ) ) <nl> { <nl> retrieveKeysForThriftTables ( ) ; <nl> return ; <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordWriter . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordWriter . java <nl> index 76d419e . . 3d03486 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordWriter . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordWriter . java <nl> @ @ - 340 , 7 + 340 , 7 @ @ final class CqlRecordWriter extends AbstractColumnFamilyRecordWriter < Map < String , <nl> logger . debug ( " partition keys : " + keyString ) ; <nl> <nl> List < String > keys = FBUtilities . fromJsonList ( keyString ) ; <nl> - if ( keys . size ( ) = = 0 ) <nl> + if ( keys . isEmpty ( ) ) <nl> { <nl> retrieveKeysForThriftTables ( client ) ; <nl> return ; <nl> @ @ - 385 , 6 + 385 , 7 @ @ final class CqlRecordWriter extends AbstractColumnFamilyRecordWriter < Map < String , <nl> } <nl> } <nl> } <nl> + <nl> private AbstractType < ? > parseType ( String type ) throws ConfigurationException <nl> { <nl> try

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 4440942 . . b1fade1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 0 . 6 
 + * Fix direct Memory on architectures that do not support unaligned long access 
 + ( CASSANDRA - 6628 ) 
 * Let scrub optionally skip broken counter partitions ( CASSANDRA - 5930 ) 
 
 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 44d9d3a . . bd5db69 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 172 , 12 + 172 , 12 @ @ public class DatabaseDescriptor 
 } 
 
 if ( conf . commitlog _ total _ space _ in _ mb = = null ) 
 - conf . commitlog _ total _ space _ in _ mb = System . getProperty ( " os . arch " ) . contains ( " 64 " ) ? 1024 : 32 ; 
 + conf . commitlog _ total _ space _ in _ mb = hasLargeAddressSpace ( ) ? 1024 : 32 ; 
 
 / * evaluate the DiskAccessMode Config directive , which also affects indexAccessMode selection * / 
 if ( conf . disk _ access _ mode = = Config . DiskAccessMode . auto ) 
 { 
 - conf . disk _ access _ mode = System . getProperty ( " os . arch " ) . contains ( " 64 " ) ? Config . DiskAccessMode . mmap : Config . DiskAccessMode . standard ; 
 + conf . disk _ access _ mode = hasLargeAddressSpace ( ) ? Config . DiskAccessMode . mmap : Config . DiskAccessMode . standard ; 
 indexAccessMode = conf . disk _ access _ mode ; 
 logger . info ( " DiskAccessMode ' auto ' determined to be " + conf . disk _ access _ mode + " , indexAccessMode is " + indexAccessMode ) ; 
 } 
 @ @ - 1323 , 4 + 1323 , 20 @ @ public class DatabaseDescriptor 
 throw new RuntimeException ( e ) ; 
 } 
 } 
 + 
 + public static boolean hasLargeAddressSpace ( ) 
 + { 
 + / / currently we just check if it ' s a 64bit arch , but any we only really care if the address space is large 
 + String datamodel = System . getProperty ( " sun . arch . data . model " ) ; 
 + if ( datamodel ! = null ) 
 + { 
 + switch ( datamodel ) 
 + { 
 + case " 64 " : return true ; 
 + case " 32 " : return false ; 
 + } 
 + } 
 + String arch = System . getProperty ( " os . arch " ) ; 
 + return arch . contains ( " 64 " ) | | arch . contains ( " sparcv9 " ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / util / Memory . java b / src / java / org / apache / cassandra / io / util / Memory . java 
 index f276190 . . 263205b 100644 
 - - - a / src / java / org / apache / cassandra / io / util / Memory . java 
 + + + b / src / java / org / apache / cassandra / io / util / Memory . java 
 @ @ - 17 , 9 + 17 , 10 @ @ 
 * / 
 package org . apache . cassandra . io . util ; 
 
 - import sun . misc . Unsafe ; 
 + import java . nio . ByteOrder ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import sun . misc . Unsafe ; 
 
 / * * 
 * An off - heap region of memory that must be manually free ' d when no longer needed . 
 @ @ - 30 , 6 + 31 , 16 @ @ public class Memory 
 private static final IAllocator allocator = DatabaseDescriptor . getoffHeapMemoryAllocator ( ) ; 
 private static final long BYTE _ ARRAY _ BASE _ OFFSET = unsafe . arrayBaseOffset ( byte [ ] . class ) ; 
 
 + private static final boolean bigEndian = ByteOrder . nativeOrder ( ) . equals ( ByteOrder . BIG _ ENDIAN ) ; 
 + private static final boolean unaligned ; 
 + 
 + static 
 + { 
 + String arch = System . getProperty ( " os . arch " ) ; 
 + unaligned = arch . equals ( " i386 " ) | | arch . equals ( " x86 " ) 
 + | | arch . equals ( " amd64 " ) | | arch . equals ( " x86 _ 64 " ) ; 
 + } 
 + 
 protected long peer ; 
 / / size of the memory region 
 private final long size ; 
 @ @ - 64 , 13 + 75 , 71 @ @ public class Memory 
 public void setLong ( long offset , long l ) 
 { 
 checkPosition ( offset ) ; 
 - unsafe . putLong ( peer + offset , l ) ; 
 + if ( unaligned ) 
 + { 
 + unsafe . putLong ( peer + offset , l ) ; 
 + } 
 + else 
 + { 
 + putLongByByte ( peer + offset , l ) ; 
 + } 
 + } 
 + 
 + private void putLongByByte ( long address , long value ) 
 + { 
 + if ( bigEndian ) 
 + { 
 + unsafe . putByte ( address , ( byte ) ( value > > 56 ) ) ; 
 + unsafe . putByte ( address + 1 , ( byte ) ( value > > 48 ) ) ; 
 + unsafe . putByte ( address + 2 , ( byte ) ( value > > 40 ) ) ; 
 + unsafe . putByte ( address + 3 , ( byte ) ( value > > 32 ) ) ; 
 + unsafe . putByte ( address + 4 , ( byte ) ( value > > 24 ) ) ; 
 + unsafe . putByte ( address + 5 , ( byte ) ( value > > 16 ) ) ; 
 + unsafe . putByte ( address + 6 , ( byte ) ( value > > 8 ) ) ; 
 + unsafe . putByte ( address + 7 , ( byte ) ( value ) ) ; 
 + } 
 + else 
 + { 
 + unsafe . putByte ( address + 7 , ( byte ) ( value > > 56 ) ) ; 
 + unsafe . putByte ( address + 6 , ( byte ) ( value > > 48 ) ) ; 
 + unsafe . putByte ( address + 5 , ( byte ) ( value > > 40 ) ) ; 
 + unsafe . putByte ( address + 4 , ( byte ) ( value > > 32 ) ) ; 
 + unsafe . putByte ( address + 3 , ( byte ) ( value > > 24 ) ) ; 
 + unsafe . putByte ( address + 2 , ( byte ) ( value > > 16 ) ) ; 
 + unsafe . putByte ( address + 1 , ( byte ) ( value > > 8 ) ) ; 
 + unsafe . putByte ( address , ( byte ) ( value ) ) ; 
 + } 
 } 
 
 public void setInt ( long offset , int l ) 
 { 
 checkPosition ( offset ) ; 
 - unsafe . putInt ( peer + offset , l ) ; 
 + if ( unaligned ) 
 + { 
 + unsafe . putInt ( peer + offset , l ) ; 
 + } 
 + else 
 + { 
 + putIntByByte ( peer + offset , l ) ; 
 + } 
 + } 
 + 
 + private void putIntByByte ( long address , int value ) 
 + { 
 + if ( bigEndian ) 
 + { 
 + unsafe . putByte ( address , ( byte ) ( value > > 24 ) ) ; 
 + unsafe . putByte ( address + 1 , ( byte ) ( value > > 16 ) ) ; 
 + unsafe . putByte ( address + 2 , ( byte ) ( value > > 8 ) ) ; 
 + unsafe . putByte ( address + 3 , ( byte ) ( value ) ) ; 
 + } 
 + else 
 + { 
 + unsafe . putByte ( address + 3 , ( byte ) ( value > > 24 ) ) ; 
 + unsafe . putByte ( address + 2 , ( byte ) ( value > > 16 ) ) ; 
 + unsafe . putByte ( address + 1 , ( byte ) ( value > > 8 ) ) ; 
 + unsafe . putByte ( address , ( byte ) ( value ) ) ; 
 + } 
 } 
 
 / * * 
 @ @ - 108 , 13 + 177 , 57 @ @ public class Memory 
 public long getLong ( long offset ) 
 { 
 checkPosition ( offset ) ; 
 - return unsafe . getLong ( peer + offset ) ; 
 + if ( unaligned ) { 
 + return unsafe . getLong ( peer + offset ) ; 
 + } else { 
 + return getLongByByte ( peer + offset ) ; 
 + } 
 + } 
 + 
 + private long getLongByByte ( long address ) { 
 + if ( bigEndian ) { 
 + return ( ( ( long ) unsafe . getByte ( address ) ) < < 56 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 1 ) & 0xff ) < < 48 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 2 ) & 0xff ) < < 40 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 3 ) & 0xff ) < < 32 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 4 ) & 0xff ) < < 24 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 5 ) & 0xff ) < < 16 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 6 ) & 0xff ) < < 8 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 7 ) & 0xff ) ) ; 
 + } else { 
 + return ( ( ( long ) unsafe . getByte ( address + 7 ) ) < < 56 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 6 ) & 0xff ) < < 48 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 5 ) & 0xff ) < < 40 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 4 ) & 0xff ) < < 32 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 3 ) & 0xff ) < < 24 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 2 ) & 0xff ) < < 16 ) | 
 + ( ( ( long ) unsafe . getByte ( address + 1 ) & 0xff ) < < 8 ) | 
 + ( ( ( long ) unsafe . getByte ( address ) & 0xff ) ) ; 
 + } 
 } 
 
 public int getInt ( long offset ) 
 { 
 checkPosition ( offset ) ; 
 - return unsafe . getInt ( peer + offset ) ; 
 + if ( unaligned ) { 
 + return unsafe . getInt ( peer + offset ) ; 
 + } else { 
 + return getIntByByte ( peer + offset ) ; 
 + } 
 + } 
 + 
 + private int getIntByByte ( long address ) { 
 + if ( bigEndian ) { 
 + return ( ( ( int ) unsafe . getByte ( address ) ) < < 24 ) | 
 + ( ( ( int ) unsafe . getByte ( address + 1 ) & 0xff ) < < 16 ) | 
 + ( ( ( int ) unsafe . getByte ( address + 2 ) & 0xff ) < < 8 ) | 
 + ( ( ( int ) unsafe . getByte ( address + 3 ) & 0xff ) ) ; 
 + } else { 
 + return ( ( ( int ) unsafe . getByte ( address + 3 ) ) < < 24 ) | 
 + ( ( ( int ) unsafe . getByte ( address + 2 ) & 0xff ) < < 16 ) | 
 + ( ( ( int ) unsafe . getByte ( address + 1 ) & 0xff ) < < 8 ) | 
 + ( ( ( int ) unsafe . getByte ( address ) & 0xff ) ) ; 
 + } 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index 60e9c25 . . 9e63c05 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 148 , 7 + 148 , 7 @ @ public class CassandraDaemon 
 protected void setup ( ) 
 { 
 / / log warnings for different kinds of sub - optimal JVMs . tldr use 64 - bit Oracle > = 1 . 6u32 
 - if ( ! System . getProperty ( " os . arch " ) . contains ( " 64 " ) ) 
 + if ( ! DatabaseDescriptor . hasLargeAddressSpace ( ) ) 
 logger . info ( " 32bit JVM detected . It is recommended to run Cassandra on a 64bit JVM for better performance . " ) ; 
 String javaVersion = System . getProperty ( " java . version " ) ; 
 String javaVmName = System . getProperty ( " java . vm . name " ) ; 
 diff - - git a / src / java / org / apache / cassandra / utils / FastByteComparisons . java b / src / java / org / apache / cassandra / utils / FastByteComparisons . java 
 index c135a01 . . 4be6cd4 100644 
 - - - a / src / java / org / apache / cassandra / utils / FastByteComparisons . java 
 + + + b / src / java / org / apache / cassandra / utils / FastByteComparisons . java 
 @ @ - 69 , 6 + 69 , 11 @ @ abstract class FastByteComparisons { 
 * implementation if unable to do so . 
 * / 
 static Comparer < byte [ ] > getBestComparer ( ) { 
 + String arch = System . getProperty ( " os . arch " ) ; 
 + boolean unaligned = arch . equals ( " i386 " ) | | arch . equals ( " x86 " ) 
 + | | arch . equals ( " amd64 " ) | | arch . equals ( " x86 _ 64 " ) ; 
 + if ( ! unaligned ) 
 + return lexicographicalComparerJavaImpl ( ) ; 
 try { 
 Class < ? > theClass = Class . forName ( UNSAFE _ COMPARER _ NAME ) ; 
 
 @ @ - 229 , 6 + 234 , 7 @ @ abstract class FastByteComparisons { 
 } 
 return length1 - length2 ; 
 } 
 + 
 } 
 } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlPagingRecordReader . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlPagingRecordReader . java 
 index db77c9e . . c6eb46d 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlPagingRecordReader . java 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlPagingRecordReader . java 
 @ @ - 674 , 7 + 674 , 7 @ @ public class CqlPagingRecordReader extends RecordReader < Map < String , ByteBuffer > , 
 
 for ( String key : keys ) 
 partitionBoundColumns . add ( new BoundColumn ( key ) ) ; 
 - if ( partitionBoundColumns . size ( ) = = 0 ) 
 + if ( partitionBoundColumns . isEmpty ( ) ) 
 { 
 retrieveKeysForThriftTables ( ) ; 
 return ; 
 diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordWriter . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordWriter . java 
 index 76d419e . . 3d03486 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordWriter . java 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordWriter . java 
 @ @ - 340 , 7 + 340 , 7 @ @ final class CqlRecordWriter extends AbstractColumnFamilyRecordWriter < Map < String , 
 logger . debug ( " partition keys : " + keyString ) ; 
 
 List < String > keys = FBUtilities . fromJsonList ( keyString ) ; 
 - if ( keys . size ( ) = = 0 ) 
 + if ( keys . isEmpty ( ) ) 
 { 
 retrieveKeysForThriftTables ( client ) ; 
 return ; 
 @ @ - 385 , 6 + 385 , 7 @ @ final class CqlRecordWriter extends AbstractColumnFamilyRecordWriter < Map < String , 
 } 
 } 
 } 
 + 
 private AbstractType < ? > parseType ( String type ) throws ConfigurationException 
 { 
 try
