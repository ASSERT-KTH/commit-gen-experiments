BLEU SCORE: 0.03283637368030199

TEST MSG: Fix potential exception with ReversedType in DynamicCompositeType
GENERATED MSG: merge from 1 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c9b4e59 . . f3d5998 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 0 . 11 : <nl> + * Fix potential exception when using ReversedType in DynamicCompositeType <nl> + ( CASSANDRA - 7898 ) <nl> * Better validation of collection values ( CASSANDRA - 7833 ) <nl> * Track min / max timestamps correctly ( CASSANDRA - 7969 ) <nl> * Fix possible overflow while sorting CL segments for replay ( CASSANDRA - 7992 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / DynamicCompositeType . java b / src / java / org / apache / cassandra / db / marshal / DynamicCompositeType . java <nl> index 4285d9c . . cddbd1d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / DynamicCompositeType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / DynamicCompositeType . java <nl> @ @ - 119 , 6 + 119 , 16 @ @ public class DynamicCompositeType extends AbstractCompositeType <nl> { <nl> AbstractType < ? > comp1 = getComparator ( bb1 ) ; <nl> AbstractType < ? > comp2 = getComparator ( bb2 ) ; <nl> + AbstractType < ? > rawComp = comp1 ; <nl> + <nl> + / * <nl> + * If both types are ReversedType ( Type ) , we need to compare on the wrapped type ( which may differ between the two types ) to avoid <nl> + * incompatible comparisons being made . <nl> + * / <nl> + if ( ( comp1 instanceof ReversedType ) & & ( comp2 instanceof ReversedType ) ) { <nl> + comp1 = ( ( ReversedType < ? > ) comp1 ) . baseType ; <nl> + comp2 = ( ( ReversedType < ? > ) comp2 ) . baseType ; <nl> + } <nl> <nl> / / Fast test if the comparator uses singleton instances <nl> if ( comp1 ! = comp2 ) <nl> @ @ - 140 , 7 + 150 , 8 @ @ public class DynamicCompositeType extends AbstractCompositeType <nl> / / if cmp = = 0 , we ' re actually having the same type , but one that <nl> / / did not have a singleton instance . It ' s ok ( though inefficient ) . <nl> } <nl> - return comp1 ; <nl> + / / Use the raw comparator ( prior to ReversedType unwrapping ) <nl> + return rawComp ; <nl> } <nl> <nl> protected AbstractType < ? > getAndAppendComparator ( int i , ByteBuffer bb , StringBuilder sb ) <nl> diff - - git a / test / unit / org / apache / cassandra / SchemaLoader . java b / test / unit / org / apache / cassandra / SchemaLoader . java <nl> index e4929ee . . 7dea52c 100644 <nl> - - - a / test / unit / org / apache / cassandra / SchemaLoader . java <nl> + + + b / test / unit / org / apache / cassandra / SchemaLoader . java <nl> @ @ - 126 , 6 + 126 , 8 @ @ public class SchemaLoader <nl> Map < Byte , AbstractType < ? > > aliases = new HashMap < Byte , AbstractType < ? > > ( ) ; <nl> aliases . put ( ( byte ) ' b ' , BytesType . instance ) ; <nl> aliases . put ( ( byte ) ' t ' , TimeUUIDType . instance ) ; <nl> + aliases . put ( ( byte ) ' B ' , ReversedType . getInstance ( BytesType . instance ) ) ; <nl> + aliases . put ( ( byte ) ' T ' , ReversedType . getInstance ( TimeUUIDType . instance ) ) ; <nl> AbstractType < ? > dynamicComposite = DynamicCompositeType . getInstance ( aliases ) ; <nl> <nl> / / these column definitions will will be applied to the jdbc utf and integer column familes respectively . <nl> diff - - git a / test / unit / org / apache / cassandra / db / marshal / DynamicCompositeTypeTest . java b / test / unit / org / apache / cassandra / db / marshal / DynamicCompositeTypeTest . java <nl> index f8e2fb6 . . 763779d 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / marshal / DynamicCompositeTypeTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / marshal / DynamicCompositeTypeTest . java <nl> @ @ - 43 , 7 + 43 , 9 @ @ public class DynamicCompositeTypeTest extends SchemaLoader <nl> { <nl> Map < Byte , AbstractType < ? > > aliases = new HashMap < Byte , AbstractType < ? > > ( ) ; <nl> aliases . put ( ( byte ) ' b ' , BytesType . instance ) ; <nl> + aliases . put ( ( byte ) ' B ' , ReversedType . getInstance ( BytesType . instance ) ) ; <nl> aliases . put ( ( byte ) ' t ' , TimeUUIDType . instance ) ; <nl> + aliases . put ( ( byte ) ' T ' , ReversedType . getInstance ( TimeUUIDType . instance ) ) ; <nl> comparator = DynamicCompositeType . getInstance ( aliases ) ; <nl> } <nl> <nl> @ @ - 192 , 6 + 194 , 38 @ @ public class DynamicCompositeTypeTest extends SchemaLoader <nl> } <nl> <nl> @ Test <nl> + public void testFullRoundReversed ( ) throws Exception <nl> + { <nl> + Keyspace keyspace = Keyspace . open ( " Keyspace1 " ) ; <nl> + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; <nl> + <nl> + ByteBuffer cname1 = createDynamicCompositeKey ( " test1 " , null , - 1 , false , true ) ; <nl> + ByteBuffer cname2 = createDynamicCompositeKey ( " test1 " , uuids [ 0 ] , 24 , false , true ) ; <nl> + ByteBuffer cname3 = createDynamicCompositeKey ( " test1 " , uuids [ 0 ] , 42 , false , true ) ; <nl> + ByteBuffer cname4 = createDynamicCompositeKey ( " test2 " , uuids [ 0 ] , - 1 , false , true ) ; <nl> + ByteBuffer cname5 = createDynamicCompositeKey ( " test2 " , uuids [ 1 ] , 42 , false , true ) ; <nl> + <nl> + ByteBuffer key = ByteBufferUtil . bytes ( " kr " ) ; <nl> + RowMutation rm = new RowMutation ( " Keyspace1 " , key ) ; <nl> + addColumn ( rm , cname5 ) ; <nl> + addColumn ( rm , cname1 ) ; <nl> + addColumn ( rm , cname4 ) ; <nl> + addColumn ( rm , cname2 ) ; <nl> + addColumn ( rm , cname3 ) ; <nl> + rm . apply ( ) ; <nl> + <nl> + ColumnFamily cf = cfs . getColumnFamily ( QueryFilter . getIdentityFilter ( Util . dk ( " kr " ) , cfName , System . currentTimeMillis ( ) ) ) ; <nl> + <nl> + Iterator < Column > iter = cf . getSortedColumns ( ) . iterator ( ) ; <nl> + <nl> + assert iter . next ( ) . name ( ) . equals ( cname5 ) ; <nl> + assert iter . next ( ) . name ( ) . equals ( cname4 ) ; <nl> + assert iter . next ( ) . name ( ) . equals ( cname1 ) ; / / null UUID < reversed value <nl> + assert iter . next ( ) . name ( ) . equals ( cname3 ) ; <nl> + assert iter . next ( ) . name ( ) . equals ( cname2 ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testUncomparableColumns ( ) <nl> { <nl> ByteBuffer bytes = ByteBuffer . allocate ( 2 + 2 + 4 + 1 ) ; <nl> @ @ - 219 , 6 + 253 , 34 @ @ public class DynamicCompositeTypeTest extends SchemaLoader <nl> } <nl> } <nl> <nl> + @ Test <nl> + public void testUncomparableReversedColumns ( ) <nl> + { <nl> + ByteBuffer uuid = ByteBuffer . allocate ( 2 + 2 + 16 + 1 ) ; <nl> + uuid . putShort ( ( short ) ( 0x8000 | ' T ' ) ) ; <nl> + uuid . putShort ( ( short ) 16 ) ; <nl> + uuid . put ( UUIDGen . decompose ( uuids [ 0 ] ) ) ; <nl> + uuid . put ( ( byte ) 0 ) ; <nl> + uuid . rewind ( ) ; <nl> + <nl> + ByteBuffer bytes = ByteBuffer . allocate ( 2 + 2 + 4 + 1 ) ; <nl> + bytes . putShort ( ( short ) ( 0x8000 | ' B ' ) ) ; <nl> + bytes . putShort ( ( short ) 4 ) ; <nl> + bytes . put ( new byte [ 4 ] ) ; <nl> + bytes . put ( ( byte ) 0 ) ; <nl> + bytes . rewind ( ) ; <nl> + <nl> + try <nl> + { <nl> + int c = comparator . compare ( uuid , bytes ) ; <nl> + assert c = = 1 : " Expecting bytes to sort before uuid , but got " + c ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + fail ( " Shouldn ' t throw exception " ) ; <nl> + } <nl> + } <nl> + <nl> public void testCompatibility ( ) throws Exception <nl> { <nl> assert TypeParser . parse ( " DynamicCompositeType ( ) " ) . isCompatibleWith ( TypeParser . parse ( " DynamicCompositeType ( ) " ) ) ; <nl> @ @ - 236 , 6 + 298 , 13 @ @ public class DynamicCompositeTypeTest extends SchemaLoader <nl> <nl> private ByteBuffer createDynamicCompositeKey ( String s , UUID uuid , int i , boolean lastIsOne ) <nl> { <nl> + return createDynamicCompositeKey ( s , uuid , i , lastIsOne , false ) ; <nl> + } <nl> + <nl> + private ByteBuffer createDynamicCompositeKey ( String s , UUID uuid , int i , boolean lastIsOne , <nl> + final boolean reversed ) <nl> + { <nl> + String intType = ( reversed ? " ReversedType ( IntegerType ) " : " IntegerType " ) ; <nl> ByteBuffer bytes = ByteBufferUtil . bytes ( s ) ; <nl> int totalSize = 0 ; <nl> if ( s ! = null ) <nl> @ @ - 246 , 7 + 315 , 7 @ @ public class DynamicCompositeTypeTest extends SchemaLoader <nl> totalSize + = 2 + 2 + 16 + 1 ; <nl> if ( i ! = - 1 ) <nl> { <nl> - totalSize + = 2 + " IntegerType " . length ( ) + 2 + 1 + 1 ; <nl> + totalSize + = 2 + intType . length ( ) + 2 + 1 + 1 ; <nl> } <nl> } <nl> } <nl> @ @ - 255 , 20 + 324 , 20 @ @ public class DynamicCompositeTypeTest extends SchemaLoader <nl> <nl> if ( s ! = null ) <nl> { <nl> - bb . putShort ( ( short ) ( 0x8000 | ' b ' ) ) ; <nl> + bb . putShort ( ( short ) ( 0x8000 | ( reversed ? ' B ' : ' b ' ) ) ) ; <nl> bb . putShort ( ( short ) bytes . remaining ( ) ) ; <nl> bb . put ( bytes ) ; <nl> bb . put ( uuid = = null & & lastIsOne ? ( byte ) 1 : ( byte ) 0 ) ; <nl> if ( uuid ! = null ) <nl> { <nl> - bb . putShort ( ( short ) ( 0x8000 | ' t ' ) ) ; <nl> + bb . putShort ( ( short ) ( 0x8000 | ( reversed ? ' T ' : ' t ' ) ) ) ; <nl> bb . putShort ( ( short ) 16 ) ; <nl> bb . put ( UUIDGen . decompose ( uuid ) ) ; <nl> bb . put ( i = = - 1 & & lastIsOne ? ( byte ) 1 : ( byte ) 0 ) ; <nl> if ( i ! = - 1 ) <nl> { <nl> - bb . putShort ( ( short ) " IntegerType " . length ( ) ) ; <nl> - bb . put ( ByteBufferUtil . bytes ( " IntegerType " ) ) ; <nl> + bb . putShort ( ( short ) intType . length ( ) ) ; <nl> + bb . put ( ByteBufferUtil . bytes ( intType ) ) ; <nl> / / We are putting a byte only because our test use ints that fit in a byte * and * IntegerType . fromString ( ) will <nl> / / return something compatible ( i . e , putting a full int here would break ' fromStringTest ' ) <nl> bb . putShort ( ( short ) 1 ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d518830 . . 52cc2c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> * make column family backed column map pluggable and introduce unsynchronized <nl> - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) <nl> + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) <nl> * refactoring of the secondary index api ( CASSANDRA - 2982 ) <nl> * make CL > ONE reads wait for digest reconciliation before returning <nl> ( CASSANDRA - 2494 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index c316a85 . . 71c7213 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor <nl> this . reversed = reversed ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public AbstractType < ? > getComparator ( ) <nl> { <nl> return comparator ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 1239d1c . . 38bc0d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> this . cfm = cfm ; <nl> } <nl> <nl> - public ColumnFamily cloneMeShallow ( ) <nl> + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) <nl> { <nl> - ColumnFamily cf = ColumnFamily . create ( cfm ) ; <nl> + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; <nl> / / since deletion info is immutable , aliasing it is fine <nl> cf . deletionInfo . set ( deletionInfo . get ( ) ) ; <nl> return cf ; <nl> } <nl> <nl> + public ColumnFamily cloneMeShallow ( ) <nl> + { <nl> + return cloneMeShallow ( columns . getFactory ( ) ) ; <nl> + } <nl> + <nl> public AbstractType getSubComparator ( ) <nl> { <nl> IColumnSerializer s = getColumnSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0bfd1c5 . . 552d3e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> - * tombstones that are no longer relevant . * / <nl> + / * * <nl> + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> + * tombstones that are no longer relevant . <nl> + * The returned column family won ' t be thread safe . <nl> + * / <nl> ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) <nl> { <nl> / / special case slicing the entire row : <nl> @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; <nl> if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) <nl> { <nl> - ColumnFamily cf = cached . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> if ( sc ! = null ) <nl> cf . addColumn ( sc , HeapAllocator . instance ) ; <nl> return removeDeleted ( cf , gcBefore ) ; <nl> @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; <nl> - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; <nl> / / TODO this is necessary because when we collate supercolumns together , we don ' t check <nl> / / their subcolumns for relevance , so we need to do a second prune post facto here . <nl> diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> index 37f5a60 . . 624dec7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns <nl> public ISortedColumns cloneMe ( ) ; <nl> <nl> / * * <nl> + * Returns the factory used for this ISortedColumns implementation . <nl> + * / <nl> + public Factory getFactory ( ) ; <nl> + <nl> + / * * <nl> * Adds a column to this column map . <nl> * If a column with the same name is already present in the map , it will <nl> * be replaced by the newly added column . <nl> diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> index cd2488a . . 13a111a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new ThreadSafeSortedColumns ( this ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 34e83dc . . 6c3fc42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new TreeMapBackedSortedColumns ( this ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c9b4e59 . . f3d5998 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 0 . 11 : 
 + * Fix potential exception when using ReversedType in DynamicCompositeType 
 + ( CASSANDRA - 7898 ) 
 * Better validation of collection values ( CASSANDRA - 7833 ) 
 * Track min / max timestamps correctly ( CASSANDRA - 7969 ) 
 * Fix possible overflow while sorting CL segments for replay ( CASSANDRA - 7992 ) 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / DynamicCompositeType . java b / src / java / org / apache / cassandra / db / marshal / DynamicCompositeType . java 
 index 4285d9c . . cddbd1d 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / DynamicCompositeType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / DynamicCompositeType . java 
 @ @ - 119 , 6 + 119 , 16 @ @ public class DynamicCompositeType extends AbstractCompositeType 
 { 
 AbstractType < ? > comp1 = getComparator ( bb1 ) ; 
 AbstractType < ? > comp2 = getComparator ( bb2 ) ; 
 + AbstractType < ? > rawComp = comp1 ; 
 + 
 + / * 
 + * If both types are ReversedType ( Type ) , we need to compare on the wrapped type ( which may differ between the two types ) to avoid 
 + * incompatible comparisons being made . 
 + * / 
 + if ( ( comp1 instanceof ReversedType ) & & ( comp2 instanceof ReversedType ) ) { 
 + comp1 = ( ( ReversedType < ? > ) comp1 ) . baseType ; 
 + comp2 = ( ( ReversedType < ? > ) comp2 ) . baseType ; 
 + } 
 
 / / Fast test if the comparator uses singleton instances 
 if ( comp1 ! = comp2 ) 
 @ @ - 140 , 7 + 150 , 8 @ @ public class DynamicCompositeType extends AbstractCompositeType 
 / / if cmp = = 0 , we ' re actually having the same type , but one that 
 / / did not have a singleton instance . It ' s ok ( though inefficient ) . 
 } 
 - return comp1 ; 
 + / / Use the raw comparator ( prior to ReversedType unwrapping ) 
 + return rawComp ; 
 } 
 
 protected AbstractType < ? > getAndAppendComparator ( int i , ByteBuffer bb , StringBuilder sb ) 
 diff - - git a / test / unit / org / apache / cassandra / SchemaLoader . java b / test / unit / org / apache / cassandra / SchemaLoader . java 
 index e4929ee . . 7dea52c 100644 
 - - - a / test / unit / org / apache / cassandra / SchemaLoader . java 
 + + + b / test / unit / org / apache / cassandra / SchemaLoader . java 
 @ @ - 126 , 6 + 126 , 8 @ @ public class SchemaLoader 
 Map < Byte , AbstractType < ? > > aliases = new HashMap < Byte , AbstractType < ? > > ( ) ; 
 aliases . put ( ( byte ) ' b ' , BytesType . instance ) ; 
 aliases . put ( ( byte ) ' t ' , TimeUUIDType . instance ) ; 
 + aliases . put ( ( byte ) ' B ' , ReversedType . getInstance ( BytesType . instance ) ) ; 
 + aliases . put ( ( byte ) ' T ' , ReversedType . getInstance ( TimeUUIDType . instance ) ) ; 
 AbstractType < ? > dynamicComposite = DynamicCompositeType . getInstance ( aliases ) ; 
 
 / / these column definitions will will be applied to the jdbc utf and integer column familes respectively . 
 diff - - git a / test / unit / org / apache / cassandra / db / marshal / DynamicCompositeTypeTest . java b / test / unit / org / apache / cassandra / db / marshal / DynamicCompositeTypeTest . java 
 index f8e2fb6 . . 763779d 100644 
 - - - a / test / unit / org / apache / cassandra / db / marshal / DynamicCompositeTypeTest . java 
 + + + b / test / unit / org / apache / cassandra / db / marshal / DynamicCompositeTypeTest . java 
 @ @ - 43 , 7 + 43 , 9 @ @ public class DynamicCompositeTypeTest extends SchemaLoader 
 { 
 Map < Byte , AbstractType < ? > > aliases = new HashMap < Byte , AbstractType < ? > > ( ) ; 
 aliases . put ( ( byte ) ' b ' , BytesType . instance ) ; 
 + aliases . put ( ( byte ) ' B ' , ReversedType . getInstance ( BytesType . instance ) ) ; 
 aliases . put ( ( byte ) ' t ' , TimeUUIDType . instance ) ; 
 + aliases . put ( ( byte ) ' T ' , ReversedType . getInstance ( TimeUUIDType . instance ) ) ; 
 comparator = DynamicCompositeType . getInstance ( aliases ) ; 
 } 
 
 @ @ - 192 , 6 + 194 , 38 @ @ public class DynamicCompositeTypeTest extends SchemaLoader 
 } 
 
 @ Test 
 + public void testFullRoundReversed ( ) throws Exception 
 + { 
 + Keyspace keyspace = Keyspace . open ( " Keyspace1 " ) ; 
 + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; 
 + 
 + ByteBuffer cname1 = createDynamicCompositeKey ( " test1 " , null , - 1 , false , true ) ; 
 + ByteBuffer cname2 = createDynamicCompositeKey ( " test1 " , uuids [ 0 ] , 24 , false , true ) ; 
 + ByteBuffer cname3 = createDynamicCompositeKey ( " test1 " , uuids [ 0 ] , 42 , false , true ) ; 
 + ByteBuffer cname4 = createDynamicCompositeKey ( " test2 " , uuids [ 0 ] , - 1 , false , true ) ; 
 + ByteBuffer cname5 = createDynamicCompositeKey ( " test2 " , uuids [ 1 ] , 42 , false , true ) ; 
 + 
 + ByteBuffer key = ByteBufferUtil . bytes ( " kr " ) ; 
 + RowMutation rm = new RowMutation ( " Keyspace1 " , key ) ; 
 + addColumn ( rm , cname5 ) ; 
 + addColumn ( rm , cname1 ) ; 
 + addColumn ( rm , cname4 ) ; 
 + addColumn ( rm , cname2 ) ; 
 + addColumn ( rm , cname3 ) ; 
 + rm . apply ( ) ; 
 + 
 + ColumnFamily cf = cfs . getColumnFamily ( QueryFilter . getIdentityFilter ( Util . dk ( " kr " ) , cfName , System . currentTimeMillis ( ) ) ) ; 
 + 
 + Iterator < Column > iter = cf . getSortedColumns ( ) . iterator ( ) ; 
 + 
 + assert iter . next ( ) . name ( ) . equals ( cname5 ) ; 
 + assert iter . next ( ) . name ( ) . equals ( cname4 ) ; 
 + assert iter . next ( ) . name ( ) . equals ( cname1 ) ; / / null UUID < reversed value 
 + assert iter . next ( ) . name ( ) . equals ( cname3 ) ; 
 + assert iter . next ( ) . name ( ) . equals ( cname2 ) ; 
 + } 
 + 
 + @ Test 
 public void testUncomparableColumns ( ) 
 { 
 ByteBuffer bytes = ByteBuffer . allocate ( 2 + 2 + 4 + 1 ) ; 
 @ @ - 219 , 6 + 253 , 34 @ @ public class DynamicCompositeTypeTest extends SchemaLoader 
 } 
 } 
 
 + @ Test 
 + public void testUncomparableReversedColumns ( ) 
 + { 
 + ByteBuffer uuid = ByteBuffer . allocate ( 2 + 2 + 16 + 1 ) ; 
 + uuid . putShort ( ( short ) ( 0x8000 | ' T ' ) ) ; 
 + uuid . putShort ( ( short ) 16 ) ; 
 + uuid . put ( UUIDGen . decompose ( uuids [ 0 ] ) ) ; 
 + uuid . put ( ( byte ) 0 ) ; 
 + uuid . rewind ( ) ; 
 + 
 + ByteBuffer bytes = ByteBuffer . allocate ( 2 + 2 + 4 + 1 ) ; 
 + bytes . putShort ( ( short ) ( 0x8000 | ' B ' ) ) ; 
 + bytes . putShort ( ( short ) 4 ) ; 
 + bytes . put ( new byte [ 4 ] ) ; 
 + bytes . put ( ( byte ) 0 ) ; 
 + bytes . rewind ( ) ; 
 + 
 + try 
 + { 
 + int c = comparator . compare ( uuid , bytes ) ; 
 + assert c = = 1 : " Expecting bytes to sort before uuid , but got " + c ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + fail ( " Shouldn ' t throw exception " ) ; 
 + } 
 + } 
 + 
 public void testCompatibility ( ) throws Exception 
 { 
 assert TypeParser . parse ( " DynamicCompositeType ( ) " ) . isCompatibleWith ( TypeParser . parse ( " DynamicCompositeType ( ) " ) ) ; 
 @ @ - 236 , 6 + 298 , 13 @ @ public class DynamicCompositeTypeTest extends SchemaLoader 
 
 private ByteBuffer createDynamicCompositeKey ( String s , UUID uuid , int i , boolean lastIsOne ) 
 { 
 + return createDynamicCompositeKey ( s , uuid , i , lastIsOne , false ) ; 
 + } 
 + 
 + private ByteBuffer createDynamicCompositeKey ( String s , UUID uuid , int i , boolean lastIsOne , 
 + final boolean reversed ) 
 + { 
 + String intType = ( reversed ? " ReversedType ( IntegerType ) " : " IntegerType " ) ; 
 ByteBuffer bytes = ByteBufferUtil . bytes ( s ) ; 
 int totalSize = 0 ; 
 if ( s ! = null ) 
 @ @ - 246 , 7 + 315 , 7 @ @ public class DynamicCompositeTypeTest extends SchemaLoader 
 totalSize + = 2 + 2 + 16 + 1 ; 
 if ( i ! = - 1 ) 
 { 
 - totalSize + = 2 + " IntegerType " . length ( ) + 2 + 1 + 1 ; 
 + totalSize + = 2 + intType . length ( ) + 2 + 1 + 1 ; 
 } 
 } 
 } 
 @ @ - 255 , 20 + 324 , 20 @ @ public class DynamicCompositeTypeTest extends SchemaLoader 
 
 if ( s ! = null ) 
 { 
 - bb . putShort ( ( short ) ( 0x8000 | ' b ' ) ) ; 
 + bb . putShort ( ( short ) ( 0x8000 | ( reversed ? ' B ' : ' b ' ) ) ) ; 
 bb . putShort ( ( short ) bytes . remaining ( ) ) ; 
 bb . put ( bytes ) ; 
 bb . put ( uuid = = null & & lastIsOne ? ( byte ) 1 : ( byte ) 0 ) ; 
 if ( uuid ! = null ) 
 { 
 - bb . putShort ( ( short ) ( 0x8000 | ' t ' ) ) ; 
 + bb . putShort ( ( short ) ( 0x8000 | ( reversed ? ' T ' : ' t ' ) ) ) ; 
 bb . putShort ( ( short ) 16 ) ; 
 bb . put ( UUIDGen . decompose ( uuid ) ) ; 
 bb . put ( i = = - 1 & & lastIsOne ? ( byte ) 1 : ( byte ) 0 ) ; 
 if ( i ! = - 1 ) 
 { 
 - bb . putShort ( ( short ) " IntegerType " . length ( ) ) ; 
 - bb . put ( ByteBufferUtil . bytes ( " IntegerType " ) ) ; 
 + bb . putShort ( ( short ) intType . length ( ) ) ; 
 + bb . put ( ByteBufferUtil . bytes ( intType ) ) ; 
 / / We are putting a byte only because our test use ints that fit in a byte * and * IntegerType . fromString ( ) will 
 / / return something compatible ( i . e , putting a full int here would break ' fromStringTest ' ) 
 bb . putShort ( ( short ) 1 ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d518830 . . 52cc2c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 * make column family backed column map pluggable and introduce unsynchronized 
 - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) 
 + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) 
 * refactoring of the secondary index api ( CASSANDRA - 2982 ) 
 * make CL > ONE reads wait for digest reconciliation before returning 
 ( CASSANDRA - 2494 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index c316a85 . . 71c7213 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor 
 this . reversed = reversed ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public AbstractType < ? > getComparator ( ) 
 { 
 return comparator ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 1239d1c . . 38bc0d7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer 
 this . cfm = cfm ; 
 } 
 
 - public ColumnFamily cloneMeShallow ( ) 
 + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) 
 { 
 - ColumnFamily cf = ColumnFamily . create ( cfm ) ; 
 + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; 
 / / since deletion info is immutable , aliasing it is fine 
 cf . deletionInfo . set ( deletionInfo . get ( ) ) ; 
 return cf ; 
 } 
 
 + public ColumnFamily cloneMeShallow ( ) 
 + { 
 + return cloneMeShallow ( columns . getFactory ( ) ) ; 
 + } 
 + 
 public AbstractType getSubComparator ( ) 
 { 
 IColumnSerializer s = getColumnSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0bfd1c5 . . 552d3e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 - * tombstones that are no longer relevant . * / 
 + / * * 
 + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 + * tombstones that are no longer relevant . 
 + * The returned column family won ' t be thread safe . 
 + * / 
 ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) 
 { 
 / / special case slicing the entire row : 
 @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; 
 if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) 
 { 
 - ColumnFamily cf = cached . cloneMeShallow ( ) ; 
 + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 if ( sc ! = null ) 
 cf . addColumn ( sc , HeapAllocator . instance ) ; 
 return removeDeleted ( cf , gcBefore ) ; 
 @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; 
 - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; 
 + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; 
 / / TODO this is necessary because when we collate supercolumns together , we don ' t check 
 / / their subcolumns for relevance , so we need to do a second prune post facto here . 
 diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 index 37f5a60 . . 624dec7 100644 
 - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns 
 public ISortedColumns cloneMe ( ) ; 
 
 / * * 
 + * Returns the factory used for this ISortedColumns implementation . 
 + * / 
 + public Factory getFactory ( ) ; 
 + 
 + / * * 
 * Adds a column to this column map . 
 * If a column with the same name is already present in the map , it will 
 * be replaced by the newly added column . 
 diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 index cd2488a . . 13a111a 100644 
 - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new ThreadSafeSortedColumns ( this ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 34e83dc . . 6c3fc42 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new TreeMapBackedSortedColumns ( this ) ;
