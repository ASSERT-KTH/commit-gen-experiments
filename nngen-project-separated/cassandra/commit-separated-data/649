BLEU SCORE: 0.02139089632303349

TEST MSG: Make randompartitioner work with new vnode allocation
GENERATED MSG: merge from 0 . 7 ( CASSANDRA - 1951 )

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 8e39d95 . . b625a58 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 10 <nl> + * Make randompartitioner work with new vnode allocation ( CASSANDRA - 12647 ) <nl> * Fix cassandra - stress graphing ( CASSANDRA - 12237 ) <nl> * Allow filtering on partition key columns for queries without secondary indexes ( CASSANDRA - 11031 ) <nl> * Fix Cassandra Stress reporting thread model and precision ( CASSANDRA - 12585 ) <nl> diff - - git a / src / java / org / apache / cassandra / dht / RandomPartitioner . java b / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> index c063be3 . . 7c8f6ac 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> + + + b / src / java / org / apache / cassandra / dht / RandomPartitioner . java <nl> @ @ - 177 , 6 + 177 , 19 @ @ public class RandomPartitioner implements IPartitioner <nl> { <nl> return HEAP _ SIZE ; <nl> } <nl> + <nl> + public Token increaseSlightly ( ) <nl> + { <nl> + return new BigIntegerToken ( token . add ( BigInteger . ONE ) ) ; <nl> + } <nl> + <nl> + public double size ( Token next ) <nl> + { <nl> + BigIntegerToken n = ( BigIntegerToken ) next ; <nl> + BigInteger v = n . token . subtract ( token ) ; / / Overflow acceptable and desired . <nl> + double d = Math . scalb ( v . doubleValue ( ) , - 127 ) ; / / Scale so that the full range is 1 . <nl> + return d > 0 . 0 ? d : ( d + 1 . 0 ) ; / / Adjust for signed long , also making sure t . size ( t ) = = 1 . <nl> + } <nl> } <nl> <nl> public BigIntegerToken getToken ( ByteBuffer key ) <nl> diff - - git a / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java b / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java <nl> index 1b36c55 . . 482e2ac 100644 <nl> - - - a / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java <nl> + + + b / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java <nl> @ @ - 30 , 7 + 30 , 9 @ @ import org . apache . commons . math3 . stat . descriptive . SummaryStatistics ; <nl> import org . junit . Test ; <nl> <nl> import org . apache . cassandra . Util ; <nl> + import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> + import org . apache . cassandra . dht . RandomPartitioner ; <nl> import org . apache . cassandra . dht . Token ; <nl> <nl> public class ReplicationAwareTokenAllocatorTest <nl> @ @ - 489 , 10 + 491 , 10 @ @ public class ReplicationAwareTokenAllocatorTest <nl> } <nl> } ; <nl> <nl> - Murmur3Partitioner partitioner = new Murmur3Partitioner ( ) ; <nl> Random seededRand = new Random ( 2 ) ; <nl> <nl> - private void random ( Map < Token , Unit > map , TestReplicationStrategy rs , int unitCount , TokenCount tc , int perUnitCount ) <nl> + private void random ( Map < Token , Unit > map , TestReplicationStrategy rs , <nl> + int unitCount , TokenCount tc , int perUnitCount , IPartitioner partitioner ) <nl> { <nl> System . out . format ( " \ nRandom generation of % d units with % d tokens each \ n " , unitCount , perUnitCount ) ; <nl> Random rand = seededRand ; <nl> @ @ - 509 , 49 + 511 , 82 @ @ public class ReplicationAwareTokenAllocatorTest <nl> } <nl> <nl> @ Test <nl> - public void testExistingCluster ( ) <nl> + public void testExistingClusterWithRandomPartitioner ( ) <nl> + { <nl> + testExistingCluster ( new RandomPartitioner ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testExistingClusterWithMurmur3Partitioner ( ) <nl> + { <nl> + testExistingCluster ( new Murmur3Partitioner ( ) ) ; <nl> + } <nl> + <nl> + public void testExistingCluster ( IPartitioner partitioner ) <nl> { <nl> for ( int rf = 1 ; rf < = 5 ; + + rf ) <nl> { <nl> for ( int perUnitCount = 1 ; perUnitCount < = MAX _ VNODE _ COUNT ; perUnitCount * = 4 ) <nl> { <nl> - testExistingCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) ) ; <nl> - testExistingCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) ) ; <nl> + testExistingCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) , partitioner ) ; <nl> + testExistingCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) , partitioner ) ; <nl> if ( rf = = 1 ) continue ; / / Replication strategy doesn ' t matter for RF = 1 . <nl> for ( int groupSize = 4 ; groupSize < = 64 & & groupSize * rf * 4 < TARGET _ CLUSTER _ SIZE ; groupSize * = 4 ) <nl> { <nl> - testExistingCluster ( perUnitCount , fixedTokenCount , new BalancedGroupReplicationStrategy ( rf , groupSize ) ) ; <nl> - testExistingCluster ( perUnitCount , varyingTokenCount , new UnbalancedGroupReplicationStrategy ( rf , groupSize / 2 , groupSize * 2 , seededRand ) ) ; <nl> + testExistingCluster ( perUnitCount , fixedTokenCount , <nl> + new BalancedGroupReplicationStrategy ( rf , groupSize ) , partitioner ) ; <nl> + testExistingCluster ( perUnitCount , varyingTokenCount , <nl> + new UnbalancedGroupReplicationStrategy ( rf , groupSize / 2 , groupSize * 2 , seededRand ) , <nl> + partitioner ) ; <nl> } <nl> - testExistingCluster ( perUnitCount , fixedTokenCount , new FixedGroupCountReplicationStrategy ( rf , rf * 2 ) ) ; <nl> + testExistingCluster ( perUnitCount , fixedTokenCount , <nl> + new FixedGroupCountReplicationStrategy ( rf , rf * 2 ) , partitioner ) ; <nl> } <nl> } <nl> } <nl> <nl> - public void testExistingCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs ) <nl> + public void testExistingCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs , IPartitioner partitioner ) <nl> { <nl> System . out . println ( " Testing existing cluster , target " + perUnitCount + " vnodes , replication " + rs ) ; <nl> final int targetClusterSize = TARGET _ CLUSTER _ SIZE ; <nl> NavigableMap < Token , Unit > tokenMap = Maps . newTreeMap ( ) ; <nl> <nl> - random ( tokenMap , rs , targetClusterSize / 2 , tc , perUnitCount ) ; <nl> + random ( tokenMap , rs , targetClusterSize / 2 , tc , perUnitCount , partitioner ) ; <nl> <nl> ReplicationAwareTokenAllocator < Unit > t = new ReplicationAwareTokenAllocator < > ( tokenMap , rs , partitioner ) ; <nl> grow ( t , targetClusterSize * 9 / 10 , tc , perUnitCount , false ) ; <nl> grow ( t , targetClusterSize , tc , perUnitCount , true ) ; <nl> - loseAndReplace ( t , targetClusterSize / 10 , tc , perUnitCount ) ; <nl> + loseAndReplace ( t , targetClusterSize / 10 , tc , perUnitCount , partitioner ) ; <nl> System . out . println ( ) ; <nl> } <nl> <nl> @ Test <nl> - public void testNewCluster ( ) <nl> + public void testNewClusterWithRandomPartitioner ( ) <nl> { <nl> - Util . flakyTest ( this : : flakyTestNewCluster , <nl> + Util . flakyTest ( this : : flakyTestNewClusterWithRandomPartitioner , <nl> 5 , <nl> " It tends to fail sometimes due to the random selection of the tokens in the first few nodes . " ) ; <nl> } <nl> <nl> - public void flakyTestNewCluster ( ) <nl> + @ Test <nl> + public void testNewClusterWithMurmur3Partitioner ( ) <nl> + { <nl> + Util . flakyTest ( this : : flakyTestNewClusterWithMurmur3Partitioner , <nl> + 5 , <nl> + " It tends to fail sometimes due to the random selection of the tokens in the first few nodes . " ) ; <nl> + } <nl> + <nl> + public void flakyTestNewClusterWithRandomPartitioner ( ) <nl> + { <nl> + flakyTestNewCluster ( new RandomPartitioner ( ) ) ; <nl> + } <nl> + <nl> + public void flakyTestNewClusterWithMurmur3Partitioner ( ) <nl> + { <nl> + flakyTestNewCluster ( new Murmur3Partitioner ( ) ) ; <nl> + } <nl> + <nl> + public void flakyTestNewCluster ( IPartitioner partitioner ) <nl> { <nl> / / This test is flaky because the selection of the tokens for the first RF nodes ( which is random , with an <nl> / / uncontrolled seed ) can sometimes cause a pathological situation where the algorithm will find a ( close to ) <nl> @ @ - 564 , 20 + 599 , 24 @ @ public class ReplicationAwareTokenAllocatorTest <nl> { <nl> for ( int perUnitCount = 1 ; perUnitCount < = MAX _ VNODE _ COUNT ; perUnitCount * = 4 ) <nl> { <nl> - testNewCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) ) ; <nl> - testNewCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) ) ; <nl> + testNewCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) , partitioner ) ; <nl> + testNewCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) , partitioner ) ; <nl> if ( rf = = 1 ) continue ; / / Replication strategy doesn ' t matter for RF = 1 . <nl> for ( int groupSize = 4 ; groupSize < = 64 & & groupSize * rf * 8 < TARGET _ CLUSTER _ SIZE ; groupSize * = 4 ) <nl> { <nl> - testNewCluster ( perUnitCount , fixedTokenCount , new BalancedGroupReplicationStrategy ( rf , groupSize ) ) ; <nl> - testNewCluster ( perUnitCount , varyingTokenCount , new UnbalancedGroupReplicationStrategy ( rf , groupSize / 2 , groupSize * 2 , seededRand ) ) ; <nl> + testNewCluster ( perUnitCount , fixedTokenCount , <nl> + new BalancedGroupReplicationStrategy ( rf , groupSize ) , partitioner ) ; <nl> + testNewCluster ( perUnitCount , varyingTokenCount , <nl> + new UnbalancedGroupReplicationStrategy ( rf , groupSize / 2 , groupSize * 2 , seededRand ) , <nl> + partitioner ) ; <nl> } <nl> - testNewCluster ( perUnitCount , fixedTokenCount , new FixedGroupCountReplicationStrategy ( rf , rf * 2 ) ) ; <nl> + testNewCluster ( perUnitCount , fixedTokenCount , <nl> + new FixedGroupCountReplicationStrategy ( rf , rf * 2 ) , partitioner ) ; <nl> } <nl> } <nl> } <nl> <nl> - public void testNewCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs ) <nl> + public void testNewCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs , IPartitioner partitioner ) <nl> { <nl> System . out . println ( " Testing new cluster , target " + perUnitCount + " vnodes , replication " + rs ) ; <nl> final int targetClusterSize = TARGET _ CLUSTER _ SIZE ; <nl> @ @ - 586 , 11 + 625 , 12 @ @ public class ReplicationAwareTokenAllocatorTest <nl> ReplicationAwareTokenAllocator < Unit > t = new ReplicationAwareTokenAllocator < > ( tokenMap , rs , partitioner ) ; <nl> grow ( t , targetClusterSize * 2 / 5 , tc , perUnitCount , false ) ; <nl> grow ( t , targetClusterSize , tc , perUnitCount , true ) ; <nl> - loseAndReplace ( t , targetClusterSize / 5 , tc , perUnitCount ) ; <nl> + loseAndReplace ( t , targetClusterSize / 5 , tc , perUnitCount , partitioner ) ; <nl> System . out . println ( ) ; <nl> } <nl> <nl> - private void loseAndReplace ( ReplicationAwareTokenAllocator < Unit > t , int howMany , TokenCount tc , int perUnitCount ) <nl> + private void loseAndReplace ( ReplicationAwareTokenAllocator < Unit > t , int howMany , <nl> + TokenCount tc , int perUnitCount , IPartitioner partitioner ) <nl> { <nl> int fullCount = t . unitCount ( ) ; <nl> System . out . format ( " Losing % d units . " , howMany ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 54112fd . . 62def25 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 8 , 8 + 8 , 9 @ @ <nl> <nl> <nl> 0 . 7 . 2 - dev <nl> - * fix potential overflow in nodetool cfstats <nl> - * offline nodes ( CASSANDRA - 1951 ) <nl> + * fix potential overflow in nodetool cfstats ( CASSANDRA - 2057 ) <nl> + * add JVM shutdownhook to sync commitlog ( CASSANDRA - 1919 ) <nl> + * allow nodes to be up without being part of normal traffic ( CASSANDRA - 1951 ) <nl> <nl> <nl> 0 . 7 . 1 <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java <nl> index 483e93f . . 71e18f4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java <nl> @ @ - 61 , 19 + 61 , 12 @ @ public abstract class AbstractCommitLogExecutorService extends AbstractExecutorS <nl> return completedTaskCount ; <nl> } <nl> <nl> - / / cassandra is crash - only so there ' s no need to implement the shutdown methods <nl> - <nl> - public boolean isShutdown ( ) <nl> - { <nl> - return false ; <nl> - } <nl> - <nl> public boolean isTerminated ( ) <nl> { <nl> - return false ; <nl> + throw new UnsupportedOperationException ( ) ; <nl> } <nl> <nl> - public void shutdown ( ) <nl> + public boolean isShutdown ( ) <nl> { <nl> throw new UnsupportedOperationException ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> index 588c4e6 . . bc67476 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> @ @ - 31 , 6 + 31 , 8 @ @ import org . apache . cassandra . utils . WrappedRunnable ; <nl> class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService implements ICommitLogExecutorService , BatchCommitLogExecutorServiceMBean <nl> { <nl> private final BlockingQueue < CheaterFutureTask > queue ; <nl> + private final Thread appendingThread ; <nl> + private volatile boolean run = true ; <nl> <nl> public BatchCommitLogExecutorService ( ) <nl> { <nl> @ @ - 44 , 14 + 46 , 15 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> { <nl> public void runMayThrow ( ) throws Exception <nl> { <nl> - while ( true ) <nl> + while ( run ) <nl> { <nl> - processWithSyncBatch ( ) ; <nl> - completedTaskCount + + ; <nl> + if ( processWithSyncBatch ( ) ) <nl> + completedTaskCount + + ; <nl> } <nl> } <nl> } ; <nl> - new Thread ( runnable , " COMMIT - LOG - WRITER " ) . start ( ) ; <nl> + appendingThread = new Thread ( runnable , " COMMIT - LOG - WRITER " ) ; <nl> + appendingThread . start ( ) ; <nl> <nl> registerMBean ( this ) ; <nl> } <nl> @ @ - 63 , 13 + 66 , 15 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> <nl> private final ArrayList < CheaterFutureTask > incompleteTasks = new ArrayList < CheaterFutureTask > ( ) ; <nl> private final ArrayList taskValues = new ArrayList ( ) ; / / TODO not sure how to generify this <nl> - private void processWithSyncBatch ( ) throws Exception <nl> + private boolean processWithSyncBatch ( ) throws Exception <nl> { <nl> - CheaterFutureTask firstTask = queue . take ( ) ; <nl> + CheaterFutureTask firstTask = queue . poll ( 100 , TimeUnit . MILLISECONDS ) ; <nl> + if ( firstTask = = null ) <nl> + return false ; <nl> if ( ! ( firstTask . getRawCallable ( ) instanceof CommitLog . LogRecordAdder ) ) <nl> { <nl> firstTask . run ( ) ; <nl> - return ; <nl> + return true ; <nl> } <nl> <nl> / / attempt to do a bunch of LogRecordAdder ops before syncing <nl> @ @ - 105 , 6 + 110 , 7 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> { <nl> incompleteTasks . get ( i ) . set ( taskValues . get ( i ) ) ; <nl> } <nl> + return true ; <nl> } <nl> <nl> <nl> @ @ - 148 , 6 + 154 , 25 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> } <nl> } <nl> <nl> + public void shutdown ( ) <nl> + { <nl> + new Thread ( new WrappedRunnable ( ) <nl> + { <nl> + public void runMayThrow ( ) throws InterruptedException , IOException <nl> + { <nl> + while ( ! queue . isEmpty ( ) ) <nl> + Thread . sleep ( 100 ) ; <nl> + run = false ; <nl> + appendingThread . join ( ) ; <nl> + } <nl> + } , " Commitlog Shutdown " ) . start ( ) ; <nl> + } <nl> + <nl> + public void awaitTermination ( ) throws InterruptedException <nl> + { <nl> + appendingThread . join ( ) ; <nl> + } <nl> + <nl> private static class CheaterFutureTask < V > extends FutureTask < V > <nl> { <nl> private final Callable rawCallable ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index 7ebda3b . . 0e1aa7a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 114 , 45 + 114 , 9 @ @ public class CommitLog <nl> / / All we need to do is create a new one . <nl> segments . add ( new CommitLogSegment ( ) ) ; <nl> <nl> - if ( DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch ) <nl> - { <nl> - executor = new BatchCommitLogExecutorService ( ) ; <nl> - } <nl> - else <nl> - { <nl> - executor = new PeriodicCommitLogExecutorService ( ) ; <nl> - final Callable syncer = new Callable ( ) <nl> - { <nl> - public Object call ( ) throws Exception <nl> - { <nl> - sync ( ) ; <nl> - return null ; <nl> - } <nl> - } ; <nl> - <nl> - new Thread ( new Runnable ( ) <nl> - { <nl> - public void run ( ) <nl> - { <nl> - while ( true ) <nl> - { <nl> - try <nl> - { <nl> - executor . submit ( syncer ) . get ( ) ; <nl> - Thread . sleep ( DatabaseDescriptor . getCommitLogSyncPeriod ( ) ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> - catch ( ExecutionException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - } <nl> - } <nl> - } , " PERIODIC - COMMIT - LOG - SYNCER " ) . start ( ) ; <nl> - } <nl> + executor = DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch <nl> + ? new BatchCommitLogExecutorService ( ) <nl> + : new PeriodicCommitLogExecutorService ( this ) ; <nl> } <nl> <nl> public void resetUnsafe ( ) <nl> @ @ - 525 , 4 + 489 , 10 @ @ public class CommitLog <nl> return null ; <nl> } <nl> } <nl> + <nl> + public void shutdownBlocking ( ) throws InterruptedException <nl> + { <nl> + executor . shutdown ( ) ; <nl> + executor . awaitTermination ( ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java <nl> index 7acecf2 . . 20e471f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java <nl> @ @ - 38 , 4 + 38 , 9 @ @ public interface ICommitLogExecutorService extends IExecutorMBean <nl> * / <nl> public void add ( CommitLog . LogRecordAdder adder ) ; <nl> <nl> + / * * shuts down the CommitLogExecutor in an orderly fashion * / <nl> + public void shutdown ( ) ; <nl> + <nl> + / * * Blocks until shutdown is complete . * / <nl> + public void awaitTermination ( ) throws InterruptedException ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java <nl> index f44bf5e . . 228be2c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java <nl> @ @ - 21 , 35 + 21 , 71 @ @ package org . apache . cassandra . db . commitlog ; <nl> * / <nl> <nl> <nl> + import java . io . IOException ; <nl> import java . util . concurrent . * ; <nl> <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . utils . WrappedRunnable ; <nl> <nl> class PeriodicCommitLogExecutorService implements ICommitLogExecutorService , PeriodicCommitLogExecutorServiceMBean <nl> { <nl> private final BlockingQueue < Runnable > queue ; <nl> protected volatile long completedTaskCount = 0 ; <nl> + private final Thread appendingThread ; <nl> + private volatile boolean run = true ; <nl> <nl> - public PeriodicCommitLogExecutorService ( ) <nl> + public PeriodicCommitLogExecutorService ( final CommitLog commitLog ) <nl> { <nl> - this ( 1024 * Runtime . getRuntime ( ) . availableProcessors ( ) ) ; <nl> - } <nl> - <nl> - public PeriodicCommitLogExecutorService ( int queueSize ) <nl> - { <nl> - queue = new LinkedBlockingQueue < Runnable > ( queueSize ) ; <nl> + queue = new LinkedBlockingQueue < Runnable > ( 1024 * Runtime . getRuntime ( ) . availableProcessors ( ) ) ; <nl> Runnable runnable = new WrappedRunnable ( ) <nl> { <nl> public void runMayThrow ( ) throws Exception <nl> { <nl> - while ( true ) <nl> + while ( run ) <nl> { <nl> - queue . take ( ) . run ( ) ; <nl> + Runnable r = queue . poll ( 100 , TimeUnit . MILLISECONDS ) ; <nl> + if ( r = = null ) <nl> + continue ; <nl> + r . run ( ) ; <nl> completedTaskCount + + ; <nl> } <nl> + commitLog . sync ( ) ; <nl> + } <nl> + } ; <nl> + appendingThread = new Thread ( runnable , " COMMIT - LOG - WRITER " ) ; <nl> + appendingThread . start ( ) ; <nl> + <nl> + final Callable syncer = new Callable ( ) <nl> + { <nl> + public Object call ( ) throws Exception <nl> + { <nl> + commitLog . sync ( ) ; <nl> + return null ; <nl> } <nl> } ; <nl> - new Thread ( runnable , " COMMIT - LOG - WRITER " ) . start ( ) ; <nl> + <nl> + new Thread ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + while ( run ) <nl> + { <nl> + try <nl> + { <nl> + submit ( syncer ) . get ( ) ; <nl> + Thread . sleep ( DatabaseDescriptor . getCommitLogSyncPeriod ( ) ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + } <nl> + } , " PERIODIC - COMMIT - LOG - SYNCER " ) . start ( ) ; <nl> <nl> AbstractCommitLogExecutorService . registerMBean ( this ) ; <nl> } <nl> @ @ - 80 , 6 + 116 , 25 @ @ class PeriodicCommitLogExecutorService implements ICommitLogExecutorService , Per <nl> return ft ; <nl> } <nl> <nl> + public void shutdown ( ) <nl> + { <nl> + new Thread ( new WrappedRunnable ( ) <nl> + { <nl> + public void runMayThrow ( ) throws InterruptedException , IOException <nl> + { <nl> + while ( ! queue . isEmpty ( ) ) <nl> + Thread . sleep ( 100 ) ; <nl> + run = false ; <nl> + appendingThread . join ( ) ; <nl> + } <nl> + } , " Commitlog Shutdown " ) . start ( ) ; <nl> + } <nl> + <nl> + public void awaitTermination ( ) throws InterruptedException <nl> + { <nl> + appendingThread . join ( ) ; <nl> + } <nl> + <nl> public long getPendingTasks ( ) <nl> { <nl> return queue . size ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 56ffbbf . . 7ee262f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 33 , 6 + 33 , 8 @ @ import javax . management . ObjectName ; <nl> import com . google . common . base . Charsets ; <nl> import com . google . common . collect . HashMultimap ; <nl> import com . google . common . collect . Multimap ; <nl> + <nl> + import org . apache . cassandra . db . commitlog . CommitLog ; <nl> import org . apache . cassandra . locator . * ; <nl> import org . apache . log4j . Level ; <nl> import org . apache . commons . lang . StringUtils ; <nl> @ @ - 381 , 6 + 383 , 22 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> } <nl> } <nl> <nl> + / / daemon threads , like our executors ' , continue to run while shutdown hooks are invoked <nl> + Thread drainOnShutdown = new Thread ( new WrappedRunnable ( ) <nl> + { <nl> + public void runMayThrow ( ) throws ExecutionException , InterruptedException , IOException <nl> + { <nl> + ThreadPoolExecutor mutationStage = StageManager . getStage ( Stage . MUTATION ) ; <nl> + if ( ! mutationStage . isShutdown ( ) ) <nl> + { <nl> + mutationStage . shutdown ( ) ; <nl> + mutationStage . awaitTermination ( 1 , TimeUnit . SECONDS ) ; <nl> + CommitLog . instance . shutdownBlocking ( ) ; <nl> + } <nl> + } <nl> + } ) ; <nl> + Runtime . getRuntime ( ) . addShutdownHook ( drainOnShutdown ) ; <nl> + <nl> if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) <nl> { <nl> joinTokenRing ( ) ; <nl> @ @ - 1899 , 6 + 1917 , 8 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> ColumnFamilyStore . postFlushExecutor . shutdown ( ) ; <nl> ColumnFamilyStore . postFlushExecutor . awaitTermination ( 60 , TimeUnit . SECONDS ) ; <nl> <nl> + CommitLog . instance . shutdownBlocking ( ) ; <nl> + <nl> / / want to make sure that any segments deleted as a result of flushing are gone . <nl> DeletionService . waitFor ( ) ; <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 8e39d95 . . b625a58 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 10 
 + * Make randompartitioner work with new vnode allocation ( CASSANDRA - 12647 ) 
 * Fix cassandra - stress graphing ( CASSANDRA - 12237 ) 
 * Allow filtering on partition key columns for queries without secondary indexes ( CASSANDRA - 11031 ) 
 * Fix Cassandra Stress reporting thread model and precision ( CASSANDRA - 12585 ) 
 diff - - git a / src / java / org / apache / cassandra / dht / RandomPartitioner . java b / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 index c063be3 . . 7c8f6ac 100644 
 - - - a / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 + + + b / src / java / org / apache / cassandra / dht / RandomPartitioner . java 
 @ @ - 177 , 6 + 177 , 19 @ @ public class RandomPartitioner implements IPartitioner 
 { 
 return HEAP _ SIZE ; 
 } 
 + 
 + public Token increaseSlightly ( ) 
 + { 
 + return new BigIntegerToken ( token . add ( BigInteger . ONE ) ) ; 
 + } 
 + 
 + public double size ( Token next ) 
 + { 
 + BigIntegerToken n = ( BigIntegerToken ) next ; 
 + BigInteger v = n . token . subtract ( token ) ; / / Overflow acceptable and desired . 
 + double d = Math . scalb ( v . doubleValue ( ) , - 127 ) ; / / Scale so that the full range is 1 . 
 + return d > 0 . 0 ? d : ( d + 1 . 0 ) ; / / Adjust for signed long , also making sure t . size ( t ) = = 1 . 
 + } 
 } 
 
 public BigIntegerToken getToken ( ByteBuffer key ) 
 diff - - git a / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java b / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java 
 index 1b36c55 . . 482e2ac 100644 
 - - - a / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java 
 + + + b / test / long / org / apache / cassandra / dht / tokenallocator / ReplicationAwareTokenAllocatorTest . java 
 @ @ - 30 , 7 + 30 , 9 @ @ import org . apache . commons . math3 . stat . descriptive . SummaryStatistics ; 
 import org . junit . Test ; 
 
 import org . apache . cassandra . Util ; 
 + import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . dht . Murmur3Partitioner ; 
 + import org . apache . cassandra . dht . RandomPartitioner ; 
 import org . apache . cassandra . dht . Token ; 
 
 public class ReplicationAwareTokenAllocatorTest 
 @ @ - 489 , 10 + 491 , 10 @ @ public class ReplicationAwareTokenAllocatorTest 
 } 
 } ; 
 
 - Murmur3Partitioner partitioner = new Murmur3Partitioner ( ) ; 
 Random seededRand = new Random ( 2 ) ; 
 
 - private void random ( Map < Token , Unit > map , TestReplicationStrategy rs , int unitCount , TokenCount tc , int perUnitCount ) 
 + private void random ( Map < Token , Unit > map , TestReplicationStrategy rs , 
 + int unitCount , TokenCount tc , int perUnitCount , IPartitioner partitioner ) 
 { 
 System . out . format ( " \ nRandom generation of % d units with % d tokens each \ n " , unitCount , perUnitCount ) ; 
 Random rand = seededRand ; 
 @ @ - 509 , 49 + 511 , 82 @ @ public class ReplicationAwareTokenAllocatorTest 
 } 
 
 @ Test 
 - public void testExistingCluster ( ) 
 + public void testExistingClusterWithRandomPartitioner ( ) 
 + { 
 + testExistingCluster ( new RandomPartitioner ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testExistingClusterWithMurmur3Partitioner ( ) 
 + { 
 + testExistingCluster ( new Murmur3Partitioner ( ) ) ; 
 + } 
 + 
 + public void testExistingCluster ( IPartitioner partitioner ) 
 { 
 for ( int rf = 1 ; rf < = 5 ; + + rf ) 
 { 
 for ( int perUnitCount = 1 ; perUnitCount < = MAX _ VNODE _ COUNT ; perUnitCount * = 4 ) 
 { 
 - testExistingCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) ) ; 
 - testExistingCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) ) ; 
 + testExistingCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) , partitioner ) ; 
 + testExistingCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) , partitioner ) ; 
 if ( rf = = 1 ) continue ; / / Replication strategy doesn ' t matter for RF = 1 . 
 for ( int groupSize = 4 ; groupSize < = 64 & & groupSize * rf * 4 < TARGET _ CLUSTER _ SIZE ; groupSize * = 4 ) 
 { 
 - testExistingCluster ( perUnitCount , fixedTokenCount , new BalancedGroupReplicationStrategy ( rf , groupSize ) ) ; 
 - testExistingCluster ( perUnitCount , varyingTokenCount , new UnbalancedGroupReplicationStrategy ( rf , groupSize / 2 , groupSize * 2 , seededRand ) ) ; 
 + testExistingCluster ( perUnitCount , fixedTokenCount , 
 + new BalancedGroupReplicationStrategy ( rf , groupSize ) , partitioner ) ; 
 + testExistingCluster ( perUnitCount , varyingTokenCount , 
 + new UnbalancedGroupReplicationStrategy ( rf , groupSize / 2 , groupSize * 2 , seededRand ) , 
 + partitioner ) ; 
 } 
 - testExistingCluster ( perUnitCount , fixedTokenCount , new FixedGroupCountReplicationStrategy ( rf , rf * 2 ) ) ; 
 + testExistingCluster ( perUnitCount , fixedTokenCount , 
 + new FixedGroupCountReplicationStrategy ( rf , rf * 2 ) , partitioner ) ; 
 } 
 } 
 } 
 
 - public void testExistingCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs ) 
 + public void testExistingCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs , IPartitioner partitioner ) 
 { 
 System . out . println ( " Testing existing cluster , target " + perUnitCount + " vnodes , replication " + rs ) ; 
 final int targetClusterSize = TARGET _ CLUSTER _ SIZE ; 
 NavigableMap < Token , Unit > tokenMap = Maps . newTreeMap ( ) ; 
 
 - random ( tokenMap , rs , targetClusterSize / 2 , tc , perUnitCount ) ; 
 + random ( tokenMap , rs , targetClusterSize / 2 , tc , perUnitCount , partitioner ) ; 
 
 ReplicationAwareTokenAllocator < Unit > t = new ReplicationAwareTokenAllocator < > ( tokenMap , rs , partitioner ) ; 
 grow ( t , targetClusterSize * 9 / 10 , tc , perUnitCount , false ) ; 
 grow ( t , targetClusterSize , tc , perUnitCount , true ) ; 
 - loseAndReplace ( t , targetClusterSize / 10 , tc , perUnitCount ) ; 
 + loseAndReplace ( t , targetClusterSize / 10 , tc , perUnitCount , partitioner ) ; 
 System . out . println ( ) ; 
 } 
 
 @ Test 
 - public void testNewCluster ( ) 
 + public void testNewClusterWithRandomPartitioner ( ) 
 { 
 - Util . flakyTest ( this : : flakyTestNewCluster , 
 + Util . flakyTest ( this : : flakyTestNewClusterWithRandomPartitioner , 
 5 , 
 " It tends to fail sometimes due to the random selection of the tokens in the first few nodes . " ) ; 
 } 
 
 - public void flakyTestNewCluster ( ) 
 + @ Test 
 + public void testNewClusterWithMurmur3Partitioner ( ) 
 + { 
 + Util . flakyTest ( this : : flakyTestNewClusterWithMurmur3Partitioner , 
 + 5 , 
 + " It tends to fail sometimes due to the random selection of the tokens in the first few nodes . " ) ; 
 + } 
 + 
 + public void flakyTestNewClusterWithRandomPartitioner ( ) 
 + { 
 + flakyTestNewCluster ( new RandomPartitioner ( ) ) ; 
 + } 
 + 
 + public void flakyTestNewClusterWithMurmur3Partitioner ( ) 
 + { 
 + flakyTestNewCluster ( new Murmur3Partitioner ( ) ) ; 
 + } 
 + 
 + public void flakyTestNewCluster ( IPartitioner partitioner ) 
 { 
 / / This test is flaky because the selection of the tokens for the first RF nodes ( which is random , with an 
 / / uncontrolled seed ) can sometimes cause a pathological situation where the algorithm will find a ( close to ) 
 @ @ - 564 , 20 + 599 , 24 @ @ public class ReplicationAwareTokenAllocatorTest 
 { 
 for ( int perUnitCount = 1 ; perUnitCount < = MAX _ VNODE _ COUNT ; perUnitCount * = 4 ) 
 { 
 - testNewCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) ) ; 
 - testNewCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) ) ; 
 + testNewCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) , partitioner ) ; 
 + testNewCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) , partitioner ) ; 
 if ( rf = = 1 ) continue ; / / Replication strategy doesn ' t matter for RF = 1 . 
 for ( int groupSize = 4 ; groupSize < = 64 & & groupSize * rf * 8 < TARGET _ CLUSTER _ SIZE ; groupSize * = 4 ) 
 { 
 - testNewCluster ( perUnitCount , fixedTokenCount , new BalancedGroupReplicationStrategy ( rf , groupSize ) ) ; 
 - testNewCluster ( perUnitCount , varyingTokenCount , new UnbalancedGroupReplicationStrategy ( rf , groupSize / 2 , groupSize * 2 , seededRand ) ) ; 
 + testNewCluster ( perUnitCount , fixedTokenCount , 
 + new BalancedGroupReplicationStrategy ( rf , groupSize ) , partitioner ) ; 
 + testNewCluster ( perUnitCount , varyingTokenCount , 
 + new UnbalancedGroupReplicationStrategy ( rf , groupSize / 2 , groupSize * 2 , seededRand ) , 
 + partitioner ) ; 
 } 
 - testNewCluster ( perUnitCount , fixedTokenCount , new FixedGroupCountReplicationStrategy ( rf , rf * 2 ) ) ; 
 + testNewCluster ( perUnitCount , fixedTokenCount , 
 + new FixedGroupCountReplicationStrategy ( rf , rf * 2 ) , partitioner ) ; 
 } 
 } 
 } 
 
 - public void testNewCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs ) 
 + public void testNewCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs , IPartitioner partitioner ) 
 { 
 System . out . println ( " Testing new cluster , target " + perUnitCount + " vnodes , replication " + rs ) ; 
 final int targetClusterSize = TARGET _ CLUSTER _ SIZE ; 
 @ @ - 586 , 11 + 625 , 12 @ @ public class ReplicationAwareTokenAllocatorTest 
 ReplicationAwareTokenAllocator < Unit > t = new ReplicationAwareTokenAllocator < > ( tokenMap , rs , partitioner ) ; 
 grow ( t , targetClusterSize * 2 / 5 , tc , perUnitCount , false ) ; 
 grow ( t , targetClusterSize , tc , perUnitCount , true ) ; 
 - loseAndReplace ( t , targetClusterSize / 5 , tc , perUnitCount ) ; 
 + loseAndReplace ( t , targetClusterSize / 5 , tc , perUnitCount , partitioner ) ; 
 System . out . println ( ) ; 
 } 
 
 - private void loseAndReplace ( ReplicationAwareTokenAllocator < Unit > t , int howMany , TokenCount tc , int perUnitCount ) 
 + private void loseAndReplace ( ReplicationAwareTokenAllocator < Unit > t , int howMany , 
 + TokenCount tc , int perUnitCount , IPartitioner partitioner ) 
 { 
 int fullCount = t . unitCount ( ) ; 
 System . out . format ( " Losing % d units . " , howMany ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 54112fd . . 62def25 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 8 , 8 + 8 , 9 @ @ 
 
 
 0 . 7 . 2 - dev 
 - * fix potential overflow in nodetool cfstats 
 - * offline nodes ( CASSANDRA - 1951 ) 
 + * fix potential overflow in nodetool cfstats ( CASSANDRA - 2057 ) 
 + * add JVM shutdownhook to sync commitlog ( CASSANDRA - 1919 ) 
 + * allow nodes to be up without being part of normal traffic ( CASSANDRA - 1951 ) 
 
 
 0 . 7 . 1 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java 
 index 483e93f . . 71e18f4 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java 
 @ @ - 61 , 19 + 61 , 12 @ @ public abstract class AbstractCommitLogExecutorService extends AbstractExecutorS 
 return completedTaskCount ; 
 } 
 
 - / / cassandra is crash - only so there ' s no need to implement the shutdown methods 
 - 
 - public boolean isShutdown ( ) 
 - { 
 - return false ; 
 - } 
 - 
 public boolean isTerminated ( ) 
 { 
 - return false ; 
 + throw new UnsupportedOperationException ( ) ; 
 } 
 
 - public void shutdown ( ) 
 + public boolean isShutdown ( ) 
 { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 index 588c4e6 . . bc67476 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 @ @ - 31 , 6 + 31 , 8 @ @ import org . apache . cassandra . utils . WrappedRunnable ; 
 class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService implements ICommitLogExecutorService , BatchCommitLogExecutorServiceMBean 
 { 
 private final BlockingQueue < CheaterFutureTask > queue ; 
 + private final Thread appendingThread ; 
 + private volatile boolean run = true ; 
 
 public BatchCommitLogExecutorService ( ) 
 { 
 @ @ - 44 , 14 + 46 , 15 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 { 
 public void runMayThrow ( ) throws Exception 
 { 
 - while ( true ) 
 + while ( run ) 
 { 
 - processWithSyncBatch ( ) ; 
 - completedTaskCount + + ; 
 + if ( processWithSyncBatch ( ) ) 
 + completedTaskCount + + ; 
 } 
 } 
 } ; 
 - new Thread ( runnable , " COMMIT - LOG - WRITER " ) . start ( ) ; 
 + appendingThread = new Thread ( runnable , " COMMIT - LOG - WRITER " ) ; 
 + appendingThread . start ( ) ; 
 
 registerMBean ( this ) ; 
 } 
 @ @ - 63 , 13 + 66 , 15 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 
 private final ArrayList < CheaterFutureTask > incompleteTasks = new ArrayList < CheaterFutureTask > ( ) ; 
 private final ArrayList taskValues = new ArrayList ( ) ; / / TODO not sure how to generify this 
 - private void processWithSyncBatch ( ) throws Exception 
 + private boolean processWithSyncBatch ( ) throws Exception 
 { 
 - CheaterFutureTask firstTask = queue . take ( ) ; 
 + CheaterFutureTask firstTask = queue . poll ( 100 , TimeUnit . MILLISECONDS ) ; 
 + if ( firstTask = = null ) 
 + return false ; 
 if ( ! ( firstTask . getRawCallable ( ) instanceof CommitLog . LogRecordAdder ) ) 
 { 
 firstTask . run ( ) ; 
 - return ; 
 + return true ; 
 } 
 
 / / attempt to do a bunch of LogRecordAdder ops before syncing 
 @ @ - 105 , 6 + 110 , 7 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 { 
 incompleteTasks . get ( i ) . set ( taskValues . get ( i ) ) ; 
 } 
 + return true ; 
 } 
 
 
 @ @ - 148 , 6 + 154 , 25 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 } 
 } 
 
 + public void shutdown ( ) 
 + { 
 + new Thread ( new WrappedRunnable ( ) 
 + { 
 + public void runMayThrow ( ) throws InterruptedException , IOException 
 + { 
 + while ( ! queue . isEmpty ( ) ) 
 + Thread . sleep ( 100 ) ; 
 + run = false ; 
 + appendingThread . join ( ) ; 
 + } 
 + } , " Commitlog Shutdown " ) . start ( ) ; 
 + } 
 + 
 + public void awaitTermination ( ) throws InterruptedException 
 + { 
 + appendingThread . join ( ) ; 
 + } 
 + 
 private static class CheaterFutureTask < V > extends FutureTask < V > 
 { 
 private final Callable rawCallable ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index 7ebda3b . . 0e1aa7a 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 114 , 45 + 114 , 9 @ @ public class CommitLog 
 / / All we need to do is create a new one . 
 segments . add ( new CommitLogSegment ( ) ) ; 
 
 - if ( DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch ) 
 - { 
 - executor = new BatchCommitLogExecutorService ( ) ; 
 - } 
 - else 
 - { 
 - executor = new PeriodicCommitLogExecutorService ( ) ; 
 - final Callable syncer = new Callable ( ) 
 - { 
 - public Object call ( ) throws Exception 
 - { 
 - sync ( ) ; 
 - return null ; 
 - } 
 - } ; 
 - 
 - new Thread ( new Runnable ( ) 
 - { 
 - public void run ( ) 
 - { 
 - while ( true ) 
 - { 
 - try 
 - { 
 - executor . submit ( syncer ) . get ( ) ; 
 - Thread . sleep ( DatabaseDescriptor . getCommitLogSyncPeriod ( ) ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 - catch ( ExecutionException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - } 
 - } 
 - } , " PERIODIC - COMMIT - LOG - SYNCER " ) . start ( ) ; 
 - } 
 + executor = DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch 
 + ? new BatchCommitLogExecutorService ( ) 
 + : new PeriodicCommitLogExecutorService ( this ) ; 
 } 
 
 public void resetUnsafe ( ) 
 @ @ - 525 , 4 + 489 , 10 @ @ public class CommitLog 
 return null ; 
 } 
 } 
 + 
 + public void shutdownBlocking ( ) throws InterruptedException 
 + { 
 + executor . shutdown ( ) ; 
 + executor . awaitTermination ( ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java 
 index 7acecf2 . . 20e471f 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java 
 @ @ - 38 , 4 + 38 , 9 @ @ public interface ICommitLogExecutorService extends IExecutorMBean 
 * / 
 public void add ( CommitLog . LogRecordAdder adder ) ; 
 
 + / * * shuts down the CommitLogExecutor in an orderly fashion * / 
 + public void shutdown ( ) ; 
 + 
 + / * * Blocks until shutdown is complete . * / 
 + public void awaitTermination ( ) throws InterruptedException ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java 
 index f44bf5e . . 228be2c 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java 
 @ @ - 21 , 35 + 21 , 71 @ @ package org . apache . cassandra . db . commitlog ; 
 * / 
 
 
 + import java . io . IOException ; 
 import java . util . concurrent . * ; 
 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . utils . WrappedRunnable ; 
 
 class PeriodicCommitLogExecutorService implements ICommitLogExecutorService , PeriodicCommitLogExecutorServiceMBean 
 { 
 private final BlockingQueue < Runnable > queue ; 
 protected volatile long completedTaskCount = 0 ; 
 + private final Thread appendingThread ; 
 + private volatile boolean run = true ; 
 
 - public PeriodicCommitLogExecutorService ( ) 
 + public PeriodicCommitLogExecutorService ( final CommitLog commitLog ) 
 { 
 - this ( 1024 * Runtime . getRuntime ( ) . availableProcessors ( ) ) ; 
 - } 
 - 
 - public PeriodicCommitLogExecutorService ( int queueSize ) 
 - { 
 - queue = new LinkedBlockingQueue < Runnable > ( queueSize ) ; 
 + queue = new LinkedBlockingQueue < Runnable > ( 1024 * Runtime . getRuntime ( ) . availableProcessors ( ) ) ; 
 Runnable runnable = new WrappedRunnable ( ) 
 { 
 public void runMayThrow ( ) throws Exception 
 { 
 - while ( true ) 
 + while ( run ) 
 { 
 - queue . take ( ) . run ( ) ; 
 + Runnable r = queue . poll ( 100 , TimeUnit . MILLISECONDS ) ; 
 + if ( r = = null ) 
 + continue ; 
 + r . run ( ) ; 
 completedTaskCount + + ; 
 } 
 + commitLog . sync ( ) ; 
 + } 
 + } ; 
 + appendingThread = new Thread ( runnable , " COMMIT - LOG - WRITER " ) ; 
 + appendingThread . start ( ) ; 
 + 
 + final Callable syncer = new Callable ( ) 
 + { 
 + public Object call ( ) throws Exception 
 + { 
 + commitLog . sync ( ) ; 
 + return null ; 
 } 
 } ; 
 - new Thread ( runnable , " COMMIT - LOG - WRITER " ) . start ( ) ; 
 + 
 + new Thread ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + while ( run ) 
 + { 
 + try 
 + { 
 + submit ( syncer ) . get ( ) ; 
 + Thread . sleep ( DatabaseDescriptor . getCommitLogSyncPeriod ( ) ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + } 
 + } , " PERIODIC - COMMIT - LOG - SYNCER " ) . start ( ) ; 
 
 AbstractCommitLogExecutorService . registerMBean ( this ) ; 
 } 
 @ @ - 80 , 6 + 116 , 25 @ @ class PeriodicCommitLogExecutorService implements ICommitLogExecutorService , Per 
 return ft ; 
 } 
 
 + public void shutdown ( ) 
 + { 
 + new Thread ( new WrappedRunnable ( ) 
 + { 
 + public void runMayThrow ( ) throws InterruptedException , IOException 
 + { 
 + while ( ! queue . isEmpty ( ) ) 
 + Thread . sleep ( 100 ) ; 
 + run = false ; 
 + appendingThread . join ( ) ; 
 + } 
 + } , " Commitlog Shutdown " ) . start ( ) ; 
 + } 
 + 
 + public void awaitTermination ( ) throws InterruptedException 
 + { 
 + appendingThread . join ( ) ; 
 + } 
 + 
 public long getPendingTasks ( ) 
 { 
 return queue . size ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 56ffbbf . . 7ee262f 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 33 , 6 + 33 , 8 @ @ import javax . management . ObjectName ; 
 import com . google . common . base . Charsets ; 
 import com . google . common . collect . HashMultimap ; 
 import com . google . common . collect . Multimap ; 
 + 
 + import org . apache . cassandra . db . commitlog . CommitLog ; 
 import org . apache . cassandra . locator . * ; 
 import org . apache . log4j . Level ; 
 import org . apache . commons . lang . StringUtils ; 
 @ @ - 381 , 6 + 383 , 22 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 } 
 } 
 
 + / / daemon threads , like our executors ' , continue to run while shutdown hooks are invoked 
 + Thread drainOnShutdown = new Thread ( new WrappedRunnable ( ) 
 + { 
 + public void runMayThrow ( ) throws ExecutionException , InterruptedException , IOException 
 + { 
 + ThreadPoolExecutor mutationStage = StageManager . getStage ( Stage . MUTATION ) ; 
 + if ( ! mutationStage . isShutdown ( ) ) 
 + { 
 + mutationStage . shutdown ( ) ; 
 + mutationStage . awaitTermination ( 1 , TimeUnit . SECONDS ) ; 
 + CommitLog . instance . shutdownBlocking ( ) ; 
 + } 
 + } 
 + } ) ; 
 + Runtime . getRuntime ( ) . addShutdownHook ( drainOnShutdown ) ; 
 + 
 if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) 
 { 
 joinTokenRing ( ) ; 
 @ @ - 1899 , 6 + 1917 , 8 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 ColumnFamilyStore . postFlushExecutor . shutdown ( ) ; 
 ColumnFamilyStore . postFlushExecutor . awaitTermination ( 60 , TimeUnit . SECONDS ) ; 
 
 + CommitLog . instance . shutdownBlocking ( ) ; 
 + 
 / / want to make sure that any segments deleted as a result of flushing are gone . 
 DeletionService . waitFor ( ) ; 

