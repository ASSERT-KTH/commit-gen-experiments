BLEU SCORE: 0.12872632311973017

TEST MSG: Fix NativeSSTableLoaderClient post CASSANDRA - 10365
GENERATED MSG: Fix dtest failures caused by CASSANDRA - 8143

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / schema / Types . java b / src / java / org / apache / cassandra / schema / Types . java <nl> index 4f3d78c . . 258be9f 100644 <nl> - - - a / src / java / org / apache / cassandra / schema / Types . java <nl> + + + b / src / java / org / apache / cassandra / schema / Types . java <nl> @ @ - 237 , 7 + 237 , 7 @ @ public final class Types implements Iterable < UserType > <nl> return Types . builder ( ) . add ( types ) . build ( ) ; <nl> } <nl> <nl> - void add ( String name , List < String > fieldNames , List < String > fieldTypes ) <nl> + public void add ( String name , List < String > fieldNames , List < String > fieldTypes ) <nl> { <nl> List < CQL3Type . Raw > rawFieldTypes = <nl> fieldTypes . stream ( ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / NativeSSTableLoaderClient . java b / src / java / org / apache / cassandra / utils / NativeSSTableLoaderClient . java <nl> index 8dff532 . . cebee4a 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / NativeSSTableLoaderClient . java <nl> + + + b / src / java / org / apache / cassandra / utils / NativeSSTableLoaderClient . java <nl> @ @ - 30 , 7 + 30 , 9 @ @ import org . apache . cassandra . dht . * ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . dht . Token . TokenFactory ; <nl> import org . apache . cassandra . io . sstable . SSTableLoader ; <nl> + import org . apache . cassandra . schema . CQLTypeParser ; <nl> import org . apache . cassandra . schema . SchemaKeyspace ; <nl> + import org . apache . cassandra . schema . Types ; <nl> <nl> public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> { <nl> @ @ - 79 , 9 + 81 , 11 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> addRangeForEndpoint ( range , endpoint . getAddress ( ) ) ; <nl> } <nl> <nl> - tables . putAll ( fetchTablesMetadata ( keyspace , session , partitioner ) ) ; <nl> + Types types = fetchTypes ( keyspace , session ) ; <nl> + <nl> + tables . putAll ( fetchTables ( keyspace , session , partitioner , types ) ) ; <nl> / / We only need the CFMetaData for the views , so we only load that . <nl> - tables . putAll ( fetchViewMetadata ( keyspace , session , partitioner ) ) ; <nl> + tables . putAll ( fetchViews ( keyspace , session , partitioner , types ) ) ; <nl> } <nl> } <nl> <nl> @ @ - 96 , 6 + 100 , 21 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> tables . put ( cfm . cfName , cfm ) ; <nl> } <nl> <nl> + private static Types fetchTypes ( String keyspace , Session session ) <nl> + { <nl> + String query = String . format ( " SELECT * FROM % s . % s WHERE keyspace _ name = ? " , SchemaKeyspace . NAME , SchemaKeyspace . TYPES ) ; <nl> + <nl> + Types . RawBuilder types = Types . rawBuilder ( keyspace ) ; <nl> + for ( Row row : session . execute ( query , keyspace ) ) <nl> + { <nl> + String name = row . getString ( " type _ name " ) ; <nl> + List < String > fieldNames = row . getList ( " field _ names " , String . class ) ; <nl> + List < String > fieldTypes = row . getList ( " field _ types " , String . class ) ; <nl> + types . add ( name , fieldNames , fieldTypes ) ; <nl> + } <nl> + return types . build ( ) ; <nl> + } <nl> + <nl> / * <nl> * The following is a slightly simplified but otherwise duplicated version of <nl> * SchemaKeyspace . createTableFromTableRowAndColumnRows ( ) . <nl> @ @ - 105 , 7 + 124 , 7 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> * Note : It is not safe for this class to use static methods from SchemaKeyspace ( static final fields are ok ) <nl> * as that triggers initialization of the class , which fails in client mode . <nl> * / <nl> - private static Map < String , CFMetaData > fetchTablesMetadata ( String keyspace , Session session , IPartitioner partitioner ) <nl> + private static Map < String , CFMetaData > fetchTables ( String keyspace , Session session , IPartitioner partitioner , Types types ) <nl> { <nl> Map < String , CFMetaData > tables = new HashMap < > ( ) ; <nl> String query = String . format ( " SELECT * FROM % s . % s WHERE keyspace _ name = ? " , SchemaKeyspace . NAME , SchemaKeyspace . TABLES ) ; <nl> @ @ - 113 , 7 + 132 , 7 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> for ( Row row : session . execute ( query , keyspace ) ) <nl> { <nl> String name = row . getString ( " table _ name " ) ; <nl> - tables . put ( name , createTableMetadata ( keyspace , session , partitioner , false , row , name ) ) ; <nl> + tables . put ( name , createTableMetadata ( keyspace , session , partitioner , false , row , name , types ) ) ; <nl> } <nl> <nl> return tables ; <nl> @ @ - 122 , 7 + 141 , 7 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> / * <nl> * In the case where we are creating View CFMetaDatas , we <nl> * / <nl> - private static Map < String , CFMetaData > fetchViewMetadata ( String keyspace , Session session , IPartitioner partitioner ) <nl> + private static Map < String , CFMetaData > fetchViews ( String keyspace , Session session , IPartitioner partitioner , Types types ) <nl> { <nl> Map < String , CFMetaData > tables = new HashMap < > ( ) ; <nl> String query = String . format ( " SELECT * FROM % s . % s WHERE keyspace _ name = ? " , SchemaKeyspace . NAME , SchemaKeyspace . VIEWS ) ; <nl> @ @ - 130 , 18 + 149 , 22 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> for ( Row row : session . execute ( query , keyspace ) ) <nl> { <nl> String name = row . getString ( " view _ name " ) ; <nl> - tables . put ( name , createTableMetadata ( keyspace , session , partitioner , true , row , name ) ) ; <nl> + tables . put ( name , createTableMetadata ( keyspace , session , partitioner , true , row , name , types ) ) ; <nl> } <nl> <nl> return tables ; <nl> } <nl> <nl> - private static CFMetaData createTableMetadata ( String keyspace , Session session , IPartitioner partitioner , boolean isView , Row row , String name ) <nl> + private static CFMetaData createTableMetadata ( String keyspace , <nl> + Session session , <nl> + IPartitioner partitioner , <nl> + boolean isView , <nl> + Row row , <nl> + String name , <nl> + Types types ) <nl> { <nl> UUID id = row . getUUID ( " id " ) ; <nl> - Set < CFMetaData . Flag > flags = row . isNull ( " flags " ) <nl> - ? Collections . emptySet ( ) <nl> - : CFMetaData . flagsFromStrings ( row . getSet ( " flags " , String . class ) ) ; <nl> + Set < CFMetaData . Flag > flags = CFMetaData . flagsFromStrings ( row . getSet ( " flags " , String . class ) ) ; <nl> <nl> boolean isSuper = flags . contains ( CFMetaData . Flag . SUPER ) ; <nl> boolean isCounter = flags . contains ( CFMetaData . Flag . COUNTER ) ; <nl> @ @ - 154 , 7 + 177 , 7 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> <nl> List < ColumnDefinition > defs = new ArrayList < > ( ) ; <nl> for ( Row colRow : session . execute ( columnsQuery , keyspace , name ) ) <nl> - defs . add ( createDefinitionFromRow ( colRow , keyspace , name ) ) ; <nl> + defs . add ( createDefinitionFromRow ( colRow , keyspace , name , types ) ) ; <nl> <nl> return CFMetaData . create ( keyspace , <nl> name , <nl> @ @ - 168 , 10 + 191 , 15 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client <nl> partitioner ) ; <nl> } <nl> <nl> - private static ColumnDefinition createDefinitionFromRow ( Row row , String keyspace , String table ) <nl> + private static ColumnDefinition createDefinitionFromRow ( Row row , String keyspace , String table , Types types ) <nl> { <nl> ColumnIdentifier name = ColumnIdentifier . getInterned ( row . getBytes ( " column _ name _ bytes " ) , row . getString ( " column _ name " ) ) ; <nl> - AbstractType < ? > type = TypeParser . parse ( row . getString ( " type " ) ) ; <nl> + <nl> + ClusteringOrder order = ClusteringOrder . valueOf ( row . getString ( " clustering _ order " ) . toUpperCase ( ) ) ; <nl> + AbstractType < ? > type = CQLTypeParser . parse ( keyspace , row . getString ( " type " ) , types ) ; <nl> + if ( order = = ClusteringOrder . DESC ) <nl> + type = ReversedType . getInstance ( type ) ; <nl> + <nl> int position = row . getInt ( " position " ) ; <nl> ColumnDefinition . Kind kind = ColumnDefinition . Kind . valueOf ( row . getString ( " kind " ) . toUpperCase ( ) ) ; <nl> return new ColumnDefinition ( keyspace , table , name , type , position , kind ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / schema / Types . java b / src / java / org / apache / cassandra / schema / Types . java 
 index 4f3d78c . . 258be9f 100644 
 - - - a / src / java / org / apache / cassandra / schema / Types . java 
 + + + b / src / java / org / apache / cassandra / schema / Types . java 
 @ @ - 237 , 7 + 237 , 7 @ @ public final class Types implements Iterable < UserType > 
 return Types . builder ( ) . add ( types ) . build ( ) ; 
 } 
 
 - void add ( String name , List < String > fieldNames , List < String > fieldTypes ) 
 + public void add ( String name , List < String > fieldNames , List < String > fieldTypes ) 
 { 
 List < CQL3Type . Raw > rawFieldTypes = 
 fieldTypes . stream ( ) 
 diff - - git a / src / java / org / apache / cassandra / utils / NativeSSTableLoaderClient . java b / src / java / org / apache / cassandra / utils / NativeSSTableLoaderClient . java 
 index 8dff532 . . cebee4a 100644 
 - - - a / src / java / org / apache / cassandra / utils / NativeSSTableLoaderClient . java 
 + + + b / src / java / org / apache / cassandra / utils / NativeSSTableLoaderClient . java 
 @ @ - 30 , 7 + 30 , 9 @ @ import org . apache . cassandra . dht . * ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . dht . Token . TokenFactory ; 
 import org . apache . cassandra . io . sstable . SSTableLoader ; 
 + import org . apache . cassandra . schema . CQLTypeParser ; 
 import org . apache . cassandra . schema . SchemaKeyspace ; 
 + import org . apache . cassandra . schema . Types ; 
 
 public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 { 
 @ @ - 79 , 9 + 81 , 11 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 addRangeForEndpoint ( range , endpoint . getAddress ( ) ) ; 
 } 
 
 - tables . putAll ( fetchTablesMetadata ( keyspace , session , partitioner ) ) ; 
 + Types types = fetchTypes ( keyspace , session ) ; 
 + 
 + tables . putAll ( fetchTables ( keyspace , session , partitioner , types ) ) ; 
 / / We only need the CFMetaData for the views , so we only load that . 
 - tables . putAll ( fetchViewMetadata ( keyspace , session , partitioner ) ) ; 
 + tables . putAll ( fetchViews ( keyspace , session , partitioner , types ) ) ; 
 } 
 } 
 
 @ @ - 96 , 6 + 100 , 21 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 tables . put ( cfm . cfName , cfm ) ; 
 } 
 
 + private static Types fetchTypes ( String keyspace , Session session ) 
 + { 
 + String query = String . format ( " SELECT * FROM % s . % s WHERE keyspace _ name = ? " , SchemaKeyspace . NAME , SchemaKeyspace . TYPES ) ; 
 + 
 + Types . RawBuilder types = Types . rawBuilder ( keyspace ) ; 
 + for ( Row row : session . execute ( query , keyspace ) ) 
 + { 
 + String name = row . getString ( " type _ name " ) ; 
 + List < String > fieldNames = row . getList ( " field _ names " , String . class ) ; 
 + List < String > fieldTypes = row . getList ( " field _ types " , String . class ) ; 
 + types . add ( name , fieldNames , fieldTypes ) ; 
 + } 
 + return types . build ( ) ; 
 + } 
 + 
 / * 
 * The following is a slightly simplified but otherwise duplicated version of 
 * SchemaKeyspace . createTableFromTableRowAndColumnRows ( ) . 
 @ @ - 105 , 7 + 124 , 7 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 * Note : It is not safe for this class to use static methods from SchemaKeyspace ( static final fields are ok ) 
 * as that triggers initialization of the class , which fails in client mode . 
 * / 
 - private static Map < String , CFMetaData > fetchTablesMetadata ( String keyspace , Session session , IPartitioner partitioner ) 
 + private static Map < String , CFMetaData > fetchTables ( String keyspace , Session session , IPartitioner partitioner , Types types ) 
 { 
 Map < String , CFMetaData > tables = new HashMap < > ( ) ; 
 String query = String . format ( " SELECT * FROM % s . % s WHERE keyspace _ name = ? " , SchemaKeyspace . NAME , SchemaKeyspace . TABLES ) ; 
 @ @ - 113 , 7 + 132 , 7 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 for ( Row row : session . execute ( query , keyspace ) ) 
 { 
 String name = row . getString ( " table _ name " ) ; 
 - tables . put ( name , createTableMetadata ( keyspace , session , partitioner , false , row , name ) ) ; 
 + tables . put ( name , createTableMetadata ( keyspace , session , partitioner , false , row , name , types ) ) ; 
 } 
 
 return tables ; 
 @ @ - 122 , 7 + 141 , 7 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 / * 
 * In the case where we are creating View CFMetaDatas , we 
 * / 
 - private static Map < String , CFMetaData > fetchViewMetadata ( String keyspace , Session session , IPartitioner partitioner ) 
 + private static Map < String , CFMetaData > fetchViews ( String keyspace , Session session , IPartitioner partitioner , Types types ) 
 { 
 Map < String , CFMetaData > tables = new HashMap < > ( ) ; 
 String query = String . format ( " SELECT * FROM % s . % s WHERE keyspace _ name = ? " , SchemaKeyspace . NAME , SchemaKeyspace . VIEWS ) ; 
 @ @ - 130 , 18 + 149 , 22 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 for ( Row row : session . execute ( query , keyspace ) ) 
 { 
 String name = row . getString ( " view _ name " ) ; 
 - tables . put ( name , createTableMetadata ( keyspace , session , partitioner , true , row , name ) ) ; 
 + tables . put ( name , createTableMetadata ( keyspace , session , partitioner , true , row , name , types ) ) ; 
 } 
 
 return tables ; 
 } 
 
 - private static CFMetaData createTableMetadata ( String keyspace , Session session , IPartitioner partitioner , boolean isView , Row row , String name ) 
 + private static CFMetaData createTableMetadata ( String keyspace , 
 + Session session , 
 + IPartitioner partitioner , 
 + boolean isView , 
 + Row row , 
 + String name , 
 + Types types ) 
 { 
 UUID id = row . getUUID ( " id " ) ; 
 - Set < CFMetaData . Flag > flags = row . isNull ( " flags " ) 
 - ? Collections . emptySet ( ) 
 - : CFMetaData . flagsFromStrings ( row . getSet ( " flags " , String . class ) ) ; 
 + Set < CFMetaData . Flag > flags = CFMetaData . flagsFromStrings ( row . getSet ( " flags " , String . class ) ) ; 
 
 boolean isSuper = flags . contains ( CFMetaData . Flag . SUPER ) ; 
 boolean isCounter = flags . contains ( CFMetaData . Flag . COUNTER ) ; 
 @ @ - 154 , 7 + 177 , 7 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 
 List < ColumnDefinition > defs = new ArrayList < > ( ) ; 
 for ( Row colRow : session . execute ( columnsQuery , keyspace , name ) ) 
 - defs . add ( createDefinitionFromRow ( colRow , keyspace , name ) ) ; 
 + defs . add ( createDefinitionFromRow ( colRow , keyspace , name , types ) ) ; 
 
 return CFMetaData . create ( keyspace , 
 name , 
 @ @ - 168 , 10 + 191 , 15 @ @ public class NativeSSTableLoaderClient extends SSTableLoader . Client 
 partitioner ) ; 
 } 
 
 - private static ColumnDefinition createDefinitionFromRow ( Row row , String keyspace , String table ) 
 + private static ColumnDefinition createDefinitionFromRow ( Row row , String keyspace , String table , Types types ) 
 { 
 ColumnIdentifier name = ColumnIdentifier . getInterned ( row . getBytes ( " column _ name _ bytes " ) , row . getString ( " column _ name " ) ) ; 
 - AbstractType < ? > type = TypeParser . parse ( row . getString ( " type " ) ) ; 
 + 
 + ClusteringOrder order = ClusteringOrder . valueOf ( row . getString ( " clustering _ order " ) . toUpperCase ( ) ) ; 
 + AbstractType < ? > type = CQLTypeParser . parse ( keyspace , row . getString ( " type " ) , types ) ; 
 + if ( order = = ClusteringOrder . DESC ) 
 + type = ReversedType . getInstance ( type ) ; 
 + 
 int position = row . getInt ( " position " ) ; 
 ColumnDefinition . Kind kind = ColumnDefinition . Kind . valueOf ( row . getString ( " kind " ) . toUpperCase ( ) ) ; 
 return new ColumnDefinition ( keyspace , table , name , type , position , kind ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
