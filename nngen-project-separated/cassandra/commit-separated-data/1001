BLEU SCORE: 0.027611988917697356

TEST MSG: Add extension points in storage and streaming classes
GENERATED MSG: Fix SSTable not released if stream session fails

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 9b113c4 . . fa95063 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1217 , 6 + 1217 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> DecoratedKey key = update . partitionKey ( ) ; <nl> invalidateCachedPartition ( key ) ; <nl> metric . samplers . get ( Sampler . WRITES ) . addSample ( key . getKey ( ) , key . hashCode ( ) , 1 ) ; <nl> + StorageHook . instance . reportWrite ( metadata . cfId , update ) ; <nl> metric . writeLatency . addNano ( System . nanoTime ( ) - start ) ; <nl> if ( timeDelta < Long . MAX _ VALUE ) <nl> metric . colUpdateTimeDeltaHistogram . update ( timeDelta ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> index 1a0b400 . . 9712497 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> @ @ - 547 , 7 + 547 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> <nl> @ SuppressWarnings ( " resource " ) / / ' iter ' is added to iterators which is closed on exception , <nl> / / or through the closing of the final merged iterator <nl> - UnfilteredRowIteratorWithLowerBound iter = makeIterator ( sstable , true ) ; <nl> + UnfilteredRowIteratorWithLowerBound iter = makeIterator ( cfs , sstable , true ) ; <nl> if ( ! sstable . isRepaired ( ) ) <nl> oldestUnrepairedTombstone = Math . min ( oldestUnrepairedTombstone , sstable . getMinLocalDeletionTime ( ) ) ; <nl> <nl> @ @ - 567 , 7 + 567 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> <nl> @ SuppressWarnings ( " resource " ) / / ' iter ' is added to iterators which is close on exception , <nl> / / or through the closing of the final merged iterator <nl> - UnfilteredRowIteratorWithLowerBound iter = makeIterator ( sstable , false ) ; <nl> + UnfilteredRowIteratorWithLowerBound iter = makeIterator ( cfs , sstable , false ) ; <nl> if ( ! sstable . isRepaired ( ) ) <nl> oldestUnrepairedTombstone = Math . min ( oldestUnrepairedTombstone , sstable . getMinLocalDeletionTime ( ) ) ; <nl> <nl> @ @ - 582 , 6 + 582 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> if ( iterators . isEmpty ( ) ) <nl> return EmptyIterators . unfilteredRow ( cfs . metadata , partitionKey ( ) , filter . isReversed ( ) ) ; <nl> <nl> + StorageHook . instance . reportRead ( cfs . metadata . cfId , partitionKey ( ) ) ; <nl> return withStateTracking ( withSSTablesIterated ( iterators , cfs . metric ) ) ; <nl> } <nl> catch ( RuntimeException | Error e ) <nl> @ @ - 609 , 15 + 610 , 17 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> return clusteringIndexFilter ( ) . shouldInclude ( sstable ) ; <nl> } <nl> <nl> - private UnfilteredRowIteratorWithLowerBound makeIterator ( final SSTableReader sstable , boolean applyThriftTransformation ) <nl> + private UnfilteredRowIteratorWithLowerBound makeIterator ( ColumnFamilyStore cfs , final SSTableReader sstable , boolean applyThriftTransformation ) <nl> { <nl> - return new UnfilteredRowIteratorWithLowerBound ( partitionKey ( ) , <nl> - sstable , <nl> - clusteringIndexFilter ( ) , <nl> - columnFilter ( ) , <nl> - isForThrift ( ) , <nl> - nowInSec ( ) , <nl> - applyThriftTransformation ) ; <nl> + return StorageHook . instance . makeRowIteratorWithLowerBound ( cfs , <nl> + partitionKey ( ) , <nl> + sstable , <nl> + clusteringIndexFilter ( ) , <nl> + columnFilter ( ) , <nl> + isForThrift ( ) , <nl> + nowInSec ( ) , <nl> + applyThriftTransformation ) ; <nl> + <nl> } <nl> <nl> / * * <nl> @ @ - 724 , 7 + 727 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> <nl> / / We need to get the partition deletion and include it if it ' s live . In any case though , we ' re done with that sstable . <nl> sstable . incrementReadCount ( ) ; <nl> - try ( UnfilteredRowIterator iter = sstable . iterator ( partitionKey ( ) , Slices . ALL , columnFilter ( ) , filter . isReversed ( ) , isForThrift ( ) ) ) <nl> + try ( UnfilteredRowIterator iter = StorageHook . instance . makeRowIterator ( cfs , sstable , partitionKey ( ) , Slices . ALL , columnFilter ( ) , filter . isReversed ( ) , isForThrift ( ) ) ) <nl> { <nl> if ( iter . partitionLevelDeletion ( ) . isLive ( ) ) <nl> { <nl> @ @ - 737 , 7 + 740 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> <nl> Tracing . trace ( " Merging data from sstable { } " , sstable . descriptor . generation ) ; <nl> sstable . incrementReadCount ( ) ; <nl> - try ( UnfilteredRowIterator iter = sstable . iterator ( partitionKey ( ) , filter . getSlices ( metadata ( ) ) , columnFilter ( ) , filter . isReversed ( ) , isForThrift ( ) ) ) <nl> + try ( UnfilteredRowIterator iter = StorageHook . instance . makeRowIterator ( cfs , sstable , partitionKey ( ) , filter . getSlices ( metadata ( ) ) , columnFilter ( ) , filter . isReversed ( ) , isForThrift ( ) ) ) <nl> { <nl> if ( iter . isEmpty ( ) ) <nl> continue ; <nl> @ @ - 754 , 6 + 757 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> <nl> DecoratedKey key = result . partitionKey ( ) ; <nl> cfs . metric . samplers . get ( TableMetrics . Sampler . READS ) . addSample ( key . getKey ( ) , key . hashCode ( ) , 1 ) ; <nl> + StorageHook . instance . reportRead ( cfs . metadata . cfId , partitionKey ( ) ) ; <nl> <nl> / / " hoist up " the requested data into a more recent sstable <nl> if ( sstablesIterated > cfs . getMinimumCompactionThreshold ( ) <nl> diff - - git a / src / java / org / apache / cassandra / db / StorageHook . java b / src / java / org / apache / cassandra / db / StorageHook . java <nl> new file mode 100644 <nl> index 0000000 . . 0f27adb <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / db / StorageHook . java <nl> @ @ - 0 , 0 + 1 , 86 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . db ; <nl> + <nl> + import java . util . UUID ; <nl> + <nl> + import org . apache . cassandra . db . filter . ClusteringIndexFilter ; <nl> + import org . apache . cassandra . db . filter . ColumnFilter ; <nl> + import org . apache . cassandra . db . partitions . PartitionUpdate ; <nl> + import org . apache . cassandra . db . rows . UnfilteredRowIterator ; <nl> + import org . apache . cassandra . db . rows . UnfilteredRowIteratorWithLowerBound ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public interface StorageHook <nl> + { <nl> + public static final StorageHook instance = createHook ( ) ; <nl> + <nl> + public void reportWrite ( UUID cfid , PartitionUpdate partitionUpdate ) ; <nl> + public void reportRead ( UUID cfid , DecoratedKey key ) ; <nl> + public UnfilteredRowIteratorWithLowerBound makeRowIteratorWithLowerBound ( ColumnFamilyStore cfs , <nl> + DecoratedKey partitionKey , <nl> + SSTableReader sstable , <nl> + ClusteringIndexFilter filter , <nl> + ColumnFilter selectedColumns , <nl> + boolean isForThrift , <nl> + int nowInSec , <nl> + boolean applyThriftTransformation ) ; <nl> + public UnfilteredRowIterator makeRowIterator ( ColumnFamilyStore cfs , <nl> + SSTableReader sstable , <nl> + DecoratedKey key , <nl> + Slices slices , <nl> + ColumnFilter selectedColumns , <nl> + boolean reversed , <nl> + boolean isForThrift ) ; <nl> + <nl> + static StorageHook createHook ( ) <nl> + { <nl> + String className = System . getProperty ( " cassandra . storage _ hook " ) ; <nl> + if ( className ! = null ) <nl> + { <nl> + return FBUtilities . construct ( className , StorageHook . class . getSimpleName ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + return new StorageHook ( ) <nl> + { <nl> + public void reportWrite ( UUID cfid , PartitionUpdate partitionUpdate ) { } <nl> + <nl> + public void reportRead ( UUID cfid , DecoratedKey key ) { } <nl> + <nl> + public UnfilteredRowIteratorWithLowerBound makeRowIteratorWithLowerBound ( ColumnFamilyStore cfs , DecoratedKey partitionKey , SSTableReader sstable , ClusteringIndexFilter filter , ColumnFilter selectedColumns , boolean isForThrift , int nowInSec , boolean applyThriftTransformation ) <nl> + { <nl> + return new UnfilteredRowIteratorWithLowerBound ( partitionKey , <nl> + sstable , <nl> + filter , <nl> + selectedColumns , <nl> + isForThrift , <nl> + nowInSec , <nl> + applyThriftTransformation ) ; <nl> + } <nl> + <nl> + public UnfilteredRowIterator makeRowIterator ( ColumnFamilyStore cfs , SSTableReader sstable , DecoratedKey key , Slices slices , ColumnFilter selectedColumns , boolean reversed , boolean isForThrift ) <nl> + { <nl> + return sstable . iterator ( key , slices , selectedColumns , reversed , isForThrift ) ; <nl> + } <nl> + } ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamHook . java b / src / java / org / apache / cassandra / streaming / StreamHook . java <nl> new file mode 100644 <nl> index 0000000 . . d610297 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamHook . java <nl> @ @ - 0 , 0 + 1 , 57 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . streaming ; <nl> + <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . io . sstable . SSTableMultiWriter ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> + import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public interface StreamHook <nl> + { <nl> + public static final StreamHook instance = createHook ( ) ; <nl> + <nl> + public OutgoingFileMessage reportOutgoingFile ( StreamSession session , SSTableReader sstable , OutgoingFileMessage message ) ; <nl> + public void reportStreamFuture ( StreamSession session , StreamResultFuture future ) ; <nl> + public void reportIncomingFile ( ColumnFamilyStore cfs , SSTableMultiWriter writer , StreamSession session , int sequenceNumber ) ; <nl> + <nl> + static StreamHook createHook ( ) <nl> + { <nl> + String className = System . getProperty ( " cassandra . stream _ hook " ) ; <nl> + if ( className ! = null ) <nl> + { <nl> + return FBUtilities . construct ( className , StreamHook . class . getSimpleName ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + return new StreamHook ( ) <nl> + { <nl> + public OutgoingFileMessage reportOutgoingFile ( StreamSession session , SSTableReader sstable , OutgoingFileMessage message ) <nl> + { <nl> + return message ; <nl> + } <nl> + <nl> + public void reportStreamFuture ( StreamSession session , StreamResultFuture future ) { } <nl> + <nl> + public void reportIncomingFile ( ColumnFamilyStore cfs , SSTableMultiWriter writer , StreamSession session , int sequenceNumber ) { } <nl> + } ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamReader . java b / src / java / org / apache / cassandra / streaming / StreamReader . java <nl> index 838664d . . 7348027 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamReader . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamReader . java <nl> @ @ - 143 , 7 + 143 , 9 @ @ public class StreamReader <nl> if ( localDir = = null ) <nl> throw new IOException ( " Insufficient disk space to store " + totalSize + " bytes " ) ; <nl> <nl> - return new RangeAwareSSTableWriter ( cfs , estimatedKeys , repairedAt , format , sstableLevel , totalSize , session . getTransaction ( cfId ) , header ) ; <nl> + RangeAwareSSTableWriter writer = new RangeAwareSSTableWriter ( cfs , estimatedKeys , repairedAt , format , sstableLevel , totalSize , session . getTransaction ( cfId ) , header ) ; <nl> + StreamHook . instance . reportIncomingFile ( cfs , writer , session , fileSeqNum ) ; <nl> + return writer ; <nl> } <nl> <nl> protected void drain ( InputStream dis , long bytesRead ) throws IOException <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> index 9078acc . . 67e6b84 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> @ @ - 39 , 8 + 39 , 6 @ @ import org . apache . cassandra . db . PartitionPosition ; <nl> import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . gms . * ; <nl> - import org . apache . cassandra . io . sstable . Component ; <nl> - import org . apache . cassandra . io . sstable . Descriptor ; <nl> import org . apache . cassandra . metrics . StreamingMetrics ; <nl> import org . apache . cassandra . service . ActiveRepairService ; <nl> import org . apache . cassandra . streaming . messages . * ; <nl> @ @ - 222 , 6 + 220 , 7 @ @ public class StreamSession implements IEndpointStateChangeSubscriber <nl> public void init ( StreamResultFuture streamResult ) <nl> { <nl> this . streamResult = streamResult ; <nl> + StreamHook . instance . reportStreamFuture ( this , streamResult ) ; <nl> } <nl> <nl> public void start ( ) <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> index f14abd2 . . e8d0cae 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> @ @ - 23 , 14 + 23 , 12 @ @ import java . util . concurrent . ScheduledFuture ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> import com . google . common . base . Throwables ; <nl> - import com . google . common . collect . Iterables ; <nl> <nl> import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; <nl> import org . apache . cassandra . utils . Pair ; <nl> import org . apache . cassandra . utils . concurrent . Ref ; <nl> - import org . apache . cassandra . utils . concurrent . RefCounted ; <nl> <nl> / * * <nl> * StreamTransferTask sends sections of SSTable files in certain ColumnFamily . <nl> @ @ - 56 , 6 + 54 , 7 @ @ public class StreamTransferTask extends StreamTask <nl> { <nl> assert ref . get ( ) ! = null & & cfId . equals ( ref . get ( ) . metadata . cfId ) ; <nl> OutgoingFileMessage message = new OutgoingFileMessage ( ref , sequenceNumber . getAndIncrement ( ) , estimatedKeys , sections , repairedAt , session . keepSSTableLevel ( ) ) ; <nl> + message = StreamHook . instance . reportOutgoingFile ( session , ref . get ( ) , message ) ; <nl> files . put ( message . header . sequenceNumber , message ) ; <nl> totalSize + = message . header . size ( ) ; <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 9b113c4 . . fa95063 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1217 , 6 + 1217 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 DecoratedKey key = update . partitionKey ( ) ; 
 invalidateCachedPartition ( key ) ; 
 metric . samplers . get ( Sampler . WRITES ) . addSample ( key . getKey ( ) , key . hashCode ( ) , 1 ) ; 
 + StorageHook . instance . reportWrite ( metadata . cfId , update ) ; 
 metric . writeLatency . addNano ( System . nanoTime ( ) - start ) ; 
 if ( timeDelta < Long . MAX _ VALUE ) 
 metric . colUpdateTimeDeltaHistogram . update ( timeDelta ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 index 1a0b400 . . 9712497 100644 
 - - - a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 @ @ - 547 , 7 + 547 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 
 @ SuppressWarnings ( " resource " ) / / ' iter ' is added to iterators which is closed on exception , 
 / / or through the closing of the final merged iterator 
 - UnfilteredRowIteratorWithLowerBound iter = makeIterator ( sstable , true ) ; 
 + UnfilteredRowIteratorWithLowerBound iter = makeIterator ( cfs , sstable , true ) ; 
 if ( ! sstable . isRepaired ( ) ) 
 oldestUnrepairedTombstone = Math . min ( oldestUnrepairedTombstone , sstable . getMinLocalDeletionTime ( ) ) ; 
 
 @ @ - 567 , 7 + 567 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 
 @ SuppressWarnings ( " resource " ) / / ' iter ' is added to iterators which is close on exception , 
 / / or through the closing of the final merged iterator 
 - UnfilteredRowIteratorWithLowerBound iter = makeIterator ( sstable , false ) ; 
 + UnfilteredRowIteratorWithLowerBound iter = makeIterator ( cfs , sstable , false ) ; 
 if ( ! sstable . isRepaired ( ) ) 
 oldestUnrepairedTombstone = Math . min ( oldestUnrepairedTombstone , sstable . getMinLocalDeletionTime ( ) ) ; 
 
 @ @ - 582 , 6 + 582 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 if ( iterators . isEmpty ( ) ) 
 return EmptyIterators . unfilteredRow ( cfs . metadata , partitionKey ( ) , filter . isReversed ( ) ) ; 
 
 + StorageHook . instance . reportRead ( cfs . metadata . cfId , partitionKey ( ) ) ; 
 return withStateTracking ( withSSTablesIterated ( iterators , cfs . metric ) ) ; 
 } 
 catch ( RuntimeException | Error e ) 
 @ @ - 609 , 15 + 610 , 17 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 return clusteringIndexFilter ( ) . shouldInclude ( sstable ) ; 
 } 
 
 - private UnfilteredRowIteratorWithLowerBound makeIterator ( final SSTableReader sstable , boolean applyThriftTransformation ) 
 + private UnfilteredRowIteratorWithLowerBound makeIterator ( ColumnFamilyStore cfs , final SSTableReader sstable , boolean applyThriftTransformation ) 
 { 
 - return new UnfilteredRowIteratorWithLowerBound ( partitionKey ( ) , 
 - sstable , 
 - clusteringIndexFilter ( ) , 
 - columnFilter ( ) , 
 - isForThrift ( ) , 
 - nowInSec ( ) , 
 - applyThriftTransformation ) ; 
 + return StorageHook . instance . makeRowIteratorWithLowerBound ( cfs , 
 + partitionKey ( ) , 
 + sstable , 
 + clusteringIndexFilter ( ) , 
 + columnFilter ( ) , 
 + isForThrift ( ) , 
 + nowInSec ( ) , 
 + applyThriftTransformation ) ; 
 + 
 } 
 
 / * * 
 @ @ - 724 , 7 + 727 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 
 / / We need to get the partition deletion and include it if it ' s live . In any case though , we ' re done with that sstable . 
 sstable . incrementReadCount ( ) ; 
 - try ( UnfilteredRowIterator iter = sstable . iterator ( partitionKey ( ) , Slices . ALL , columnFilter ( ) , filter . isReversed ( ) , isForThrift ( ) ) ) 
 + try ( UnfilteredRowIterator iter = StorageHook . instance . makeRowIterator ( cfs , sstable , partitionKey ( ) , Slices . ALL , columnFilter ( ) , filter . isReversed ( ) , isForThrift ( ) ) ) 
 { 
 if ( iter . partitionLevelDeletion ( ) . isLive ( ) ) 
 { 
 @ @ - 737 , 7 + 740 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 
 Tracing . trace ( " Merging data from sstable { } " , sstable . descriptor . generation ) ; 
 sstable . incrementReadCount ( ) ; 
 - try ( UnfilteredRowIterator iter = sstable . iterator ( partitionKey ( ) , filter . getSlices ( metadata ( ) ) , columnFilter ( ) , filter . isReversed ( ) , isForThrift ( ) ) ) 
 + try ( UnfilteredRowIterator iter = StorageHook . instance . makeRowIterator ( cfs , sstable , partitionKey ( ) , filter . getSlices ( metadata ( ) ) , columnFilter ( ) , filter . isReversed ( ) , isForThrift ( ) ) ) 
 { 
 if ( iter . isEmpty ( ) ) 
 continue ; 
 @ @ - 754 , 6 + 757 , 7 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 
 DecoratedKey key = result . partitionKey ( ) ; 
 cfs . metric . samplers . get ( TableMetrics . Sampler . READS ) . addSample ( key . getKey ( ) , key . hashCode ( ) , 1 ) ; 
 + StorageHook . instance . reportRead ( cfs . metadata . cfId , partitionKey ( ) ) ; 
 
 / / " hoist up " the requested data into a more recent sstable 
 if ( sstablesIterated > cfs . getMinimumCompactionThreshold ( ) 
 diff - - git a / src / java / org / apache / cassandra / db / StorageHook . java b / src / java / org / apache / cassandra / db / StorageHook . java 
 new file mode 100644 
 index 0000000 . . 0f27adb 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / db / StorageHook . java 
 @ @ - 0 , 0 + 1 , 86 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . db ; 
 + 
 + import java . util . UUID ; 
 + 
 + import org . apache . cassandra . db . filter . ClusteringIndexFilter ; 
 + import org . apache . cassandra . db . filter . ColumnFilter ; 
 + import org . apache . cassandra . db . partitions . PartitionUpdate ; 
 + import org . apache . cassandra . db . rows . UnfilteredRowIterator ; 
 + import org . apache . cassandra . db . rows . UnfilteredRowIteratorWithLowerBound ; 
 + import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public interface StorageHook 
 + { 
 + public static final StorageHook instance = createHook ( ) ; 
 + 
 + public void reportWrite ( UUID cfid , PartitionUpdate partitionUpdate ) ; 
 + public void reportRead ( UUID cfid , DecoratedKey key ) ; 
 + public UnfilteredRowIteratorWithLowerBound makeRowIteratorWithLowerBound ( ColumnFamilyStore cfs , 
 + DecoratedKey partitionKey , 
 + SSTableReader sstable , 
 + ClusteringIndexFilter filter , 
 + ColumnFilter selectedColumns , 
 + boolean isForThrift , 
 + int nowInSec , 
 + boolean applyThriftTransformation ) ; 
 + public UnfilteredRowIterator makeRowIterator ( ColumnFamilyStore cfs , 
 + SSTableReader sstable , 
 + DecoratedKey key , 
 + Slices slices , 
 + ColumnFilter selectedColumns , 
 + boolean reversed , 
 + boolean isForThrift ) ; 
 + 
 + static StorageHook createHook ( ) 
 + { 
 + String className = System . getProperty ( " cassandra . storage _ hook " ) ; 
 + if ( className ! = null ) 
 + { 
 + return FBUtilities . construct ( className , StorageHook . class . getSimpleName ( ) ) ; 
 + } 
 + else 
 + { 
 + return new StorageHook ( ) 
 + { 
 + public void reportWrite ( UUID cfid , PartitionUpdate partitionUpdate ) { } 
 + 
 + public void reportRead ( UUID cfid , DecoratedKey key ) { } 
 + 
 + public UnfilteredRowIteratorWithLowerBound makeRowIteratorWithLowerBound ( ColumnFamilyStore cfs , DecoratedKey partitionKey , SSTableReader sstable , ClusteringIndexFilter filter , ColumnFilter selectedColumns , boolean isForThrift , int nowInSec , boolean applyThriftTransformation ) 
 + { 
 + return new UnfilteredRowIteratorWithLowerBound ( partitionKey , 
 + sstable , 
 + filter , 
 + selectedColumns , 
 + isForThrift , 
 + nowInSec , 
 + applyThriftTransformation ) ; 
 + } 
 + 
 + public UnfilteredRowIterator makeRowIterator ( ColumnFamilyStore cfs , SSTableReader sstable , DecoratedKey key , Slices slices , ColumnFilter selectedColumns , boolean reversed , boolean isForThrift ) 
 + { 
 + return sstable . iterator ( key , slices , selectedColumns , reversed , isForThrift ) ; 
 + } 
 + } ; 
 + } 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamHook . java b / src / java / org / apache / cassandra / streaming / StreamHook . java 
 new file mode 100644 
 index 0000000 . . d610297 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / streaming / StreamHook . java 
 @ @ - 0 , 0 + 1 , 57 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . streaming ; 
 + 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . io . sstable . SSTableMultiWriter ; 
 + import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 + import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public interface StreamHook 
 + { 
 + public static final StreamHook instance = createHook ( ) ; 
 + 
 + public OutgoingFileMessage reportOutgoingFile ( StreamSession session , SSTableReader sstable , OutgoingFileMessage message ) ; 
 + public void reportStreamFuture ( StreamSession session , StreamResultFuture future ) ; 
 + public void reportIncomingFile ( ColumnFamilyStore cfs , SSTableMultiWriter writer , StreamSession session , int sequenceNumber ) ; 
 + 
 + static StreamHook createHook ( ) 
 + { 
 + String className = System . getProperty ( " cassandra . stream _ hook " ) ; 
 + if ( className ! = null ) 
 + { 
 + return FBUtilities . construct ( className , StreamHook . class . getSimpleName ( ) ) ; 
 + } 
 + else 
 + { 
 + return new StreamHook ( ) 
 + { 
 + public OutgoingFileMessage reportOutgoingFile ( StreamSession session , SSTableReader sstable , OutgoingFileMessage message ) 
 + { 
 + return message ; 
 + } 
 + 
 + public void reportStreamFuture ( StreamSession session , StreamResultFuture future ) { } 
 + 
 + public void reportIncomingFile ( ColumnFamilyStore cfs , SSTableMultiWriter writer , StreamSession session , int sequenceNumber ) { } 
 + } ; 
 + } 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamReader . java b / src / java / org / apache / cassandra / streaming / StreamReader . java 
 index 838664d . . 7348027 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamReader . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamReader . java 
 @ @ - 143 , 7 + 143 , 9 @ @ public class StreamReader 
 if ( localDir = = null ) 
 throw new IOException ( " Insufficient disk space to store " + totalSize + " bytes " ) ; 
 
 - return new RangeAwareSSTableWriter ( cfs , estimatedKeys , repairedAt , format , sstableLevel , totalSize , session . getTransaction ( cfId ) , header ) ; 
 + RangeAwareSSTableWriter writer = new RangeAwareSSTableWriter ( cfs , estimatedKeys , repairedAt , format , sstableLevel , totalSize , session . getTransaction ( cfId ) , header ) ; 
 + StreamHook . instance . reportIncomingFile ( cfs , writer , session , fileSeqNum ) ; 
 + return writer ; 
 } 
 
 protected void drain ( InputStream dis , long bytesRead ) throws IOException 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 index 9078acc . . 67e6b84 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 @ @ - 39 , 8 + 39 , 6 @ @ import org . apache . cassandra . db . PartitionPosition ; 
 import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . gms . * ; 
 - import org . apache . cassandra . io . sstable . Component ; 
 - import org . apache . cassandra . io . sstable . Descriptor ; 
 import org . apache . cassandra . metrics . StreamingMetrics ; 
 import org . apache . cassandra . service . ActiveRepairService ; 
 import org . apache . cassandra . streaming . messages . * ; 
 @ @ - 222 , 6 + 220 , 7 @ @ public class StreamSession implements IEndpointStateChangeSubscriber 
 public void init ( StreamResultFuture streamResult ) 
 { 
 this . streamResult = streamResult ; 
 + StreamHook . instance . reportStreamFuture ( this , streamResult ) ; 
 } 
 
 public void start ( ) 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 index f14abd2 . . e8d0cae 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 @ @ - 23 , 14 + 23 , 12 @ @ import java . util . concurrent . ScheduledFuture ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 
 import com . google . common . base . Throwables ; 
 - import com . google . common . collect . Iterables ; 
 
 import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; 
 import org . apache . cassandra . utils . Pair ; 
 import org . apache . cassandra . utils . concurrent . Ref ; 
 - import org . apache . cassandra . utils . concurrent . RefCounted ; 
 
 / * * 
 * StreamTransferTask sends sections of SSTable files in certain ColumnFamily . 
 @ @ - 56 , 6 + 54 , 7 @ @ public class StreamTransferTask extends StreamTask 
 { 
 assert ref . get ( ) ! = null & & cfId . equals ( ref . get ( ) . metadata . cfId ) ; 
 OutgoingFileMessage message = new OutgoingFileMessage ( ref , sequenceNumber . getAndIncrement ( ) , estimatedKeys , sections , repairedAt , session . keepSSTableLevel ( ) ) ; 
 + message = StreamHook . instance . reportOutgoingFile ( session , ref . get ( ) , message ) ; 
 files . put ( message . header . sequenceNumber , message ) ; 
 totalSize + = message . header . size ( ) ; 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
