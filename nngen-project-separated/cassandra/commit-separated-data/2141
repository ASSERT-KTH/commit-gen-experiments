BLEU SCORE: 0.03283637368030199

TEST MSG: Permit use of custom allocator for memtables
GENERATED MSG: Fix potential SlabAllocator yield - starvation

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a9be239 . . 837f770 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 18 , 7 + 18 , 6 @ @ <nl> * Use unsafe mutations for most unit tests ( CASSANDRA - 6969 ) <nl> * Fix race condition during calculation of pending ranges ( CASSANDRA - 7390 ) <nl> <nl> - <nl> 2 . 1 . 1 <nl> * ( cqlsh ) : Support for query paging ( CASSANDRA - 7514 ) <nl> * ( cqlsh ) : Show progress of COPY operations ( CASSANDRA - 7789 ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java b / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java <nl> index 1b5dcf2 . . ccb1104 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java <nl> + + + b / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java <nl> @ @ - 17 , 14 + 17 , 13 @ @ <nl> * / <nl> package org . apache . cassandra . utils . memory ; <nl> <nl> - import java . lang . reflect . Field ; <nl> - <nl> import java . util . concurrent . ConcurrentLinkedQueue ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> import java . util . concurrent . atomic . AtomicLong ; <nl> import java . util . concurrent . atomic . AtomicReference ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . Cell ; <nl> import org . apache . cassandra . db . CounterCell ; <nl> import org . apache . cassandra . db . DecoratedKey ; <nl> @ @ - 35 , 10 + 34 , 10 @ @ import org . apache . cassandra . db . NativeCounterCell ; <nl> import org . apache . cassandra . db . NativeDecoratedKey ; <nl> import org . apache . cassandra . db . NativeDeletedCell ; <nl> import org . apache . cassandra . db . NativeExpiringCell ; <nl> + import org . apache . cassandra . io . util . IAllocator ; <nl> import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> - import sun . misc . Unsafe ; <nl> <nl> public class NativeAllocator extends MemtableAllocator <nl> { <nl> @ @ - 47 , 6 + 46 , 8 @ @ public class NativeAllocator extends MemtableAllocator <nl> private final static int REGION _ SIZE = 1024 * 1024 ; <nl> private final static int MAX _ CLONED _ SIZE = 128 * 1024 ; / / bigger than this don ' t go in the region <nl> <nl> + private static final IAllocator allocator = DatabaseDescriptor . getoffHeapMemoryAllocator ( ) ; <nl> + <nl> / / globally stash any Regions we allocate but are beaten to using , and use these up before allocating any more <nl> private static final ConcurrentLinkedQueue < Region > RACE _ ALLOCATED = new ConcurrentLinkedQueue < > ( ) ; <nl> <nl> @ @ - 104 , 7 + 105 , 7 @ @ public class NativeAllocator extends MemtableAllocator <nl> if ( size > MAX _ CLONED _ SIZE ) <nl> { <nl> unslabbed . addAndGet ( size ) ; <nl> - Region region = new Region ( unsafe . allocateMemory ( size ) , size ) ; <nl> + Region region = new Region ( allocator . allocate ( size ) , size ) ; <nl> regions . add ( region ) ; <nl> <nl> long peer ; <nl> @ @ - 130 , 7 + 131 , 7 @ @ public class NativeAllocator extends MemtableAllocator <nl> public void setDiscarded ( ) <nl> { <nl> for ( Region region : regions ) <nl> - unsafe . freeMemory ( region . peer ) ; <nl> + allocator . free ( region . peer ) ; <nl> super . setDiscarded ( ) ; <nl> } <nl> <nl> @ @ - 150 , 7 + 151 , 7 @ @ public class NativeAllocator extends MemtableAllocator <nl> / / against other allocators to CAS in a Region , and if we fail we stash the region for re - use <nl> region = RACE _ ALLOCATED . poll ( ) ; <nl> if ( region = = null ) <nl> - region = new Region ( unsafe . allocateMemory ( REGION _ SIZE ) , REGION _ SIZE ) ; <nl> + region = new Region ( allocator . allocate ( REGION _ SIZE ) , REGION _ SIZE ) ; <nl> if ( currentRegion . compareAndSet ( null , region ) ) <nl> { <nl> regions . add ( region ) ; <nl> @ @ - 239 , 20 + 240 , 4 @ @ public class NativeAllocator extends MemtableAllocator <nl> } <nl> } <nl> <nl> - <nl> - static final Unsafe unsafe ; <nl> - <nl> - static <nl> - { <nl> - try <nl> - { <nl> - Field field = sun . misc . Unsafe . class . getDeclaredField ( " theUnsafe " ) ; <nl> - field . setAccessible ( true ) ; <nl> - unsafe = ( sun . misc . Unsafe ) field . get ( null ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> - } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a9be239 . . 837f770 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 18 , 7 + 18 , 6 @ @ 
 * Use unsafe mutations for most unit tests ( CASSANDRA - 6969 ) 
 * Fix race condition during calculation of pending ranges ( CASSANDRA - 7390 ) 
 
 - 
 2 . 1 . 1 
 * ( cqlsh ) : Support for query paging ( CASSANDRA - 7514 ) 
 * ( cqlsh ) : Show progress of COPY operations ( CASSANDRA - 7789 ) 
 diff - - git a / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java b / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java 
 index 1b5dcf2 . . ccb1104 100644 
 - - - a / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java 
 + + + b / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java 
 @ @ - 17 , 14 + 17 , 13 @ @ 
 * / 
 package org . apache . cassandra . utils . memory ; 
 
 - import java . lang . reflect . Field ; 
 - 
 import java . util . concurrent . ConcurrentLinkedQueue ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 import java . util . concurrent . atomic . AtomicLong ; 
 import java . util . concurrent . atomic . AtomicReference ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . Cell ; 
 import org . apache . cassandra . db . CounterCell ; 
 import org . apache . cassandra . db . DecoratedKey ; 
 @ @ - 35 , 10 + 34 , 10 @ @ import org . apache . cassandra . db . NativeCounterCell ; 
 import org . apache . cassandra . db . NativeDecoratedKey ; 
 import org . apache . cassandra . db . NativeDeletedCell ; 
 import org . apache . cassandra . db . NativeExpiringCell ; 
 + import org . apache . cassandra . io . util . IAllocator ; 
 import org . apache . cassandra . utils . concurrent . OpOrder ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 - import sun . misc . Unsafe ; 
 
 public class NativeAllocator extends MemtableAllocator 
 { 
 @ @ - 47 , 6 + 46 , 8 @ @ public class NativeAllocator extends MemtableAllocator 
 private final static int REGION _ SIZE = 1024 * 1024 ; 
 private final static int MAX _ CLONED _ SIZE = 128 * 1024 ; / / bigger than this don ' t go in the region 
 
 + private static final IAllocator allocator = DatabaseDescriptor . getoffHeapMemoryAllocator ( ) ; 
 + 
 / / globally stash any Regions we allocate but are beaten to using , and use these up before allocating any more 
 private static final ConcurrentLinkedQueue < Region > RACE _ ALLOCATED = new ConcurrentLinkedQueue < > ( ) ; 
 
 @ @ - 104 , 7 + 105 , 7 @ @ public class NativeAllocator extends MemtableAllocator 
 if ( size > MAX _ CLONED _ SIZE ) 
 { 
 unslabbed . addAndGet ( size ) ; 
 - Region region = new Region ( unsafe . allocateMemory ( size ) , size ) ; 
 + Region region = new Region ( allocator . allocate ( size ) , size ) ; 
 regions . add ( region ) ; 
 
 long peer ; 
 @ @ - 130 , 7 + 131 , 7 @ @ public class NativeAllocator extends MemtableAllocator 
 public void setDiscarded ( ) 
 { 
 for ( Region region : regions ) 
 - unsafe . freeMemory ( region . peer ) ; 
 + allocator . free ( region . peer ) ; 
 super . setDiscarded ( ) ; 
 } 
 
 @ @ - 150 , 7 + 151 , 7 @ @ public class NativeAllocator extends MemtableAllocator 
 / / against other allocators to CAS in a Region , and if we fail we stash the region for re - use 
 region = RACE _ ALLOCATED . poll ( ) ; 
 if ( region = = null ) 
 - region = new Region ( unsafe . allocateMemory ( REGION _ SIZE ) , REGION _ SIZE ) ; 
 + region = new Region ( allocator . allocate ( REGION _ SIZE ) , REGION _ SIZE ) ; 
 if ( currentRegion . compareAndSet ( null , region ) ) 
 { 
 regions . add ( region ) ; 
 @ @ - 239 , 20 + 240 , 4 @ @ public class NativeAllocator extends MemtableAllocator 
 } 
 } 
 
 - 
 - static final Unsafe unsafe ; 
 - 
 - static 
 - { 
 - try 
 - { 
 - Field field = sun . misc . Unsafe . class . getDeclaredField ( " theUnsafe " ) ; 
 - field . setAccessible ( true ) ; 
 - unsafe = ( sun . misc . Unsafe ) field . get ( null ) ; 
 - } 
 - catch ( Exception e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 - } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
