BLEU SCORE: 0.08116697886877475

TEST MSG: Handle CQL row marker in SSTableImport
GENERATED MSG: CQL : keyspace creation

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 5b5283f . . 8714265 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 0 - rc6 <nl> + * json2sstable couldn ' t import JSON for CQL table ( CASSANDRA - 7477 ) <nl> * Invalidate all caches on table drop ( CASSANDRA - 7561 ) <nl> * Skip strict endpoint selection for ranges if RF = = nodes ( CASSANRA - 7765 ) <nl> * Fix Thrift range filtering without 2ary index lookups ( CASSANDRA - 7741 ) <nl> diff - - git a / src / java / org / apache / cassandra / tools / SSTableImport . java b / src / java / org / apache / cassandra / tools / SSTableImport . java <nl> index 4e7bf06 . . 6e1415f 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / SSTableImport . java <nl> + + + b / src / java / org / apache / cassandra / tools / SSTableImport . java <nl> @ @ - 142 , 7 + 142 , 11 @ @ public class SSTableImport <nl> } <nl> else <nl> { <nl> - value = stringAsType ( ( String ) fields . get ( 1 ) , meta . getValueValidator ( comparator . cellFromByteBuffer ( name ) ) ) ; <nl> + assert meta . isCQL3Table ( ) | | name . hasRemaining ( ) : " Cell name should not be empty " ; <nl> + value = stringAsType ( ( String ) fields . get ( 1 ) , <nl> + meta . getValueValidator ( name . hasRemaining ( ) <nl> + ? comparator . cellFromByteBuffer ( name ) <nl> + : meta . comparator . rowMarker ( Composites . EMPTY ) ) ) ; <nl> } <nl> } <nl> } <nl> @ @ - 215 , 8 + 219 , 10 @ @ public class SSTableImport <nl> cfamily . addAtom ( new RangeTombstone ( start , end , col . timestamp , col . localExpirationTime ) ) ; <nl> continue ; <nl> } <nl> - <nl> - CellName cname = cfm . comparator . cellFromByteBuffer ( col . getName ( ) ) ; <nl> + <nl> + assert cfm . isCQL3Table ( ) | | col . getName ( ) . hasRemaining ( ) : " Cell name should not be empty " ; <nl> + CellName cname = col . getName ( ) . hasRemaining ( ) ? cfm . comparator . cellFromByteBuffer ( col . getName ( ) ) <nl> + : cfm . comparator . rowMarker ( Composites . EMPTY ) ; <nl> <nl> if ( col . isExpiring ( ) ) <nl> { <nl> diff - - git a / test / resources / CQLTable . json b / test / resources / CQLTable . json <nl> new file mode 100644 <nl> index 0000000 . . af15f70 <nl> - - - / dev / null <nl> + + + b / test / resources / CQLTable . json <nl> @ @ - 0 , 0 + 1 , 10 @ @ <nl> + [ <nl> + { " key " : " 00000001 " , <nl> + " cells " : [ [ " " , " " , 1408056347831000 ] , <nl> + [ " v1 " , " NY " , 1408056347831000 ] , <nl> + [ " v2 " , " 1980 " , 1408056347831000 ] ] } , <nl> + { " key " : " 00000002 " , <nl> + " cells " : [ [ " " , " " , 1408056347812000 ] , <nl> + [ " v1 " , " CA " , 1408056347812000 ] , <nl> + [ " v2 " , " 2014 " , 1408056347812000 ] ] } <nl> + ] <nl> diff - - git a / test / unit / org / apache / cassandra / tools / SSTableImportTest . java b / test / unit / org / apache / cassandra / tools / SSTableImportTest . java <nl> index 2fdeaf4 . . 308a184 100644 <nl> - - - a / test / unit / org / apache / cassandra / tools / SSTableImportTest . java <nl> + + + b / test / unit / org / apache / cassandra / tools / SSTableImportTest . java <nl> @ @ - 18 , 7 + 18 , 11 @ @ <nl> * / <nl> package org . apache . cassandra . tools ; <nl> <nl> + import static org . hamcrest . CoreMatchers . is ; <nl> import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertThat ; <nl> + import static org . junit . matchers . JUnitMatchers . hasItem ; <nl> + <nl> import static org . apache . cassandra . io . sstable . SSTableUtils . tempSSTableFile ; <nl> import static org . apache . cassandra . utils . ByteBufferUtil . hexToBytes ; <nl> <nl> @ @ - 27 , 16 + 31 , 21 @ @ import java . io . IOException ; <nl> import java . net . URI ; <nl> import java . net . URISyntaxException ; <nl> <nl> + import org . hamcrest . Description ; <nl> + import org . hamcrest . Matcher ; <nl> import org . junit . Test ; <nl> + import org . junit . internal . matchers . TypeSafeMatcher ; <nl> <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . Util ; <nl> + import org . apache . cassandra . cql3 . QueryProcessor ; <nl> + import org . apache . cassandra . cql3 . UntypedResultSet ; <nl> + import org . apache . cassandra . cql3 . UntypedResultSet . Row ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; <nl> import org . apache . cassandra . db . filter . QueryFilter ; <nl> import org . apache . cassandra . io . sstable . Descriptor ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> - import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> public class SSTableImportTest extends SchemaLoader <nl> { <nl> @ @ - 138 , 4 + 147 , 55 @ @ public class SSTableImportTest extends SchemaLoader <nl> assert c instanceof CounterCell : c ; <nl> assert ( ( CounterCell ) c ) . total ( ) = = 42 ; <nl> } <nl> + <nl> + @ Test <nl> + / * <nl> + * The schema is <nl> + * CREATE TABLE cql _ keyspace . table1 ( k int PRIMARY KEY , v1 text , v2 int ) <nl> + * * / <nl> + public void shouldImportCqlTable ( ) throws IOException , URISyntaxException <nl> + { <nl> + String cql _ keyspace = " cql _ keyspace " ; <nl> + String cql _ table = " table1 " ; <nl> + String jsonUrl = resourcePath ( " CQLTable . json " ) ; <nl> + File tempSS = tempSSTableFile ( cql _ keyspace , cql _ table ) ; <nl> + new SSTableImport ( true ) . importJson ( jsonUrl , cql _ keyspace , cql _ table , tempSS . getPath ( ) ) ; <nl> + SSTableReader reader = SSTableReader . open ( Descriptor . fromFilename ( tempSS . getPath ( ) ) ) ; <nl> + Keyspace . open ( cql _ keyspace ) . getColumnFamilyStore ( cql _ table ) . addSSTable ( reader ) ; <nl> + <nl> + UntypedResultSet result = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s " , cql _ keyspace , cql _ table ) ) ; <nl> + assertThat ( result . size ( ) , is ( 2 ) ) ; <nl> + assertThat ( result , hasItem ( withElements ( 1 , " NY " , 1980 ) ) ) ; <nl> + assertThat ( result , hasItem ( withElements ( 2 , " CA " , 2014 ) ) ) ; <nl> + } <nl> + <nl> + @ Test ( expected = AssertionError . class ) <nl> + public void shouldRejectEmptyCellNamesForNonCqlTables ( ) throws IOException , URISyntaxException <nl> + { <nl> + String jsonUrl = resourcePath ( " CQLTable . json " ) ; <nl> + File tempSS = tempSSTableFile ( " Keyspace1 " , " Counter1 " ) ; <nl> + new SSTableImport ( true ) . importJson ( jsonUrl , " Keyspace1 " , " Counter1 " , tempSS . getPath ( ) ) ; <nl> + } <nl> + <nl> + private static Matcher < UntypedResultSet . Row > withElements ( final int key , final String v1 , final int v2 ) { <nl> + return new TypeSafeMatcher < UntypedResultSet . Row > ( ) <nl> + { <nl> + @ Override <nl> + public boolean matchesSafely ( Row input ) <nl> + { <nl> + if ( ! input . has ( " k " ) | | ! input . has ( " v1 " ) | | ! input . has ( " v2 " ) ) <nl> + return false ; <nl> + return input . getInt ( " k " ) = = key <nl> + & & input . getString ( " v1 " ) . equals ( v1 ) <nl> + & & input . getInt ( " v2 " ) = = v2 ; <nl> + } <nl> + <nl> + @ Override <nl> + public void describeTo ( Description description ) <nl> + { <nl> + description . appendText ( String . format ( " a row containing : % s , % s , % s " , key , v1 , v2 ) ) ; <nl> + } <nl> + } ; <nl> + <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / doc / cql / CQL . html b / doc / cql / CQL . html <nl> index 30a50aa . . 1a13a12 100644 <nl> - - - a / doc / cql / CQL . html <nl> + + + b / doc / cql / CQL . html <nl> @ @ - 1 , 4 + 1 , 4 @ @ <nl> - < ? xml version = ' 1 . 0 ' encoding = ' utf - 8 ' ? > < ! DOCTYPE html PUBLIC " - / / W3C / / DTD XHTML 1 . 0 Transitional / / EN " " http : / / www . w3 . org / TR / xhtml1 / DTD / xhtml1 - transitional . dtd " > < html xmlns = " http : / / www . w3 . org / 1999 / xhtml " > < head > < meta http - equiv = " Content - Type " content = " text / html ; charset = utf - 8 " / > < / head > < body > < h1 id = " CassandraQueryLanguageCQLv0 . 99 . 1 " > Cassandra Query Language ( CQL ) v0 . 99 . 1 < / h1 > < h2 id = " TableofContents " > Table of Contents < / h2 > < ol style = " list - style : none ; " > < li > < a href = " # CassandraQueryLanguageCQLv0 . 99 . 1 " > Cassandra Query Language ( CQL ) v0 . 99 . 1 < / a > < ol style = " list - style : none ; " > < li > < a href = " # TableofContents " > Table of Contents < / a > < / li > < li > < a href = " # USE " > USE < / a > < / li > < li > < a href = " # SELECT " > SELECT < / a > < ol style = " list - style : none ; " > < li > < a href = " # SpecifyingColumns " > Specifying Columns < / a > < / li > < li > < a href = " # ColumnFamily " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel " > Consistency Level < / a > < / li > < li > < a href = " # Filteringrows " > Filtering rows < / a > < / li > < li > < a href = " # Limits " > Limits < / a > < / li > < / ol > < / li > < li > < a href = " # UPDATE " > UPDATE < / a > < ol style = " list - style : none ; " > < li > < a href = " # ColumnFamily2 " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel2 " > Consistency Level < / a > < / li > < li > < a href = " # SpecifyingColumnsandRow " > Specifying Columns and Row < / a > < / li > < / ol > < / li > < li > < a href = " # DELETE " > DELETE < / a > < ol style = " list - style : none ; " > < li > < a href = " # SpecifyingColumns2 " > Specifying Columns < / a > < / li > < li > < a href = " # ColumnFamily3 " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel3 " > Consistency Level < / a > < / li > < li > < a href = " # deleterows " > Specifying Rows < / a > < / li > < / ol > < / li > < li > < a href = " # TRUNCATE " > TRUNCATE < / a > < / li > < li > < a href = " # CommonIdioms " > Common Idioms < / a > < ol style = " list - style : none ; " > < li > < a href = " # consistency " > Specifying Consistency < / a > < / li > < li > < a href = " # terms " > Term specification < / a > < ol style = " list - style : none ; " > < li > < a href = " # StringLiterals " > String Literals < / a > < / li > < li > < a href = " # Integerslongs " > Integers / longs < / a > < / li > < / ol > < / li > < / ol > < / li > < / ol > < / li > < / ol > < h2 id = " USE " > USE < / h2 > < p > < i > Synopsis : < / i > < / p > < pre > < code > USE & lt ; KEYSPACE & gt ; ; <nl> + < ? xml version = ' 1 . 0 ' encoding = ' utf - 8 ' ? > < ! DOCTYPE html PUBLIC " - / / W3C / / DTD XHTML 1 . 0 Transitional / / EN " " http : / / www . w3 . org / TR / xhtml1 / DTD / xhtml1 - transitional . dtd " > < html xmlns = " http : / / www . w3 . org / 1999 / xhtml " > < head > < meta http - equiv = " Content - Type " content = " text / html ; charset = utf - 8 " / > < / head > < body > < h1 id = " CassandraQueryLanguageCQLv0 . 99 . 1 " > Cassandra Query Language ( CQL ) v0 . 99 . 1 < / h1 > < h2 id = " TableofContents " > Table of Contents < / h2 > < ol style = " list - style : none ; " > < li > < a href = " # CassandraQueryLanguageCQLv0 . 99 . 1 " > Cassandra Query Language ( CQL ) v0 . 99 . 1 < / a > < ol style = " list - style : none ; " > < li > < a href = " # TableofContents " > Table of Contents < / a > < / li > < li > < a href = " # USE " > USE < / a > < / li > < li > < a href = " # SELECT " > SELECT < / a > < ol style = " list - style : none ; " > < li > < a href = " # SpecifyingColumns " > Specifying Columns < / a > < / li > < li > < a href = " # ColumnFamily " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel " > Consistency Level < / a > < / li > < li > < a href = " # Filteringrows " > Filtering rows < / a > < / li > < li > < a href = " # Limits " > Limits < / a > < / li > < / ol > < / li > < li > < a href = " # UPDATE " > UPDATE < / a > < ol style = " list - style : none ; " > < li > < a href = " # ColumnFamily2 " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel2 " > Consistency Level < / a > < / li > < li > < a href = " # SpecifyingColumnsandRow " > Specifying Columns and Row < / a > < / li > < / ol > < / li > < li > < a href = " # DELETE " > DELETE < / a > < ol style = " list - style : none ; " > < li > < a href = " # SpecifyingColumns2 " > Specifying Columns < / a > < / li > < li > < a href = " # ColumnFamily3 " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel3 " > Consistency Level < / a > < / li > < li > < a href = " # deleterows " > Specifying Rows < / a > < / li > < / ol > < / li > < li > < a href = " # TRUNCATE " > TRUNCATE < / a > < / li > < li > < a href = " # CREATEKEYSPACE " > CREATE KEYSPACE < / a > < / li > < li > < a href = " # CommonIdioms " > Common Idioms < / a > < ol style = " list - style : none ; " > < li > < a href = " # consistency " > Specifying Consistency < / a > < / li > < li > < a href = " # terms " > Term specification < / a > < ol style = " list - style : none ; " > < li > < a href = " # StringLiterals " > String Literals < / a > < / li > < li > < a href = " # Integerslongs " > Integers / longs < / a > < / li > < / ol > < / li > < / ol > < / li > < / ol > < / li > < / ol > < h2 id = " USE " > USE < / h2 > < p > < i > Synopsis : < / i > < / p > < pre > < code > USE & lt ; KEYSPACE & gt ; ; <nl> < / code > < / pre > < p > A < code > USE < / code > statement consists of the < code > USE < / code > keyword , followed by a valid keyspace name . Its purpose is to assign the per - connection , current working keyspace . All subsequent keyspace - specific actions will be performed in the context of the supplied value . < / p > < h2 id = " SELECT " > SELECT < / h2 > < p > < i > Synopsis : < / i > < / p > < pre > < code > SELECT [ FIRST N ] [ REVERSED ] & lt ; SELECT EXPR & gt ; FROM & lt ; COLUMN FAMILY & gt ; [ USING & lt ; CONSISTENCY & gt ; ] <nl> [ WHERE & lt ; CLAUSE & gt ; ] [ LIMIT N ] ; <nl> < / code > < / pre > < p > A < code > SELECT < / code > is used to read one or more records from a Cassandra column family . It returns a result - set of rows , where each row consists of a key and a collection of columns corresponding to the query . < / p > < h3 id = " SpecifyingColumns " > Specifying Columns < / h3 > < pre > < code > SELECT [ FIRST N ] [ REVERSED ] name1 , name2 , name3 FROM . . . <nl> @ @ - 21 , 10 + 21 , 12 @ @ APPLY BATCH <nl> < / code > < / pre > < p > When batching UPDATEs , a single consistency level is used for the entire batch , it appears after the < code > BEGIN BATCH < / code > statement , and uses the standard < a href = " # consistency " > consistency level specification < / a > . Batch UPDATEs default to < code > CONSISTENCY . ONE < / code > when left unspecified . < / p > < p > < em > NOTE : While there are no isolation guarantees , < code > UPDATE < / code > queries are atomic within a give record . < / em > < / p > < h2 id = " DELETE " > DELETE < / h2 > < p > < em > Synopsis : < / em > < / p > < pre > < code > DELETE [ COLUMNS ] FROM & lt ; COLUMN FAMILY & gt ; [ USING & lt ; CONSISTENCY & gt ; ] WHERE KEY = keyname1 <nl> DELETE [ COLUMNS ] FROM & lt ; COLUMN FAMILY & gt ; [ USING & lt ; CONSISTENCY & gt ; ] WHERE KEY IN ( keyname1 , keyname2 ) ; <nl> < / code > < / pre > < p > A < code > DELETE < / code > is used to perform the removal of one or more columns from one or more rows . < / p > < h3 id = " SpecifyingColumns2 " > Specifying Columns < / h3 > < pre > < code > DELETE [ COLUMNS ] . . . <nl> - < / code > < / pre > < p > Following the < code > DELETE < / code > keyword is an optional comma - delimited list of column name terms . When no column names are specified , the remove applies to the entire row ( s ) matched by the < a href = " # deleterows " > < code > WHERE < / code > clause < / a > < / p > < h3 id = " ColumnFamily3 " > Column Family < / h3 > < pre > < code > DELETE . . . FROM & lt ; COLUMN FAMILY & gt ; . . . <nl> + < / code > < / pre > < p > Following the < code > DELETE < / code > keyword is an optional comma - delimited list of column name terms . When no column names are specified , the remove applies to the entire row ( s ) matched by the < a href = " # deleterows " > WHERE clause < / a > < / p > < h3 id = " ColumnFamily3 " > Column Family < / h3 > < pre > < code > DELETE . . . FROM & lt ; COLUMN FAMILY & gt ; . . . <nl> < / code > < / pre > < p > The column family name follows the list of column names . < / p > < h3 id = " ConsistencyLevel3 " > Consistency Level < / h3 > < pre > < code > UPDATE . . . [ USING & lt ; CONSISTENCY & gt ; ] . . . <nl> < / code > < / pre > < p > Following the column family identifier is an optional < a href = " # consistency " > consistency level specification < / a > . < / p > < h3 id = " deleterows " > Specifying Rows < / h3 > < pre > < code > UPDATE . . . WHERE KEY = keyname1 <nl> UPDATE . . . WHERE KEY IN ( keyname1 , keyname2 ) <nl> < / code > < / pre > < p > The < code > WHERE < / code > clause is used to determine which row ( s ) a < code > DELETE < / code > applies to . The first form allows the specification of a single keyname using the < code > KEY < / code > keyword and the < code > = < / code > operator . The second form allows a list of keyname terms to be specified using the < code > IN < / code > notation and a parenthesized list of comma - delimited keyname terms . < / p > < h2 id = " TRUNCATE " > TRUNCATE < / h2 > < p > < em > Synopsis : < / em > < / p > < pre > < code > TRUNCATE & lt ; COLUMN FAMILY & gt ; <nl> - < / code > < / pre > < p > Accepts a single argument for the column family name , and permanently removes all data from said column family . < / p > < h2 id = " CommonIdioms " > Common Idioms < / h2 > < h3 id = " consistency " > Specifying Consistency < / h3 > < pre > < code > . . . USING & lt ; CONSISTENCY & gt ; . . . <nl> + < / code > < / pre > < p > Accepts a single argument for the column family name , and permanently removes all data from said column family . < / p > < h2 id = " CREATEKEYSPACE " > CREATE KEYSPACE < / h2 > < p > < em > Synopsis : < / em > < / p > < pre > < code > CREATE KEYSPACE & lt ; NAME & gt ; WITH replication _ factor = & lt ; NUM & gt ; AND strategy _ class = " & lt ; STRATEGY & gt ; " <nl> + [ AND strategy _ options . & lt ; OPTION & gt ; = & lt ; VALUE & gt ; [ AND strategy _ options . & lt ; OPTION & gt ; = & lt ; VALUE & gt ; ] ] ; <nl> + < / code > < / pre > < p > The < code > CREATE KEYSPACE < / code > statement creates a new top - level namespace ( aka & # 8220 ; keyspace & # 8221 ; ) . Valid names are any string constructed of alphanumeric characters and underscores , but must begin with a letter . Properties such as replication strategy and count are specified during creation using the following accepted keyword arguments : < / p > < table > < tr > < th > keyword < / th > < th > required < / th > < th > description < / th > < / tr > < tr > < td > replication _ factor < / td > < td > yes < / td > < td > Numeric argument that specifies the number of replicas for this keyspace . < / td > < / tr > < tr > < td > strategy _ class < / td > < td > yes < / td > < td > Class name to use for managing replica placement . Any of the shipped strategies can be used by specifying the class name relative to org . apache . cassandra . locator , others will need to be fully - qualified and located on the classpath . < / td > < / tr > < tr > < td > strategy _ options < / td > < td > no < / td > < td > Some strategies require additional arguments which can be supplied by appending the option name to the < code > strategy _ options < / code > keyword , separated by a colon ( < code > : < / code > ) . For example , a strategy option of & # 8220 ; DC1 & # 8221 ; with a value of & # 8220 ; 1 & # 8221 ; would be specified as < code > strategy _ options : DC1 = " 1 " < / code > . < / td > < / tr > < / table > < h2 id = " CommonIdioms " > Common Idioms < / h2 > < h3 id = " consistency " > Specifying Consistency < / h3 > < pre > < code > . . . USING & lt ; CONSISTENCY & gt ; . . . <nl> < / code > < / pre > < p > Consistency level specifications are made up the keyword < code > USING < / code > , followed by a consistency level identifier . Valid consistency levels are as follows : < / p > < ul > < li > < code > CONSISTENCY . ZERO < / code > < / li > < li > < code > CONSISTENCY . ONE < / code > ( default ) < / li > < li > < code > CONSISTENCY . QUORUM < / code > < / li > < li > < code > CONSISTENCY . ALL < / code > < / li > < li > < code > CONSISTENCY . DCQUORUM < / code > < / li > < li > < code > CONSISTENCY . DCQUORUMSYNC < / code > < / li > < / ul > < h3 id = " terms " > Term specification < / h3 > < p > Where possible , the type of terms are inferred ; the following term types are supported : < / p > < h4 id = " StringLiterals " > String Literals < / h4 > < p > String literals are any value enclosed in double - quotes , ( ` " ` ) . String literals are treated as raw bytes ; no interpolation is performed . < / p > < h4 id = " Integerslongs " > Integers / longs < / h4 > < p > Integers are any term consisting soley of unquoted numericals , longs are any otherwise valid integer term followed by an upper case & # 8220 ; L & # 8221 ; , ( e . g . 100L ) . It is an error to specify an integer term that will not fit in 4 bytes unsigned , or a long that will not fit in 8 bytes unsigned . < / p > < / body > < / html > <nl> \ No newline at end of file <nl> diff - - git a / doc / cql / CQL . textile b / doc / cql / CQL . textile <nl> index a7479ca . . 1d82664 100644 <nl> - - - a / doc / cql / CQL . textile <nl> + + + b / doc / cql / CQL . textile <nl> @ @ - 160 , 6 + 160 , 21 @ @ TRUNCATE < COLUMN FAMILY > <nl> <nl> Accepts a single argument for the column family name , and permanently removes all data from said column family . <nl> <nl> + h2 . CREATE KEYSPACE <nl> + <nl> + _ Synopsis : _ <nl> + <nl> + bc . <nl> + CREATE KEYSPACE < NAME > WITH replication _ factor = < NUM > AND strategy _ class = " < STRATEGY > " <nl> + [ AND strategy _ options . < OPTION > = < VALUE > [ AND strategy _ options . < OPTION > = < VALUE > ] ] ; <nl> + <nl> + The @ CREATE KEYSPACE @ statement creates a new top - level namespace ( aka " keyspace " ) . Valid names are any string constructed of alphanumeric characters and underscores , but must begin with a letter . Properties such as replication strategy and count are specified during creation using the following accepted keyword arguments : <nl> + <nl> + | _ . keyword | _ . required | _ . description | <nl> + | replication _ factor | yes | Numeric argument that specifies the number of replicas for this keyspace . | <nl> + | strategy _ class | yes | Class name to use for managing replica placement . Any of the shipped strategies can be used by specifying the class name relative to org . apache . cassandra . locator , others will need to be fully - qualified and located on the classpath . | <nl> + | strategy _ options | no | Some strategies require additional arguments which can be supplied by appending the option name to the @ strategy _ options @ keyword , separated by a colon ( @ : @ ) . For example , a strategy option of " DC1 " with a value of " 1 " would be specified as @ strategy _ options : DC1 = " 1 " @ . | <nl> + <nl> h2 . Common Idioms <nl> <nl> h3 ( # consistency ) . Specifying Consistency

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 5b5283f . . 8714265 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 0 - rc6 
 + * json2sstable couldn ' t import JSON for CQL table ( CASSANDRA - 7477 ) 
 * Invalidate all caches on table drop ( CASSANDRA - 7561 ) 
 * Skip strict endpoint selection for ranges if RF = = nodes ( CASSANRA - 7765 ) 
 * Fix Thrift range filtering without 2ary index lookups ( CASSANDRA - 7741 ) 
 diff - - git a / src / java / org / apache / cassandra / tools / SSTableImport . java b / src / java / org / apache / cassandra / tools / SSTableImport . java 
 index 4e7bf06 . . 6e1415f 100644 
 - - - a / src / java / org / apache / cassandra / tools / SSTableImport . java 
 + + + b / src / java / org / apache / cassandra / tools / SSTableImport . java 
 @ @ - 142 , 7 + 142 , 11 @ @ public class SSTableImport 
 } 
 else 
 { 
 - value = stringAsType ( ( String ) fields . get ( 1 ) , meta . getValueValidator ( comparator . cellFromByteBuffer ( name ) ) ) ; 
 + assert meta . isCQL3Table ( ) | | name . hasRemaining ( ) : " Cell name should not be empty " ; 
 + value = stringAsType ( ( String ) fields . get ( 1 ) , 
 + meta . getValueValidator ( name . hasRemaining ( ) 
 + ? comparator . cellFromByteBuffer ( name ) 
 + : meta . comparator . rowMarker ( Composites . EMPTY ) ) ) ; 
 } 
 } 
 } 
 @ @ - 215 , 8 + 219 , 10 @ @ public class SSTableImport 
 cfamily . addAtom ( new RangeTombstone ( start , end , col . timestamp , col . localExpirationTime ) ) ; 
 continue ; 
 } 
 - 
 - CellName cname = cfm . comparator . cellFromByteBuffer ( col . getName ( ) ) ; 
 + 
 + assert cfm . isCQL3Table ( ) | | col . getName ( ) . hasRemaining ( ) : " Cell name should not be empty " ; 
 + CellName cname = col . getName ( ) . hasRemaining ( ) ? cfm . comparator . cellFromByteBuffer ( col . getName ( ) ) 
 + : cfm . comparator . rowMarker ( Composites . EMPTY ) ; 
 
 if ( col . isExpiring ( ) ) 
 { 
 diff - - git a / test / resources / CQLTable . json b / test / resources / CQLTable . json 
 new file mode 100644 
 index 0000000 . . af15f70 
 - - - / dev / null 
 + + + b / test / resources / CQLTable . json 
 @ @ - 0 , 0 + 1 , 10 @ @ 
 + [ 
 + { " key " : " 00000001 " , 
 + " cells " : [ [ " " , " " , 1408056347831000 ] , 
 + [ " v1 " , " NY " , 1408056347831000 ] , 
 + [ " v2 " , " 1980 " , 1408056347831000 ] ] } , 
 + { " key " : " 00000002 " , 
 + " cells " : [ [ " " , " " , 1408056347812000 ] , 
 + [ " v1 " , " CA " , 1408056347812000 ] , 
 + [ " v2 " , " 2014 " , 1408056347812000 ] ] } 
 + ] 
 diff - - git a / test / unit / org / apache / cassandra / tools / SSTableImportTest . java b / test / unit / org / apache / cassandra / tools / SSTableImportTest . java 
 index 2fdeaf4 . . 308a184 100644 
 - - - a / test / unit / org / apache / cassandra / tools / SSTableImportTest . java 
 + + + b / test / unit / org / apache / cassandra / tools / SSTableImportTest . java 
 @ @ - 18 , 7 + 18 , 11 @ @ 
 * / 
 package org . apache . cassandra . tools ; 
 
 + import static org . hamcrest . CoreMatchers . is ; 
 import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertThat ; 
 + import static org . junit . matchers . JUnitMatchers . hasItem ; 
 + 
 import static org . apache . cassandra . io . sstable . SSTableUtils . tempSSTableFile ; 
 import static org . apache . cassandra . utils . ByteBufferUtil . hexToBytes ; 
 
 @ @ - 27 , 16 + 31 , 21 @ @ import java . io . IOException ; 
 import java . net . URI ; 
 import java . net . URISyntaxException ; 
 
 + import org . hamcrest . Description ; 
 + import org . hamcrest . Matcher ; 
 import org . junit . Test ; 
 + import org . junit . internal . matchers . TypeSafeMatcher ; 
 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . Util ; 
 + import org . apache . cassandra . cql3 . QueryProcessor ; 
 + import org . apache . cassandra . cql3 . UntypedResultSet ; 
 + import org . apache . cassandra . cql3 . UntypedResultSet . Row ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; 
 import org . apache . cassandra . db . filter . QueryFilter ; 
 import org . apache . cassandra . io . sstable . Descriptor ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 - import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 public class SSTableImportTest extends SchemaLoader 
 { 
 @ @ - 138 , 4 + 147 , 55 @ @ public class SSTableImportTest extends SchemaLoader 
 assert c instanceof CounterCell : c ; 
 assert ( ( CounterCell ) c ) . total ( ) = = 42 ; 
 } 
 + 
 + @ Test 
 + / * 
 + * The schema is 
 + * CREATE TABLE cql _ keyspace . table1 ( k int PRIMARY KEY , v1 text , v2 int ) 
 + * * / 
 + public void shouldImportCqlTable ( ) throws IOException , URISyntaxException 
 + { 
 + String cql _ keyspace = " cql _ keyspace " ; 
 + String cql _ table = " table1 " ; 
 + String jsonUrl = resourcePath ( " CQLTable . json " ) ; 
 + File tempSS = tempSSTableFile ( cql _ keyspace , cql _ table ) ; 
 + new SSTableImport ( true ) . importJson ( jsonUrl , cql _ keyspace , cql _ table , tempSS . getPath ( ) ) ; 
 + SSTableReader reader = SSTableReader . open ( Descriptor . fromFilename ( tempSS . getPath ( ) ) ) ; 
 + Keyspace . open ( cql _ keyspace ) . getColumnFamilyStore ( cql _ table ) . addSSTable ( reader ) ; 
 + 
 + UntypedResultSet result = QueryProcessor . executeOnceInternal ( String . format ( " SELECT * FROM % s . % s " , cql _ keyspace , cql _ table ) ) ; 
 + assertThat ( result . size ( ) , is ( 2 ) ) ; 
 + assertThat ( result , hasItem ( withElements ( 1 , " NY " , 1980 ) ) ) ; 
 + assertThat ( result , hasItem ( withElements ( 2 , " CA " , 2014 ) ) ) ; 
 + } 
 + 
 + @ Test ( expected = AssertionError . class ) 
 + public void shouldRejectEmptyCellNamesForNonCqlTables ( ) throws IOException , URISyntaxException 
 + { 
 + String jsonUrl = resourcePath ( " CQLTable . json " ) ; 
 + File tempSS = tempSSTableFile ( " Keyspace1 " , " Counter1 " ) ; 
 + new SSTableImport ( true ) . importJson ( jsonUrl , " Keyspace1 " , " Counter1 " , tempSS . getPath ( ) ) ; 
 + } 
 + 
 + private static Matcher < UntypedResultSet . Row > withElements ( final int key , final String v1 , final int v2 ) { 
 + return new TypeSafeMatcher < UntypedResultSet . Row > ( ) 
 + { 
 + @ Override 
 + public boolean matchesSafely ( Row input ) 
 + { 
 + if ( ! input . has ( " k " ) | | ! input . has ( " v1 " ) | | ! input . has ( " v2 " ) ) 
 + return false ; 
 + return input . getInt ( " k " ) = = key 
 + & & input . getString ( " v1 " ) . equals ( v1 ) 
 + & & input . getInt ( " v2 " ) = = v2 ; 
 + } 
 + 
 + @ Override 
 + public void describeTo ( Description description ) 
 + { 
 + description . appendText ( String . format ( " a row containing : % s , % s , % s " , key , v1 , v2 ) ) ; 
 + } 
 + } ; 
 + 
 + } 
 }

NEAREST DIFF:
diff - - git a / doc / cql / CQL . html b / doc / cql / CQL . html 
 index 30a50aa . . 1a13a12 100644 
 - - - a / doc / cql / CQL . html 
 + + + b / doc / cql / CQL . html 
 @ @ - 1 , 4 + 1 , 4 @ @ 
 - < ? xml version = ' 1 . 0 ' encoding = ' utf - 8 ' ? > < ! DOCTYPE html PUBLIC " - / / W3C / / DTD XHTML 1 . 0 Transitional / / EN " " http : / / www . w3 . org / TR / xhtml1 / DTD / xhtml1 - transitional . dtd " > < html xmlns = " http : / / www . w3 . org / 1999 / xhtml " > < head > < meta http - equiv = " Content - Type " content = " text / html ; charset = utf - 8 " / > < / head > < body > < h1 id = " CassandraQueryLanguageCQLv0 . 99 . 1 " > Cassandra Query Language ( CQL ) v0 . 99 . 1 < / h1 > < h2 id = " TableofContents " > Table of Contents < / h2 > < ol style = " list - style : none ; " > < li > < a href = " # CassandraQueryLanguageCQLv0 . 99 . 1 " > Cassandra Query Language ( CQL ) v0 . 99 . 1 < / a > < ol style = " list - style : none ; " > < li > < a href = " # TableofContents " > Table of Contents < / a > < / li > < li > < a href = " # USE " > USE < / a > < / li > < li > < a href = " # SELECT " > SELECT < / a > < ol style = " list - style : none ; " > < li > < a href = " # SpecifyingColumns " > Specifying Columns < / a > < / li > < li > < a href = " # ColumnFamily " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel " > Consistency Level < / a > < / li > < li > < a href = " # Filteringrows " > Filtering rows < / a > < / li > < li > < a href = " # Limits " > Limits < / a > < / li > < / ol > < / li > < li > < a href = " # UPDATE " > UPDATE < / a > < ol style = " list - style : none ; " > < li > < a href = " # ColumnFamily2 " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel2 " > Consistency Level < / a > < / li > < li > < a href = " # SpecifyingColumnsandRow " > Specifying Columns and Row < / a > < / li > < / ol > < / li > < li > < a href = " # DELETE " > DELETE < / a > < ol style = " list - style : none ; " > < li > < a href = " # SpecifyingColumns2 " > Specifying Columns < / a > < / li > < li > < a href = " # ColumnFamily3 " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel3 " > Consistency Level < / a > < / li > < li > < a href = " # deleterows " > Specifying Rows < / a > < / li > < / ol > < / li > < li > < a href = " # TRUNCATE " > TRUNCATE < / a > < / li > < li > < a href = " # CommonIdioms " > Common Idioms < / a > < ol style = " list - style : none ; " > < li > < a href = " # consistency " > Specifying Consistency < / a > < / li > < li > < a href = " # terms " > Term specification < / a > < ol style = " list - style : none ; " > < li > < a href = " # StringLiterals " > String Literals < / a > < / li > < li > < a href = " # Integerslongs " > Integers / longs < / a > < / li > < / ol > < / li > < / ol > < / li > < / ol > < / li > < / ol > < h2 id = " USE " > USE < / h2 > < p > < i > Synopsis : < / i > < / p > < pre > < code > USE & lt ; KEYSPACE & gt ; ; 
 + < ? xml version = ' 1 . 0 ' encoding = ' utf - 8 ' ? > < ! DOCTYPE html PUBLIC " - / / W3C / / DTD XHTML 1 . 0 Transitional / / EN " " http : / / www . w3 . org / TR / xhtml1 / DTD / xhtml1 - transitional . dtd " > < html xmlns = " http : / / www . w3 . org / 1999 / xhtml " > < head > < meta http - equiv = " Content - Type " content = " text / html ; charset = utf - 8 " / > < / head > < body > < h1 id = " CassandraQueryLanguageCQLv0 . 99 . 1 " > Cassandra Query Language ( CQL ) v0 . 99 . 1 < / h1 > < h2 id = " TableofContents " > Table of Contents < / h2 > < ol style = " list - style : none ; " > < li > < a href = " # CassandraQueryLanguageCQLv0 . 99 . 1 " > Cassandra Query Language ( CQL ) v0 . 99 . 1 < / a > < ol style = " list - style : none ; " > < li > < a href = " # TableofContents " > Table of Contents < / a > < / li > < li > < a href = " # USE " > USE < / a > < / li > < li > < a href = " # SELECT " > SELECT < / a > < ol style = " list - style : none ; " > < li > < a href = " # SpecifyingColumns " > Specifying Columns < / a > < / li > < li > < a href = " # ColumnFamily " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel " > Consistency Level < / a > < / li > < li > < a href = " # Filteringrows " > Filtering rows < / a > < / li > < li > < a href = " # Limits " > Limits < / a > < / li > < / ol > < / li > < li > < a href = " # UPDATE " > UPDATE < / a > < ol style = " list - style : none ; " > < li > < a href = " # ColumnFamily2 " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel2 " > Consistency Level < / a > < / li > < li > < a href = " # SpecifyingColumnsandRow " > Specifying Columns and Row < / a > < / li > < / ol > < / li > < li > < a href = " # DELETE " > DELETE < / a > < ol style = " list - style : none ; " > < li > < a href = " # SpecifyingColumns2 " > Specifying Columns < / a > < / li > < li > < a href = " # ColumnFamily3 " > Column Family < / a > < / li > < li > < a href = " # ConsistencyLevel3 " > Consistency Level < / a > < / li > < li > < a href = " # deleterows " > Specifying Rows < / a > < / li > < / ol > < / li > < li > < a href = " # TRUNCATE " > TRUNCATE < / a > < / li > < li > < a href = " # CREATEKEYSPACE " > CREATE KEYSPACE < / a > < / li > < li > < a href = " # CommonIdioms " > Common Idioms < / a > < ol style = " list - style : none ; " > < li > < a href = " # consistency " > Specifying Consistency < / a > < / li > < li > < a href = " # terms " > Term specification < / a > < ol style = " list - style : none ; " > < li > < a href = " # StringLiterals " > String Literals < / a > < / li > < li > < a href = " # Integerslongs " > Integers / longs < / a > < / li > < / ol > < / li > < / ol > < / li > < / ol > < / li > < / ol > < h2 id = " USE " > USE < / h2 > < p > < i > Synopsis : < / i > < / p > < pre > < code > USE & lt ; KEYSPACE & gt ; ; 
 < / code > < / pre > < p > A < code > USE < / code > statement consists of the < code > USE < / code > keyword , followed by a valid keyspace name . Its purpose is to assign the per - connection , current working keyspace . All subsequent keyspace - specific actions will be performed in the context of the supplied value . < / p > < h2 id = " SELECT " > SELECT < / h2 > < p > < i > Synopsis : < / i > < / p > < pre > < code > SELECT [ FIRST N ] [ REVERSED ] & lt ; SELECT EXPR & gt ; FROM & lt ; COLUMN FAMILY & gt ; [ USING & lt ; CONSISTENCY & gt ; ] 
 [ WHERE & lt ; CLAUSE & gt ; ] [ LIMIT N ] ; 
 < / code > < / pre > < p > A < code > SELECT < / code > is used to read one or more records from a Cassandra column family . It returns a result - set of rows , where each row consists of a key and a collection of columns corresponding to the query . < / p > < h3 id = " SpecifyingColumns " > Specifying Columns < / h3 > < pre > < code > SELECT [ FIRST N ] [ REVERSED ] name1 , name2 , name3 FROM . . . 
 @ @ - 21 , 10 + 21 , 12 @ @ APPLY BATCH 
 < / code > < / pre > < p > When batching UPDATEs , a single consistency level is used for the entire batch , it appears after the < code > BEGIN BATCH < / code > statement , and uses the standard < a href = " # consistency " > consistency level specification < / a > . Batch UPDATEs default to < code > CONSISTENCY . ONE < / code > when left unspecified . < / p > < p > < em > NOTE : While there are no isolation guarantees , < code > UPDATE < / code > queries are atomic within a give record . < / em > < / p > < h2 id = " DELETE " > DELETE < / h2 > < p > < em > Synopsis : < / em > < / p > < pre > < code > DELETE [ COLUMNS ] FROM & lt ; COLUMN FAMILY & gt ; [ USING & lt ; CONSISTENCY & gt ; ] WHERE KEY = keyname1 
 DELETE [ COLUMNS ] FROM & lt ; COLUMN FAMILY & gt ; [ USING & lt ; CONSISTENCY & gt ; ] WHERE KEY IN ( keyname1 , keyname2 ) ; 
 < / code > < / pre > < p > A < code > DELETE < / code > is used to perform the removal of one or more columns from one or more rows . < / p > < h3 id = " SpecifyingColumns2 " > Specifying Columns < / h3 > < pre > < code > DELETE [ COLUMNS ] . . . 
 - < / code > < / pre > < p > Following the < code > DELETE < / code > keyword is an optional comma - delimited list of column name terms . When no column names are specified , the remove applies to the entire row ( s ) matched by the < a href = " # deleterows " > < code > WHERE < / code > clause < / a > < / p > < h3 id = " ColumnFamily3 " > Column Family < / h3 > < pre > < code > DELETE . . . FROM & lt ; COLUMN FAMILY & gt ; . . . 
 + < / code > < / pre > < p > Following the < code > DELETE < / code > keyword is an optional comma - delimited list of column name terms . When no column names are specified , the remove applies to the entire row ( s ) matched by the < a href = " # deleterows " > WHERE clause < / a > < / p > < h3 id = " ColumnFamily3 " > Column Family < / h3 > < pre > < code > DELETE . . . FROM & lt ; COLUMN FAMILY & gt ; . . . 
 < / code > < / pre > < p > The column family name follows the list of column names . < / p > < h3 id = " ConsistencyLevel3 " > Consistency Level < / h3 > < pre > < code > UPDATE . . . [ USING & lt ; CONSISTENCY & gt ; ] . . . 
 < / code > < / pre > < p > Following the column family identifier is an optional < a href = " # consistency " > consistency level specification < / a > . < / p > < h3 id = " deleterows " > Specifying Rows < / h3 > < pre > < code > UPDATE . . . WHERE KEY = keyname1 
 UPDATE . . . WHERE KEY IN ( keyname1 , keyname2 ) 
 < / code > < / pre > < p > The < code > WHERE < / code > clause is used to determine which row ( s ) a < code > DELETE < / code > applies to . The first form allows the specification of a single keyname using the < code > KEY < / code > keyword and the < code > = < / code > operator . The second form allows a list of keyname terms to be specified using the < code > IN < / code > notation and a parenthesized list of comma - delimited keyname terms . < / p > < h2 id = " TRUNCATE " > TRUNCATE < / h2 > < p > < em > Synopsis : < / em > < / p > < pre > < code > TRUNCATE & lt ; COLUMN FAMILY & gt ; 
 - < / code > < / pre > < p > Accepts a single argument for the column family name , and permanently removes all data from said column family . < / p > < h2 id = " CommonIdioms " > Common Idioms < / h2 > < h3 id = " consistency " > Specifying Consistency < / h3 > < pre > < code > . . . USING & lt ; CONSISTENCY & gt ; . . . 
 + < / code > < / pre > < p > Accepts a single argument for the column family name , and permanently removes all data from said column family . < / p > < h2 id = " CREATEKEYSPACE " > CREATE KEYSPACE < / h2 > < p > < em > Synopsis : < / em > < / p > < pre > < code > CREATE KEYSPACE & lt ; NAME & gt ; WITH replication _ factor = & lt ; NUM & gt ; AND strategy _ class = " & lt ; STRATEGY & gt ; " 
 + [ AND strategy _ options . & lt ; OPTION & gt ; = & lt ; VALUE & gt ; [ AND strategy _ options . & lt ; OPTION & gt ; = & lt ; VALUE & gt ; ] ] ; 
 + < / code > < / pre > < p > The < code > CREATE KEYSPACE < / code > statement creates a new top - level namespace ( aka & # 8220 ; keyspace & # 8221 ; ) . Valid names are any string constructed of alphanumeric characters and underscores , but must begin with a letter . Properties such as replication strategy and count are specified during creation using the following accepted keyword arguments : < / p > < table > < tr > < th > keyword < / th > < th > required < / th > < th > description < / th > < / tr > < tr > < td > replication _ factor < / td > < td > yes < / td > < td > Numeric argument that specifies the number of replicas for this keyspace . < / td > < / tr > < tr > < td > strategy _ class < / td > < td > yes < / td > < td > Class name to use for managing replica placement . Any of the shipped strategies can be used by specifying the class name relative to org . apache . cassandra . locator , others will need to be fully - qualified and located on the classpath . < / td > < / tr > < tr > < td > strategy _ options < / td > < td > no < / td > < td > Some strategies require additional arguments which can be supplied by appending the option name to the < code > strategy _ options < / code > keyword , separated by a colon ( < code > : < / code > ) . For example , a strategy option of & # 8220 ; DC1 & # 8221 ; with a value of & # 8220 ; 1 & # 8221 ; would be specified as < code > strategy _ options : DC1 = " 1 " < / code > . < / td > < / tr > < / table > < h2 id = " CommonIdioms " > Common Idioms < / h2 > < h3 id = " consistency " > Specifying Consistency < / h3 > < pre > < code > . . . USING & lt ; CONSISTENCY & gt ; . . . 
 < / code > < / pre > < p > Consistency level specifications are made up the keyword < code > USING < / code > , followed by a consistency level identifier . Valid consistency levels are as follows : < / p > < ul > < li > < code > CONSISTENCY . ZERO < / code > < / li > < li > < code > CONSISTENCY . ONE < / code > ( default ) < / li > < li > < code > CONSISTENCY . QUORUM < / code > < / li > < li > < code > CONSISTENCY . ALL < / code > < / li > < li > < code > CONSISTENCY . DCQUORUM < / code > < / li > < li > < code > CONSISTENCY . DCQUORUMSYNC < / code > < / li > < / ul > < h3 id = " terms " > Term specification < / h3 > < p > Where possible , the type of terms are inferred ; the following term types are supported : < / p > < h4 id = " StringLiterals " > String Literals < / h4 > < p > String literals are any value enclosed in double - quotes , ( ` " ` ) . String literals are treated as raw bytes ; no interpolation is performed . < / p > < h4 id = " Integerslongs " > Integers / longs < / h4 > < p > Integers are any term consisting soley of unquoted numericals , longs are any otherwise valid integer term followed by an upper case & # 8220 ; L & # 8221 ; , ( e . g . 100L ) . It is an error to specify an integer term that will not fit in 4 bytes unsigned , or a long that will not fit in 8 bytes unsigned . < / p > < / body > < / html > 
 \ No newline at end of file 
 diff - - git a / doc / cql / CQL . textile b / doc / cql / CQL . textile 
 index a7479ca . . 1d82664 100644 
 - - - a / doc / cql / CQL . textile 
 + + + b / doc / cql / CQL . textile 
 @ @ - 160 , 6 + 160 , 21 @ @ TRUNCATE < COLUMN FAMILY > 
 
 Accepts a single argument for the column family name , and permanently removes all data from said column family . 
 
 + h2 . CREATE KEYSPACE 
 + 
 + _ Synopsis : _ 
 + 
 + bc . 
 + CREATE KEYSPACE < NAME > WITH replication _ factor = < NUM > AND strategy _ class = " < STRATEGY > " 
 + [ AND strategy _ options . < OPTION > = < VALUE > [ AND strategy _ options . < OPTION > = < VALUE > ] ] ; 
 + 
 + The @ CREATE KEYSPACE @ statement creates a new top - level namespace ( aka " keyspace " ) . Valid names are any string constructed of alphanumeric characters and underscores , but must begin with a letter . Properties such as replication strategy and count are specified during creation using the following accepted keyword arguments : 
 + 
 + | _ . keyword | _ . required | _ . description | 
 + | replication _ factor | yes | Numeric argument that specifies the number of replicas for this keyspace . | 
 + | strategy _ class | yes | Class name to use for managing replica placement . Any of the shipped strategies can be used by specifying the class name relative to org . apache . cassandra . locator , others will need to be fully - qualified and located on the classpath . | 
 + | strategy _ options | no | Some strategies require additional arguments which can be supplied by appending the option name to the @ strategy _ options @ keyword , separated by a colon ( @ : @ ) . For example , a strategy option of " DC1 " with a value of " 1 " would be specified as @ strategy _ options : DC1 = " 1 " @ . | 
 + 
 h2 . Common Idioms 
 
 h3 ( # consistency ) . Specifying Consistency
