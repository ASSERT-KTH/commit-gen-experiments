BLEU SCORE: 0.01222796968620182

TEST MSG: Fix pending view mutations handling and cleanup batchlog when there are local and remote paired mutations
GENERATED MSG: Re - apply MV updates on commitlog replay

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 76d155e . . 26b1794 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 15 <nl> + * Fix pending view mutations handling and cleanup batchlog when there are local and remote paired mutations ( CASSANDRA - 13069 ) <nl> * Range deletes in a CAS batch are ignored ( CASSANDRA - 13655 ) <nl> * Change repair midpoint logging for tiny ranges ( CASSANDRA - 13603 ) <nl> * Better handle corrupt final commitlog segment ( CASSANDRA - 11995 ) <nl> diff - - git a / src / java / org / apache / cassandra / batchlog / BatchlogManager . java b / src / java / org / apache / cassandra / batchlog / BatchlogManager . java <nl> index b614fc5 . . a0b614f 100644 <nl> - - - a / src / java / org / apache / cassandra / batchlog / BatchlogManager . java <nl> + + + b / src / java / org / apache / cassandra / batchlog / BatchlogManager . java <nl> @ @ - 67 , 6 + 67 , 7 @ @ public class BatchlogManager implements BatchlogManagerMBean <nl> <nl> private static final Logger logger = LoggerFactory . getLogger ( BatchlogManager . class ) ; <nl> public static final BatchlogManager instance = new BatchlogManager ( ) ; <nl> + public static final long BATCHLOG _ REPLAY _ TIMEOUT = Long . getLong ( " cassandra . batchlog . replay _ timeout _ in _ ms " , DatabaseDescriptor . getWriteRpcTimeout ( ) * 2 ) ; <nl> <nl> private volatile long totalBatchesReplayed = 0 ; / / no concurrency protection necessary as only written by replay thread . <nl> private volatile UUID lastReplayedUuid = UUIDGen . minTimeUUID ( 0 ) ; <nl> @ @ - 284 , 7 + 285 , 7 @ @ public class BatchlogManager implements BatchlogManagerMBean <nl> <nl> public static long getBatchlogTimeout ( ) <nl> { <nl> - return DatabaseDescriptor . getWriteRpcTimeout ( ) * 2 ; / / enough time for the actual write + BM removal mutation <nl> + return BATCHLOG _ REPLAY _ TIMEOUT ; / / enough time for the actual write + BM removal mutation <nl> } <nl> <nl> private static class ReplayingBatch <nl> diff - - git a / src / java / org / apache / cassandra / service / BatchlogResponseHandler . java b / src / java / org / apache / cassandra / service / BatchlogResponseHandler . java <nl> index ac44923 . . a1477e6 100644 <nl> - - - a / src / java / org / apache / cassandra / service / BatchlogResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / BatchlogResponseHandler . java <nl> @ @ - 50 , 7 + 50 , 7 @ @ public class BatchlogResponseHandler < T > extends AbstractWriteResponseHandler < T > <nl> { <nl> wrapped . response ( msg ) ; <nl> if ( requiredBeforeFinishUpdater . decrementAndGet ( this ) = = 0 ) <nl> - cleanup . run ( ) ; <nl> + cleanup . ackMutation ( ) ; <nl> } <nl> <nl> public boolean isLatencyForSnitch ( ) <nl> @ @ - 107 , 7 + 107 , 7 @ @ public class BatchlogResponseHandler < T > extends AbstractWriteResponseHandler < T > <nl> this . callback = callback ; <nl> } <nl> <nl> - public void run ( ) <nl> + public void ackMutation ( ) <nl> { <nl> if ( mutationsWaitingForUpdater . decrementAndGet ( this ) = = 0 ) <nl> callback . invoke ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 6610cf7 . . 1ce1bc5 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 729 , 15 + 729 , 16 @ @ public class StorageProxy implements StorageProxyMBean <nl> else <nl> { <nl> List < WriteResponseHandlerWrapper > wrappers = new ArrayList < > ( mutations . size ( ) ) ; <nl> - List < Mutation > nonPairedMutations = new LinkedList < > ( ) ; <nl> + / / non - local mutations rely on the base mutation commit - log entry for eventual consistency <nl> + Set < Mutation > nonLocalMutations = new HashSet < > ( mutations ) ; <nl> Token baseToken = StorageService . instance . getTokenMetadata ( ) . partitioner . getToken ( dataKey ) ; <nl> <nl> ConsistencyLevel consistencyLevel = ConsistencyLevel . ONE ; <nl> <nl> / / Since the base - > view replication is 1 : 1 we only need to store the BL locally <nl> final Collection < InetAddress > batchlogEndpoints = Collections . singleton ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> - BatchlogResponseHandler . BatchlogCleanup cleanup = new BatchlogResponseHandler . BatchlogCleanup ( mutations . size ( ) , <nl> - ( ) - > asyncRemoveFromBatchlog ( batchlogEndpoints , batchUUID ) ) ; <nl> + BatchlogResponseHandler . BatchlogCleanup cleanup = new BatchlogResponseHandler . BatchlogCleanup ( mutations . size ( ) , ( ) - > asyncRemoveFromBatchlog ( batchlogEndpoints , batchUUID ) ) ; <nl> + <nl> / / add a handler for each mutation - includes checking availability , but doesn ' t initiate any writes , yet <nl> for ( Mutation mutation : mutations ) <nl> { <nl> @ @ - 746 , 61 + 747 , 50 @ @ public class StorageProxy implements StorageProxyMBean <nl> Optional < InetAddress > pairedEndpoint = ViewUtils . getViewNaturalEndpoint ( keyspaceName , baseToken , tk ) ; <nl> Collection < InetAddress > pendingEndpoints = StorageService . instance . getTokenMetadata ( ) . pendingEndpointsFor ( tk , keyspaceName ) ; <nl> <nl> - if ( pairedEndpoint . isPresent ( ) ) <nl> - { <nl> - / / When local node is the endpoint and there are no pending nodes we can <nl> - / / Just apply the mutation locally . <nl> - if ( pairedEndpoint . get ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) <nl> - & & pendingEndpoints . isEmpty ( ) & & StorageService . instance . isJoined ( ) ) <nl> - try <nl> - { <nl> - mutation . apply ( writeCommitLog ) ; <nl> - } <nl> - catch ( Exception exc ) <nl> - { <nl> - logger . error ( " Error applying local view update to keyspace { } : { } " , mutation . getKeyspaceName ( ) , mutation ) ; <nl> - throw exc ; <nl> - } <nl> - else <nl> - { <nl> - wrappers . add ( wrapViewBatchResponseHandler ( mutation , <nl> - consistencyLevel , <nl> - consistencyLevel , <nl> - Collections . singletonList ( pairedEndpoint . get ( ) ) , <nl> - baseComplete , <nl> - WriteType . BATCH , <nl> - cleanup ) ) ; <nl> - } <nl> - } <nl> - else <nl> + / / if there are no paired endpoints there are probably range movements going on , so we write to the local batchlog to replay later <nl> + if ( ! pairedEndpoint . isPresent ( ) ) <nl> { <nl> - / / if there are no paired endpoints there are probably range movements going on , <nl> - / / so we write to the local batchlog to replay later <nl> if ( pendingEndpoints . isEmpty ( ) ) <nl> logger . warn ( " Received base materialized view mutation for key { } that does not belong " + <nl> " to this node . There is probably a range movement happening ( move or decommission ) , " + <nl> " but this node hasn ' t updated its ring metadata yet . Adding mutation to " + <nl> " local batchlog to be replayed later . " , <nl> mutation . key ( ) ) ; <nl> - nonPairedMutations . add ( mutation ) ; <nl> + continue ; <nl> + } <nl> + <nl> + / / When local node is the paired endpoint just apply the mutation locally . <nl> + if ( pairedEndpoint . get ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) & & StorageService . instance . isJoined ( ) ) <nl> + try <nl> + { <nl> + mutation . apply ( writeCommitLog ) ; <nl> + nonLocalMutations . remove ( mutation ) ; <nl> + cleanup . ackMutation ( ) ; <nl> + } <nl> + catch ( Exception exc ) <nl> + { <nl> + logger . error ( " Error applying local view update to keyspace { } : { } " , mutation . getKeyspaceName ( ) , mutation ) ; <nl> + throw exc ; <nl> + } <nl> + else <nl> + { <nl> + wrappers . add ( wrapViewBatchResponseHandler ( mutation , <nl> + consistencyLevel , <nl> + consistencyLevel , <nl> + Collections . singletonList ( pairedEndpoint . get ( ) ) , <nl> + baseComplete , <nl> + WriteType . BATCH , <nl> + cleanup ) ) ; <nl> } <nl> } <nl> <nl> - if ( ! wrappers . isEmpty ( ) ) <nl> - { <nl> - / / Apply to local batchlog memtable in this thread <nl> - BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , Lists . transform ( wrappers , w - > w . mutation ) ) , <nl> - writeCommitLog ) ; <nl> + / / Apply to local batchlog memtable in this thread <nl> + if ( ! nonLocalMutations . isEmpty ( ) ) <nl> + BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , nonLocalMutations ) , writeCommitLog ) ; <nl> <nl> - / / now actually perform the writes and wait for them to complete <nl> + / / Perform remote writes <nl> + if ( ! wrappers . isEmpty ( ) ) <nl> asyncWriteBatchedMutations ( wrappers , localDataCenter , Stage . VIEW _ MUTATION ) ; <nl> - } <nl> - <nl> - if ( ! nonPairedMutations . isEmpty ( ) ) <nl> - { <nl> - BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , nonPairedMutations ) , <nl> - writeCommitLog ) ; <nl> - } <nl> } <nl> } <nl> finally
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 76d155e . . 26b1794 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 15 
 + * Fix pending view mutations handling and cleanup batchlog when there are local and remote paired mutations ( CASSANDRA - 13069 ) 
 * Range deletes in a CAS batch are ignored ( CASSANDRA - 13655 ) 
 * Change repair midpoint logging for tiny ranges ( CASSANDRA - 13603 ) 
 * Better handle corrupt final commitlog segment ( CASSANDRA - 11995 ) 
 diff - - git a / src / java / org / apache / cassandra / batchlog / BatchlogManager . java b / src / java / org / apache / cassandra / batchlog / BatchlogManager . java 
 index b614fc5 . . a0b614f 100644 
 - - - a / src / java / org / apache / cassandra / batchlog / BatchlogManager . java 
 + + + b / src / java / org / apache / cassandra / batchlog / BatchlogManager . java 
 @ @ - 67 , 6 + 67 , 7 @ @ public class BatchlogManager implements BatchlogManagerMBean 
 
 private static final Logger logger = LoggerFactory . getLogger ( BatchlogManager . class ) ; 
 public static final BatchlogManager instance = new BatchlogManager ( ) ; 
 + public static final long BATCHLOG _ REPLAY _ TIMEOUT = Long . getLong ( " cassandra . batchlog . replay _ timeout _ in _ ms " , DatabaseDescriptor . getWriteRpcTimeout ( ) * 2 ) ; 
 
 private volatile long totalBatchesReplayed = 0 ; / / no concurrency protection necessary as only written by replay thread . 
 private volatile UUID lastReplayedUuid = UUIDGen . minTimeUUID ( 0 ) ; 
 @ @ - 284 , 7 + 285 , 7 @ @ public class BatchlogManager implements BatchlogManagerMBean 
 
 public static long getBatchlogTimeout ( ) 
 { 
 - return DatabaseDescriptor . getWriteRpcTimeout ( ) * 2 ; / / enough time for the actual write + BM removal mutation 
 + return BATCHLOG _ REPLAY _ TIMEOUT ; / / enough time for the actual write + BM removal mutation 
 } 
 
 private static class ReplayingBatch 
 diff - - git a / src / java / org / apache / cassandra / service / BatchlogResponseHandler . java b / src / java / org / apache / cassandra / service / BatchlogResponseHandler . java 
 index ac44923 . . a1477e6 100644 
 - - - a / src / java / org / apache / cassandra / service / BatchlogResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / BatchlogResponseHandler . java 
 @ @ - 50 , 7 + 50 , 7 @ @ public class BatchlogResponseHandler < T > extends AbstractWriteResponseHandler < T > 
 { 
 wrapped . response ( msg ) ; 
 if ( requiredBeforeFinishUpdater . decrementAndGet ( this ) = = 0 ) 
 - cleanup . run ( ) ; 
 + cleanup . ackMutation ( ) ; 
 } 
 
 public boolean isLatencyForSnitch ( ) 
 @ @ - 107 , 7 + 107 , 7 @ @ public class BatchlogResponseHandler < T > extends AbstractWriteResponseHandler < T > 
 this . callback = callback ; 
 } 
 
 - public void run ( ) 
 + public void ackMutation ( ) 
 { 
 if ( mutationsWaitingForUpdater . decrementAndGet ( this ) = = 0 ) 
 callback . invoke ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 6610cf7 . . 1ce1bc5 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 729 , 15 + 729 , 16 @ @ public class StorageProxy implements StorageProxyMBean 
 else 
 { 
 List < WriteResponseHandlerWrapper > wrappers = new ArrayList < > ( mutations . size ( ) ) ; 
 - List < Mutation > nonPairedMutations = new LinkedList < > ( ) ; 
 + / / non - local mutations rely on the base mutation commit - log entry for eventual consistency 
 + Set < Mutation > nonLocalMutations = new HashSet < > ( mutations ) ; 
 Token baseToken = StorageService . instance . getTokenMetadata ( ) . partitioner . getToken ( dataKey ) ; 
 
 ConsistencyLevel consistencyLevel = ConsistencyLevel . ONE ; 
 
 / / Since the base - > view replication is 1 : 1 we only need to store the BL locally 
 final Collection < InetAddress > batchlogEndpoints = Collections . singleton ( FBUtilities . getBroadcastAddress ( ) ) ; 
 - BatchlogResponseHandler . BatchlogCleanup cleanup = new BatchlogResponseHandler . BatchlogCleanup ( mutations . size ( ) , 
 - ( ) - > asyncRemoveFromBatchlog ( batchlogEndpoints , batchUUID ) ) ; 
 + BatchlogResponseHandler . BatchlogCleanup cleanup = new BatchlogResponseHandler . BatchlogCleanup ( mutations . size ( ) , ( ) - > asyncRemoveFromBatchlog ( batchlogEndpoints , batchUUID ) ) ; 
 + 
 / / add a handler for each mutation - includes checking availability , but doesn ' t initiate any writes , yet 
 for ( Mutation mutation : mutations ) 
 { 
 @ @ - 746 , 61 + 747 , 50 @ @ public class StorageProxy implements StorageProxyMBean 
 Optional < InetAddress > pairedEndpoint = ViewUtils . getViewNaturalEndpoint ( keyspaceName , baseToken , tk ) ; 
 Collection < InetAddress > pendingEndpoints = StorageService . instance . getTokenMetadata ( ) . pendingEndpointsFor ( tk , keyspaceName ) ; 
 
 - if ( pairedEndpoint . isPresent ( ) ) 
 - { 
 - / / When local node is the endpoint and there are no pending nodes we can 
 - / / Just apply the mutation locally . 
 - if ( pairedEndpoint . get ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) 
 - & & pendingEndpoints . isEmpty ( ) & & StorageService . instance . isJoined ( ) ) 
 - try 
 - { 
 - mutation . apply ( writeCommitLog ) ; 
 - } 
 - catch ( Exception exc ) 
 - { 
 - logger . error ( " Error applying local view update to keyspace { } : { } " , mutation . getKeyspaceName ( ) , mutation ) ; 
 - throw exc ; 
 - } 
 - else 
 - { 
 - wrappers . add ( wrapViewBatchResponseHandler ( mutation , 
 - consistencyLevel , 
 - consistencyLevel , 
 - Collections . singletonList ( pairedEndpoint . get ( ) ) , 
 - baseComplete , 
 - WriteType . BATCH , 
 - cleanup ) ) ; 
 - } 
 - } 
 - else 
 + / / if there are no paired endpoints there are probably range movements going on , so we write to the local batchlog to replay later 
 + if ( ! pairedEndpoint . isPresent ( ) ) 
 { 
 - / / if there are no paired endpoints there are probably range movements going on , 
 - / / so we write to the local batchlog to replay later 
 if ( pendingEndpoints . isEmpty ( ) ) 
 logger . warn ( " Received base materialized view mutation for key { } that does not belong " + 
 " to this node . There is probably a range movement happening ( move or decommission ) , " + 
 " but this node hasn ' t updated its ring metadata yet . Adding mutation to " + 
 " local batchlog to be replayed later . " , 
 mutation . key ( ) ) ; 
 - nonPairedMutations . add ( mutation ) ; 
 + continue ; 
 + } 
 + 
 + / / When local node is the paired endpoint just apply the mutation locally . 
 + if ( pairedEndpoint . get ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) & & StorageService . instance . isJoined ( ) ) 
 + try 
 + { 
 + mutation . apply ( writeCommitLog ) ; 
 + nonLocalMutations . remove ( mutation ) ; 
 + cleanup . ackMutation ( ) ; 
 + } 
 + catch ( Exception exc ) 
 + { 
 + logger . error ( " Error applying local view update to keyspace { } : { } " , mutation . getKeyspaceName ( ) , mutation ) ; 
 + throw exc ; 
 + } 
 + else 
 + { 
 + wrappers . add ( wrapViewBatchResponseHandler ( mutation , 
 + consistencyLevel , 
 + consistencyLevel , 
 + Collections . singletonList ( pairedEndpoint . get ( ) ) , 
 + baseComplete , 
 + WriteType . BATCH , 
 + cleanup ) ) ; 
 } 
 } 
 
 - if ( ! wrappers . isEmpty ( ) ) 
 - { 
 - / / Apply to local batchlog memtable in this thread 
 - BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , Lists . transform ( wrappers , w - > w . mutation ) ) , 
 - writeCommitLog ) ; 
 + / / Apply to local batchlog memtable in this thread 
 + if ( ! nonLocalMutations . isEmpty ( ) ) 
 + BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , nonLocalMutations ) , writeCommitLog ) ; 
 
 - / / now actually perform the writes and wait for them to complete 
 + / / Perform remote writes 
 + if ( ! wrappers . isEmpty ( ) ) 
 asyncWriteBatchedMutations ( wrappers , localDataCenter , Stage . VIEW _ MUTATION ) ; 
 - } 
 - 
 - if ( ! nonPairedMutations . isEmpty ( ) ) 
 - { 
 - BatchlogManager . store ( Batch . createLocal ( batchUUID , FBUtilities . timestampMicros ( ) , nonPairedMutations ) , 
 - writeCommitLog ) ; 
 - } 
 } 
 } 
 finally

NEAREST DIFF:
ELIMINATEDSENTENCE
