BLEU SCORE: 0.02383853510228548

TEST MSG: Nodetool tablehistograms to print statics for all the tables
GENERATED MSG: Support long name output from nodetool commands

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a5bdb42 . . e28ffd9 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Nodetool tablehistograms to print statics for all the tables ( CASSANDRA - 14185 ) <nl> * Migrate dtests to use pytest and python3 ( CASSANDRA - 14134 ) <nl> * Allow storage port to be configurable per node ( CASSANDRA - 7544 ) <nl> * Make sub - range selection for non - frozen collections return null instead of empty ( CASSANDRA - 14182 ) <nl> diff - - git a / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java b / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java <nl> index 5286e18 . . 910176a 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java <nl> + + + b / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java <nl> @ @ - 23 , 8 + 23 , 13 @ @ import io . airlift . airline . Arguments ; <nl> import io . airlift . airline . Command ; <nl> <nl> import java . util . ArrayList ; <nl> + import java . util . Arrays ; <nl> + import java . util . HashMap ; <nl> + import java . util . Iterator ; <nl> import java . util . List ; <nl> + import java . util . Map ; <nl> <nl> + import org . apache . cassandra . db . ColumnFamilyStoreMBean ; <nl> import org . apache . cassandra . metrics . CassandraMetricsRegistry ; <nl> import org . apache . cassandra . tools . NodeProbe ; <nl> import org . apache . cassandra . tools . NodeTool . NodeToolCmd ; <nl> @ @ - 34 , 107 + 39 , 126 @ @ import org . apache . commons . lang3 . ArrayUtils ; <nl> @ Command ( name = " tablehistograms " , description = " Print statistic histograms for a given table " ) <nl> public class TableHistograms extends NodeToolCmd <nl> { <nl> - @ Arguments ( usage = " < keyspace > < table > | < keyspace . table > " , description = " The keyspace and table name " ) <nl> + @ Arguments ( usage = " [ < keyspace > < table > | < keyspace . table > ] " , description = " The keyspace and table name " ) <nl> private List < String > args = new ArrayList < > ( ) ; <nl> <nl> @ Override <nl> public void execute ( NodeProbe probe ) <nl> { <nl> - String keyspace = null , table = null ; <nl> + Map < String , List < String > > tablesList = new HashMap < > ( ) ; <nl> if ( args . size ( ) = = 2 ) <nl> { <nl> - keyspace = args . get ( 0 ) ; <nl> - table = args . get ( 1 ) ; <nl> + tablesList . put ( args . get ( 0 ) , new ArrayList < String > ( Arrays . asList ( args . get ( 1 ) ) ) ) ; <nl> } <nl> else if ( args . size ( ) = = 1 ) <nl> { <nl> String [ ] input = args . get ( 0 ) . split ( " \ \ . " ) ; <nl> checkArgument ( input . length = = 2 , " tablehistograms requires keyspace and table name arguments " ) ; <nl> - keyspace = input [ 0 ] ; <nl> - table = input [ 1 ] ; <nl> + tablesList . put ( input [ 0 ] , new ArrayList < String > ( Arrays . asList ( input [ 1 ] ) ) ) ; <nl> } <nl> else <nl> { <nl> - checkArgument ( false , " tablehistograms requires keyspace and table name arguments " ) ; <nl> - } <nl> - <nl> - / / calculate percentile of row size and column count <nl> - long [ ] estimatedPartitionSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedPartitionSizeHistogram " ) ; <nl> - long [ ] estimatedColumnCount = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedColumnCountHistogram " ) ; <nl> - <nl> - / / build arrays to store percentile values <nl> - double [ ] estimatedRowSizePercentiles = new double [ 7 ] ; <nl> - double [ ] estimatedColumnCountPercentiles = new double [ 7 ] ; <nl> - double [ ] offsetPercentiles = new double [ ] { 0 . 5 , 0 . 75 , 0 . 95 , 0 . 98 , 0 . 99 } ; <nl> - <nl> - if ( ArrayUtils . isEmpty ( estimatedPartitionSize ) | | ArrayUtils . isEmpty ( estimatedColumnCount ) ) <nl> - { <nl> - System . err . println ( " No SSTables exists , unable to calculate ' Partition Size ' and ' Cell Count ' percentiles " ) ; <nl> - <nl> - for ( int i = 0 ; i < 7 ; i + + ) <nl> + / / get a list of table stores <nl> + Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > tableMBeans = probe . getColumnFamilyStoreMBeanProxies ( ) ; <nl> + while ( tableMBeans . hasNext ( ) ) <nl> { <nl> - estimatedRowSizePercentiles [ i ] = Double . NaN ; <nl> - estimatedColumnCountPercentiles [ i ] = Double . NaN ; <nl> + Map . Entry < String , ColumnFamilyStoreMBean > entry = tableMBeans . next ( ) ; <nl> + String keyspaceName = entry . getKey ( ) ; <nl> + ColumnFamilyStoreMBean tableProxy = entry . getValue ( ) ; <nl> + if ( ! tablesList . containsKey ( keyspaceName ) ) <nl> + { <nl> + tablesList . put ( keyspaceName , new ArrayList < String > ( ) ) ; <nl> + } <nl> + tablesList . get ( keyspaceName ) . add ( tableProxy . getTableName ( ) ) ; <nl> } <nl> } <nl> - else <nl> - { <nl> - EstimatedHistogram partitionSizeHist = new EstimatedHistogram ( estimatedPartitionSize ) ; <nl> - EstimatedHistogram columnCountHist = new EstimatedHistogram ( estimatedColumnCount ) ; <nl> <nl> - if ( partitionSizeHist . isOverflowed ( ) ) <nl> + Iterator < Map . Entry < String , List < String > > > iter = tablesList . entrySet ( ) . iterator ( ) ; <nl> + while ( iter . hasNext ( ) ) <nl> + { <nl> + Map . Entry < String , List < String > > entry = iter . next ( ) ; <nl> + String keyspace = entry . getKey ( ) ; <nl> + for ( String table : entry . getValue ( ) ) <nl> { <nl> - System . err . println ( String . format ( " Row sizes are larger than % s , unable to calculate percentiles " , partitionSizeHist . getLargestBucketOffset ( ) ) ) ; <nl> - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> + / / calculate percentile of row size and column count <nl> + long [ ] estimatedPartitionSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedPartitionSizeHistogram " ) ; <nl> + long [ ] estimatedColumnCount = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedColumnCountHistogram " ) ; <nl> + <nl> + / / build arrays to store percentile values <nl> + double [ ] estimatedRowSizePercentiles = new double [ 7 ] ; <nl> + double [ ] estimatedColumnCountPercentiles = new double [ 7 ] ; <nl> + double [ ] offsetPercentiles = new double [ ] { 0 . 5 , 0 . 75 , 0 . 95 , 0 . 98 , 0 . 99 } ; <nl> + <nl> + if ( ArrayUtils . isEmpty ( estimatedPartitionSize ) | | ArrayUtils . isEmpty ( estimatedColumnCount ) ) <nl> + { <nl> + System . out . println ( " No SSTables exists , unable to calculate ' Partition Size ' and ' Cell Count ' percentiles " ) ; <nl> + <nl> + for ( int i = 0 ; i < 7 ; i + + ) <nl> + { <nl> estimatedRowSizePercentiles [ i ] = Double . NaN ; <nl> - } <nl> - else <nl> - { <nl> - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> - estimatedRowSizePercentiles [ i ] = partitionSizeHist . percentile ( offsetPercentiles [ i ] ) ; <nl> - } <nl> + estimatedColumnCountPercentiles [ i ] = Double . NaN ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + EstimatedHistogram partitionSizeHist = new EstimatedHistogram ( estimatedPartitionSize ) ; <nl> + EstimatedHistogram columnCountHist = new EstimatedHistogram ( estimatedColumnCount ) ; <nl> <nl> - if ( columnCountHist . isOverflowed ( ) ) <nl> - { <nl> - System . err . println ( String . format ( " Column counts are larger than % s , unable to calculate percentiles " , columnCountHist . getLargestBucketOffset ( ) ) ) ; <nl> - for ( int i = 0 ; i < estimatedColumnCountPercentiles . length ; i + + ) <nl> - estimatedColumnCountPercentiles [ i ] = Double . NaN ; <nl> - } <nl> - else <nl> - { <nl> - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> - estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; <nl> - } <nl> + if ( partitionSizeHist . isOverflowed ( ) ) <nl> + { <nl> + System . out . println ( String . format ( " Row sizes are larger than % s , unable to calculate percentiles " , partitionSizeHist . getLargestBucketOffset ( ) ) ) ; <nl> + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> + estimatedRowSizePercentiles [ i ] = Double . NaN ; <nl> + } <nl> + else <nl> + { <nl> + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> + estimatedRowSizePercentiles [ i ] = partitionSizeHist . percentile ( offsetPercentiles [ i ] ) ; <nl> + } <nl> <nl> - / / min value <nl> - estimatedRowSizePercentiles [ 5 ] = partitionSizeHist . min ( ) ; <nl> - estimatedColumnCountPercentiles [ 5 ] = columnCountHist . min ( ) ; <nl> - / / max value <nl> - estimatedRowSizePercentiles [ 6 ] = partitionSizeHist . max ( ) ; <nl> - estimatedColumnCountPercentiles [ 6 ] = columnCountHist . max ( ) ; <nl> - } <nl> + if ( columnCountHist . isOverflowed ( ) ) <nl> + { <nl> + System . out . println ( String . format ( " Column counts are larger than % s , unable to calculate percentiles " , columnCountHist . getLargestBucketOffset ( ) ) ) ; <nl> + for ( int i = 0 ; i < estimatedColumnCountPercentiles . length ; i + + ) <nl> + estimatedColumnCountPercentiles [ i ] = Double . NaN ; <nl> + } <nl> + else <nl> + { <nl> + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> + estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; <nl> + } <nl> <nl> - String [ ] percentiles = new String [ ] { " 50 % " , " 75 % " , " 95 % " , " 98 % " , " 99 % " , " Min " , " Max " } ; <nl> - double [ ] readLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , " ReadLatency " ) ) ; <nl> - double [ ] writeLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , " WriteLatency " ) ) ; <nl> - double [ ] sstablesPerRead = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxHistogramMBean ) probe . getColumnFamilyMetric ( keyspace , table , " SSTablesPerReadHistogram " ) ) ; <nl> + / / min value <nl> + estimatedRowSizePercentiles [ 5 ] = partitionSizeHist . min ( ) ; <nl> + estimatedColumnCountPercentiles [ 5 ] = columnCountHist . min ( ) ; <nl> + / / max value <nl> + estimatedRowSizePercentiles [ 6 ] = partitionSizeHist . max ( ) ; <nl> + estimatedColumnCountPercentiles [ 6 ] = columnCountHist . max ( ) ; <nl> + } <nl> <nl> - System . out . println ( format ( " % s / % s histograms " , keyspace , table ) ) ; <nl> - System . out . println ( format ( " % - 10s % 10s % 18s % 18s % 18s % 18s " , <nl> - " Percentile " , " SSTables " , " Write Latency " , " Read Latency " , " Partition Size " , " Cell Count " ) ) ; <nl> - System . out . println ( format ( " % - 10s % 10s % 18s % 18s % 18s % 18s " , <nl> - " " , " " , " ( micros ) " , " ( micros ) " , " ( bytes ) " , " " ) ) ; <nl> + String [ ] percentiles = new String [ ] { " 50 % " , " 75 % " , " 95 % " , " 98 % " , " 99 % " , " Min " , " Max " } ; <nl> + double [ ] readLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , " ReadLatency " ) ) ; <nl> + double [ ] writeLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , " WriteLatency " ) ) ; <nl> + double [ ] sstablesPerRead = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxHistogramMBean ) probe . getColumnFamilyMetric ( keyspace , table , " SSTablesPerReadHistogram " ) ) ; <nl> <nl> - for ( int i = 0 ; i < percentiles . length ; i + + ) <nl> - { <nl> - System . out . println ( format ( " % - 10s % 10 . 2f % 18 . 2f % 18 . 2f % 18 . 0f % 18 . 0f " , <nl> - percentiles [ i ] , <nl> - sstablesPerRead [ i ] , <nl> - writeLatency [ i ] , <nl> - readLatency [ i ] , <nl> - estimatedRowSizePercentiles [ i ] , <nl> - estimatedColumnCountPercentiles [ i ] ) ) ; <nl> + System . out . println ( format ( " % s / % s histograms " , keyspace , table ) ) ; <nl> + System . out . println ( format ( " % - 10s % 10s % 18s % 18s % 18s % 18s " , <nl> + " Percentile " , " SSTables " , " Write Latency " , " Read Latency " , " Partition Size " , " Cell Count " ) ) ; <nl> + System . out . println ( format ( " % - 10s % 10s % 18s % 18s % 18s % 18s " , <nl> + " " , " " , " ( micros ) " , " ( micros ) " , " ( bytes ) " , " " ) ) ; <nl> + <nl> + for ( int i = 0 ; i < percentiles . length ; i + + ) <nl> + { <nl> + System . out . println ( format ( " % - 10s % 10 . 2f % 18 . 2f % 18 . 2f % 18 . 0f % 18 . 0f " , <nl> + percentiles [ i ] , <nl> + sstablesPerRead [ i ] , <nl> + writeLatency [ i ] , <nl> + readLatency [ i ] , <nl> + estimatedRowSizePercentiles [ i ] , <nl> + estimatedColumnCountPercentiles [ i ] ) ) ; <nl> + } <nl> + System . out . println ( ) ; <nl> + } <nl> } <nl> - System . out . println ( ) ; <nl> } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a5bdb42 . . e28ffd9 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Nodetool tablehistograms to print statics for all the tables ( CASSANDRA - 14185 ) 
 * Migrate dtests to use pytest and python3 ( CASSANDRA - 14134 ) 
 * Allow storage port to be configurable per node ( CASSANDRA - 7544 ) 
 * Make sub - range selection for non - frozen collections return null instead of empty ( CASSANDRA - 14182 ) 
 diff - - git a / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java b / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java 
 index 5286e18 . . 910176a 100644 
 - - - a / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java 
 + + + b / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java 
 @ @ - 23 , 8 + 23 , 13 @ @ import io . airlift . airline . Arguments ; 
 import io . airlift . airline . Command ; 
 
 import java . util . ArrayList ; 
 + import java . util . Arrays ; 
 + import java . util . HashMap ; 
 + import java . util . Iterator ; 
 import java . util . List ; 
 + import java . util . Map ; 
 
 + import org . apache . cassandra . db . ColumnFamilyStoreMBean ; 
 import org . apache . cassandra . metrics . CassandraMetricsRegistry ; 
 import org . apache . cassandra . tools . NodeProbe ; 
 import org . apache . cassandra . tools . NodeTool . NodeToolCmd ; 
 @ @ - 34 , 107 + 39 , 126 @ @ import org . apache . commons . lang3 . ArrayUtils ; 
 @ Command ( name = " tablehistograms " , description = " Print statistic histograms for a given table " ) 
 public class TableHistograms extends NodeToolCmd 
 { 
 - @ Arguments ( usage = " < keyspace > < table > | < keyspace . table > " , description = " The keyspace and table name " ) 
 + @ Arguments ( usage = " [ < keyspace > < table > | < keyspace . table > ] " , description = " The keyspace and table name " ) 
 private List < String > args = new ArrayList < > ( ) ; 
 
 @ Override 
 public void execute ( NodeProbe probe ) 
 { 
 - String keyspace = null , table = null ; 
 + Map < String , List < String > > tablesList = new HashMap < > ( ) ; 
 if ( args . size ( ) = = 2 ) 
 { 
 - keyspace = args . get ( 0 ) ; 
 - table = args . get ( 1 ) ; 
 + tablesList . put ( args . get ( 0 ) , new ArrayList < String > ( Arrays . asList ( args . get ( 1 ) ) ) ) ; 
 } 
 else if ( args . size ( ) = = 1 ) 
 { 
 String [ ] input = args . get ( 0 ) . split ( " \ \ . " ) ; 
 checkArgument ( input . length = = 2 , " tablehistograms requires keyspace and table name arguments " ) ; 
 - keyspace = input [ 0 ] ; 
 - table = input [ 1 ] ; 
 + tablesList . put ( input [ 0 ] , new ArrayList < String > ( Arrays . asList ( input [ 1 ] ) ) ) ; 
 } 
 else 
 { 
 - checkArgument ( false , " tablehistograms requires keyspace and table name arguments " ) ; 
 - } 
 - 
 - / / calculate percentile of row size and column count 
 - long [ ] estimatedPartitionSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedPartitionSizeHistogram " ) ; 
 - long [ ] estimatedColumnCount = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedColumnCountHistogram " ) ; 
 - 
 - / / build arrays to store percentile values 
 - double [ ] estimatedRowSizePercentiles = new double [ 7 ] ; 
 - double [ ] estimatedColumnCountPercentiles = new double [ 7 ] ; 
 - double [ ] offsetPercentiles = new double [ ] { 0 . 5 , 0 . 75 , 0 . 95 , 0 . 98 , 0 . 99 } ; 
 - 
 - if ( ArrayUtils . isEmpty ( estimatedPartitionSize ) | | ArrayUtils . isEmpty ( estimatedColumnCount ) ) 
 - { 
 - System . err . println ( " No SSTables exists , unable to calculate ' Partition Size ' and ' Cell Count ' percentiles " ) ; 
 - 
 - for ( int i = 0 ; i < 7 ; i + + ) 
 + / / get a list of table stores 
 + Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > tableMBeans = probe . getColumnFamilyStoreMBeanProxies ( ) ; 
 + while ( tableMBeans . hasNext ( ) ) 
 { 
 - estimatedRowSizePercentiles [ i ] = Double . NaN ; 
 - estimatedColumnCountPercentiles [ i ] = Double . NaN ; 
 + Map . Entry < String , ColumnFamilyStoreMBean > entry = tableMBeans . next ( ) ; 
 + String keyspaceName = entry . getKey ( ) ; 
 + ColumnFamilyStoreMBean tableProxy = entry . getValue ( ) ; 
 + if ( ! tablesList . containsKey ( keyspaceName ) ) 
 + { 
 + tablesList . put ( keyspaceName , new ArrayList < String > ( ) ) ; 
 + } 
 + tablesList . get ( keyspaceName ) . add ( tableProxy . getTableName ( ) ) ; 
 } 
 } 
 - else 
 - { 
 - EstimatedHistogram partitionSizeHist = new EstimatedHistogram ( estimatedPartitionSize ) ; 
 - EstimatedHistogram columnCountHist = new EstimatedHistogram ( estimatedColumnCount ) ; 
 
 - if ( partitionSizeHist . isOverflowed ( ) ) 
 + Iterator < Map . Entry < String , List < String > > > iter = tablesList . entrySet ( ) . iterator ( ) ; 
 + while ( iter . hasNext ( ) ) 
 + { 
 + Map . Entry < String , List < String > > entry = iter . next ( ) ; 
 + String keyspace = entry . getKey ( ) ; 
 + for ( String table : entry . getValue ( ) ) 
 { 
 - System . err . println ( String . format ( " Row sizes are larger than % s , unable to calculate percentiles " , partitionSizeHist . getLargestBucketOffset ( ) ) ) ; 
 - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 + / / calculate percentile of row size and column count 
 + long [ ] estimatedPartitionSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedPartitionSizeHistogram " ) ; 
 + long [ ] estimatedColumnCount = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedColumnCountHistogram " ) ; 
 + 
 + / / build arrays to store percentile values 
 + double [ ] estimatedRowSizePercentiles = new double [ 7 ] ; 
 + double [ ] estimatedColumnCountPercentiles = new double [ 7 ] ; 
 + double [ ] offsetPercentiles = new double [ ] { 0 . 5 , 0 . 75 , 0 . 95 , 0 . 98 , 0 . 99 } ; 
 + 
 + if ( ArrayUtils . isEmpty ( estimatedPartitionSize ) | | ArrayUtils . isEmpty ( estimatedColumnCount ) ) 
 + { 
 + System . out . println ( " No SSTables exists , unable to calculate ' Partition Size ' and ' Cell Count ' percentiles " ) ; 
 + 
 + for ( int i = 0 ; i < 7 ; i + + ) 
 + { 
 estimatedRowSizePercentiles [ i ] = Double . NaN ; 
 - } 
 - else 
 - { 
 - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 - estimatedRowSizePercentiles [ i ] = partitionSizeHist . percentile ( offsetPercentiles [ i ] ) ; 
 - } 
 + estimatedColumnCountPercentiles [ i ] = Double . NaN ; 
 + } 
 + } 
 + else 
 + { 
 + EstimatedHistogram partitionSizeHist = new EstimatedHistogram ( estimatedPartitionSize ) ; 
 + EstimatedHistogram columnCountHist = new EstimatedHistogram ( estimatedColumnCount ) ; 
 
 - if ( columnCountHist . isOverflowed ( ) ) 
 - { 
 - System . err . println ( String . format ( " Column counts are larger than % s , unable to calculate percentiles " , columnCountHist . getLargestBucketOffset ( ) ) ) ; 
 - for ( int i = 0 ; i < estimatedColumnCountPercentiles . length ; i + + ) 
 - estimatedColumnCountPercentiles [ i ] = Double . NaN ; 
 - } 
 - else 
 - { 
 - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 - estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; 
 - } 
 + if ( partitionSizeHist . isOverflowed ( ) ) 
 + { 
 + System . out . println ( String . format ( " Row sizes are larger than % s , unable to calculate percentiles " , partitionSizeHist . getLargestBucketOffset ( ) ) ) ; 
 + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 + estimatedRowSizePercentiles [ i ] = Double . NaN ; 
 + } 
 + else 
 + { 
 + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 + estimatedRowSizePercentiles [ i ] = partitionSizeHist . percentile ( offsetPercentiles [ i ] ) ; 
 + } 
 
 - / / min value 
 - estimatedRowSizePercentiles [ 5 ] = partitionSizeHist . min ( ) ; 
 - estimatedColumnCountPercentiles [ 5 ] = columnCountHist . min ( ) ; 
 - / / max value 
 - estimatedRowSizePercentiles [ 6 ] = partitionSizeHist . max ( ) ; 
 - estimatedColumnCountPercentiles [ 6 ] = columnCountHist . max ( ) ; 
 - } 
 + if ( columnCountHist . isOverflowed ( ) ) 
 + { 
 + System . out . println ( String . format ( " Column counts are larger than % s , unable to calculate percentiles " , columnCountHist . getLargestBucketOffset ( ) ) ) ; 
 + for ( int i = 0 ; i < estimatedColumnCountPercentiles . length ; i + + ) 
 + estimatedColumnCountPercentiles [ i ] = Double . NaN ; 
 + } 
 + else 
 + { 
 + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 + estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; 
 + } 
 
 - String [ ] percentiles = new String [ ] { " 50 % " , " 75 % " , " 95 % " , " 98 % " , " 99 % " , " Min " , " Max " } ; 
 - double [ ] readLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , " ReadLatency " ) ) ; 
 - double [ ] writeLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , " WriteLatency " ) ) ; 
 - double [ ] sstablesPerRead = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxHistogramMBean ) probe . getColumnFamilyMetric ( keyspace , table , " SSTablesPerReadHistogram " ) ) ; 
 + / / min value 
 + estimatedRowSizePercentiles [ 5 ] = partitionSizeHist . min ( ) ; 
 + estimatedColumnCountPercentiles [ 5 ] = columnCountHist . min ( ) ; 
 + / / max value 
 + estimatedRowSizePercentiles [ 6 ] = partitionSizeHist . max ( ) ; 
 + estimatedColumnCountPercentiles [ 6 ] = columnCountHist . max ( ) ; 
 + } 
 
 - System . out . println ( format ( " % s / % s histograms " , keyspace , table ) ) ; 
 - System . out . println ( format ( " % - 10s % 10s % 18s % 18s % 18s % 18s " , 
 - " Percentile " , " SSTables " , " Write Latency " , " Read Latency " , " Partition Size " , " Cell Count " ) ) ; 
 - System . out . println ( format ( " % - 10s % 10s % 18s % 18s % 18s % 18s " , 
 - " " , " " , " ( micros ) " , " ( micros ) " , " ( bytes ) " , " " ) ) ; 
 + String [ ] percentiles = new String [ ] { " 50 % " , " 75 % " , " 95 % " , " 98 % " , " 99 % " , " Min " , " Max " } ; 
 + double [ ] readLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , " ReadLatency " ) ) ; 
 + double [ ] writeLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , " WriteLatency " ) ) ; 
 + double [ ] sstablesPerRead = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxHistogramMBean ) probe . getColumnFamilyMetric ( keyspace , table , " SSTablesPerReadHistogram " ) ) ; 
 
 - for ( int i = 0 ; i < percentiles . length ; i + + ) 
 - { 
 - System . out . println ( format ( " % - 10s % 10 . 2f % 18 . 2f % 18 . 2f % 18 . 0f % 18 . 0f " , 
 - percentiles [ i ] , 
 - sstablesPerRead [ i ] , 
 - writeLatency [ i ] , 
 - readLatency [ i ] , 
 - estimatedRowSizePercentiles [ i ] , 
 - estimatedColumnCountPercentiles [ i ] ) ) ; 
 + System . out . println ( format ( " % s / % s histograms " , keyspace , table ) ) ; 
 + System . out . println ( format ( " % - 10s % 10s % 18s % 18s % 18s % 18s " , 
 + " Percentile " , " SSTables " , " Write Latency " , " Read Latency " , " Partition Size " , " Cell Count " ) ) ; 
 + System . out . println ( format ( " % - 10s % 10s % 18s % 18s % 18s % 18s " , 
 + " " , " " , " ( micros ) " , " ( micros ) " , " ( bytes ) " , " " ) ) ; 
 + 
 + for ( int i = 0 ; i < percentiles . length ; i + + ) 
 + { 
 + System . out . println ( format ( " % - 10s % 10 . 2f % 18 . 2f % 18 . 2f % 18 . 0f % 18 . 0f " , 
 + percentiles [ i ] , 
 + sstablesPerRead [ i ] , 
 + writeLatency [ i ] , 
 + readLatency [ i ] , 
 + estimatedRowSizePercentiles [ i ] , 
 + estimatedColumnCountPercentiles [ i ] ) ) ; 
 + } 
 + System . out . println ( ) ; 
 + } 
 } 
 - System . out . println ( ) ; 
 } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
