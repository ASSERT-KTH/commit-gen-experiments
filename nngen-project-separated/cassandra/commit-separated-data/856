BLEU SCORE: 0.027611988917697356

TEST MSG: Avoid holding SSTableReaders for duration of incremental repair
GENERATED MSG: merge from 0 . 7 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7a0ccba . . fcd7c3c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 15 <nl> + * Avoid holding SSTableReaders for duration of incremental repair ( CASSANDRA - 11739 ) <nl> * Add message dropped tasks to nodetool netstats ( CASSANDRA - 11855 ) <nl> * Don ' t compute expensive MaxPurgeableTimestamp until we ' ve verified there ' s an <nl> expired tombstone ( CASSANDRA - 11834 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index 96d873f . . 5af63fe 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 474 , 7 + 474 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> / * * <nl> * Make sure the { validatedForRepair } are marked for compaction before calling this . <nl> * <nl> - * Caller must reference the validatedForRepair sstables ( via ParentRepairSession . getAndReferenceSSTables ( . . ) ) . <nl> + * Caller must reference the validatedForRepair sstables ( via ParentRepairSession . getActiveRepairedSSTableRefs ( . . ) ) . <nl> * <nl> * @ param cfs <nl> * @ param ranges Ranges that the repair was carried out on <nl> diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> index 732267e . . 5297ce3 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> @ @ - 17 , 7 + 17 , 6 @ @ <nl> * / <nl> package org . apache . cassandra . service ; <nl> <nl> - import java . io . File ; <nl> import java . net . InetAddress ; <nl> import java . net . UnknownHostException ; <nl> import java . util . * ; <nl> @ @ - 42 , 7 + 41 , 6 @ @ import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . gms . FailureDetector ; <nl> import org . apache . cassandra . gms . Gossiper ; <nl> - import org . apache . cassandra . io . sstable . Component ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> import org . apache . cassandra . net . IAsyncCallbackWithFailure ; <nl> @ @ - 321 , 7 + 319 , 7 @ @ public class ActiveRepairService <nl> Set < SSTableReader > repairing = new HashSet < > ( ) ; <nl> for ( Map . Entry < UUID , ParentRepairSession > entry : parentRepairSessions . entrySet ( ) ) <nl> { <nl> - Collection < SSTableReader > sstables = entry . getValue ( ) . sstableMap . get ( cfId ) ; <nl> + Collection < SSTableReader > sstables = entry . getValue ( ) . getActiveSSTables ( cfId ) ; <nl> if ( sstables ! = null & & ! entry . getKey ( ) . equals ( parentRepairSession ) ) <nl> repairing . addAll ( sstables ) ; <nl> } <nl> @ @ - 384 , 7 + 382 , 7 @ @ public class ActiveRepairService <nl> List < ListenableFuture < ? > > futures = new ArrayList < > ( ) ; <nl> for ( Map . Entry < UUID , ColumnFamilyStore > columnFamilyStoreEntry : prs . columnFamilyStores . entrySet ( ) ) <nl> { <nl> - Refs < SSTableReader > sstables = prs . getAndReferenceSSTables ( columnFamilyStoreEntry . getKey ( ) ) ; <nl> + Refs < SSTableReader > sstables = prs . getActiveRepairedSSTableRefs ( columnFamilyStoreEntry . getKey ( ) ) ; <nl> ColumnFamilyStore cfs = columnFamilyStoreEntry . getValue ( ) ; <nl> futures . add ( CompactionManager . instance . submitAntiCompaction ( cfs , prs . ranges , sstables , prs . repairedAt ) ) ; <nl> } <nl> @ @ - 428 , 7 + 426 , 7 @ @ public class ActiveRepairService <nl> { <nl> public final Map < UUID , ColumnFamilyStore > columnFamilyStores = new HashMap < > ( ) ; <nl> public final Collection < Range < Token > > ranges ; <nl> - public final Map < UUID , Set < SSTableReader > > sstableMap = new HashMap < > ( ) ; <nl> + public final Map < UUID , Set < String > > sstableMap = new HashMap < > ( ) ; <nl> public final long repairedAt ; <nl> <nl> public ParentRepairSession ( List < ColumnFamilyStore > columnFamilyStores , Collection < Range < Token > > ranges , long repairedAt ) <nl> @ @ - 436 , 39 + 434 , 50 @ @ public class ActiveRepairService <nl> for ( ColumnFamilyStore cfs : columnFamilyStores ) <nl> { <nl> this . columnFamilyStores . put ( cfs . metadata . cfId , cfs ) ; <nl> - sstableMap . put ( cfs . metadata . cfId , new HashSet < SSTableReader > ( ) ) ; <nl> + sstableMap . put ( cfs . metadata . cfId , new HashSet < String > ( ) ) ; <nl> } <nl> this . ranges = ranges ; <nl> this . repairedAt = repairedAt ; <nl> } <nl> <nl> - public synchronized Refs < SSTableReader > getAndReferenceSSTables ( UUID cfId ) <nl> + @ SuppressWarnings ( " resource " ) <nl> + public synchronized Refs < SSTableReader > getActiveRepairedSSTableRefs ( UUID cfId ) <nl> { <nl> - Set < SSTableReader > sstables = sstableMap . get ( cfId ) ; <nl> - Iterator < SSTableReader > sstableIterator = sstables . iterator ( ) ; <nl> ImmutableMap . Builder < SSTableReader , Ref < SSTableReader > > references = ImmutableMap . builder ( ) ; <nl> - while ( sstableIterator . hasNext ( ) ) <nl> + for ( SSTableReader sstable : getActiveSSTables ( cfId ) ) <nl> { <nl> - SSTableReader sstable = sstableIterator . next ( ) ; <nl> - if ( ! new File ( sstable . descriptor . filenameFor ( Component . DATA ) ) . exists ( ) ) <nl> - { <nl> - sstableIterator . remove ( ) ; <nl> - } <nl> + Ref < SSTableReader > ref = sstable . tryRef ( ) ; <nl> + if ( ref = = null ) <nl> + sstableMap . get ( cfId ) . remove ( sstable . getFilename ( ) ) ; <nl> else <nl> + references . put ( sstable , ref ) ; <nl> + } <nl> + return new Refs < > ( references . build ( ) ) ; <nl> + } <nl> + <nl> + private Set < SSTableReader > getActiveSSTables ( UUID cfId ) <nl> + { <nl> + Set < String > repairedSSTables = sstableMap . get ( cfId ) ; <nl> + Set < SSTableReader > activeSSTables = new HashSet < > ( ) ; <nl> + Set < String > activeSSTableNames = new HashSet < > ( ) ; <nl> + for ( SSTableReader sstable : columnFamilyStores . get ( cfId ) . getSSTables ( ) ) <nl> + { <nl> + if ( repairedSSTables . contains ( sstable . getFilename ( ) ) ) <nl> { <nl> - Ref < SSTableReader > ref = sstable . tryRef ( ) ; <nl> - if ( ref = = null ) <nl> - sstableIterator . remove ( ) ; <nl> - else <nl> - references . put ( sstable , ref ) ; <nl> + activeSSTables . add ( sstable ) ; <nl> + activeSSTableNames . add ( sstable . getFilename ( ) ) ; <nl> } <nl> } <nl> - return new Refs < > ( references . build ( ) ) ; <nl> + sstableMap . put ( cfId , activeSSTableNames ) ; <nl> + return activeSSTables ; <nl> } <nl> <nl> public void addSSTables ( UUID cfId , Collection < SSTableReader > sstables ) <nl> { <nl> - sstableMap . get ( cfId ) . addAll ( sstables ) ; <nl> + for ( SSTableReader sstable : sstables ) <nl> + { <nl> + sstableMap . get ( cfId ) . add ( sstable . getFilename ( ) ) ; <nl> + } <nl> } <nl> <nl> @ Override <nl> diff - - git a / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java b / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java <nl> new file mode 100644 <nl> index 0000000 . . 419ea1a <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java <nl> @ @ - 0 , 0 + 1 , 107 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . service ; <nl> + <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . HashSet ; <nl> + import java . util . Iterator ; <nl> + import java . util . Set ; <nl> + import java . util . UUID ; <nl> + <nl> + import com . google . common . collect . Sets ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . Util ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . db . Mutation ; <nl> + import org . apache . cassandra . io . sstable . SSTableReader ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . concurrent . Refs ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> + <nl> + public class ActiveRepairServiceTest extends SchemaLoader <nl> + { <nl> + <nl> + private static final String KEYSPACE1 = " Keyspace1 " ; <nl> + private static final String CF = " Standard1 " ; <nl> + <nl> + @ Test <nl> + public void testGetActiveRepairedSSTableRefs ( ) <nl> + { <nl> + ColumnFamilyStore store = prepareColumnFamilyStore ( ) ; <nl> + Set < SSTableReader > original = store . getUnrepairedSSTables ( ) ; <nl> + <nl> + UUID prsId = UUID . randomUUID ( ) ; <nl> + ActiveRepairService . instance . registerParentRepairSession ( prsId , Collections . singletonList ( store ) , null ) ; <nl> + ActiveRepairService . ParentRepairSession prs = ActiveRepairService . instance . getParentRepairSession ( prsId ) ; <nl> + <nl> + / / add all sstables to parent repair session <nl> + prs . addSSTables ( store . metadata . cfId , original ) ; <nl> + <nl> + / / retrieve all sstable references from parent repair sessions <nl> + Refs < SSTableReader > refs = prs . getActiveRepairedSSTableRefs ( store . metadata . cfId ) ; <nl> + Set < SSTableReader > retrieved = Sets . newHashSet ( refs . iterator ( ) ) ; <nl> + assertEquals ( original , retrieved ) ; <nl> + refs . release ( ) ; <nl> + <nl> + / / remove 1 sstable from data data tracker <nl> + Set < SSTableReader > newLiveSet = new HashSet < > ( original ) ; <nl> + Iterator < SSTableReader > it = newLiveSet . iterator ( ) ; <nl> + SSTableReader removed = it . next ( ) ; <nl> + it . remove ( ) ; <nl> + store . getDataTracker ( ) . replaceWithNewInstances ( Collections . singleton ( removed ) , Collections . EMPTY _ SET ) ; <nl> + <nl> + / / retrieve sstable references from parent repair session again - removed sstable must not be present <nl> + refs = prs . getActiveRepairedSSTableRefs ( store . metadata . cfId ) ; <nl> + retrieved = Sets . newHashSet ( refs . iterator ( ) ) ; <nl> + assertEquals ( newLiveSet , retrieved ) ; <nl> + assertFalse ( retrieved . contains ( removed ) ) ; <nl> + refs . release ( ) ; <nl> + } <nl> + <nl> + private ColumnFamilyStore prepareColumnFamilyStore ( ) <nl> + { <nl> + Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; <nl> + ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; <nl> + store . truncateBlocking ( ) ; <nl> + store . disableAutoCompaction ( ) ; <nl> + long timestamp = System . currentTimeMillis ( ) ; <nl> + / / create 10 sstables <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + { <nl> + DecoratedKey key = Util . dk ( Integer . toString ( i ) ) ; <nl> + Mutation rm = new Mutation ( KEYSPACE1 , key . getKey ( ) ) ; <nl> + for ( int j = 0 ; j < 10 ; j + + ) <nl> + rm . add ( " Standard1 " , Util . cellname ( Integer . toString ( j ) ) , <nl> + ByteBufferUtil . EMPTY _ BYTE _ BUFFER , <nl> + timestamp , <nl> + 0 ) ; <nl> + rm . apply ( ) ; <nl> + store . forceBlockingFlush ( ) ; <nl> + } <nl> + return store ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2bfc0e8 . . acec31e 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 18 , 6 + 18 , 7 @ @ dev <nl> replication Strategies <nl> * increased amount of index locks for faster commitlog replay <nl> * collect secondary index tombstones immediately ( CASSANDRA - 1914 ) <nl> + * revert commitlog changes from # 1780 ( CASSANDRA - 1917 ) <nl> <nl> <nl> 0 . 7 . 0 - rc3 <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index ba171d9 . . 8c629e1 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 61 , 32 + 61 , 17 @ @ saved _ caches _ directory : / var / lib / cassandra / saved _ caches <nl> # Size to allow commitlog to grow to before creating a new segment <nl> commitlog _ rotation _ threshold _ in _ mb : 128 <nl> <nl> - # commitlog _ sync supports the following modes : <nl> - # <nl> - # batch : <nl> - # In batch mode , Cassandra won ' t ack writes until the commit log <nl> - # has been fsynced to disk . But fsyncing each write at once is <nl> - # performance - prohibitive , so instead Cassandra will wait up to <nl> - # commitlog _ sync _ batch _ window _ in _ ms milliseconds for other writes , before <nl> - # syncing that " batch " at once . This causes a performance penalty <nl> - # of about 15 % when the commitlog is on a separate device , and much more <nl> - # when it shares the same device as the data files . <nl> - # <nl> - # periodic : <nl> - # Writes may be acked immediately ( without waiting for the commitlog <nl> - # append ) and the CommitLog is simply synced every <nl> - # commitlog _ sync _ period _ in _ ms milliseconds . <nl> - # <nl> - # periodic _ without _ flush : <nl> - # Like periodic , but the commitlog write buffer is only flushed <nl> - # before the sync , so any interruption to the process can be <nl> - # expected to lose some writes . This is the old 0 . 6 periodic <nl> - # behavior and will be removed in future versions if testing <nl> - # continues to show no performance benefit over normal periodic . <nl> + # commitlog _ sync may be either " periodic " or " batch . " <nl> + # When in batch mode , Cassandra won ' t ack writes until the commit log <nl> + # has been fsynced to disk . It will wait up to <nl> + # CommitLogSyncBatchWindowInMS milliseconds for other writes , before <nl> + # performing the sync . <nl> commitlog _ sync : periodic <nl> + <nl> + # the other option is " timed , " where writes may be acked immediately <nl> + # and the CommitLog is simply synced every commitlog _ sync _ period _ in _ ms <nl> + # milliseconds . <nl> commitlog _ sync _ period _ in _ ms : 10000 <nl> - # commitlog _ sync : batch <nl> - # commitlog _ sync _ batch _ window _ in _ ms : 10 <nl> <nl> # Addresses of hosts that are deemed contact points . <nl> # Cassandra nodes use this list of hosts to find each other and learn <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 58e33c6 . . def0a5e 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 105 , 8 + 105 , 7 @ @ public class Config <nl> <nl> public static enum CommitLogSync { <nl> periodic , <nl> - batch , <nl> - periodic _ without _ flush <nl> + batch <nl> } <nl> <nl> public static enum DiskAccessMode { <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index 340fef8 . . 761c6e6 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 491 , 7 + 491 , 6 @ @ public class CommitLog <nl> <nl> / / TODO this should be a Runnable since it doesn ' t actually return anything , but it ' s difficult to do that <nl> / / without breaking the fragile CheaterFutureTask in BatchCLES . <nl> - final static boolean flushEachWrite = DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . periodic ; <nl> class LogRecordAdder implements Callable , Runnable <nl> { <nl> final RowMutation rowMutation ; <nl> @ @ - 514 , 10 + 513 , 6 @ @ public class CommitLog <nl> sync ( ) ; <nl> segments . add ( new CommitLogSegment ( ) ) ; <nl> } <nl> - else if ( flushEachWrite ) <nl> - { <nl> - currentSegment ( ) . flush ( ) ; <nl> - } <nl> } <nl> catch ( IOException e ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> index dafa4bf . . 4bc12bd 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> @ @ - 141 , 11 + 141 , 6 @ @ public class CommitLogSegment <nl> logWriter . sync ( ) ; <nl> } <nl> <nl> - public void flush ( ) throws IOException <nl> - { <nl> - logWriter . flush ( ) ; <nl> - } <nl> - <nl> public CommitLogContext getContext ( ) <nl> { <nl> return new CommitLogContext ( logWriter . getFilePointer ( ) ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7a0ccba . . fcd7c3c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 15 
 + * Avoid holding SSTableReaders for duration of incremental repair ( CASSANDRA - 11739 ) 
 * Add message dropped tasks to nodetool netstats ( CASSANDRA - 11855 ) 
 * Don ' t compute expensive MaxPurgeableTimestamp until we ' ve verified there ' s an 
 expired tombstone ( CASSANDRA - 11834 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index 96d873f . . 5af63fe 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 474 , 7 + 474 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 / * * 
 * Make sure the { validatedForRepair } are marked for compaction before calling this . 
 * 
 - * Caller must reference the validatedForRepair sstables ( via ParentRepairSession . getAndReferenceSSTables ( . . ) ) . 
 + * Caller must reference the validatedForRepair sstables ( via ParentRepairSession . getActiveRepairedSSTableRefs ( . . ) ) . 
 * 
 * @ param cfs 
 * @ param ranges Ranges that the repair was carried out on 
 diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 index 732267e . . 5297ce3 100644 
 - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 @ @ - 17 , 7 + 17 , 6 @ @ 
 * / 
 package org . apache . cassandra . service ; 
 
 - import java . io . File ; 
 import java . net . InetAddress ; 
 import java . net . UnknownHostException ; 
 import java . util . * ; 
 @ @ - 42 , 7 + 41 , 6 @ @ import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . gms . FailureDetector ; 
 import org . apache . cassandra . gms . Gossiper ; 
 - import org . apache . cassandra . io . sstable . Component ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 import org . apache . cassandra . net . IAsyncCallbackWithFailure ; 
 @ @ - 321 , 7 + 319 , 7 @ @ public class ActiveRepairService 
 Set < SSTableReader > repairing = new HashSet < > ( ) ; 
 for ( Map . Entry < UUID , ParentRepairSession > entry : parentRepairSessions . entrySet ( ) ) 
 { 
 - Collection < SSTableReader > sstables = entry . getValue ( ) . sstableMap . get ( cfId ) ; 
 + Collection < SSTableReader > sstables = entry . getValue ( ) . getActiveSSTables ( cfId ) ; 
 if ( sstables ! = null & & ! entry . getKey ( ) . equals ( parentRepairSession ) ) 
 repairing . addAll ( sstables ) ; 
 } 
 @ @ - 384 , 7 + 382 , 7 @ @ public class ActiveRepairService 
 List < ListenableFuture < ? > > futures = new ArrayList < > ( ) ; 
 for ( Map . Entry < UUID , ColumnFamilyStore > columnFamilyStoreEntry : prs . columnFamilyStores . entrySet ( ) ) 
 { 
 - Refs < SSTableReader > sstables = prs . getAndReferenceSSTables ( columnFamilyStoreEntry . getKey ( ) ) ; 
 + Refs < SSTableReader > sstables = prs . getActiveRepairedSSTableRefs ( columnFamilyStoreEntry . getKey ( ) ) ; 
 ColumnFamilyStore cfs = columnFamilyStoreEntry . getValue ( ) ; 
 futures . add ( CompactionManager . instance . submitAntiCompaction ( cfs , prs . ranges , sstables , prs . repairedAt ) ) ; 
 } 
 @ @ - 428 , 7 + 426 , 7 @ @ public class ActiveRepairService 
 { 
 public final Map < UUID , ColumnFamilyStore > columnFamilyStores = new HashMap < > ( ) ; 
 public final Collection < Range < Token > > ranges ; 
 - public final Map < UUID , Set < SSTableReader > > sstableMap = new HashMap < > ( ) ; 
 + public final Map < UUID , Set < String > > sstableMap = new HashMap < > ( ) ; 
 public final long repairedAt ; 
 
 public ParentRepairSession ( List < ColumnFamilyStore > columnFamilyStores , Collection < Range < Token > > ranges , long repairedAt ) 
 @ @ - 436 , 39 + 434 , 50 @ @ public class ActiveRepairService 
 for ( ColumnFamilyStore cfs : columnFamilyStores ) 
 { 
 this . columnFamilyStores . put ( cfs . metadata . cfId , cfs ) ; 
 - sstableMap . put ( cfs . metadata . cfId , new HashSet < SSTableReader > ( ) ) ; 
 + sstableMap . put ( cfs . metadata . cfId , new HashSet < String > ( ) ) ; 
 } 
 this . ranges = ranges ; 
 this . repairedAt = repairedAt ; 
 } 
 
 - public synchronized Refs < SSTableReader > getAndReferenceSSTables ( UUID cfId ) 
 + @ SuppressWarnings ( " resource " ) 
 + public synchronized Refs < SSTableReader > getActiveRepairedSSTableRefs ( UUID cfId ) 
 { 
 - Set < SSTableReader > sstables = sstableMap . get ( cfId ) ; 
 - Iterator < SSTableReader > sstableIterator = sstables . iterator ( ) ; 
 ImmutableMap . Builder < SSTableReader , Ref < SSTableReader > > references = ImmutableMap . builder ( ) ; 
 - while ( sstableIterator . hasNext ( ) ) 
 + for ( SSTableReader sstable : getActiveSSTables ( cfId ) ) 
 { 
 - SSTableReader sstable = sstableIterator . next ( ) ; 
 - if ( ! new File ( sstable . descriptor . filenameFor ( Component . DATA ) ) . exists ( ) ) 
 - { 
 - sstableIterator . remove ( ) ; 
 - } 
 + Ref < SSTableReader > ref = sstable . tryRef ( ) ; 
 + if ( ref = = null ) 
 + sstableMap . get ( cfId ) . remove ( sstable . getFilename ( ) ) ; 
 else 
 + references . put ( sstable , ref ) ; 
 + } 
 + return new Refs < > ( references . build ( ) ) ; 
 + } 
 + 
 + private Set < SSTableReader > getActiveSSTables ( UUID cfId ) 
 + { 
 + Set < String > repairedSSTables = sstableMap . get ( cfId ) ; 
 + Set < SSTableReader > activeSSTables = new HashSet < > ( ) ; 
 + Set < String > activeSSTableNames = new HashSet < > ( ) ; 
 + for ( SSTableReader sstable : columnFamilyStores . get ( cfId ) . getSSTables ( ) ) 
 + { 
 + if ( repairedSSTables . contains ( sstable . getFilename ( ) ) ) 
 { 
 - Ref < SSTableReader > ref = sstable . tryRef ( ) ; 
 - if ( ref = = null ) 
 - sstableIterator . remove ( ) ; 
 - else 
 - references . put ( sstable , ref ) ; 
 + activeSSTables . add ( sstable ) ; 
 + activeSSTableNames . add ( sstable . getFilename ( ) ) ; 
 } 
 } 
 - return new Refs < > ( references . build ( ) ) ; 
 + sstableMap . put ( cfId , activeSSTableNames ) ; 
 + return activeSSTables ; 
 } 
 
 public void addSSTables ( UUID cfId , Collection < SSTableReader > sstables ) 
 { 
 - sstableMap . get ( cfId ) . addAll ( sstables ) ; 
 + for ( SSTableReader sstable : sstables ) 
 + { 
 + sstableMap . get ( cfId ) . add ( sstable . getFilename ( ) ) ; 
 + } 
 } 
 
 @ Override 
 diff - - git a / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java b / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java 
 new file mode 100644 
 index 0000000 . . 419ea1a 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java 
 @ @ - 0 , 0 + 1 , 107 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . service ; 
 + 
 + 
 + import java . util . Collections ; 
 + import java . util . HashSet ; 
 + import java . util . Iterator ; 
 + import java . util . Set ; 
 + import java . util . UUID ; 
 + 
 + import com . google . common . collect . Sets ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . Util ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . db . Mutation ; 
 + import org . apache . cassandra . io . sstable . SSTableReader ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . concurrent . Refs ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 + 
 + public class ActiveRepairServiceTest extends SchemaLoader 
 + { 
 + 
 + private static final String KEYSPACE1 = " Keyspace1 " ; 
 + private static final String CF = " Standard1 " ; 
 + 
 + @ Test 
 + public void testGetActiveRepairedSSTableRefs ( ) 
 + { 
 + ColumnFamilyStore store = prepareColumnFamilyStore ( ) ; 
 + Set < SSTableReader > original = store . getUnrepairedSSTables ( ) ; 
 + 
 + UUID prsId = UUID . randomUUID ( ) ; 
 + ActiveRepairService . instance . registerParentRepairSession ( prsId , Collections . singletonList ( store ) , null ) ; 
 + ActiveRepairService . ParentRepairSession prs = ActiveRepairService . instance . getParentRepairSession ( prsId ) ; 
 + 
 + / / add all sstables to parent repair session 
 + prs . addSSTables ( store . metadata . cfId , original ) ; 
 + 
 + / / retrieve all sstable references from parent repair sessions 
 + Refs < SSTableReader > refs = prs . getActiveRepairedSSTableRefs ( store . metadata . cfId ) ; 
 + Set < SSTableReader > retrieved = Sets . newHashSet ( refs . iterator ( ) ) ; 
 + assertEquals ( original , retrieved ) ; 
 + refs . release ( ) ; 
 + 
 + / / remove 1 sstable from data data tracker 
 + Set < SSTableReader > newLiveSet = new HashSet < > ( original ) ; 
 + Iterator < SSTableReader > it = newLiveSet . iterator ( ) ; 
 + SSTableReader removed = it . next ( ) ; 
 + it . remove ( ) ; 
 + store . getDataTracker ( ) . replaceWithNewInstances ( Collections . singleton ( removed ) , Collections . EMPTY _ SET ) ; 
 + 
 + / / retrieve sstable references from parent repair session again - removed sstable must not be present 
 + refs = prs . getActiveRepairedSSTableRefs ( store . metadata . cfId ) ; 
 + retrieved = Sets . newHashSet ( refs . iterator ( ) ) ; 
 + assertEquals ( newLiveSet , retrieved ) ; 
 + assertFalse ( retrieved . contains ( removed ) ) ; 
 + refs . release ( ) ; 
 + } 
 + 
 + private ColumnFamilyStore prepareColumnFamilyStore ( ) 
 + { 
 + Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; 
 + ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; 
 + store . truncateBlocking ( ) ; 
 + store . disableAutoCompaction ( ) ; 
 + long timestamp = System . currentTimeMillis ( ) ; 
 + / / create 10 sstables 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + { 
 + DecoratedKey key = Util . dk ( Integer . toString ( i ) ) ; 
 + Mutation rm = new Mutation ( KEYSPACE1 , key . getKey ( ) ) ; 
 + for ( int j = 0 ; j < 10 ; j + + ) 
 + rm . add ( " Standard1 " , Util . cellname ( Integer . toString ( j ) ) , 
 + ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 
 + timestamp , 
 + 0 ) ; 
 + rm . apply ( ) ; 
 + store . forceBlockingFlush ( ) ; 
 + } 
 + return store ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2bfc0e8 . . acec31e 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 18 , 6 + 18 , 7 @ @ dev 
 replication Strategies 
 * increased amount of index locks for faster commitlog replay 
 * collect secondary index tombstones immediately ( CASSANDRA - 1914 ) 
 + * revert commitlog changes from # 1780 ( CASSANDRA - 1917 ) 
 
 
 0 . 7 . 0 - rc3 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index ba171d9 . . 8c629e1 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 61 , 32 + 61 , 17 @ @ saved _ caches _ directory : / var / lib / cassandra / saved _ caches 
 # Size to allow commitlog to grow to before creating a new segment 
 commitlog _ rotation _ threshold _ in _ mb : 128 
 
 - # commitlog _ sync supports the following modes : 
 - # 
 - # batch : 
 - # In batch mode , Cassandra won ' t ack writes until the commit log 
 - # has been fsynced to disk . But fsyncing each write at once is 
 - # performance - prohibitive , so instead Cassandra will wait up to 
 - # commitlog _ sync _ batch _ window _ in _ ms milliseconds for other writes , before 
 - # syncing that " batch " at once . This causes a performance penalty 
 - # of about 15 % when the commitlog is on a separate device , and much more 
 - # when it shares the same device as the data files . 
 - # 
 - # periodic : 
 - # Writes may be acked immediately ( without waiting for the commitlog 
 - # append ) and the CommitLog is simply synced every 
 - # commitlog _ sync _ period _ in _ ms milliseconds . 
 - # 
 - # periodic _ without _ flush : 
 - # Like periodic , but the commitlog write buffer is only flushed 
 - # before the sync , so any interruption to the process can be 
 - # expected to lose some writes . This is the old 0 . 6 periodic 
 - # behavior and will be removed in future versions if testing 
 - # continues to show no performance benefit over normal periodic . 
 + # commitlog _ sync may be either " periodic " or " batch . " 
 + # When in batch mode , Cassandra won ' t ack writes until the commit log 
 + # has been fsynced to disk . It will wait up to 
 + # CommitLogSyncBatchWindowInMS milliseconds for other writes , before 
 + # performing the sync . 
 commitlog _ sync : periodic 
 + 
 + # the other option is " timed , " where writes may be acked immediately 
 + # and the CommitLog is simply synced every commitlog _ sync _ period _ in _ ms 
 + # milliseconds . 
 commitlog _ sync _ period _ in _ ms : 10000 
 - # commitlog _ sync : batch 
 - # commitlog _ sync _ batch _ window _ in _ ms : 10 
 
 # Addresses of hosts that are deemed contact points . 
 # Cassandra nodes use this list of hosts to find each other and learn 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 58e33c6 . . def0a5e 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 105 , 8 + 105 , 7 @ @ public class Config 
 
 public static enum CommitLogSync { 
 periodic , 
 - batch , 
 - periodic _ without _ flush 
 + batch 
 } 
 
 public static enum DiskAccessMode { 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index 340fef8 . . 761c6e6 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 491 , 7 + 491 , 6 @ @ public class CommitLog 
 
 / / TODO this should be a Runnable since it doesn ' t actually return anything , but it ' s difficult to do that 
 / / without breaking the fragile CheaterFutureTask in BatchCLES . 
 - final static boolean flushEachWrite = DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . periodic ; 
 class LogRecordAdder implements Callable , Runnable 
 { 
 final RowMutation rowMutation ; 
 @ @ - 514 , 10 + 513 , 6 @ @ public class CommitLog 
 sync ( ) ; 
 segments . add ( new CommitLogSegment ( ) ) ; 
 } 
 - else if ( flushEachWrite ) 
 - { 
 - currentSegment ( ) . flush ( ) ; 
 - } 
 } 
 catch ( IOException e ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 index dafa4bf . . 4bc12bd 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 @ @ - 141 , 11 + 141 , 6 @ @ public class CommitLogSegment 
 logWriter . sync ( ) ; 
 } 
 
 - public void flush ( ) throws IOException 
 - { 
 - logWriter . flush ( ) ; 
 - } 
 - 
 public CommitLogContext getContext ( ) 
 { 
 return new CommitLogContext ( logWriter . getFilePointer ( ) ) ;
