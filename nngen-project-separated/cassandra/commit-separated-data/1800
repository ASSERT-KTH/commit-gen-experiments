BLEU SCORE: 0.012239112014172727

TEST MSG: Make syntax for Role options consistent with other statements
GENERATED MSG: Bulk loader is no longer a fat client , hadoop bulk loader output format .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d6ba737 . . 0148925 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 <nl> + * Add role based access control ( CASSANDRA - 7653 , 8650 , 7216 , 8760 , 8849 , 8761 , 8850 ) <nl> * Record client ip address in tracing sessions ( CASSANDRA - 8162 ) <nl> * Indicate partition key columns in response metadata for prepared <nl> statements ( CASSANDRA - 7660 ) <nl> @ @ - 7 , 7 + 8 , 6 @ @ <nl> * Optimise ( Time ) ? UUIDType Comparisons ( CASSANDRA - 8730 ) <nl> * Make CRC32Ex into a separate maven dependency ( CASSANDRA - 8836 ) <nl> * Use preloaded jemalloc w / Unsafe ( CASSANDRA - 8714 ) <nl> - * Add role based access control ( CASSANDRA - 7653 , 8650 , 7216 , 8760 , 8849 , 8761 ) <nl> * Avoid accessing partitioner through StorageProxy ( CASSANDRA - 8244 , 8268 ) <nl> * Upgrade Metrics library and remove depricated metrics ( CASSANDRA - 5657 ) <nl> * Serializing Row cache alternative , fully off heap ( CASSANDRA - 7438 ) <nl> diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index 0eb7a3b . . 592daad 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 1181 , 17 + 1181 , 16 @ @ syntax _ rules + = r ' ' ' <nl> <nl> < createRoleStatement > : : = " CREATE " " ROLE " < rolename > <nl> ( " WITH " < roleProperty > ( " AND " < roleProperty > ) * ) ? <nl> - ( " SUPERUSER " | " NOSUPERUSER " ) ? <nl> - ( " LOGIN " | " NOLOGIN " ) ? <nl> ; <nl> <nl> < alterRoleStatement > : : = " ALTER " " ROLE " < rolename > <nl> ( " WITH " < roleProperty > ( " AND " < roleProperty > ) * ) ? <nl> - ( " SUPERUSER " | " NOSUPERUSER " ) ? <nl> - ( " LOGIN " | " NOLOGIN " ) ? <nl> ; <nl> - < roleProperty > : : = " PASSWORD " " = " ? < stringLiteral > <nl> - | " OPTIONS " " = " ? < mapLiteral > <nl> + <nl> + < roleProperty > : : = " PASSWORD " " = " < stringLiteral > <nl> + | " OPTIONS " " = " < mapLiteral > <nl> + | " SUPERUSER " " = " < boolean > <nl> + | " LOGIN " " = " < boolean > <nl> ; <nl> <nl> < dropRoleStatement > : : = " DROP " " ROLE " < rolename > <nl> diff - - git a / src / java / org / apache / cassandra / auth / CassandraRoleManager . java b / src / java / org / apache / cassandra / auth / CassandraRoleManager . java <nl> index 36c57d4 . . 05a4fc8 100644 <nl> - - - a / src / java / org / apache / cassandra / auth / CassandraRoleManager . java <nl> + + + b / src / java / org / apache / cassandra / auth / CassandraRoleManager . java <nl> @ @ - 115 , 11 + 115 , 11 @ @ public class CassandraRoleManager implements IRoleManager <nl> public CassandraRoleManager ( ) <nl> { <nl> supportedOptions = DatabaseDescriptor . getAuthenticator ( ) . getClass ( ) = = PasswordAuthenticator . class <nl> - ? ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER , Option . PASSWORD ) <nl> - : ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER ) ; <nl> + ? ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER , Option . PASSWORD ) <nl> + : ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER ) ; <nl> alterableOptions = DatabaseDescriptor . getAuthenticator ( ) . getClass ( ) . equals ( PasswordAuthenticator . class ) <nl> - ? ImmutableSet . of ( Option . PASSWORD ) <nl> - : ImmutableSet . < Option > of ( ) ; <nl> + ? ImmutableSet . of ( Option . PASSWORD ) <nl> + : ImmutableSet . < Option > of ( ) ; <nl> } <nl> <nl> public void setup ( ) <nl> @ @ - 135 , 8 + 135 , 8 @ @ public class CassandraRoleManager implements IRoleManager <nl> if ( Schema . instance . getCFMetaData ( AuthKeyspace . NAME , " users " ) ! = null ) <nl> { <nl> legacySelectUserStatement = ( SelectStatement ) prepare ( " SELECT * FROM % s . % s WHERE name = ? " , <nl> - AuthKeyspace . NAME , <nl> - LEGACY _ USERS _ TABLE ) ; <nl> + AuthKeyspace . NAME , <nl> + LEGACY _ USERS _ TABLE ) ; <nl> scheduleSetupTask ( new Runnable ( ) <nl> { <nl> public void run ( ) <nl> @ @ - 167 , 23 + 167 , 23 @ @ public class CassandraRoleManager implements IRoleManager <nl> return alterableOptions ; <nl> } <nl> <nl> - public void createRole ( AuthenticatedUser performer , RoleResource role , Map < Option , Object > options ) <nl> + public void createRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) <nl> throws RequestValidationException , RequestExecutionException <nl> { <nl> - String insertCql = options . containsKey ( Option . PASSWORD ) <nl> - ? String . format ( " INSERT INTO % s . % s ( role , is _ superuser , can _ login , salted _ hash ) VALUES ( ' % s ' , % s , % s , ' % s ' ) " , <nl> - AuthKeyspace . NAME , <nl> - AuthKeyspace . ROLES , <nl> - escape ( role . getRoleName ( ) ) , <nl> - options . get ( Option . SUPERUSER ) , <nl> - options . get ( Option . LOGIN ) , <nl> - escape ( hashpw ( options . get ( Option . PASSWORD ) . toString ( ) ) ) ) <nl> - : String . format ( " INSERT INTO % s . % s ( role , is _ superuser , can _ login ) VALUES ( ' % s ' , % s , % s ) " , <nl> - AuthKeyspace . NAME , <nl> - AuthKeyspace . ROLES , <nl> - escape ( role . getRoleName ( ) ) , <nl> - options . get ( Option . SUPERUSER ) , <nl> - options . get ( Option . LOGIN ) ) ; <nl> + String insertCql = options . getPassword ( ) . isPresent ( ) <nl> + ? String . format ( " INSERT INTO % s . % s ( role , is _ superuser , can _ login , salted _ hash ) VALUES ( ' % s ' , % s , % s , ' % s ' ) " , <nl> + AuthKeyspace . NAME , <nl> + AuthKeyspace . ROLES , <nl> + escape ( role . getRoleName ( ) ) , <nl> + options . getSuperuser ( ) . get ( ) , <nl> + options . getLogin ( ) . get ( ) , <nl> + escape ( hashpw ( options . getPassword ( ) . get ( ) ) ) ) <nl> + : String . format ( " INSERT INTO % s . % s ( role , is _ superuser , can _ login ) VALUES ( ' % s ' , % s , % s ) " , <nl> + AuthKeyspace . NAME , <nl> + AuthKeyspace . ROLES , <nl> + escape ( role . getRoleName ( ) ) , <nl> + options . getSuperuser ( ) . get ( ) , <nl> + options . getLogin ( ) . get ( ) ) ; <nl> process ( insertCql , consistencyForRole ( role . getRoleName ( ) ) ) ; <nl> } <nl> <nl> @ @ - 197 , 14 + 197 , 12 @ @ public class CassandraRoleManager implements IRoleManager <nl> removeAllMembers ( role . getRoleName ( ) ) ; <nl> } <nl> <nl> - public void alterRole ( AuthenticatedUser performer , RoleResource role , Map < Option , Object > options ) <nl> - throws RequestValidationException , RequestExecutionException <nl> + public void alterRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) <nl> { <nl> / / Unlike most of the other data access methods here , this does not use a <nl> / / prepared statement in order to allow the set of assignments to be variable . <nl> - String assignments = Joiner . on ( ' , ' ) <nl> - . join ( Iterables . filter ( optionsToAssignments ( options ) , <nl> - Predicates . notNull ( ) ) ) ; <nl> + String assignments = Joiner . on ( ' , ' ) . join ( Iterables . filter ( optionsToAssignments ( options . getOptions ( ) ) , <nl> + Predicates . notNull ( ) ) ) ; <nl> if ( ! Strings . isNullOrEmpty ( assignments ) ) <nl> { <nl> QueryProcessor . process ( String . format ( " UPDATE % s . % s SET % s WHERE role = ' % s ' " , <nl> @ @ - 372 , 9 + 370 , 9 @ @ public class CassandraRoleManager implements IRoleManager <nl> ConsistencyLevel . QUORUM ) ; <nl> for ( UntypedResultSet . Row row : users ) <nl> { <nl> - Map < Option , Object > options = new HashMap < > ( ) ; <nl> - options . put ( Option . SUPERUSER , row . getBoolean ( " super " ) ) ; <nl> - options . put ( Option . LOGIN , true ) ; <nl> + RoleOptions options = new RoleOptions ( ) ; <nl> + options . setOption ( Option . SUPERUSER , row . getBoolean ( " super " ) ) ; <nl> + options . setOption ( Option . LOGIN , true ) ; <nl> createRole ( null , RoleResource . role ( row . getString ( " name " ) ) , options ) ; <nl> } <nl> logger . info ( " Completed conversion of legacy users " ) ; <nl> diff - - git a / src / java / org / apache / cassandra / auth / IRoleManager . java b / src / java / org / apache / cassandra / auth / IRoleManager . java <nl> index 5205dad . . a8befde 100644 <nl> - - - a / src / java / org / apache / cassandra / auth / IRoleManager . java <nl> + + + b / src / java / org / apache / cassandra / auth / IRoleManager . java <nl> @ @ - 65 , 7 + 65 , 7 @ @ public interface IRoleManager <nl> * @ throws RequestValidationException <nl> * @ throws RequestExecutionException <nl> * / <nl> - void createRole ( AuthenticatedUser performer , RoleResource role , Map < Option , Object > options ) <nl> + void createRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) <nl> throws RequestValidationException , RequestExecutionException ; <nl> <nl> / * * <nl> @ @ - 91 , 7 + 91 , 7 @ @ public interface IRoleManager <nl> * @ throws RequestValidationException <nl> * @ throws RequestExecutionException <nl> * / <nl> - void alterRole ( AuthenticatedUser performer , RoleResource role , Map < Option , Object > options ) <nl> + void alterRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) <nl> throws RequestValidationException , RequestExecutionException ; <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / auth / RoleOptions . java b / src / java / org / apache / cassandra / auth / RoleOptions . java <nl> new file mode 100644 <nl> index 0000000 . . 9609ff3 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / auth / RoleOptions . java <nl> @ @ - 0 , 0 + 1 , 153 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . auth ; <nl> + <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + <nl> + import com . google . common . base . Optional ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> + import org . apache . cassandra . exceptions . SyntaxException ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public class RoleOptions <nl> + { <nl> + private final Map < IRoleManager . Option , Object > options = new HashMap < > ( ) ; <nl> + <nl> + / * * <nl> + * Set a value for a specific option . <nl> + * Throws SyntaxException if the same option is set multiple times <nl> + * @ param option <nl> + * @ param value <nl> + * / <nl> + public void setOption ( IRoleManager . Option option , Object value ) <nl> + { <nl> + if ( options . containsKey ( option ) ) <nl> + throw new SyntaxException ( String . format ( " Multiple definition for property ' % s ' " , option . name ( ) ) ) ; <nl> + options . put ( option , value ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return true if there are no options with values set , false otherwise <nl> + * @ return whether any options have values set or not <nl> + * / <nl> + public boolean isEmpty ( ) <nl> + { <nl> + return options . isEmpty ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return a map of all the options which have been set <nl> + * @ return all options with values <nl> + * / <nl> + public Map < IRoleManager . Option , Object > getOptions ( ) <nl> + { <nl> + return options ; <nl> + } <nl> + <nl> + / * * <nl> + * Return a boolean value of the superuser option <nl> + * @ return superuser option value <nl> + * / <nl> + public Optional < Boolean > getSuperuser ( ) <nl> + { <nl> + return Optional . fromNullable ( ( Boolean ) options . get ( IRoleManager . Option . SUPERUSER ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return a boolean value of the login option <nl> + * @ return login option value <nl> + * / <nl> + public Optional < Boolean > getLogin ( ) <nl> + { <nl> + return Optional . fromNullable ( ( Boolean ) options . get ( IRoleManager . Option . LOGIN ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return the string value of the password option <nl> + * @ return password option value <nl> + * / <nl> + public Optional < String > getPassword ( ) <nl> + { <nl> + return Optional . fromNullable ( ( String ) options . get ( IRoleManager . Option . PASSWORD ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return a Map < String , String > representing custom options <nl> + * It is the responsiblity of IRoleManager implementations which support <nl> + * IRoleManager . Option . OPTION to handle type checking and conversion of these <nl> + * values , if present <nl> + * @ return map of custom options <nl> + * / <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + public Optional < Map < String , String > > getCustomOptions ( ) <nl> + { <nl> + return Optional . fromNullable ( ( Map < String , String > ) options . get ( IRoleManager . Option . OPTIONS ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Validate the contents of the options in two ways : <nl> + * - Ensure that only a subset of the options supported by the configured IRoleManager are set <nl> + * - Validate the type of any option values present . <nl> + * Should either condition fail , then InvalidRequestException is thrown . This method is called <nl> + * during validation of CQL statements , so the IRE results in a error response to the client . <nl> + * <nl> + * @ throws InvalidRequestException if any options which are not supported by the configured IRoleManager <nl> + * are set or if any option value is of an incorrect type . <nl> + * / <nl> + public void validate ( ) <nl> + { <nl> + for ( Map . Entry < IRoleManager . Option , Object > option : options . entrySet ( ) ) <nl> + { <nl> + if ( ! DatabaseDescriptor . getRoleManager ( ) . supportedOptions ( ) . contains ( option . getKey ( ) ) ) <nl> + throw new InvalidRequestException ( String . format ( " % s doesn ' t support % s " , <nl> + DatabaseDescriptor . getRoleManager ( ) . getClass ( ) . getName ( ) , <nl> + option . getKey ( ) ) ) ; <nl> + switch ( option . getKey ( ) ) <nl> + { <nl> + case LOGIN : <nl> + case SUPERUSER : <nl> + if ( ! ( option . getValue ( ) instanceof Boolean ) ) <nl> + throw new InvalidRequestException ( String . format ( " Invalid value for property ' % s ' . " + <nl> + " It must be a boolean " , <nl> + option . getKey ( ) ) ) ; <nl> + break ; <nl> + case PASSWORD : <nl> + if ( ! ( option . getValue ( ) instanceof String ) ) <nl> + throw new InvalidRequestException ( String . format ( " Invalid value for property ' % s ' . " + <nl> + " It must be a string " , <nl> + option . getKey ( ) ) ) ; <nl> + break ; <nl> + case OPTIONS : <nl> + if ( ! ( option . getValue ( ) instanceof Map ) ) <nl> + throw new InvalidRequestException ( String . format ( " Invalid value for property ' % s ' . " + <nl> + " It must be a map " , <nl> + option . getKey ( ) ) ) ; <nl> + break ; <nl> + <nl> + } <nl> + } <nl> + } <nl> + <nl> + public String toString ( ) <nl> + { <nl> + return FBUtilities . toString ( options ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index d565258 . . 2ca6b5d 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 914 , 15 + 914 , 15 @ @ roleResource returns [ RoleResource res ] <nl> createUserStatement returns [ CreateRoleStatement stmt ] <nl> @ init { <nl> RoleOptions opts = new RoleOptions ( ) ; <nl> - opts . put ( IRoleManager . Option . LOGIN . name ( ) , true ) ; <nl> + opts . setOption ( IRoleManager . Option . LOGIN , true ) ; <nl> boolean superuser = false ; <nl> boolean ifNotExists = false ; <nl> RoleName name = new RoleName ( ) ; <nl> } <nl> : K _ CREATE K _ USER ( K _ IF K _ NOT K _ EXISTS { ifNotExists = true ; } ) ? u = username { name . setName ( $ u . text , false ) ; } <nl> - ( K _ WITH roleOptions [ opts ] ) ? <nl> + ( K _ WITH userPassword [ opts ] ) ? <nl> ( K _ SUPERUSER { superuser = true ; } | K _ NOSUPERUSER { superuser = false ; } ) ? <nl> - { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , superuser ) ; <nl> + { opts . setOption ( IRoleManager . Option . SUPERUSER , superuser ) ; <nl> $ stmt = new CreateRoleStatement ( name , opts , ifNotExists ) ; } <nl> ; <nl> <nl> @ @ - 935 , 9 + 935 , 9 @ @ alterUserStatement returns [ AlterRoleStatement stmt ] <nl> RoleName name = new RoleName ( ) ; <nl> } <nl> : K _ ALTER K _ USER u = username { name . setName ( $ u . text , false ) ; } <nl> - ( K _ WITH roleOptions [ opts ] ) ? <nl> - ( K _ SUPERUSER { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , true ) ; } <nl> - | K _ NOSUPERUSER { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , false ) ; } ) ? <nl> + ( K _ WITH userPassword [ opts ] ) ? <nl> + ( K _ SUPERUSER { opts . setOption ( IRoleManager . Option . SUPERUSER , true ) ; } <nl> + | K _ NOSUPERUSER { opts . setOption ( IRoleManager . Option . SUPERUSER , false ) ; } ) ? <nl> { $ stmt = new AlterRoleStatement ( name , opts ) ; } <nl> ; <nl> <nl> @ @ - 960 , 26 + 960 , 43 @ @ listUsersStatement returns [ ListRolesStatement stmt ] <nl> ; <nl> <nl> / * * <nl> - * CREATE ROLE [ IF NOT EXISTS ] < rolename > [ WITH PASSWORD < password > ] [ SUPERUSER | NOSUPERUSER ] [ LOGIN | NOLOGIN ] <nl> + * CREATE ROLE [ IF NOT EXISTS ] < rolename > [ [ WITH ] option [ [ AND ] option ] * ] <nl> + * <nl> + * where option can be : <nl> + * PASSWORD = ' < password > ' <nl> + * SUPERUSER = ( true | false ) <nl> + * LOGIN = ( true | false ) <nl> + * OPTIONS = { ' k1 ' : ' v1 ' , ' k2 ' : ' v2 ' } <nl> * / <nl> createRoleStatement returns [ CreateRoleStatement stmt ] <nl> @ init { <nl> RoleOptions opts = new RoleOptions ( ) ; <nl> - boolean superuser = false ; <nl> - boolean login = false ; <nl> boolean ifNotExists = false ; <nl> } <nl> : K _ CREATE K _ ROLE ( K _ IF K _ NOT K _ EXISTS { ifNotExists = true ; } ) ? name = userOrRoleName <nl> ( K _ WITH roleOptions [ opts ] ) ? <nl> - ( K _ SUPERUSER { superuser = true ; } | K _ NOSUPERUSER { superuser = false ; } ) ? <nl> - ( K _ LOGIN { login = true ; } | K _ NOLOGIN { login = false ; } ) ? <nl> - { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , superuser ) ; <nl> - opts . put ( IRoleManager . Option . LOGIN . name ( ) , login ) ; <nl> - $ stmt = new CreateRoleStatement ( name , opts , ifNotExists ) ; } <nl> + { <nl> + / / set defaults if they weren ' t explictly supplied <nl> + if ( ! opts . getLogin ( ) . isPresent ( ) ) <nl> + { <nl> + opts . setOption ( IRoleManager . Option . LOGIN , false ) ; <nl> + } <nl> + if ( ! opts . getSuperuser ( ) . isPresent ( ) ) <nl> + { <nl> + opts . setOption ( IRoleManager . Option . SUPERUSER , false ) ; <nl> + } <nl> + $ stmt = new CreateRoleStatement ( name , opts , ifNotExists ) ; <nl> + } <nl> ; <nl> <nl> / * * <nl> - * ALTER ROLE < rolename > [ WITH PASSWORD < password > ] [ SUPERUSER | NOSUPERUSER ] <nl> + * ALTER ROLE < rolename > [ [ WITH ] option [ [ AND ] option ] * ] <nl> + * <nl> + * where option can be : <nl> + * PASSWORD = ' < password > ' <nl> + * SUPERUSER = ( true | false ) <nl> + * LOGIN = ( true | false ) <nl> + * OPTIONS = { ' k1 ' : ' v1 ' , ' k2 ' : ' v2 ' } <nl> * / <nl> alterRoleStatement returns [ AlterRoleStatement stmt ] <nl> @ init { <nl> @ @ - 987 , 10 + 1004 , 6 @ @ alterRoleStatement returns [ AlterRoleStatement stmt ] <nl> } <nl> : K _ ALTER K _ ROLE name = userOrRoleName <nl> ( K _ WITH roleOptions [ opts ] ) ? <nl> - ( K _ SUPERUSER { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , true ) ; } <nl> - | K _ NOSUPERUSER { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , false ) ; } ) ? <nl> - ( K _ LOGIN { opts . put ( IRoleManager . Option . LOGIN . name ( ) , true ) ; } <nl> - | K _ NOLOGIN { opts . put ( IRoleManager . Option . LOGIN . name ( ) , false ) ; } ) ? <nl> { $ stmt = new AlterRoleStatement ( name , opts ) ; } <nl> ; <nl> <nl> @ @ - 1024 , 8 + 1037 , 15 @ @ roleOptions [ RoleOptions opts ] <nl> ; <nl> <nl> roleOption [ RoleOptions opts ] <nl> - : k = K _ PASSWORD ' = ' ? v = STRING _ LITERAL { opts . put ( $ k . text , $ v . text ) ; } <nl> - | k = K _ OPTIONS ' = ' ? m = mapLiteral { opts . put ( IRoleManager . Option . OPTIONS . name ( ) , convertPropertyMap ( m ) ) ; } <nl> + : K _ PASSWORD ' = ' v = STRING _ LITERAL { opts . setOption ( IRoleManager . Option . PASSWORD , $ v . text ) ; } <nl> + | K _ OPTIONS ' = ' m = mapLiteral { opts . setOption ( IRoleManager . Option . OPTIONS , convertPropertyMap ( m ) ) ; } <nl> + | K _ SUPERUSER ' = ' b = BOOLEAN { opts . setOption ( IRoleManager . Option . SUPERUSER , Boolean . valueOf ( $ b . text ) ) ; } <nl> + | K _ LOGIN ' = ' b = BOOLEAN { opts . setOption ( IRoleManager . Option . LOGIN , Boolean . valueOf ( $ b . text ) ) ; } <nl> + ; <nl> + <nl> + / / for backwards compatibility in CREATE / ALTER USER , this has no ' = ' <nl> + userPassword [ RoleOptions opts ] <nl> + : K _ PASSWORD v = STRING _ LITERAL { opts . setOption ( IRoleManager . Option . PASSWORD , $ v . text ) ; } <nl> ; <nl> <nl> / * * DEFINITIONS * * / <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / RoleOptions . java b / src / java / org / apache / cassandra / cql3 / RoleOptions . java <nl> deleted file mode 100644 <nl> index 89f37dd . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / cql3 / RoleOptions . java <nl> + + + / dev / null <nl> @ @ - 1 , 62 + 0 , 0 @ @ <nl> - / * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - package org . apache . cassandra . cql3 ; <nl> - <nl> - import java . util . HashMap ; <nl> - import java . util . Map ; <nl> - <nl> - import org . apache . cassandra . auth . IRoleManager ; <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> - import org . apache . cassandra . utils . FBUtilities ; <nl> - <nl> - public class RoleOptions <nl> - { <nl> - private final Map < IRoleManager . Option , Object > options = new HashMap < > ( ) ; <nl> - <nl> - public void put ( String name , Object value ) <nl> - { <nl> - options . put ( IRoleManager . Option . valueOf ( name . toUpperCase ( ) ) , value ) ; <nl> - } <nl> - <nl> - public boolean isEmpty ( ) <nl> - { <nl> - return options . isEmpty ( ) ; <nl> - } <nl> - <nl> - public Map < IRoleManager . Option , Object > getOptions ( ) <nl> - { <nl> - return options ; <nl> - } <nl> - <nl> - public void validate ( ) throws InvalidRequestException <nl> - { <nl> - for ( IRoleManager . Option option : options . keySet ( ) ) <nl> - { <nl> - if ( ! DatabaseDescriptor . getRoleManager ( ) . supportedOptions ( ) . contains ( option ) ) <nl> - throw new InvalidRequestException ( String . format ( " % s doesn ' t support % s " , <nl> - DatabaseDescriptor . getRoleManager ( ) . getClass ( ) . getName ( ) , <nl> - option ) ) ; <nl> - } <nl> - } <nl> - <nl> - public String toString ( ) <nl> - { <nl> - return FBUtilities . toString ( options ) ; <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterRoleStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterRoleStatement . java <nl> index 494ab19 . . 6134741 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterRoleStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterRoleStatement . java <nl> @ @ - 17 , 13 + 17 , 10 @ @ <nl> * / <nl> package org . apache . cassandra . cql3 . statements ; <nl> <nl> - import org . apache . cassandra . auth . AuthenticatedUser ; <nl> + import org . apache . cassandra . auth . * ; <nl> import org . apache . cassandra . auth . IRoleManager . Option ; <nl> - import org . apache . cassandra . auth . Permission ; <nl> - import org . apache . cassandra . auth . RoleResource ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . cql3 . RoleName ; <nl> - import org . apache . cassandra . cql3 . RoleOptions ; <nl> import org . apache . cassandra . exceptions . * ; <nl> import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> @ @ - 57 , 11 + 54 , 11 @ @ public class AlterRoleStatement extends AuthenticationStatement <nl> AuthenticatedUser user = state . getUser ( ) ; <nl> boolean isSuper = user . isSuper ( ) ; <nl> <nl> - if ( opts . getOptions ( ) . containsKey ( Option . SUPERUSER ) & & user . getRoles ( ) . contains ( role ) ) <nl> + if ( opts . getSuperuser ( ) . isPresent ( ) & & user . getRoles ( ) . contains ( role ) ) <nl> throw new UnauthorizedException ( " You aren ' t allowed to alter your own superuser " + <nl> " status or that of a role granted to you " ) ; <nl> <nl> - if ( opts . getOptions ( ) . containsKey ( Option . SUPERUSER ) & & ! isSuper ) <nl> + if ( opts . getSuperuser ( ) . isPresent ( ) & & ! isSuper ) <nl> throw new UnauthorizedException ( " Only superusers are allowed to alter superuser status " ) ; <nl> <nl> / / superusers can do whatever else they like <nl> @ @ - 87 , 7 + 84 , 7 @ @ public class AlterRoleStatement extends AuthenticationStatement <nl> public ResultMessage execute ( ClientState state ) throws RequestValidationException , RequestExecutionException <nl> { <nl> if ( ! opts . isEmpty ( ) ) <nl> - DatabaseDescriptor . getRoleManager ( ) . alterRole ( state . getUser ( ) , role , opts . getOptions ( ) ) ; <nl> + DatabaseDescriptor . getRoleManager ( ) . alterRole ( state . getUser ( ) , role , opts ) ; <nl> return null ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateRoleStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateRoleStatement . java <nl> index 347d20a . . 9be4c89 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateRoleStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateRoleStatement . java <nl> @ @ - 17 , 13 + 17 , 9 @ @ <nl> * / <nl> package org . apache . cassandra . cql3 . statements ; <nl> <nl> - import org . apache . cassandra . auth . AuthenticatedUser ; <nl> - import org . apache . cassandra . auth . IRoleManager . Option ; <nl> - import org . apache . cassandra . auth . Permission ; <nl> - import org . apache . cassandra . auth . RoleResource ; <nl> + import org . apache . cassandra . auth . * ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . cql3 . RoleName ; <nl> - import org . apache . cassandra . cql3 . RoleOptions ; <nl> import org . apache . cassandra . exceptions . * ; <nl> import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> @ @ - 44 , 9 + 40 , 9 @ @ public class CreateRoleStatement extends AuthenticationStatement <nl> public void checkAccess ( ClientState state ) throws UnauthorizedException <nl> { <nl> super . checkPermission ( state , Permission . CREATE , RoleResource . root ( ) ) ; <nl> - if ( opts . getOptions ( ) . containsKey ( Option . SUPERUSER ) ) <nl> + if ( opts . getSuperuser ( ) . isPresent ( ) ) <nl> { <nl> - if ( ( Boolean ) opts . getOptions ( ) . get ( Option . SUPERUSER ) & & ! state . getUser ( ) . isSuper ( ) ) <nl> + if ( opts . getSuperuser ( ) . get ( ) & & ! state . getUser ( ) . isSuper ( ) ) <nl> throw new UnauthorizedException ( " Only superusers can create a role with superuser status " ) ; <nl> } <nl> } <nl> @ @ - 63 , 12 + 59 , 6 @ @ public class CreateRoleStatement extends AuthenticationStatement <nl> <nl> if ( ! ifNotExists & & DatabaseDescriptor . getRoleManager ( ) . isExistingRole ( role ) ) <nl> throw new InvalidRequestException ( String . format ( " % s already exists " , role . getRoleName ( ) ) ) ; <nl> - <nl> - for ( Option option : opts . getOptions ( ) . keySet ( ) ) <nl> - { <nl> - if ( ! DatabaseDescriptor . getRoleManager ( ) . supportedOptions ( ) . contains ( option ) ) <nl> - throw new UnauthorizedException ( String . format ( " You aren ' t allowed to alter % s " , option ) ) ; <nl> - } <nl> } <nl> <nl> public ResultMessage execute ( ClientState state ) throws RequestExecutionException , RequestValidationException <nl> @ @ - 77 , 7 + 67 , 7 @ @ public class CreateRoleStatement extends AuthenticationStatement <nl> if ( ifNotExists & & DatabaseDescriptor . getRoleManager ( ) . isExistingRole ( role ) ) <nl> return null ; <nl> <nl> - DatabaseDescriptor . getRoleManager ( ) . createRole ( state . getUser ( ) , role , opts . getOptions ( ) ) ; <nl> + DatabaseDescriptor . getRoleManager ( ) . createRole ( state . getUser ( ) , role , opts ) ; <nl> grantPermissionsToCreator ( state ) ; <nl> return null ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / auth / RoleOptionsTest . java b / test / unit / org / apache / cassandra / auth / RoleOptionsTest . java <nl> new file mode 100644 <nl> index 0000000 . . 71f0c97 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / auth / RoleOptionsTest . java <nl> @ @ - 0 , 0 + 1 , 227 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . auth ; <nl> + <nl> + import java . lang . reflect . Field ; <nl> + import java . util . * ; <nl> + <nl> + import com . google . common . collect . ImmutableSet ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . exceptions . * ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + import static org . junit . Assert . fail ; <nl> + <nl> + public class RoleOptionsTest <nl> + { <nl> + @ Test <nl> + public void validateValueTypes ( ) <nl> + { <nl> + setupRoleManager ( getRoleManager ( IRoleManager . Option . values ( ) ) ) ; <nl> + <nl> + RoleOptions opts = new RoleOptions ( ) ; <nl> + opts . setOption ( IRoleManager . Option . LOGIN , " test " ) ; <nl> + assertInvalidOptions ( opts , " Invalid value for property ' LOGIN ' . It must be a boolean " ) ; <nl> + <nl> + opts = new RoleOptions ( ) ; <nl> + opts . setOption ( IRoleManager . Option . PASSWORD , 99 ) ; <nl> + assertInvalidOptions ( opts , " Invalid value for property ' PASSWORD ' . It must be a string " ) ; <nl> + <nl> + opts = new RoleOptions ( ) ; <nl> + opts . setOption ( IRoleManager . Option . SUPERUSER , new HashSet < > ( ) ) ; <nl> + assertInvalidOptions ( opts , " Invalid value for property ' SUPERUSER ' . It must be a boolean " ) ; <nl> + <nl> + opts = new RoleOptions ( ) ; <nl> + opts . setOption ( IRoleManager . Option . OPTIONS , false ) ; <nl> + assertInvalidOptions ( opts , " Invalid value for property ' OPTIONS ' . It must be a map " ) ; <nl> + <nl> + opts = new RoleOptions ( ) ; <nl> + opts . setOption ( IRoleManager . Option . LOGIN , true ) ; <nl> + opts . setOption ( IRoleManager . Option . SUPERUSER , false ) ; <nl> + opts . setOption ( IRoleManager . Option . PASSWORD , " test " ) ; <nl> + opts . setOption ( IRoleManager . Option . OPTIONS , Collections . singletonMap ( " key " , " value " ) ) ; <nl> + opts . validate ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void rejectUnsupportedOptions ( ) <nl> + { <nl> + / / Our hypothetical IRoleManager only supports the LOGIN option <nl> + IRoleManager roleManager = getRoleManager ( IRoleManager . Option . LOGIN ) ; <nl> + setupRoleManager ( roleManager ) ; <nl> + RoleOptions opts = new RoleOptions ( ) ; <nl> + opts . setOption ( IRoleManager . Option . PASSWORD , " test " ) ; <nl> + assertInvalidOptions ( opts , String . format ( " % s doesn ' t support PASSWORD " , roleManager . getClass ( ) . getName ( ) ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void rejectSettingSameOptionMultipleTimes ( ) <nl> + { <nl> + RoleOptions opts = new RoleOptions ( ) ; <nl> + opts . setOption ( IRoleManager . Option . LOGIN , true ) ; <nl> + try <nl> + { <nl> + opts . setOption ( IRoleManager . Option . LOGIN , false ) ; <nl> + } <nl> + catch ( SyntaxException e ) <nl> + { <nl> + assertEquals ( " Multiple definition for property ' LOGIN ' " , e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void emptyByDefault ( ) <nl> + { <nl> + RoleOptions opts = new RoleOptions ( ) ; <nl> + assertTrue ( opts . isEmpty ( ) ) ; <nl> + assertFalse ( opts . getLogin ( ) . isPresent ( ) ) ; <nl> + <nl> + opts . setOption ( IRoleManager . Option . LOGIN , true ) ; <nl> + assertFalse ( opts . isEmpty ( ) ) ; <nl> + assertTrue ( opts . getLogin ( ) . isPresent ( ) ) ; <nl> + assertTrue ( opts . getLogin ( ) . get ( ) ) ; <nl> + } <nl> + <nl> + private void assertInvalidOptions ( RoleOptions opts , String message ) <nl> + { <nl> + try <nl> + { <nl> + opts . validate ( ) ; <nl> + fail ( " Expected error but didn ' t get one " ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + assertTrue ( e . getMessage ( ) . equals ( message ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void setupRoleManager ( IRoleManager manager ) <nl> + { <nl> + Field field = FBUtilities . getProtectedField ( DatabaseDescriptor . class , " roleManager " ) ; <nl> + field . setAccessible ( true ) ; <nl> + try <nl> + { <nl> + field . set ( null , manager ) ; <nl> + } <nl> + catch ( IllegalAccessException e ) <nl> + { <nl> + fail ( " Error setting IRoleManager instance for test " ) ; <nl> + } <nl> + } <nl> + <nl> + private IRoleManager getRoleManager ( final IRoleManager . Option . . . supportedOptions ) <nl> + { <nl> + return new IRoleManager ( ) <nl> + { <nl> + public Set < Option > supportedOptions ( ) <nl> + { <nl> + return ImmutableSet . copyOf ( supportedOptions ) ; <nl> + } <nl> + <nl> + public Set < Option > alterableOptions ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + public void createRole ( AuthenticatedUser performer , <nl> + RoleResource role , <nl> + RoleOptions options ) throws RequestValidationException , RequestExecutionException <nl> + { <nl> + <nl> + } <nl> + <nl> + public void dropRole ( AuthenticatedUser performer , <nl> + RoleResource role ) throws RequestValidationException , RequestExecutionException <nl> + { <nl> + <nl> + } <nl> + <nl> + public void alterRole ( AuthenticatedUser performer , <nl> + RoleResource role , <nl> + RoleOptions options ) throws RequestValidationException , RequestExecutionException <nl> + { <nl> + <nl> + } <nl> + <nl> + public void grantRole ( AuthenticatedUser performer , <nl> + RoleResource role , <nl> + RoleResource grantee ) throws RequestValidationException , RequestExecutionException <nl> + { <nl> + <nl> + } <nl> + <nl> + public void revokeRole ( AuthenticatedUser performer , <nl> + RoleResource role , <nl> + RoleResource revokee ) throws RequestValidationException , RequestExecutionException <nl> + { <nl> + <nl> + } <nl> + <nl> + public Set < RoleResource > getRoles ( RoleResource grantee , <nl> + boolean includeInherited ) throws RequestValidationException , RequestExecutionException <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + public Set < RoleResource > getAllRoles ( ) throws RequestValidationException , RequestExecutionException <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + public boolean isSuper ( RoleResource role ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + public boolean canLogin ( RoleResource role ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + public Map < String , String > getCustomOptions ( RoleResource role ) <nl> + { <nl> + return Collections . EMPTY _ MAP ; <nl> + } <nl> + <nl> + public boolean isExistingRole ( RoleResource role ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + public Set < ? extends IResource > protectedResources ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + public void validateConfiguration ( ) throws ConfigurationException <nl> + { <nl> + <nl> + } <nl> + <nl> + public void setup ( ) <nl> + { <nl> + <nl> + } <nl> + } ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> index 1baebb6 . . 831a8d7 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> @ @ - 31 , 27 + 31 , 26 @ @ import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> import com . google . common . base . Objects ; <nl> import com . google . common . collect . ImmutableSet ; <nl> - import org . junit . AfterClass ; <nl> - import org . junit . After ; <nl> - import org . junit . Assert ; <nl> - import org . junit . Before ; <nl> - import org . junit . BeforeClass ; <nl> + import org . junit . * ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> import com . datastax . driver . core . * ; <nl> import com . datastax . driver . core . ResultSet ; <nl> - import com . datastax . driver . core . Row ; <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . concurrent . ScheduledExecutors ; <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . cql3 . functions . FunctionName ; <nl> import org . apache . cassandra . cql3 . statements . ParsedStatement ; <nl> - import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . db . Directories ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . db . SystemKeyspace ; <nl> import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . db . marshal . TupleType ; <nl> - import org . apache . cassandra . exceptions . * ; <nl> + import org . apache . cassandra . exceptions . CassandraException ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . exceptions . SyntaxException ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . serializers . TypeSerializer ; <nl> import org . apache . cassandra . service . ClientState ; <nl> @ @ - 670 , 6 + 669 , 19 @ @ public abstract class CQLTester <nl> : replaceValues ( query , values ) ; <nl> } <nl> <nl> + protected void assertValidSyntax ( String query ) throws Throwable <nl> + { <nl> + try <nl> + { <nl> + QueryProcessor . parseStatement ( query ) ; <nl> + } <nl> + catch ( SyntaxException e ) <nl> + { <nl> + Assert . fail ( String . format ( " Expected query syntax to be valid but was invalid . Query is : % s ; Error is % s " , <nl> + query , e . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> protected void assertInvalidSyntax ( String query , Object . . . values ) throws Throwable <nl> { <nl> assertInvalidSyntaxMessage ( null , query , values ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / RoleSyntaxTest . java b / test / unit / org / apache / cassandra / cql3 / RoleSyntaxTest . java <nl> new file mode 100644 <nl> index 0000000 . . 02bfe61 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / RoleSyntaxTest . java <nl> @ @ - 0 , 0 + 1 , 51 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + public class RoleSyntaxTest extends CQLTester <nl> + { <nl> + @ Test <nl> + public void standardOptionsSyntaxTest ( ) throws Throwable <nl> + { <nl> + assertValidSyntax ( " CREATE ROLE r WITH LOGIN = true AND SUPERUSER = false AND PASSWORD = ' foo ' " ) ; <nl> + assertValidSyntax ( " CREATE ROLE r WITH PASSWORD = ' foo ' AND LOGIN = true AND SUPERUSER = false " ) ; <nl> + assertValidSyntax ( " CREATE ROLE r WITH SUPERUSER = true AND PASSWORD = ' foo ' AND LOGIN = false " ) ; <nl> + assertValidSyntax ( " CREATE ROLE r WITH LOGIN = true AND PASSWORD = ' foo ' AND SUPERUSER = false " ) ; <nl> + assertValidSyntax ( " CREATE ROLE r WITH SUPERUSER = true AND PASSWORD = ' foo ' AND LOGIN = false " ) ; <nl> + <nl> + assertValidSyntax ( " ALTER ROLE r WITH LOGIN = true AND SUPERUSER = false AND PASSWORD = ' foo ' " ) ; <nl> + assertValidSyntax ( " ALTER ROLE r WITH PASSWORD = ' foo ' AND LOGIN = true AND SUPERUSER = false " ) ; <nl> + assertValidSyntax ( " ALTER ROLE r WITH SUPERUSER = true AND PASSWORD = ' foo ' AND LOGIN = false " ) ; <nl> + assertValidSyntax ( " ALTER ROLE r WITH LOGIN = true AND PASSWORD = ' foo ' AND SUPERUSER = false " ) ; <nl> + assertValidSyntax ( " ALTER ROLE r WITH SUPERUSER = true AND PASSWORD = ' foo ' AND LOGIN = false " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void customOptionsSyntaxTestl ( ) throws Throwable <nl> + { <nl> + assertValidSyntax ( " CREATE ROLE r WITH OPTIONS = { ' a ' : ' b ' , ' b ' : 1 } " ) ; <nl> + assertInvalidSyntax ( " CREATE ROLE r WITH OPTIONS = ' term ' " ) ; <nl> + assertInvalidSyntax ( " CREATE ROLE r WITH OPTIONS = 99 " ) ; <nl> + <nl> + assertValidSyntax ( " ALTER ROLE r WITH OPTIONS = { ' a ' : ' b ' , ' b ' : 1 } " ) ; <nl> + assertInvalidSyntax ( " ALTER ROLE r WITH OPTIONS = ' term ' " ) ; <nl> + assertInvalidSyntax ( " ALTER ROLE r WITH OPTIONS = 99 " ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7be913e . . 7c5a752 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 2 , 6 + 2 , 8 @ @ <nl> * add command to stop compactions ( CASSANDRA - 1740 ) <nl> * filter out unavailable cipher suites when using encryption ( CASSANDRA - 3178 ) <nl> * ( HADOOP ) add old - style api support for CFIF and CFRR ( CASSANDRA - 2799 ) <nl> + * Support TimeUUIDType column names in Stress . java tool ( CASSANDRA - 3541 ) <nl> + <nl> <nl> 1 . 0 . 5 <nl> * revert CASSANDRA - 3407 ( see CASSANDRA - 3540 ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / Session . java b / tools / stress / src / org / apache / cassandra / stress / Session . java <nl> index abbea50 . . ddc6a69 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / Session . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / Session . java <nl> @ @ - 27 , 9 + 27 , 7 @ @ import java . util . concurrent . atomic . AtomicLong ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ConfigurationException ; <nl> - import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; <nl> - import org . apache . cassandra . db . marshal . AbstractType ; <nl> - import org . apache . cassandra . db . marshal . TypeParser ; <nl> + import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . commons . cli . * ; <nl> <nl> import org . apache . cassandra . db . ColumnFamilyType ; <nl> @ @ - 50 , 6 + 48 , 8 @ @ public class Session implements Serializable <nl> public static final String DEFAULT _ COMPARATOR = " AsciiType " ; <nl> public static final String DEFAULT _ VALIDATOR = " BytesType " ; <nl> <nl> + private static InetAddress localInetAddress ; <nl> + <nl> public final AtomicInteger operations ; <nl> public final AtomicInteger keys ; <nl> public final AtomicLong latency ; <nl> @ @ - 89 , 6 + 89 , 7 @ @ public class Session implements Serializable <nl> availableOptions . addOption ( " I " , " compression " , true , " Specify the compression to use for sstable , default : no compression " ) ; <nl> availableOptions . addOption ( " Q " , " query - names " , true , " Comma - separated list of column names to retrieve from each row . " ) ; <nl> availableOptions . addOption ( " Z " , " compaction - strategy " , true , " CompactionStrategy to use . " ) ; <nl> + availableOptions . addOption ( " U " , " comparator " , true , " Column Comparator to use . Currently supported types are : TimeUUIDType , AsciiType , UTF8Type . " ) ; <nl> } <nl> <nl> private int numKeys = 1000 * 1000 ; <nl> @ @ - 131 , 6 + 132 , 8 @ @ public class Session implements Serializable <nl> protected float sigma ; <nl> <nl> public final InetAddress sendToDaemon ; <nl> + public final String comparator ; <nl> + public final boolean timeUUIDComparator ; <nl> <nl> public Session ( String [ ] arguments ) throws IllegalArgumentException <nl> { <nl> @ @ - 321 , 6 + 324 , 35 @ @ public class Session implements Serializable <nl> System . exit ( 1 ) ; <nl> } <nl> } <nl> + <nl> + if ( cmd . hasOption ( " U " ) ) <nl> + { <nl> + AbstractType parsed = null ; <nl> + <nl> + try <nl> + { <nl> + parsed = TypeParser . parse ( cmd . getOptionValue ( " U " ) ) ; <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + System . err . println ( e . getMessage ( ) ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + <nl> + comparator = cmd . getOptionValue ( " U " ) ; <nl> + timeUUIDComparator = parsed instanceof TimeUUIDType ; <nl> + <nl> + if ( ! ( parsed instanceof TimeUUIDType | | parsed instanceof AsciiType | | parsed instanceof UTF8Type ) ) <nl> + { <nl> + System . err . println ( " Currently supported types are : TimeUUIDType , AsciiType , UTF8Type . " ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + comparator = null ; <nl> + timeUUIDComparator = false ; <nl> + } <nl> } <nl> catch ( ParseException e ) <nl> { <nl> @ @ - 464 , 6 + 496 , 7 @ @ public class Session implements Serializable <nl> public void createKeySpaces ( ) <nl> { <nl> KsDef keyspace = new KsDef ( ) ; <nl> + String defaultComparator = comparator = = null ? DEFAULT _ COMPARATOR : comparator ; <nl> <nl> / / column family for standard columns <nl> CfDef standardCfDef = new CfDef ( " Keyspace1 " , " Standard1 " ) ; <nl> @ @ - 471 , 7 + 504 , 7 @ @ public class Session implements Serializable <nl> if ( compression ! = null ) <nl> compressionOptions . put ( " sstable _ compression " , compression ) ; <nl> <nl> - standardCfDef . setComparator _ type ( DEFAULT _ COMPARATOR ) <nl> + standardCfDef . setComparator _ type ( defaultComparator ) <nl> . setDefault _ validation _ class ( DEFAULT _ VALIDATOR ) <nl> . setCompression _ options ( compressionOptions ) ; <nl> <nl> @ @ - 485 , 7 + 518 , 7 @ @ public class Session implements Serializable <nl> / / column family with super columns <nl> CfDef superCfDef = new CfDef ( " Keyspace1 " , " Super1 " ) . setColumn _ type ( " Super " ) ; <nl> superCfDef . setComparator _ type ( DEFAULT _ COMPARATOR ) <nl> - . setSubcomparator _ type ( DEFAULT _ COMPARATOR ) <nl> + . setSubcomparator _ type ( defaultComparator ) <nl> . setDefault _ validation _ class ( DEFAULT _ VALIDATOR ) <nl> . setCompression _ options ( compressionOptions ) ; <nl> <nl> @ @ - 574 , 4 + 607 , 20 @ @ public class Session implements Serializable <nl> return client ; <nl> } <nl> <nl> + public static InetAddress getLocalAddress ( ) <nl> + { <nl> + if ( localInetAddress = = null ) <nl> + { <nl> + try <nl> + { <nl> + localInetAddress = InetAddress . getLocalHost ( ) ; <nl> + } <nl> + catch ( UnknownHostException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + return localInetAddress ; <nl> + } <nl> } <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java b / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java <nl> index 45d33cb . . c81df6f 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java <nl> @ @ - 52 , 9 + 52 , 9 @ @ public class Inserter extends Operation <nl> <nl> for ( int i = 0 ; i < session . getColumnsPerKey ( ) ; i + + ) <nl> { <nl> - String columnName = ( " C " + Integer . toString ( i ) ) ; <nl> - ByteBuffer columnValue = values . get ( i % values . size ( ) ) ; <nl> - columns . add ( new Column ( ByteBufferUtil . bytes ( columnName ) ) . setValue ( columnValue ) . setTimestamp ( System . currentTimeMillis ( ) ) ) ; <nl> + columns . add ( new Column ( columnName ( i , session . timeUUIDComparator ) ) <nl> + . setValue ( values . get ( i % values . size ( ) ) ) <nl> + . setTimestamp ( System . currentTimeMillis ( ) ) ) ; <nl> } <nl> <nl> if ( session . getColumnFamilyType ( ) = = ColumnFamilyType . Super ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / Operation . java b / tools / stress / src / org / apache / cassandra / stress / util / Operation . java <nl> index 10b97ad . . dd5128f 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / util / Operation . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / util / Operation . java <nl> @ @ - 27 , 11 + 27 , 14 @ @ import java . util . Random ; <nl> <nl> import static com . google . common . base . Charsets . UTF _ 8 ; <nl> <nl> + import org . apache . cassandra . db . marshal . TimeUUIDType ; <nl> import org . apache . cassandra . stress . Session ; <nl> import org . apache . cassandra . stress . Stress ; <nl> import org . apache . cassandra . thrift . Cassandra ; <nl> import org . apache . cassandra . thrift . InvalidRequestException ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . UUIDGen ; <nl> <nl> public abstract class Operation <nl> { <nl> @ @ - 200 , 6 + 203 , 13 @ @ public abstract class Operation <nl> return result . toString ( ) ; <nl> } <nl> <nl> + protected ByteBuffer columnName ( int index , boolean timeUUIDComparator ) <nl> + { <nl> + return timeUUIDComparator <nl> + ? TimeUUIDType . instance . decompose ( UUIDGen . makeType1UUIDFromHost ( Session . getLocalAddress ( ) ) ) <nl> + : ByteBufferUtil . bytes ( String . format ( " C % d " , index ) ) ; <nl> + } <nl> + <nl> protected String getExceptionMessage ( Exception e ) <nl> { <nl> String className = e . getClass ( ) . getSimpleName ( ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d6ba737 . . 0148925 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 
 + * Add role based access control ( CASSANDRA - 7653 , 8650 , 7216 , 8760 , 8849 , 8761 , 8850 ) 
 * Record client ip address in tracing sessions ( CASSANDRA - 8162 ) 
 * Indicate partition key columns in response metadata for prepared 
 statements ( CASSANDRA - 7660 ) 
 @ @ - 7 , 7 + 8 , 6 @ @ 
 * Optimise ( Time ) ? UUIDType Comparisons ( CASSANDRA - 8730 ) 
 * Make CRC32Ex into a separate maven dependency ( CASSANDRA - 8836 ) 
 * Use preloaded jemalloc w / Unsafe ( CASSANDRA - 8714 ) 
 - * Add role based access control ( CASSANDRA - 7653 , 8650 , 7216 , 8760 , 8849 , 8761 ) 
 * Avoid accessing partitioner through StorageProxy ( CASSANDRA - 8244 , 8268 ) 
 * Upgrade Metrics library and remove depricated metrics ( CASSANDRA - 5657 ) 
 * Serializing Row cache alternative , fully off heap ( CASSANDRA - 7438 ) 
 diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index 0eb7a3b . . 592daad 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 1181 , 17 + 1181 , 16 @ @ syntax _ rules + = r ' ' ' 
 
 < createRoleStatement > : : = " CREATE " " ROLE " < rolename > 
 ( " WITH " < roleProperty > ( " AND " < roleProperty > ) * ) ? 
 - ( " SUPERUSER " | " NOSUPERUSER " ) ? 
 - ( " LOGIN " | " NOLOGIN " ) ? 
 ; 
 
 < alterRoleStatement > : : = " ALTER " " ROLE " < rolename > 
 ( " WITH " < roleProperty > ( " AND " < roleProperty > ) * ) ? 
 - ( " SUPERUSER " | " NOSUPERUSER " ) ? 
 - ( " LOGIN " | " NOLOGIN " ) ? 
 ; 
 - < roleProperty > : : = " PASSWORD " " = " ? < stringLiteral > 
 - | " OPTIONS " " = " ? < mapLiteral > 
 + 
 + < roleProperty > : : = " PASSWORD " " = " < stringLiteral > 
 + | " OPTIONS " " = " < mapLiteral > 
 + | " SUPERUSER " " = " < boolean > 
 + | " LOGIN " " = " < boolean > 
 ; 
 
 < dropRoleStatement > : : = " DROP " " ROLE " < rolename > 
 diff - - git a / src / java / org / apache / cassandra / auth / CassandraRoleManager . java b / src / java / org / apache / cassandra / auth / CassandraRoleManager . java 
 index 36c57d4 . . 05a4fc8 100644 
 - - - a / src / java / org / apache / cassandra / auth / CassandraRoleManager . java 
 + + + b / src / java / org / apache / cassandra / auth / CassandraRoleManager . java 
 @ @ - 115 , 11 + 115 , 11 @ @ public class CassandraRoleManager implements IRoleManager 
 public CassandraRoleManager ( ) 
 { 
 supportedOptions = DatabaseDescriptor . getAuthenticator ( ) . getClass ( ) = = PasswordAuthenticator . class 
 - ? ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER , Option . PASSWORD ) 
 - : ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER ) ; 
 + ? ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER , Option . PASSWORD ) 
 + : ImmutableSet . of ( Option . LOGIN , Option . SUPERUSER ) ; 
 alterableOptions = DatabaseDescriptor . getAuthenticator ( ) . getClass ( ) . equals ( PasswordAuthenticator . class ) 
 - ? ImmutableSet . of ( Option . PASSWORD ) 
 - : ImmutableSet . < Option > of ( ) ; 
 + ? ImmutableSet . of ( Option . PASSWORD ) 
 + : ImmutableSet . < Option > of ( ) ; 
 } 
 
 public void setup ( ) 
 @ @ - 135 , 8 + 135 , 8 @ @ public class CassandraRoleManager implements IRoleManager 
 if ( Schema . instance . getCFMetaData ( AuthKeyspace . NAME , " users " ) ! = null ) 
 { 
 legacySelectUserStatement = ( SelectStatement ) prepare ( " SELECT * FROM % s . % s WHERE name = ? " , 
 - AuthKeyspace . NAME , 
 - LEGACY _ USERS _ TABLE ) ; 
 + AuthKeyspace . NAME , 
 + LEGACY _ USERS _ TABLE ) ; 
 scheduleSetupTask ( new Runnable ( ) 
 { 
 public void run ( ) 
 @ @ - 167 , 23 + 167 , 23 @ @ public class CassandraRoleManager implements IRoleManager 
 return alterableOptions ; 
 } 
 
 - public void createRole ( AuthenticatedUser performer , RoleResource role , Map < Option , Object > options ) 
 + public void createRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) 
 throws RequestValidationException , RequestExecutionException 
 { 
 - String insertCql = options . containsKey ( Option . PASSWORD ) 
 - ? String . format ( " INSERT INTO % s . % s ( role , is _ superuser , can _ login , salted _ hash ) VALUES ( ' % s ' , % s , % s , ' % s ' ) " , 
 - AuthKeyspace . NAME , 
 - AuthKeyspace . ROLES , 
 - escape ( role . getRoleName ( ) ) , 
 - options . get ( Option . SUPERUSER ) , 
 - options . get ( Option . LOGIN ) , 
 - escape ( hashpw ( options . get ( Option . PASSWORD ) . toString ( ) ) ) ) 
 - : String . format ( " INSERT INTO % s . % s ( role , is _ superuser , can _ login ) VALUES ( ' % s ' , % s , % s ) " , 
 - AuthKeyspace . NAME , 
 - AuthKeyspace . ROLES , 
 - escape ( role . getRoleName ( ) ) , 
 - options . get ( Option . SUPERUSER ) , 
 - options . get ( Option . LOGIN ) ) ; 
 + String insertCql = options . getPassword ( ) . isPresent ( ) 
 + ? String . format ( " INSERT INTO % s . % s ( role , is _ superuser , can _ login , salted _ hash ) VALUES ( ' % s ' , % s , % s , ' % s ' ) " , 
 + AuthKeyspace . NAME , 
 + AuthKeyspace . ROLES , 
 + escape ( role . getRoleName ( ) ) , 
 + options . getSuperuser ( ) . get ( ) , 
 + options . getLogin ( ) . get ( ) , 
 + escape ( hashpw ( options . getPassword ( ) . get ( ) ) ) ) 
 + : String . format ( " INSERT INTO % s . % s ( role , is _ superuser , can _ login ) VALUES ( ' % s ' , % s , % s ) " , 
 + AuthKeyspace . NAME , 
 + AuthKeyspace . ROLES , 
 + escape ( role . getRoleName ( ) ) , 
 + options . getSuperuser ( ) . get ( ) , 
 + options . getLogin ( ) . get ( ) ) ; 
 process ( insertCql , consistencyForRole ( role . getRoleName ( ) ) ) ; 
 } 
 
 @ @ - 197 , 14 + 197 , 12 @ @ public class CassandraRoleManager implements IRoleManager 
 removeAllMembers ( role . getRoleName ( ) ) ; 
 } 
 
 - public void alterRole ( AuthenticatedUser performer , RoleResource role , Map < Option , Object > options ) 
 - throws RequestValidationException , RequestExecutionException 
 + public void alterRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) 
 { 
 / / Unlike most of the other data access methods here , this does not use a 
 / / prepared statement in order to allow the set of assignments to be variable . 
 - String assignments = Joiner . on ( ' , ' ) 
 - . join ( Iterables . filter ( optionsToAssignments ( options ) , 
 - Predicates . notNull ( ) ) ) ; 
 + String assignments = Joiner . on ( ' , ' ) . join ( Iterables . filter ( optionsToAssignments ( options . getOptions ( ) ) , 
 + Predicates . notNull ( ) ) ) ; 
 if ( ! Strings . isNullOrEmpty ( assignments ) ) 
 { 
 QueryProcessor . process ( String . format ( " UPDATE % s . % s SET % s WHERE role = ' % s ' " , 
 @ @ - 372 , 9 + 370 , 9 @ @ public class CassandraRoleManager implements IRoleManager 
 ConsistencyLevel . QUORUM ) ; 
 for ( UntypedResultSet . Row row : users ) 
 { 
 - Map < Option , Object > options = new HashMap < > ( ) ; 
 - options . put ( Option . SUPERUSER , row . getBoolean ( " super " ) ) ; 
 - options . put ( Option . LOGIN , true ) ; 
 + RoleOptions options = new RoleOptions ( ) ; 
 + options . setOption ( Option . SUPERUSER , row . getBoolean ( " super " ) ) ; 
 + options . setOption ( Option . LOGIN , true ) ; 
 createRole ( null , RoleResource . role ( row . getString ( " name " ) ) , options ) ; 
 } 
 logger . info ( " Completed conversion of legacy users " ) ; 
 diff - - git a / src / java / org / apache / cassandra / auth / IRoleManager . java b / src / java / org / apache / cassandra / auth / IRoleManager . java 
 index 5205dad . . a8befde 100644 
 - - - a / src / java / org / apache / cassandra / auth / IRoleManager . java 
 + + + b / src / java / org / apache / cassandra / auth / IRoleManager . java 
 @ @ - 65 , 7 + 65 , 7 @ @ public interface IRoleManager 
 * @ throws RequestValidationException 
 * @ throws RequestExecutionException 
 * / 
 - void createRole ( AuthenticatedUser performer , RoleResource role , Map < Option , Object > options ) 
 + void createRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) 
 throws RequestValidationException , RequestExecutionException ; 
 
 / * * 
 @ @ - 91 , 7 + 91 , 7 @ @ public interface IRoleManager 
 * @ throws RequestValidationException 
 * @ throws RequestExecutionException 
 * / 
 - void alterRole ( AuthenticatedUser performer , RoleResource role , Map < Option , Object > options ) 
 + void alterRole ( AuthenticatedUser performer , RoleResource role , RoleOptions options ) 
 throws RequestValidationException , RequestExecutionException ; 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / auth / RoleOptions . java b / src / java / org / apache / cassandra / auth / RoleOptions . java 
 new file mode 100644 
 index 0000000 . . 9609ff3 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / auth / RoleOptions . java 
 @ @ - 0 , 0 + 1 , 153 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . auth ; 
 + 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + 
 + import com . google . common . base . Optional ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 + import org . apache . cassandra . exceptions . SyntaxException ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public class RoleOptions 
 + { 
 + private final Map < IRoleManager . Option , Object > options = new HashMap < > ( ) ; 
 + 
 + / * * 
 + * Set a value for a specific option . 
 + * Throws SyntaxException if the same option is set multiple times 
 + * @ param option 
 + * @ param value 
 + * / 
 + public void setOption ( IRoleManager . Option option , Object value ) 
 + { 
 + if ( options . containsKey ( option ) ) 
 + throw new SyntaxException ( String . format ( " Multiple definition for property ' % s ' " , option . name ( ) ) ) ; 
 + options . put ( option , value ) ; 
 + } 
 + 
 + / * * 
 + * Return true if there are no options with values set , false otherwise 
 + * @ return whether any options have values set or not 
 + * / 
 + public boolean isEmpty ( ) 
 + { 
 + return options . isEmpty ( ) ; 
 + } 
 + 
 + / * * 
 + * Return a map of all the options which have been set 
 + * @ return all options with values 
 + * / 
 + public Map < IRoleManager . Option , Object > getOptions ( ) 
 + { 
 + return options ; 
 + } 
 + 
 + / * * 
 + * Return a boolean value of the superuser option 
 + * @ return superuser option value 
 + * / 
 + public Optional < Boolean > getSuperuser ( ) 
 + { 
 + return Optional . fromNullable ( ( Boolean ) options . get ( IRoleManager . Option . SUPERUSER ) ) ; 
 + } 
 + 
 + / * * 
 + * Return a boolean value of the login option 
 + * @ return login option value 
 + * / 
 + public Optional < Boolean > getLogin ( ) 
 + { 
 + return Optional . fromNullable ( ( Boolean ) options . get ( IRoleManager . Option . LOGIN ) ) ; 
 + } 
 + 
 + / * * 
 + * Return the string value of the password option 
 + * @ return password option value 
 + * / 
 + public Optional < String > getPassword ( ) 
 + { 
 + return Optional . fromNullable ( ( String ) options . get ( IRoleManager . Option . PASSWORD ) ) ; 
 + } 
 + 
 + / * * 
 + * Return a Map < String , String > representing custom options 
 + * It is the responsiblity of IRoleManager implementations which support 
 + * IRoleManager . Option . OPTION to handle type checking and conversion of these 
 + * values , if present 
 + * @ return map of custom options 
 + * / 
 + @ SuppressWarnings ( " unchecked " ) 
 + public Optional < Map < String , String > > getCustomOptions ( ) 
 + { 
 + return Optional . fromNullable ( ( Map < String , String > ) options . get ( IRoleManager . Option . OPTIONS ) ) ; 
 + } 
 + 
 + / * * 
 + * Validate the contents of the options in two ways : 
 + * - Ensure that only a subset of the options supported by the configured IRoleManager are set 
 + * - Validate the type of any option values present . 
 + * Should either condition fail , then InvalidRequestException is thrown . This method is called 
 + * during validation of CQL statements , so the IRE results in a error response to the client . 
 + * 
 + * @ throws InvalidRequestException if any options which are not supported by the configured IRoleManager 
 + * are set or if any option value is of an incorrect type . 
 + * / 
 + public void validate ( ) 
 + { 
 + for ( Map . Entry < IRoleManager . Option , Object > option : options . entrySet ( ) ) 
 + { 
 + if ( ! DatabaseDescriptor . getRoleManager ( ) . supportedOptions ( ) . contains ( option . getKey ( ) ) ) 
 + throw new InvalidRequestException ( String . format ( " % s doesn ' t support % s " , 
 + DatabaseDescriptor . getRoleManager ( ) . getClass ( ) . getName ( ) , 
 + option . getKey ( ) ) ) ; 
 + switch ( option . getKey ( ) ) 
 + { 
 + case LOGIN : 
 + case SUPERUSER : 
 + if ( ! ( option . getValue ( ) instanceof Boolean ) ) 
 + throw new InvalidRequestException ( String . format ( " Invalid value for property ' % s ' . " + 
 + " It must be a boolean " , 
 + option . getKey ( ) ) ) ; 
 + break ; 
 + case PASSWORD : 
 + if ( ! ( option . getValue ( ) instanceof String ) ) 
 + throw new InvalidRequestException ( String . format ( " Invalid value for property ' % s ' . " + 
 + " It must be a string " , 
 + option . getKey ( ) ) ) ; 
 + break ; 
 + case OPTIONS : 
 + if ( ! ( option . getValue ( ) instanceof Map ) ) 
 + throw new InvalidRequestException ( String . format ( " Invalid value for property ' % s ' . " + 
 + " It must be a map " , 
 + option . getKey ( ) ) ) ; 
 + break ; 
 + 
 + } 
 + } 
 + } 
 + 
 + public String toString ( ) 
 + { 
 + return FBUtilities . toString ( options ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index d565258 . . 2ca6b5d 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 914 , 15 + 914 , 15 @ @ roleResource returns [ RoleResource res ] 
 createUserStatement returns [ CreateRoleStatement stmt ] 
 @ init { 
 RoleOptions opts = new RoleOptions ( ) ; 
 - opts . put ( IRoleManager . Option . LOGIN . name ( ) , true ) ; 
 + opts . setOption ( IRoleManager . Option . LOGIN , true ) ; 
 boolean superuser = false ; 
 boolean ifNotExists = false ; 
 RoleName name = new RoleName ( ) ; 
 } 
 : K _ CREATE K _ USER ( K _ IF K _ NOT K _ EXISTS { ifNotExists = true ; } ) ? u = username { name . setName ( $ u . text , false ) ; } 
 - ( K _ WITH roleOptions [ opts ] ) ? 
 + ( K _ WITH userPassword [ opts ] ) ? 
 ( K _ SUPERUSER { superuser = true ; } | K _ NOSUPERUSER { superuser = false ; } ) ? 
 - { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , superuser ) ; 
 + { opts . setOption ( IRoleManager . Option . SUPERUSER , superuser ) ; 
 $ stmt = new CreateRoleStatement ( name , opts , ifNotExists ) ; } 
 ; 
 
 @ @ - 935 , 9 + 935 , 9 @ @ alterUserStatement returns [ AlterRoleStatement stmt ] 
 RoleName name = new RoleName ( ) ; 
 } 
 : K _ ALTER K _ USER u = username { name . setName ( $ u . text , false ) ; } 
 - ( K _ WITH roleOptions [ opts ] ) ? 
 - ( K _ SUPERUSER { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , true ) ; } 
 - | K _ NOSUPERUSER { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , false ) ; } ) ? 
 + ( K _ WITH userPassword [ opts ] ) ? 
 + ( K _ SUPERUSER { opts . setOption ( IRoleManager . Option . SUPERUSER , true ) ; } 
 + | K _ NOSUPERUSER { opts . setOption ( IRoleManager . Option . SUPERUSER , false ) ; } ) ? 
 { $ stmt = new AlterRoleStatement ( name , opts ) ; } 
 ; 
 
 @ @ - 960 , 26 + 960 , 43 @ @ listUsersStatement returns [ ListRolesStatement stmt ] 
 ; 
 
 / * * 
 - * CREATE ROLE [ IF NOT EXISTS ] < rolename > [ WITH PASSWORD < password > ] [ SUPERUSER | NOSUPERUSER ] [ LOGIN | NOLOGIN ] 
 + * CREATE ROLE [ IF NOT EXISTS ] < rolename > [ [ WITH ] option [ [ AND ] option ] * ] 
 + * 
 + * where option can be : 
 + * PASSWORD = ' < password > ' 
 + * SUPERUSER = ( true | false ) 
 + * LOGIN = ( true | false ) 
 + * OPTIONS = { ' k1 ' : ' v1 ' , ' k2 ' : ' v2 ' } 
 * / 
 createRoleStatement returns [ CreateRoleStatement stmt ] 
 @ init { 
 RoleOptions opts = new RoleOptions ( ) ; 
 - boolean superuser = false ; 
 - boolean login = false ; 
 boolean ifNotExists = false ; 
 } 
 : K _ CREATE K _ ROLE ( K _ IF K _ NOT K _ EXISTS { ifNotExists = true ; } ) ? name = userOrRoleName 
 ( K _ WITH roleOptions [ opts ] ) ? 
 - ( K _ SUPERUSER { superuser = true ; } | K _ NOSUPERUSER { superuser = false ; } ) ? 
 - ( K _ LOGIN { login = true ; } | K _ NOLOGIN { login = false ; } ) ? 
 - { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , superuser ) ; 
 - opts . put ( IRoleManager . Option . LOGIN . name ( ) , login ) ; 
 - $ stmt = new CreateRoleStatement ( name , opts , ifNotExists ) ; } 
 + { 
 + / / set defaults if they weren ' t explictly supplied 
 + if ( ! opts . getLogin ( ) . isPresent ( ) ) 
 + { 
 + opts . setOption ( IRoleManager . Option . LOGIN , false ) ; 
 + } 
 + if ( ! opts . getSuperuser ( ) . isPresent ( ) ) 
 + { 
 + opts . setOption ( IRoleManager . Option . SUPERUSER , false ) ; 
 + } 
 + $ stmt = new CreateRoleStatement ( name , opts , ifNotExists ) ; 
 + } 
 ; 
 
 / * * 
 - * ALTER ROLE < rolename > [ WITH PASSWORD < password > ] [ SUPERUSER | NOSUPERUSER ] 
 + * ALTER ROLE < rolename > [ [ WITH ] option [ [ AND ] option ] * ] 
 + * 
 + * where option can be : 
 + * PASSWORD = ' < password > ' 
 + * SUPERUSER = ( true | false ) 
 + * LOGIN = ( true | false ) 
 + * OPTIONS = { ' k1 ' : ' v1 ' , ' k2 ' : ' v2 ' } 
 * / 
 alterRoleStatement returns [ AlterRoleStatement stmt ] 
 @ init { 
 @ @ - 987 , 10 + 1004 , 6 @ @ alterRoleStatement returns [ AlterRoleStatement stmt ] 
 } 
 : K _ ALTER K _ ROLE name = userOrRoleName 
 ( K _ WITH roleOptions [ opts ] ) ? 
 - ( K _ SUPERUSER { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , true ) ; } 
 - | K _ NOSUPERUSER { opts . put ( IRoleManager . Option . SUPERUSER . name ( ) , false ) ; } ) ? 
 - ( K _ LOGIN { opts . put ( IRoleManager . Option . LOGIN . name ( ) , true ) ; } 
 - | K _ NOLOGIN { opts . put ( IRoleManager . Option . LOGIN . name ( ) , false ) ; } ) ? 
 { $ stmt = new AlterRoleStatement ( name , opts ) ; } 
 ; 
 
 @ @ - 1024 , 8 + 1037 , 15 @ @ roleOptions [ RoleOptions opts ] 
 ; 
 
 roleOption [ RoleOptions opts ] 
 - : k = K _ PASSWORD ' = ' ? v = STRING _ LITERAL { opts . put ( $ k . text , $ v . text ) ; } 
 - | k = K _ OPTIONS ' = ' ? m = mapLiteral { opts . put ( IRoleManager . Option . OPTIONS . name ( ) , convertPropertyMap ( m ) ) ; } 
 + : K _ PASSWORD ' = ' v = STRING _ LITERAL { opts . setOption ( IRoleManager . Option . PASSWORD , $ v . text ) ; } 
 + | K _ OPTIONS ' = ' m = mapLiteral { opts . setOption ( IRoleManager . Option . OPTIONS , convertPropertyMap ( m ) ) ; } 
 + | K _ SUPERUSER ' = ' b = BOOLEAN { opts . setOption ( IRoleManager . Option . SUPERUSER , Boolean . valueOf ( $ b . text ) ) ; } 
 + | K _ LOGIN ' = ' b = BOOLEAN { opts . setOption ( IRoleManager . Option . LOGIN , Boolean . valueOf ( $ b . text ) ) ; } 
 + ; 
 + 
 + / / for backwards compatibility in CREATE / ALTER USER , this has no ' = ' 
 + userPassword [ RoleOptions opts ] 
 + : K _ PASSWORD v = STRING _ LITERAL { opts . setOption ( IRoleManager . Option . PASSWORD , $ v . text ) ; } 
 ; 
 
 / * * DEFINITIONS * * / 
 diff - - git a / src / java / org / apache / cassandra / cql3 / RoleOptions . java b / src / java / org / apache / cassandra / cql3 / RoleOptions . java 
 deleted file mode 100644 
 index 89f37dd . . 0000000 
 - - - a / src / java / org / apache / cassandra / cql3 / RoleOptions . java 
 + + + / dev / null 
 @ @ - 1 , 62 + 0 , 0 @ @ 
 - / * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - package org . apache . cassandra . cql3 ; 
 - 
 - import java . util . HashMap ; 
 - import java . util . Map ; 
 - 
 - import org . apache . cassandra . auth . IRoleManager ; 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 - import org . apache . cassandra . exceptions . InvalidRequestException ; 
 - import org . apache . cassandra . utils . FBUtilities ; 
 - 
 - public class RoleOptions 
 - { 
 - private final Map < IRoleManager . Option , Object > options = new HashMap < > ( ) ; 
 - 
 - public void put ( String name , Object value ) 
 - { 
 - options . put ( IRoleManager . Option . valueOf ( name . toUpperCase ( ) ) , value ) ; 
 - } 
 - 
 - public boolean isEmpty ( ) 
 - { 
 - return options . isEmpty ( ) ; 
 - } 
 - 
 - public Map < IRoleManager . Option , Object > getOptions ( ) 
 - { 
 - return options ; 
 - } 
 - 
 - public void validate ( ) throws InvalidRequestException 
 - { 
 - for ( IRoleManager . Option option : options . keySet ( ) ) 
 - { 
 - if ( ! DatabaseDescriptor . getRoleManager ( ) . supportedOptions ( ) . contains ( option ) ) 
 - throw new InvalidRequestException ( String . format ( " % s doesn ' t support % s " , 
 - DatabaseDescriptor . getRoleManager ( ) . getClass ( ) . getName ( ) , 
 - option ) ) ; 
 - } 
 - } 
 - 
 - public String toString ( ) 
 - { 
 - return FBUtilities . toString ( options ) ; 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterRoleStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterRoleStatement . java 
 index 494ab19 . . 6134741 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterRoleStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterRoleStatement . java 
 @ @ - 17 , 13 + 17 , 10 @ @ 
 * / 
 package org . apache . cassandra . cql3 . statements ; 
 
 - import org . apache . cassandra . auth . AuthenticatedUser ; 
 + import org . apache . cassandra . auth . * ; 
 import org . apache . cassandra . auth . IRoleManager . Option ; 
 - import org . apache . cassandra . auth . Permission ; 
 - import org . apache . cassandra . auth . RoleResource ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . cql3 . RoleName ; 
 - import org . apache . cassandra . cql3 . RoleOptions ; 
 import org . apache . cassandra . exceptions . * ; 
 import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 @ @ - 57 , 11 + 54 , 11 @ @ public class AlterRoleStatement extends AuthenticationStatement 
 AuthenticatedUser user = state . getUser ( ) ; 
 boolean isSuper = user . isSuper ( ) ; 
 
 - if ( opts . getOptions ( ) . containsKey ( Option . SUPERUSER ) & & user . getRoles ( ) . contains ( role ) ) 
 + if ( opts . getSuperuser ( ) . isPresent ( ) & & user . getRoles ( ) . contains ( role ) ) 
 throw new UnauthorizedException ( " You aren ' t allowed to alter your own superuser " + 
 " status or that of a role granted to you " ) ; 
 
 - if ( opts . getOptions ( ) . containsKey ( Option . SUPERUSER ) & & ! isSuper ) 
 + if ( opts . getSuperuser ( ) . isPresent ( ) & & ! isSuper ) 
 throw new UnauthorizedException ( " Only superusers are allowed to alter superuser status " ) ; 
 
 / / superusers can do whatever else they like 
 @ @ - 87 , 7 + 84 , 7 @ @ public class AlterRoleStatement extends AuthenticationStatement 
 public ResultMessage execute ( ClientState state ) throws RequestValidationException , RequestExecutionException 
 { 
 if ( ! opts . isEmpty ( ) ) 
 - DatabaseDescriptor . getRoleManager ( ) . alterRole ( state . getUser ( ) , role , opts . getOptions ( ) ) ; 
 + DatabaseDescriptor . getRoleManager ( ) . alterRole ( state . getUser ( ) , role , opts ) ; 
 return null ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateRoleStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateRoleStatement . java 
 index 347d20a . . 9be4c89 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateRoleStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateRoleStatement . java 
 @ @ - 17 , 13 + 17 , 9 @ @ 
 * / 
 package org . apache . cassandra . cql3 . statements ; 
 
 - import org . apache . cassandra . auth . AuthenticatedUser ; 
 - import org . apache . cassandra . auth . IRoleManager . Option ; 
 - import org . apache . cassandra . auth . Permission ; 
 - import org . apache . cassandra . auth . RoleResource ; 
 + import org . apache . cassandra . auth . * ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . cql3 . RoleName ; 
 - import org . apache . cassandra . cql3 . RoleOptions ; 
 import org . apache . cassandra . exceptions . * ; 
 import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 @ @ - 44 , 9 + 40 , 9 @ @ public class CreateRoleStatement extends AuthenticationStatement 
 public void checkAccess ( ClientState state ) throws UnauthorizedException 
 { 
 super . checkPermission ( state , Permission . CREATE , RoleResource . root ( ) ) ; 
 - if ( opts . getOptions ( ) . containsKey ( Option . SUPERUSER ) ) 
 + if ( opts . getSuperuser ( ) . isPresent ( ) ) 
 { 
 - if ( ( Boolean ) opts . getOptions ( ) . get ( Option . SUPERUSER ) & & ! state . getUser ( ) . isSuper ( ) ) 
 + if ( opts . getSuperuser ( ) . get ( ) & & ! state . getUser ( ) . isSuper ( ) ) 
 throw new UnauthorizedException ( " Only superusers can create a role with superuser status " ) ; 
 } 
 } 
 @ @ - 63 , 12 + 59 , 6 @ @ public class CreateRoleStatement extends AuthenticationStatement 
 
 if ( ! ifNotExists & & DatabaseDescriptor . getRoleManager ( ) . isExistingRole ( role ) ) 
 throw new InvalidRequestException ( String . format ( " % s already exists " , role . getRoleName ( ) ) ) ; 
 - 
 - for ( Option option : opts . getOptions ( ) . keySet ( ) ) 
 - { 
 - if ( ! DatabaseDescriptor . getRoleManager ( ) . supportedOptions ( ) . contains ( option ) ) 
 - throw new UnauthorizedException ( String . format ( " You aren ' t allowed to alter % s " , option ) ) ; 
 - } 
 } 
 
 public ResultMessage execute ( ClientState state ) throws RequestExecutionException , RequestValidationException 
 @ @ - 77 , 7 + 67 , 7 @ @ public class CreateRoleStatement extends AuthenticationStatement 
 if ( ifNotExists & & DatabaseDescriptor . getRoleManager ( ) . isExistingRole ( role ) ) 
 return null ; 
 
 - DatabaseDescriptor . getRoleManager ( ) . createRole ( state . getUser ( ) , role , opts . getOptions ( ) ) ; 
 + DatabaseDescriptor . getRoleManager ( ) . createRole ( state . getUser ( ) , role , opts ) ; 
 grantPermissionsToCreator ( state ) ; 
 return null ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / auth / RoleOptionsTest . java b / test / unit / org / apache / cassandra / auth / RoleOptionsTest . java 
 new file mode 100644 
 index 0000000 . . 71f0c97 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / auth / RoleOptionsTest . java 
 @ @ - 0 , 0 + 1 , 227 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . auth ; 
 + 
 + import java . lang . reflect . Field ; 
 + import java . util . * ; 
 + 
 + import com . google . common . collect . ImmutableSet ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . exceptions . * ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertTrue ; 
 + import static org . junit . Assert . fail ; 
 + 
 + public class RoleOptionsTest 
 + { 
 + @ Test 
 + public void validateValueTypes ( ) 
 + { 
 + setupRoleManager ( getRoleManager ( IRoleManager . Option . values ( ) ) ) ; 
 + 
 + RoleOptions opts = new RoleOptions ( ) ; 
 + opts . setOption ( IRoleManager . Option . LOGIN , " test " ) ; 
 + assertInvalidOptions ( opts , " Invalid value for property ' LOGIN ' . It must be a boolean " ) ; 
 + 
 + opts = new RoleOptions ( ) ; 
 + opts . setOption ( IRoleManager . Option . PASSWORD , 99 ) ; 
 + assertInvalidOptions ( opts , " Invalid value for property ' PASSWORD ' . It must be a string " ) ; 
 + 
 + opts = new RoleOptions ( ) ; 
 + opts . setOption ( IRoleManager . Option . SUPERUSER , new HashSet < > ( ) ) ; 
 + assertInvalidOptions ( opts , " Invalid value for property ' SUPERUSER ' . It must be a boolean " ) ; 
 + 
 + opts = new RoleOptions ( ) ; 
 + opts . setOption ( IRoleManager . Option . OPTIONS , false ) ; 
 + assertInvalidOptions ( opts , " Invalid value for property ' OPTIONS ' . It must be a map " ) ; 
 + 
 + opts = new RoleOptions ( ) ; 
 + opts . setOption ( IRoleManager . Option . LOGIN , true ) ; 
 + opts . setOption ( IRoleManager . Option . SUPERUSER , false ) ; 
 + opts . setOption ( IRoleManager . Option . PASSWORD , " test " ) ; 
 + opts . setOption ( IRoleManager . Option . OPTIONS , Collections . singletonMap ( " key " , " value " ) ) ; 
 + opts . validate ( ) ; 
 + } 
 + 
 + @ Test 
 + public void rejectUnsupportedOptions ( ) 
 + { 
 + / / Our hypothetical IRoleManager only supports the LOGIN option 
 + IRoleManager roleManager = getRoleManager ( IRoleManager . Option . LOGIN ) ; 
 + setupRoleManager ( roleManager ) ; 
 + RoleOptions opts = new RoleOptions ( ) ; 
 + opts . setOption ( IRoleManager . Option . PASSWORD , " test " ) ; 
 + assertInvalidOptions ( opts , String . format ( " % s doesn ' t support PASSWORD " , roleManager . getClass ( ) . getName ( ) ) ) ; 
 + } 
 + 
 + @ Test 
 + public void rejectSettingSameOptionMultipleTimes ( ) 
 + { 
 + RoleOptions opts = new RoleOptions ( ) ; 
 + opts . setOption ( IRoleManager . Option . LOGIN , true ) ; 
 + try 
 + { 
 + opts . setOption ( IRoleManager . Option . LOGIN , false ) ; 
 + } 
 + catch ( SyntaxException e ) 
 + { 
 + assertEquals ( " Multiple definition for property ' LOGIN ' " , e . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void emptyByDefault ( ) 
 + { 
 + RoleOptions opts = new RoleOptions ( ) ; 
 + assertTrue ( opts . isEmpty ( ) ) ; 
 + assertFalse ( opts . getLogin ( ) . isPresent ( ) ) ; 
 + 
 + opts . setOption ( IRoleManager . Option . LOGIN , true ) ; 
 + assertFalse ( opts . isEmpty ( ) ) ; 
 + assertTrue ( opts . getLogin ( ) . isPresent ( ) ) ; 
 + assertTrue ( opts . getLogin ( ) . get ( ) ) ; 
 + } 
 + 
 + private void assertInvalidOptions ( RoleOptions opts , String message ) 
 + { 
 + try 
 + { 
 + opts . validate ( ) ; 
 + fail ( " Expected error but didn ' t get one " ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + assertTrue ( e . getMessage ( ) . equals ( message ) ) ; 
 + } 
 + } 
 + 
 + private void setupRoleManager ( IRoleManager manager ) 
 + { 
 + Field field = FBUtilities . getProtectedField ( DatabaseDescriptor . class , " roleManager " ) ; 
 + field . setAccessible ( true ) ; 
 + try 
 + { 
 + field . set ( null , manager ) ; 
 + } 
 + catch ( IllegalAccessException e ) 
 + { 
 + fail ( " Error setting IRoleManager instance for test " ) ; 
 + } 
 + } 
 + 
 + private IRoleManager getRoleManager ( final IRoleManager . Option . . . supportedOptions ) 
 + { 
 + return new IRoleManager ( ) 
 + { 
 + public Set < Option > supportedOptions ( ) 
 + { 
 + return ImmutableSet . copyOf ( supportedOptions ) ; 
 + } 
 + 
 + public Set < Option > alterableOptions ( ) 
 + { 
 + return null ; 
 + } 
 + 
 + public void createRole ( AuthenticatedUser performer , 
 + RoleResource role , 
 + RoleOptions options ) throws RequestValidationException , RequestExecutionException 
 + { 
 + 
 + } 
 + 
 + public void dropRole ( AuthenticatedUser performer , 
 + RoleResource role ) throws RequestValidationException , RequestExecutionException 
 + { 
 + 
 + } 
 + 
 + public void alterRole ( AuthenticatedUser performer , 
 + RoleResource role , 
 + RoleOptions options ) throws RequestValidationException , RequestExecutionException 
 + { 
 + 
 + } 
 + 
 + public void grantRole ( AuthenticatedUser performer , 
 + RoleResource role , 
 + RoleResource grantee ) throws RequestValidationException , RequestExecutionException 
 + { 
 + 
 + } 
 + 
 + public void revokeRole ( AuthenticatedUser performer , 
 + RoleResource role , 
 + RoleResource revokee ) throws RequestValidationException , RequestExecutionException 
 + { 
 + 
 + } 
 + 
 + public Set < RoleResource > getRoles ( RoleResource grantee , 
 + boolean includeInherited ) throws RequestValidationException , RequestExecutionException 
 + { 
 + return null ; 
 + } 
 + 
 + public Set < RoleResource > getAllRoles ( ) throws RequestValidationException , RequestExecutionException 
 + { 
 + return null ; 
 + } 
 + 
 + public boolean isSuper ( RoleResource role ) 
 + { 
 + return false ; 
 + } 
 + 
 + public boolean canLogin ( RoleResource role ) 
 + { 
 + return false ; 
 + } 
 + 
 + public Map < String , String > getCustomOptions ( RoleResource role ) 
 + { 
 + return Collections . EMPTY _ MAP ; 
 + } 
 + 
 + public boolean isExistingRole ( RoleResource role ) 
 + { 
 + return false ; 
 + } 
 + 
 + public Set < ? extends IResource > protectedResources ( ) 
 + { 
 + return null ; 
 + } 
 + 
 + public void validateConfiguration ( ) throws ConfigurationException 
 + { 
 + 
 + } 
 + 
 + public void setup ( ) 
 + { 
 + 
 + } 
 + } ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 index 1baebb6 . . 831a8d7 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 @ @ - 31 , 27 + 31 , 26 @ @ import java . util . concurrent . atomic . AtomicInteger ; 
 
 import com . google . common . base . Objects ; 
 import com . google . common . collect . ImmutableSet ; 
 - import org . junit . AfterClass ; 
 - import org . junit . After ; 
 - import org . junit . Assert ; 
 - import org . junit . Before ; 
 - import org . junit . BeforeClass ; 
 + import org . junit . * ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 import com . datastax . driver . core . * ; 
 import com . datastax . driver . core . ResultSet ; 
 - import com . datastax . driver . core . Row ; 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . concurrent . ScheduledExecutors ; 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . cql3 . functions . FunctionName ; 
 import org . apache . cassandra . cql3 . statements . ParsedStatement ; 
 - import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . db . Directories ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . db . SystemKeyspace ; 
 import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . db . marshal . TupleType ; 
 - import org . apache . cassandra . exceptions . * ; 
 + import org . apache . cassandra . exceptions . CassandraException ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . exceptions . SyntaxException ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . serializers . TypeSerializer ; 
 import org . apache . cassandra . service . ClientState ; 
 @ @ - 670 , 6 + 669 , 19 @ @ public abstract class CQLTester 
 : replaceValues ( query , values ) ; 
 } 
 
 + protected void assertValidSyntax ( String query ) throws Throwable 
 + { 
 + try 
 + { 
 + QueryProcessor . parseStatement ( query ) ; 
 + } 
 + catch ( SyntaxException e ) 
 + { 
 + Assert . fail ( String . format ( " Expected query syntax to be valid but was invalid . Query is : % s ; Error is % s " , 
 + query , e . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 protected void assertInvalidSyntax ( String query , Object . . . values ) throws Throwable 
 { 
 assertInvalidSyntaxMessage ( null , query , values ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / RoleSyntaxTest . java b / test / unit / org / apache / cassandra / cql3 / RoleSyntaxTest . java 
 new file mode 100644 
 index 0000000 . . 02bfe61 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / RoleSyntaxTest . java 
 @ @ - 0 , 0 + 1 , 51 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import org . junit . Test ; 
 + 
 + public class RoleSyntaxTest extends CQLTester 
 + { 
 + @ Test 
 + public void standardOptionsSyntaxTest ( ) throws Throwable 
 + { 
 + assertValidSyntax ( " CREATE ROLE r WITH LOGIN = true AND SUPERUSER = false AND PASSWORD = ' foo ' " ) ; 
 + assertValidSyntax ( " CREATE ROLE r WITH PASSWORD = ' foo ' AND LOGIN = true AND SUPERUSER = false " ) ; 
 + assertValidSyntax ( " CREATE ROLE r WITH SUPERUSER = true AND PASSWORD = ' foo ' AND LOGIN = false " ) ; 
 + assertValidSyntax ( " CREATE ROLE r WITH LOGIN = true AND PASSWORD = ' foo ' AND SUPERUSER = false " ) ; 
 + assertValidSyntax ( " CREATE ROLE r WITH SUPERUSER = true AND PASSWORD = ' foo ' AND LOGIN = false " ) ; 
 + 
 + assertValidSyntax ( " ALTER ROLE r WITH LOGIN = true AND SUPERUSER = false AND PASSWORD = ' foo ' " ) ; 
 + assertValidSyntax ( " ALTER ROLE r WITH PASSWORD = ' foo ' AND LOGIN = true AND SUPERUSER = false " ) ; 
 + assertValidSyntax ( " ALTER ROLE r WITH SUPERUSER = true AND PASSWORD = ' foo ' AND LOGIN = false " ) ; 
 + assertValidSyntax ( " ALTER ROLE r WITH LOGIN = true AND PASSWORD = ' foo ' AND SUPERUSER = false " ) ; 
 + assertValidSyntax ( " ALTER ROLE r WITH SUPERUSER = true AND PASSWORD = ' foo ' AND LOGIN = false " ) ; 
 + } 
 + 
 + @ Test 
 + public void customOptionsSyntaxTestl ( ) throws Throwable 
 + { 
 + assertValidSyntax ( " CREATE ROLE r WITH OPTIONS = { ' a ' : ' b ' , ' b ' : 1 } " ) ; 
 + assertInvalidSyntax ( " CREATE ROLE r WITH OPTIONS = ' term ' " ) ; 
 + assertInvalidSyntax ( " CREATE ROLE r WITH OPTIONS = 99 " ) ; 
 + 
 + assertValidSyntax ( " ALTER ROLE r WITH OPTIONS = { ' a ' : ' b ' , ' b ' : 1 } " ) ; 
 + assertInvalidSyntax ( " ALTER ROLE r WITH OPTIONS = ' term ' " ) ; 
 + assertInvalidSyntax ( " ALTER ROLE r WITH OPTIONS = 99 " ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7be913e . . 7c5a752 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 2 , 6 + 2 , 8 @ @ 
 * add command to stop compactions ( CASSANDRA - 1740 ) 
 * filter out unavailable cipher suites when using encryption ( CASSANDRA - 3178 ) 
 * ( HADOOP ) add old - style api support for CFIF and CFRR ( CASSANDRA - 2799 ) 
 + * Support TimeUUIDType column names in Stress . java tool ( CASSANDRA - 3541 ) 
 + 
 
 1 . 0 . 5 
 * revert CASSANDRA - 3407 ( see CASSANDRA - 3540 ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / Session . java b / tools / stress / src / org / apache / cassandra / stress / Session . java 
 index abbea50 . . ddc6a69 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / Session . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / Session . java 
 @ @ - 27 , 9 + 27 , 7 @ @ import java . util . concurrent . atomic . AtomicLong ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ConfigurationException ; 
 - import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; 
 - import org . apache . cassandra . db . marshal . AbstractType ; 
 - import org . apache . cassandra . db . marshal . TypeParser ; 
 + import org . apache . cassandra . db . marshal . * ; 
 import org . apache . commons . cli . * ; 
 
 import org . apache . cassandra . db . ColumnFamilyType ; 
 @ @ - 50 , 6 + 48 , 8 @ @ public class Session implements Serializable 
 public static final String DEFAULT _ COMPARATOR = " AsciiType " ; 
 public static final String DEFAULT _ VALIDATOR = " BytesType " ; 
 
 + private static InetAddress localInetAddress ; 
 + 
 public final AtomicInteger operations ; 
 public final AtomicInteger keys ; 
 public final AtomicLong latency ; 
 @ @ - 89 , 6 + 89 , 7 @ @ public class Session implements Serializable 
 availableOptions . addOption ( " I " , " compression " , true , " Specify the compression to use for sstable , default : no compression " ) ; 
 availableOptions . addOption ( " Q " , " query - names " , true , " Comma - separated list of column names to retrieve from each row . " ) ; 
 availableOptions . addOption ( " Z " , " compaction - strategy " , true , " CompactionStrategy to use . " ) ; 
 + availableOptions . addOption ( " U " , " comparator " , true , " Column Comparator to use . Currently supported types are : TimeUUIDType , AsciiType , UTF8Type . " ) ; 
 } 
 
 private int numKeys = 1000 * 1000 ; 
 @ @ - 131 , 6 + 132 , 8 @ @ public class Session implements Serializable 
 protected float sigma ; 
 
 public final InetAddress sendToDaemon ; 
 + public final String comparator ; 
 + public final boolean timeUUIDComparator ; 
 
 public Session ( String [ ] arguments ) throws IllegalArgumentException 
 { 
 @ @ - 321 , 6 + 324 , 35 @ @ public class Session implements Serializable 
 System . exit ( 1 ) ; 
 } 
 } 
 + 
 + if ( cmd . hasOption ( " U " ) ) 
 + { 
 + AbstractType parsed = null ; 
 + 
 + try 
 + { 
 + parsed = TypeParser . parse ( cmd . getOptionValue ( " U " ) ) ; 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + System . err . println ( e . getMessage ( ) ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + 
 + comparator = cmd . getOptionValue ( " U " ) ; 
 + timeUUIDComparator = parsed instanceof TimeUUIDType ; 
 + 
 + if ( ! ( parsed instanceof TimeUUIDType | | parsed instanceof AsciiType | | parsed instanceof UTF8Type ) ) 
 + { 
 + System . err . println ( " Currently supported types are : TimeUUIDType , AsciiType , UTF8Type . " ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + } 
 + else 
 + { 
 + comparator = null ; 
 + timeUUIDComparator = false ; 
 + } 
 } 
 catch ( ParseException e ) 
 { 
 @ @ - 464 , 6 + 496 , 7 @ @ public class Session implements Serializable 
 public void createKeySpaces ( ) 
 { 
 KsDef keyspace = new KsDef ( ) ; 
 + String defaultComparator = comparator = = null ? DEFAULT _ COMPARATOR : comparator ; 
 
 / / column family for standard columns 
 CfDef standardCfDef = new CfDef ( " Keyspace1 " , " Standard1 " ) ; 
 @ @ - 471 , 7 + 504 , 7 @ @ public class Session implements Serializable 
 if ( compression ! = null ) 
 compressionOptions . put ( " sstable _ compression " , compression ) ; 
 
 - standardCfDef . setComparator _ type ( DEFAULT _ COMPARATOR ) 
 + standardCfDef . setComparator _ type ( defaultComparator ) 
 . setDefault _ validation _ class ( DEFAULT _ VALIDATOR ) 
 . setCompression _ options ( compressionOptions ) ; 
 
 @ @ - 485 , 7 + 518 , 7 @ @ public class Session implements Serializable 
 / / column family with super columns 
 CfDef superCfDef = new CfDef ( " Keyspace1 " , " Super1 " ) . setColumn _ type ( " Super " ) ; 
 superCfDef . setComparator _ type ( DEFAULT _ COMPARATOR ) 
 - . setSubcomparator _ type ( DEFAULT _ COMPARATOR ) 
 + . setSubcomparator _ type ( defaultComparator ) 
 . setDefault _ validation _ class ( DEFAULT _ VALIDATOR ) 
 . setCompression _ options ( compressionOptions ) ; 
 
 @ @ - 574 , 4 + 607 , 20 @ @ public class Session implements Serializable 
 return client ; 
 } 
 
 + public static InetAddress getLocalAddress ( ) 
 + { 
 + if ( localInetAddress = = null ) 
 + { 
 + try 
 + { 
 + localInetAddress = InetAddress . getLocalHost ( ) ; 
 + } 
 + catch ( UnknownHostException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + return localInetAddress ; 
 + } 
 } 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java b / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java 
 index 45d33cb . . c81df6f 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java 
 @ @ - 52 , 9 + 52 , 9 @ @ public class Inserter extends Operation 
 
 for ( int i = 0 ; i < session . getColumnsPerKey ( ) ; i + + ) 
 { 
 - String columnName = ( " C " + Integer . toString ( i ) ) ; 
 - ByteBuffer columnValue = values . get ( i % values . size ( ) ) ; 
 - columns . add ( new Column ( ByteBufferUtil . bytes ( columnName ) ) . setValue ( columnValue ) . setTimestamp ( System . currentTimeMillis ( ) ) ) ; 
 + columns . add ( new Column ( columnName ( i , session . timeUUIDComparator ) ) 
 + . setValue ( values . get ( i % values . size ( ) ) ) 
 + . setTimestamp ( System . currentTimeMillis ( ) ) ) ; 
 } 
 
 if ( session . getColumnFamilyType ( ) = = ColumnFamilyType . Super ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / Operation . java b / tools / stress / src / org / apache / cassandra / stress / util / Operation . java 
 index 10b97ad . . dd5128f 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / util / Operation . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / util / Operation . java 
 @ @ - 27 , 11 + 27 , 14 @ @ import java . util . Random ; 
 
 import static com . google . common . base . Charsets . UTF _ 8 ; 
 
 + import org . apache . cassandra . db . marshal . TimeUUIDType ; 
 import org . apache . cassandra . stress . Session ; 
 import org . apache . cassandra . stress . Stress ; 
 import org . apache . cassandra . thrift . Cassandra ; 
 import org . apache . cassandra . thrift . InvalidRequestException ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . UUIDGen ; 
 
 public abstract class Operation 
 { 
 @ @ - 200 , 6 + 203 , 13 @ @ public abstract class Operation 
 return result . toString ( ) ; 
 } 
 
 + protected ByteBuffer columnName ( int index , boolean timeUUIDComparator ) 
 + { 
 + return timeUUIDComparator 
 + ? TimeUUIDType . instance . decompose ( UUIDGen . makeType1UUIDFromHost ( Session . getLocalAddress ( ) ) ) 
 + : ByteBufferUtil . bytes ( String . format ( " C % d " , index ) ) ; 
 + } 
 + 
 protected String getExceptionMessage ( Exception e ) 
 { 
 String className = e . getClass ( ) . getSimpleName ( ) ;
