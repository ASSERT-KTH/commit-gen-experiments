BLEU SCORE: 0.011614897408688967

TEST MSG: Validate ALTER for involved views as well as to the base table
GENERATED MSG: Validate that column names in column _ metadata does not equal to key _ alias on create / update of the ColumnFamily and CQL ' ALTER ' statement .

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index 00ca704 . . 0387060 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 786 , 7 + 786 , 7 @ @ public final class CFMetaData <nl> throw new ConfigurationException ( " types do not match . " ) ; <nl> <nl> if ( ! cfm . comparator . isCompatibleWith ( comparator ) ) <nl> - throw new ConfigurationException ( String . format ( " Column family comparators do not match or are not compatible ( found % s ; expected % s ) . " , cfm . comparator . getClass ( ) . getSimpleName ( ) , comparator . getClass ( ) . getSimpleName ( ) ) ) ; <nl> + throw new ConfigurationException ( String . format ( " Column family comparators do not match or are not compatible ( found % s ; expected % s ) . " , cfm . comparator . toString ( ) , comparator . toString ( ) ) ) ; <nl> } <nl> <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> index c410f10 . . 879f618 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . db . marshal . CollectionType ; <nl> import org . apache . cassandra . db . marshal . CounterColumnType ; <nl> + import org . apache . cassandra . db . marshal . ReversedType ; <nl> import org . apache . cassandra . db . view . View ; <nl> import org . apache . cassandra . exceptions . * ; <nl> import org . apache . cassandra . schema . IndexMetadata ; <nl> @ @ - 186 , 55 + 187 , 25 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> if ( def = = null ) <nl> throw new InvalidRequestException ( String . format ( " Column % s was not found in table % s " , columnName , columnFamily ( ) ) ) ; <nl> <nl> - AbstractType < ? > validatorType = validator . getType ( ) ; <nl> - switch ( def . kind ) <nl> - { <nl> - case PARTITION _ KEY : <nl> - if ( validatorType instanceof CounterColumnType ) <nl> - throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , columnName ) ) ; <nl> - <nl> - AbstractType < ? > currentType = cfm . getKeyValidatorAsClusteringComparator ( ) . subtype ( def . position ( ) ) ; <nl> - if ( ! validatorType . isValueCompatibleWith ( currentType ) ) <nl> - throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are incompatible . " , <nl> - columnName , <nl> - currentType . asCQL3Type ( ) , <nl> - validator ) ) ; <nl> - break ; <nl> - case CLUSTERING : <nl> - AbstractType < ? > oldType = cfm . comparator . subtype ( def . position ( ) ) ; <nl> - / / Note that CFMetaData . validateCompatibility already validate the change we ' re about to do . However , the error message it <nl> - / / sends is a bit cryptic for a CQL3 user , so validating here for a sake of returning a better error message <nl> - / / Do note that we need isCompatibleWith here , not just isValueCompatibleWith . <nl> - if ( ! validatorType . isCompatibleWith ( oldType ) ) <nl> - throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are not order - compatible . " , <nl> - columnName , <nl> - oldType . asCQL3Type ( ) , <nl> - validator ) ) ; <nl> - <nl> - break ; <nl> - case REGULAR : <nl> - case STATIC : <nl> - / / Thrift allows to change a column validator so CFMetaData . validateCompatibility will let it slide <nl> - / / if we change to an incompatible type ( contrarily to the comparator case ) . But we don ' t want to <nl> - / / allow it for CQL3 ( see # 5882 ) so validating it explicitly here . We only care about value compatibility <nl> - / / though since we won ' t compare values ( except when there is an index , but that is validated by <nl> - / / ColumnDefinition already ) . <nl> - if ( ! validatorType . isValueCompatibleWith ( def . type ) ) <nl> - throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are incompatible . " , <nl> - columnName , <nl> - def . type . asCQL3Type ( ) , <nl> - validator ) ) ; <nl> - break ; <nl> - } <nl> + AbstractType < ? > validatorType = def . isReversedType ( ) & & ! validator . getType ( ) . isReversed ( ) <nl> + ? ReversedType . getInstance ( validator . getType ( ) ) <nl> + : validator . getType ( ) ; <nl> + validateAlter ( cfm , def , validatorType ) ; <nl> / / In any case , we update the column definition <nl> cfm . addOrReplaceColumnDefinition ( def . withNewType ( validatorType ) ) ; <nl> <nl> - / / We have to alter the schema of the view table as well ; it doesn ' t affect the definition however <nl> + / / We also have to validate the view types here . If we have a view which includes a column as part of <nl> + / / the clustering key , we need to make sure that it is indeed compatible . <nl> for ( ViewDefinition view : views ) <nl> { <nl> if ( ! view . includes ( columnName ) ) continue ; <nl> ViewDefinition viewCopy = view . copy ( ) ; <nl> - viewCopy . metadata . addOrReplaceColumnDefinition ( def . withNewType ( validatorType ) ) ; <nl> + ColumnDefinition viewDef = view . metadata . getColumnDefinition ( columnName ) ; <nl> + AbstractType viewType = viewDef . isReversedType ( ) & & ! validator . getType ( ) . isReversed ( ) <nl> + ? ReversedType . getInstance ( validator . getType ( ) ) <nl> + : validator . getType ( ) ; <nl> + validateAlter ( view . metadata , viewDef , viewType ) ; <nl> + viewCopy . metadata . addOrReplaceColumnDefinition ( viewDef . withNewType ( viewType ) ) ; <nl> <nl> if ( viewUpdates = = null ) <nl> viewUpdates = new ArrayList < > ( ) ; <nl> @ @ - 361 , 6 + 332 , 50 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> return true ; <nl> } <nl> <nl> + private static void validateAlter ( CFMetaData cfm , ColumnDefinition def , AbstractType < ? > validatorType ) <nl> + { <nl> + switch ( def . kind ) <nl> + { <nl> + case PARTITION _ KEY : <nl> + if ( validatorType instanceof CounterColumnType ) <nl> + throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , def . name ) ) ; <nl> + <nl> + AbstractType < ? > currentType = cfm . getKeyValidatorAsClusteringComparator ( ) . subtype ( def . position ( ) ) ; <nl> + if ( ! validatorType . isValueCompatibleWith ( currentType ) ) <nl> + throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are incompatible . " , <nl> + def . name , <nl> + currentType . asCQL3Type ( ) , <nl> + validatorType . asCQL3Type ( ) ) ) ; <nl> + break ; <nl> + case CLUSTERING : <nl> + AbstractType < ? > oldType = cfm . comparator . subtype ( def . position ( ) ) ; <nl> + / / Note that CFMetaData . validateCompatibility already validate the change we ' re about to do . However , the error message it <nl> + / / sends is a bit cryptic for a CQL3 user , so validating here for a sake of returning a better error message <nl> + / / Do note that we need isCompatibleWith here , not just isValueCompatibleWith . <nl> + if ( ! validatorType . isCompatibleWith ( oldType ) ) <nl> + { <nl> + throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are not order - compatible . " , <nl> + def . name , <nl> + oldType . asCQL3Type ( ) , <nl> + validatorType . asCQL3Type ( ) ) ) ; <nl> + } <nl> + break ; <nl> + case REGULAR : <nl> + case STATIC : <nl> + / / Thrift allows to change a column validator so CFMetaData . validateCompatibility will let it slide <nl> + / / if we change to an incompatible type ( contrarily to the comparator case ) . But we don ' t want to <nl> + / / allow it for CQL3 ( see # 5882 ) so validating it explicitly here . We only care about value compatibility <nl> + / / though since we won ' t compare values ( except when there is an index , but that is validated by <nl> + / / ColumnDefinition already ) . <nl> + if ( ! validatorType . isValueCompatibleWith ( def . type ) ) <nl> + throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are incompatible . " , <nl> + def . name , <nl> + def . type . asCQL3Type ( ) , <nl> + validatorType . asCQL3Type ( ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + <nl> public String toString ( ) <nl> { <nl> return String . format ( " AlterTableStatement ( name = % s , type = % s , column = % s , validator = % s ) " , <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / ViewTest . java b / test / unit / org / apache / cassandra / cql3 / ViewTest . java <nl> index 5d65115 . . 55e7e1f 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / ViewTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / ViewTest . java <nl> @ @ - 1456 , 4 + 1456 , 80 @ @ public class ViewTest extends CQLTester <nl> ResultSet mvRows = executeNet ( protocolVersion , " SELECT a , b FROM mv1 " ) ; <nl> assertRowsNet ( protocolVersion , mvRows , row ( 1 , 1 ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testAlterTable ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( " + <nl> + " a int , " + <nl> + " b text , " + <nl> + " PRIMARY KEY ( a , b ) ) " ) ; <nl> + <nl> + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; <nl> + <nl> + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( b , a ) " ) ; <nl> + <nl> + alterTable ( " ALTER TABLE % s ALTER b TYPE blob " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAlterReversedTypeBaseTable ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( " + <nl> + " a int , " + <nl> + " b text , " + <nl> + " PRIMARY KEY ( a , b ) ) " + <nl> + " WITH CLUSTERING ORDER BY ( b DESC ) " ) ; <nl> + <nl> + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; <nl> + <nl> + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( a , b ) WITH CLUSTERING ORDER BY ( b ASC ) " ) ; <nl> + <nl> + alterTable ( " ALTER TABLE % s ALTER b TYPE blob " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAlterReversedTypeViewTable ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( " + <nl> + " a int , " + <nl> + " b text , " + <nl> + " PRIMARY KEY ( a , b ) ) " ) ; <nl> + <nl> + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; <nl> + <nl> + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( a , b ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; <nl> + <nl> + alterTable ( " ALTER TABLE % s ALTER b TYPE blob " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAlterClusteringViewTable ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( " + <nl> + " a int , " + <nl> + " b text , " + <nl> + " PRIMARY KEY ( a ) ) " ) ; <nl> + <nl> + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; <nl> + <nl> + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( a , b ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; <nl> + <nl> + alterTable ( " ALTER TABLE % s ALTER b TYPE blob " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAlterViewTableValue ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( " + <nl> + " a int , " + <nl> + " b int , " + <nl> + " PRIMARY KEY ( a ) ) " ) ; <nl> + <nl> + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; <nl> + <nl> + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( a , b ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; <nl> + <nl> + assertInvalid ( " ALTER TABLE % s ALTER b TYPE blob " ) ; <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java <nl> index b7f814b . . a56ccc9 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java <nl> @ @ - 273 , 6 + 273 , 20 @ @ public class AlterTest extends CQLTester <nl> " ALTER TABLE % s WITH compression = { ' class ' : ' SnappyCompressor ' , ' chunk _ length _ kb ' : 32 , ' chunk _ length _ in _ kb ' : 32 } ; " ) ; <nl> } <nl> <nl> + @ Test <nl> + public void testAlterType ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( id text PRIMARY KEY , content text ) ; " ) ; <nl> + alterTable ( " ALTER TABLE % s ALTER content TYPE blob " ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( pk int , ck text , value blob , PRIMARY KEY ( pk , ck ) ) WITH CLUSTERING ORDER BY ( ck DESC ) " ) ; <nl> + alterTable ( " ALTER TABLE % s ALTER ck TYPE blob " ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( pk int , ck int , value blob , PRIMARY KEY ( pk , ck ) ) " ) ; <nl> + assertThrowsConfigurationException ( " Cannot change value from type blob to type text : types are incompatible . " , <nl> + " ALTER TABLE % s ALTER value TYPE TEXT ; " ) ; <nl> + } <nl> + <nl> private void assertThrowsConfigurationException ( String errorMsg , String alterStmt ) throws Throwable <nl> { <nl> try
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / gms / VersionedValue . java b / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> index fb6181a . . 2323f2b 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> + + + b / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> @ @ - 160 , 7 + 160 , 7 @ @ public class VersionedValue implements Comparable < VersionedValue > <nl> <nl> public VersionedValue rpcaddress ( InetAddress endpoint ) <nl> { <nl> - return new VersionedValue ( endpoint . toString ( ) ) ; <nl> + return new VersionedValue ( endpoint . getHostAddress ( ) ) ; <nl> } <nl> <nl> public VersionedValue releaseVersion ( )

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index 00ca704 . . 0387060 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 786 , 7 + 786 , 7 @ @ public final class CFMetaData 
 throw new ConfigurationException ( " types do not match . " ) ; 
 
 if ( ! cfm . comparator . isCompatibleWith ( comparator ) ) 
 - throw new ConfigurationException ( String . format ( " Column family comparators do not match or are not compatible ( found % s ; expected % s ) . " , cfm . comparator . getClass ( ) . getSimpleName ( ) , comparator . getClass ( ) . getSimpleName ( ) ) ) ; 
 + throw new ConfigurationException ( String . format ( " Column family comparators do not match or are not compatible ( found % s ; expected % s ) . " , cfm . comparator . toString ( ) , comparator . toString ( ) ) ) ; 
 } 
 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 index c410f10 . . 879f618 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . db . marshal . CollectionType ; 
 import org . apache . cassandra . db . marshal . CounterColumnType ; 
 + import org . apache . cassandra . db . marshal . ReversedType ; 
 import org . apache . cassandra . db . view . View ; 
 import org . apache . cassandra . exceptions . * ; 
 import org . apache . cassandra . schema . IndexMetadata ; 
 @ @ - 186 , 55 + 187 , 25 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 if ( def = = null ) 
 throw new InvalidRequestException ( String . format ( " Column % s was not found in table % s " , columnName , columnFamily ( ) ) ) ; 
 
 - AbstractType < ? > validatorType = validator . getType ( ) ; 
 - switch ( def . kind ) 
 - { 
 - case PARTITION _ KEY : 
 - if ( validatorType instanceof CounterColumnType ) 
 - throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , columnName ) ) ; 
 - 
 - AbstractType < ? > currentType = cfm . getKeyValidatorAsClusteringComparator ( ) . subtype ( def . position ( ) ) ; 
 - if ( ! validatorType . isValueCompatibleWith ( currentType ) ) 
 - throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are incompatible . " , 
 - columnName , 
 - currentType . asCQL3Type ( ) , 
 - validator ) ) ; 
 - break ; 
 - case CLUSTERING : 
 - AbstractType < ? > oldType = cfm . comparator . subtype ( def . position ( ) ) ; 
 - / / Note that CFMetaData . validateCompatibility already validate the change we ' re about to do . However , the error message it 
 - / / sends is a bit cryptic for a CQL3 user , so validating here for a sake of returning a better error message 
 - / / Do note that we need isCompatibleWith here , not just isValueCompatibleWith . 
 - if ( ! validatorType . isCompatibleWith ( oldType ) ) 
 - throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are not order - compatible . " , 
 - columnName , 
 - oldType . asCQL3Type ( ) , 
 - validator ) ) ; 
 - 
 - break ; 
 - case REGULAR : 
 - case STATIC : 
 - / / Thrift allows to change a column validator so CFMetaData . validateCompatibility will let it slide 
 - / / if we change to an incompatible type ( contrarily to the comparator case ) . But we don ' t want to 
 - / / allow it for CQL3 ( see # 5882 ) so validating it explicitly here . We only care about value compatibility 
 - / / though since we won ' t compare values ( except when there is an index , but that is validated by 
 - / / ColumnDefinition already ) . 
 - if ( ! validatorType . isValueCompatibleWith ( def . type ) ) 
 - throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are incompatible . " , 
 - columnName , 
 - def . type . asCQL3Type ( ) , 
 - validator ) ) ; 
 - break ; 
 - } 
 + AbstractType < ? > validatorType = def . isReversedType ( ) & & ! validator . getType ( ) . isReversed ( ) 
 + ? ReversedType . getInstance ( validator . getType ( ) ) 
 + : validator . getType ( ) ; 
 + validateAlter ( cfm , def , validatorType ) ; 
 / / In any case , we update the column definition 
 cfm . addOrReplaceColumnDefinition ( def . withNewType ( validatorType ) ) ; 
 
 - / / We have to alter the schema of the view table as well ; it doesn ' t affect the definition however 
 + / / We also have to validate the view types here . If we have a view which includes a column as part of 
 + / / the clustering key , we need to make sure that it is indeed compatible . 
 for ( ViewDefinition view : views ) 
 { 
 if ( ! view . includes ( columnName ) ) continue ; 
 ViewDefinition viewCopy = view . copy ( ) ; 
 - viewCopy . metadata . addOrReplaceColumnDefinition ( def . withNewType ( validatorType ) ) ; 
 + ColumnDefinition viewDef = view . metadata . getColumnDefinition ( columnName ) ; 
 + AbstractType viewType = viewDef . isReversedType ( ) & & ! validator . getType ( ) . isReversed ( ) 
 + ? ReversedType . getInstance ( validator . getType ( ) ) 
 + : validator . getType ( ) ; 
 + validateAlter ( view . metadata , viewDef , viewType ) ; 
 + viewCopy . metadata . addOrReplaceColumnDefinition ( viewDef . withNewType ( viewType ) ) ; 
 
 if ( viewUpdates = = null ) 
 viewUpdates = new ArrayList < > ( ) ; 
 @ @ - 361 , 6 + 332 , 50 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 return true ; 
 } 
 
 + private static void validateAlter ( CFMetaData cfm , ColumnDefinition def , AbstractType < ? > validatorType ) 
 + { 
 + switch ( def . kind ) 
 + { 
 + case PARTITION _ KEY : 
 + if ( validatorType instanceof CounterColumnType ) 
 + throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , def . name ) ) ; 
 + 
 + AbstractType < ? > currentType = cfm . getKeyValidatorAsClusteringComparator ( ) . subtype ( def . position ( ) ) ; 
 + if ( ! validatorType . isValueCompatibleWith ( currentType ) ) 
 + throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are incompatible . " , 
 + def . name , 
 + currentType . asCQL3Type ( ) , 
 + validatorType . asCQL3Type ( ) ) ) ; 
 + break ; 
 + case CLUSTERING : 
 + AbstractType < ? > oldType = cfm . comparator . subtype ( def . position ( ) ) ; 
 + / / Note that CFMetaData . validateCompatibility already validate the change we ' re about to do . However , the error message it 
 + / / sends is a bit cryptic for a CQL3 user , so validating here for a sake of returning a better error message 
 + / / Do note that we need isCompatibleWith here , not just isValueCompatibleWith . 
 + if ( ! validatorType . isCompatibleWith ( oldType ) ) 
 + { 
 + throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are not order - compatible . " , 
 + def . name , 
 + oldType . asCQL3Type ( ) , 
 + validatorType . asCQL3Type ( ) ) ) ; 
 + } 
 + break ; 
 + case REGULAR : 
 + case STATIC : 
 + / / Thrift allows to change a column validator so CFMetaData . validateCompatibility will let it slide 
 + / / if we change to an incompatible type ( contrarily to the comparator case ) . But we don ' t want to 
 + / / allow it for CQL3 ( see # 5882 ) so validating it explicitly here . We only care about value compatibility 
 + / / though since we won ' t compare values ( except when there is an index , but that is validated by 
 + / / ColumnDefinition already ) . 
 + if ( ! validatorType . isValueCompatibleWith ( def . type ) ) 
 + throw new ConfigurationException ( String . format ( " Cannot change % s from type % s to type % s : types are incompatible . " , 
 + def . name , 
 + def . type . asCQL3Type ( ) , 
 + validatorType . asCQL3Type ( ) ) ) ; 
 + break ; 
 + } 
 + } 
 + 
 public String toString ( ) 
 { 
 return String . format ( " AlterTableStatement ( name = % s , type = % s , column = % s , validator = % s ) " , 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / ViewTest . java b / test / unit / org / apache / cassandra / cql3 / ViewTest . java 
 index 5d65115 . . 55e7e1f 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / ViewTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / ViewTest . java 
 @ @ - 1456 , 4 + 1456 , 80 @ @ public class ViewTest extends CQLTester 
 ResultSet mvRows = executeNet ( protocolVersion , " SELECT a , b FROM mv1 " ) ; 
 assertRowsNet ( protocolVersion , mvRows , row ( 1 , 1 ) ) ; 
 } 
 + 
 + @ Test 
 + public void testAlterTable ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( " + 
 + " a int , " + 
 + " b text , " + 
 + " PRIMARY KEY ( a , b ) ) " ) ; 
 + 
 + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; 
 + 
 + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( b , a ) " ) ; 
 + 
 + alterTable ( " ALTER TABLE % s ALTER b TYPE blob " ) ; 
 + } 
 + 
 + @ Test 
 + public void testAlterReversedTypeBaseTable ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( " + 
 + " a int , " + 
 + " b text , " + 
 + " PRIMARY KEY ( a , b ) ) " + 
 + " WITH CLUSTERING ORDER BY ( b DESC ) " ) ; 
 + 
 + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; 
 + 
 + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( a , b ) WITH CLUSTERING ORDER BY ( b ASC ) " ) ; 
 + 
 + alterTable ( " ALTER TABLE % s ALTER b TYPE blob " ) ; 
 + } 
 + 
 + @ Test 
 + public void testAlterReversedTypeViewTable ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( " + 
 + " a int , " + 
 + " b text , " + 
 + " PRIMARY KEY ( a , b ) ) " ) ; 
 + 
 + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; 
 + 
 + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( a , b ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; 
 + 
 + alterTable ( " ALTER TABLE % s ALTER b TYPE blob " ) ; 
 + } 
 + 
 + @ Test 
 + public void testAlterClusteringViewTable ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( " + 
 + " a int , " + 
 + " b text , " + 
 + " PRIMARY KEY ( a ) ) " ) ; 
 + 
 + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; 
 + 
 + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( a , b ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; 
 + 
 + alterTable ( " ALTER TABLE % s ALTER b TYPE blob " ) ; 
 + } 
 + 
 + @ Test 
 + public void testAlterViewTableValue ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( " + 
 + " a int , " + 
 + " b int , " + 
 + " PRIMARY KEY ( a ) ) " ) ; 
 + 
 + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; 
 + 
 + createView ( " mv1 " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY ( a , b ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; 
 + 
 + assertInvalid ( " ALTER TABLE % s ALTER b TYPE blob " ) ; 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java 
 index b7f814b . . a56ccc9 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java 
 @ @ - 273 , 6 + 273 , 20 @ @ public class AlterTest extends CQLTester 
 " ALTER TABLE % s WITH compression = { ' class ' : ' SnappyCompressor ' , ' chunk _ length _ kb ' : 32 , ' chunk _ length _ in _ kb ' : 32 } ; " ) ; 
 } 
 
 + @ Test 
 + public void testAlterType ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( id text PRIMARY KEY , content text ) ; " ) ; 
 + alterTable ( " ALTER TABLE % s ALTER content TYPE blob " ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( pk int , ck text , value blob , PRIMARY KEY ( pk , ck ) ) WITH CLUSTERING ORDER BY ( ck DESC ) " ) ; 
 + alterTable ( " ALTER TABLE % s ALTER ck TYPE blob " ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( pk int , ck int , value blob , PRIMARY KEY ( pk , ck ) ) " ) ; 
 + assertThrowsConfigurationException ( " Cannot change value from type blob to type text : types are incompatible . " , 
 + " ALTER TABLE % s ALTER value TYPE TEXT ; " ) ; 
 + } 
 + 
 private void assertThrowsConfigurationException ( String errorMsg , String alterStmt ) throws Throwable 
 { 
 try

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / gms / VersionedValue . java b / src / java / org / apache / cassandra / gms / VersionedValue . java 
 index fb6181a . . 2323f2b 100644 
 - - - a / src / java / org / apache / cassandra / gms / VersionedValue . java 
 + + + b / src / java / org / apache / cassandra / gms / VersionedValue . java 
 @ @ - 160 , 7 + 160 , 7 @ @ public class VersionedValue implements Comparable < VersionedValue > 
 
 public VersionedValue rpcaddress ( InetAddress endpoint ) 
 { 
 - return new VersionedValue ( endpoint . toString ( ) ) ; 
 + return new VersionedValue ( endpoint . getHostAddress ( ) ) ; 
 } 
 
 public VersionedValue releaseVersion ( )
