BLEU SCORE: 0.03283637368030199

TEST MSG: Improve nodetool status performance for large cluster
GENERATED MSG: Restore getRangeToEndpointMap .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 72b3d59 . . 3bbef11 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 14 <nl> + * Improve nodetool status performance for large cluster ( CASSANDRA - 7238 ) <nl> * Make it clear what DTCS timestamp _ resolution is used for ( CASSANDRA - 11041 ) <nl> * Gossiper # isEnabled is not thread safe ( CASSANDRA - 11116 ) <nl> * Avoid major compaction mixing repaired and unrepaired sstables in DTCS ( CASSANDRA - 11113 ) <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index d8b1869 . . 02f6cf4 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 3599 , 14 + 3599 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> for ( String keyspace : keyspaceNames ) <nl> { <nl> + / / replication strategy of the current keyspace <nl> + AbstractReplicationStrategy strategy = Keyspace . open ( keyspace ) . getReplicationStrategy ( ) ; <nl> + Multimap < InetAddress , Range < Token > > endpointToRanges = strategy . getAddressRanges ( ) ; <nl> + <nl> logger . debug ( " Calculating ranges to stream and request for keyspace { } " , keyspace ) ; <nl> for ( Token newToken : newTokens ) <nl> { <nl> - / / replication strategy of the current keyspace ( aka table ) <nl> - AbstractReplicationStrategy strategy = Keyspace . open ( keyspace ) . getReplicationStrategy ( ) ; <nl> - <nl> / / getting collection of the currently used ranges by this keyspace <nl> - Collection < Range < Token > > currentRanges = getRangesForEndpoint ( keyspace , localAddress ) ; <nl> + Collection < Range < Token > > currentRanges = endpointToRanges . get ( localAddress ) ; <nl> / / collection of ranges which this node will serve after move to the new token <nl> Collection < Range < Token > > updatedRanges = strategy . getPendingAddressRanges ( tokenMetaClone , newToken , localAddress ) ; <nl> <nl> @ @ - 4018 , 18 + 4019 , 19 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * / <nl> public LinkedHashMap < InetAddress , Float > effectiveOwnership ( String keyspace ) throws IllegalStateException <nl> { <nl> - <nl> - 	 if ( keyspace ! = null ) <nl> - 	 { <nl> + AbstractReplicationStrategy strategy ; <nl> + if ( keyspace ! = null ) <nl> + { <nl> Keyspace keyspaceInstance = Schema . instance . getKeyspaceInstance ( keyspace ) ; <nl> - if ( keyspaceInstance = = null ) <nl> + if ( keyspaceInstance = = null ) <nl> throw new IllegalArgumentException ( " The keyspace " + keyspace + " , does not exist " ) ; <nl> <nl> - if ( keyspaceInstance . getReplicationStrategy ( ) instanceof LocalStrategy ) <nl> + if ( keyspaceInstance . getReplicationStrategy ( ) instanceof LocalStrategy ) <nl> throw new IllegalStateException ( " Ownership values for keyspaces with LocalStrategy are meaningless " ) ; <nl> - 	 } <nl> - 	 else <nl> - 	 { <nl> + strategy = keyspaceInstance . getReplicationStrategy ( ) ; <nl> + } <nl> + else <nl> + { <nl> List < String > nonSystemKeyspaces = Schema . instance . getNonSystemKeyspaces ( ) ; <nl> <nl> / / system _ traces is a non - system keyspace however it needs to be counted as one for this process <nl> @ @ - 4044 , 8 + 4046 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> keyspace = " system _ traces " ; <nl> <nl> Keyspace keyspaceInstance = Schema . instance . getKeyspaceInstance ( keyspace ) ; <nl> - if ( keyspaceInstance = = null ) <nl> + if ( keyspaceInstance = = null ) <nl> throw new IllegalArgumentException ( " The node does not have " + keyspace + " yet , probably still bootstrapping " ) ; <nl> + strategy = keyspaceInstance . getReplicationStrategy ( ) ; <nl> } <nl> <nl> TokenMetadata metadata = tokenMetadata . cloneOnlyTokenMap ( ) ; <nl> @ @ - 4060 , 6 + 4063 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> Map < Token , Float > tokenOwnership = getPartitioner ( ) . describeOwnership ( tokenMetadata . sortedTokens ( ) ) ; <nl> LinkedHashMap < InetAddress , Float > finalOwnership = Maps . newLinkedHashMap ( ) ; <nl> <nl> + Multimap < InetAddress , Range < Token > > endpointToRanges = strategy . getAddressRanges ( ) ; <nl> / / calculate ownership per dc <nl> for ( Collection < InetAddress > endpoints : endpointsGroupedByDc ) <nl> { <nl> @ @ - 4067 , 7 + 4071 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> for ( InetAddress endpoint : endpoints ) <nl> { <nl> float ownership = 0 . 0f ; <nl> - for ( Range < Token > range : getRangesForEndpoint ( keyspace , endpoint ) ) <nl> + for ( Range < Token > range : endpointToRanges . get ( endpoint ) ) <nl> { <nl> if ( tokenOwnership . containsKey ( range . right ) ) <nl> ownership + = tokenOwnership . get ( range . right ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / service / GCInspector . java b / src / java / org / apache / cassandra / service / GCInspector . java <nl> index e565e33 . . e88f671 100644 <nl> - - - a / src / java / org / apache / cassandra / service / GCInspector . java <nl> + + + b / src / java / org / apache / cassandra / service / GCInspector . java <nl> @ @ - 103 , 10 + 103 , 12 @ @ public class GCInspector <nl> <nl> Long previousCount = gccounts . get ( gc . getName ( ) ) ; <nl> Long count = gc . getCollectionCount ( ) ; <nl> - if ( count = = 0 ) <nl> - continue ; <nl> + <nl> if ( previousCount = = null ) <nl> - previousCount = 0L ; <nl> + previousCount = 0L ; <nl> + if ( count = = previousCount ) <nl> + continue ; <nl> + <nl> gccounts . put ( gc . getName ( ) , count ) ; <nl> <nl> MemoryUsage mu = membean . getHeapMemoryUsage ( ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 72b3d59 . . 3bbef11 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 14 
 + * Improve nodetool status performance for large cluster ( CASSANDRA - 7238 ) 
 * Make it clear what DTCS timestamp _ resolution is used for ( CASSANDRA - 11041 ) 
 * Gossiper # isEnabled is not thread safe ( CASSANDRA - 11116 ) 
 * Avoid major compaction mixing repaired and unrepaired sstables in DTCS ( CASSANDRA - 11113 ) 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index d8b1869 . . 02f6cf4 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 3599 , 14 + 3599 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 for ( String keyspace : keyspaceNames ) 
 { 
 + / / replication strategy of the current keyspace 
 + AbstractReplicationStrategy strategy = Keyspace . open ( keyspace ) . getReplicationStrategy ( ) ; 
 + Multimap < InetAddress , Range < Token > > endpointToRanges = strategy . getAddressRanges ( ) ; 
 + 
 logger . debug ( " Calculating ranges to stream and request for keyspace { } " , keyspace ) ; 
 for ( Token newToken : newTokens ) 
 { 
 - / / replication strategy of the current keyspace ( aka table ) 
 - AbstractReplicationStrategy strategy = Keyspace . open ( keyspace ) . getReplicationStrategy ( ) ; 
 - 
 / / getting collection of the currently used ranges by this keyspace 
 - Collection < Range < Token > > currentRanges = getRangesForEndpoint ( keyspace , localAddress ) ; 
 + Collection < Range < Token > > currentRanges = endpointToRanges . get ( localAddress ) ; 
 / / collection of ranges which this node will serve after move to the new token 
 Collection < Range < Token > > updatedRanges = strategy . getPendingAddressRanges ( tokenMetaClone , newToken , localAddress ) ; 
 
 @ @ - 4018 , 18 + 4019 , 19 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * / 
 public LinkedHashMap < InetAddress , Float > effectiveOwnership ( String keyspace ) throws IllegalStateException 
 { 
 - 
 - 	 if ( keyspace ! = null ) 
 - 	 { 
 + AbstractReplicationStrategy strategy ; 
 + if ( keyspace ! = null ) 
 + { 
 Keyspace keyspaceInstance = Schema . instance . getKeyspaceInstance ( keyspace ) ; 
 - if ( keyspaceInstance = = null ) 
 + if ( keyspaceInstance = = null ) 
 throw new IllegalArgumentException ( " The keyspace " + keyspace + " , does not exist " ) ; 
 
 - if ( keyspaceInstance . getReplicationStrategy ( ) instanceof LocalStrategy ) 
 + if ( keyspaceInstance . getReplicationStrategy ( ) instanceof LocalStrategy ) 
 throw new IllegalStateException ( " Ownership values for keyspaces with LocalStrategy are meaningless " ) ; 
 - 	 } 
 - 	 else 
 - 	 { 
 + strategy = keyspaceInstance . getReplicationStrategy ( ) ; 
 + } 
 + else 
 + { 
 List < String > nonSystemKeyspaces = Schema . instance . getNonSystemKeyspaces ( ) ; 
 
 / / system _ traces is a non - system keyspace however it needs to be counted as one for this process 
 @ @ - 4044 , 8 + 4046 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 keyspace = " system _ traces " ; 
 
 Keyspace keyspaceInstance = Schema . instance . getKeyspaceInstance ( keyspace ) ; 
 - if ( keyspaceInstance = = null ) 
 + if ( keyspaceInstance = = null ) 
 throw new IllegalArgumentException ( " The node does not have " + keyspace + " yet , probably still bootstrapping " ) ; 
 + strategy = keyspaceInstance . getReplicationStrategy ( ) ; 
 } 
 
 TokenMetadata metadata = tokenMetadata . cloneOnlyTokenMap ( ) ; 
 @ @ - 4060 , 6 + 4063 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 Map < Token , Float > tokenOwnership = getPartitioner ( ) . describeOwnership ( tokenMetadata . sortedTokens ( ) ) ; 
 LinkedHashMap < InetAddress , Float > finalOwnership = Maps . newLinkedHashMap ( ) ; 
 
 + Multimap < InetAddress , Range < Token > > endpointToRanges = strategy . getAddressRanges ( ) ; 
 / / calculate ownership per dc 
 for ( Collection < InetAddress > endpoints : endpointsGroupedByDc ) 
 { 
 @ @ - 4067 , 7 + 4071 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 for ( InetAddress endpoint : endpoints ) 
 { 
 float ownership = 0 . 0f ; 
 - for ( Range < Token > range : getRangesForEndpoint ( keyspace , endpoint ) ) 
 + for ( Range < Token > range : endpointToRanges . get ( endpoint ) ) 
 { 
 if ( tokenOwnership . containsKey ( range . right ) ) 
 ownership + = tokenOwnership . get ( range . right ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / service / GCInspector . java b / src / java / org / apache / cassandra / service / GCInspector . java 
 index e565e33 . . e88f671 100644 
 - - - a / src / java / org / apache / cassandra / service / GCInspector . java 
 + + + b / src / java / org / apache / cassandra / service / GCInspector . java 
 @ @ - 103 , 10 + 103 , 12 @ @ public class GCInspector 
 
 Long previousCount = gccounts . get ( gc . getName ( ) ) ; 
 Long count = gc . getCollectionCount ( ) ; 
 - if ( count = = 0 ) 
 - continue ; 
 + 
 if ( previousCount = = null ) 
 - previousCount = 0L ; 
 + previousCount = 0L ; 
 + if ( count = = previousCount ) 
 + continue ; 
 + 
 gccounts . put ( gc . getName ( ) , count ) ; 
 
 MemoryUsage mu = membean . getHeapMemoryUsage ( ) ;
