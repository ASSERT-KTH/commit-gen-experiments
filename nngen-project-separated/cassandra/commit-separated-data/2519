BLEU SCORE: 0.029079340872079116

TEST MSG: Fix regression from CASSANDRA - 6855
GENERATED MSG: Reject CAS queries with the native protocol v1

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql3 / QueryOptions . java b / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> index 12accaf . . 5801d55 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> @ @ - 58 , 7 + 58 , 7 @ @ public abstract class QueryOptions <nl> <nl> public static QueryOptions forInternalCalls ( ConsistencyLevel consistency , List < ByteBuffer > values ) <nl> { <nl> - return new DefaultQueryOptions ( consistency , values , false , SpecificOptions . DEFAULT , 0 ) ; <nl> + return new DefaultQueryOptions ( consistency , values , false , SpecificOptions . DEFAULT , 3 ) ; <nl> } <nl> <nl> public static QueryOptions fromPreV3Batch ( ConsistencyLevel consistency ) <nl> @ @ - 123 , 8 + 123 , 6 @ @ public abstract class QueryOptions <nl> <nl> private final SpecificOptions options ; <nl> <nl> - / / The protocol version of incoming queries . This is set during deserializaion and will be 0 <nl> - / / if the QueryOptions does not come from a user message ( or come from thrift ) . <nl> private final transient int protocolVersion ; <nl> <nl> DefaultQueryOptions ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , SpecificOptions options , int protocolVersion ) <nl> diff - - git a / src / java / org / apache / cassandra / serializers / CollectionSerializer . java b / src / java / org / apache / cassandra / serializers / CollectionSerializer . java <nl> index 0e16fda . . 43b04f3 100644 <nl> - - - a / src / java / org / apache / cassandra / serializers / CollectionSerializer . java <nl> + + + b / src / java / org / apache / cassandra / serializers / CollectionSerializer . java <nl> @ @ - 38 , 15 + 38 , 17 @ @ public abstract class CollectionSerializer < T > implements TypeSerializer < T > <nl> public ByteBuffer serialize ( T value ) <nl> { <nl> List < ByteBuffer > values = serializeValues ( value ) ; <nl> - / / The only case we serialize / deserialize collections internally ( i . e . not for the protocol sake ) , <nl> - / / is when collections are in UDT values . There , we use the protocol 3 version since it ' s more flexible . <nl> + / / See deserialize ( ) for why using the protocol v3 variant is the right thing to do . <nl> return pack ( values , getElementCount ( value ) , 3 ) ; <nl> } <nl> <nl> public T deserialize ( ByteBuffer bytes ) <nl> { <nl> - / / The only case we serialize / deserialize collections internally ( i . e . not for the protocol sake ) , <nl> - / / is when collections are in UDT values . There , we use the protocol 3 version since it ' s more flexible . <nl> + / / The only cases we serialize / deserialize collections internally ( i . e . not for the protocol sake ) , <nl> + / / is : <nl> + / / 1 ) when collections are in UDT values <nl> + / / 2 ) for internal calls . <nl> + / / In both case , using the protocol 3 version variant is the right thing to do . <nl> return deserializeForNativeProtocol ( bytes , 3 ) ; <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index ed221d9 . . 4af1cdc 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 166 , 8 + 166 , 19 @ @ public class SSTableReader extends SSTable implements Closeable <nl> partitioner , <nl> System . currentTimeMillis ( ) , <nl> sstableMetadata ) ; <nl> + <nl> + / / special implementation of load to use non - pooled SegmentedFile builders <nl> + SegmentedFile . Builder ibuilder = new BufferedSegmentedFile . Builder ( ) ; <nl> + SegmentedFile . Builder dbuilder = sstable . compression <nl> + ? new CompressedSegmentedFile . Builder ( ) <nl> + : new BufferedSegmentedFile . Builder ( ) ; <nl> + <nl> + if ( ! loadSummary ( sstable , ibuilder , dbuilder ) ) <nl> + sstable . buildSummary ( false , ibuilder , dbuilder , false ) ; <nl> + sstable . ifile = ibuilder . complete ( sstable . descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; <nl> + sstable . dfile = dbuilder . complete ( sstable . descriptor . filenameFor ( Component . DATA ) ) ; <nl> + <nl> sstable . bf = new AlwaysPresentFilter ( ) ; <nl> - sstable . loadForBatch ( ) ; <nl> return sstable ; <nl> } <nl> <nl> @ @ - 409 , 37 + 420 , 6 @ @ public class SSTableReader extends SSTable implements Closeable <nl> saveSummary ( this , ibuilder , dbuilder ) ; <nl> } <nl> <nl> - / * * <nl> - * A simplified load that creates a minimal partition index <nl> - * / <nl> - private void loadForBatch ( ) throws IOException <nl> - { <nl> - SegmentedFile . Builder ibuilder = new BufferedSegmentedFile . Builder ( ) ; <nl> - SegmentedFile . Builder dbuilder = compression <nl> - ? new CompressedSegmentedFile . Builder ( ) <nl> - : new BufferedSegmentedFile . Builder ( ) ; <nl> - <nl> - / / build a bare - bones IndexSummary <nl> - IndexSummaryBuilder summaryBuilder = new IndexSummaryBuilder ( 1 ) ; <nl> - RandomAccessReader in = RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) , true ) ; <nl> - try <nl> - { <nl> - ByteBuffer key = ByteBufferUtil . readWithShortLength ( in ) ; <nl> - first = decodeKey ( partitioner , descriptor , key ) ; <nl> - summaryBuilder . maybeAddEntry ( first , 0 ) ; <nl> - indexSummary = summaryBuilder . build ( partitioner ) ; <nl> - } <nl> - finally <nl> - { <nl> - FileUtils . closeQuietly ( in ) ; <nl> - } <nl> - <nl> - last = null ; / / shouldn ' t need this for batch operations <nl> - <nl> - ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; <nl> - dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; <nl> - } <nl> - <nl> private void buildSummary ( boolean recreatebloom , SegmentedFile . Builder ibuilder , SegmentedFile . Builder dbuilder , boolean summaryLoaded ) throws IOException <nl> { <nl> / / we read the positions in a BRAF so we don ' t have to worry about an entry spanning a mmap boundary . <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableReaderTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableReaderTest . java <nl> index 02b6855 . . fef27f1 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / sstable / SSTableReaderTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableReaderTest . java <nl> @ @ - 27 , 8 + 27 , 10 @ @ import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . List ; <nl> + import java . util . Set ; <nl> import java . util . concurrent . ExecutionException ; <nl> <nl> + import com . google . common . collect . Sets ; <nl> import org . junit . Test ; <nl> import org . junit . runner . RunWith ; <nl> <nl> @ @ - 315 , 6 + 317 , 42 @ @ public class SSTableReaderTest extends SchemaLoader <nl> assert reopened . first . token instanceof LocalToken ; <nl> } <nl> <nl> + @ Test <nl> + public void testGetPositionsForRangesFromTableOpenedForBulkLoading ( ) throws IOException , ExecutionException , InterruptedException <nl> + { <nl> + Table table = Table . open ( " Keyspace1 " ) ; <nl> + ColumnFamilyStore store = table . getColumnFamilyStore ( " Standard2 " ) ; <nl> + <nl> + / / insert data and compact to a single sstable . The <nl> + / / number of keys inserted is greater than index _ interval <nl> + / / to ensure multiple segments in the index file <nl> + CompactionManager . instance . disableAutoCompaction ( ) ; <nl> + for ( int j = 0 ; j < 130 ; j + + ) <nl> + { <nl> + ByteBuffer key = ByteBufferUtil . bytes ( String . valueOf ( j ) ) ; <nl> + RowMutation rm = new RowMutation ( " Keyspace1 " , key ) ; <nl> + rm . add ( new QueryPath ( " Standard2 " , null , ByteBufferUtil . bytes ( " 0 " ) ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , j ) ; <nl> + rm . apply ( ) ; <nl> + } <nl> + store . forceBlockingFlush ( ) ; <nl> + CompactionManager . instance . performMaximal ( store ) ; <nl> + <nl> + / / construct a range which is present in the sstable , but whose <nl> + / / keys are not found in the first segment of the index . <nl> + List < Range < Token > > ranges = new ArrayList < Range < Token > > ( ) ; <nl> + ranges . add ( new Range < Token > ( t ( 98 ) , t ( 99 ) ) ) ; <nl> + <nl> + SSTableReader sstable = store . getSSTables ( ) . iterator ( ) . next ( ) ; <nl> + List < Pair < Long , Long > > sections = sstable . getPositionsForRanges ( ranges ) ; <nl> + assert sections . size ( ) = = 1 : " Expected to find range in sstable " ; <nl> + <nl> + / / re - open the same sstable as it would be during bulk loading <nl> + Set < Component > components = Sets . newHashSet ( Component . DATA , Component . PRIMARY _ INDEX ) ; <nl> + SSTableReader bulkLoaded = SSTableReader . openForBatch ( sstable . descriptor , components , sstable . partitioner ) ; <nl> + sections = bulkLoaded . getPositionsForRanges ( ranges ) ; <nl> + assert sections . size ( ) = = 1 : " Expected to find range in sstable opened for bulk loading " ; <nl> + } <nl> + <nl> private void assertIndexQueryWorks ( ColumnFamilyStore indexedCFS ) throws IOException <nl> { <nl> assert " Indexed1 " . equals ( indexedCFS . getColumnFamilyName ( ) ) ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql3 / QueryOptions . java b / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 index 12accaf . . 5801d55 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 @ @ - 58 , 7 + 58 , 7 @ @ public abstract class QueryOptions 
 
 public static QueryOptions forInternalCalls ( ConsistencyLevel consistency , List < ByteBuffer > values ) 
 { 
 - return new DefaultQueryOptions ( consistency , values , false , SpecificOptions . DEFAULT , 0 ) ; 
 + return new DefaultQueryOptions ( consistency , values , false , SpecificOptions . DEFAULT , 3 ) ; 
 } 
 
 public static QueryOptions fromPreV3Batch ( ConsistencyLevel consistency ) 
 @ @ - 123 , 8 + 123 , 6 @ @ public abstract class QueryOptions 
 
 private final SpecificOptions options ; 
 
 - / / The protocol version of incoming queries . This is set during deserializaion and will be 0 
 - / / if the QueryOptions does not come from a user message ( or come from thrift ) . 
 private final transient int protocolVersion ; 
 
 DefaultQueryOptions ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , SpecificOptions options , int protocolVersion ) 
 diff - - git a / src / java / org / apache / cassandra / serializers / CollectionSerializer . java b / src / java / org / apache / cassandra / serializers / CollectionSerializer . java 
 index 0e16fda . . 43b04f3 100644 
 - - - a / src / java / org / apache / cassandra / serializers / CollectionSerializer . java 
 + + + b / src / java / org / apache / cassandra / serializers / CollectionSerializer . java 
 @ @ - 38 , 15 + 38 , 17 @ @ public abstract class CollectionSerializer < T > implements TypeSerializer < T > 
 public ByteBuffer serialize ( T value ) 
 { 
 List < ByteBuffer > values = serializeValues ( value ) ; 
 - / / The only case we serialize / deserialize collections internally ( i . e . not for the protocol sake ) , 
 - / / is when collections are in UDT values . There , we use the protocol 3 version since it ' s more flexible . 
 + / / See deserialize ( ) for why using the protocol v3 variant is the right thing to do . 
 return pack ( values , getElementCount ( value ) , 3 ) ; 
 } 
 
 public T deserialize ( ByteBuffer bytes ) 
 { 
 - / / The only case we serialize / deserialize collections internally ( i . e . not for the protocol sake ) , 
 - / / is when collections are in UDT values . There , we use the protocol 3 version since it ' s more flexible . 
 + / / The only cases we serialize / deserialize collections internally ( i . e . not for the protocol sake ) , 
 + / / is : 
 + / / 1 ) when collections are in UDT values 
 + / / 2 ) for internal calls . 
 + / / In both case , using the protocol 3 version variant is the right thing to do . 
 return deserializeForNativeProtocol ( bytes , 3 ) ; 
 } 


NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index ed221d9 . . 4af1cdc 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 166 , 8 + 166 , 19 @ @ public class SSTableReader extends SSTable implements Closeable 
 partitioner , 
 System . currentTimeMillis ( ) , 
 sstableMetadata ) ; 
 + 
 + / / special implementation of load to use non - pooled SegmentedFile builders 
 + SegmentedFile . Builder ibuilder = new BufferedSegmentedFile . Builder ( ) ; 
 + SegmentedFile . Builder dbuilder = sstable . compression 
 + ? new CompressedSegmentedFile . Builder ( ) 
 + : new BufferedSegmentedFile . Builder ( ) ; 
 + 
 + if ( ! loadSummary ( sstable , ibuilder , dbuilder ) ) 
 + sstable . buildSummary ( false , ibuilder , dbuilder , false ) ; 
 + sstable . ifile = ibuilder . complete ( sstable . descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; 
 + sstable . dfile = dbuilder . complete ( sstable . descriptor . filenameFor ( Component . DATA ) ) ; 
 + 
 sstable . bf = new AlwaysPresentFilter ( ) ; 
 - sstable . loadForBatch ( ) ; 
 return sstable ; 
 } 
 
 @ @ - 409 , 37 + 420 , 6 @ @ public class SSTableReader extends SSTable implements Closeable 
 saveSummary ( this , ibuilder , dbuilder ) ; 
 } 
 
 - / * * 
 - * A simplified load that creates a minimal partition index 
 - * / 
 - private void loadForBatch ( ) throws IOException 
 - { 
 - SegmentedFile . Builder ibuilder = new BufferedSegmentedFile . Builder ( ) ; 
 - SegmentedFile . Builder dbuilder = compression 
 - ? new CompressedSegmentedFile . Builder ( ) 
 - : new BufferedSegmentedFile . Builder ( ) ; 
 - 
 - / / build a bare - bones IndexSummary 
 - IndexSummaryBuilder summaryBuilder = new IndexSummaryBuilder ( 1 ) ; 
 - RandomAccessReader in = RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) , true ) ; 
 - try 
 - { 
 - ByteBuffer key = ByteBufferUtil . readWithShortLength ( in ) ; 
 - first = decodeKey ( partitioner , descriptor , key ) ; 
 - summaryBuilder . maybeAddEntry ( first , 0 ) ; 
 - indexSummary = summaryBuilder . build ( partitioner ) ; 
 - } 
 - finally 
 - { 
 - FileUtils . closeQuietly ( in ) ; 
 - } 
 - 
 - last = null ; / / shouldn ' t need this for batch operations 
 - 
 - ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; 
 - dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; 
 - } 
 - 
 private void buildSummary ( boolean recreatebloom , SegmentedFile . Builder ibuilder , SegmentedFile . Builder dbuilder , boolean summaryLoaded ) throws IOException 
 { 
 / / we read the positions in a BRAF so we don ' t have to worry about an entry spanning a mmap boundary . 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableReaderTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableReaderTest . java 
 index 02b6855 . . fef27f1 100644 
 - - - a / test / unit / org / apache / cassandra / io / sstable / SSTableReaderTest . java 
 + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableReaderTest . java 
 @ @ - 27 , 8 + 27 , 10 @ @ import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . List ; 
 + import java . util . Set ; 
 import java . util . concurrent . ExecutionException ; 
 
 + import com . google . common . collect . Sets ; 
 import org . junit . Test ; 
 import org . junit . runner . RunWith ; 
 
 @ @ - 315 , 6 + 317 , 42 @ @ public class SSTableReaderTest extends SchemaLoader 
 assert reopened . first . token instanceof LocalToken ; 
 } 
 
 + @ Test 
 + public void testGetPositionsForRangesFromTableOpenedForBulkLoading ( ) throws IOException , ExecutionException , InterruptedException 
 + { 
 + Table table = Table . open ( " Keyspace1 " ) ; 
 + ColumnFamilyStore store = table . getColumnFamilyStore ( " Standard2 " ) ; 
 + 
 + / / insert data and compact to a single sstable . The 
 + / / number of keys inserted is greater than index _ interval 
 + / / to ensure multiple segments in the index file 
 + CompactionManager . instance . disableAutoCompaction ( ) ; 
 + for ( int j = 0 ; j < 130 ; j + + ) 
 + { 
 + ByteBuffer key = ByteBufferUtil . bytes ( String . valueOf ( j ) ) ; 
 + RowMutation rm = new RowMutation ( " Keyspace1 " , key ) ; 
 + rm . add ( new QueryPath ( " Standard2 " , null , ByteBufferUtil . bytes ( " 0 " ) ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , j ) ; 
 + rm . apply ( ) ; 
 + } 
 + store . forceBlockingFlush ( ) ; 
 + CompactionManager . instance . performMaximal ( store ) ; 
 + 
 + / / construct a range which is present in the sstable , but whose 
 + / / keys are not found in the first segment of the index . 
 + List < Range < Token > > ranges = new ArrayList < Range < Token > > ( ) ; 
 + ranges . add ( new Range < Token > ( t ( 98 ) , t ( 99 ) ) ) ; 
 + 
 + SSTableReader sstable = store . getSSTables ( ) . iterator ( ) . next ( ) ; 
 + List < Pair < Long , Long > > sections = sstable . getPositionsForRanges ( ranges ) ; 
 + assert sections . size ( ) = = 1 : " Expected to find range in sstable " ; 
 + 
 + / / re - open the same sstable as it would be during bulk loading 
 + Set < Component > components = Sets . newHashSet ( Component . DATA , Component . PRIMARY _ INDEX ) ; 
 + SSTableReader bulkLoaded = SSTableReader . openForBatch ( sstable . descriptor , components , sstable . partitioner ) ; 
 + sections = bulkLoaded . getPositionsForRanges ( ranges ) ; 
 + assert sections . size ( ) = = 1 : " Expected to find range in sstable opened for bulk loading " ; 
 + } 
 + 
 private void assertIndexQueryWorks ( ColumnFamilyStore indexedCFS ) throws IOException 
 { 
 assert " Indexed1 " . equals ( indexedCFS . getColumnFamilyName ( ) ) ;
