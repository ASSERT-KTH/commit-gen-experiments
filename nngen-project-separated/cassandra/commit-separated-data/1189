BLEU SCORE: 0.040583489434387374

TEST MSG: 10089 - 2 . 2 patch
GENERATED MSG: Fix NPE in Gossip handleStateNormal

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / gms / EndpointState . java b / src / java / org / apache / cassandra / gms / EndpointState . java <nl> index 0e6985a . . 931da8d 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / EndpointState . java <nl> + + + b / src / java / org / apache / cassandra / gms / EndpointState . java <nl> @ @ - 18 , 7 + 18 , 11 @ @ <nl> package org . apache . cassandra . gms ; <nl> <nl> import java . io . * ; <nl> + import java . util . Collections ; <nl> + import java . util . EnumMap ; <nl> import java . util . Map ; <nl> + import java . util . Set ; <nl> + import java . util . concurrent . atomic . AtomicReference ; <nl> <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> @ @ - 27 , 8 + 31 , 6 @ @ import org . apache . cassandra . db . TypeSizes ; <nl> import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> <nl> - import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; <nl> - <nl> / * * <nl> * This abstraction represents both the HeartBeatState and the ApplicationState in an EndpointState <nl> * instance . Any state for a given endpoint can be retrieved from this instance . <nl> @ @ - 42 , 7 + 44 , 7 @ @ public class EndpointState <nl> public final static IVersionedSerializer < EndpointState > serializer = new EndpointStateSerializer ( ) ; <nl> <nl> private volatile HeartBeatState hbState ; <nl> - final Map < ApplicationState , VersionedValue > applicationState = new NonBlockingHashMap < ApplicationState , VersionedValue > ( ) ; <nl> + private final AtomicReference < Map < ApplicationState , VersionedValue > > applicationState ; <nl> <nl> / * fields below do not get serialized * / <nl> private volatile long updateTimestamp ; <nl> @ @ - 50 , 7 + 52 , 13 @ @ public class EndpointState <nl> <nl> EndpointState ( HeartBeatState initialHbState ) <nl> { <nl> + this ( initialHbState , new EnumMap < ApplicationState , VersionedValue > ( ApplicationState . class ) ) ; <nl> + } <nl> + <nl> + EndpointState ( HeartBeatState initialHbState , Map < ApplicationState , VersionedValue > states ) <nl> + { <nl> hbState = initialHbState ; <nl> + applicationState = new AtomicReference < Map < ApplicationState , VersionedValue > > ( new EnumMap < > ( states ) ) ; <nl> updateTimestamp = System . nanoTime ( ) ; <nl> isAlive = true ; <nl> } <nl> @ @ - 68 , 21 + 76 , 37 @ @ public class EndpointState <nl> <nl> public VersionedValue getApplicationState ( ApplicationState key ) <nl> { <nl> - return applicationState . get ( key ) ; <nl> + return applicationState . get ( ) . get ( key ) ; <nl> } <nl> <nl> - / * * <nl> - * TODO replace this with operations that don ' t expose private state <nl> - * / <nl> - @ Deprecated <nl> - public Map < ApplicationState , VersionedValue > getApplicationStateMap ( ) <nl> + public Set < Map . Entry < ApplicationState , VersionedValue > > states ( ) <nl> + { <nl> + return applicationState . get ( ) . entrySet ( ) ; <nl> + } <nl> + <nl> + public void addApplicationState ( ApplicationState key , VersionedValue value ) <nl> { <nl> - return applicationState ; <nl> + addApplicationStates ( Collections . singletonMap ( key , value ) ) ; <nl> } <nl> <nl> - void addApplicationState ( ApplicationState key , VersionedValue value ) <nl> + public void addApplicationStates ( Map < ApplicationState , VersionedValue > values ) <nl> { <nl> - applicationState . put ( key , value ) ; <nl> + addApplicationStates ( values . entrySet ( ) ) ; <nl> + } <nl> + <nl> + public void addApplicationStates ( Set < Map . Entry < ApplicationState , VersionedValue > > values ) <nl> + { <nl> + while ( true ) <nl> + { <nl> + Map < ApplicationState , VersionedValue > orig = applicationState . get ( ) ; <nl> + Map < ApplicationState , VersionedValue > copy = new EnumMap < > ( orig ) ; <nl> + <nl> + for ( Map . Entry < ApplicationState , VersionedValue > value : values ) <nl> + copy . put ( value . getKey ( ) , value . getValue ( ) ) ; <nl> + <nl> + if ( applicationState . compareAndSet ( orig , copy ) ) <nl> + return ; <nl> + } <nl> } <nl> <nl> / * getters and setters * / <nl> @ @ - 133 , 7 + 157 , 7 @ @ public class EndpointState <nl> <nl> public String toString ( ) <nl> { <nl> - return " EndpointState : HeartBeatState = " + hbState + " , AppStateMap = " + applicationState ; <nl> + return " EndpointState : HeartBeatState = " + hbState + " , AppStateMap = " + applicationState . get ( ) ; <nl> } <nl> } <nl> <nl> @ @ - 146 , 12 + 170 , 12 @ @ class EndpointStateSerializer implements IVersionedSerializer < EndpointState > <nl> HeartBeatState . serializer . serialize ( hbState , out , version ) ; <nl> <nl> / * serialize the map of ApplicationState objects * / <nl> - int size = epState . applicationState . size ( ) ; <nl> - out . writeInt ( size ) ; <nl> - for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . applicationState . entrySet ( ) ) <nl> + Set < Map . Entry < ApplicationState , VersionedValue > > states = epState . states ( ) ; <nl> + out . writeInt ( states . size ( ) ) ; <nl> + for ( Map . Entry < ApplicationState , VersionedValue > state : states ) <nl> { <nl> - VersionedValue value = entry . getValue ( ) ; <nl> - out . writeInt ( entry . getKey ( ) . ordinal ( ) ) ; <nl> + VersionedValue value = state . getValue ( ) ; <nl> + out . writeInt ( state . getKey ( ) . ordinal ( ) ) ; <nl> VersionedValue . serializer . serialize ( value , out , version ) ; <nl> } <nl> } <nl> @ @ - 159 , 26 + 183 , 28 @ @ class EndpointStateSerializer implements IVersionedSerializer < EndpointState > <nl> public EndpointState deserialize ( DataInput in , int version ) throws IOException <nl> { <nl> HeartBeatState hbState = HeartBeatState . serializer . deserialize ( in , version ) ; <nl> - EndpointState epState = new EndpointState ( hbState ) ; <nl> <nl> int appStateSize = in . readInt ( ) ; <nl> + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; <nl> for ( int i = 0 ; i < appStateSize ; + + i ) <nl> { <nl> int key = in . readInt ( ) ; <nl> VersionedValue value = VersionedValue . serializer . deserialize ( in , version ) ; <nl> - epState . addApplicationState ( Gossiper . STATES [ key ] , value ) ; <nl> + states . put ( Gossiper . STATES [ key ] , value ) ; <nl> } <nl> - return epState ; <nl> + <nl> + return new EndpointState ( hbState , states ) ; <nl> } <nl> <nl> public long serializedSize ( EndpointState epState , int version ) <nl> { <nl> long size = HeartBeatState . serializer . serializedSize ( epState . getHeartBeatState ( ) , version ) ; <nl> - size + = TypeSizes . NATIVE . sizeof ( epState . applicationState . size ( ) ) ; <nl> - for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . applicationState . entrySet ( ) ) <nl> + Set < Map . Entry < ApplicationState , VersionedValue > > states = epState . states ( ) ; <nl> + size + = TypeSizes . NATIVE . sizeof ( states . size ( ) ) ; <nl> + for ( Map . Entry < ApplicationState , VersionedValue > state : states ) <nl> { <nl> - VersionedValue value = entry . getValue ( ) ; <nl> - size + = TypeSizes . NATIVE . sizeof ( entry . getKey ( ) . ordinal ( ) ) ; <nl> + VersionedValue value = state . getValue ( ) ; <nl> + size + = TypeSizes . NATIVE . sizeof ( state . getKey ( ) . ordinal ( ) ) ; <nl> size + = VersionedValue . serializer . serializedSize ( value , version ) ; <nl> } <nl> return size ; <nl> diff - - git a / src / java / org / apache / cassandra / gms / FailureDetector . java b / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> index c563872 . . a0754b1 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> + + + b / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> @ @ - 192 , 15 + 192 , 16 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean <nl> { <nl> sb . append ( " generation : " ) . append ( endpointState . getHeartBeatState ( ) . getGeneration ( ) ) . append ( " \ n " ) ; <nl> sb . append ( " heartbeat : " ) . append ( endpointState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ) . append ( " \ n " ) ; <nl> - for ( Map . Entry < ApplicationState , VersionedValue > state : endpointState . applicationState . entrySet ( ) ) <nl> + for ( Map . Entry < ApplicationState , VersionedValue > state : endpointState . states ( ) ) <nl> { <nl> if ( state . getKey ( ) = = ApplicationState . TOKENS ) <nl> continue ; <nl> sb . append ( " " ) . append ( state . getKey ( ) ) . append ( " : " ) . append ( state . getValue ( ) . version ) . append ( " : " ) . append ( state . getValue ( ) . value ) . append ( " \ n " ) ; <nl> } <nl> - if ( endpointState . applicationState . containsKey ( ApplicationState . TOKENS ) ) <nl> + VersionedValue tokens = endpointState . getApplicationState ( ApplicationState . TOKENS ) ; <nl> + if ( tokens ! = null ) <nl> { <nl> - sb . append ( " TOKENS : " ) . append ( endpointState . applicationState . get ( ApplicationState . TOKENS ) . version ) . append ( " : < hidden > \ n " ) ; <nl> + sb . append ( " TOKENS : " ) . append ( tokens . version ) . append ( " : < hidden > \ n " ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index f78dc7a . . 86fdab2 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 224 , 7 + 224 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> return true ; <nl> try <nl> { <nl> - if ( entry . getValue ( ) . getApplicationStateMap ( ) . containsKey ( ApplicationState . INTERNAL _ IP ) & & seeds . contains ( InetAddress . getByName ( entry . getValue ( ) . getApplicationState ( ApplicationState . INTERNAL _ IP ) . value ) ) ) <nl> + VersionedValue internalIp = entry . getValue ( ) . getApplicationState ( ApplicationState . INTERNAL _ IP ) ; <nl> + if ( internalIp ! = null & & seeds . contains ( InetAddress . getByName ( internalIp . value ) ) ) <nl> return true ; <nl> } <nl> catch ( UnknownHostException e ) <nl> @ @ - 371 , 8 + 372 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> int getMaxEndpointStateVersion ( EndpointState epState ) <nl> { <nl> int maxVersion = epState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ; <nl> - for ( VersionedValue value : epState . getApplicationStateMap ( ) . values ( ) ) <nl> - maxVersion = Math . max ( maxVersion , value . version ) ; <nl> + for ( Map . Entry < ApplicationState , VersionedValue > state : epState . states ( ) ) <nl> + maxVersion = Math . max ( maxVersion , state . getValue ( ) . version ) ; <nl> return maxVersion ; <nl> } <nl> <nl> @ @ - 525 , 8 + 526 , 10 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> logger . info ( " Advertising removal for { } " , endpoint ) ; <nl> epState . updateTimestamp ( ) ; / / make sure we don ' t evict it too soon <nl> epState . getHeartBeatState ( ) . forceNewerGenerationUnsafe ( ) ; <nl> - epState . addApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . removingNonlocal ( hostId ) ) ; <nl> - epState . addApplicationState ( ApplicationState . REMOVAL _ COORDINATOR , StorageService . instance . valueFactory . removalCoordinator ( localHostId ) ) ; <nl> + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; <nl> + states . put ( ApplicationState . STATUS , StorageService . instance . valueFactory . removingNonlocal ( hostId ) ) ; <nl> + states . put ( ApplicationState . REMOVAL _ COORDINATOR , StorageService . instance . valueFactory . removalCoordinator ( localHostId ) ) ; <nl> + epState . addApplicationStates ( states ) ; <nl> endpointStateMap . put ( endpoint , epState ) ; <nl> } <nl> <nl> @ @ - 853 , 7 + 856 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> logger . trace ( " local heartbeat version { } greater than { } for { } " , localHbVersion , version , forEndpoint ) ; <nl> } <nl> / * Accumulate all application states whose versions are greater than " version " variable * / <nl> - for ( Entry < ApplicationState , VersionedValue > entry : epState . getApplicationStateMap ( ) . entrySet ( ) ) <nl> + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; <nl> + for ( Entry < ApplicationState , VersionedValue > entry : epState . states ( ) ) <nl> { <nl> VersionedValue value = entry . getValue ( ) ; <nl> if ( value . version > version ) <nl> @ @ - 865 , 9 + 869 , 11 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> final ApplicationState key = entry . getKey ( ) ; <nl> if ( logger . isTraceEnabled ( ) ) <nl> logger . trace ( " Adding state { } : { } " , key , value . value ) ; <nl> - reqdEndpointState . addApplicationState ( key , value ) ; <nl> + <nl> + states . put ( key , value ) ; <nl> } <nl> } <nl> + reqdEndpointState . addApplicationStates ( states ) ; <nl> } <nl> return reqdEndpointState ; <nl> } <nl> @ @ - 1147 , 19 + 1153 , 13 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> localState . setHeartBeatState ( remoteState . getHeartBeatState ( ) ) ; <nl> if ( logger . isTraceEnabled ( ) ) <nl> logger . trace ( " Updating heartbeat state version to { } from { } for { } . . . " , localState . getHeartBeatState ( ) . getHeartBeatVersion ( ) , oldVersion , addr ) ; <nl> - / / we need to make two loops here , one to apply , then another to notify , this way all states in an update are present and current when the notifications are received <nl> - for ( Entry < ApplicationState , VersionedValue > remoteEntry : remoteState . getApplicationStateMap ( ) . entrySet ( ) ) <nl> - { <nl> - ApplicationState remoteKey = remoteEntry . getKey ( ) ; <nl> - VersionedValue remoteValue = remoteEntry . getValue ( ) ; <nl> <nl> - assert remoteState . getHeartBeatState ( ) . getGeneration ( ) = = localState . getHeartBeatState ( ) . getGeneration ( ) ; <nl> - localState . addApplicationState ( remoteKey , remoteValue ) ; <nl> - } <nl> - for ( Entry < ApplicationState , VersionedValue > remoteEntry : remoteState . getApplicationStateMap ( ) . entrySet ( ) ) <nl> - { <nl> + Set < Entry < ApplicationState , VersionedValue > > remoteStates = remoteState . states ( ) ; <nl> + assert remoteState . getHeartBeatState ( ) . getGeneration ( ) = = localState . getHeartBeatState ( ) . getGeneration ( ) ; <nl> + localState . addApplicationStates ( remoteStates ) ; <nl> + <nl> + for ( Entry < ApplicationState , VersionedValue > remoteEntry : remoteStates ) <nl> doOnChangeNotifications ( addr , remoteEntry . getKey ( ) , remoteEntry . getValue ( ) ) ; <nl> - } <nl> } <nl> <nl> / / notify that a local application state is going to change ( doesn ' t get triggered for remote changes ) <nl> @ @ - 1273 , 7 + 1273 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> <nl> public void start ( int generationNumber ) <nl> { <nl> - start ( generationNumber , new HashMap < ApplicationState , VersionedValue > ( ) ) ; <nl> + start ( generationNumber , new EnumMap < ApplicationState , VersionedValue > ( ApplicationState . class ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 1285 , 8 + 1285 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> / * initialize the heartbeat state for this localEndpoint * / <nl> maybeInitializeLocalState ( generationNbr ) ; <nl> EndpointState localState = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> - for ( Map . Entry < ApplicationState , VersionedValue > entry : preloadLocalStates . entrySet ( ) ) <nl> - localState . addApplicationState ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + localState . addApplicationStates ( preloadLocalStates ) ; <nl> <nl> / / notify snitches that Gossiper is about to start <nl> DatabaseDescriptor . getEndpointSnitch ( ) . gossiperStarting ( ) ; <nl> @ @ - 1475 , 8 + 1474 , 10 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> EndpointState localState = oldState = = null ? newState : oldState ; <nl> <nl> / / always add the version state <nl> - localState . addApplicationState ( ApplicationState . NET _ VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; <nl> - localState . addApplicationState ( ApplicationState . HOST _ ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; <nl> + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; <nl> + states . put ( ApplicationState . NET _ VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; <nl> + states . put ( ApplicationState . HOST _ ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; <nl> + localState . addApplicationStates ( states ) ; <nl> } <nl> <nl> @ VisibleForTesting <nl> diff - - git a / src / java / org / apache / cassandra / gms / VersionedValue . java b / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> index a142f41 . . 3ea7bb4 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> + + + b / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> @ @ - 109 , 6 + 109 , 11 @ @ public class VersionedValue implements Comparable < VersionedValue > <nl> return " Value ( " + value + " , " + version + " ) " ; <nl> } <nl> <nl> + public byte [ ] toBytes ( ) <nl> + { <nl> + return value . getBytes ( ISO _ 8859 _ 1 ) ; <nl> + } <nl> + <nl> private static String versionString ( String . . . args ) <nl> { <nl> return StringUtils . join ( args , VersionedValue . DELIMITER ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index ad209fc . . 3ea261e 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> + import java . util . EnumMap ; <nl> import java . util . HashMap ; <nl> import java . util . HashSet ; <nl> import java . util . Iterator ; <nl> @ @ - 521 , 9 + 522 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> hostId = Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ; <nl> try <nl> { <nl> - if ( Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) . getApplicationState ( ApplicationState . TOKENS ) = = null ) <nl> + VersionedValue tokensVersionedValue = Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) . getApplicationState ( ApplicationState . TOKENS ) ; <nl> + if ( tokensVersionedValue = = null ) <nl> throw new RuntimeException ( " Could not find tokens for " + DatabaseDescriptor . getReplaceAddress ( ) + " to replace " ) ; <nl> - Collection < Token > tokens = TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( getApplicationStateValue ( DatabaseDescriptor . getReplaceAddress ( ) , ApplicationState . TOKENS ) ) ) ) ; <nl> + Collection < Token > tokens = TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( tokensVersionedValue . toBytes ( ) ) ) ) ; <nl> <nl> SystemKeyspace . setLocalHostId ( hostId ) ; / / use the replacee ' s host Id as our own so we receive hints , etc <nl> Gossiper . instance . resetEndpointStateMap ( ) ; / / clean up since we have what we need <nl> @ @ - 740 , 7 + 742 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> if ( ! joined ) <nl> { <nl> - Map < ApplicationState , VersionedValue > appStates = new HashMap < > ( ) ; <nl> + Map < ApplicationState , VersionedValue > appStates = new EnumMap < > ( ApplicationState . class ) ; <nl> <nl> if ( replacing & & ! ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) ) <nl> throw new ConfigurationException ( " Cannot set both join _ ring = false and attempt to replace a node " ) ; <nl> @ @ - 1655 , 8 + 1657 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> handleStateBootstrap ( endpoint ) ; <nl> break ; <nl> case VersionedValue . STATUS _ NORMAL : <nl> + handleStateNormal ( endpoint , VersionedValue . STATUS _ NORMAL ) ; <nl> + break ; <nl> case VersionedValue . SHUTDOWN : <nl> - handleStateNormal ( endpoint ) ; <nl> + handleStateNormal ( endpoint , VersionedValue . SHUTDOWN ) ; <nl> break ; <nl> case VersionedValue . REMOVING _ TOKEN : <nl> case VersionedValue . REMOVED _ TOKEN : <nl> @ @ - 1738 , 7 + 1742 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> private void updatePeerInfo ( InetAddress endpoint ) <nl> { <nl> EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; <nl> - for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . getApplicationStateMap ( ) . entrySet ( ) ) <nl> + for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . states ( ) ) <nl> { <nl> switch ( entry . getKey ( ) ) <nl> { <nl> @ @ - 1771 , 12 + 1775 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> } <nl> <nl> - private byte [ ] getApplicationStateValue ( InetAddress endpoint , ApplicationState appstate ) <nl> - { <nl> - String vvalue = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( appstate ) . value ; <nl> - return vvalue . getBytes ( ISO _ 8859 _ 1 ) ; <nl> - } <nl> - <nl> private void notifyRpcChange ( InetAddress endpoint , boolean ready ) <nl> { <nl> if ( ready ) <nl> @ @ - 1846 , 7 + 1844 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> try <nl> { <nl> - return TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( getApplicationStateValue ( endpoint , ApplicationState . TOKENS ) ) ) ) ; <nl> + EndpointState state = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; <nl> + if ( state = = null ) <nl> + return Collections . emptyList ( ) ; <nl> + <nl> + VersionedValue versionedValue = state . getApplicationState ( ApplicationState . TOKENS ) ; <nl> + if ( versionedValue = = null ) <nl> + return Collections . emptyList ( ) ; <nl> + <nl> + return TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( versionedValue . toBytes ( ) ) ) ) ; <nl> } <nl> catch ( IOException e ) <nl> { <nl> @ @ - 1895 , 22 + 1901 , 23 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * <nl> * @ param endpoint node <nl> * / <nl> - private void handleStateNormal ( final InetAddress endpoint ) <nl> + private void handleStateNormal ( final InetAddress endpoint , final String status ) <nl> { <nl> - Collection < Token > tokens ; <nl> - <nl> - tokens = getTokensFor ( endpoint ) ; <nl> - <nl> + Collection < Token > tokens = getTokensFor ( endpoint ) ; <nl> Set < Token > tokensToUpdateInMetadata = new HashSet < > ( ) ; <nl> Set < Token > tokensToUpdateInSystemKeyspace = new HashSet < > ( ) ; <nl> Set < InetAddress > endpointsToRemove = new HashSet < > ( ) ; <nl> <nl> - <nl> if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " Node { } state normal , token { } " , endpoint , tokens ) ; <nl> + logger . debug ( " Node { } state { } , token { } " , endpoint , status , tokens ) ; <nl> <nl> if ( tokenMetadata . isMember ( endpoint ) ) <nl> - logger . info ( " Node { } state jump to normal " , endpoint ) ; <nl> + logger . info ( " Node { } state jump to { } " , endpoint , status ) ; <nl> + <nl> + if ( tokens . isEmpty ( ) & & status . equals ( VersionedValue . STATUS _ NORMAL ) ) <nl> + logger . error ( " Node { } is in state normal but it has no tokens , state : { } " , <nl> + endpoint , <nl> + Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ) ; <nl> <nl> updatePeerInfo ( endpoint ) ; <nl> / / Order Matters , TM . updateHostID ( ) should be called before TM . updateNormalToken ( ) , ( see CASSANDRA - 4300 ) . <nl> @ @ - 2021 , 8 + 2028 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * / <nl> private void handleStateLeaving ( InetAddress endpoint ) <nl> { <nl> - Collection < Token > tokens ; <nl> - tokens = getTokensFor ( endpoint ) ; <nl> + Collection < Token > tokens = getTokensFor ( endpoint ) ; <nl> <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Node { } state leaving , tokens { } " , endpoint , tokens ) ; <nl> @ @ - 2056 , 16 + 2062 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> private void handleStateLeft ( InetAddress endpoint , String [ ] pieces ) <nl> { <nl> assert pieces . length > = 2 ; <nl> - Collection < Token > tokens = null ; <nl> - try <nl> - { <nl> - tokens = getTokensFor ( endpoint ) ; <nl> - } <nl> - catch ( Throwable th ) <nl> - { <nl> - JVMStabilityInspector . inspectThrowable ( th ) ; <nl> - logger . warn ( " Unable to calculate tokens for { } . " , endpoint ) ; <nl> - } <nl> + Collection < Token > tokens = getTokensFor ( endpoint ) ; <nl> <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Node { } state left , tokens { } " , endpoint , tokens ) ; <nl> @ @ - 2154 , 7 + 2151 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> HintedHandOffManager . instance . deleteHintsForEndpoint ( endpoint ) ; <nl> removeEndpoint ( endpoint ) ; <nl> tokenMetadata . removeEndpoint ( endpoint ) ; <nl> - if ( tokens ! = null ) <nl> + if ( ! tokens . isEmpty ( ) ) <nl> tokenMetadata . removeBootstrapTokens ( tokens ) ; <nl> <nl> notifyLeft ( endpoint ) ; <nl> @ @ - 2358 , 7 + 2355 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public void onJoin ( InetAddress endpoint , EndpointState epState ) <nl> { <nl> - for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . getApplicationStateMap ( ) . entrySet ( ) ) <nl> + for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . states ( ) ) <nl> { <nl> onChange ( endpoint , entry . getKey ( ) , entry . getValue ( ) ) ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / gms / EndpointStateTest . java b / test / unit / org / apache / cassandra / gms / EndpointStateTest . java <nl> new file mode 100644 <nl> index 0000000 . . b06c435 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / gms / EndpointStateTest . java <nl> @ @ - 0 , 0 + 1 , 159 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . gms ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . EnumMap ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + import java . util . UUID ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . dht . Token ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + public class EndpointStateTest <nl> + { <nl> + public volatile VersionedValue . VersionedValueFactory valueFactory = <nl> + new VersionedValue . VersionedValueFactory ( DatabaseDescriptor . getPartitioner ( ) ) ; <nl> + <nl> + @ Test <nl> + public void testMultiThreadedReadConsistency ( ) throws InterruptedException <nl> + { <nl> + for ( int i = 0 ; i < 500 ; i + + ) <nl> + innerTestMultiThreadedReadConsistency ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Test that a thread reading values whilst they are updated by another thread will <nl> + * not see an entry unless it sees the entry previously added as well , even though <nl> + * we are accessing the map via an iterator backed by the underlying map . This <nl> + * works because EndpointState copies the map each time values are added . <nl> + * / <nl> + private void innerTestMultiThreadedReadConsistency ( ) throws InterruptedException <nl> + { <nl> + final Token token = DatabaseDescriptor . getPartitioner ( ) . getRandomToken ( ) ; <nl> + final List < Token > tokens = Collections . singletonList ( token ) ; <nl> + final HeartBeatState hb = new HeartBeatState ( 0 ) ; <nl> + final EndpointState state = new EndpointState ( hb ) ; <nl> + final AtomicInteger numFailures = new AtomicInteger ( ) ; <nl> + <nl> + Thread t1 = new Thread ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + state . addApplicationState ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; <nl> + state . addApplicationState ( ApplicationState . STATUS , valueFactory . normal ( tokens ) ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + Thread t2 = new Thread ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + for ( int i = 0 ; i < 50 ; i + + ) <nl> + { <nl> + Map < ApplicationState , VersionedValue > values = new EnumMap < > ( ApplicationState . class ) ; <nl> + for ( Map . Entry < ApplicationState , VersionedValue > entry : state . states ( ) ) <nl> + values . put ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + <nl> + if ( values . containsKey ( ApplicationState . STATUS ) & & ! values . containsKey ( ApplicationState . TOKENS ) ) <nl> + { <nl> + numFailures . incrementAndGet ( ) ; <nl> + System . out . println ( String . format ( " Failed : % s " , values ) ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + t1 . start ( ) ; <nl> + t2 . start ( ) ; <nl> + <nl> + t1 . join ( ) ; <nl> + t2 . join ( ) ; <nl> + <nl> + assertTrue ( numFailures . get ( ) = = 0 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testMultiThreadWriteConsistency ( ) throws InterruptedException <nl> + { <nl> + for ( int i = 0 ; i < 500 ; i + + ) <nl> + innerTestMultiThreadWriteConsistency ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Test that two threads can update the state map concurrently . <nl> + * / <nl> + private void innerTestMultiThreadWriteConsistency ( ) throws InterruptedException <nl> + { <nl> + final Token token = DatabaseDescriptor . getPartitioner ( ) . getRandomToken ( ) ; <nl> + final List < Token > tokens = Collections . singletonList ( token ) ; <nl> + final String ip = " 127 . 0 . 0 . 1 " ; <nl> + final UUID hostId = UUID . randomUUID ( ) ; <nl> + final HeartBeatState hb = new HeartBeatState ( 0 ) ; <nl> + final EndpointState state = new EndpointState ( hb ) ; <nl> + <nl> + Thread t1 = new Thread ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; <nl> + states . put ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; <nl> + states . put ( ApplicationState . STATUS , valueFactory . normal ( tokens ) ) ; <nl> + state . addApplicationStates ( states ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + Thread t2 = new Thread ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; <nl> + states . put ( ApplicationState . INTERNAL _ IP , valueFactory . internalIP ( ip ) ) ; <nl> + states . put ( ApplicationState . HOST _ ID , valueFactory . hostId ( hostId ) ) ; <nl> + state . addApplicationStates ( states ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + t1 . start ( ) ; <nl> + t2 . start ( ) ; <nl> + <nl> + t1 . join ( ) ; <nl> + t2 . join ( ) ; <nl> + <nl> + Set < Map . Entry < ApplicationState , VersionedValue > > states = state . states ( ) ; <nl> + assertEquals ( 4 , states . size ( ) ) ; <nl> + <nl> + Map < ApplicationState , VersionedValue > values = new EnumMap < > ( ApplicationState . class ) ; <nl> + for ( Map . Entry < ApplicationState , VersionedValue > entry : states ) <nl> + values . put ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + <nl> + assertTrue ( values . containsKey ( ApplicationState . STATUS ) ) ; <nl> + assertTrue ( values . containsKey ( ApplicationState . TOKENS ) ) ; <nl> + assertTrue ( values . containsKey ( ApplicationState . INTERNAL _ IP ) ) ; <nl> + assertTrue ( values . containsKey ( ApplicationState . HOST _ ID ) ) ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / locator / CloudstackSnitchTest . java b / test / unit / org / apache / cassandra / locator / CloudstackSnitchTest . java <nl> index d9a4ef1 . . 90e63e0 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / CloudstackSnitchTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / CloudstackSnitchTest . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . locator ; <nl> <nl> import java . io . IOException ; <nl> import java . net . InetAddress ; <nl> + import java . util . EnumMap ; <nl> import java . util . Map ; <nl> <nl> import org . junit . AfterClass ; <nl> @ @ - 77 , 9 + 78 , 10 @ @ public class CloudstackSnitchTest <nl> InetAddress nonlocal = InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ; <nl> <nl> Gossiper . instance . addSavedEndpoint ( nonlocal ) ; <nl> - Map < ApplicationState , VersionedValue > stateMap = Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . getApplicationStateMap ( ) ; <nl> + Map < ApplicationState , VersionedValue > stateMap = new EnumMap < > ( ApplicationState . class ) ; <nl> stateMap . put ( ApplicationState . DC , StorageService . instance . valueFactory . datacenter ( " ch - zrh " ) ) ; <nl> stateMap . put ( ApplicationState . RACK , StorageService . instance . valueFactory . rack ( " 2 " ) ) ; <nl> + Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . addApplicationStates ( stateMap ) ; <nl> <nl> assertEquals ( " ch - zrh " , snitch . getDatacenter ( nonlocal ) ) ; <nl> assertEquals ( " 2 " , snitch . getRack ( nonlocal ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / locator / EC2SnitchTest . java b / test / unit / org / apache / cassandra / locator / EC2SnitchTest . java <nl> index 6015adf . . 56bbb77 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / EC2SnitchTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / EC2SnitchTest . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ package org . apache . cassandra . locator ; <nl> import java . io . IOException ; <nl> import java . net . InetAddress ; <nl> import java . net . UnknownHostException ; <nl> + import java . util . EnumMap ; <nl> import java . util . Map ; <nl> <nl> import org . junit . AfterClass ; <nl> @ @ - 79 , 9 + 80 , 10 @ @ public class EC2SnitchTest <nl> InetAddress nonlocal = InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ; <nl> <nl> Gossiper . instance . addSavedEndpoint ( nonlocal ) ; <nl> - Map < ApplicationState , VersionedValue > stateMap = Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . getApplicationStateMap ( ) ; <nl> + Map < ApplicationState , VersionedValue > stateMap = new EnumMap < > ( ApplicationState . class ) ; <nl> stateMap . put ( ApplicationState . DC , StorageService . instance . valueFactory . datacenter ( " us - west " ) ) ; <nl> stateMap . put ( ApplicationState . RACK , StorageService . instance . valueFactory . datacenter ( " 1a " ) ) ; <nl> + Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . addApplicationStates ( stateMap ) ; <nl> <nl> assertEquals ( " us - west " , snitch . getDatacenter ( nonlocal ) ) ; <nl> assertEquals ( " 1a " , snitch . getRack ( nonlocal ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / locator / GoogleCloudSnitchTest . java b / test / unit / org / apache / cassandra / locator / GoogleCloudSnitchTest . java <nl> index 54ea722 . . 1521454 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / GoogleCloudSnitchTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / GoogleCloudSnitchTest . java <nl> @ @ - 23 , 6 + 23 , 7 @ @ package org . apache . cassandra . locator ; <nl> <nl> import java . io . IOException ; <nl> import java . net . InetAddress ; <nl> + import java . util . EnumMap ; <nl> import java . util . Map ; <nl> <nl> import org . junit . AfterClass ; <nl> @ @ - 75 , 9 + 76 , 10 @ @ public class GoogleCloudSnitchTest <nl> InetAddress nonlocal = InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ; <nl> <nl> Gossiper . instance . addSavedEndpoint ( nonlocal ) ; <nl> - Map < ApplicationState , VersionedValue > stateMap = Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . getApplicationStateMap ( ) ; <nl> + Map < ApplicationState , VersionedValue > stateMap = new EnumMap < > ( ApplicationState . class ) ; <nl> stateMap . put ( ApplicationState . DC , StorageService . instance . valueFactory . datacenter ( " europe - west1 " ) ) ; <nl> stateMap . put ( ApplicationState . RACK , StorageService . instance . valueFactory . datacenter ( " a " ) ) ; <nl> + Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . addApplicationStates ( stateMap ) ; <nl> <nl> assertEquals ( " europe - west1 " , snitch . getDatacenter ( nonlocal ) ) ; <nl> assertEquals ( " a " , snitch . getRack ( nonlocal ) ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / gms / EndpointState . java b / src / java / org / apache / cassandra / gms / EndpointState . java 
 index 0e6985a . . 931da8d 100644 
 - - - a / src / java / org / apache / cassandra / gms / EndpointState . java 
 + + + b / src / java / org / apache / cassandra / gms / EndpointState . java 
 @ @ - 18 , 7 + 18 , 11 @ @ 
 package org . apache . cassandra . gms ; 
 
 import java . io . * ; 
 + import java . util . Collections ; 
 + import java . util . EnumMap ; 
 import java . util . Map ; 
 + import java . util . Set ; 
 + import java . util . concurrent . atomic . AtomicReference ; 
 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 @ @ - 27 , 8 + 31 , 6 @ @ import org . apache . cassandra . db . TypeSizes ; 
 import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 
 - import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; 
 - 
 / * * 
 * This abstraction represents both the HeartBeatState and the ApplicationState in an EndpointState 
 * instance . Any state for a given endpoint can be retrieved from this instance . 
 @ @ - 42 , 7 + 44 , 7 @ @ public class EndpointState 
 public final static IVersionedSerializer < EndpointState > serializer = new EndpointStateSerializer ( ) ; 
 
 private volatile HeartBeatState hbState ; 
 - final Map < ApplicationState , VersionedValue > applicationState = new NonBlockingHashMap < ApplicationState , VersionedValue > ( ) ; 
 + private final AtomicReference < Map < ApplicationState , VersionedValue > > applicationState ; 
 
 / * fields below do not get serialized * / 
 private volatile long updateTimestamp ; 
 @ @ - 50 , 7 + 52 , 13 @ @ public class EndpointState 
 
 EndpointState ( HeartBeatState initialHbState ) 
 { 
 + this ( initialHbState , new EnumMap < ApplicationState , VersionedValue > ( ApplicationState . class ) ) ; 
 + } 
 + 
 + EndpointState ( HeartBeatState initialHbState , Map < ApplicationState , VersionedValue > states ) 
 + { 
 hbState = initialHbState ; 
 + applicationState = new AtomicReference < Map < ApplicationState , VersionedValue > > ( new EnumMap < > ( states ) ) ; 
 updateTimestamp = System . nanoTime ( ) ; 
 isAlive = true ; 
 } 
 @ @ - 68 , 21 + 76 , 37 @ @ public class EndpointState 
 
 public VersionedValue getApplicationState ( ApplicationState key ) 
 { 
 - return applicationState . get ( key ) ; 
 + return applicationState . get ( ) . get ( key ) ; 
 } 
 
 - / * * 
 - * TODO replace this with operations that don ' t expose private state 
 - * / 
 - @ Deprecated 
 - public Map < ApplicationState , VersionedValue > getApplicationStateMap ( ) 
 + public Set < Map . Entry < ApplicationState , VersionedValue > > states ( ) 
 + { 
 + return applicationState . get ( ) . entrySet ( ) ; 
 + } 
 + 
 + public void addApplicationState ( ApplicationState key , VersionedValue value ) 
 { 
 - return applicationState ; 
 + addApplicationStates ( Collections . singletonMap ( key , value ) ) ; 
 } 
 
 - void addApplicationState ( ApplicationState key , VersionedValue value ) 
 + public void addApplicationStates ( Map < ApplicationState , VersionedValue > values ) 
 { 
 - applicationState . put ( key , value ) ; 
 + addApplicationStates ( values . entrySet ( ) ) ; 
 + } 
 + 
 + public void addApplicationStates ( Set < Map . Entry < ApplicationState , VersionedValue > > values ) 
 + { 
 + while ( true ) 
 + { 
 + Map < ApplicationState , VersionedValue > orig = applicationState . get ( ) ; 
 + Map < ApplicationState , VersionedValue > copy = new EnumMap < > ( orig ) ; 
 + 
 + for ( Map . Entry < ApplicationState , VersionedValue > value : values ) 
 + copy . put ( value . getKey ( ) , value . getValue ( ) ) ; 
 + 
 + if ( applicationState . compareAndSet ( orig , copy ) ) 
 + return ; 
 + } 
 } 
 
 / * getters and setters * / 
 @ @ - 133 , 7 + 157 , 7 @ @ public class EndpointState 
 
 public String toString ( ) 
 { 
 - return " EndpointState : HeartBeatState = " + hbState + " , AppStateMap = " + applicationState ; 
 + return " EndpointState : HeartBeatState = " + hbState + " , AppStateMap = " + applicationState . get ( ) ; 
 } 
 } 
 
 @ @ - 146 , 12 + 170 , 12 @ @ class EndpointStateSerializer implements IVersionedSerializer < EndpointState > 
 HeartBeatState . serializer . serialize ( hbState , out , version ) ; 
 
 / * serialize the map of ApplicationState objects * / 
 - int size = epState . applicationState . size ( ) ; 
 - out . writeInt ( size ) ; 
 - for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . applicationState . entrySet ( ) ) 
 + Set < Map . Entry < ApplicationState , VersionedValue > > states = epState . states ( ) ; 
 + out . writeInt ( states . size ( ) ) ; 
 + for ( Map . Entry < ApplicationState , VersionedValue > state : states ) 
 { 
 - VersionedValue value = entry . getValue ( ) ; 
 - out . writeInt ( entry . getKey ( ) . ordinal ( ) ) ; 
 + VersionedValue value = state . getValue ( ) ; 
 + out . writeInt ( state . getKey ( ) . ordinal ( ) ) ; 
 VersionedValue . serializer . serialize ( value , out , version ) ; 
 } 
 } 
 @ @ - 159 , 26 + 183 , 28 @ @ class EndpointStateSerializer implements IVersionedSerializer < EndpointState > 
 public EndpointState deserialize ( DataInput in , int version ) throws IOException 
 { 
 HeartBeatState hbState = HeartBeatState . serializer . deserialize ( in , version ) ; 
 - EndpointState epState = new EndpointState ( hbState ) ; 
 
 int appStateSize = in . readInt ( ) ; 
 + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; 
 for ( int i = 0 ; i < appStateSize ; + + i ) 
 { 
 int key = in . readInt ( ) ; 
 VersionedValue value = VersionedValue . serializer . deserialize ( in , version ) ; 
 - epState . addApplicationState ( Gossiper . STATES [ key ] , value ) ; 
 + states . put ( Gossiper . STATES [ key ] , value ) ; 
 } 
 - return epState ; 
 + 
 + return new EndpointState ( hbState , states ) ; 
 } 
 
 public long serializedSize ( EndpointState epState , int version ) 
 { 
 long size = HeartBeatState . serializer . serializedSize ( epState . getHeartBeatState ( ) , version ) ; 
 - size + = TypeSizes . NATIVE . sizeof ( epState . applicationState . size ( ) ) ; 
 - for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . applicationState . entrySet ( ) ) 
 + Set < Map . Entry < ApplicationState , VersionedValue > > states = epState . states ( ) ; 
 + size + = TypeSizes . NATIVE . sizeof ( states . size ( ) ) ; 
 + for ( Map . Entry < ApplicationState , VersionedValue > state : states ) 
 { 
 - VersionedValue value = entry . getValue ( ) ; 
 - size + = TypeSizes . NATIVE . sizeof ( entry . getKey ( ) . ordinal ( ) ) ; 
 + VersionedValue value = state . getValue ( ) ; 
 + size + = TypeSizes . NATIVE . sizeof ( state . getKey ( ) . ordinal ( ) ) ; 
 size + = VersionedValue . serializer . serializedSize ( value , version ) ; 
 } 
 return size ; 
 diff - - git a / src / java / org / apache / cassandra / gms / FailureDetector . java b / src / java / org / apache / cassandra / gms / FailureDetector . java 
 index c563872 . . a0754b1 100644 
 - - - a / src / java / org / apache / cassandra / gms / FailureDetector . java 
 + + + b / src / java / org / apache / cassandra / gms / FailureDetector . java 
 @ @ - 192 , 15 + 192 , 16 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean 
 { 
 sb . append ( " generation : " ) . append ( endpointState . getHeartBeatState ( ) . getGeneration ( ) ) . append ( " \ n " ) ; 
 sb . append ( " heartbeat : " ) . append ( endpointState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ) . append ( " \ n " ) ; 
 - for ( Map . Entry < ApplicationState , VersionedValue > state : endpointState . applicationState . entrySet ( ) ) 
 + for ( Map . Entry < ApplicationState , VersionedValue > state : endpointState . states ( ) ) 
 { 
 if ( state . getKey ( ) = = ApplicationState . TOKENS ) 
 continue ; 
 sb . append ( " " ) . append ( state . getKey ( ) ) . append ( " : " ) . append ( state . getValue ( ) . version ) . append ( " : " ) . append ( state . getValue ( ) . value ) . append ( " \ n " ) ; 
 } 
 - if ( endpointState . applicationState . containsKey ( ApplicationState . TOKENS ) ) 
 + VersionedValue tokens = endpointState . getApplicationState ( ApplicationState . TOKENS ) ; 
 + if ( tokens ! = null ) 
 { 
 - sb . append ( " TOKENS : " ) . append ( endpointState . applicationState . get ( ApplicationState . TOKENS ) . version ) . append ( " : < hidden > \ n " ) ; 
 + sb . append ( " TOKENS : " ) . append ( tokens . version ) . append ( " : < hidden > \ n " ) ; 
 } 
 else 
 { 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index f78dc7a . . 86fdab2 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 224 , 7 + 224 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 return true ; 
 try 
 { 
 - if ( entry . getValue ( ) . getApplicationStateMap ( ) . containsKey ( ApplicationState . INTERNAL _ IP ) & & seeds . contains ( InetAddress . getByName ( entry . getValue ( ) . getApplicationState ( ApplicationState . INTERNAL _ IP ) . value ) ) ) 
 + VersionedValue internalIp = entry . getValue ( ) . getApplicationState ( ApplicationState . INTERNAL _ IP ) ; 
 + if ( internalIp ! = null & & seeds . contains ( InetAddress . getByName ( internalIp . value ) ) ) 
 return true ; 
 } 
 catch ( UnknownHostException e ) 
 @ @ - 371 , 8 + 372 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 int getMaxEndpointStateVersion ( EndpointState epState ) 
 { 
 int maxVersion = epState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ; 
 - for ( VersionedValue value : epState . getApplicationStateMap ( ) . values ( ) ) 
 - maxVersion = Math . max ( maxVersion , value . version ) ; 
 + for ( Map . Entry < ApplicationState , VersionedValue > state : epState . states ( ) ) 
 + maxVersion = Math . max ( maxVersion , state . getValue ( ) . version ) ; 
 return maxVersion ; 
 } 
 
 @ @ - 525 , 8 + 526 , 10 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 logger . info ( " Advertising removal for { } " , endpoint ) ; 
 epState . updateTimestamp ( ) ; / / make sure we don ' t evict it too soon 
 epState . getHeartBeatState ( ) . forceNewerGenerationUnsafe ( ) ; 
 - epState . addApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . removingNonlocal ( hostId ) ) ; 
 - epState . addApplicationState ( ApplicationState . REMOVAL _ COORDINATOR , StorageService . instance . valueFactory . removalCoordinator ( localHostId ) ) ; 
 + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; 
 + states . put ( ApplicationState . STATUS , StorageService . instance . valueFactory . removingNonlocal ( hostId ) ) ; 
 + states . put ( ApplicationState . REMOVAL _ COORDINATOR , StorageService . instance . valueFactory . removalCoordinator ( localHostId ) ) ; 
 + epState . addApplicationStates ( states ) ; 
 endpointStateMap . put ( endpoint , epState ) ; 
 } 
 
 @ @ - 853 , 7 + 856 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 logger . trace ( " local heartbeat version { } greater than { } for { } " , localHbVersion , version , forEndpoint ) ; 
 } 
 / * Accumulate all application states whose versions are greater than " version " variable * / 
 - for ( Entry < ApplicationState , VersionedValue > entry : epState . getApplicationStateMap ( ) . entrySet ( ) ) 
 + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; 
 + for ( Entry < ApplicationState , VersionedValue > entry : epState . states ( ) ) 
 { 
 VersionedValue value = entry . getValue ( ) ; 
 if ( value . version > version ) 
 @ @ - 865 , 9 + 869 , 11 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 final ApplicationState key = entry . getKey ( ) ; 
 if ( logger . isTraceEnabled ( ) ) 
 logger . trace ( " Adding state { } : { } " , key , value . value ) ; 
 - reqdEndpointState . addApplicationState ( key , value ) ; 
 + 
 + states . put ( key , value ) ; 
 } 
 } 
 + reqdEndpointState . addApplicationStates ( states ) ; 
 } 
 return reqdEndpointState ; 
 } 
 @ @ - 1147 , 19 + 1153 , 13 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 localState . setHeartBeatState ( remoteState . getHeartBeatState ( ) ) ; 
 if ( logger . isTraceEnabled ( ) ) 
 logger . trace ( " Updating heartbeat state version to { } from { } for { } . . . " , localState . getHeartBeatState ( ) . getHeartBeatVersion ( ) , oldVersion , addr ) ; 
 - / / we need to make two loops here , one to apply , then another to notify , this way all states in an update are present and current when the notifications are received 
 - for ( Entry < ApplicationState , VersionedValue > remoteEntry : remoteState . getApplicationStateMap ( ) . entrySet ( ) ) 
 - { 
 - ApplicationState remoteKey = remoteEntry . getKey ( ) ; 
 - VersionedValue remoteValue = remoteEntry . getValue ( ) ; 
 
 - assert remoteState . getHeartBeatState ( ) . getGeneration ( ) = = localState . getHeartBeatState ( ) . getGeneration ( ) ; 
 - localState . addApplicationState ( remoteKey , remoteValue ) ; 
 - } 
 - for ( Entry < ApplicationState , VersionedValue > remoteEntry : remoteState . getApplicationStateMap ( ) . entrySet ( ) ) 
 - { 
 + Set < Entry < ApplicationState , VersionedValue > > remoteStates = remoteState . states ( ) ; 
 + assert remoteState . getHeartBeatState ( ) . getGeneration ( ) = = localState . getHeartBeatState ( ) . getGeneration ( ) ; 
 + localState . addApplicationStates ( remoteStates ) ; 
 + 
 + for ( Entry < ApplicationState , VersionedValue > remoteEntry : remoteStates ) 
 doOnChangeNotifications ( addr , remoteEntry . getKey ( ) , remoteEntry . getValue ( ) ) ; 
 - } 
 } 
 
 / / notify that a local application state is going to change ( doesn ' t get triggered for remote changes ) 
 @ @ - 1273 , 7 + 1273 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 
 public void start ( int generationNumber ) 
 { 
 - start ( generationNumber , new HashMap < ApplicationState , VersionedValue > ( ) ) ; 
 + start ( generationNumber , new EnumMap < ApplicationState , VersionedValue > ( ApplicationState . class ) ) ; 
 } 
 
 / * * 
 @ @ - 1285 , 8 + 1285 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 / * initialize the heartbeat state for this localEndpoint * / 
 maybeInitializeLocalState ( generationNbr ) ; 
 EndpointState localState = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; 
 - for ( Map . Entry < ApplicationState , VersionedValue > entry : preloadLocalStates . entrySet ( ) ) 
 - localState . addApplicationState ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + localState . addApplicationStates ( preloadLocalStates ) ; 
 
 / / notify snitches that Gossiper is about to start 
 DatabaseDescriptor . getEndpointSnitch ( ) . gossiperStarting ( ) ; 
 @ @ - 1475 , 8 + 1474 , 10 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 EndpointState localState = oldState = = null ? newState : oldState ; 
 
 / / always add the version state 
 - localState . addApplicationState ( ApplicationState . NET _ VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; 
 - localState . addApplicationState ( ApplicationState . HOST _ ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; 
 + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; 
 + states . put ( ApplicationState . NET _ VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; 
 + states . put ( ApplicationState . HOST _ ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; 
 + localState . addApplicationStates ( states ) ; 
 } 
 
 @ VisibleForTesting 
 diff - - git a / src / java / org / apache / cassandra / gms / VersionedValue . java b / src / java / org / apache / cassandra / gms / VersionedValue . java 
 index a142f41 . . 3ea7bb4 100644 
 - - - a / src / java / org / apache / cassandra / gms / VersionedValue . java 
 + + + b / src / java / org / apache / cassandra / gms / VersionedValue . java 
 @ @ - 109 , 6 + 109 , 11 @ @ public class VersionedValue implements Comparable < VersionedValue > 
 return " Value ( " + value + " , " + version + " ) " ; 
 } 
 
 + public byte [ ] toBytes ( ) 
 + { 
 + return value . getBytes ( ISO _ 8859 _ 1 ) ; 
 + } 
 + 
 private static String versionString ( String . . . args ) 
 { 
 return StringUtils . join ( args , VersionedValue . DELIMITER ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index ad209fc . . 3ea261e 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 + import java . util . EnumMap ; 
 import java . util . HashMap ; 
 import java . util . HashSet ; 
 import java . util . Iterator ; 
 @ @ - 521 , 9 + 522 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 hostId = Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ; 
 try 
 { 
 - if ( Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) . getApplicationState ( ApplicationState . TOKENS ) = = null ) 
 + VersionedValue tokensVersionedValue = Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) . getApplicationState ( ApplicationState . TOKENS ) ; 
 + if ( tokensVersionedValue = = null ) 
 throw new RuntimeException ( " Could not find tokens for " + DatabaseDescriptor . getReplaceAddress ( ) + " to replace " ) ; 
 - Collection < Token > tokens = TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( getApplicationStateValue ( DatabaseDescriptor . getReplaceAddress ( ) , ApplicationState . TOKENS ) ) ) ) ; 
 + Collection < Token > tokens = TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( tokensVersionedValue . toBytes ( ) ) ) ) ; 
 
 SystemKeyspace . setLocalHostId ( hostId ) ; / / use the replacee ' s host Id as our own so we receive hints , etc 
 Gossiper . instance . resetEndpointStateMap ( ) ; / / clean up since we have what we need 
 @ @ - 740 , 7 + 742 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 if ( ! joined ) 
 { 
 - Map < ApplicationState , VersionedValue > appStates = new HashMap < > ( ) ; 
 + Map < ApplicationState , VersionedValue > appStates = new EnumMap < > ( ApplicationState . class ) ; 
 
 if ( replacing & & ! ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) ) 
 throw new ConfigurationException ( " Cannot set both join _ ring = false and attempt to replace a node " ) ; 
 @ @ - 1655 , 8 + 1657 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 handleStateBootstrap ( endpoint ) ; 
 break ; 
 case VersionedValue . STATUS _ NORMAL : 
 + handleStateNormal ( endpoint , VersionedValue . STATUS _ NORMAL ) ; 
 + break ; 
 case VersionedValue . SHUTDOWN : 
 - handleStateNormal ( endpoint ) ; 
 + handleStateNormal ( endpoint , VersionedValue . SHUTDOWN ) ; 
 break ; 
 case VersionedValue . REMOVING _ TOKEN : 
 case VersionedValue . REMOVED _ TOKEN : 
 @ @ - 1738 , 7 + 1742 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 private void updatePeerInfo ( InetAddress endpoint ) 
 { 
 EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; 
 - for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . getApplicationStateMap ( ) . entrySet ( ) ) 
 + for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . states ( ) ) 
 { 
 switch ( entry . getKey ( ) ) 
 { 
 @ @ - 1771 , 12 + 1775 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 } 
 
 - private byte [ ] getApplicationStateValue ( InetAddress endpoint , ApplicationState appstate ) 
 - { 
 - String vvalue = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( appstate ) . value ; 
 - return vvalue . getBytes ( ISO _ 8859 _ 1 ) ; 
 - } 
 - 
 private void notifyRpcChange ( InetAddress endpoint , boolean ready ) 
 { 
 if ( ready ) 
 @ @ - 1846 , 7 + 1844 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 try 
 { 
 - return TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( getApplicationStateValue ( endpoint , ApplicationState . TOKENS ) ) ) ) ; 
 + EndpointState state = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; 
 + if ( state = = null ) 
 + return Collections . emptyList ( ) ; 
 + 
 + VersionedValue versionedValue = state . getApplicationState ( ApplicationState . TOKENS ) ; 
 + if ( versionedValue = = null ) 
 + return Collections . emptyList ( ) ; 
 + 
 + return TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( versionedValue . toBytes ( ) ) ) ) ; 
 } 
 catch ( IOException e ) 
 { 
 @ @ - 1895 , 22 + 1901 , 23 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * 
 * @ param endpoint node 
 * / 
 - private void handleStateNormal ( final InetAddress endpoint ) 
 + private void handleStateNormal ( final InetAddress endpoint , final String status ) 
 { 
 - Collection < Token > tokens ; 
 - 
 - tokens = getTokensFor ( endpoint ) ; 
 - 
 + Collection < Token > tokens = getTokensFor ( endpoint ) ; 
 Set < Token > tokensToUpdateInMetadata = new HashSet < > ( ) ; 
 Set < Token > tokensToUpdateInSystemKeyspace = new HashSet < > ( ) ; 
 Set < InetAddress > endpointsToRemove = new HashSet < > ( ) ; 
 
 - 
 if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " Node { } state normal , token { } " , endpoint , tokens ) ; 
 + logger . debug ( " Node { } state { } , token { } " , endpoint , status , tokens ) ; 
 
 if ( tokenMetadata . isMember ( endpoint ) ) 
 - logger . info ( " Node { } state jump to normal " , endpoint ) ; 
 + logger . info ( " Node { } state jump to { } " , endpoint , status ) ; 
 + 
 + if ( tokens . isEmpty ( ) & & status . equals ( VersionedValue . STATUS _ NORMAL ) ) 
 + logger . error ( " Node { } is in state normal but it has no tokens , state : { } " , 
 + endpoint , 
 + Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ) ; 
 
 updatePeerInfo ( endpoint ) ; 
 / / Order Matters , TM . updateHostID ( ) should be called before TM . updateNormalToken ( ) , ( see CASSANDRA - 4300 ) . 
 @ @ - 2021 , 8 + 2028 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * / 
 private void handleStateLeaving ( InetAddress endpoint ) 
 { 
 - Collection < Token > tokens ; 
 - tokens = getTokensFor ( endpoint ) ; 
 + Collection < Token > tokens = getTokensFor ( endpoint ) ; 
 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Node { } state leaving , tokens { } " , endpoint , tokens ) ; 
 @ @ - 2056 , 16 + 2062 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 private void handleStateLeft ( InetAddress endpoint , String [ ] pieces ) 
 { 
 assert pieces . length > = 2 ; 
 - Collection < Token > tokens = null ; 
 - try 
 - { 
 - tokens = getTokensFor ( endpoint ) ; 
 - } 
 - catch ( Throwable th ) 
 - { 
 - JVMStabilityInspector . inspectThrowable ( th ) ; 
 - logger . warn ( " Unable to calculate tokens for { } . " , endpoint ) ; 
 - } 
 + Collection < Token > tokens = getTokensFor ( endpoint ) ; 
 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Node { } state left , tokens { } " , endpoint , tokens ) ; 
 @ @ - 2154 , 7 + 2151 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 HintedHandOffManager . instance . deleteHintsForEndpoint ( endpoint ) ; 
 removeEndpoint ( endpoint ) ; 
 tokenMetadata . removeEndpoint ( endpoint ) ; 
 - if ( tokens ! = null ) 
 + if ( ! tokens . isEmpty ( ) ) 
 tokenMetadata . removeBootstrapTokens ( tokens ) ; 
 
 notifyLeft ( endpoint ) ; 
 @ @ - 2358 , 7 + 2355 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public void onJoin ( InetAddress endpoint , EndpointState epState ) 
 { 
 - for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . getApplicationStateMap ( ) . entrySet ( ) ) 
 + for ( Map . Entry < ApplicationState , VersionedValue > entry : epState . states ( ) ) 
 { 
 onChange ( endpoint , entry . getKey ( ) , entry . getValue ( ) ) ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / gms / EndpointStateTest . java b / test / unit / org / apache / cassandra / gms / EndpointStateTest . java 
 new file mode 100644 
 index 0000000 . . b06c435 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / gms / EndpointStateTest . java 
 @ @ - 0 , 0 + 1 , 159 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . gms ; 
 + 
 + import java . util . Collections ; 
 + import java . util . EnumMap ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + import java . util . UUID ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . dht . Token ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + public class EndpointStateTest 
 + { 
 + public volatile VersionedValue . VersionedValueFactory valueFactory = 
 + new VersionedValue . VersionedValueFactory ( DatabaseDescriptor . getPartitioner ( ) ) ; 
 + 
 + @ Test 
 + public void testMultiThreadedReadConsistency ( ) throws InterruptedException 
 + { 
 + for ( int i = 0 ; i < 500 ; i + + ) 
 + innerTestMultiThreadedReadConsistency ( ) ; 
 + } 
 + 
 + / * * 
 + * Test that a thread reading values whilst they are updated by another thread will 
 + * not see an entry unless it sees the entry previously added as well , even though 
 + * we are accessing the map via an iterator backed by the underlying map . This 
 + * works because EndpointState copies the map each time values are added . 
 + * / 
 + private void innerTestMultiThreadedReadConsistency ( ) throws InterruptedException 
 + { 
 + final Token token = DatabaseDescriptor . getPartitioner ( ) . getRandomToken ( ) ; 
 + final List < Token > tokens = Collections . singletonList ( token ) ; 
 + final HeartBeatState hb = new HeartBeatState ( 0 ) ; 
 + final EndpointState state = new EndpointState ( hb ) ; 
 + final AtomicInteger numFailures = new AtomicInteger ( ) ; 
 + 
 + Thread t1 = new Thread ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + state . addApplicationState ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; 
 + state . addApplicationState ( ApplicationState . STATUS , valueFactory . normal ( tokens ) ) ; 
 + } 
 + } ) ; 
 + 
 + Thread t2 = new Thread ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + for ( int i = 0 ; i < 50 ; i + + ) 
 + { 
 + Map < ApplicationState , VersionedValue > values = new EnumMap < > ( ApplicationState . class ) ; 
 + for ( Map . Entry < ApplicationState , VersionedValue > entry : state . states ( ) ) 
 + values . put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + 
 + if ( values . containsKey ( ApplicationState . STATUS ) & & ! values . containsKey ( ApplicationState . TOKENS ) ) 
 + { 
 + numFailures . incrementAndGet ( ) ; 
 + System . out . println ( String . format ( " Failed : % s " , values ) ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + t1 . start ( ) ; 
 + t2 . start ( ) ; 
 + 
 + t1 . join ( ) ; 
 + t2 . join ( ) ; 
 + 
 + assertTrue ( numFailures . get ( ) = = 0 ) ; 
 + } 
 + 
 + @ Test 
 + public void testMultiThreadWriteConsistency ( ) throws InterruptedException 
 + { 
 + for ( int i = 0 ; i < 500 ; i + + ) 
 + innerTestMultiThreadWriteConsistency ( ) ; 
 + } 
 + 
 + / * * 
 + * Test that two threads can update the state map concurrently . 
 + * / 
 + private void innerTestMultiThreadWriteConsistency ( ) throws InterruptedException 
 + { 
 + final Token token = DatabaseDescriptor . getPartitioner ( ) . getRandomToken ( ) ; 
 + final List < Token > tokens = Collections . singletonList ( token ) ; 
 + final String ip = " 127 . 0 . 0 . 1 " ; 
 + final UUID hostId = UUID . randomUUID ( ) ; 
 + final HeartBeatState hb = new HeartBeatState ( 0 ) ; 
 + final EndpointState state = new EndpointState ( hb ) ; 
 + 
 + Thread t1 = new Thread ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; 
 + states . put ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; 
 + states . put ( ApplicationState . STATUS , valueFactory . normal ( tokens ) ) ; 
 + state . addApplicationStates ( states ) ; 
 + } 
 + } ) ; 
 + 
 + Thread t2 = new Thread ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; 
 + states . put ( ApplicationState . INTERNAL _ IP , valueFactory . internalIP ( ip ) ) ; 
 + states . put ( ApplicationState . HOST _ ID , valueFactory . hostId ( hostId ) ) ; 
 + state . addApplicationStates ( states ) ; 
 + } 
 + } ) ; 
 + 
 + t1 . start ( ) ; 
 + t2 . start ( ) ; 
 + 
 + t1 . join ( ) ; 
 + t2 . join ( ) ; 
 + 
 + Set < Map . Entry < ApplicationState , VersionedValue > > states = state . states ( ) ; 
 + assertEquals ( 4 , states . size ( ) ) ; 
 + 
 + Map < ApplicationState , VersionedValue > values = new EnumMap < > ( ApplicationState . class ) ; 
 + for ( Map . Entry < ApplicationState , VersionedValue > entry : states ) 
 + values . put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + 
 + assertTrue ( values . containsKey ( ApplicationState . STATUS ) ) ; 
 + assertTrue ( values . containsKey ( ApplicationState . TOKENS ) ) ; 
 + assertTrue ( values . containsKey ( ApplicationState . INTERNAL _ IP ) ) ; 
 + assertTrue ( values . containsKey ( ApplicationState . HOST _ ID ) ) ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / locator / CloudstackSnitchTest . java b / test / unit / org / apache / cassandra / locator / CloudstackSnitchTest . java 
 index d9a4ef1 . . 90e63e0 100644 
 - - - a / test / unit / org / apache / cassandra / locator / CloudstackSnitchTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / CloudstackSnitchTest . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . locator ; 
 
 import java . io . IOException ; 
 import java . net . InetAddress ; 
 + import java . util . EnumMap ; 
 import java . util . Map ; 
 
 import org . junit . AfterClass ; 
 @ @ - 77 , 9 + 78 , 10 @ @ public class CloudstackSnitchTest 
 InetAddress nonlocal = InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ; 
 
 Gossiper . instance . addSavedEndpoint ( nonlocal ) ; 
 - Map < ApplicationState , VersionedValue > stateMap = Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . getApplicationStateMap ( ) ; 
 + Map < ApplicationState , VersionedValue > stateMap = new EnumMap < > ( ApplicationState . class ) ; 
 stateMap . put ( ApplicationState . DC , StorageService . instance . valueFactory . datacenter ( " ch - zrh " ) ) ; 
 stateMap . put ( ApplicationState . RACK , StorageService . instance . valueFactory . rack ( " 2 " ) ) ; 
 + Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . addApplicationStates ( stateMap ) ; 
 
 assertEquals ( " ch - zrh " , snitch . getDatacenter ( nonlocal ) ) ; 
 assertEquals ( " 2 " , snitch . getRack ( nonlocal ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / locator / EC2SnitchTest . java b / test / unit / org / apache / cassandra / locator / EC2SnitchTest . java 
 index 6015adf . . 56bbb77 100644 
 - - - a / test / unit / org / apache / cassandra / locator / EC2SnitchTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / EC2SnitchTest . java 
 @ @ - 24 , 6 + 24 , 7 @ @ package org . apache . cassandra . locator ; 
 import java . io . IOException ; 
 import java . net . InetAddress ; 
 import java . net . UnknownHostException ; 
 + import java . util . EnumMap ; 
 import java . util . Map ; 
 
 import org . junit . AfterClass ; 
 @ @ - 79 , 9 + 80 , 10 @ @ public class EC2SnitchTest 
 InetAddress nonlocal = InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ; 
 
 Gossiper . instance . addSavedEndpoint ( nonlocal ) ; 
 - Map < ApplicationState , VersionedValue > stateMap = Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . getApplicationStateMap ( ) ; 
 + Map < ApplicationState , VersionedValue > stateMap = new EnumMap < > ( ApplicationState . class ) ; 
 stateMap . put ( ApplicationState . DC , StorageService . instance . valueFactory . datacenter ( " us - west " ) ) ; 
 stateMap . put ( ApplicationState . RACK , StorageService . instance . valueFactory . datacenter ( " 1a " ) ) ; 
 + Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . addApplicationStates ( stateMap ) ; 
 
 assertEquals ( " us - west " , snitch . getDatacenter ( nonlocal ) ) ; 
 assertEquals ( " 1a " , snitch . getRack ( nonlocal ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / locator / GoogleCloudSnitchTest . java b / test / unit / org / apache / cassandra / locator / GoogleCloudSnitchTest . java 
 index 54ea722 . . 1521454 100644 
 - - - a / test / unit / org / apache / cassandra / locator / GoogleCloudSnitchTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / GoogleCloudSnitchTest . java 
 @ @ - 23 , 6 + 23 , 7 @ @ package org . apache . cassandra . locator ; 
 
 import java . io . IOException ; 
 import java . net . InetAddress ; 
 + import java . util . EnumMap ; 
 import java . util . Map ; 
 
 import org . junit . AfterClass ; 
 @ @ - 75 , 9 + 76 , 10 @ @ public class GoogleCloudSnitchTest 
 InetAddress nonlocal = InetAddress . getByName ( " 127 . 0 . 0 . 7 " ) ; 
 
 Gossiper . instance . addSavedEndpoint ( nonlocal ) ; 
 - Map < ApplicationState , VersionedValue > stateMap = Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . getApplicationStateMap ( ) ; 
 + Map < ApplicationState , VersionedValue > stateMap = new EnumMap < > ( ApplicationState . class ) ; 
 stateMap . put ( ApplicationState . DC , StorageService . instance . valueFactory . datacenter ( " europe - west1 " ) ) ; 
 stateMap . put ( ApplicationState . RACK , StorageService . instance . valueFactory . datacenter ( " a " ) ) ; 
 + Gossiper . instance . getEndpointStateForEndpoint ( nonlocal ) . addApplicationStates ( stateMap ) ; 
 
 assertEquals ( " europe - west1 " , snitch . getDatacenter ( nonlocal ) ) ; 
 assertEquals ( " a " , snitch . getRack ( nonlocal ) ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
