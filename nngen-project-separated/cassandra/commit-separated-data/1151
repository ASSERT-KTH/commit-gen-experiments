BLEU SCORE: 0.004321926918459305

TEST MSG: Optimize the way we check if a token is repaired in anticompaction
GENERATED MSG: get token on bootstrap that gives us half of the keys from the most heavily - loaded node . ( the " splits " approach should also be useful for # 342 ; adding it to Thrift is trivial )

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3ce2da6 . . b0f9588 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 12 <nl> + * Optimize the way we check if a token is repaired in anticompaction ( CASSANDRA - 10768 ) <nl> * Add proper error handling to stream receiver ( CASSANDRA - 10774 ) <nl> * Warn or fail when changing cluster topology live ( CASSANDRA - 10243 ) <nl> * Status command in debian / ubuntu init script doesn ' t work ( CASSANDRA - 10213 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index b0ad244 . . 2630ba2 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 1115 , 11 + 1115 , 11 @ @ public class CompactionManager implements CompactionManagerMBean <nl> metrics . beginCompaction ( ci ) ; <nl> try <nl> { <nl> + Range . OrderedRangeContainmentChecker containmentChecker = new Range . OrderedRangeContainmentChecker ( ranges ) ; <nl> while ( iter . hasNext ( ) ) <nl> { <nl> AbstractCompactedRow row = iter . next ( ) ; <nl> - / / if current range from sstable is repaired , save it into the new repaired sstable <nl> - if ( Range . isInRanges ( row . key . getToken ( ) , ranges ) ) <nl> + if ( containmentChecker . contains ( row . key . getToken ( ) ) ) <nl> { <nl> repairedSSTableWriter . append ( row ) ; <nl> repairedKeyCount + + ; <nl> diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java <nl> index 505f1f3 . . 81c92a2 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Range . java <nl> + + + b / src / java / org / apache / cassandra / dht / Range . java <nl> @ @ - 21 , 6 + 21 , 8 @ @ import java . io . Serializable ; <nl> import java . util . * ; <nl> <nl> import org . apache . commons . lang3 . ObjectUtils ; <nl> + <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . RowPosition ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . Pair ; <nl> @ @ - 491 , 4 + 493 , 46 @ @ public class Range < T extends RingPosition < T > > extends AbstractBounds < T > implemen <nl> { <nl> return new Range < T > ( left , newRight ) ; <nl> } <nl> + <nl> + / * * <nl> + * Helper class to check if a token is contained within a given collection of ranges <nl> + * / <nl> + public static class OrderedRangeContainmentChecker <nl> + { <nl> + private final Iterator < Range < Token > > normalizedRangesIterator ; <nl> + private Token lastToken = null ; <nl> + private Range < Token > currentRange ; <nl> + <nl> + public OrderedRangeContainmentChecker ( Collection < Range < Token > > ranges ) <nl> + { <nl> + normalizedRangesIterator = normalize ( ranges ) . iterator ( ) ; <nl> + assert normalizedRangesIterator . hasNext ( ) ; <nl> + currentRange = normalizedRangesIterator . next ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns true if the ranges given in the constructor contains the token , false otherwise . <nl> + * <nl> + * The tokens passed to this method must be in increasing order <nl> + * <nl> + * @ param t token to check , must be larger than or equal to the last token passed <nl> + * @ return true if the token is contained within the ranges given to the constructor . <nl> + * / <nl> + public boolean contains ( Token t ) <nl> + { <nl> + assert lastToken = = null | | lastToken . compareTo ( t ) < = 0 ; <nl> + lastToken = t ; <nl> + while ( true ) <nl> + { <nl> + if ( t . compareTo ( currentRange . left ) < = 0 ) <nl> + return false ; <nl> + else if ( t . compareTo ( currentRange . right ) < = 0 | | currentRange . right . compareTo ( currentRange . left ) < = 0 ) <nl> + return true ; <nl> + <nl> + if ( ! normalizedRangesIterator . hasNext ( ) ) <nl> + return false ; <nl> + currentRange = normalizedRangesIterator . next ( ) ; <nl> + } <nl> + } <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / dht / RangeTest . java b / test / unit / org / apache / cassandra / dht / RangeTest . java <nl> index 906396c . . 1d8123b 100644 <nl> - - - a / test / unit / org / apache / cassandra / dht / RangeTest . java <nl> + + + b / test / unit / org / apache / cassandra / dht / RangeTest . java <nl> @ @ - 19 , 9 + 19 , 15 @ @ <nl> package org . apache . cassandra . dht ; <nl> <nl> import java . nio . ByteBuffer ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> import java . util . HashSet ; <nl> import java . util . List ; <nl> + import java . util . Random ; <nl> import java . util . Set ; <nl> + <nl> + import com . google . common . base . Joiner ; <nl> + <nl> import static java . util . Arrays . asList ; <nl> <nl> import org . apache . commons . lang3 . StringUtils ; <nl> @ @ - 29 , 6 + 35 , 7 @ @ import org . junit . Test ; <nl> <nl> import org . apache . cassandra . db . RowPosition ; <nl> import static org . apache . cassandra . Util . range ; <nl> + import static org . junit . Assert . * ; <nl> <nl> <nl> public class RangeTest <nl> @ @ - 536 , 4 + 543 , 64 @ @ public class RangeTest <nl> expected = asList ( range ( " " , " " ) ) ; <nl> assertNormalize ( input , expected ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testRandomOrderedRangeContainmentChecker ( ) <nl> + { <nl> + Random r = new Random ( ) ; <nl> + for ( int j = 0 ; j < 1000 ; j + + ) <nl> + { <nl> + int numTokens = r . nextInt ( 300 ) + 1 ; <nl> + List < Range < Token > > ranges = new ArrayList < > ( numTokens ) ; <nl> + List < Token > tokens = new ArrayList < > ( 2 * numTokens ) ; <nl> + for ( int i = 0 ; i < 2 * numTokens ; i + + ) <nl> + tokens . add ( t ( r . nextLong ( ) ) ) ; <nl> + <nl> + Collections . sort ( tokens ) ; <nl> + <nl> + for ( int i = 0 ; i < tokens . size ( ) ; i + + ) <nl> + { <nl> + ranges . add ( new Range < > ( tokens . get ( i ) , tokens . get ( i + 1 ) ) ) ; <nl> + i + + ; <nl> + } <nl> + <nl> + List < Token > tokensToTest = new ArrayList < > ( ) ; <nl> + for ( int i = 0 ; i < 10000 ; i + + ) <nl> + tokensToTest . add ( t ( r . nextLong ( ) ) ) ; <nl> + <nl> + tokensToTest . add ( t ( Long . MAX _ VALUE ) ) ; <nl> + tokensToTest . add ( t ( Long . MIN _ VALUE ) ) ; <nl> + tokensToTest . add ( t ( Long . MAX _ VALUE - 1 ) ) ; <nl> + tokensToTest . add ( t ( Long . MIN _ VALUE + 1 ) ) ; <nl> + Collections . sort ( tokensToTest ) ; <nl> + <nl> + Range . OrderedRangeContainmentChecker checker = new Range . OrderedRangeContainmentChecker ( ranges ) ; <nl> + for ( Token t : tokensToTest ) <nl> + { <nl> + if ( checker . contains ( t ) ! = Range . isInRanges ( t , ranges ) ) / / avoid running Joiner . on ( . . ) every iteration <nl> + fail ( String . format ( " This should never flap ! If it does , it is a bug ( ranges = % s , token = % s ) " , Joiner . on ( " , " ) . join ( ranges ) , t ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testBoundariesORCC ( ) <nl> + { <nl> + List < Range < Token > > ranges = asList ( r ( Long . MIN _ VALUE , Long . MIN _ VALUE + 1 ) , r ( Long . MAX _ VALUE - 1 , Long . MAX _ VALUE ) ) ; <nl> + Range . OrderedRangeContainmentChecker checker = new Range . OrderedRangeContainmentChecker ( ranges ) ; <nl> + assertFalse ( checker . contains ( t ( Long . MIN _ VALUE ) ) ) ; <nl> + assertTrue ( checker . contains ( t ( Long . MIN _ VALUE + 1 ) ) ) ; <nl> + assertFalse ( checker . contains ( t ( 0 ) ) ) ; <nl> + assertFalse ( checker . contains ( t ( Long . MAX _ VALUE - 1 ) ) ) ; <nl> + assertTrue ( checker . contains ( t ( Long . MAX _ VALUE ) ) ) ; <nl> + } <nl> + <nl> + private static Range < Token > r ( long left , long right ) <nl> + { <nl> + return new Range < > ( t ( left ) , t ( right ) ) ; <nl> + } <nl> + private static Token t ( long t ) <nl> + { <nl> + return new LongToken ( t ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0ce9ee6 . . 8dfd1f8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 725 , 10 + 725 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> void doCleanup ( SSTableReader sstable ) throws IOException <nl> { <nl> assert sstable ! = null ; <nl> - List < Range > myRanges ; <nl> - Map < EndPoint , List < Range > > endPointtoRangeMap = StorageService . instance ( ) . constructEndPointToRangesMap ( ) ; <nl> - myRanges = endPointtoRangeMap . get ( StorageService . getLocalStorageEndPoint ( ) ) ; <nl> - List < SSTableReader > sstables = doFileAntiCompaction ( Arrays . asList ( sstable ) , myRanges , null ) ; <nl> + List < SSTableReader > sstables = doFileAntiCompaction ( Arrays . asList ( sstable ) , StorageService . instance ( ) . getLocalRanges ( ) , null ) ; <nl> if ( ! sstables . isEmpty ( ) ) <nl> { <nl> assert sstables . size ( ) = = 1 ; <nl> @ @ - 764 , 7 + 761 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> long startTime = System . currentTimeMillis ( ) ; <nl> long totalkeysWritten = 0 ; <nl> <nl> - int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , SSTableReader . getApproximateKeyCount ( sstables ) / 2 ) ; <nl> + int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , ( int ) ( SSTableReader . getApproximateKeyCount ( sstables ) / 2 ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Expected bloom filter size : " + expectedBloomFilterSize ) ; <nl> <nl> @ @ - 844 , 7 + 841 , 8 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> long startTime = System . currentTimeMillis ( ) ; <nl> long totalkeysWritten = 0 ; <nl> <nl> - int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , SSTableReader . getApproximateKeyCount ( sstables ) ) ; <nl> + / / TODO the int cast here is potentially buggy <nl> + int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , ( int ) SSTableReader . getApproximateKeyCount ( sstables ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Expected bloom filter size : " + expectedBloomFilterSize ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / DecoratedKey . java b / src / java / org / apache / cassandra / db / DecoratedKey . java <nl> index 1b9af39 . . b2a72da 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DecoratedKey . java <nl> + + + b / src / java / org / apache / cassandra / db / DecoratedKey . java <nl> @ @ - 24 , 7 + 24 , 7 @ @ import org . apache . cassandra . dht . Token ; <nl> * Represents a decorated key , handy for certain operations <nl> * where just working with strings gets slow . <nl> * / <nl> - public class DecoratedKey < T extends Token > <nl> + public class DecoratedKey < T extends Token > implements Comparable < DecoratedKey > <nl> { <nl> public final T token ; <nl> public final String key ; <nl> @ @ - 32 , 6 + 32 , 7 @ @ public class DecoratedKey < T extends Token > <nl> public DecoratedKey ( T token , String key ) <nl> { <nl> super ( ) ; <nl> + assert key ! = null ; <nl> this . token = token ; <nl> this . key = key ; <nl> } <nl> @ @ - 55 , 20 + 56 , 22 @ @ public class DecoratedKey < T extends Token > <nl> return false ; <nl> if ( getClass ( ) ! = obj . getClass ( ) ) <nl> return false ; <nl> + <nl> DecoratedKey other = ( DecoratedKey ) obj ; <nl> - if ( key = = null ) <nl> - { <nl> - if ( other . key ! = null ) <nl> - return false ; <nl> - } else if ( ! key . equals ( other . key ) ) <nl> - return false ; <nl> + / / either both should be of a class where all tokens are null , or neither <nl> + assert ( token = = null ) = = ( other . token = = null ) ; <nl> if ( token = = null ) <nl> - { <nl> - if ( other . token ! = null ) <nl> - return false ; <nl> - } else if ( ! token . equals ( other . token ) ) <nl> - return false ; <nl> - return true ; <nl> + return key . equals ( other . key ) ; <nl> + return token . equals ( other . token ) & & key . equals ( other . key ) ; <nl> + } <nl> + <nl> + public int compareTo ( DecoratedKey other ) <nl> + { <nl> + assert ( token = = null ) = = ( other . token = = null ) ; <nl> + if ( token = = null ) <nl> + return key . compareTo ( other . key ) ; <nl> + int i = token . compareTo ( other . token ) ; <nl> + return i = = 0 ? key . compareTo ( other . key ) : i ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java <nl> index b61991e . . 5503a8f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Table . java <nl> + + + b / src / java / org / apache / cassandra / db / Table . java <nl> @ @ - 492 , 7 + 492 , 7 @ @ public class Table <nl> } <nl> <nl> / * <nl> - * Get the list of all SSTables on disk . Not safe unless you aquire the CFS readlocks ! <nl> + * Get the list of all SSTables on disk . <nl> * / <nl> public List < SSTableReader > getAllSSTablesOnDisk ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> index 35cab21 . . 9402048 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> @ @ - 41 , 8 + 41 , 10 @ @ import org . apache . cassandra . utils . LogUtil ; <nl> * / <nl> public class BootStrapper implements Runnable <nl> { <nl> + public static final long INITIAL _ DELAY = 30 * 1000 ; / / ms <nl> + <nl> private static Logger logger _ = Logger . getLogger ( BootStrapper . class ) ; <nl> - private static final long INITIAL _ DELAY = 60 * 1000 ; / / ms <nl> + <nl> / * endpoints that need to be bootstrapped * / <nl> protected EndPoint [ ] targets _ = new EndPoint [ 0 ] ; <nl> / * tokens of the nodes being bootstrapped . * / <nl> @ @ - 60 , 10 + 62 , 6 @ @ public class BootStrapper implements Runnable <nl> { <nl> try <nl> { <nl> - / * Initial delay waiting for this node to get a stable endpoint map * / <nl> - Thread . sleep ( INITIAL _ DELAY ) ; <nl> - / * Clone again now so we include all discovered nodes in our calculations * / <nl> - tokenMetadata _ = StorageService . instance ( ) . getTokenMetadata ( ) ; <nl> / / Mark as not bootstrapping to calculate ranges correctly <nl> for ( int i = 0 ; i < targets _ . length ; i + + ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / io / SSTableReader . java b / src / java / org / apache / cassandra / io / SSTableReader . java <nl> index 1954732 . . c498a7e 100644 <nl> - - - a / src / java / org / apache / cassandra / io / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / SSTableReader . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . log4j . Logger ; <nl> import org . apache . commons . lang . StringUtils ; <nl> <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> + import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . utils . BloomFilter ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> @ @ - 86 , 9 + 87 , 14 @ @ public class SSTableReader extends SSTable implements Comparable < SSTableReader > <nl> return INDEX _ INTERVAL ; <nl> } <nl> <nl> - public static int getApproximateKeyCount ( Iterable < SSTableReader > sstables ) <nl> + public static long getApproximateKeyCount ( ) <nl> { <nl> - int count = 0 ; <nl> + return getApproximateKeyCount ( openedFiles . values ( ) ) ; <nl> + } <nl> + <nl> + public static long getApproximateKeyCount ( Iterable < SSTableReader > sstables ) <nl> + { <nl> + long count = 0 ; <nl> <nl> for ( SSTableReader sstable : sstables ) <nl> { <nl> @ @ - 101 , 6 + 107 , 30 @ @ public class SSTableReader extends SSTable implements Comparable < SSTableReader > <nl> return count ; <nl> } <nl> <nl> + / * * <nl> + * Get all indexed keys in any SSTable for our primary range <nl> + * TODO add option to include keys from one or more other ranges <nl> + * / <nl> + public static List < DecoratedKey > getIndexedDecoratedKeys ( ) <nl> + { <nl> + Range range = StorageService . instance ( ) . getLocalPrimaryRange ( ) ; <nl> + List < DecoratedKey > indexedKeys = new ArrayList < DecoratedKey > ( ) ; <nl> + <nl> + for ( SSTableReader sstable : openedFiles . values ( ) ) <nl> + { <nl> + for ( KeyPosition kp : sstable . getIndexPositions ( ) ) <nl> + { <nl> + if ( range . contains ( kp . key . token ) ) <nl> + { <nl> + indexedKeys . add ( kp . key ) ; <nl> + } <nl> + } <nl> + } <nl> + Collections . sort ( indexedKeys ) ; <nl> + <nl> + return indexedKeys ; <nl> + } <nl> + <nl> public static SSTableReader open ( String dataFileName ) throws IOException <nl> { <nl> return open ( dataFileName , StorageService . getPartitioner ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / SSTableWriter . java b / src / java / org / apache / cassandra / io / SSTableWriter . java <nl> index 41f3de1 . . 1340d2c 100644 <nl> - - - a / src / java / org / apache / cassandra / io / SSTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / SSTableWriter . java <nl> @ @ - 46 , 12 + 46 , 12 @ @ public class SSTableWriter extends SSTable <nl> private DecoratedKey lastWrittenKey ; <nl> private BloomFilter bf ; <nl> <nl> - public SSTableWriter ( String filename , int keyCount , IPartitioner partitioner ) throws IOException <nl> + public SSTableWriter ( String filename , long keyCount , IPartitioner partitioner ) throws IOException <nl> { <nl> super ( filename , partitioner ) ; <nl> dataFile = new BufferedRandomAccessFile ( path , " rw " , ( int ) ( DatabaseDescriptor . getFlushDataBufferSizeInMB ( ) * 1024 * 1024 ) ) ; <nl> indexFile = new BufferedRandomAccessFile ( indexFilename ( ) , " rw " , ( int ) ( DatabaseDescriptor . getFlushIndexBufferSizeInMB ( ) * 1024 * 1024 ) ) ; <nl> - bf = new BloomFilter ( keyCount , 15 ) ; <nl> + bf = new BloomFilter ( ( int ) keyCount , 15 ) ; / / TODO fix long - > int cast <nl> } <nl> <nl> private long beforeAppend ( DecoratedKey decoratedKey ) throws IOException <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index c685711 . . 6758b2f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 77 , 8 + 77 , 7 @ @ public class CassandraDaemon <nl> } ) ; <nl> <nl> / / initialize stuff <nl> - Set < String > tables = DatabaseDescriptor . getTableToColumnFamilyMap ( ) . keySet ( ) ; <nl> - for ( String table : tables ) <nl> + for ( String table : DatabaseDescriptor . getTableToColumnFamilyMap ( ) . keySet ( ) ) <nl> { <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " opening keyspace " + table ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraServer . java b / src / java / org / apache / cassandra / service / CassandraServer . java <nl> index 1228525 . . 8b6a607 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraServer . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraServer . java <nl> @ @ - 525 , 10 + 525 , 7 @ @ public class CassandraServer implements Cassandra . Iface <nl> { <nl> return DatabaseDescriptor . getTables ( ) ; <nl> } <nl> - else <nl> - { <nl> - return new ArrayList < String > ( ) ; <nl> - } <nl> + return Collections . emptyList ( ) ; <nl> } <nl> <nl> public Map < String , Map < String , String > > describe _ keyspace ( String table ) throws NotFoundException <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 7a7c1cd . . 5a4e5e3 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . service ; <nl> <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> + import java . io . UnsupportedEncodingException ; <nl> import java . lang . management . ManagementFactory ; <nl> import java . net . InetAddress ; <nl> import java . net . UnknownHostException ; <nl> @ @ - 27 , 8 + 28 , 7 @ @ import java . util . * ; <nl> import java . util . concurrent . ExecutorService ; <nl> import java . util . concurrent . LinkedBlockingQueue ; <nl> import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . locks . Lock ; <nl> - import java . util . concurrent . locks . ReentrantLock ; <nl> + import java . util . concurrent . locks . Condition ; <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> <nl> @ @ - 43 , 8 + 43 , 18 @ @ import org . apache . cassandra . net . io . StreamContextManager ; <nl> import org . apache . cassandra . tools . MembershipCleanerVerbHandler ; <nl> import org . apache . cassandra . utils . FileUtils ; <nl> import org . apache . cassandra . utils . LogUtil ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . SimpleCondition ; <nl> + import org . apache . cassandra . io . SSTableReader ; <nl> + import org . apache . thrift . protocol . TBinaryProtocol ; <nl> + import org . apache . thrift . transport . TSocket ; <nl> + import org . apache . thrift . transport . TTransport ; <nl> + import org . apache . thrift . transport . TTransportException ; <nl> + import org . apache . thrift . TException ; <nl> + <nl> import org . apache . log4j . Logger ; <nl> import org . apache . log4j . Level ; <nl> + import org . apache . commons . lang . ArrayUtils ; <nl> <nl> / * <nl> * This abstraction contains the token / identifier of this node <nl> @ @ - 77 , 6 + 87 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> public final static String mbrshipCleanerVerbHandler _ = " MBRSHIP - CLEANER - VERB - HANDLER " ; <nl> public final static String bsMetadataVerbHandler _ = " BS - METADATA - VERB - HANDLER " ; <nl> public final static String rangeVerbHandler _ = " RANGE - VERB - HANDLER " ; <nl> + public final static String bootstrapTokenVerbHandler _ = " SPLITS - VERB - HANDLER " ; <nl> <nl> private static StorageService instance _ ; <nl> private static EndPoint tcpAddr _ ; <nl> @ @ - 97 , 6 + 108 , 16 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> return partitioner _ ; <nl> } <nl> <nl> + public List < Range > getLocalRanges ( ) <nl> + { <nl> + return getRangesForEndPoint ( getLocalStorageEndPoint ( ) ) ; <nl> + } <nl> + <nl> + public Range getLocalPrimaryRange ( ) <nl> + { <nl> + return getPrimaryRangeForEndPoint ( getLocalStorageEndPoint ( ) ) ; <nl> + } <nl> + <nl> static <nl> { <nl> partitioner _ = DatabaseDescriptor . getPartitioner ( ) ; <nl> @ @ - 254 , 6 + 275 , 24 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . mbrshipCleanerVerbHandler _ , new MembershipCleanerVerbHandler ( ) ) ; <nl> MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . bsMetadataVerbHandler _ , new BootstrapMetadataVerbHandler ( ) ) ; <nl> MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . rangeVerbHandler _ , new RangeVerbHandler ( ) ) ; <nl> + MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . bootstrapTokenVerbHandler _ , new IVerbHandler ( ) <nl> + { <nl> + public void doVerb ( Message message ) <nl> + { <nl> + List < String > tokens = getSplits ( 2 ) ; <nl> + assert tokens . size ( ) = = 3 : tokens . size ( ) ; <nl> + Message response ; <nl> + try <nl> + { <nl> + response = message . getReply ( getLocalStorageEndPoint ( ) , tokens . get ( 1 ) . getBytes ( " UTF - 8 " ) ) ; <nl> + } <nl> + catch ( UnsupportedEncodingException e ) <nl> + { <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; <nl> + } <nl> + } ) ; <nl> <nl> / * register the stage for the mutations * / <nl> consistencyManager _ = new DebuggableThreadPoolExecutor ( DatabaseDescriptor . getConsistencyThreads ( ) , <nl> @ @ - 309 , 12 + 348 , 56 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> Gossiper . instance ( ) . addApplicationState ( StorageService . nodeId _ , state ) ; <nl> if ( isBootstrapMode ) <nl> { <nl> - logger _ . info ( " Starting in bootstrap mode " ) ; <nl> + logger _ . info ( " Starting in bootstrap mode ( first , sleeping to get load information ) " ) ; <nl> + / / wait for node information to be available . if the rest of the cluster just came up , <nl> + / / this could be up to threshold _ ms ( currently 5 minutes ) . <nl> + try <nl> + { <nl> + while ( storageLoadBalancer _ . getLoadInfo ( ) . isEmpty ( ) ) <nl> + { <nl> + Thread . sleep ( 100 ) ; <nl> + } <nl> + / / one more sleep in case there are some stragglers <nl> + Thread . sleep ( BootStrapper . INITIAL _ DELAY ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + <nl> + / / if initialtoken was specified , use that . otherwise , pick a token to assume half the load of the most - loaded node . <nl> + if ( DatabaseDescriptor . getInitialToken ( ) = = null ) <nl> + { <nl> + double maxLoad = 0 ; <nl> + EndPoint maxEndpoint = null ; <nl> + for ( Map . Entry < EndPoint , Double > entry : storageLoadBalancer _ . getLoadInfo ( ) . entrySet ( ) ) <nl> + { <nl> + if ( maxEndpoint = = null | | entry . getValue ( ) > maxLoad ) <nl> + { <nl> + maxEndpoint = entry . getKey ( ) ; <nl> + maxLoad = entry . getValue ( ) ; <nl> + } <nl> + } <nl> + if ( ! maxEndpoint . equals ( getLocalStorageEndPoint ( ) ) ) <nl> + { <nl> + Token < ? > t = getBootstrapTokenFrom ( maxEndpoint ) ; <nl> + logger _ . info ( " Setting token to " + t + " to assume load from " + maxEndpoint . getHost ( ) ) ; <nl> + updateToken ( t ) ; <nl> + } <nl> + } <nl> doBootstrap ( StorageService . getLocalStorageEndPoint ( ) ) ; <nl> Gossiper . instance ( ) . addApplicationState ( BOOTSTRAP _ MODE , new ApplicationState ( " " ) ) ; <nl> } <nl> } <nl> - <nl> + <nl> + private Token < ? > getBootstrapTokenFrom ( EndPoint maxEndpoint ) <nl> + { <nl> + Message message = new Message ( getLocalStorageEndPoint ( ) , " " , bootstrapTokenVerbHandler _ , ArrayUtils . EMPTY _ BYTE _ ARRAY ) ; <nl> + BootstrapTokenCallback btc = new BootstrapTokenCallback ( ) ; <nl> + MessagingService . getMessagingInstance ( ) . sendRR ( message , maxEndpoint , btc ) ; <nl> + return btc . getToken ( ) ; <nl> + } <nl> + <nl> public boolean isBootstrapMode ( ) <nl> { <nl> return isBootstrapMode ; <nl> @ @ - 1058 , 4 + 1141 , 68 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> Logger . getLogger ( classQualifier ) . setLevel ( level ) ; <nl> logger _ . info ( " set log level to " + level + " for classes under ' " + classQualifier + " ' ( if the level doesn ' t look like ' " + rawLevel + " ' then log4j couldn ' t parse ' " + rawLevel + " ' ) " ) ; <nl> } <nl> + <nl> + / * * <nl> + * @ param splits : number of ranges to break into . Minimum 2 . <nl> + * @ return list of Tokens ( _ not _ keys ! ) breaking up the data this node is responsible for into ` splits ` pieces . <nl> + * There will be 1 more token than splits requested . So for splits of 2 , tokens T1 T2 T3 will be returned , <nl> + * where ( T1 , T2 ] is the first range and ( T2 , T3 ] is the second . The first token will always be the left <nl> + * Token of this node ' s primary range , and the last will always be the Right token of that range . <nl> + * / <nl> + public List < String > getSplits ( int splits ) <nl> + { <nl> + assert splits > 1 ; <nl> + / / we use the actual Range token for the first and last brackets of the splits to ensure correctness <nl> + / / ( we ' re only operating on 1 / 128 of the keys remember ) <nl> + Range range = getLocalPrimaryRange ( ) ; <nl> + List < String > tokens = new ArrayList < String > ( ) ; <nl> + tokens . add ( range . left ( ) . toString ( ) ) ; <nl> + <nl> + List < DecoratedKey > decoratedKeys = SSTableReader . getIndexedDecoratedKeys ( ) ; <nl> + for ( int i = 1 ; i < splits ; i + + ) <nl> + { <nl> + int index = i * ( decoratedKeys . size ( ) / splits ) ; <nl> + tokens . add ( decoratedKeys . get ( index ) . token . toString ( ) ) ; <nl> + } <nl> + <nl> + tokens . add ( range . right ( ) . toString ( ) ) ; <nl> + return tokens ; <nl> + } <nl> + <nl> + class BootstrapTokenCallback implements IAsyncCallback <nl> + { <nl> + private volatile Token < ? > token ; <nl> + private final Condition condition = new SimpleCondition ( ) ; <nl> + <nl> + public Token < ? > getToken ( ) <nl> + { <nl> + try <nl> + { <nl> + condition . await ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + return token ; <nl> + } <nl> + <nl> + public void response ( Message msg ) <nl> + { <nl> + try <nl> + { <nl> + token = partitioner _ . getTokenFactory ( ) . fromString ( new String ( msg . getMessageBody ( ) , " UTF - 8 " ) ) ; <nl> + } <nl> + catch ( UnsupportedEncodingException e ) <nl> + { <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + condition . signalAll ( ) ; <nl> + } <nl> + <nl> + public void attachContext ( Object o ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3ce2da6 . . b0f9588 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 12 
 + * Optimize the way we check if a token is repaired in anticompaction ( CASSANDRA - 10768 ) 
 * Add proper error handling to stream receiver ( CASSANDRA - 10774 ) 
 * Warn or fail when changing cluster topology live ( CASSANDRA - 10243 ) 
 * Status command in debian / ubuntu init script doesn ' t work ( CASSANDRA - 10213 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index b0ad244 . . 2630ba2 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 1115 , 11 + 1115 , 11 @ @ public class CompactionManager implements CompactionManagerMBean 
 metrics . beginCompaction ( ci ) ; 
 try 
 { 
 + Range . OrderedRangeContainmentChecker containmentChecker = new Range . OrderedRangeContainmentChecker ( ranges ) ; 
 while ( iter . hasNext ( ) ) 
 { 
 AbstractCompactedRow row = iter . next ( ) ; 
 - / / if current range from sstable is repaired , save it into the new repaired sstable 
 - if ( Range . isInRanges ( row . key . getToken ( ) , ranges ) ) 
 + if ( containmentChecker . contains ( row . key . getToken ( ) ) ) 
 { 
 repairedSSTableWriter . append ( row ) ; 
 repairedKeyCount + + ; 
 diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java 
 index 505f1f3 . . 81c92a2 100644 
 - - - a / src / java / org / apache / cassandra / dht / Range . java 
 + + + b / src / java / org / apache / cassandra / dht / Range . java 
 @ @ - 21 , 6 + 21 , 8 @ @ import java . io . Serializable ; 
 import java . util . * ; 
 
 import org . apache . commons . lang3 . ObjectUtils ; 
 + 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . RowPosition ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . Pair ; 
 @ @ - 491 , 4 + 493 , 46 @ @ public class Range < T extends RingPosition < T > > extends AbstractBounds < T > implemen 
 { 
 return new Range < T > ( left , newRight ) ; 
 } 
 + 
 + / * * 
 + * Helper class to check if a token is contained within a given collection of ranges 
 + * / 
 + public static class OrderedRangeContainmentChecker 
 + { 
 + private final Iterator < Range < Token > > normalizedRangesIterator ; 
 + private Token lastToken = null ; 
 + private Range < Token > currentRange ; 
 + 
 + public OrderedRangeContainmentChecker ( Collection < Range < Token > > ranges ) 
 + { 
 + normalizedRangesIterator = normalize ( ranges ) . iterator ( ) ; 
 + assert normalizedRangesIterator . hasNext ( ) ; 
 + currentRange = normalizedRangesIterator . next ( ) ; 
 + } 
 + 
 + / * * 
 + * Returns true if the ranges given in the constructor contains the token , false otherwise . 
 + * 
 + * The tokens passed to this method must be in increasing order 
 + * 
 + * @ param t token to check , must be larger than or equal to the last token passed 
 + * @ return true if the token is contained within the ranges given to the constructor . 
 + * / 
 + public boolean contains ( Token t ) 
 + { 
 + assert lastToken = = null | | lastToken . compareTo ( t ) < = 0 ; 
 + lastToken = t ; 
 + while ( true ) 
 + { 
 + if ( t . compareTo ( currentRange . left ) < = 0 ) 
 + return false ; 
 + else if ( t . compareTo ( currentRange . right ) < = 0 | | currentRange . right . compareTo ( currentRange . left ) < = 0 ) 
 + return true ; 
 + 
 + if ( ! normalizedRangesIterator . hasNext ( ) ) 
 + return false ; 
 + currentRange = normalizedRangesIterator . next ( ) ; 
 + } 
 + } 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / dht / RangeTest . java b / test / unit / org / apache / cassandra / dht / RangeTest . java 
 index 906396c . . 1d8123b 100644 
 - - - a / test / unit / org / apache / cassandra / dht / RangeTest . java 
 + + + b / test / unit / org / apache / cassandra / dht / RangeTest . java 
 @ @ - 19 , 9 + 19 , 15 @ @ 
 package org . apache . cassandra . dht ; 
 
 import java . nio . ByteBuffer ; 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 import java . util . HashSet ; 
 import java . util . List ; 
 + import java . util . Random ; 
 import java . util . Set ; 
 + 
 + import com . google . common . base . Joiner ; 
 + 
 import static java . util . Arrays . asList ; 
 
 import org . apache . commons . lang3 . StringUtils ; 
 @ @ - 29 , 6 + 35 , 7 @ @ import org . junit . Test ; 
 
 import org . apache . cassandra . db . RowPosition ; 
 import static org . apache . cassandra . Util . range ; 
 + import static org . junit . Assert . * ; 
 
 
 public class RangeTest 
 @ @ - 536 , 4 + 543 , 64 @ @ public class RangeTest 
 expected = asList ( range ( " " , " " ) ) ; 
 assertNormalize ( input , expected ) ; 
 } 
 + 
 + @ Test 
 + public void testRandomOrderedRangeContainmentChecker ( ) 
 + { 
 + Random r = new Random ( ) ; 
 + for ( int j = 0 ; j < 1000 ; j + + ) 
 + { 
 + int numTokens = r . nextInt ( 300 ) + 1 ; 
 + List < Range < Token > > ranges = new ArrayList < > ( numTokens ) ; 
 + List < Token > tokens = new ArrayList < > ( 2 * numTokens ) ; 
 + for ( int i = 0 ; i < 2 * numTokens ; i + + ) 
 + tokens . add ( t ( r . nextLong ( ) ) ) ; 
 + 
 + Collections . sort ( tokens ) ; 
 + 
 + for ( int i = 0 ; i < tokens . size ( ) ; i + + ) 
 + { 
 + ranges . add ( new Range < > ( tokens . get ( i ) , tokens . get ( i + 1 ) ) ) ; 
 + i + + ; 
 + } 
 + 
 + List < Token > tokensToTest = new ArrayList < > ( ) ; 
 + for ( int i = 0 ; i < 10000 ; i + + ) 
 + tokensToTest . add ( t ( r . nextLong ( ) ) ) ; 
 + 
 + tokensToTest . add ( t ( Long . MAX _ VALUE ) ) ; 
 + tokensToTest . add ( t ( Long . MIN _ VALUE ) ) ; 
 + tokensToTest . add ( t ( Long . MAX _ VALUE - 1 ) ) ; 
 + tokensToTest . add ( t ( Long . MIN _ VALUE + 1 ) ) ; 
 + Collections . sort ( tokensToTest ) ; 
 + 
 + Range . OrderedRangeContainmentChecker checker = new Range . OrderedRangeContainmentChecker ( ranges ) ; 
 + for ( Token t : tokensToTest ) 
 + { 
 + if ( checker . contains ( t ) ! = Range . isInRanges ( t , ranges ) ) / / avoid running Joiner . on ( . . ) every iteration 
 + fail ( String . format ( " This should never flap ! If it does , it is a bug ( ranges = % s , token = % s ) " , Joiner . on ( " , " ) . join ( ranges ) , t ) ) ; 
 + } 
 + } 
 + } 
 + 
 + @ Test 
 + public void testBoundariesORCC ( ) 
 + { 
 + List < Range < Token > > ranges = asList ( r ( Long . MIN _ VALUE , Long . MIN _ VALUE + 1 ) , r ( Long . MAX _ VALUE - 1 , Long . MAX _ VALUE ) ) ; 
 + Range . OrderedRangeContainmentChecker checker = new Range . OrderedRangeContainmentChecker ( ranges ) ; 
 + assertFalse ( checker . contains ( t ( Long . MIN _ VALUE ) ) ) ; 
 + assertTrue ( checker . contains ( t ( Long . MIN _ VALUE + 1 ) ) ) ; 
 + assertFalse ( checker . contains ( t ( 0 ) ) ) ; 
 + assertFalse ( checker . contains ( t ( Long . MAX _ VALUE - 1 ) ) ) ; 
 + assertTrue ( checker . contains ( t ( Long . MAX _ VALUE ) ) ) ; 
 + } 
 + 
 + private static Range < Token > r ( long left , long right ) 
 + { 
 + return new Range < > ( t ( left ) , t ( right ) ) ; 
 + } 
 + private static Token t ( long t ) 
 + { 
 + return new LongToken ( t ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0ce9ee6 . . 8dfd1f8 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 725 , 10 + 725 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 void doCleanup ( SSTableReader sstable ) throws IOException 
 { 
 assert sstable ! = null ; 
 - List < Range > myRanges ; 
 - Map < EndPoint , List < Range > > endPointtoRangeMap = StorageService . instance ( ) . constructEndPointToRangesMap ( ) ; 
 - myRanges = endPointtoRangeMap . get ( StorageService . getLocalStorageEndPoint ( ) ) ; 
 - List < SSTableReader > sstables = doFileAntiCompaction ( Arrays . asList ( sstable ) , myRanges , null ) ; 
 + List < SSTableReader > sstables = doFileAntiCompaction ( Arrays . asList ( sstable ) , StorageService . instance ( ) . getLocalRanges ( ) , null ) ; 
 if ( ! sstables . isEmpty ( ) ) 
 { 
 assert sstables . size ( ) = = 1 ; 
 @ @ - 764 , 7 + 761 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 long startTime = System . currentTimeMillis ( ) ; 
 long totalkeysWritten = 0 ; 
 
 - int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , SSTableReader . getApproximateKeyCount ( sstables ) / 2 ) ; 
 + int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , ( int ) ( SSTableReader . getApproximateKeyCount ( sstables ) / 2 ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Expected bloom filter size : " + expectedBloomFilterSize ) ; 
 
 @ @ - 844 , 7 + 841 , 8 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 long startTime = System . currentTimeMillis ( ) ; 
 long totalkeysWritten = 0 ; 
 
 - int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , SSTableReader . getApproximateKeyCount ( sstables ) ) ; 
 + / / TODO the int cast here is potentially buggy 
 + int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , ( int ) SSTableReader . getApproximateKeyCount ( sstables ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Expected bloom filter size : " + expectedBloomFilterSize ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / DecoratedKey . java b / src / java / org / apache / cassandra / db / DecoratedKey . java 
 index 1b9af39 . . b2a72da 100644 
 - - - a / src / java / org / apache / cassandra / db / DecoratedKey . java 
 + + + b / src / java / org / apache / cassandra / db / DecoratedKey . java 
 @ @ - 24 , 7 + 24 , 7 @ @ import org . apache . cassandra . dht . Token ; 
 * Represents a decorated key , handy for certain operations 
 * where just working with strings gets slow . 
 * / 
 - public class DecoratedKey < T extends Token > 
 + public class DecoratedKey < T extends Token > implements Comparable < DecoratedKey > 
 { 
 public final T token ; 
 public final String key ; 
 @ @ - 32 , 6 + 32 , 7 @ @ public class DecoratedKey < T extends Token > 
 public DecoratedKey ( T token , String key ) 
 { 
 super ( ) ; 
 + assert key ! = null ; 
 this . token = token ; 
 this . key = key ; 
 } 
 @ @ - 55 , 20 + 56 , 22 @ @ public class DecoratedKey < T extends Token > 
 return false ; 
 if ( getClass ( ) ! = obj . getClass ( ) ) 
 return false ; 
 + 
 DecoratedKey other = ( DecoratedKey ) obj ; 
 - if ( key = = null ) 
 - { 
 - if ( other . key ! = null ) 
 - return false ; 
 - } else if ( ! key . equals ( other . key ) ) 
 - return false ; 
 + / / either both should be of a class where all tokens are null , or neither 
 + assert ( token = = null ) = = ( other . token = = null ) ; 
 if ( token = = null ) 
 - { 
 - if ( other . token ! = null ) 
 - return false ; 
 - } else if ( ! token . equals ( other . token ) ) 
 - return false ; 
 - return true ; 
 + return key . equals ( other . key ) ; 
 + return token . equals ( other . token ) & & key . equals ( other . key ) ; 
 + } 
 + 
 + public int compareTo ( DecoratedKey other ) 
 + { 
 + assert ( token = = null ) = = ( other . token = = null ) ; 
 + if ( token = = null ) 
 + return key . compareTo ( other . key ) ; 
 + int i = token . compareTo ( other . token ) ; 
 + return i = = 0 ? key . compareTo ( other . key ) : i ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java 
 index b61991e . . 5503a8f 100644 
 - - - a / src / java / org / apache / cassandra / db / Table . java 
 + + + b / src / java / org / apache / cassandra / db / Table . java 
 @ @ - 492 , 7 + 492 , 7 @ @ public class Table 
 } 
 
 / * 
 - * Get the list of all SSTables on disk . Not safe unless you aquire the CFS readlocks ! 
 + * Get the list of all SSTables on disk . 
 * / 
 public List < SSTableReader > getAllSSTablesOnDisk ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 index 35cab21 . . 9402048 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java 
 + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 @ @ - 41 , 8 + 41 , 10 @ @ import org . apache . cassandra . utils . LogUtil ; 
 * / 
 public class BootStrapper implements Runnable 
 { 
 + public static final long INITIAL _ DELAY = 30 * 1000 ; / / ms 
 + 
 private static Logger logger _ = Logger . getLogger ( BootStrapper . class ) ; 
 - private static final long INITIAL _ DELAY = 60 * 1000 ; / / ms 
 + 
 / * endpoints that need to be bootstrapped * / 
 protected EndPoint [ ] targets _ = new EndPoint [ 0 ] ; 
 / * tokens of the nodes being bootstrapped . * / 
 @ @ - 60 , 10 + 62 , 6 @ @ public class BootStrapper implements Runnable 
 { 
 try 
 { 
 - / * Initial delay waiting for this node to get a stable endpoint map * / 
 - Thread . sleep ( INITIAL _ DELAY ) ; 
 - / * Clone again now so we include all discovered nodes in our calculations * / 
 - tokenMetadata _ = StorageService . instance ( ) . getTokenMetadata ( ) ; 
 / / Mark as not bootstrapping to calculate ranges correctly 
 for ( int i = 0 ; i < targets _ . length ; i + + ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / io / SSTableReader . java b / src / java / org / apache / cassandra / io / SSTableReader . java 
 index 1954732 . . c498a7e 100644 
 - - - a / src / java / org / apache / cassandra / io / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / SSTableReader . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . log4j . Logger ; 
 import org . apache . commons . lang . StringUtils ; 
 
 import org . apache . cassandra . dht . IPartitioner ; 
 + import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . utils . BloomFilter ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 @ @ - 86 , 9 + 87 , 14 @ @ public class SSTableReader extends SSTable implements Comparable < SSTableReader > 
 return INDEX _ INTERVAL ; 
 } 
 
 - public static int getApproximateKeyCount ( Iterable < SSTableReader > sstables ) 
 + public static long getApproximateKeyCount ( ) 
 { 
 - int count = 0 ; 
 + return getApproximateKeyCount ( openedFiles . values ( ) ) ; 
 + } 
 + 
 + public static long getApproximateKeyCount ( Iterable < SSTableReader > sstables ) 
 + { 
 + long count = 0 ; 
 
 for ( SSTableReader sstable : sstables ) 
 { 
 @ @ - 101 , 6 + 107 , 30 @ @ public class SSTableReader extends SSTable implements Comparable < SSTableReader > 
 return count ; 
 } 
 
 + / * * 
 + * Get all indexed keys in any SSTable for our primary range 
 + * TODO add option to include keys from one or more other ranges 
 + * / 
 + public static List < DecoratedKey > getIndexedDecoratedKeys ( ) 
 + { 
 + Range range = StorageService . instance ( ) . getLocalPrimaryRange ( ) ; 
 + List < DecoratedKey > indexedKeys = new ArrayList < DecoratedKey > ( ) ; 
 + 
 + for ( SSTableReader sstable : openedFiles . values ( ) ) 
 + { 
 + for ( KeyPosition kp : sstable . getIndexPositions ( ) ) 
 + { 
 + if ( range . contains ( kp . key . token ) ) 
 + { 
 + indexedKeys . add ( kp . key ) ; 
 + } 
 + } 
 + } 
 + Collections . sort ( indexedKeys ) ; 
 + 
 + return indexedKeys ; 
 + } 
 + 
 public static SSTableReader open ( String dataFileName ) throws IOException 
 { 
 return open ( dataFileName , StorageService . getPartitioner ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / SSTableWriter . java b / src / java / org / apache / cassandra / io / SSTableWriter . java 
 index 41f3de1 . . 1340d2c 100644 
 - - - a / src / java / org / apache / cassandra / io / SSTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / SSTableWriter . java 
 @ @ - 46 , 12 + 46 , 12 @ @ public class SSTableWriter extends SSTable 
 private DecoratedKey lastWrittenKey ; 
 private BloomFilter bf ; 
 
 - public SSTableWriter ( String filename , int keyCount , IPartitioner partitioner ) throws IOException 
 + public SSTableWriter ( String filename , long keyCount , IPartitioner partitioner ) throws IOException 
 { 
 super ( filename , partitioner ) ; 
 dataFile = new BufferedRandomAccessFile ( path , " rw " , ( int ) ( DatabaseDescriptor . getFlushDataBufferSizeInMB ( ) * 1024 * 1024 ) ) ; 
 indexFile = new BufferedRandomAccessFile ( indexFilename ( ) , " rw " , ( int ) ( DatabaseDescriptor . getFlushIndexBufferSizeInMB ( ) * 1024 * 1024 ) ) ; 
 - bf = new BloomFilter ( keyCount , 15 ) ; 
 + bf = new BloomFilter ( ( int ) keyCount , 15 ) ; / / TODO fix long - > int cast 
 } 
 
 private long beforeAppend ( DecoratedKey decoratedKey ) throws IOException 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index c685711 . . 6758b2f 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 77 , 8 + 77 , 7 @ @ public class CassandraDaemon 
 } ) ; 
 
 / / initialize stuff 
 - Set < String > tables = DatabaseDescriptor . getTableToColumnFamilyMap ( ) . keySet ( ) ; 
 - for ( String table : tables ) 
 + for ( String table : DatabaseDescriptor . getTableToColumnFamilyMap ( ) . keySet ( ) ) 
 { 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " opening keyspace " + table ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraServer . java b / src / java / org / apache / cassandra / service / CassandraServer . java 
 index 1228525 . . 8b6a607 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraServer . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraServer . java 
 @ @ - 525 , 10 + 525 , 7 @ @ public class CassandraServer implements Cassandra . Iface 
 { 
 return DatabaseDescriptor . getTables ( ) ; 
 } 
 - else 
 - { 
 - return new ArrayList < String > ( ) ; 
 - } 
 + return Collections . emptyList ( ) ; 
 } 
 
 public Map < String , Map < String , String > > describe _ keyspace ( String table ) throws NotFoundException 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 7a7c1cd . . 5a4e5e3 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . service ; 
 
 import java . io . File ; 
 import java . io . IOException ; 
 + import java . io . UnsupportedEncodingException ; 
 import java . lang . management . ManagementFactory ; 
 import java . net . InetAddress ; 
 import java . net . UnknownHostException ; 
 @ @ - 27 , 8 + 28 , 7 @ @ import java . util . * ; 
 import java . util . concurrent . ExecutorService ; 
 import java . util . concurrent . LinkedBlockingQueue ; 
 import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . locks . Lock ; 
 - import java . util . concurrent . locks . ReentrantLock ; 
 + import java . util . concurrent . locks . Condition ; 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 
 @ @ - 43 , 8 + 43 , 18 @ @ import org . apache . cassandra . net . io . StreamContextManager ; 
 import org . apache . cassandra . tools . MembershipCleanerVerbHandler ; 
 import org . apache . cassandra . utils . FileUtils ; 
 import org . apache . cassandra . utils . LogUtil ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . SimpleCondition ; 
 + import org . apache . cassandra . io . SSTableReader ; 
 + import org . apache . thrift . protocol . TBinaryProtocol ; 
 + import org . apache . thrift . transport . TSocket ; 
 + import org . apache . thrift . transport . TTransport ; 
 + import org . apache . thrift . transport . TTransportException ; 
 + import org . apache . thrift . TException ; 
 + 
 import org . apache . log4j . Logger ; 
 import org . apache . log4j . Level ; 
 + import org . apache . commons . lang . ArrayUtils ; 
 
 / * 
 * This abstraction contains the token / identifier of this node 
 @ @ - 77 , 6 + 87 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 public final static String mbrshipCleanerVerbHandler _ = " MBRSHIP - CLEANER - VERB - HANDLER " ; 
 public final static String bsMetadataVerbHandler _ = " BS - METADATA - VERB - HANDLER " ; 
 public final static String rangeVerbHandler _ = " RANGE - VERB - HANDLER " ; 
 + public final static String bootstrapTokenVerbHandler _ = " SPLITS - VERB - HANDLER " ; 
 
 private static StorageService instance _ ; 
 private static EndPoint tcpAddr _ ; 
 @ @ - 97 , 6 + 108 , 16 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 return partitioner _ ; 
 } 
 
 + public List < Range > getLocalRanges ( ) 
 + { 
 + return getRangesForEndPoint ( getLocalStorageEndPoint ( ) ) ; 
 + } 
 + 
 + public Range getLocalPrimaryRange ( ) 
 + { 
 + return getPrimaryRangeForEndPoint ( getLocalStorageEndPoint ( ) ) ; 
 + } 
 + 
 static 
 { 
 partitioner _ = DatabaseDescriptor . getPartitioner ( ) ; 
 @ @ - 254 , 6 + 275 , 24 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . mbrshipCleanerVerbHandler _ , new MembershipCleanerVerbHandler ( ) ) ; 
 MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . bsMetadataVerbHandler _ , new BootstrapMetadataVerbHandler ( ) ) ; 
 MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . rangeVerbHandler _ , new RangeVerbHandler ( ) ) ; 
 + MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . bootstrapTokenVerbHandler _ , new IVerbHandler ( ) 
 + { 
 + public void doVerb ( Message message ) 
 + { 
 + List < String > tokens = getSplits ( 2 ) ; 
 + assert tokens . size ( ) = = 3 : tokens . size ( ) ; 
 + Message response ; 
 + try 
 + { 
 + response = message . getReply ( getLocalStorageEndPoint ( ) , tokens . get ( 1 ) . getBytes ( " UTF - 8 " ) ) ; 
 + } 
 + catch ( UnsupportedEncodingException e ) 
 + { 
 + throw new AssertionError ( ) ; 
 + } 
 + MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; 
 + } 
 + } ) ; 
 
 / * register the stage for the mutations * / 
 consistencyManager _ = new DebuggableThreadPoolExecutor ( DatabaseDescriptor . getConsistencyThreads ( ) , 
 @ @ - 309 , 12 + 348 , 56 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 Gossiper . instance ( ) . addApplicationState ( StorageService . nodeId _ , state ) ; 
 if ( isBootstrapMode ) 
 { 
 - logger _ . info ( " Starting in bootstrap mode " ) ; 
 + logger _ . info ( " Starting in bootstrap mode ( first , sleeping to get load information ) " ) ; 
 + / / wait for node information to be available . if the rest of the cluster just came up , 
 + / / this could be up to threshold _ ms ( currently 5 minutes ) . 
 + try 
 + { 
 + while ( storageLoadBalancer _ . getLoadInfo ( ) . isEmpty ( ) ) 
 + { 
 + Thread . sleep ( 100 ) ; 
 + } 
 + / / one more sleep in case there are some stragglers 
 + Thread . sleep ( BootStrapper . INITIAL _ DELAY ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + 
 + / / if initialtoken was specified , use that . otherwise , pick a token to assume half the load of the most - loaded node . 
 + if ( DatabaseDescriptor . getInitialToken ( ) = = null ) 
 + { 
 + double maxLoad = 0 ; 
 + EndPoint maxEndpoint = null ; 
 + for ( Map . Entry < EndPoint , Double > entry : storageLoadBalancer _ . getLoadInfo ( ) . entrySet ( ) ) 
 + { 
 + if ( maxEndpoint = = null | | entry . getValue ( ) > maxLoad ) 
 + { 
 + maxEndpoint = entry . getKey ( ) ; 
 + maxLoad = entry . getValue ( ) ; 
 + } 
 + } 
 + if ( ! maxEndpoint . equals ( getLocalStorageEndPoint ( ) ) ) 
 + { 
 + Token < ? > t = getBootstrapTokenFrom ( maxEndpoint ) ; 
 + logger _ . info ( " Setting token to " + t + " to assume load from " + maxEndpoint . getHost ( ) ) ; 
 + updateToken ( t ) ; 
 + } 
 + } 
 doBootstrap ( StorageService . getLocalStorageEndPoint ( ) ) ; 
 Gossiper . instance ( ) . addApplicationState ( BOOTSTRAP _ MODE , new ApplicationState ( " " ) ) ; 
 } 
 } 
 - 
 + 
 + private Token < ? > getBootstrapTokenFrom ( EndPoint maxEndpoint ) 
 + { 
 + Message message = new Message ( getLocalStorageEndPoint ( ) , " " , bootstrapTokenVerbHandler _ , ArrayUtils . EMPTY _ BYTE _ ARRAY ) ; 
 + BootstrapTokenCallback btc = new BootstrapTokenCallback ( ) ; 
 + MessagingService . getMessagingInstance ( ) . sendRR ( message , maxEndpoint , btc ) ; 
 + return btc . getToken ( ) ; 
 + } 
 + 
 public boolean isBootstrapMode ( ) 
 { 
 return isBootstrapMode ; 
 @ @ - 1058 , 4 + 1141 , 68 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 Logger . getLogger ( classQualifier ) . setLevel ( level ) ; 
 logger _ . info ( " set log level to " + level + " for classes under ' " + classQualifier + " ' ( if the level doesn ' t look like ' " + rawLevel + " ' then log4j couldn ' t parse ' " + rawLevel + " ' ) " ) ; 
 } 
 + 
 + / * * 
 + * @ param splits : number of ranges to break into . Minimum 2 . 
 + * @ return list of Tokens ( _ not _ keys ! ) breaking up the data this node is responsible for into ` splits ` pieces . 
 + * There will be 1 more token than splits requested . So for splits of 2 , tokens T1 T2 T3 will be returned , 
 + * where ( T1 , T2 ] is the first range and ( T2 , T3 ] is the second . The first token will always be the left 
 + * Token of this node ' s primary range , and the last will always be the Right token of that range . 
 + * / 
 + public List < String > getSplits ( int splits ) 
 + { 
 + assert splits > 1 ; 
 + / / we use the actual Range token for the first and last brackets of the splits to ensure correctness 
 + / / ( we ' re only operating on 1 / 128 of the keys remember ) 
 + Range range = getLocalPrimaryRange ( ) ; 
 + List < String > tokens = new ArrayList < String > ( ) ; 
 + tokens . add ( range . left ( ) . toString ( ) ) ; 
 + 
 + List < DecoratedKey > decoratedKeys = SSTableReader . getIndexedDecoratedKeys ( ) ; 
 + for ( int i = 1 ; i < splits ; i + + ) 
 + { 
 + int index = i * ( decoratedKeys . size ( ) / splits ) ; 
 + tokens . add ( decoratedKeys . get ( index ) . token . toString ( ) ) ; 
 + } 
 + 
 + tokens . add ( range . right ( ) . toString ( ) ) ; 
 + return tokens ; 
 + } 
 + 
 + class BootstrapTokenCallback implements IAsyncCallback 
 + { 
 + private volatile Token < ? > token ; 
 + private final Condition condition = new SimpleCondition ( ) ; 
 + 
 + public Token < ? > getToken ( ) 
 + { 
 + try 
 + { 
 + condition . await ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + return token ; 
 + } 
 + 
 + public void response ( Message msg ) 
 + { 
 + try 
 + { 
 + token = partitioner _ . getTokenFactory ( ) . fromString ( new String ( msg . getMessageBody ( ) , " UTF - 8 " ) ) ; 
 + } 
 + catch ( UnsupportedEncodingException e ) 
 + { 
 + throw new AssertionError ( ) ; 
 + } 
 + condition . signalAll ( ) ; 
 + } 
 + 
 + public void attachContext ( Object o ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + } 
 }
