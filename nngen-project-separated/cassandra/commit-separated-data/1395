BLEU SCORE: 0.09535414040914189

TEST MSG: Improve assertions around some of the usage of AbstractBounds
GENERATED MSG: Better printing of AbstractBounds in traces

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 482e3ee . . 8bda6b2 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1929 , 11 + 1929 , 17 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> * / <nl> public Function < View , List < SSTableReader > > viewFilter ( final AbstractBounds < RowPosition > rowBounds ) <nl> { <nl> + assert ! AbstractBounds . strictlyWrapsAround ( rowBounds . left , rowBounds . right ) ; <nl> return new Function < View , List < SSTableReader > > ( ) <nl> { <nl> public List < SSTableReader > apply ( View view ) <nl> { <nl> - return compactionStrategyWrapper . filterSSTablesForReads ( view . sstablesInBounds ( rowBounds ) ) ; <nl> + / / Note that View . sstablesInBounds always includes it ' s bound while rowBounds may not . This is ok however <nl> + / / because the fact we restrict the sstables returned by this function is an optimization in the first <nl> + / / place and the returned sstables will ( almost ) never cover * exactly * rowBounds anyway . It ' s also <nl> + / / * very * unlikely that a sstable is included * just * because we consider one of the bound inclusively <nl> + / / instead of exclusively , so the performance impact is negligible in practice . <nl> + return view . sstablesInBounds ( rowBounds . left , rowBounds . right ) ; <nl> } <nl> } ; <nl> } <nl> @ @ - 1944 , 6 + 1950 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> * / <nl> public Function < View , List < SSTableReader > > viewFilter ( final Collection < AbstractBounds < RowPosition > > rowBoundsCollection , final boolean includeRepaired ) <nl> { <nl> + assert AbstractBounds . noneStrictlyWrapsAround ( rowBoundsCollection ) ; <nl> return new Function < View , List < SSTableReader > > ( ) <nl> { <nl> public List < SSTableReader > apply ( View view ) <nl> @ @ - 1951 , 7 + 1958 , 12 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> Set < SSTableReader > sstables = Sets . newHashSet ( ) ; <nl> for ( AbstractBounds < RowPosition > rowBounds : rowBoundsCollection ) <nl> { <nl> - for ( SSTableReader sstable : view . sstablesInBounds ( rowBounds ) ) <nl> + / / Note that View . sstablesInBounds always includes it ' s bound while rowBounds may not . This is ok however <nl> + / / because the fact we restrict the sstables returned by this function is an optimization in the first <nl> + / / place and the returned sstables will ( almost ) never cover * exactly * rowBounds anyway . It ' s also <nl> + / / * very * unlikely that a sstable is included * just * because we consider one of the bound inclusively <nl> + / / instead of exclusively , so the performance impact is negligible in practice . <nl> + for ( SSTableReader sstable : view . sstablesInBounds ( rowBounds . left , rowBounds . right ) ) <nl> { <nl> if ( includeRepaired | | ! sstable . isRepaired ( ) ) <nl> sstables . add ( sstable ) ; <nl> @ @ - 2335 , 7 + 2347 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> if ( ! manifestFile . getParentFile ( ) . exists ( ) ) <nl> manifestFile . getParentFile ( ) . mkdirs ( ) ; <nl> - <nl> + <nl> try ( PrintStream out = new PrintStream ( manifestFile ) ) <nl> { <nl> final JSONObject manifestJSON = new JSONObject ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java b / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java <nl> index c68109c . . f054315 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java <nl> + + + b / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java <nl> @ @ - 85 , 9 + 85 , 10 @ @ public class SizeEstimatesRecorder extends MigrationListener implements Runnable <nl> @ SuppressWarnings ( " resource " ) <nl> private void recordSizeEstimates ( ColumnFamilyStore table , Collection < Range < Token > > localRanges ) <nl> { <nl> + List < Range < Token > > unwrappedRanges = Range . normalize ( localRanges ) ; <nl> / / for each local primary range , estimate ( crudely ) mean partition size and partitions count . <nl> Map < Range < Token > , Pair < Long , Long > > estimates = new HashMap < > ( localRanges . size ( ) ) ; <nl> - for ( Range < Token > range : localRanges ) <nl> + for ( Range < Token > range : unwrappedRanges ) <nl> { <nl> / / filter sstables that have partitions in this range . <nl> Refs < SSTableReader > refs = null ; <nl> diff - - git a / src / java / org / apache / cassandra / db / lifecycle / View . java b / src / java / org / apache / cassandra / db / lifecycle / View . java <nl> index 0d1100b . . 73ba131 100644 <nl> - - - a / src / java / org / apache / cassandra / db / lifecycle / View . java <nl> + + + b / src / java / org / apache / cassandra / db / lifecycle / View . java <nl> @ @ - 126 , 12 + 126 , 19 @ @ public class View <nl> return String . format ( " View ( pending _ count = % d , sstables = % s , compacting = % s ) " , liveMemtables . size ( ) + flushingMemtables . size ( ) - 1 , sstables , compacting ) ; <nl> } <nl> <nl> - public List < SSTableReader > sstablesInBounds ( AbstractBounds < RowPosition > rowBounds ) <nl> + / * * <nl> + * Returns the sstables that have any partition between { @ code left } and { @ code right } , when both bounds are taken inclusively . <nl> + * The interval formed by { @ code left } and { @ code right } shouldn ' t wrap . <nl> + * / <nl> + public List < SSTableReader > sstablesInBounds ( RowPosition left , RowPosition right ) <nl> { <nl> + assert ! AbstractBounds . strictlyWrapsAround ( left , right ) ; <nl> + <nl> if ( intervalTree . isEmpty ( ) ) <nl> return Collections . emptyList ( ) ; <nl> - RowPosition stopInTree = rowBounds . right . isMinimum ( ) ? intervalTree . max ( ) : rowBounds . right ; <nl> - return intervalTree . search ( Interval . < RowPosition , SSTableReader > create ( rowBounds . left , stopInTree ) ) ; <nl> + <nl> + RowPosition stopInTree = right . isMinimum ( ) ? intervalTree . max ( ) : right ; <nl> + return intervalTree . search ( Interval . < RowPosition , SSTableReader > create ( left , stopInTree ) ) ; <nl> } <nl> <nl> / / METHODS TO CONSTRUCT FUNCTIONS FOR MODIFYING A VIEW : <nl> diff - - git a / src / java / org / apache / cassandra / dht / AbstractBounds . java b / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> index b5ffc22 . . c33ffc0 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . dht ; <nl> import java . io . DataInput ; <nl> import java . io . IOException ; <nl> import java . io . Serializable ; <nl> + import java . util . Collection ; <nl> import java . util . List ; <nl> <nl> import org . apache . cassandra . db . DecoratedKey ; <nl> @ @ - 71 , 6 + 72 , 30 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria <nl> public abstract boolean inclusiveLeft ( ) ; <nl> public abstract boolean inclusiveRight ( ) ; <nl> <nl> + / * * <nl> + * Whether { @ code left } and { @ code right } forms a wrapping interval , that is if unwrapping wouldn ' t be a no - op . <nl> + * < p > <nl> + * Note that the semantic is slightly different from { @ link Range # isWrapAround ( ) } in the sense that if both <nl> + * { @ code right } are minimal ( for the partitioner ) , this methods return false ( doesn ' t wrap ) while <nl> + * { @ link Range # isWrapAround ( ) } returns true ( does wrap ) . This is confusing and we should fix it by <nl> + * refactoring / rewriting the whole AbstractBounds hierarchy with cleaner semantics , but we don ' t want to risk <nl> + * breaking something by changing { @ link Range # isWrapAround ( ) } in the meantime . <nl> + * / <nl> + public static < T extends RingPosition < T > > boolean strictlyWrapsAround ( T left , T right ) <nl> + { <nl> + return ! ( left . compareTo ( right ) < = 0 | | right . isMinimum ( ) ) ; <nl> + } <nl> + <nl> + public static < T extends RingPosition < T > > boolean noneStrictlyWrapsAround ( Collection < AbstractBounds < T > > bounds ) <nl> + { <nl> + for ( AbstractBounds < T > b : bounds ) <nl> + { <nl> + if ( strictlyWrapsAround ( b . left , b . right ) ) <nl> + return false ; <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> @ Override <nl> public int hashCode ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java <nl> index 4a5a701 . . 9060bcf 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Bounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / Bounds . java <nl> @ @ - 32 , 7 + 32 , 7 @ @ public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > <nl> { <nl> super ( left , right ) ; <nl> / / unlike a Range , a Bounds may not wrap <nl> - assert left . compareTo ( right ) < = 0 | | right . isMinimum ( ) : " [ " + left + " , " + right + " ] " ; <nl> + assert ! strictlyWrapsAround ( left , right ) : " [ " + left + " , " + right + " ] " ; <nl> } <nl> <nl> public boolean contains ( T position ) <nl> diff - - git a / src / java / org / apache / cassandra / dht / ExcludingBounds . java b / src / java / org / apache / cassandra / dht / ExcludingBounds . java <nl> index 0d37e5c . . 7319356 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / ExcludingBounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / ExcludingBounds . java <nl> @ @ - 31 , 7 + 31 , 7 @ @ public class ExcludingBounds < T extends RingPosition < T > > extends AbstractBounds < T <nl> { <nl> super ( left , right ) ; <nl> / / unlike a Range , an ExcludingBounds may not wrap , nor be empty <nl> - assert left . compareTo ( right ) < 0 | | right . isMinimum ( ) : " ( " + left + " , " + right + " ) " ; <nl> + assert ! strictlyWrapsAround ( left , right ) & & ( right . isMinimum ( ) | | left . compareTo ( right ) ! = 0 ) : " ( " + left + " , " + right + " ) " ; <nl> } <nl> <nl> public boolean contains ( T position ) <nl> diff - - git a / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java b / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java <nl> index e9e8e8e . . abcf87b 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java <nl> @ @ - 32 , 7 + 32 , 7 @ @ public class IncludingExcludingBounds < T extends RingPosition < T > > extends Abstrac <nl> super ( left , right ) ; <nl> / / unlike a Range , an IncludingExcludingBounds may not wrap , nor have <nl> / / right = = left unless the right is the min token <nl> - assert left . compareTo ( right ) < 0 | | right . isMinimum ( ) : " [ " + left + " , " + right + " ) " ; <nl> + assert ! strictlyWrapsAround ( left , right ) & & ( right . isMinimum ( ) | | left . compareTo ( right ) ! = 0 ) : " ( " + left + " , " + right + " ) " ; <nl> } <nl> <nl> public boolean contains ( T position ) <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> index 366bc33 . . 55d7e68 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> @ @ - 24 , 8 + 24 , 6 @ @ import java . util . * ; <nl> import java . util . concurrent . * ; <nl> import java . util . concurrent . atomic . AtomicBoolean ; <nl> <nl> - import javax . annotation . Nullable ; <nl> - <nl> import com . google . common . base . Function ; <nl> import com . google . common . collect . * ; <nl> <nl> @ @ - 38 , 7 + 36 , 6 @ @ import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . db . RowPosition ; <nl> - import org . apache . cassandra . dht . AbstractBounds ; <nl> import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . gms . * ; <nl> @ @ - 316 , 9 + 313 , 9 @ @ public class StreamSession implements IEndpointStateChangeSubscriber <nl> { <nl> for ( ColumnFamilyStore cfStore : stores ) <nl> { <nl> - final List < AbstractBounds < RowPosition > > rowBoundsList = new ArrayList < > ( ranges . size ( ) ) ; <nl> + final List < Range < RowPosition > > keyRanges = new ArrayList < > ( ranges . size ( ) ) ; <nl> for ( Range < Token > range : ranges ) <nl> - rowBoundsList . add ( Range . makeRowRange ( range ) ) ; <nl> + keyRanges . add ( Range . makeRowRange ( range ) ) ; <nl> refs . addAll ( cfStore . selectAndReference ( new Function < View , List < SSTableReader > > ( ) <nl> { <nl> public List < SSTableReader > apply ( View view ) <nl> @ @ - 328 , 11 + 325 , 17 @ @ public class StreamSession implements IEndpointStateChangeSubscriber <nl> permittedInstances . put ( reader , reader ) ; <nl> <nl> Set < SSTableReader > sstables = Sets . newHashSet ( ) ; <nl> - for ( AbstractBounds < RowPosition > rowBounds : rowBoundsList ) <nl> + for ( Range < RowPosition > keyRange : keyRanges ) <nl> { <nl> - / / sstableInBounds may contain early opened sstables <nl> - for ( SSTableReader sstable : view . sstablesInBounds ( rowBounds ) ) <nl> + / / keyRange excludes its start , while sstableInBounds is inclusive ( of both start and end ) . <nl> + / / This is fine however , because keyRange has been created from a token range through Range . makeRowRange ( see above ) . <nl> + / / And that later method uses the Token . maxKeyBound ( ) method to creates the range , which return a " fake " key that <nl> + / / sort after all keys having the token . That " fake " key cannot however be equal to any real key , so that even <nl> + / / including keyRange . left will still exclude any key having the token of the original token range , and so we ' re <nl> + / / still actually selecting what we wanted . <nl> + for ( SSTableReader sstable : view . sstablesInBounds ( keyRange . left , keyRange . right ) ) <nl> { <nl> + / / sstableInBounds may contain early opened sstables <nl> if ( isIncremental & & sstable . isRepaired ( ) ) <nl> continue ; <nl> sstable = permittedInstances . get ( sstable ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java b / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java <nl> index 4c8006a . . 32a81e2 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java <nl> @ @ - 61 , 13 + 61 , 14 @ @ public class ViewTest <nl> { <nl> RowPosition min = MockSchema . readerBounds ( i ) ; <nl> RowPosition max = MockSchema . readerBounds ( j ) ; <nl> - for ( boolean minInc : new boolean [ ] { true , false } ) <nl> + for ( boolean minInc : new boolean [ ] { true } ) / / , false } ) <nl> { <nl> - for ( boolean maxInc : new boolean [ ] { true , false } ) <nl> + for ( boolean maxInc : new boolean [ ] { true } ) / / , false } ) <nl> { <nl> if ( i = = j & & ! ( minInc & & maxInc ) ) <nl> continue ; <nl> - List < SSTableReader > r = initialView . sstablesInBounds ( AbstractBounds . bounds ( min , minInc , max , maxInc ) ) ; <nl> + AbstractBounds < RowPosition > bounds = AbstractBounds . bounds ( min , minInc , max , maxInc ) ; <nl> + List < SSTableReader > r = initialView . sstablesInBounds ( bounds . left , bounds . right ) ; <nl> Assert . assertEquals ( String . format ( " % d ( % s ) % d ( % s ) " , i , minInc , j , maxInc ) , j - i + ( minInc ? 0 : - 1 ) + ( maxInc ? 1 : 0 ) , r . size ( ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java <nl> index 87361d4 . . 9594525 100644 <nl> - - - a / src / java / org / apache / cassandra / cli / CliClient . java <nl> + + + b / src / java / org / apache / cassandra / cli / CliClient . java <nl> @ @ - 2924 , 11 + 2924 , 9 @ @ public class CliClient <nl> private boolean isCounterCF ( CfDef cfdef ) <nl> { <nl> String defaultValidator = cfdef . default _ validation _ class ; <nl> - if ( defaultValidator ! = null & & ! defaultValidator . isEmpty ( ) ) <nl> - { <nl> - return ( getFormatType ( defaultValidator ) instanceof CounterColumnType ) ; <nl> - } <nl> - return false ; <nl> + return defaultValidator ! = null <nl> + & & ! defaultValidator . isEmpty ( ) <nl> + & & getFormatType ( defaultValidator ) instanceof CounterColumnType ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / cli / Cql3CfDef . java b / src / java / org / apache / cassandra / cli / Cql3CfDef . java <nl> new file mode 100644 <nl> index 0000000 . . 6828e3d <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cli / Cql3CfDef . java <nl> @ @ - 0 , 0 + 1 , 5 @ @ <nl> + package org . apache . cassandra . cli ; <nl> + <nl> + public class Cql3CfDef <nl> + { <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / CFDefinition . java b / src / java / org / apache / cassandra / cql3 / CFDefinition . java <nl> index 980fb68 . . 670fdb4 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / CFDefinition . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / CFDefinition . java <nl> @ @ - 99 , 7 + 99 , 7 @ @ public class CFDefinition implements Iterable < CFDefinition . Name > <nl> int last = composite . types . size ( ) - 1 ; <nl> AbstractType < ? > lastType = composite . types . get ( last ) ; <nl> if ( lastType instanceof ColumnToCollectionType <nl> - | | ( cfm . getColumnAliases ( ) . size ( ) = = last & & lastType instanceof UTF8Type ) ) <nl> + | | ( cfm . getColumnAliases ( ) . size ( ) = = last & & lastType instanceof UTF8Type ) ) <nl> { <nl> / / " sparse " composite <nl> this . isCompact = false ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 482e3ee . . 8bda6b2 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1929 , 11 + 1929 , 17 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 * / 
 public Function < View , List < SSTableReader > > viewFilter ( final AbstractBounds < RowPosition > rowBounds ) 
 { 
 + assert ! AbstractBounds . strictlyWrapsAround ( rowBounds . left , rowBounds . right ) ; 
 return new Function < View , List < SSTableReader > > ( ) 
 { 
 public List < SSTableReader > apply ( View view ) 
 { 
 - return compactionStrategyWrapper . filterSSTablesForReads ( view . sstablesInBounds ( rowBounds ) ) ; 
 + / / Note that View . sstablesInBounds always includes it ' s bound while rowBounds may not . This is ok however 
 + / / because the fact we restrict the sstables returned by this function is an optimization in the first 
 + / / place and the returned sstables will ( almost ) never cover * exactly * rowBounds anyway . It ' s also 
 + / / * very * unlikely that a sstable is included * just * because we consider one of the bound inclusively 
 + / / instead of exclusively , so the performance impact is negligible in practice . 
 + return view . sstablesInBounds ( rowBounds . left , rowBounds . right ) ; 
 } 
 } ; 
 } 
 @ @ - 1944 , 6 + 1950 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 * / 
 public Function < View , List < SSTableReader > > viewFilter ( final Collection < AbstractBounds < RowPosition > > rowBoundsCollection , final boolean includeRepaired ) 
 { 
 + assert AbstractBounds . noneStrictlyWrapsAround ( rowBoundsCollection ) ; 
 return new Function < View , List < SSTableReader > > ( ) 
 { 
 public List < SSTableReader > apply ( View view ) 
 @ @ - 1951 , 7 + 1958 , 12 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 Set < SSTableReader > sstables = Sets . newHashSet ( ) ; 
 for ( AbstractBounds < RowPosition > rowBounds : rowBoundsCollection ) 
 { 
 - for ( SSTableReader sstable : view . sstablesInBounds ( rowBounds ) ) 
 + / / Note that View . sstablesInBounds always includes it ' s bound while rowBounds may not . This is ok however 
 + / / because the fact we restrict the sstables returned by this function is an optimization in the first 
 + / / place and the returned sstables will ( almost ) never cover * exactly * rowBounds anyway . It ' s also 
 + / / * very * unlikely that a sstable is included * just * because we consider one of the bound inclusively 
 + / / instead of exclusively , so the performance impact is negligible in practice . 
 + for ( SSTableReader sstable : view . sstablesInBounds ( rowBounds . left , rowBounds . right ) ) 
 { 
 if ( includeRepaired | | ! sstable . isRepaired ( ) ) 
 sstables . add ( sstable ) ; 
 @ @ - 2335 , 7 + 2347 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 if ( ! manifestFile . getParentFile ( ) . exists ( ) ) 
 manifestFile . getParentFile ( ) . mkdirs ( ) ; 
 - 
 + 
 try ( PrintStream out = new PrintStream ( manifestFile ) ) 
 { 
 final JSONObject manifestJSON = new JSONObject ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java b / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java 
 index c68109c . . f054315 100644 
 - - - a / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java 
 + + + b / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java 
 @ @ - 85 , 9 + 85 , 10 @ @ public class SizeEstimatesRecorder extends MigrationListener implements Runnable 
 @ SuppressWarnings ( " resource " ) 
 private void recordSizeEstimates ( ColumnFamilyStore table , Collection < Range < Token > > localRanges ) 
 { 
 + List < Range < Token > > unwrappedRanges = Range . normalize ( localRanges ) ; 
 / / for each local primary range , estimate ( crudely ) mean partition size and partitions count . 
 Map < Range < Token > , Pair < Long , Long > > estimates = new HashMap < > ( localRanges . size ( ) ) ; 
 - for ( Range < Token > range : localRanges ) 
 + for ( Range < Token > range : unwrappedRanges ) 
 { 
 / / filter sstables that have partitions in this range . 
 Refs < SSTableReader > refs = null ; 
 diff - - git a / src / java / org / apache / cassandra / db / lifecycle / View . java b / src / java / org / apache / cassandra / db / lifecycle / View . java 
 index 0d1100b . . 73ba131 100644 
 - - - a / src / java / org / apache / cassandra / db / lifecycle / View . java 
 + + + b / src / java / org / apache / cassandra / db / lifecycle / View . java 
 @ @ - 126 , 12 + 126 , 19 @ @ public class View 
 return String . format ( " View ( pending _ count = % d , sstables = % s , compacting = % s ) " , liveMemtables . size ( ) + flushingMemtables . size ( ) - 1 , sstables , compacting ) ; 
 } 
 
 - public List < SSTableReader > sstablesInBounds ( AbstractBounds < RowPosition > rowBounds ) 
 + / * * 
 + * Returns the sstables that have any partition between { @ code left } and { @ code right } , when both bounds are taken inclusively . 
 + * The interval formed by { @ code left } and { @ code right } shouldn ' t wrap . 
 + * / 
 + public List < SSTableReader > sstablesInBounds ( RowPosition left , RowPosition right ) 
 { 
 + assert ! AbstractBounds . strictlyWrapsAround ( left , right ) ; 
 + 
 if ( intervalTree . isEmpty ( ) ) 
 return Collections . emptyList ( ) ; 
 - RowPosition stopInTree = rowBounds . right . isMinimum ( ) ? intervalTree . max ( ) : rowBounds . right ; 
 - return intervalTree . search ( Interval . < RowPosition , SSTableReader > create ( rowBounds . left , stopInTree ) ) ; 
 + 
 + RowPosition stopInTree = right . isMinimum ( ) ? intervalTree . max ( ) : right ; 
 + return intervalTree . search ( Interval . < RowPosition , SSTableReader > create ( left , stopInTree ) ) ; 
 } 
 
 / / METHODS TO CONSTRUCT FUNCTIONS FOR MODIFYING A VIEW : 
 diff - - git a / src / java / org / apache / cassandra / dht / AbstractBounds . java b / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 index b5ffc22 . . c33ffc0 100644 
 - - - a / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 + + + b / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . dht ; 
 import java . io . DataInput ; 
 import java . io . IOException ; 
 import java . io . Serializable ; 
 + import java . util . Collection ; 
 import java . util . List ; 
 
 import org . apache . cassandra . db . DecoratedKey ; 
 @ @ - 71 , 6 + 72 , 30 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria 
 public abstract boolean inclusiveLeft ( ) ; 
 public abstract boolean inclusiveRight ( ) ; 
 
 + / * * 
 + * Whether { @ code left } and { @ code right } forms a wrapping interval , that is if unwrapping wouldn ' t be a no - op . 
 + * < p > 
 + * Note that the semantic is slightly different from { @ link Range # isWrapAround ( ) } in the sense that if both 
 + * { @ code right } are minimal ( for the partitioner ) , this methods return false ( doesn ' t wrap ) while 
 + * { @ link Range # isWrapAround ( ) } returns true ( does wrap ) . This is confusing and we should fix it by 
 + * refactoring / rewriting the whole AbstractBounds hierarchy with cleaner semantics , but we don ' t want to risk 
 + * breaking something by changing { @ link Range # isWrapAround ( ) } in the meantime . 
 + * / 
 + public static < T extends RingPosition < T > > boolean strictlyWrapsAround ( T left , T right ) 
 + { 
 + return ! ( left . compareTo ( right ) < = 0 | | right . isMinimum ( ) ) ; 
 + } 
 + 
 + public static < T extends RingPosition < T > > boolean noneStrictlyWrapsAround ( Collection < AbstractBounds < T > > bounds ) 
 + { 
 + for ( AbstractBounds < T > b : bounds ) 
 + { 
 + if ( strictlyWrapsAround ( b . left , b . right ) ) 
 + return false ; 
 + } 
 + return true ; 
 + } 
 + 
 @ Override 
 public int hashCode ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java 
 index 4a5a701 . . 9060bcf 100644 
 - - - a / src / java / org / apache / cassandra / dht / Bounds . java 
 + + + b / src / java / org / apache / cassandra / dht / Bounds . java 
 @ @ - 32 , 7 + 32 , 7 @ @ public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > 
 { 
 super ( left , right ) ; 
 / / unlike a Range , a Bounds may not wrap 
 - assert left . compareTo ( right ) < = 0 | | right . isMinimum ( ) : " [ " + left + " , " + right + " ] " ; 
 + assert ! strictlyWrapsAround ( left , right ) : " [ " + left + " , " + right + " ] " ; 
 } 
 
 public boolean contains ( T position ) 
 diff - - git a / src / java / org / apache / cassandra / dht / ExcludingBounds . java b / src / java / org / apache / cassandra / dht / ExcludingBounds . java 
 index 0d37e5c . . 7319356 100644 
 - - - a / src / java / org / apache / cassandra / dht / ExcludingBounds . java 
 + + + b / src / java / org / apache / cassandra / dht / ExcludingBounds . java 
 @ @ - 31 , 7 + 31 , 7 @ @ public class ExcludingBounds < T extends RingPosition < T > > extends AbstractBounds < T 
 { 
 super ( left , right ) ; 
 / / unlike a Range , an ExcludingBounds may not wrap , nor be empty 
 - assert left . compareTo ( right ) < 0 | | right . isMinimum ( ) : " ( " + left + " , " + right + " ) " ; 
 + assert ! strictlyWrapsAround ( left , right ) & & ( right . isMinimum ( ) | | left . compareTo ( right ) ! = 0 ) : " ( " + left + " , " + right + " ) " ; 
 } 
 
 public boolean contains ( T position ) 
 diff - - git a / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java b / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java 
 index e9e8e8e . . abcf87b 100644 
 - - - a / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java 
 + + + b / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java 
 @ @ - 32 , 7 + 32 , 7 @ @ public class IncludingExcludingBounds < T extends RingPosition < T > > extends Abstrac 
 super ( left , right ) ; 
 / / unlike a Range , an IncludingExcludingBounds may not wrap , nor have 
 / / right = = left unless the right is the min token 
 - assert left . compareTo ( right ) < 0 | | right . isMinimum ( ) : " [ " + left + " , " + right + " ) " ; 
 + assert ! strictlyWrapsAround ( left , right ) & & ( right . isMinimum ( ) | | left . compareTo ( right ) ! = 0 ) : " ( " + left + " , " + right + " ) " ; 
 } 
 
 public boolean contains ( T position ) 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 index 366bc33 . . 55d7e68 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 @ @ - 24 , 8 + 24 , 6 @ @ import java . util . * ; 
 import java . util . concurrent . * ; 
 import java . util . concurrent . atomic . AtomicBoolean ; 
 
 - import javax . annotation . Nullable ; 
 - 
 import com . google . common . base . Function ; 
 import com . google . common . collect . * ; 
 
 @ @ - 38 , 7 + 36 , 6 @ @ import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . db . RowPosition ; 
 - import org . apache . cassandra . dht . AbstractBounds ; 
 import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . gms . * ; 
 @ @ - 316 , 9 + 313 , 9 @ @ public class StreamSession implements IEndpointStateChangeSubscriber 
 { 
 for ( ColumnFamilyStore cfStore : stores ) 
 { 
 - final List < AbstractBounds < RowPosition > > rowBoundsList = new ArrayList < > ( ranges . size ( ) ) ; 
 + final List < Range < RowPosition > > keyRanges = new ArrayList < > ( ranges . size ( ) ) ; 
 for ( Range < Token > range : ranges ) 
 - rowBoundsList . add ( Range . makeRowRange ( range ) ) ; 
 + keyRanges . add ( Range . makeRowRange ( range ) ) ; 
 refs . addAll ( cfStore . selectAndReference ( new Function < View , List < SSTableReader > > ( ) 
 { 
 public List < SSTableReader > apply ( View view ) 
 @ @ - 328 , 11 + 325 , 17 @ @ public class StreamSession implements IEndpointStateChangeSubscriber 
 permittedInstances . put ( reader , reader ) ; 
 
 Set < SSTableReader > sstables = Sets . newHashSet ( ) ; 
 - for ( AbstractBounds < RowPosition > rowBounds : rowBoundsList ) 
 + for ( Range < RowPosition > keyRange : keyRanges ) 
 { 
 - / / sstableInBounds may contain early opened sstables 
 - for ( SSTableReader sstable : view . sstablesInBounds ( rowBounds ) ) 
 + / / keyRange excludes its start , while sstableInBounds is inclusive ( of both start and end ) . 
 + / / This is fine however , because keyRange has been created from a token range through Range . makeRowRange ( see above ) . 
 + / / And that later method uses the Token . maxKeyBound ( ) method to creates the range , which return a " fake " key that 
 + / / sort after all keys having the token . That " fake " key cannot however be equal to any real key , so that even 
 + / / including keyRange . left will still exclude any key having the token of the original token range , and so we ' re 
 + / / still actually selecting what we wanted . 
 + for ( SSTableReader sstable : view . sstablesInBounds ( keyRange . left , keyRange . right ) ) 
 { 
 + / / sstableInBounds may contain early opened sstables 
 if ( isIncremental & & sstable . isRepaired ( ) ) 
 continue ; 
 sstable = permittedInstances . get ( sstable ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java b / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java 
 index 4c8006a . . 32a81e2 100644 
 - - - a / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java 
 + + + b / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java 
 @ @ - 61 , 13 + 61 , 14 @ @ public class ViewTest 
 { 
 RowPosition min = MockSchema . readerBounds ( i ) ; 
 RowPosition max = MockSchema . readerBounds ( j ) ; 
 - for ( boolean minInc : new boolean [ ] { true , false } ) 
 + for ( boolean minInc : new boolean [ ] { true } ) / / , false } ) 
 { 
 - for ( boolean maxInc : new boolean [ ] { true , false } ) 
 + for ( boolean maxInc : new boolean [ ] { true } ) / / , false } ) 
 { 
 if ( i = = j & & ! ( minInc & & maxInc ) ) 
 continue ; 
 - List < SSTableReader > r = initialView . sstablesInBounds ( AbstractBounds . bounds ( min , minInc , max , maxInc ) ) ; 
 + AbstractBounds < RowPosition > bounds = AbstractBounds . bounds ( min , minInc , max , maxInc ) ; 
 + List < SSTableReader > r = initialView . sstablesInBounds ( bounds . left , bounds . right ) ; 
 Assert . assertEquals ( String . format ( " % d ( % s ) % d ( % s ) " , i , minInc , j , maxInc ) , j - i + ( minInc ? 0 : - 1 ) + ( maxInc ? 1 : 0 ) , r . size ( ) ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java 
 index 87361d4 . . 9594525 100644 
 - - - a / src / java / org / apache / cassandra / cli / CliClient . java 
 + + + b / src / java / org / apache / cassandra / cli / CliClient . java 
 @ @ - 2924 , 11 + 2924 , 9 @ @ public class CliClient 
 private boolean isCounterCF ( CfDef cfdef ) 
 { 
 String defaultValidator = cfdef . default _ validation _ class ; 
 - if ( defaultValidator ! = null & & ! defaultValidator . isEmpty ( ) ) 
 - { 
 - return ( getFormatType ( defaultValidator ) instanceof CounterColumnType ) ; 
 - } 
 - return false ; 
 + return defaultValidator ! = null 
 + & & ! defaultValidator . isEmpty ( ) 
 + & & getFormatType ( defaultValidator ) instanceof CounterColumnType ; 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / cli / Cql3CfDef . java b / src / java / org / apache / cassandra / cli / Cql3CfDef . java 
 new file mode 100644 
 index 0000000 . . 6828e3d 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cli / Cql3CfDef . java 
 @ @ - 0 , 0 + 1 , 5 @ @ 
 + package org . apache . cassandra . cli ; 
 + 
 + public class Cql3CfDef 
 + { 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / CFDefinition . java b / src / java / org / apache / cassandra / cql3 / CFDefinition . java 
 index 980fb68 . . 670fdb4 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / CFDefinition . java 
 + + + b / src / java / org / apache / cassandra / cql3 / CFDefinition . java 
 @ @ - 99 , 7 + 99 , 7 @ @ public class CFDefinition implements Iterable < CFDefinition . Name > 
 int last = composite . types . size ( ) - 1 ; 
 AbstractType < ? > lastType = composite . types . get ( last ) ; 
 if ( lastType instanceof ColumnToCollectionType 
 - | | ( cfm . getColumnAliases ( ) . size ( ) = = last & & lastType instanceof UTF8Type ) ) 
 + | | ( cfm . getColumnAliases ( ) . size ( ) = = last & & lastType instanceof UTF8Type ) ) 
 { 
 / / " sparse " composite 
 this . isCompact = false ;
