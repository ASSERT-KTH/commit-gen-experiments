BLEU SCORE: 0.02276859592073037

TEST MSG: Duplicate rows after upgrading from 2 . 1 . 16 to 3 . 0 . 10 / 3 . 9
GENERATED MSG: Disable passing control to post - flush after flush failure to prevent

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 4387019 . . 7da61e7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 11 <nl> + * Duplicate rows after upgrading from 2 . 1 . 16 to 3 . 0 . 10 / 3 . 9 ( CASSANDRA - 13125 ) <nl> * Fix UPDATE queries with empty IN restrictions ( CASSANDRA - 13152 ) <nl> * Abort or retry on failed hints delivery ( CASSANDRA - 13124 ) <nl> * Fix handling of partition with partition - level deletion plus <nl> diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> index 3f69671 . . 3788c3c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> @ @ - 1803 , 17 + 1803 , 42 @ @ public abstract class LegacyLayout <nl> if ( a . isStatic ! = b . isStatic ) <nl> return a . isStatic ? - 1 : 1 ; <nl> <nl> - int result = this . clusteringComparator . compare ( a . bound , b . bound ) ; <nl> - if ( result ! = 0 ) <nl> - return result ; <nl> + / / We have to be careful with bound comparison because of collections . Namely , if the 2 bounds represent the <nl> + / / same prefix , then we should take the collectionName into account before taking the bounds kind <nl> + / / ( ClusteringPrefix . Kind ) . This means we can ' t really call ClusteringComparator . compare ( ) directly . <nl> + / / For instance , if <nl> + / / a is ( bound = INCL _ START _ BOUND ( ' x ' ) , collectionName = ' d ' ) <nl> + / / b is ( bound = INCL _ END _ BOUND ( ' x ' ) , collectionName = ' c ' ) <nl> + / / Ten b < a since the element ' c ' of collection ' x ' comes before element ' d ' , but calling <nl> + / / clusteringComparator . compare ( a . bound , b . bound ) returns - 1 . <nl> + / / See CASSANDRA - 13125 for details . <nl> + int sa = a . bound . size ( ) ; <nl> + int sb = b . bound . size ( ) ; <nl> + for ( int i = 0 ; i < Math . min ( sa , sb ) ; i + + ) <nl> + { <nl> + int cmp = clusteringComparator . compareComponent ( i , a . bound . get ( i ) , b . bound . get ( i ) ) ; <nl> + if ( cmp ! = 0 ) <nl> + return cmp ; <nl> + } <nl> + <nl> + if ( sa ! = sb ) <nl> + return sa < sb ? a . bound . kind ( ) . comparedToClustering : - b . bound . kind ( ) . comparedToClustering ; <nl> + <nl> + / / Both bound represent the same prefix , compare the collection names <nl> + / / If one has a collection name and the other doesn ' t , the other comes before as it points to the beginning of the row . <nl> + if ( ( a . collectionName = = null ) ! = ( b . collectionName = = null ) ) <nl> + return a . collectionName = = null ? - 1 : 1 ; <nl> <nl> - / / If both have equal " bound " but one is a collection tombstone and not the other , then the other comes before as it points to the beginning of the row . <nl> - if ( a . collectionName = = null ) <nl> - return b . collectionName = = null ? 0 : 1 ; <nl> - if ( b . collectionName = = null ) <nl> - return - 1 ; <nl> + / / If they both have a collection , compare that first <nl> + if ( a . collectionName ! = null ) <nl> + { <nl> + int cmp = UTF8Type . instance . compare ( a . collectionName . name . bytes , b . collectionName . name . bytes ) ; <nl> + if ( cmp ! = 0 ) <nl> + return cmp ; <nl> + } <nl> <nl> - return UTF8Type . instance . compare ( a . collectionName . name . bytes , b . collectionName . name . bytes ) ; <nl> + / / Lastly , if everything so far is equal , compare their clustering kind <nl> + return ClusteringPrefix . Kind . compare ( a . bound . kind ( ) , b . bound . kind ( ) ) ; <nl> } <nl> } <nl> <nl> @ @ - 1830 , 8 + 1855 , 8 @ @ public abstract class LegacyLayout <nl> <nl> / / Note : we don ' t want to use a List for the markedAts and delTimes to avoid boxing . We could <nl> / / use a List for starts and ends , but having arrays everywhere is almost simpler . <nl> - private LegacyBound [ ] starts ; <nl> - private LegacyBound [ ] ends ; <nl> + LegacyBound [ ] starts ; <nl> + LegacyBound [ ] ends ; <nl> private long [ ] markedAts ; <nl> private int [ ] delTimes ; <nl> <nl> @ @ - 1853 , 6 + 1878 , 20 @ @ public abstract class LegacyLayout <nl> this ( comparator , new LegacyBound [ capacity ] , new LegacyBound [ capacity ] , new long [ capacity ] , new int [ capacity ] , 0 ) ; <nl> } <nl> <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + sb . append ( ' [ ' ) ; <nl> + for ( int i = 0 ; i < size ; i + + ) <nl> + { <nl> + if ( i > 0 ) <nl> + sb . append ( ' , ' ) ; <nl> + sb . append ( ' ( ' ) . append ( starts [ i ] ) . append ( " , " ) . append ( ends [ i ] ) . append ( ' ) ' ) ; <nl> + } <nl> + return sb . append ( ' ] ' ) . toString ( ) ; <nl> + } <nl> + <nl> public boolean isEmpty ( ) <nl> { <nl> return size = = 0 ; <nl> @ @ - 2107 , 6 + 2146 , 7 @ @ public abstract class LegacyLayout <nl> / / If we got there , then just insert the remainder at the end <nl> addInternal ( i , start , end , markedAt , delTime ) ; <nl> } <nl> + <nl> private int capacity ( ) <nl> { <nl> return starts . length ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / LegacyLayoutTest . java b / test / unit / org / apache / cassandra / db / LegacyLayoutTest . java <nl> new file mode 100644 <nl> index 0000000 . . 09e9755 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / LegacyLayoutTest . java <nl> @ @ - 0 , 0 + 1 , 71 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . db ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . config . ColumnDefinition ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> + import org . apache . cassandra . db . marshal . Int32Type ; <nl> + import org . apache . cassandra . db . marshal . SetType ; <nl> + import org . apache . cassandra . db . partitions . PartitionUpdate ; <nl> + import org . apache . cassandra . db . rows . BTreeRow ; <nl> + import org . apache . cassandra . db . rows . Row ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> + import static org . junit . Assert . * ; <nl> + <nl> + public class LegacyLayoutTest <nl> + { <nl> + @ Test <nl> + public void testFromUnfilteredRowIterator ( ) throws Throwable <nl> + { <nl> + CFMetaData table = CFMetaData . Builder . create ( " ks " , " table " ) <nl> + . addPartitionKey ( " k " , Int32Type . instance ) <nl> + . addRegularColumn ( " a " , SetType . getInstance ( Int32Type . instance , true ) ) <nl> + . addRegularColumn ( " b " , SetType . getInstance ( Int32Type . instance , true ) ) <nl> + . build ( ) ; <nl> + <nl> + ColumnDefinition a = table . getColumnDefinition ( new ColumnIdentifier ( " a " , false ) ) ; <nl> + ColumnDefinition b = table . getColumnDefinition ( new ColumnIdentifier ( " b " , false ) ) ; <nl> + <nl> + Row . Builder builder = BTreeRow . unsortedBuilder ( 0 ) ; <nl> + builder . newRow ( Clustering . EMPTY ) ; <nl> + builder . addComplexDeletion ( a , new DeletionTime ( 1L , 1 ) ) ; <nl> + builder . addComplexDeletion ( b , new DeletionTime ( 1L , 1 ) ) ; <nl> + Row row = builder . build ( ) ; <nl> + <nl> + ByteBuffer key = ByteBufferUtil . bytes ( 1 ) ; <nl> + PartitionUpdate upd = PartitionUpdate . singleRowUpdate ( table , key , row ) ; <nl> + <nl> + LegacyLayout . LegacyUnfilteredPartition p = LegacyLayout . fromUnfilteredRowIterator ( null , upd . unfilteredIterator ( ) ) ; <nl> + assertEquals ( DeletionTime . LIVE , p . partitionDeletion ) ; <nl> + assertEquals ( 0 , p . cells . size ( ) ) ; <nl> + <nl> + LegacyLayout . LegacyRangeTombstoneList l = p . rangeTombstones ; <nl> + assertEquals ( " a " , l . starts [ 0 ] . collectionName . name . toString ( ) ) ; <nl> + assertEquals ( " a " , l . ends [ 0 ] . collectionName . name . toString ( ) ) ; <nl> + <nl> + assertEquals ( " b " , l . starts [ 1 ] . collectionName . name . toString ( ) ) ; <nl> + assertEquals ( " b " , l . ends [ 1 ] . collectionName . name . toString ( ) ) ; <nl> + } <nl> + } <nl> \ No newline at end of file
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 4387019 . . 7da61e7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 11 
 + * Duplicate rows after upgrading from 2 . 1 . 16 to 3 . 0 . 10 / 3 . 9 ( CASSANDRA - 13125 ) 
 * Fix UPDATE queries with empty IN restrictions ( CASSANDRA - 13152 ) 
 * Abort or retry on failed hints delivery ( CASSANDRA - 13124 ) 
 * Fix handling of partition with partition - level deletion plus 
 diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 index 3f69671 . . 3788c3c 100644 
 - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java 
 + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 @ @ - 1803 , 17 + 1803 , 42 @ @ public abstract class LegacyLayout 
 if ( a . isStatic ! = b . isStatic ) 
 return a . isStatic ? - 1 : 1 ; 
 
 - int result = this . clusteringComparator . compare ( a . bound , b . bound ) ; 
 - if ( result ! = 0 ) 
 - return result ; 
 + / / We have to be careful with bound comparison because of collections . Namely , if the 2 bounds represent the 
 + / / same prefix , then we should take the collectionName into account before taking the bounds kind 
 + / / ( ClusteringPrefix . Kind ) . This means we can ' t really call ClusteringComparator . compare ( ) directly . 
 + / / For instance , if 
 + / / a is ( bound = INCL _ START _ BOUND ( ' x ' ) , collectionName = ' d ' ) 
 + / / b is ( bound = INCL _ END _ BOUND ( ' x ' ) , collectionName = ' c ' ) 
 + / / Ten b < a since the element ' c ' of collection ' x ' comes before element ' d ' , but calling 
 + / / clusteringComparator . compare ( a . bound , b . bound ) returns - 1 . 
 + / / See CASSANDRA - 13125 for details . 
 + int sa = a . bound . size ( ) ; 
 + int sb = b . bound . size ( ) ; 
 + for ( int i = 0 ; i < Math . min ( sa , sb ) ; i + + ) 
 + { 
 + int cmp = clusteringComparator . compareComponent ( i , a . bound . get ( i ) , b . bound . get ( i ) ) ; 
 + if ( cmp ! = 0 ) 
 + return cmp ; 
 + } 
 + 
 + if ( sa ! = sb ) 
 + return sa < sb ? a . bound . kind ( ) . comparedToClustering : - b . bound . kind ( ) . comparedToClustering ; 
 + 
 + / / Both bound represent the same prefix , compare the collection names 
 + / / If one has a collection name and the other doesn ' t , the other comes before as it points to the beginning of the row . 
 + if ( ( a . collectionName = = null ) ! = ( b . collectionName = = null ) ) 
 + return a . collectionName = = null ? - 1 : 1 ; 
 
 - / / If both have equal " bound " but one is a collection tombstone and not the other , then the other comes before as it points to the beginning of the row . 
 - if ( a . collectionName = = null ) 
 - return b . collectionName = = null ? 0 : 1 ; 
 - if ( b . collectionName = = null ) 
 - return - 1 ; 
 + / / If they both have a collection , compare that first 
 + if ( a . collectionName ! = null ) 
 + { 
 + int cmp = UTF8Type . instance . compare ( a . collectionName . name . bytes , b . collectionName . name . bytes ) ; 
 + if ( cmp ! = 0 ) 
 + return cmp ; 
 + } 
 
 - return UTF8Type . instance . compare ( a . collectionName . name . bytes , b . collectionName . name . bytes ) ; 
 + / / Lastly , if everything so far is equal , compare their clustering kind 
 + return ClusteringPrefix . Kind . compare ( a . bound . kind ( ) , b . bound . kind ( ) ) ; 
 } 
 } 
 
 @ @ - 1830 , 8 + 1855 , 8 @ @ public abstract class LegacyLayout 
 
 / / Note : we don ' t want to use a List for the markedAts and delTimes to avoid boxing . We could 
 / / use a List for starts and ends , but having arrays everywhere is almost simpler . 
 - private LegacyBound [ ] starts ; 
 - private LegacyBound [ ] ends ; 
 + LegacyBound [ ] starts ; 
 + LegacyBound [ ] ends ; 
 private long [ ] markedAts ; 
 private int [ ] delTimes ; 
 
 @ @ - 1853 , 6 + 1878 , 20 @ @ public abstract class LegacyLayout 
 this ( comparator , new LegacyBound [ capacity ] , new LegacyBound [ capacity ] , new long [ capacity ] , new int [ capacity ] , 0 ) ; 
 } 
 
 + @ Override 
 + public String toString ( ) 
 + { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + sb . append ( ' [ ' ) ; 
 + for ( int i = 0 ; i < size ; i + + ) 
 + { 
 + if ( i > 0 ) 
 + sb . append ( ' , ' ) ; 
 + sb . append ( ' ( ' ) . append ( starts [ i ] ) . append ( " , " ) . append ( ends [ i ] ) . append ( ' ) ' ) ; 
 + } 
 + return sb . append ( ' ] ' ) . toString ( ) ; 
 + } 
 + 
 public boolean isEmpty ( ) 
 { 
 return size = = 0 ; 
 @ @ - 2107 , 6 + 2146 , 7 @ @ public abstract class LegacyLayout 
 / / If we got there , then just insert the remainder at the end 
 addInternal ( i , start , end , markedAt , delTime ) ; 
 } 
 + 
 private int capacity ( ) 
 { 
 return starts . length ; 
 diff - - git a / test / unit / org / apache / cassandra / db / LegacyLayoutTest . java b / test / unit / org / apache / cassandra / db / LegacyLayoutTest . java 
 new file mode 100644 
 index 0000000 . . 09e9755 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / LegacyLayoutTest . java 
 @ @ - 0 , 0 + 1 , 71 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . db ; 
 + 
 + import java . nio . ByteBuffer ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . config . ColumnDefinition ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 + import org . apache . cassandra . db . marshal . Int32Type ; 
 + import org . apache . cassandra . db . marshal . SetType ; 
 + import org . apache . cassandra . db . partitions . PartitionUpdate ; 
 + import org . apache . cassandra . db . rows . BTreeRow ; 
 + import org . apache . cassandra . db . rows . Row ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 + import static org . junit . Assert . * ; 
 + 
 + public class LegacyLayoutTest 
 + { 
 + @ Test 
 + public void testFromUnfilteredRowIterator ( ) throws Throwable 
 + { 
 + CFMetaData table = CFMetaData . Builder . create ( " ks " , " table " ) 
 + . addPartitionKey ( " k " , Int32Type . instance ) 
 + . addRegularColumn ( " a " , SetType . getInstance ( Int32Type . instance , true ) ) 
 + . addRegularColumn ( " b " , SetType . getInstance ( Int32Type . instance , true ) ) 
 + . build ( ) ; 
 + 
 + ColumnDefinition a = table . getColumnDefinition ( new ColumnIdentifier ( " a " , false ) ) ; 
 + ColumnDefinition b = table . getColumnDefinition ( new ColumnIdentifier ( " b " , false ) ) ; 
 + 
 + Row . Builder builder = BTreeRow . unsortedBuilder ( 0 ) ; 
 + builder . newRow ( Clustering . EMPTY ) ; 
 + builder . addComplexDeletion ( a , new DeletionTime ( 1L , 1 ) ) ; 
 + builder . addComplexDeletion ( b , new DeletionTime ( 1L , 1 ) ) ; 
 + Row row = builder . build ( ) ; 
 + 
 + ByteBuffer key = ByteBufferUtil . bytes ( 1 ) ; 
 + PartitionUpdate upd = PartitionUpdate . singleRowUpdate ( table , key , row ) ; 
 + 
 + LegacyLayout . LegacyUnfilteredPartition p = LegacyLayout . fromUnfilteredRowIterator ( null , upd . unfilteredIterator ( ) ) ; 
 + assertEquals ( DeletionTime . LIVE , p . partitionDeletion ) ; 
 + assertEquals ( 0 , p . cells . size ( ) ) ; 
 + 
 + LegacyLayout . LegacyRangeTombstoneList l = p . rangeTombstones ; 
 + assertEquals ( " a " , l . starts [ 0 ] . collectionName . name . toString ( ) ) ; 
 + assertEquals ( " a " , l . ends [ 0 ] . collectionName . name . toString ( ) ) ; 
 + 
 + assertEquals ( " b " , l . starts [ 1 ] . collectionName . name . toString ( ) ) ; 
 + assertEquals ( " b " , l . ends [ 1 ] . collectionName . name . toString ( ) ) ; 
 + } 
 + } 
 \ No newline at end of file

NEAREST DIFF:
ELIMINATEDSENTENCE
