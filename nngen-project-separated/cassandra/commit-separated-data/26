BLEU SCORE: 0.21200626759025185

TEST MSG: Validate token ( ) arguments early instead of throwing NPE at execution
GENERATED MSG: Validate token ( ) args are in partition key order

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a0c51f0 . . 852cccf 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Validate token ( ) arguments early instead of throwing NPE at execution ( CASSANDRA - 14989 ) <nl> * Add a new tool to dump audit logs ( CASSANDRA - 14885 ) <nl> * Fix generating javadoc with Java11 ( CASSANDRA - 14988 ) <nl> * Only cancel conflicting compactions when starting anticompactions and sub range compactions ( CASSANDRA - 14935 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / FunctionResolver . java b / src / java / org / apache / cassandra / cql3 / functions / FunctionResolver . java <nl> index 99c0fca . . ae5d17e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / FunctionResolver . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / FunctionResolver . java <nl> @ @ - 69 , 8 + 69 , 32 @ @ public final class FunctionResolver <nl> AbstractType < ? > receiverType ) <nl> throws InvalidRequestException <nl> { <nl> + Collection < Function > candidates = collectCandidates ( keyspace , name , receiverKs , receiverCf , receiverType ) ; <nl> + <nl> + if ( candidates . isEmpty ( ) ) <nl> + return null ; <nl> + <nl> + / / Fast path if there is only one choice <nl> + if ( candidates . size ( ) = = 1 ) <nl> + { <nl> + Function fun = candidates . iterator ( ) . next ( ) ; <nl> + validateTypes ( keyspace , fun , providedArgs , receiverKs , receiverCf ) ; <nl> + return fun ; <nl> + } <nl> + <nl> + return pickBestMatch ( keyspace , name , providedArgs , receiverKs , receiverCf , receiverType , candidates ) ; <nl> + } <nl> + <nl> + private static Collection < Function > collectCandidates ( String keyspace , <nl> + FunctionName name , <nl> + String receiverKs , <nl> + String receiverCf , <nl> + AbstractType < ? > receiverType ) <nl> + { <nl> + Collection < Function > candidates = new ArrayList < > ( ) ; <nl> + <nl> if ( name . equalsNativeFunction ( TOKEN _ FUNCTION _ NAME ) ) <nl> - return new TokenFct ( Schema . instance . getTableMetadata ( receiverKs , receiverCf ) ) ; <nl> + candidates . add ( new TokenFct ( Schema . instance . getTableMetadata ( receiverKs , receiverCf ) ) ) ; <nl> <nl> / / The toJson ( ) function can accept any type of argument , so instances of it are not pre - declared . Instead , <nl> / / we create new instances as needed while handling selectors ( which is the only place that toJson ( ) is supported , <nl> @ @ - 83 , 14 + 107 , 12 @ @ public final class FunctionResolver <nl> { <nl> if ( receiverType = = null ) <nl> throw new InvalidRequestException ( " fromJson ( ) cannot be used in the selection clause of a SELECT statement " ) ; <nl> - return FromJsonFct . getInstance ( receiverType ) ; <nl> + candidates . add ( FromJsonFct . getInstance ( receiverType ) ) ; <nl> } <nl> <nl> - Collection < Function > candidates ; <nl> if ( ! name . hasKeyspace ( ) ) <nl> { <nl> / / function name not fully qualified <nl> - candidates = new ArrayList < > ( ) ; <nl> / / add ' SYSTEM ' ( native ) candidates <nl> candidates . addAll ( Schema . instance . getFunctions ( name . asNativeFunction ( ) ) ) ; <nl> / / add ' current keyspace ' candidates <nl> @ @ - 99 , 20 + 121 , 19 @ @ public final class FunctionResolver <nl> else <nl> { <nl> / / function name is fully qualified ( keyspace + name ) <nl> - candidates = Schema . instance . getFunctions ( name ) ; <nl> + candidates . addAll ( Schema . instance . getFunctions ( name ) ) ; <nl> } <nl> <nl> - if ( candidates . isEmpty ( ) ) <nl> - return null ; <nl> - <nl> - / / Fast path if there is only one choice <nl> - if ( candidates . size ( ) = = 1 ) <nl> - { <nl> - Function fun = candidates . iterator ( ) . next ( ) ; <nl> - validateTypes ( keyspace , fun , providedArgs , receiverKs , receiverCf ) ; <nl> - return fun ; <nl> - } <nl> + return candidates ; <nl> + } <nl> <nl> + private static Function pickBestMatch ( String keyspace , <nl> + FunctionName name , <nl> + List < ? extends AssignmentTestable > providedArgs , <nl> + String receiverKs , <nl> + String receiverCf , AbstractType < ? > receiverType , <nl> + Collection < Function > candidates ) <nl> + { <nl> List < Function > compatibles = null ; <nl> for ( Function toTest : candidates ) <nl> { <nl> @ @ - 166 , 6 + 187 , 7 @ @ public final class FunctionResolver <nl> throw invalidRequest ( " Ambiguous call to function % s ( can be matched by following signatures : % s ) : use type casts to disambiguate " , <nl> name , format ( compatibles ) ) ; <nl> } <nl> + <nl> return compatibles . get ( 0 ) ; <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> index 54e079e . . d7c1e25 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> @ @ - 3086 , 4 + 3086 , 77 @ @ public class SelectTest extends CQLTester <nl> } <nl> } <nl> <nl> + @ Test / / CASSANDRA - 14989 <nl> + public void testTokenFctAcceptsValidArguments ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; <nl> + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; <nl> + assertRowCount ( execute ( " SELECT token ( k1 , k2 ) FROM % s " ) , 1 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTokenFctRejectsInvalidColumnName ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; <nl> + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; <nl> + assertInvalidMessage ( " Undefined column name " , " SELECT token ( s1 , k1 ) FROM % s " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTokenFctRejectsInvalidColumnType ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; <nl> + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; <nl> + assertInvalidMessage ( " Type error : k2 cannot be passed as argument 0 of function system . token of type uuid " , <nl> + " SELECT token ( k2 , k1 ) FROM % s " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTokenFctRejectsInvalidColumnCount ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; <nl> + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; <nl> + assertInvalidMessage ( " Invalid number of arguments in call to function system . token : 2 required but 1 provided " , <nl> + " SELECT token ( k1 ) FROM % s " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreatingUDFWithSameNameAsBuiltin _ PrefersCompatibleArgs _ SameKeyspace ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; <nl> + createFunctionOverload ( KEYSPACE + " . token " , " double " , <nl> + " CREATE FUNCTION % s ( val double ) RETURNS null ON null INPUT RETURNS double LANGUAGE java AS ' return 10 . 0d ; ' " ) ; <nl> + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; <nl> + assertRows ( execute ( " SELECT token ( 10 ) FROM % s " ) , row ( 10 . 0d ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreatingUDFWithSameNameAsBuiltin _ FullyQualifiedFunctionNameWorks ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; <nl> + createFunctionOverload ( KEYSPACE + " . token " , " double " , <nl> + " CREATE FUNCTION % s ( val double ) RETURNS null ON null INPUT RETURNS double LANGUAGE java AS ' return 10 . 0d ; ' " ) ; <nl> + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; <nl> + assertRows ( execute ( " SELECT " + KEYSPACE + " . token ( 10 ) FROM % s " ) , row ( 10 . 0d ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreatingUDFWithSameNameAsBuiltin _ PrefersCompatibleArgs ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; <nl> + createFunctionOverload ( KEYSPACE + " . token " , " double " , <nl> + " CREATE FUNCTION % s ( val double ) RETURNS null ON null INPUT RETURNS double LANGUAGE java AS ' return 10 . 0d ; ' " ) ; <nl> + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; <nl> + assertRowCount ( execute ( " SELECT token ( k1 , k2 ) FROM % s " ) , 1 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreatingUDFWithSameNameAsBuiltin _ FullyQualifiedFunctionNameWorks _ SystemKeyspace ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; <nl> + createFunctionOverload ( KEYSPACE + " . token " , " double " , <nl> + " CREATE FUNCTION % s ( val double ) RETURNS null ON null INPUT RETURNS double LANGUAGE java AS ' return 10 . 0d ; ' " ) ; <nl> + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; <nl> + assertRowCount ( execute ( " SELECT system . token ( k1 , k2 ) FROM % s " ) , 1 ) ; <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a0c51f0 . . 852cccf 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Validate token ( ) arguments early instead of throwing NPE at execution ( CASSANDRA - 14989 ) 
 * Add a new tool to dump audit logs ( CASSANDRA - 14885 ) 
 * Fix generating javadoc with Java11 ( CASSANDRA - 14988 ) 
 * Only cancel conflicting compactions when starting anticompactions and sub range compactions ( CASSANDRA - 14935 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / FunctionResolver . java b / src / java / org / apache / cassandra / cql3 / functions / FunctionResolver . java 
 index 99c0fca . . ae5d17e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / FunctionResolver . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / FunctionResolver . java 
 @ @ - 69 , 8 + 69 , 32 @ @ public final class FunctionResolver 
 AbstractType < ? > receiverType ) 
 throws InvalidRequestException 
 { 
 + Collection < Function > candidates = collectCandidates ( keyspace , name , receiverKs , receiverCf , receiverType ) ; 
 + 
 + if ( candidates . isEmpty ( ) ) 
 + return null ; 
 + 
 + / / Fast path if there is only one choice 
 + if ( candidates . size ( ) = = 1 ) 
 + { 
 + Function fun = candidates . iterator ( ) . next ( ) ; 
 + validateTypes ( keyspace , fun , providedArgs , receiverKs , receiverCf ) ; 
 + return fun ; 
 + } 
 + 
 + return pickBestMatch ( keyspace , name , providedArgs , receiverKs , receiverCf , receiverType , candidates ) ; 
 + } 
 + 
 + private static Collection < Function > collectCandidates ( String keyspace , 
 + FunctionName name , 
 + String receiverKs , 
 + String receiverCf , 
 + AbstractType < ? > receiverType ) 
 + { 
 + Collection < Function > candidates = new ArrayList < > ( ) ; 
 + 
 if ( name . equalsNativeFunction ( TOKEN _ FUNCTION _ NAME ) ) 
 - return new TokenFct ( Schema . instance . getTableMetadata ( receiverKs , receiverCf ) ) ; 
 + candidates . add ( new TokenFct ( Schema . instance . getTableMetadata ( receiverKs , receiverCf ) ) ) ; 
 
 / / The toJson ( ) function can accept any type of argument , so instances of it are not pre - declared . Instead , 
 / / we create new instances as needed while handling selectors ( which is the only place that toJson ( ) is supported , 
 @ @ - 83 , 14 + 107 , 12 @ @ public final class FunctionResolver 
 { 
 if ( receiverType = = null ) 
 throw new InvalidRequestException ( " fromJson ( ) cannot be used in the selection clause of a SELECT statement " ) ; 
 - return FromJsonFct . getInstance ( receiverType ) ; 
 + candidates . add ( FromJsonFct . getInstance ( receiverType ) ) ; 
 } 
 
 - Collection < Function > candidates ; 
 if ( ! name . hasKeyspace ( ) ) 
 { 
 / / function name not fully qualified 
 - candidates = new ArrayList < > ( ) ; 
 / / add ' SYSTEM ' ( native ) candidates 
 candidates . addAll ( Schema . instance . getFunctions ( name . asNativeFunction ( ) ) ) ; 
 / / add ' current keyspace ' candidates 
 @ @ - 99 , 20 + 121 , 19 @ @ public final class FunctionResolver 
 else 
 { 
 / / function name is fully qualified ( keyspace + name ) 
 - candidates = Schema . instance . getFunctions ( name ) ; 
 + candidates . addAll ( Schema . instance . getFunctions ( name ) ) ; 
 } 
 
 - if ( candidates . isEmpty ( ) ) 
 - return null ; 
 - 
 - / / Fast path if there is only one choice 
 - if ( candidates . size ( ) = = 1 ) 
 - { 
 - Function fun = candidates . iterator ( ) . next ( ) ; 
 - validateTypes ( keyspace , fun , providedArgs , receiverKs , receiverCf ) ; 
 - return fun ; 
 - } 
 + return candidates ; 
 + } 
 
 + private static Function pickBestMatch ( String keyspace , 
 + FunctionName name , 
 + List < ? extends AssignmentTestable > providedArgs , 
 + String receiverKs , 
 + String receiverCf , AbstractType < ? > receiverType , 
 + Collection < Function > candidates ) 
 + { 
 List < Function > compatibles = null ; 
 for ( Function toTest : candidates ) 
 { 
 @ @ - 166 , 6 + 187 , 7 @ @ public final class FunctionResolver 
 throw invalidRequest ( " Ambiguous call to function % s ( can be matched by following signatures : % s ) : use type casts to disambiguate " , 
 name , format ( compatibles ) ) ; 
 } 
 + 
 return compatibles . get ( 0 ) ; 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 index 54e079e . . d7c1e25 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 @ @ - 3086 , 4 + 3086 , 77 @ @ public class SelectTest extends CQLTester 
 } 
 } 
 
 + @ Test / / CASSANDRA - 14989 
 + public void testTokenFctAcceptsValidArguments ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; 
 + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; 
 + assertRowCount ( execute ( " SELECT token ( k1 , k2 ) FROM % s " ) , 1 ) ; 
 + } 
 + 
 + @ Test 
 + public void testTokenFctRejectsInvalidColumnName ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; 
 + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; 
 + assertInvalidMessage ( " Undefined column name " , " SELECT token ( s1 , k1 ) FROM % s " ) ; 
 + } 
 + 
 + @ Test 
 + public void testTokenFctRejectsInvalidColumnType ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; 
 + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; 
 + assertInvalidMessage ( " Type error : k2 cannot be passed as argument 0 of function system . token of type uuid " , 
 + " SELECT token ( k2 , k1 ) FROM % s " ) ; 
 + } 
 + 
 + @ Test 
 + public void testTokenFctRejectsInvalidColumnCount ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; 
 + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; 
 + assertInvalidMessage ( " Invalid number of arguments in call to function system . token : 2 required but 1 provided " , 
 + " SELECT token ( k1 ) FROM % s " ) ; 
 + } 
 + 
 + @ Test 
 + public void testCreatingUDFWithSameNameAsBuiltin _ PrefersCompatibleArgs _ SameKeyspace ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; 
 + createFunctionOverload ( KEYSPACE + " . token " , " double " , 
 + " CREATE FUNCTION % s ( val double ) RETURNS null ON null INPUT RETURNS double LANGUAGE java AS ' return 10 . 0d ; ' " ) ; 
 + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; 
 + assertRows ( execute ( " SELECT token ( 10 ) FROM % s " ) , row ( 10 . 0d ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testCreatingUDFWithSameNameAsBuiltin _ FullyQualifiedFunctionNameWorks ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; 
 + createFunctionOverload ( KEYSPACE + " . token " , " double " , 
 + " CREATE FUNCTION % s ( val double ) RETURNS null ON null INPUT RETURNS double LANGUAGE java AS ' return 10 . 0d ; ' " ) ; 
 + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; 
 + assertRows ( execute ( " SELECT " + KEYSPACE + " . token ( 10 ) FROM % s " ) , row ( 10 . 0d ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testCreatingUDFWithSameNameAsBuiltin _ PrefersCompatibleArgs ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; 
 + createFunctionOverload ( KEYSPACE + " . token " , " double " , 
 + " CREATE FUNCTION % s ( val double ) RETURNS null ON null INPUT RETURNS double LANGUAGE java AS ' return 10 . 0d ; ' " ) ; 
 + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; 
 + assertRowCount ( execute ( " SELECT token ( k1 , k2 ) FROM % s " ) , 1 ) ; 
 + } 
 + 
 + @ Test 
 + public void testCreatingUDFWithSameNameAsBuiltin _ FullyQualifiedFunctionNameWorks _ SystemKeyspace ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k1 uuid , k2 text , PRIMARY KEY ( ( k1 , k2 ) ) ) " ) ; 
 + createFunctionOverload ( KEYSPACE + " . token " , " double " , 
 + " CREATE FUNCTION % s ( val double ) RETURNS null ON null INPUT RETURNS double LANGUAGE java AS ' return 10 . 0d ; ' " ) ; 
 + execute ( " INSERT INTO % s ( k1 , k2 ) VALUES ( uuid ( ) , ' k2 ' ) " ) ; 
 + assertRowCount ( execute ( " SELECT system . token ( k1 , k2 ) FROM % s " ) , 1 ) ; 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
