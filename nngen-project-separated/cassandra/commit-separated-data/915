BLEU SCORE: 0.0370865905565703

TEST MSG: Add unit test for CASSANDRA - 11548
GENERATED MSG: Fix out - of - space error treatment in memtable flushing

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 90a4f23 . . 76d3673 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 7 + 1 , 5 @ @ <nl> - 2 . 1 . 15 <nl> - * Replace sstables on DataTracker before marking them as non - compacting during anti - compaction ( CASSANDRA - 11548 ) <nl> - <nl> 2 . 1 . 14 <nl> + * Replace sstables on DataTracker before marking them as non - compacting during anti - compaction ( CASSANDRA - 11548 ) <nl> * Checking if an unlogged batch is local is inefficient ( CASSANDRA - 11529 ) <nl> * Fix paging for COMPACT tables without clustering columns ( CASSANDRA - 11467 ) <nl> * Fix out - of - space error treatment in memtable flushing ( CASSANDRA - 11448 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / DataTracker . java b / src / java / org / apache / cassandra / db / DataTracker . java <nl> index ef25236 . . c731a35 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DataTracker . java <nl> + + + b / src / java / org / apache / cassandra / db / DataTracker . java <nl> @ @ - 222 , 7 + 222 , 10 @ @ public class DataTracker <nl> <nl> View newView = currentView . markCompacting ( sstables ) ; <nl> if ( view . compareAndSet ( currentView , newView ) ) <nl> + { <nl> + notifyCompacting ( sstables , true ) ; <nl> return true ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 247 , 6 + 250 , 8 @ @ public class DataTracker <nl> / / interrupted after the CFS is invalidated , those sstables need to be unreferenced as well , so we do that here . <nl> unreferenceSSTables ( ) ; <nl> } <nl> + <nl> + notifyCompacting ( unmark , false ) ; <nl> } <nl> <nl> public void markObsolete ( Collection < SSTableReader > sstables , OperationType compactionType ) <nl> @ @ - 511 , 6 + 516 , 13 @ @ public class DataTracker <nl> subscriber . handleNotification ( notification , this ) ; <nl> } <nl> <nl> + public void notifyCompacting ( Iterable < SSTableReader > reader , boolean compacting ) <nl> + { <nl> + INotification notification = new SSTableCompactingNotification ( reader , compacting ) ; <nl> + for ( INotificationConsumer subscriber : subscribers ) <nl> + subscriber . handleNotification ( notification , this ) ; <nl> + } <nl> + <nl> public void notifyAdded ( SSTableReader added ) <nl> { <nl> INotification notification = new SSTableAddedNotification ( added ) ; <nl> diff - - git a / src / java / org / apache / cassandra / notifications / SSTableCompactingNotification . java b / src / java / org / apache / cassandra / notifications / SSTableCompactingNotification . java <nl> new file mode 100644 <nl> index 0000000 . . 6eddf3f <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / notifications / SSTableCompactingNotification . java <nl> @ @ - 0 , 0 + 1 , 41 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . notifications ; <nl> + <nl> + import org . apache . cassandra . io . sstable . SSTableReader ; <nl> + <nl> + public class SSTableCompactingNotification implements INotification <nl> + { <nl> + public final Iterable < SSTableReader > sstables ; <nl> + public final boolean compacting ; <nl> + <nl> + public SSTableCompactingNotification ( Iterable < SSTableReader > sstables , boolean compacting ) <nl> + { <nl> + this . sstables = sstables ; <nl> + this . compacting = compacting ; <nl> + } <nl> + <nl> + public String toString ( ) <nl> + { <nl> + return " SSTableCompactingNotification { " + <nl> + " sstables = " + sstables + <nl> + " , compacting = " + compacting + <nl> + ' } ' ; <nl> + } <nl> + } <nl> diff - - git a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> index 0eb769f . . fa6a31b 100644 <nl> - - - a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> + + + b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> @ @ - 19 , 6 + 19 , 9 @ @ package org . apache . cassandra . db . compaction ; <nl> <nl> import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> + import java . util . Arrays ; <nl> + import java . util . Collection ; <nl> + import java . util . HashSet ; <nl> import java . util . List ; <nl> import java . util . Set ; <nl> import java . util . concurrent . * ; <nl> @ @ - 28 , 9 + 31 , 19 @ @ import org . junit . Test ; <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . dht . BytesToken ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> + import org . apache . cassandra . notifications . INotification ; <nl> + import org . apache . cassandra . notifications . INotificationConsumer ; <nl> + import org . apache . cassandra . notifications . SSTableCompactingNotification ; <nl> + import org . apache . cassandra . notifications . SSTableListChangedNotification ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . concurrent . Refs ; <nl> <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> import static org . junit . Assert . assertTrue ; <nl> <nl> public class LongLeveledCompactionStrategyTest extends SchemaLoader <nl> @ @ - 125 , 4 + 138 , 92 @ @ public class LongLeveledCompactionStrategyTest extends SchemaLoader <nl> } <nl> } <nl> } <nl> + <nl> + class CheckThatSSTableIsReleasedOnlyAfterCompactionFinishes implements INotificationConsumer <nl> + { <nl> + public final Set < SSTableReader > finishedCompaction = new HashSet < > ( ) ; <nl> + <nl> + boolean failed = false ; <nl> + <nl> + public void handleNotification ( INotification received , Object sender ) <nl> + { <nl> + if ( received instanceof SSTableCompactingNotification ) <nl> + { <nl> + SSTableCompactingNotification notification = ( SSTableCompactingNotification ) received ; <nl> + if ( ! notification . compacting ) <nl> + { <nl> + for ( SSTableReader reader : notification . sstables ) <nl> + { <nl> + finishedCompaction . add ( reader ) ; <nl> + } <nl> + } <nl> + } <nl> + if ( received instanceof SSTableListChangedNotification ) <nl> + { <nl> + SSTableListChangedNotification notification = ( SSTableListChangedNotification ) received ; <nl> + for ( SSTableReader reader : notification . removed ) <nl> + { <nl> + if ( finishedCompaction . contains ( reader ) ) <nl> + failed = true ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + boolean isFailed ( ) <nl> + { <nl> + return failed ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testAntiCompactionAfterLCS ( ) throws Exception <nl> + { <nl> + testParallelLeveledCompaction ( ) ; <nl> + <nl> + String ksname = " Keyspace1 " ; <nl> + String cfname = " StandardLeveled " ; <nl> + Keyspace keyspace = Keyspace . open ( ksname ) ; <nl> + ColumnFamilyStore store = keyspace . getColumnFamilyStore ( cfname ) ; <nl> + WrappingCompactionStrategy strategy = ( ( WrappingCompactionStrategy ) store . getCompactionStrategy ( ) ) ; <nl> + <nl> + Collection < SSTableReader > initialSSTables = store . getUnrepairedSSTables ( ) ; <nl> + assertEquals ( store . getSSTables ( ) . size ( ) , initialSSTables . size ( ) ) ; <nl> + <nl> + CheckThatSSTableIsReleasedOnlyAfterCompactionFinishes checker = new CheckThatSSTableIsReleasedOnlyAfterCompactionFinishes ( ) ; <nl> + store . getDataTracker ( ) . subscribe ( checker ) ; <nl> + <nl> + / / anti - compact a subset of sstables <nl> + Range < Token > range = new Range < Token > ( new BytesToken ( " 110 " . getBytes ( ) ) , new BytesToken ( " 111 " . getBytes ( ) ) , store . partitioner ) ; <nl> + List < Range < Token > > ranges = Arrays . asList ( range ) ; <nl> + Refs < SSTableReader > refs = Refs . tryRef ( initialSSTables ) ; <nl> + if ( refs = = null ) <nl> + throw new IllegalStateException ( ) ; <nl> + long repairedAt = 1000 ; <nl> + CompactionManager . instance . performAnticompaction ( store , ranges , refs , repairedAt ) ; <nl> + <nl> + / / check that sstables were released only after compaction finished <nl> + assertFalse ( " Anti - compaction released sstable from compacting set before compaction was finished " , <nl> + checker . isFailed ( ) ) ; <nl> + <nl> + / / check there is only one global ref count <nl> + for ( SSTableReader sstable : store . getSSTables ( ) ) <nl> + { <nl> + assertFalse ( sstable . isMarkedCompacted ( ) ) ; <nl> + assertEquals ( 1 , sstable . selfRef ( ) . globalCount ( ) ) ; <nl> + } <nl> + <nl> + / / check that compacting status was clearedd in all sstables <nl> + assertEquals ( 0 , store . getDataTracker ( ) . getCompacting ( ) . size ( ) ) ; <nl> + <nl> + / / make sure readers were replaced correctly on unrepaired leveled manifest after anti - compaction <nl> + LeveledCompactionStrategy lcs = ( LeveledCompactionStrategy ) strategy . getWrappedStrategies ( ) . get ( 1 ) ; <nl> + for ( SSTableReader reader : initialSSTables ) <nl> + { <nl> + Range < Token > sstableRange = new Range < Token > ( reader . first . getToken ( ) , reader . last . getToken ( ) ) ; <nl> + if ( sstableRange . intersects ( range ) ) <nl> + { <nl> + assertFalse ( lcs . manifest . generations [ reader . getSSTableLevel ( ) ] . contains ( reader ) ) ; <nl> + } <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 90a4f23 . . 76d3673 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 7 + 1 , 5 @ @ 
 - 2 . 1 . 15 
 - * Replace sstables on DataTracker before marking them as non - compacting during anti - compaction ( CASSANDRA - 11548 ) 
 - 
 2 . 1 . 14 
 + * Replace sstables on DataTracker before marking them as non - compacting during anti - compaction ( CASSANDRA - 11548 ) 
 * Checking if an unlogged batch is local is inefficient ( CASSANDRA - 11529 ) 
 * Fix paging for COMPACT tables without clustering columns ( CASSANDRA - 11467 ) 
 * Fix out - of - space error treatment in memtable flushing ( CASSANDRA - 11448 ) 
 diff - - git a / src / java / org / apache / cassandra / db / DataTracker . java b / src / java / org / apache / cassandra / db / DataTracker . java 
 index ef25236 . . c731a35 100644 
 - - - a / src / java / org / apache / cassandra / db / DataTracker . java 
 + + + b / src / java / org / apache / cassandra / db / DataTracker . java 
 @ @ - 222 , 7 + 222 , 10 @ @ public class DataTracker 
 
 View newView = currentView . markCompacting ( sstables ) ; 
 if ( view . compareAndSet ( currentView , newView ) ) 
 + { 
 + notifyCompacting ( sstables , true ) ; 
 return true ; 
 + } 
 } 
 } 
 
 @ @ - 247 , 6 + 250 , 8 @ @ public class DataTracker 
 / / interrupted after the CFS is invalidated , those sstables need to be unreferenced as well , so we do that here . 
 unreferenceSSTables ( ) ; 
 } 
 + 
 + notifyCompacting ( unmark , false ) ; 
 } 
 
 public void markObsolete ( Collection < SSTableReader > sstables , OperationType compactionType ) 
 @ @ - 511 , 6 + 516 , 13 @ @ public class DataTracker 
 subscriber . handleNotification ( notification , this ) ; 
 } 
 
 + public void notifyCompacting ( Iterable < SSTableReader > reader , boolean compacting ) 
 + { 
 + INotification notification = new SSTableCompactingNotification ( reader , compacting ) ; 
 + for ( INotificationConsumer subscriber : subscribers ) 
 + subscriber . handleNotification ( notification , this ) ; 
 + } 
 + 
 public void notifyAdded ( SSTableReader added ) 
 { 
 INotification notification = new SSTableAddedNotification ( added ) ; 
 diff - - git a / src / java / org / apache / cassandra / notifications / SSTableCompactingNotification . java b / src / java / org / apache / cassandra / notifications / SSTableCompactingNotification . java 
 new file mode 100644 
 index 0000000 . . 6eddf3f 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / notifications / SSTableCompactingNotification . java 
 @ @ - 0 , 0 + 1 , 41 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . notifications ; 
 + 
 + import org . apache . cassandra . io . sstable . SSTableReader ; 
 + 
 + public class SSTableCompactingNotification implements INotification 
 + { 
 + public final Iterable < SSTableReader > sstables ; 
 + public final boolean compacting ; 
 + 
 + public SSTableCompactingNotification ( Iterable < SSTableReader > sstables , boolean compacting ) 
 + { 
 + this . sstables = sstables ; 
 + this . compacting = compacting ; 
 + } 
 + 
 + public String toString ( ) 
 + { 
 + return " SSTableCompactingNotification { " + 
 + " sstables = " + sstables + 
 + " , compacting = " + compacting + 
 + ' } ' ; 
 + } 
 + } 
 diff - - git a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 index 0eb769f . . fa6a31b 100644 
 - - - a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 + + + b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 @ @ - 19 , 6 + 19 , 9 @ @ package org . apache . cassandra . db . compaction ; 
 
 import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 + import java . util . Arrays ; 
 + import java . util . Collection ; 
 + import java . util . HashSet ; 
 import java . util . List ; 
 import java . util . Set ; 
 import java . util . concurrent . * ; 
 @ @ - 28 , 9 + 31 , 19 @ @ import org . junit . Test ; 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . Util ; 
 import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . dht . BytesToken ; 
 + import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 + import org . apache . cassandra . notifications . INotification ; 
 + import org . apache . cassandra . notifications . INotificationConsumer ; 
 + import org . apache . cassandra . notifications . SSTableCompactingNotification ; 
 + import org . apache . cassandra . notifications . SSTableListChangedNotification ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . concurrent . Refs ; 
 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 import static org . junit . Assert . assertTrue ; 
 
 public class LongLeveledCompactionStrategyTest extends SchemaLoader 
 @ @ - 125 , 4 + 138 , 92 @ @ public class LongLeveledCompactionStrategyTest extends SchemaLoader 
 } 
 } 
 } 
 + 
 + class CheckThatSSTableIsReleasedOnlyAfterCompactionFinishes implements INotificationConsumer 
 + { 
 + public final Set < SSTableReader > finishedCompaction = new HashSet < > ( ) ; 
 + 
 + boolean failed = false ; 
 + 
 + public void handleNotification ( INotification received , Object sender ) 
 + { 
 + if ( received instanceof SSTableCompactingNotification ) 
 + { 
 + SSTableCompactingNotification notification = ( SSTableCompactingNotification ) received ; 
 + if ( ! notification . compacting ) 
 + { 
 + for ( SSTableReader reader : notification . sstables ) 
 + { 
 + finishedCompaction . add ( reader ) ; 
 + } 
 + } 
 + } 
 + if ( received instanceof SSTableListChangedNotification ) 
 + { 
 + SSTableListChangedNotification notification = ( SSTableListChangedNotification ) received ; 
 + for ( SSTableReader reader : notification . removed ) 
 + { 
 + if ( finishedCompaction . contains ( reader ) ) 
 + failed = true ; 
 + } 
 + } 
 + } 
 + 
 + boolean isFailed ( ) 
 + { 
 + return failed ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testAntiCompactionAfterLCS ( ) throws Exception 
 + { 
 + testParallelLeveledCompaction ( ) ; 
 + 
 + String ksname = " Keyspace1 " ; 
 + String cfname = " StandardLeveled " ; 
 + Keyspace keyspace = Keyspace . open ( ksname ) ; 
 + ColumnFamilyStore store = keyspace . getColumnFamilyStore ( cfname ) ; 
 + WrappingCompactionStrategy strategy = ( ( WrappingCompactionStrategy ) store . getCompactionStrategy ( ) ) ; 
 + 
 + Collection < SSTableReader > initialSSTables = store . getUnrepairedSSTables ( ) ; 
 + assertEquals ( store . getSSTables ( ) . size ( ) , initialSSTables . size ( ) ) ; 
 + 
 + CheckThatSSTableIsReleasedOnlyAfterCompactionFinishes checker = new CheckThatSSTableIsReleasedOnlyAfterCompactionFinishes ( ) ; 
 + store . getDataTracker ( ) . subscribe ( checker ) ; 
 + 
 + / / anti - compact a subset of sstables 
 + Range < Token > range = new Range < Token > ( new BytesToken ( " 110 " . getBytes ( ) ) , new BytesToken ( " 111 " . getBytes ( ) ) , store . partitioner ) ; 
 + List < Range < Token > > ranges = Arrays . asList ( range ) ; 
 + Refs < SSTableReader > refs = Refs . tryRef ( initialSSTables ) ; 
 + if ( refs = = null ) 
 + throw new IllegalStateException ( ) ; 
 + long repairedAt = 1000 ; 
 + CompactionManager . instance . performAnticompaction ( store , ranges , refs , repairedAt ) ; 
 + 
 + / / check that sstables were released only after compaction finished 
 + assertFalse ( " Anti - compaction released sstable from compacting set before compaction was finished " , 
 + checker . isFailed ( ) ) ; 
 + 
 + / / check there is only one global ref count 
 + for ( SSTableReader sstable : store . getSSTables ( ) ) 
 + { 
 + assertFalse ( sstable . isMarkedCompacted ( ) ) ; 
 + assertEquals ( 1 , sstable . selfRef ( ) . globalCount ( ) ) ; 
 + } 
 + 
 + / / check that compacting status was clearedd in all sstables 
 + assertEquals ( 0 , store . getDataTracker ( ) . getCompacting ( ) . size ( ) ) ; 
 + 
 + / / make sure readers were replaced correctly on unrepaired leveled manifest after anti - compaction 
 + LeveledCompactionStrategy lcs = ( LeveledCompactionStrategy ) strategy . getWrappedStrategies ( ) . get ( 1 ) ; 
 + for ( SSTableReader reader : initialSSTables ) 
 + { 
 + Range < Token > sstableRange = new Range < Token > ( reader . first . getToken ( ) , reader . last . getToken ( ) ) ; 
 + if ( sstableRange . intersects ( range ) ) 
 + { 
 + assertFalse ( lcs . manifest . generations [ reader . getSSTableLevel ( ) ] . contains ( reader ) ) ; 
 + } 
 + } 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
