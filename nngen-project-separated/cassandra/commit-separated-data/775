BLEU SCORE: 0.0379680177759557

TEST MSG: Always select the live sstables when getting sstables in bounds
GENERATED MSG: Don ' t promote sstables for cleanup , scrub and updateSSTables

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7f8a3a1 . . 99ac3ad 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 9 <nl> + * Always select the live sstables when getting sstables in bounds ( CASSANDRA - 11944 ) <nl> * Fix column ordering of results with static columns for Thrift requests in <nl> a mixed 2 . x / 3 . x cluster , also fix potential non - resolved duplication of <nl> those static columns in query results ( CASSANDRA - 12123 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 3264327 . . 1be3175 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1231 , 7 + 1231 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> * @ return sstables whose key range overlaps with that of the given sstables , not including itself . <nl> * ( The given sstables may or may not overlap with each other . ) <nl> * / <nl> - public Collection < SSTableReader > getOverlappingSSTables ( SSTableSet sstableSet , Iterable < SSTableReader > sstables ) <nl> + public Collection < SSTableReader > getOverlappingLiveSSTables ( Iterable < SSTableReader > sstables ) <nl> { <nl> logger . trace ( " Checking for sstables overlapping { } " , sstables ) ; <nl> <nl> @ @ - 1282 , 7 + 1282 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> Set < SSTableReader > results = new HashSet < > ( ) ; <nl> <nl> for ( AbstractBounds < PartitionPosition > bound : bounds ) <nl> - Iterables . addAll ( results , view . sstablesInBounds ( sstableSet , bound . left , bound . right ) ) ; <nl> + Iterables . addAll ( results , view . liveSSTablesInBounds ( bound . left , bound . right ) ) ; <nl> <nl> return Sets . difference ( results , ImmutableSet . copyOf ( sstables ) ) ; <nl> } <nl> @ @ - 1290 , 11 + 1290 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> / * * <nl> * like getOverlappingSSTables , but acquires references before returning <nl> * / <nl> - public Refs < SSTableReader > getAndReferenceOverlappingSSTables ( SSTableSet sstableSet , Iterable < SSTableReader > sstables ) <nl> + public Refs < SSTableReader > getAndReferenceOverlappingLiveSSTables ( Iterable < SSTableReader > sstables ) <nl> { <nl> while ( true ) <nl> { <nl> - Iterable < SSTableReader > overlapped = getOverlappingSSTables ( sstableSet , sstables ) ; <nl> + Iterable < SSTableReader > overlapped = getOverlappingLiveSSTables ( sstables ) ; <nl> Refs < SSTableReader > refs = Refs . tryRef ( overlapped ) ; <nl> if ( refs ! = null ) <nl> return refs ; <nl> diff - - git a / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java b / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java <nl> index 9585b59 . . 842ad5f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java <nl> @ @ - 175 , 7 + 175 , 7 @ @ public class PartitionRangeReadCommand extends ReadCommand <nl> <nl> protected UnfilteredPartitionIterator queryStorage ( final ColumnFamilyStore cfs , ReadOrderGroup orderGroup ) <nl> { <nl> - ColumnFamilyStore . ViewFragment view = cfs . select ( View . select ( SSTableSet . LIVE , dataRange ( ) . keyRange ( ) ) ) ; <nl> + ColumnFamilyStore . ViewFragment view = cfs . select ( View . selectLive ( dataRange ( ) . keyRange ( ) ) ) ; <nl> Tracing . trace ( " Executing seq scan across { } sstables for { } " , view . sstables . size ( ) , dataRange ( ) . keyRange ( ) . getString ( metadata ( ) . getKeyValidator ( ) ) ) ; <nl> <nl> / / fetch data from current memtable , historical memtables , and SSTables in the correct order . <nl> diff - - git a / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java b / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java <nl> index 2a74ea9 . . 3461aef 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java <nl> + + + b / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java <nl> @ @ - 103 , 8 + 103 , 9 @ @ public class SizeEstimatesRecorder extends MigrationListener implements Runnable <nl> { <nl> while ( refs = = null ) <nl> { <nl> - ColumnFamilyStore . ViewFragment view = table . select ( View . select ( SSTableSet . CANONICAL , Range . makeRowRange ( range ) ) ) ; <nl> - refs = Refs . tryRef ( view . sstables ) ; <nl> + / / note that this is not guaranteed to return all sstables within the ranges , but for an estimated size , that should be fine <nl> + Iterable < SSTableReader > canonicalSSTables = table . getTracker ( ) . getView ( ) . select ( SSTableSet . CANONICAL , table . select ( View . selectLive ( Range . makeRowRange ( range ) ) ) . sstables ) ; <nl> + refs = Refs . tryRef ( canonicalSSTables ) ; <nl> } <nl> <nl> / / calculate the estimates . <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> index e30e4f7 . . 0dce52b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java <nl> @ @ - 380 , 7 + 380 , 7 @ @ public abstract class AbstractCompactionStrategy <nl> if ( uncheckedTombstoneCompaction ) <nl> return true ; <nl> <nl> - Collection < SSTableReader > overlaps = cfs . getOverlappingSSTables ( SSTableSet . CANONICAL , Collections . singleton ( sstable ) ) ; <nl> + Collection < SSTableReader > overlaps = cfs . getOverlappingLiveSSTables ( Collections . singleton ( sstable ) ) ; <nl> if ( overlaps . isEmpty ( ) ) <nl> { <nl> / / there is no overlap , tombstones are safely droppable <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionController . java b / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> index a5b8308 . . fbf29e3 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> @ @ - 103 , 7 + 103 , 7 @ @ public class CompactionController implements AutoCloseable <nl> if ( compacting = = null ) <nl> overlappingSSTables = Refs . tryRef ( Collections . < SSTableReader > emptyList ( ) ) ; <nl> else <nl> - overlappingSSTables = cfs . getAndReferenceOverlappingSSTables ( SSTableSet . LIVE , compacting ) ; <nl> + overlappingSSTables = cfs . getAndReferenceOverlappingLiveSSTables ( compacting ) ; <nl> this . overlapIterator = new OverlapIterator < > ( buildIntervals ( overlappingSSTables ) ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> index 8571906 . . 3e6ae61 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> @ @ - 99 , 7 + 99 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> if ( System . currentTimeMillis ( ) - lastExpiredCheck > options . expiredSSTableCheckFrequency ) <nl> { <nl> / / Find fully expired SSTables . Those will be included no matter what . <nl> - expired = CompactionController . getFullyExpiredSSTables ( cfs , uncompacting , cfs . getOverlappingSSTables ( SSTableSet . CANONICAL , uncompacting ) , gcBefore ) ; <nl> + expired = CompactionController . getFullyExpiredSSTables ( cfs , uncompacting , cfs . getOverlappingLiveSSTables ( uncompacting ) , gcBefore ) ; <nl> lastExpiredCheck = System . currentTimeMillis ( ) ; <nl> } <nl> Set < SSTableReader > candidates = Sets . newHashSet ( filterSuspectSSTables ( uncompacting ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java <nl> index d1630c5 . . e2ab7dc 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java <nl> @ @ - 104 , 7 + 104 , 7 @ @ public class TimeWindowCompactionStrategy extends AbstractCompactionStrategy <nl> if ( System . currentTimeMillis ( ) - lastExpiredCheck > options . expiredSSTableCheckFrequency ) <nl> { <nl> logger . debug ( " TWCS expired check sufficiently far in the past , checking for fully expired SSTables " ) ; <nl> - expired = CompactionController . getFullyExpiredSSTables ( cfs , uncompacting , cfs . getOverlappingSSTables ( SSTableSet . CANONICAL , uncompacting ) , gcBefore ) ; <nl> + expired = CompactionController . getFullyExpiredSSTables ( cfs , uncompacting , cfs . getOverlappingLiveSSTables ( uncompacting ) , gcBefore ) ; <nl> lastExpiredCheck = System . currentTimeMillis ( ) ; <nl> } <nl> else <nl> diff - - git a / src / java / org / apache / cassandra / db / lifecycle / View . java b / src / java / org / apache / cassandra / db / lifecycle / View . java <nl> index 99903fc . . 96aaa49 100644 <nl> - - - a / src / java / org / apache / cassandra / db / lifecycle / View . java <nl> + + + b / src / java / org / apache / cassandra / db / lifecycle / View . java <nl> @ @ - 136 , 7 + 136 , 7 @ @ public class View <nl> return Iterables . concat ( sstables , filterOut ( compacting , sstables ) ) ; <nl> } <nl> <nl> - private Iterable < SSTableReader > select ( SSTableSet sstableSet , Iterable < SSTableReader > sstables ) <nl> + public Iterable < SSTableReader > select ( SSTableSet sstableSet , Iterable < SSTableReader > sstables ) <nl> { <nl> switch ( sstableSet ) <nl> { <nl> @ @ - 182 , 7 + 182 , 7 @ @ public class View <nl> * Returns the sstables that have any partition between { @ code left } and { @ code right } , when both bounds are taken inclusively . <nl> * The interval formed by { @ code left } and { @ code right } shouldn ' t wrap . <nl> * / <nl> - public Iterable < SSTableReader > sstablesInBounds ( SSTableSet sstableSet , PartitionPosition left , PartitionPosition right ) <nl> + public Iterable < SSTableReader > liveSSTablesInBounds ( PartitionPosition left , PartitionPosition right ) <nl> { <nl> assert ! AbstractBounds . strictlyWrapsAround ( left , right ) ; <nl> <nl> @ @ - 190 , 7 + 190 , 7 @ @ public class View <nl> return Collections . emptyList ( ) ; <nl> <nl> PartitionPosition stopInTree = right . isMinimum ( ) ? intervalTree . max ( ) : right ; <nl> - return select ( sstableSet , intervalTree . search ( Interval . create ( left , stopInTree ) ) ) ; <nl> + return select ( SSTableSet . LIVE , intervalTree . search ( Interval . create ( left , stopInTree ) ) ) ; <nl> } <nl> <nl> public static List < SSTableReader > sstablesInBounds ( PartitionPosition left , PartitionPosition right , SSTableIntervalTree intervalTree ) <nl> @ @ - 228 , 14 + 228 , 14 @ @ public class View <nl> * @ return a ViewFragment containing the sstables and memtables that may need to be merged <nl> * for rows within @ param rowBounds , inclusive , according to the interval tree . <nl> * / <nl> - public static Function < View , Iterable < SSTableReader > > select ( SSTableSet sstableSet , AbstractBounds < PartitionPosition > rowBounds ) <nl> + public static Function < View , Iterable < SSTableReader > > selectLive ( AbstractBounds < PartitionPosition > rowBounds ) <nl> { <nl> / / Note that View . sstablesInBounds always includes it ' s bound while rowBounds may not . This is ok however <nl> / / because the fact we restrict the sstables returned by this function is an optimization in the first <nl> / / place and the returned sstables will ( almost ) never cover * exactly * rowBounds anyway . It ' s also <nl> / / * very * unlikely that a sstable is included * just * because we consider one of the bound inclusively <nl> / / instead of exclusively , so the performance impact is negligible in practice . <nl> - return ( view ) - > view . sstablesInBounds ( sstableSet , rowBounds . left , rowBounds . right ) ; <nl> + return ( view ) - > view . liveSSTablesInBounds ( rowBounds . left , rowBounds . right ) ; <nl> } <nl> <nl> / / METHODS TO CONSTRUCT FUNCTIONS FOR MODIFYING A VIEW : <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> index d5c060e . . a14f815 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> @ @ - 29 , 8 + 29 , 8 @ @ import com . google . common . annotations . VisibleForTesting ; <nl> import com . google . common . collect . * ; <nl> <nl> import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; <nl> - import org . apache . cassandra . db . lifecycle . SSTableSet ; <nl> import org . apache . cassandra . db . lifecycle . SSTableIntervalTree ; <nl> + import org . apache . cassandra . db . lifecycle . SSTableSet ; <nl> import org . apache . cassandra . db . lifecycle . View ; <nl> import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> import org . slf4j . Logger ; <nl> @ @ - 332 , 6 + 332 , 12 @ @ public class StreamSession implements IEndpointStateChangeSubscriber <nl> SSTableIntervalTree intervalTree = SSTableIntervalTree . build ( view . sstables ( SSTableSet . CANONICAL ) ) ; <nl> for ( Range < PartitionPosition > keyRange : keyRanges ) <nl> { <nl> + / / keyRange excludes its start , while sstableInBounds is inclusive ( of both start and end ) . <nl> + / / This is fine however , because keyRange has been created from a token range through Range . makeRowRange ( see above ) . <nl> + / / And that later method uses the Token . maxKeyBound ( ) method to creates the range , which return a " fake " key that <nl> + / / sort after all keys having the token . That " fake " key cannot however be equal to any real key , so that even <nl> + / / including keyRange . left will still exclude any key having the token of the original token range , and so we ' re <nl> + / / still actually selecting what we wanted . <nl> for ( SSTableReader sstable : View . sstablesInBounds ( keyRange . left , keyRange . right , intervalTree ) ) <nl> { <nl> if ( ! isIncremental | | ! sstable . isRepaired ( ) ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java b / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java <nl> index 8a5e00e . . 98f9300 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java <nl> @ @ - 71 , 7 + 71 , 7 @ @ public class ViewTest <nl> continue ; <nl> <nl> AbstractBounds < PartitionPosition > bounds = AbstractBounds . bounds ( min , minInc , max , maxInc ) ; <nl> - List < SSTableReader > r = ImmutableList . copyOf ( initialView . sstablesInBounds ( SSTableSet . LIVE , bounds . left , bounds . right ) ) ; <nl> + List < SSTableReader > r = ImmutableList . copyOf ( initialView . liveSSTablesInBounds ( bounds . left , bounds . right ) ) ; <nl> Assert . assertEquals ( String . format ( " % d ( % s ) % d ( % s ) " , i , minInc , j , maxInc ) , j - i + ( minInc ? 0 : - 1 ) + ( maxInc ? 1 : 0 ) , r . size ( ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c453943 . . 925a4a9 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 9 , 6 + 9 , 7 @ @ <nl> * Fix division - by - zero error on get _ slice ( CASSANDRA - 4000 ) <nl> * don ' t change manifest level for cleanup , scrub , and upgradesstables <nl> operations under LeveledCompactionStrategy ( CASSANDRA - 3989 ) <nl> + * fix race leading to super columns assertion failure ( CASSANDRA - 3957 ) <nl> <nl> <nl> 1 . 0 . 8 <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index cb715de . . d27a963 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 140 , 6 + 140 , 26 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> return getType ( ) = = ColumnFamilyType . Super ; <nl> } <nl> <nl> + / * * <nl> + * Same as addAll ( ) but do a cloneMeShallow of SuperColumn if necessary to <nl> + * avoid keeping references to the structure ( see # 3957 ) . <nl> + * / <nl> + public void addAllWithSCCopy ( ColumnFamily cf , Allocator allocator ) <nl> + { <nl> + if ( cf . isSuper ( ) ) <nl> + { <nl> + for ( IColumn c : cf ) <nl> + { <nl> + columns . addColumn ( ( ( SuperColumn ) c ) . cloneMeShallow ( ) , allocator ) ; <nl> + } <nl> + delete ( cf ) ; <nl> + } <nl> + else <nl> + { <nl> + addAll ( cf , allocator ) ; <nl> + } <nl> + } <nl> + <nl> public void addColumn ( QueryPath path , ByteBuffer value , long timestamp ) <nl> { <nl> addColumn ( path , value , timestamp , 0 ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index b50662a . . 60a3487 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 787 , 7 + 787 , 10 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> ColumnFamily cachedRow = getRawCachedRow ( key ) ; <nl> if ( cachedRow ! = null ) <nl> - cachedRow . addAll ( columnFamily , HeapAllocator . instance ) ; <nl> + / / columnFamily is what is written in the commit log . Because of the PeriodicCommitLog , this can be done in concurrency <nl> + / / with this . So columnFamily shouldn ' t be modified and if it contains super columns , neither should they . So for super <nl> + / / columns , we must make sure to clone them when adding to the cache . That ' s what addAllWithSCCopy does ( see # 3957 ) <nl> + cachedRow . addAllWithSCCopy ( columnFamily , HeapAllocator . instance ) ; <nl> } <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7f8a3a1 . . 99ac3ad 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 9 
 + * Always select the live sstables when getting sstables in bounds ( CASSANDRA - 11944 ) 
 * Fix column ordering of results with static columns for Thrift requests in 
 a mixed 2 . x / 3 . x cluster , also fix potential non - resolved duplication of 
 those static columns in query results ( CASSANDRA - 12123 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 3264327 . . 1be3175 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1231 , 7 + 1231 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 * @ return sstables whose key range overlaps with that of the given sstables , not including itself . 
 * ( The given sstables may or may not overlap with each other . ) 
 * / 
 - public Collection < SSTableReader > getOverlappingSSTables ( SSTableSet sstableSet , Iterable < SSTableReader > sstables ) 
 + public Collection < SSTableReader > getOverlappingLiveSSTables ( Iterable < SSTableReader > sstables ) 
 { 
 logger . trace ( " Checking for sstables overlapping { } " , sstables ) ; 
 
 @ @ - 1282 , 7 + 1282 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 Set < SSTableReader > results = new HashSet < > ( ) ; 
 
 for ( AbstractBounds < PartitionPosition > bound : bounds ) 
 - Iterables . addAll ( results , view . sstablesInBounds ( sstableSet , bound . left , bound . right ) ) ; 
 + Iterables . addAll ( results , view . liveSSTablesInBounds ( bound . left , bound . right ) ) ; 
 
 return Sets . difference ( results , ImmutableSet . copyOf ( sstables ) ) ; 
 } 
 @ @ - 1290 , 11 + 1290 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 / * * 
 * like getOverlappingSSTables , but acquires references before returning 
 * / 
 - public Refs < SSTableReader > getAndReferenceOverlappingSSTables ( SSTableSet sstableSet , Iterable < SSTableReader > sstables ) 
 + public Refs < SSTableReader > getAndReferenceOverlappingLiveSSTables ( Iterable < SSTableReader > sstables ) 
 { 
 while ( true ) 
 { 
 - Iterable < SSTableReader > overlapped = getOverlappingSSTables ( sstableSet , sstables ) ; 
 + Iterable < SSTableReader > overlapped = getOverlappingLiveSSTables ( sstables ) ; 
 Refs < SSTableReader > refs = Refs . tryRef ( overlapped ) ; 
 if ( refs ! = null ) 
 return refs ; 
 diff - - git a / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java b / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java 
 index 9585b59 . . 842ad5f 100644 
 - - - a / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java 
 @ @ - 175 , 7 + 175 , 7 @ @ public class PartitionRangeReadCommand extends ReadCommand 
 
 protected UnfilteredPartitionIterator queryStorage ( final ColumnFamilyStore cfs , ReadOrderGroup orderGroup ) 
 { 
 - ColumnFamilyStore . ViewFragment view = cfs . select ( View . select ( SSTableSet . LIVE , dataRange ( ) . keyRange ( ) ) ) ; 
 + ColumnFamilyStore . ViewFragment view = cfs . select ( View . selectLive ( dataRange ( ) . keyRange ( ) ) ) ; 
 Tracing . trace ( " Executing seq scan across { } sstables for { } " , view . sstables . size ( ) , dataRange ( ) . keyRange ( ) . getString ( metadata ( ) . getKeyValidator ( ) ) ) ; 
 
 / / fetch data from current memtable , historical memtables , and SSTables in the correct order . 
 diff - - git a / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java b / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java 
 index 2a74ea9 . . 3461aef 100644 
 - - - a / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java 
 + + + b / src / java / org / apache / cassandra / db / SizeEstimatesRecorder . java 
 @ @ - 103 , 8 + 103 , 9 @ @ public class SizeEstimatesRecorder extends MigrationListener implements Runnable 
 { 
 while ( refs = = null ) 
 { 
 - ColumnFamilyStore . ViewFragment view = table . select ( View . select ( SSTableSet . CANONICAL , Range . makeRowRange ( range ) ) ) ; 
 - refs = Refs . tryRef ( view . sstables ) ; 
 + / / note that this is not guaranteed to return all sstables within the ranges , but for an estimated size , that should be fine 
 + Iterable < SSTableReader > canonicalSSTables = table . getTracker ( ) . getView ( ) . select ( SSTableSet . CANONICAL , table . select ( View . selectLive ( Range . makeRowRange ( range ) ) ) . sstables ) ; 
 + refs = Refs . tryRef ( canonicalSSTables ) ; 
 } 
 
 / / calculate the estimates . 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 index e30e4f7 . . 0dce52b 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / AbstractCompactionStrategy . java 
 @ @ - 380 , 7 + 380 , 7 @ @ public abstract class AbstractCompactionStrategy 
 if ( uncheckedTombstoneCompaction ) 
 return true ; 
 
 - Collection < SSTableReader > overlaps = cfs . getOverlappingSSTables ( SSTableSet . CANONICAL , Collections . singleton ( sstable ) ) ; 
 + Collection < SSTableReader > overlaps = cfs . getOverlappingLiveSSTables ( Collections . singleton ( sstable ) ) ; 
 if ( overlaps . isEmpty ( ) ) 
 { 
 / / there is no overlap , tombstones are safely droppable 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionController . java b / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 index a5b8308 . . fbf29e3 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 @ @ - 103 , 7 + 103 , 7 @ @ public class CompactionController implements AutoCloseable 
 if ( compacting = = null ) 
 overlappingSSTables = Refs . tryRef ( Collections . < SSTableReader > emptyList ( ) ) ; 
 else 
 - overlappingSSTables = cfs . getAndReferenceOverlappingSSTables ( SSTableSet . LIVE , compacting ) ; 
 + overlappingSSTables = cfs . getAndReferenceOverlappingLiveSSTables ( compacting ) ; 
 this . overlapIterator = new OverlapIterator < > ( buildIntervals ( overlappingSSTables ) ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 index 8571906 . . 3e6ae61 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 @ @ - 99 , 7 + 99 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 if ( System . currentTimeMillis ( ) - lastExpiredCheck > options . expiredSSTableCheckFrequency ) 
 { 
 / / Find fully expired SSTables . Those will be included no matter what . 
 - expired = CompactionController . getFullyExpiredSSTables ( cfs , uncompacting , cfs . getOverlappingSSTables ( SSTableSet . CANONICAL , uncompacting ) , gcBefore ) ; 
 + expired = CompactionController . getFullyExpiredSSTables ( cfs , uncompacting , cfs . getOverlappingLiveSSTables ( uncompacting ) , gcBefore ) ; 
 lastExpiredCheck = System . currentTimeMillis ( ) ; 
 } 
 Set < SSTableReader > candidates = Sets . newHashSet ( filterSuspectSSTables ( uncompacting ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java 
 index d1630c5 . . e2ab7dc 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java 
 @ @ - 104 , 7 + 104 , 7 @ @ public class TimeWindowCompactionStrategy extends AbstractCompactionStrategy 
 if ( System . currentTimeMillis ( ) - lastExpiredCheck > options . expiredSSTableCheckFrequency ) 
 { 
 logger . debug ( " TWCS expired check sufficiently far in the past , checking for fully expired SSTables " ) ; 
 - expired = CompactionController . getFullyExpiredSSTables ( cfs , uncompacting , cfs . getOverlappingSSTables ( SSTableSet . CANONICAL , uncompacting ) , gcBefore ) ; 
 + expired = CompactionController . getFullyExpiredSSTables ( cfs , uncompacting , cfs . getOverlappingLiveSSTables ( uncompacting ) , gcBefore ) ; 
 lastExpiredCheck = System . currentTimeMillis ( ) ; 
 } 
 else 
 diff - - git a / src / java / org / apache / cassandra / db / lifecycle / View . java b / src / java / org / apache / cassandra / db / lifecycle / View . java 
 index 99903fc . . 96aaa49 100644 
 - - - a / src / java / org / apache / cassandra / db / lifecycle / View . java 
 + + + b / src / java / org / apache / cassandra / db / lifecycle / View . java 
 @ @ - 136 , 7 + 136 , 7 @ @ public class View 
 return Iterables . concat ( sstables , filterOut ( compacting , sstables ) ) ; 
 } 
 
 - private Iterable < SSTableReader > select ( SSTableSet sstableSet , Iterable < SSTableReader > sstables ) 
 + public Iterable < SSTableReader > select ( SSTableSet sstableSet , Iterable < SSTableReader > sstables ) 
 { 
 switch ( sstableSet ) 
 { 
 @ @ - 182 , 7 + 182 , 7 @ @ public class View 
 * Returns the sstables that have any partition between { @ code left } and { @ code right } , when both bounds are taken inclusively . 
 * The interval formed by { @ code left } and { @ code right } shouldn ' t wrap . 
 * / 
 - public Iterable < SSTableReader > sstablesInBounds ( SSTableSet sstableSet , PartitionPosition left , PartitionPosition right ) 
 + public Iterable < SSTableReader > liveSSTablesInBounds ( PartitionPosition left , PartitionPosition right ) 
 { 
 assert ! AbstractBounds . strictlyWrapsAround ( left , right ) ; 
 
 @ @ - 190 , 7 + 190 , 7 @ @ public class View 
 return Collections . emptyList ( ) ; 
 
 PartitionPosition stopInTree = right . isMinimum ( ) ? intervalTree . max ( ) : right ; 
 - return select ( sstableSet , intervalTree . search ( Interval . create ( left , stopInTree ) ) ) ; 
 + return select ( SSTableSet . LIVE , intervalTree . search ( Interval . create ( left , stopInTree ) ) ) ; 
 } 
 
 public static List < SSTableReader > sstablesInBounds ( PartitionPosition left , PartitionPosition right , SSTableIntervalTree intervalTree ) 
 @ @ - 228 , 14 + 228 , 14 @ @ public class View 
 * @ return a ViewFragment containing the sstables and memtables that may need to be merged 
 * for rows within @ param rowBounds , inclusive , according to the interval tree . 
 * / 
 - public static Function < View , Iterable < SSTableReader > > select ( SSTableSet sstableSet , AbstractBounds < PartitionPosition > rowBounds ) 
 + public static Function < View , Iterable < SSTableReader > > selectLive ( AbstractBounds < PartitionPosition > rowBounds ) 
 { 
 / / Note that View . sstablesInBounds always includes it ' s bound while rowBounds may not . This is ok however 
 / / because the fact we restrict the sstables returned by this function is an optimization in the first 
 / / place and the returned sstables will ( almost ) never cover * exactly * rowBounds anyway . It ' s also 
 / / * very * unlikely that a sstable is included * just * because we consider one of the bound inclusively 
 / / instead of exclusively , so the performance impact is negligible in practice . 
 - return ( view ) - > view . sstablesInBounds ( sstableSet , rowBounds . left , rowBounds . right ) ; 
 + return ( view ) - > view . liveSSTablesInBounds ( rowBounds . left , rowBounds . right ) ; 
 } 
 
 / / METHODS TO CONSTRUCT FUNCTIONS FOR MODIFYING A VIEW : 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 index d5c060e . . a14f815 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 @ @ - 29 , 8 + 29 , 8 @ @ import com . google . common . annotations . VisibleForTesting ; 
 import com . google . common . collect . * ; 
 
 import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; 
 - import org . apache . cassandra . db . lifecycle . SSTableSet ; 
 import org . apache . cassandra . db . lifecycle . SSTableIntervalTree ; 
 + import org . apache . cassandra . db . lifecycle . SSTableSet ; 
 import org . apache . cassandra . db . lifecycle . View ; 
 import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 import org . slf4j . Logger ; 
 @ @ - 332 , 6 + 332 , 12 @ @ public class StreamSession implements IEndpointStateChangeSubscriber 
 SSTableIntervalTree intervalTree = SSTableIntervalTree . build ( view . sstables ( SSTableSet . CANONICAL ) ) ; 
 for ( Range < PartitionPosition > keyRange : keyRanges ) 
 { 
 + / / keyRange excludes its start , while sstableInBounds is inclusive ( of both start and end ) . 
 + / / This is fine however , because keyRange has been created from a token range through Range . makeRowRange ( see above ) . 
 + / / And that later method uses the Token . maxKeyBound ( ) method to creates the range , which return a " fake " key that 
 + / / sort after all keys having the token . That " fake " key cannot however be equal to any real key , so that even 
 + / / including keyRange . left will still exclude any key having the token of the original token range , and so we ' re 
 + / / still actually selecting what we wanted . 
 for ( SSTableReader sstable : View . sstablesInBounds ( keyRange . left , keyRange . right , intervalTree ) ) 
 { 
 if ( ! isIncremental | | ! sstable . isRepaired ( ) ) 
 diff - - git a / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java b / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java 
 index 8a5e00e . . 98f9300 100644 
 - - - a / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java 
 + + + b / test / unit / org / apache / cassandra / db / lifecycle / ViewTest . java 
 @ @ - 71 , 7 + 71 , 7 @ @ public class ViewTest 
 continue ; 
 
 AbstractBounds < PartitionPosition > bounds = AbstractBounds . bounds ( min , minInc , max , maxInc ) ; 
 - List < SSTableReader > r = ImmutableList . copyOf ( initialView . sstablesInBounds ( SSTableSet . LIVE , bounds . left , bounds . right ) ) ; 
 + List < SSTableReader > r = ImmutableList . copyOf ( initialView . liveSSTablesInBounds ( bounds . left , bounds . right ) ) ; 
 Assert . assertEquals ( String . format ( " % d ( % s ) % d ( % s ) " , i , minInc , j , maxInc ) , j - i + ( minInc ? 0 : - 1 ) + ( maxInc ? 1 : 0 ) , r . size ( ) ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c453943 . . 925a4a9 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 9 , 6 + 9 , 7 @ @ 
 * Fix division - by - zero error on get _ slice ( CASSANDRA - 4000 ) 
 * don ' t change manifest level for cleanup , scrub , and upgradesstables 
 operations under LeveledCompactionStrategy ( CASSANDRA - 3989 ) 
 + * fix race leading to super columns assertion failure ( CASSANDRA - 3957 ) 
 
 
 1 . 0 . 8 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index cb715de . . d27a963 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 140 , 6 + 140 , 26 @ @ public class ColumnFamily extends AbstractColumnContainer 
 return getType ( ) = = ColumnFamilyType . Super ; 
 } 
 
 + / * * 
 + * Same as addAll ( ) but do a cloneMeShallow of SuperColumn if necessary to 
 + * avoid keeping references to the structure ( see # 3957 ) . 
 + * / 
 + public void addAllWithSCCopy ( ColumnFamily cf , Allocator allocator ) 
 + { 
 + if ( cf . isSuper ( ) ) 
 + { 
 + for ( IColumn c : cf ) 
 + { 
 + columns . addColumn ( ( ( SuperColumn ) c ) . cloneMeShallow ( ) , allocator ) ; 
 + } 
 + delete ( cf ) ; 
 + } 
 + else 
 + { 
 + addAll ( cf , allocator ) ; 
 + } 
 + } 
 + 
 public void addColumn ( QueryPath path , ByteBuffer value , long timestamp ) 
 { 
 addColumn ( path , value , timestamp , 0 ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index b50662a . . 60a3487 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 787 , 7 + 787 , 10 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 ColumnFamily cachedRow = getRawCachedRow ( key ) ; 
 if ( cachedRow ! = null ) 
 - cachedRow . addAll ( columnFamily , HeapAllocator . instance ) ; 
 + / / columnFamily is what is written in the commit log . Because of the PeriodicCommitLog , this can be done in concurrency 
 + / / with this . So columnFamily shouldn ' t be modified and if it contains super columns , neither should they . So for super 
 + / / columns , we must make sure to clone them when adding to the cache . That ' s what addAllWithSCCopy does ( see # 3957 ) 
 + cachedRow . addAllWithSCCopy ( columnFamily , HeapAllocator . instance ) ; 
 } 
 } 

