BLEU SCORE: 0.027611988917697356

TEST MSG: Allow native functions in user - defined aggregates
GENERATED MSG: Reenable ALTER TABLE DROP with new semantics

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f821136 . . 93753e5 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 <nl> + * Allow native functions in user - defined aggregates ( CASSANDRA - 9542 ) <nl> * Don ' t repair system _ distributed by default ( CASSANDRA - 9621 ) <nl> * Fix mixing min , max , and count aggregates for blob type ( CASSANRA - 9622 ) <nl> * Rename class for DATE type in Java driver ( CASSANDRA - 9563 ) <nl> diff - - git a / doc / cql3 / CQL . textile b / doc / cql3 / CQL . textile <nl> index 689ac94 . . ec1f660 100644 <nl> - - - a / doc / cql3 / CQL . textile <nl> + + + b / doc / cql3 / CQL . textile <nl> @ @ - 708 , 9 + 708 , 9 @ @ Signatures for user - defined aggregates follow the " same rules " : # functionSignatur <nl> <nl> The optional @ INITCOND @ defines the initial state value for the aggregate . It defaults to @ null @ . A non - @ null @ @ INITCOND @ must be specified for state functions that are declared with @ RETURNS NULL ON NULL INPUT @ . <nl> <nl> - @ SFUNC @ references an existing function to be used as the state modifying function . The type of first argument of the state function must match @ STYPE @ . The remaining argument types of the state function must match the argument types of the aggregate function . State is not updated for state functions declared with @ RETURNS NULL ON NULL INPUT @ and called with @ null @ . <nl> + @ SFUNC @ references an existing function to be used as the state modifying function . The type of first argument of the state function must match @ STYPE @ . The remaining argument types of the state function must match the argument types of the aggregate function . State is not updated for state functions declared with @ RETURNS NULL ON NULL INPUT @ and called with @ null @ . Functions from the system keyspace are resolved before functions in the current keyspace . <nl> <nl> - The optional @ FINALFUNC @ is called just before the aggregate result is returned . It must take only one argument with type @ STYPE @ . The return type of the @ FINALFUNC @ may be a different type . A final function declared with @ RETURNS NULL ON NULL INPUT @ means that the aggregate ' s return value will be @ null @ , if the last state is @ null @ . <nl> + The optional @ FINALFUNC @ is called just before the aggregate result is returned . It must take only one argument with type @ STYPE @ . The return type of the @ FINALFUNC @ may be a different type . A final function declared with @ RETURNS NULL ON NULL INPUT @ means that the aggregate ' s return value will be @ null @ , if the last state is @ null @ . Functions from the system keyspace are resolved before functions in the current keyspace . <nl> <nl> If no @ FINALFUNC @ is defined , the overall return type of the aggregate function is @ STYPE @ . If a @ FINALFUNC @ is defined , it is the return type of that function . <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateAggregateStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateAggregateStatement . java <nl> index 8b6c8d6 . . 039993f 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateAggregateStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateAggregateStatement . java <nl> @ @ - 86 , 7 + 86 , 11 @ @ public final class CreateAggregateStatement extends SchemaAlteringStatement <nl> argTypes . add ( prepareType ( " arguments " , rawType ) ) ; <nl> <nl> AbstractType < ? > stateType = prepareType ( " state type " , stateTypeRaw ) ; <nl> - Function f = Functions . find ( stateFunc , stateArguments ( stateType , argTypes ) ) ; <nl> + <nl> + List < AbstractType < ? > > stateArgs = stateArguments ( stateType , argTypes ) ; <nl> + stateFunc = validateFunctionKeyspace ( stateFunc , stateArgs ) ; <nl> + <nl> + Function f = Functions . find ( stateFunc , stateArgs ) ; <nl> if ( ! ( f instanceof ScalarFunction ) ) <nl> throw new InvalidRequestException ( " State function " + stateFuncSig ( stateFunc , stateTypeRaw , argRawTypes ) + " does not exist or is not a scalar function " ) ; <nl> stateFunction = ( ScalarFunction ) f ; <nl> @ @ - 97 , 7 + 101 , 9 @ @ public final class CreateAggregateStatement extends SchemaAlteringStatement <nl> <nl> if ( finalFunc ! = null ) <nl> { <nl> - f = Functions . find ( finalFunc , Collections . < AbstractType < ? > > singletonList ( stateType ) ) ; <nl> + List < AbstractType < ? > > finalArgs = Collections . < AbstractType < ? > > singletonList ( stateType ) ; <nl> + finalFunc = validateFunctionKeyspace ( finalFunc , finalArgs ) ; <nl> + f = Functions . find ( finalFunc , finalArgs ) ; <nl> if ( ! ( f instanceof ScalarFunction ) ) <nl> throw new InvalidRequestException ( " Final function " + finalFunc + ' ( ' + stateTypeRaw + " ) does not exist or is not a scalar function " ) ; <nl> finalFunction = ( ScalarFunction ) f ; <nl> @ @ - 141 , 18 + 147 , 20 @ @ public final class CreateAggregateStatement extends SchemaAlteringStatement <nl> if ( ! functionName . hasKeyspace ( ) ) <nl> throw new InvalidRequestException ( " Functions must be fully qualified with a keyspace name if a keyspace is not set for the session " ) ; <nl> <nl> - stateFunc = validateFunctionKeyspace ( stateFunc ) ; <nl> - <nl> - if ( finalFunc ! = null ) <nl> - finalFunc = validateFunctionKeyspace ( finalFunc ) ; <nl> - <nl> ThriftValidation . validateKeyspaceNotSystem ( functionName . keyspace ) ; <nl> } <nl> <nl> - private FunctionName validateFunctionKeyspace ( FunctionName func ) <nl> + private FunctionName validateFunctionKeyspace ( FunctionName func , List < AbstractType < ? > > argTypes ) <nl> { <nl> if ( ! func . hasKeyspace ( ) ) <nl> + { <nl> + / / If state / final function has no keyspace , check SYSTEM keyspace before logged keyspace . <nl> + FunctionName nativeName = FunctionName . nativeFunction ( func . name ) ; <nl> + if ( Functions . find ( nativeName , argTypes ) ! = null ) <nl> + return nativeName ; <nl> + <nl> return new FunctionName ( functionName . keyspace , func . name ) ; <nl> + } <nl> else if ( ! SystemKeyspace . NAME . equals ( func . keyspace ) & & ! functionName . keyspace . equals ( func . keyspace ) ) <nl> throw new InvalidRequestException ( String . format ( " Statement on keyspace % s cannot refer to a user function in keyspace % s ; " <nl> + " user functions can only be used in the keyspace they are defined in " , <nl> diff - - git a / src / java / org / apache / cassandra / schema / LegacySchemaTables . java b / src / java / org / apache / cassandra / schema / LegacySchemaTables . java <nl> index 1840829 . . b8f6421 100644 <nl> - - - a / src / java / org / apache / cassandra / schema / LegacySchemaTables . java <nl> + + + b / src / java / org / apache / cassandra / schema / LegacySchemaTables . java <nl> @ @ - 1393 , 11 + 1393 , 11 @ @ public class LegacySchemaTables <nl> <nl> adder . resetCollection ( " argument _ types " ) ; <nl> adder . add ( " return _ type " , aggregate . returnType ( ) . toString ( ) ) ; <nl> - adder . add ( " state _ func " , aggregate . stateFunction ( ) . name ( ) . name ) ; <nl> + adder . add ( " state _ func " , aggregate . stateFunction ( ) . name ( ) . toString ( ) ) ; <nl> if ( aggregate . stateType ( ) ! = null ) <nl> adder . add ( " state _ type " , aggregate . stateType ( ) . toString ( ) ) ; <nl> if ( aggregate . finalFunction ( ) ! = null ) <nl> - adder . add ( " final _ func " , aggregate . finalFunction ( ) . name ( ) . name ) ; <nl> + adder . add ( " final _ func " , aggregate . finalFunction ( ) . name ( ) . toString ( ) ) ; <nl> if ( aggregate . initialCondition ( ) ! = null ) <nl> adder . add ( " initcond " , aggregate . initialCondition ( ) ) ; <nl> <nl> @ @ - 1439 , 8 + 1439 , 8 @ @ public class LegacySchemaTables <nl> <nl> AbstractType < ? > returnType = parseType ( row . getString ( " return _ type " ) ) ; <nl> <nl> - FunctionName stateFunc = new FunctionName ( ksName , row . getString ( " state _ func " ) ) ; <nl> - FunctionName finalFunc = row . has ( " final _ func " ) ? new FunctionName ( ksName , row . getString ( " final _ func " ) ) : null ; <nl> + FunctionName stateFunc = aggregateParseFunctionName ( ksName , row . getString ( " state _ func " ) ) ; <nl> + FunctionName finalFunc = row . has ( " final _ func " ) ? aggregateParseFunctionName ( ksName , row . getString ( " final _ func " ) ) : null ; <nl> AbstractType < ? > stateType = row . has ( " state _ type " ) ? parseType ( row . getString ( " state _ type " ) ) : null ; <nl> ByteBuffer initcond = row . has ( " initcond " ) ? row . getBytes ( " initcond " ) : null ; <nl> <nl> @ @ - 1454 , 6 + 1454 , 23 @ @ public class LegacySchemaTables <nl> } <nl> } <nl> <nl> + private static FunctionName aggregateParseFunctionName ( String ksName , String func ) <nl> + { <nl> + int i = func . indexOf ( ' . ' ) ; <nl> + <nl> + / / function name can be abbreviated ( pre 2 . 2rc2 ) - it is in the same keyspace as the aggregate <nl> + if ( i = = - 1 ) <nl> + return new FunctionName ( ksName , func ) ; <nl> + <nl> + String ks = func . substring ( 0 , i ) ; <nl> + String f = func . substring ( i + 1 ) ; <nl> + <nl> + / / only aggregate ' s function keyspace and system keyspace are allowed <nl> + assert ks . equals ( ksName ) | | ks . equals ( SystemKeyspace . NAME ) ; <nl> + <nl> + return new FunctionName ( ks , f ) ; <nl> + } <nl> + <nl> public static Mutation makeDropAggregateMutation ( KSMetaData keyspace , UDAggregate aggregate , long timestamp ) <nl> { <nl> / / Include the serialized keyspace in case the target node missed a CREATE KEYSPACE migration ( see CASSANDRA - 5631 ) . <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / AggregationTest . java b / test / unit / org / apache / cassandra / cql3 / AggregationTest . java <nl> index 4281262 . . 38c4759 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / AggregationTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / AggregationTest . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . cql3 . functions . Functions ; <nl> import org . apache . cassandra . cql3 . functions . UDAggregate ; <nl> import org . apache . cassandra . exceptions . FunctionExecutionException ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> + import org . apache . cassandra . serializers . Int32Serializer ; <nl> import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . transport . Event ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> @ @ - 1096 , 7 + 1097 , 7 @ @ public class AggregationTest extends CQLTester <nl> " FINALFUNC " + shortFunctionName ( fFinal ) + ' ' + <nl> " INITCOND 1 " ) ; <nl> <nl> - assertInvalidMessage ( String . format ( " Statement on keyspace % s cannot refer to a user function in keyspace % s ; user functions can only be used in the keyspace they are defined in " , <nl> + assertInvalidMessage ( String . format ( " Statement on keyspace % s cannot refer to a user type in keyspace % s ; user types can only be used in the keyspace they are defined in " , <nl> KEYSPACE _ PER _ TEST , KEYSPACE ) , <nl> " CREATE AGGREGATE " + KEYSPACE _ PER _ TEST + " . test _ wrong _ ks ( int ) " + <nl> " SFUNC " + fStateWrong + ' ' + <nl> @ @ - 1104 , 7 + 1105 , 7 @ @ public class AggregationTest extends CQLTester <nl> " FINALFUNC " + shortFunctionName ( fFinal ) + ' ' + <nl> " INITCOND 1 " ) ; <nl> <nl> - assertInvalidMessage ( String . format ( " Statement on keyspace % s cannot refer to a user function in keyspace % s ; user functions can only be used in the keyspace they are defined in " , <nl> + assertInvalidMessage ( String . format ( " Statement on keyspace % s cannot refer to a user type in keyspace % s ; user types can only be used in the keyspace they are defined in " , <nl> KEYSPACE _ PER _ TEST , KEYSPACE ) , <nl> " CREATE AGGREGATE " + KEYSPACE _ PER _ TEST + " . test _ wrong _ ks ( int ) " + <nl> " SFUNC " + shortFunctionName ( fState ) + ' ' + <nl> @ @ - 1404 , 7 + 1405 , 7 @ @ public class AggregationTest extends CQLTester <nl> " AS ' return \ " fin \ " + a ; ' " ) ; <nl> <nl> String aCON = createAggregate ( KEYSPACE , <nl> - " text , text " , <nl> + " text " , <nl> " CREATE AGGREGATE % s ( text ) " + <nl> " SFUNC " + shortFunctionName ( fCON ) + ' ' + <nl> " STYPE text " + <nl> @ @ - 1428 , 7 + 1429 , 7 @ @ public class AggregationTest extends CQLTester <nl> " AS ' return \ " fin \ " + a ; ' " ) ; <nl> <nl> String aRNON = createAggregate ( KEYSPACE , <nl> - " int , int " , <nl> + " int " , <nl> " CREATE AGGREGATE % s ( text ) " + <nl> " SFUNC " + shortFunctionName ( fRNON ) + ' ' + <nl> " STYPE text " + <nl> @ @ - 1447 , 4 + 1448 , 32 @ @ public class AggregationTest extends CQLTester <nl> assertRows ( execute ( " SELECT " + aRNON + " ( b ) FROM % s " ) , row ( " fin " ) ) ; <nl> <nl> } <nl> + <nl> + @ Test <nl> + public void testSystemKsFuncs ( ) throws Throwable <nl> + { <nl> + <nl> + String fAdder = createFunction ( KEYSPACE , <nl> + " int , int " , <nl> + " CREATE FUNCTION % s ( a int , b int ) " + <nl> + " CALLED ON NULL INPUT " + <nl> + " RETURNS int " + <nl> + " LANGUAGE java " + <nl> + " AS ' return ( a ! = null ? a : 0 ) + ( b ! = null ? b : 0 ) ; ' " ) ; <nl> + <nl> + String aAggr = createAggregate ( KEYSPACE , <nl> + " int " , <nl> + " CREATE AGGREGATE % s ( int ) " + <nl> + " SFUNC " + shortFunctionName ( fAdder ) + ' ' + <nl> + " STYPE int " + <nl> + " FINALFUNC intasblob " ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( a int primary key , b int ) " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 1 , 1 ) " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 2 , 2 ) " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 3 , 3 ) " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT " + aAggr + " ( b ) FROM % s " ) , row ( Int32Serializer . instance . serialize ( 6 ) ) ) ; <nl> + <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / UFTest . java b / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> index 1b3326b . . 40f2dd3 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> @ @ - 16 , 6 + 16 , 7 @ @ <nl> * limitations under the License . <nl> * / <nl> package org . apache . cassandra . cql3 ; <nl> + <nl> import java . math . BigDecimal ; <nl> import java . math . BigInteger ; <nl> import java . nio . ByteBuffer ;
NEAREST DIFF (one line): diff - - git a / debian / changelog b / debian / changelog <nl> index 739e38a . . 76bac83 100644 <nl> - - - a / debian / changelog <nl> + + + b / debian / changelog <nl> @ @ - 2 , 7 + 2 , 7 @ @ cassandra ( 1 . 1 . 11 ) unstable ; urgency = low <nl> <nl> * New release <nl> <nl> - - - Eric Evans < eevans @ apache . org > , 16 Apr 2013 18 : 56 : 03 - 0500 <nl> + - - Eric Evans < eevans @ apache . org > Tue , 16 Apr 2013 18 : 56 : 03 - 0500 <nl> <nl> cassandra ( 1 . 1 . 10 ) unstable ; urgency = low <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f821136 . . 93753e5 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 
 + * Allow native functions in user - defined aggregates ( CASSANDRA - 9542 ) 
 * Don ' t repair system _ distributed by default ( CASSANDRA - 9621 ) 
 * Fix mixing min , max , and count aggregates for blob type ( CASSANRA - 9622 ) 
 * Rename class for DATE type in Java driver ( CASSANDRA - 9563 ) 
 diff - - git a / doc / cql3 / CQL . textile b / doc / cql3 / CQL . textile 
 index 689ac94 . . ec1f660 100644 
 - - - a / doc / cql3 / CQL . textile 
 + + + b / doc / cql3 / CQL . textile 
 @ @ - 708 , 9 + 708 , 9 @ @ Signatures for user - defined aggregates follow the " same rules " : # functionSignatur 
 
 The optional @ INITCOND @ defines the initial state value for the aggregate . It defaults to @ null @ . A non - @ null @ @ INITCOND @ must be specified for state functions that are declared with @ RETURNS NULL ON NULL INPUT @ . 
 
 - @ SFUNC @ references an existing function to be used as the state modifying function . The type of first argument of the state function must match @ STYPE @ . The remaining argument types of the state function must match the argument types of the aggregate function . State is not updated for state functions declared with @ RETURNS NULL ON NULL INPUT @ and called with @ null @ . 
 + @ SFUNC @ references an existing function to be used as the state modifying function . The type of first argument of the state function must match @ STYPE @ . The remaining argument types of the state function must match the argument types of the aggregate function . State is not updated for state functions declared with @ RETURNS NULL ON NULL INPUT @ and called with @ null @ . Functions from the system keyspace are resolved before functions in the current keyspace . 
 
 - The optional @ FINALFUNC @ is called just before the aggregate result is returned . It must take only one argument with type @ STYPE @ . The return type of the @ FINALFUNC @ may be a different type . A final function declared with @ RETURNS NULL ON NULL INPUT @ means that the aggregate ' s return value will be @ null @ , if the last state is @ null @ . 
 + The optional @ FINALFUNC @ is called just before the aggregate result is returned . It must take only one argument with type @ STYPE @ . The return type of the @ FINALFUNC @ may be a different type . A final function declared with @ RETURNS NULL ON NULL INPUT @ means that the aggregate ' s return value will be @ null @ , if the last state is @ null @ . Functions from the system keyspace are resolved before functions in the current keyspace . 
 
 If no @ FINALFUNC @ is defined , the overall return type of the aggregate function is @ STYPE @ . If a @ FINALFUNC @ is defined , it is the return type of that function . 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateAggregateStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateAggregateStatement . java 
 index 8b6c8d6 . . 039993f 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateAggregateStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateAggregateStatement . java 
 @ @ - 86 , 7 + 86 , 11 @ @ public final class CreateAggregateStatement extends SchemaAlteringStatement 
 argTypes . add ( prepareType ( " arguments " , rawType ) ) ; 
 
 AbstractType < ? > stateType = prepareType ( " state type " , stateTypeRaw ) ; 
 - Function f = Functions . find ( stateFunc , stateArguments ( stateType , argTypes ) ) ; 
 + 
 + List < AbstractType < ? > > stateArgs = stateArguments ( stateType , argTypes ) ; 
 + stateFunc = validateFunctionKeyspace ( stateFunc , stateArgs ) ; 
 + 
 + Function f = Functions . find ( stateFunc , stateArgs ) ; 
 if ( ! ( f instanceof ScalarFunction ) ) 
 throw new InvalidRequestException ( " State function " + stateFuncSig ( stateFunc , stateTypeRaw , argRawTypes ) + " does not exist or is not a scalar function " ) ; 
 stateFunction = ( ScalarFunction ) f ; 
 @ @ - 97 , 7 + 101 , 9 @ @ public final class CreateAggregateStatement extends SchemaAlteringStatement 
 
 if ( finalFunc ! = null ) 
 { 
 - f = Functions . find ( finalFunc , Collections . < AbstractType < ? > > singletonList ( stateType ) ) ; 
 + List < AbstractType < ? > > finalArgs = Collections . < AbstractType < ? > > singletonList ( stateType ) ; 
 + finalFunc = validateFunctionKeyspace ( finalFunc , finalArgs ) ; 
 + f = Functions . find ( finalFunc , finalArgs ) ; 
 if ( ! ( f instanceof ScalarFunction ) ) 
 throw new InvalidRequestException ( " Final function " + finalFunc + ' ( ' + stateTypeRaw + " ) does not exist or is not a scalar function " ) ; 
 finalFunction = ( ScalarFunction ) f ; 
 @ @ - 141 , 18 + 147 , 20 @ @ public final class CreateAggregateStatement extends SchemaAlteringStatement 
 if ( ! functionName . hasKeyspace ( ) ) 
 throw new InvalidRequestException ( " Functions must be fully qualified with a keyspace name if a keyspace is not set for the session " ) ; 
 
 - stateFunc = validateFunctionKeyspace ( stateFunc ) ; 
 - 
 - if ( finalFunc ! = null ) 
 - finalFunc = validateFunctionKeyspace ( finalFunc ) ; 
 - 
 ThriftValidation . validateKeyspaceNotSystem ( functionName . keyspace ) ; 
 } 
 
 - private FunctionName validateFunctionKeyspace ( FunctionName func ) 
 + private FunctionName validateFunctionKeyspace ( FunctionName func , List < AbstractType < ? > > argTypes ) 
 { 
 if ( ! func . hasKeyspace ( ) ) 
 + { 
 + / / If state / final function has no keyspace , check SYSTEM keyspace before logged keyspace . 
 + FunctionName nativeName = FunctionName . nativeFunction ( func . name ) ; 
 + if ( Functions . find ( nativeName , argTypes ) ! = null ) 
 + return nativeName ; 
 + 
 return new FunctionName ( functionName . keyspace , func . name ) ; 
 + } 
 else if ( ! SystemKeyspace . NAME . equals ( func . keyspace ) & & ! functionName . keyspace . equals ( func . keyspace ) ) 
 throw new InvalidRequestException ( String . format ( " Statement on keyspace % s cannot refer to a user function in keyspace % s ; " 
 + " user functions can only be used in the keyspace they are defined in " , 
 diff - - git a / src / java / org / apache / cassandra / schema / LegacySchemaTables . java b / src / java / org / apache / cassandra / schema / LegacySchemaTables . java 
 index 1840829 . . b8f6421 100644 
 - - - a / src / java / org / apache / cassandra / schema / LegacySchemaTables . java 
 + + + b / src / java / org / apache / cassandra / schema / LegacySchemaTables . java 
 @ @ - 1393 , 11 + 1393 , 11 @ @ public class LegacySchemaTables 
 
 adder . resetCollection ( " argument _ types " ) ; 
 adder . add ( " return _ type " , aggregate . returnType ( ) . toString ( ) ) ; 
 - adder . add ( " state _ func " , aggregate . stateFunction ( ) . name ( ) . name ) ; 
 + adder . add ( " state _ func " , aggregate . stateFunction ( ) . name ( ) . toString ( ) ) ; 
 if ( aggregate . stateType ( ) ! = null ) 
 adder . add ( " state _ type " , aggregate . stateType ( ) . toString ( ) ) ; 
 if ( aggregate . finalFunction ( ) ! = null ) 
 - adder . add ( " final _ func " , aggregate . finalFunction ( ) . name ( ) . name ) ; 
 + adder . add ( " final _ func " , aggregate . finalFunction ( ) . name ( ) . toString ( ) ) ; 
 if ( aggregate . initialCondition ( ) ! = null ) 
 adder . add ( " initcond " , aggregate . initialCondition ( ) ) ; 
 
 @ @ - 1439 , 8 + 1439 , 8 @ @ public class LegacySchemaTables 
 
 AbstractType < ? > returnType = parseType ( row . getString ( " return _ type " ) ) ; 
 
 - FunctionName stateFunc = new FunctionName ( ksName , row . getString ( " state _ func " ) ) ; 
 - FunctionName finalFunc = row . has ( " final _ func " ) ? new FunctionName ( ksName , row . getString ( " final _ func " ) ) : null ; 
 + FunctionName stateFunc = aggregateParseFunctionName ( ksName , row . getString ( " state _ func " ) ) ; 
 + FunctionName finalFunc = row . has ( " final _ func " ) ? aggregateParseFunctionName ( ksName , row . getString ( " final _ func " ) ) : null ; 
 AbstractType < ? > stateType = row . has ( " state _ type " ) ? parseType ( row . getString ( " state _ type " ) ) : null ; 
 ByteBuffer initcond = row . has ( " initcond " ) ? row . getBytes ( " initcond " ) : null ; 
 
 @ @ - 1454 , 6 + 1454 , 23 @ @ public class LegacySchemaTables 
 } 
 } 
 
 + private static FunctionName aggregateParseFunctionName ( String ksName , String func ) 
 + { 
 + int i = func . indexOf ( ' . ' ) ; 
 + 
 + / / function name can be abbreviated ( pre 2 . 2rc2 ) - it is in the same keyspace as the aggregate 
 + if ( i = = - 1 ) 
 + return new FunctionName ( ksName , func ) ; 
 + 
 + String ks = func . substring ( 0 , i ) ; 
 + String f = func . substring ( i + 1 ) ; 
 + 
 + / / only aggregate ' s function keyspace and system keyspace are allowed 
 + assert ks . equals ( ksName ) | | ks . equals ( SystemKeyspace . NAME ) ; 
 + 
 + return new FunctionName ( ks , f ) ; 
 + } 
 + 
 public static Mutation makeDropAggregateMutation ( KSMetaData keyspace , UDAggregate aggregate , long timestamp ) 
 { 
 / / Include the serialized keyspace in case the target node missed a CREATE KEYSPACE migration ( see CASSANDRA - 5631 ) . 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / AggregationTest . java b / test / unit / org / apache / cassandra / cql3 / AggregationTest . java 
 index 4281262 . . 38c4759 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / AggregationTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / AggregationTest . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . cql3 . functions . Functions ; 
 import org . apache . cassandra . cql3 . functions . UDAggregate ; 
 import org . apache . cassandra . exceptions . FunctionExecutionException ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 + import org . apache . cassandra . serializers . Int32Serializer ; 
 import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . transport . Event ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 @ @ - 1096 , 7 + 1097 , 7 @ @ public class AggregationTest extends CQLTester 
 " FINALFUNC " + shortFunctionName ( fFinal ) + ' ' + 
 " INITCOND 1 " ) ; 
 
 - assertInvalidMessage ( String . format ( " Statement on keyspace % s cannot refer to a user function in keyspace % s ; user functions can only be used in the keyspace they are defined in " , 
 + assertInvalidMessage ( String . format ( " Statement on keyspace % s cannot refer to a user type in keyspace % s ; user types can only be used in the keyspace they are defined in " , 
 KEYSPACE _ PER _ TEST , KEYSPACE ) , 
 " CREATE AGGREGATE " + KEYSPACE _ PER _ TEST + " . test _ wrong _ ks ( int ) " + 
 " SFUNC " + fStateWrong + ' ' + 
 @ @ - 1104 , 7 + 1105 , 7 @ @ public class AggregationTest extends CQLTester 
 " FINALFUNC " + shortFunctionName ( fFinal ) + ' ' + 
 " INITCOND 1 " ) ; 
 
 - assertInvalidMessage ( String . format ( " Statement on keyspace % s cannot refer to a user function in keyspace % s ; user functions can only be used in the keyspace they are defined in " , 
 + assertInvalidMessage ( String . format ( " Statement on keyspace % s cannot refer to a user type in keyspace % s ; user types can only be used in the keyspace they are defined in " , 
 KEYSPACE _ PER _ TEST , KEYSPACE ) , 
 " CREATE AGGREGATE " + KEYSPACE _ PER _ TEST + " . test _ wrong _ ks ( int ) " + 
 " SFUNC " + shortFunctionName ( fState ) + ' ' + 
 @ @ - 1404 , 7 + 1405 , 7 @ @ public class AggregationTest extends CQLTester 
 " AS ' return \ " fin \ " + a ; ' " ) ; 
 
 String aCON = createAggregate ( KEYSPACE , 
 - " text , text " , 
 + " text " , 
 " CREATE AGGREGATE % s ( text ) " + 
 " SFUNC " + shortFunctionName ( fCON ) + ' ' + 
 " STYPE text " + 
 @ @ - 1428 , 7 + 1429 , 7 @ @ public class AggregationTest extends CQLTester 
 " AS ' return \ " fin \ " + a ; ' " ) ; 
 
 String aRNON = createAggregate ( KEYSPACE , 
 - " int , int " , 
 + " int " , 
 " CREATE AGGREGATE % s ( text ) " + 
 " SFUNC " + shortFunctionName ( fRNON ) + ' ' + 
 " STYPE text " + 
 @ @ - 1447 , 4 + 1448 , 32 @ @ public class AggregationTest extends CQLTester 
 assertRows ( execute ( " SELECT " + aRNON + " ( b ) FROM % s " ) , row ( " fin " ) ) ; 
 
 } 
 + 
 + @ Test 
 + public void testSystemKsFuncs ( ) throws Throwable 
 + { 
 + 
 + String fAdder = createFunction ( KEYSPACE , 
 + " int , int " , 
 + " CREATE FUNCTION % s ( a int , b int ) " + 
 + " CALLED ON NULL INPUT " + 
 + " RETURNS int " + 
 + " LANGUAGE java " + 
 + " AS ' return ( a ! = null ? a : 0 ) + ( b ! = null ? b : 0 ) ; ' " ) ; 
 + 
 + String aAggr = createAggregate ( KEYSPACE , 
 + " int " , 
 + " CREATE AGGREGATE % s ( int ) " + 
 + " SFUNC " + shortFunctionName ( fAdder ) + ' ' + 
 + " STYPE int " + 
 + " FINALFUNC intasblob " ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( a int primary key , b int ) " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 1 , 1 ) " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 2 , 2 ) " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 3 , 3 ) " ) ; 
 + 
 + assertRows ( execute ( " SELECT " + aAggr + " ( b ) FROM % s " ) , row ( Int32Serializer . instance . serialize ( 6 ) ) ) ; 
 + 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / UFTest . java b / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 index 1b3326b . . 40f2dd3 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 @ @ - 16 , 6 + 16 , 7 @ @ 
 * limitations under the License . 
 * / 
 package org . apache . cassandra . cql3 ; 
 + 
 import java . math . BigDecimal ; 
 import java . math . BigInteger ; 
 import java . nio . ByteBuffer ;

NEAREST DIFF:
diff - - git a / debian / changelog b / debian / changelog 
 index 739e38a . . 76bac83 100644 
 - - - a / debian / changelog 
 + + + b / debian / changelog 
 @ @ - 2 , 7 + 2 , 7 @ @ cassandra ( 1 . 1 . 11 ) unstable ; urgency = low 
 
 * New release 
 
 - - - Eric Evans < eevans @ apache . org > , 16 Apr 2013 18 : 56 : 03 - 0500 
 + - - Eric Evans < eevans @ apache . org > Tue , 16 Apr 2013 18 : 56 : 03 - 0500 
 
 cassandra ( 1 . 1 . 10 ) unstable ; urgency = low 

