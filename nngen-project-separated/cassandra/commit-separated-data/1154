BLEU SCORE: 0.027611988917697356

TEST MSG: Rejects partition range deletions when columns are specified
GENERATED MSG: Fix deletion in CQL3

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index bd14e67 . . 7fffbbf 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 1 <nl> + * Rejects partition range deletions when columns are specified ( CASSANDRA - 10739 ) <nl> * Fix error when saving cached key for old format sstable ( CASSANDRA - 10778 ) <nl> * Invalidate prepared statements on DROP INDEX ( CASSANDRA - 10758 ) <nl> * Fix SELECT statement with IN restrictions on partition key , <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> index 0efe35c . . daeecfe 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> @ @ - 78 , 6 + 78 , 12 @ @ public class DeleteStatement extends ModificationStatement <nl> { <nl> if ( ! regularDeletions . isEmpty ( ) ) <nl> { <nl> + / / if the clustering size is zero but there are some clustering columns , it means that it ' s a <nl> + / / range deletion ( the full partition ) in which case we need to throw an error as range deletion <nl> + / / do not support specific columns <nl> + checkFalse ( clustering . size ( ) = = 0 & & cfm . clusteringColumns ( ) . size ( ) ! = 0 , <nl> + " Range deletions are not supported for specific columns " ) ; <nl> + <nl> params . newRow ( clustering ) ; <nl> <nl> for ( Operation op : regularDeletions ) <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / DeleteTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / DeleteTest . java <nl> index 5d9ef8f . . 4f35afa 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / DeleteTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / DeleteTest . java <nl> @ @ - 718 , 6 + 718 , 8 @ @ public class DeleteTest extends CQLTester <nl> / / Test invalid queries <nl> assertInvalidMessage ( " Range deletions are not supported for specific columns " , <nl> " DELETE value FROM % s WHERE partitionKey = ? AND clustering > = ? " , 2 , 1 ) ; <nl> + assertInvalidMessage ( " Range deletions are not supported for specific columns " , <nl> + " DELETE value FROM % s WHERE partitionKey = ? " , 2 ) ; <nl> } <nl> } <nl> <nl> @ @ - 911 , 6 + 913 , 12 @ @ public class DeleteTest extends CQLTester <nl> / / Test invalid queries <nl> assertInvalidMessage ( " Range deletions are not supported for specific columns " , <nl> " DELETE value FROM % s WHERE partitionKey = ? AND ( clustering _ 1 , clustering _ 2 ) > = ( ? , ? ) " , 2 , 3 , 1 ) ; <nl> + assertInvalidMessage ( " Range deletions are not supported for specific columns " , <nl> + " DELETE value FROM % s WHERE partitionKey = ? AND clustering _ 1 > = ? " , 2 , 3 ) ; <nl> + assertInvalidMessage ( " Range deletions are not supported for specific columns " , <nl> + " DELETE value FROM % s WHERE partitionKey = ? AND clustering _ 1 = ? " , 2 , 3 ) ; <nl> + assertInvalidMessage ( " Range deletions are not supported for specific columns " , <nl> + " DELETE value FROM % s WHERE partitionKey = ? " , 2 ) ; <nl> } <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3a1b4c2 . . e9f34ed 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 23 , 6 + 23 , 7 @ @ <nl> * ( cql3 ) fix range queries containing unqueried results ( CASSANDRA - 4372 ) <nl> * ( cql3 ) allow updating column _ alias types ( CASSANDRA - 4041 ) <nl> * ( cql3 ) Fix deletion bug ( CASSANDRA - 4193 ) <nl> + * Fix computation of overlapping sstable for leveled compaction ( CASSANDRA - 4321 ) <nl> Merged from 1 . 0 : <nl> * Set gc _ grace on index CF to 0 ( CASSANDRA - 4314 ) <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> index dca8b7d . . beb7d74 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> @ @ - 27 , 13 + 27 , 14 @ @ import java . io . IOException ; <nl> import java . util . * ; <nl> <nl> import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . Sets ; <nl> import com . google . common . primitives . Ints ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . RowPosition ; <nl> - import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . dht . Bounds ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . io . sstable . SSTable ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> @ @ - 287 , 24 + 288 , 6 @ @ public class LeveledManifest <nl> return Collections . emptyList ( ) ; <nl> } <nl> <nl> - / * * <nl> - * Go through candidates collection and check if any of the SSTables are marked as suspected . <nl> - * <nl> - * @ param candidates The SSTable collection to examine . <nl> - * <nl> - * @ return true if collection has at least one SSTable marked as suspected , false otherwise . <nl> - * / <nl> - private boolean hasSuspectSSTables ( Collection < SSTableReader > candidates ) <nl> - { <nl> - for ( SSTableReader candidate : candidates ) <nl> - { <nl> - if ( candidate . isMarkedSuspect ( ) ) <nl> - return true ; <nl> - } <nl> - <nl> - return false ; <nl> - } <nl> - <nl> public int getLevelSize ( int i ) <nl> { <nl> return generations . length > i ? generations [ i ] . size ( ) : 0 ; <nl> @ @ - 350 , 16 + 333 , 50 @ @ public class LeveledManifest <nl> sstableGenerations . put ( sstable , Integer . valueOf ( level ) ) ; <nl> } <nl> <nl> - private static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > candidates ) <nl> + private static Set < SSTableReader > overlapping ( Collection < SSTableReader > candidates , Iterable < SSTableReader > others ) <nl> { <nl> - Set < SSTableReader > overlapped = new HashSet < SSTableReader > ( ) ; <nl> - overlapped . add ( sstable ) ; <nl> + assert ! candidates . isEmpty ( ) ; <nl> + / * <nl> + * Picking each sstable from others that overlap one of the sstable of candidates is not enough <nl> + * because you could have the following situation : <nl> + * candidates = [ s1 ( a , c ) , s2 ( m , z ) ] <nl> + * others = [ s3 ( e , g ) ] <nl> + * In that case , s2 overlaps none of s1 or s2 , but if we compact s1 with s2 , the resulting sstable will <nl> + * overlap s3 , so we must return s3 . <nl> + * <nl> + * Thus , the correct approach is to pick sstables overlapping anything between the first key in all <nl> + * the candidate sstables , and the last . <nl> + * / <nl> + Iterator < SSTableReader > iter = candidates . iterator ( ) ; <nl> + SSTableReader sstable = iter . next ( ) ; <nl> + Token first = sstable . first . token ; <nl> + Token last = sstable . last . token ; <nl> + while ( iter . hasNext ( ) ) <nl> + { <nl> + sstable = iter . next ( ) ; <nl> + first = first . compareTo ( sstable . first . token ) < = 0 ? first : sstable . first . token ; <nl> + last = last . compareTo ( sstable . last . token ) > = 0 ? last : sstable . last . token ; <nl> + } <nl> + return overlapping ( first , last , others ) ; <nl> + } <nl> + <nl> + private static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > others ) <nl> + { <nl> + return overlapping ( sstable . first . token , sstable . last . token , others ) ; <nl> + } <nl> <nl> - Range < Token > promotedRange = new Range < Token > ( sstable . first . token , sstable . last . token ) ; <nl> - for ( SSTableReader candidate : candidates ) <nl> + / * * <nl> + * @ return sstables from @ param sstables that contain keys between @ param start and @ param end , inclusive . <nl> + * / <nl> + private static Set < SSTableReader > overlapping ( Token start , Token end , Iterable < SSTableReader > sstables ) <nl> + { <nl> + assert start . compareTo ( end ) < = 0 ; <nl> + Set < SSTableReader > overlapped = new HashSet < SSTableReader > ( ) ; <nl> + Bounds < Token > promotedBounds = new Bounds < Token > ( start , end ) ; <nl> + for ( SSTableReader candidate : sstables ) <nl> { <nl> - Range < Token > candidateRange = new Range < Token > ( candidate . first . token , candidate . last . token ) ; <nl> - if ( candidateRange . intersects ( promotedRange ) ) <nl> + Bounds < Token > candidateBounds = new Bounds < Token > ( candidate . first . token , candidate . last . token ) ; <nl> + if ( candidateBounds . intersects ( promotedBounds ) ) <nl> overlapped . add ( candidate ) ; <nl> } <nl> return overlapped ; <nl> @ @ - 394 , 7 + 411 , 7 @ @ public class LeveledManifest <nl> if ( candidates . contains ( sstable ) ) <nl> continue ; <nl> <nl> - for ( SSTableReader newCandidate : overlapping ( sstable , remaining ) ) <nl> + for ( SSTableReader newCandidate : Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , remaining ) ) ) <nl> { <nl> if ( ! newCandidate . isMarkedSuspect ( ) ) <nl> { <nl> @ @ - 412 , 8 + 429 , 7 @ @ public class LeveledManifest <nl> if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) <nl> { <nl> / / add sstables from L1 that overlap candidates <nl> - for ( SSTableReader candidate : new ArrayList < SSTableReader > ( candidates ) ) <nl> - candidates . addAll ( overlapping ( candidate , generations [ 1 ] ) ) ; <nl> + candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; <nl> } <nl> return candidates ; <nl> } <nl> @ @ - 421 , 8 + 437 , 7 @ @ public class LeveledManifest <nl> if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) <nl> { <nl> / / add sstables from L1 that overlap candidates <nl> - for ( SSTableReader candidate : new ArrayList < SSTableReader > ( candidates ) ) <nl> - candidates . addAll ( overlapping ( candidate , generations [ 1 ] ) ) ; <nl> + candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; <nl> break ; <nl> } <nl> } <nl> @ @ - 450 , 7 + 465 , 7 @ @ public class LeveledManifest <nl> while ( true ) <nl> { <nl> SSTableReader sstable = generations [ level ] . get ( i ) ; <nl> - Set < SSTableReader > candidates = overlapping ( sstable , generations [ ( level + 1 ) ] ) ; <nl> + Set < SSTableReader > candidates = Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , generations [ ( level + 1 ) ] ) ) ; <nl> for ( SSTableReader candidate : candidates ) <nl> { <nl> if ( candidate . isMarkedSuspect ( ) ) <nl> diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java <nl> index 9ff830e . . 0e4dbdf 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Bounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / Bounds . java <nl> @ @ - 62 , 6 + 62 , 12 @ @ public class Bounds < T extends RingPosition > extends AbstractBounds < T > <nl> return new Pair < AbstractBounds < T > , AbstractBounds < T > > ( lb , rb ) ; <nl> } <nl> <nl> + public boolean intersects ( Bounds < T > that ) <nl> + { <nl> + / / We either contains one of the that bounds , or we are fully contained into that . <nl> + return contains ( that . left ) | | contains ( that . right ) | | that . contains ( left ) ; <nl> + } <nl> + <nl> public List < ? extends AbstractBounds < T > > unwrap ( ) <nl> { <nl> / / Bounds objects never wrap <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> index 3e7e7a0 . . 5619951 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> @ @ - 130 , 8 + 130 , 8 @ @ public class SSTableWriter extends SSTable <nl> private long beforeAppend ( DecoratedKey < ? > decoratedKey ) throws IOException <nl> { <nl> assert decoratedKey ! = null : " Keys must not be null " ; <nl> - assert lastWrittenKey = = null | | lastWrittenKey . compareTo ( decoratedKey ) < 0 <nl> - : " Last written key " + lastWrittenKey + " > = current key " + decoratedKey + " writing into " + getFilename ( ) ; <nl> + if ( lastWrittenKey ! = null & & lastWrittenKey . compareTo ( decoratedKey ) > = 0 ) <nl> + throw new RuntimeException ( " Last written key " + lastWrittenKey + " > = current key " + decoratedKey + " writing into " + getFilename ( ) ) ; <nl> return ( lastWrittenKey = = null ) ? 0 : dataFile . getFilePointer ( ) ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index bd14e67 . . 7fffbbf 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 1 
 + * Rejects partition range deletions when columns are specified ( CASSANDRA - 10739 ) 
 * Fix error when saving cached key for old format sstable ( CASSANDRA - 10778 ) 
 * Invalidate prepared statements on DROP INDEX ( CASSANDRA - 10758 ) 
 * Fix SELECT statement with IN restrictions on partition key , 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 index 0efe35c . . daeecfe 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 @ @ - 78 , 6 + 78 , 12 @ @ public class DeleteStatement extends ModificationStatement 
 { 
 if ( ! regularDeletions . isEmpty ( ) ) 
 { 
 + / / if the clustering size is zero but there are some clustering columns , it means that it ' s a 
 + / / range deletion ( the full partition ) in which case we need to throw an error as range deletion 
 + / / do not support specific columns 
 + checkFalse ( clustering . size ( ) = = 0 & & cfm . clusteringColumns ( ) . size ( ) ! = 0 , 
 + " Range deletions are not supported for specific columns " ) ; 
 + 
 params . newRow ( clustering ) ; 
 
 for ( Operation op : regularDeletions ) 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / DeleteTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / DeleteTest . java 
 index 5d9ef8f . . 4f35afa 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / DeleteTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / DeleteTest . java 
 @ @ - 718 , 6 + 718 , 8 @ @ public class DeleteTest extends CQLTester 
 / / Test invalid queries 
 assertInvalidMessage ( " Range deletions are not supported for specific columns " , 
 " DELETE value FROM % s WHERE partitionKey = ? AND clustering > = ? " , 2 , 1 ) ; 
 + assertInvalidMessage ( " Range deletions are not supported for specific columns " , 
 + " DELETE value FROM % s WHERE partitionKey = ? " , 2 ) ; 
 } 
 } 
 
 @ @ - 911 , 6 + 913 , 12 @ @ public class DeleteTest extends CQLTester 
 / / Test invalid queries 
 assertInvalidMessage ( " Range deletions are not supported for specific columns " , 
 " DELETE value FROM % s WHERE partitionKey = ? AND ( clustering _ 1 , clustering _ 2 ) > = ( ? , ? ) " , 2 , 3 , 1 ) ; 
 + assertInvalidMessage ( " Range deletions are not supported for specific columns " , 
 + " DELETE value FROM % s WHERE partitionKey = ? AND clustering _ 1 > = ? " , 2 , 3 ) ; 
 + assertInvalidMessage ( " Range deletions are not supported for specific columns " , 
 + " DELETE value FROM % s WHERE partitionKey = ? AND clustering _ 1 = ? " , 2 , 3 ) ; 
 + assertInvalidMessage ( " Range deletions are not supported for specific columns " , 
 + " DELETE value FROM % s WHERE partitionKey = ? " , 2 ) ; 
 } 
 } 


NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3a1b4c2 . . e9f34ed 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 23 , 6 + 23 , 7 @ @ 
 * ( cql3 ) fix range queries containing unqueried results ( CASSANDRA - 4372 ) 
 * ( cql3 ) allow updating column _ alias types ( CASSANDRA - 4041 ) 
 * ( cql3 ) Fix deletion bug ( CASSANDRA - 4193 ) 
 + * Fix computation of overlapping sstable for leveled compaction ( CASSANDRA - 4321 ) 
 Merged from 1 . 0 : 
 * Set gc _ grace on index CF to 0 ( CASSANDRA - 4314 ) 
 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 index dca8b7d . . beb7d74 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 @ @ - 27 , 13 + 27 , 14 @ @ import java . io . IOException ; 
 import java . util . * ; 
 
 import com . google . common . collect . Iterables ; 
 + import com . google . common . collect . Sets ; 
 import com . google . common . primitives . Ints ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . RowPosition ; 
 - import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . dht . Bounds ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . io . sstable . SSTable ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 @ @ - 287 , 24 + 288 , 6 @ @ public class LeveledManifest 
 return Collections . emptyList ( ) ; 
 } 
 
 - / * * 
 - * Go through candidates collection and check if any of the SSTables are marked as suspected . 
 - * 
 - * @ param candidates The SSTable collection to examine . 
 - * 
 - * @ return true if collection has at least one SSTable marked as suspected , false otherwise . 
 - * / 
 - private boolean hasSuspectSSTables ( Collection < SSTableReader > candidates ) 
 - { 
 - for ( SSTableReader candidate : candidates ) 
 - { 
 - if ( candidate . isMarkedSuspect ( ) ) 
 - return true ; 
 - } 
 - 
 - return false ; 
 - } 
 - 
 public int getLevelSize ( int i ) 
 { 
 return generations . length > i ? generations [ i ] . size ( ) : 0 ; 
 @ @ - 350 , 16 + 333 , 50 @ @ public class LeveledManifest 
 sstableGenerations . put ( sstable , Integer . valueOf ( level ) ) ; 
 } 
 
 - private static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > candidates ) 
 + private static Set < SSTableReader > overlapping ( Collection < SSTableReader > candidates , Iterable < SSTableReader > others ) 
 { 
 - Set < SSTableReader > overlapped = new HashSet < SSTableReader > ( ) ; 
 - overlapped . add ( sstable ) ; 
 + assert ! candidates . isEmpty ( ) ; 
 + / * 
 + * Picking each sstable from others that overlap one of the sstable of candidates is not enough 
 + * because you could have the following situation : 
 + * candidates = [ s1 ( a , c ) , s2 ( m , z ) ] 
 + * others = [ s3 ( e , g ) ] 
 + * In that case , s2 overlaps none of s1 or s2 , but if we compact s1 with s2 , the resulting sstable will 
 + * overlap s3 , so we must return s3 . 
 + * 
 + * Thus , the correct approach is to pick sstables overlapping anything between the first key in all 
 + * the candidate sstables , and the last . 
 + * / 
 + Iterator < SSTableReader > iter = candidates . iterator ( ) ; 
 + SSTableReader sstable = iter . next ( ) ; 
 + Token first = sstable . first . token ; 
 + Token last = sstable . last . token ; 
 + while ( iter . hasNext ( ) ) 
 + { 
 + sstable = iter . next ( ) ; 
 + first = first . compareTo ( sstable . first . token ) < = 0 ? first : sstable . first . token ; 
 + last = last . compareTo ( sstable . last . token ) > = 0 ? last : sstable . last . token ; 
 + } 
 + return overlapping ( first , last , others ) ; 
 + } 
 + 
 + private static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > others ) 
 + { 
 + return overlapping ( sstable . first . token , sstable . last . token , others ) ; 
 + } 
 
 - Range < Token > promotedRange = new Range < Token > ( sstable . first . token , sstable . last . token ) ; 
 - for ( SSTableReader candidate : candidates ) 
 + / * * 
 + * @ return sstables from @ param sstables that contain keys between @ param start and @ param end , inclusive . 
 + * / 
 + private static Set < SSTableReader > overlapping ( Token start , Token end , Iterable < SSTableReader > sstables ) 
 + { 
 + assert start . compareTo ( end ) < = 0 ; 
 + Set < SSTableReader > overlapped = new HashSet < SSTableReader > ( ) ; 
 + Bounds < Token > promotedBounds = new Bounds < Token > ( start , end ) ; 
 + for ( SSTableReader candidate : sstables ) 
 { 
 - Range < Token > candidateRange = new Range < Token > ( candidate . first . token , candidate . last . token ) ; 
 - if ( candidateRange . intersects ( promotedRange ) ) 
 + Bounds < Token > candidateBounds = new Bounds < Token > ( candidate . first . token , candidate . last . token ) ; 
 + if ( candidateBounds . intersects ( promotedBounds ) ) 
 overlapped . add ( candidate ) ; 
 } 
 return overlapped ; 
 @ @ - 394 , 7 + 411 , 7 @ @ public class LeveledManifest 
 if ( candidates . contains ( sstable ) ) 
 continue ; 
 
 - for ( SSTableReader newCandidate : overlapping ( sstable , remaining ) ) 
 + for ( SSTableReader newCandidate : Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , remaining ) ) ) 
 { 
 if ( ! newCandidate . isMarkedSuspect ( ) ) 
 { 
 @ @ - 412 , 8 + 429 , 7 @ @ public class LeveledManifest 
 if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) 
 { 
 / / add sstables from L1 that overlap candidates 
 - for ( SSTableReader candidate : new ArrayList < SSTableReader > ( candidates ) ) 
 - candidates . addAll ( overlapping ( candidate , generations [ 1 ] ) ) ; 
 + candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; 
 } 
 return candidates ; 
 } 
 @ @ - 421 , 8 + 437 , 7 @ @ public class LeveledManifest 
 if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) 
 { 
 / / add sstables from L1 that overlap candidates 
 - for ( SSTableReader candidate : new ArrayList < SSTableReader > ( candidates ) ) 
 - candidates . addAll ( overlapping ( candidate , generations [ 1 ] ) ) ; 
 + candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; 
 break ; 
 } 
 } 
 @ @ - 450 , 7 + 465 , 7 @ @ public class LeveledManifest 
 while ( true ) 
 { 
 SSTableReader sstable = generations [ level ] . get ( i ) ; 
 - Set < SSTableReader > candidates = overlapping ( sstable , generations [ ( level + 1 ) ] ) ; 
 + Set < SSTableReader > candidates = Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , generations [ ( level + 1 ) ] ) ) ; 
 for ( SSTableReader candidate : candidates ) 
 { 
 if ( candidate . isMarkedSuspect ( ) ) 
 diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java 
 index 9ff830e . . 0e4dbdf 100644 
 - - - a / src / java / org / apache / cassandra / dht / Bounds . java 
 + + + b / src / java / org / apache / cassandra / dht / Bounds . java 
 @ @ - 62 , 6 + 62 , 12 @ @ public class Bounds < T extends RingPosition > extends AbstractBounds < T > 
 return new Pair < AbstractBounds < T > , AbstractBounds < T > > ( lb , rb ) ; 
 } 
 
 + public boolean intersects ( Bounds < T > that ) 
 + { 
 + / / We either contains one of the that bounds , or we are fully contained into that . 
 + return contains ( that . left ) | | contains ( that . right ) | | that . contains ( left ) ; 
 + } 
 + 
 public List < ? extends AbstractBounds < T > > unwrap ( ) 
 { 
 / / Bounds objects never wrap 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 index 3e7e7a0 . . 5619951 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 @ @ - 130 , 8 + 130 , 8 @ @ public class SSTableWriter extends SSTable 
 private long beforeAppend ( DecoratedKey < ? > decoratedKey ) throws IOException 
 { 
 assert decoratedKey ! = null : " Keys must not be null " ; 
 - assert lastWrittenKey = = null | | lastWrittenKey . compareTo ( decoratedKey ) < 0 
 - : " Last written key " + lastWrittenKey + " > = current key " + decoratedKey + " writing into " + getFilename ( ) ; 
 + if ( lastWrittenKey ! = null & & lastWrittenKey . compareTo ( decoratedKey ) > = 0 ) 
 + throw new RuntimeException ( " Last written key " + lastWrittenKey + " > = current key " + decoratedKey + " writing into " + getFilename ( ) ) ; 
 return ( lastWrittenKey = = null ) ? 0 : dataFile . getFilePointer ( ) ; 
 } 

