BLEU SCORE: 0.05522397783539471

TEST MSG: Make LCS split compaction results over many directories
GENERATED MSG: Make sstable directory picking blacklist - aware again

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 01ea887 . . 6a5ac0d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 12 : <nl> + * Make LCS split compaction results over all data directories ( CASSANDRA - 8329 ) <nl> * Fix some failing queries that use multi - column relations <nl> on COMPACT STORAGE tables ( CASSANDRA - 8264 ) <nl> * Fix InvalidRequestException with ORDER BY ( CASSANDRA - 8286 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java <nl> index 0b186dc . . 425b352 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Memtable . java <nl> + + + b / src / java / org / apache / cassandra / db / Memtable . java <nl> @ @ - 336 , 13 + 336 , 23 @ @ public class Memtable <nl> return estimatedSize ; <nl> } <nl> <nl> - protected void runWith ( File sstableDirectory ) throws Exception <nl> + protected void runMayThrow ( ) throws Exception <nl> { <nl> + long writeSize = getExpectedWriteSize ( ) ; <nl> + Directories . DataDirectory dataDirectory = getWriteDirectory ( writeSize ) ; <nl> + File sstableDirectory = cfs . directories . getLocationForDisk ( dataDirectory ) ; <nl> assert sstableDirectory ! = null : " Flush task is not bound to any disk " ; <nl> - <nl> - SSTableReader sstable = writeSortedContents ( context , sstableDirectory ) ; <nl> - cfs . replaceFlushed ( Memtable . this , sstable ) ; <nl> - latch . countDown ( ) ; <nl> + try <nl> + { <nl> + SSTableReader sstable = writeSortedContents ( context , sstableDirectory ) ; <nl> + cfs . replaceFlushed ( Memtable . this , sstable ) ; <nl> + latch . countDown ( ) ; <nl> + } <nl> + finally <nl> + { <nl> + if ( dataDirectory ! = null ) <nl> + returnWriteDirectory ( dataDirectory , writeSize ) ; <nl> + } <nl> } <nl> <nl> protected Directories getDirectories ( ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> index 5ef4aad . . 08fe81a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> @ @ - 87 , 11 + 87 , 11 @ @ public class CompactionTask extends AbstractCompactionTask <nl> * which are properly serialized . <nl> * Caller is in charge of marking / unmarking the sstables as compacting . <nl> * / <nl> - protected void runWith ( File sstableDirectory ) throws Exception <nl> + protected void runMayThrow ( ) throws Exception <nl> { <nl> / / The collection of sstables passed may be empty ( but not null ) ; even if <nl> / / it is not empty , it may compact down to nothing if all rows are deleted . <nl> - assert sstables ! = null & & sstableDirectory ! = null ; <nl> + assert sstables ! = null ; <nl> <nl> / / Note that the current compaction strategy , is not necessarily the one this task was created under . <nl> / / This should be harmless ; see comments to CFS . maybeReloadCompactionStrategy . <nl> @ @ - 149 , 45 + 149 , 60 @ @ public class CompactionTask extends AbstractCompactionTask <nl> return ; <nl> } <nl> <nl> - SSTableWriter writer = createCompactionWriter ( sstableDirectory , keysPerSSTable ) ; <nl> + long writeSize = getExpectedWriteSize ( ) / estimatedSSTables ; <nl> + Directories . DataDirectory dataDirectory = getWriteDirectory ( writeSize ) ; <nl> + SSTableWriter writer = createCompactionWriter ( cfs . directories . getLocationForDisk ( dataDirectory ) , keysPerSSTable ) ; <nl> writers . add ( writer ) ; <nl> - while ( iter . hasNext ( ) ) <nl> + try <nl> { <nl> - if ( ci . isStopRequested ( ) ) <nl> - throw new CompactionInterruptedException ( ci . getCompactionInfo ( ) ) ; <nl> - <nl> - AbstractCompactedRow row = iter . next ( ) ; <nl> - RowIndexEntry indexEntry = writer . append ( row ) ; <nl> - if ( indexEntry = = null ) <nl> + while ( iter . hasNext ( ) ) <nl> { <nl> - controller . invalidateCachedRow ( row . key ) ; <nl> - row . close ( ) ; <nl> - continue ; <nl> - } <nl> + if ( ci . isStopRequested ( ) ) <nl> + throw new CompactionInterruptedException ( ci . getCompactionInfo ( ) ) ; <nl> <nl> - totalkeysWritten + + ; <nl> + AbstractCompactedRow row = iter . next ( ) ; <nl> + RowIndexEntry indexEntry = writer . append ( row ) ; <nl> + if ( indexEntry = = null ) <nl> + { <nl> + controller . invalidateCachedRow ( row . key ) ; <nl> + row . close ( ) ; <nl> + continue ; <nl> + } <nl> <nl> - if ( DatabaseDescriptor . getPreheatKeyCache ( ) ) <nl> - { <nl> - for ( SSTableReader sstable : actuallyCompact ) <nl> + totalkeysWritten + + ; <nl> + <nl> + if ( DatabaseDescriptor . getPreheatKeyCache ( ) ) <nl> { <nl> - if ( sstable . getCachedPosition ( row . key , false ) ! = null ) <nl> + for ( SSTableReader sstable : actuallyCompact ) <nl> { <nl> - cachedKeys . put ( row . key , indexEntry ) ; <nl> - break ; <nl> + if ( sstable . getCachedPosition ( row . key , false ) ! = null ) <nl> + { <nl> + cachedKeys . put ( row . key , indexEntry ) ; <nl> + break ; <nl> + } <nl> } <nl> } <nl> - } <nl> <nl> - if ( newSSTableSegmentThresholdReached ( writer ) ) <nl> - { <nl> - / / tmp = false because later we want to query it with descriptor from SSTableReader <nl> - cachedKeyMap . put ( writer . descriptor . asTemporary ( false ) , cachedKeys ) ; <nl> - writer = createCompactionWriter ( sstableDirectory , keysPerSSTable ) ; <nl> - writers . add ( writer ) ; <nl> - cachedKeys = new HashMap < DecoratedKey , RowIndexEntry > ( ) ; <nl> + if ( newSSTableSegmentThresholdReached ( writer ) ) <nl> + { <nl> + / / tmp = false because later we want to query it with descriptor from SSTableReader <nl> + cachedKeyMap . put ( writer . descriptor . asTemporary ( false ) , cachedKeys ) ; <nl> + returnWriteDirectory ( dataDirectory , writeSize ) ; <nl> + / / make sure we don ' t try to call returnWriteDirectory in finally { . . } if we throw exception in getWriteDirectory ( ) below : <nl> + dataDirectory = null ; <nl> + writeSize = getExpectedWriteSize ( ) / estimatedSSTables ; <nl> + dataDirectory = getWriteDirectory ( writeSize ) ; <nl> + writer = createCompactionWriter ( cfs . directories . getLocationForDisk ( dataDirectory ) , keysPerSSTable ) ; <nl> + writers . add ( writer ) ; <nl> + cachedKeys = new HashMap < DecoratedKey , RowIndexEntry > ( ) ; <nl> + } <nl> } <nl> } <nl> + finally <nl> + { <nl> + if ( dataDirectory ! = null ) <nl> + returnWriteDirectory ( dataDirectory , writeSize ) ; <nl> + } <nl> <nl> if ( writer . getFilePointer ( ) > 0 ) <nl> { <nl> @ @ - 291 , 6 + 306 , 7 @ @ public class CompactionTask extends AbstractCompactionTask <nl> <nl> private SSTableWriter createCompactionWriter ( File sstableDirectory , long keysPerSSTable ) <nl> { <nl> + assert sstableDirectory ! = null ; <nl> return new SSTableWriter ( cfs . getTempSSTablePath ( sstableDirectory ) , <nl> keysPerSSTable , <nl> cfs . metadata , <nl> diff - - git a / src / java / org / apache / cassandra / io / util / DiskAwareRunnable . java b / src / java / org / apache / cassandra / io / util / DiskAwareRunnable . java <nl> index 198a88d . . 93b06ab 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / DiskAwareRunnable . java <nl> + + + b / src / java / org / apache / cassandra / io / util / DiskAwareRunnable . java <nl> @ @ - 17 , 23 + 17 , 16 @ @ <nl> * / <nl> package org . apache . cassandra . io . util ; <nl> <nl> - import java . io . File ; <nl> - <nl> import org . apache . cassandra . db . Directories ; <nl> import org . apache . cassandra . utils . WrappedRunnable ; <nl> <nl> public abstract class DiskAwareRunnable extends WrappedRunnable <nl> { <nl> - / * * <nl> - * Run this task after selecting the optimal disk for it <nl> - * / <nl> - protected void runMayThrow ( ) throws Exception <nl> + protected Directories . DataDirectory getWriteDirectory ( long writeSize ) <nl> { <nl> - long writeSize ; <nl> Directories . DataDirectory directory ; <nl> while ( true ) <nl> { <nl> - writeSize = getExpectedWriteSize ( ) ; <nl> directory = getDirectories ( ) . getWriteableLocation ( ) ; <nl> if ( directory ! = null | | ! reduceScopeForLimitedSpace ( ) ) <nl> break ; <nl> @ @ - 43 , 15 + 36 , 13 @ @ public abstract class DiskAwareRunnable extends WrappedRunnable <nl> <nl> directory . currentTasks . incrementAndGet ( ) ; <nl> directory . estimatedWorkingSize . addAndGet ( writeSize ) ; <nl> - try <nl> - { <nl> - runWith ( getDirectories ( ) . getLocationForDisk ( directory ) ) ; <nl> - } <nl> - finally <nl> - { <nl> - directory . estimatedWorkingSize . addAndGet ( - 1 * writeSize ) ; <nl> - directory . currentTasks . decrementAndGet ( ) ; <nl> - } <nl> + return directory ; <nl> + } <nl> + <nl> + protected void returnWriteDirectory ( Directories . DataDirectory directory , long writeSize ) <nl> + { <nl> + directory . estimatedWorkingSize . addAndGet ( - 1 * writeSize ) ; <nl> + directory . currentTasks . decrementAndGet ( ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 61 , 18 + 52 , 6 @ @ public abstract class DiskAwareRunnable extends WrappedRunnable <nl> protected abstract Directories getDirectories ( ) ; <nl> <nl> / * * <nl> - * Executes this task on given { @ code sstableDirectory } . <nl> - * @ param sstableDirectory sstable directory to work on <nl> - * / <nl> - protected abstract void runWith ( File sstableDirectory ) throws Exception ; <nl> - <nl> - / * * <nl> - * Get expected write size to determine which disk to use for this task . <nl> - * @ return expected size in bytes this task will write to disk . <nl> - * / <nl> - public abstract long getExpectedWriteSize ( ) ; <nl> - <nl> - / * * <nl> * Called if no disk is available with free space for the full write size . <nl> * @ return true if the scope of the task was successfully reduced . <nl> * /
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index 21ca90a . . 1738d2d 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 174 , 6 + 174 , 11 @ @ public final class CFMetaData <nl> + " rack text " <nl> + " ) WITH COMMENT = ' known peers in the cluster ' " ) ; <nl> <nl> + public static final CFMetaData PeerEventsCf = compile ( 12 , " CREATE TABLE " + SystemTable . PEER _ EVENTS _ CF + " ( " <nl> + + " peer inet PRIMARY KEY , " <nl> + + " hints _ dropped map < uuid , int > " <nl> + + " ) WITH COMMENT = ' cf contains events related to peers ' " ) ; <nl> + <nl> public static final CFMetaData LocalCf = compile ( 13 , " CREATE TABLE " + SystemTable . LOCAL _ CF + " ( " <nl> + " key text PRIMARY KEY , " <nl> + " tokens set < varchar > , " <nl> diff - - git a / src / java / org / apache / cassandra / config / KSMetaData . java b / src / java / org / apache / cassandra / config / KSMetaData . java <nl> index cfb4aef . . de41f57 100644 <nl> - - - a / src / java / org / apache / cassandra / config / KSMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / KSMetaData . java <nl> @ @ - 83 , 6 + 83 , 7 @ @ public final class KSMetaData <nl> CFMetaData . RangeXfersCf , <nl> CFMetaData . LocalCf , <nl> CFMetaData . PeersCf , <nl> + CFMetaData . PeerEventsCf , <nl> CFMetaData . HintsCf , <nl> CFMetaData . IndexCf , <nl> CFMetaData . CounterIdCf , <nl> diff - - git a / src / java / org / apache / cassandra / db / HintedHandOffManager . java b / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> index 8ca0281 . . 483d8cd 100644 <nl> - - - a / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> + + + b / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> @ @ - 52 , 6 + 52 , 7 @ @ import org . apache . cassandra . gms . FailureDetector ; <nl> import org . apache . cassandra . gms . Gossiper ; <nl> import org . apache . cassandra . io . sstable . Descriptor ; <nl> import org . apache . cassandra . io . sstable . SSTable ; <nl> + import org . apache . cassandra . metrics . HintedHandoffMetrics ; <nl> import org . apache . cassandra . net . IAsyncCallback ; <nl> import org . apache . cassandra . net . MessageOut ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> @ @ - 94 , 6 + 95 , 8 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean <nl> private static final int PAGE _ SIZE = 128 ; <nl> private static final int LARGE _ NUMBER = 65536 ; / / 64k nodes ought to be enough for anybody . <nl> <nl> + public final HintedHandoffMetrics metrics = new HintedHandoffMetrics ( ) ; <nl> + <nl> private volatile boolean hintedHandOffPaused = false ; <nl> <nl> static final CompositeType comparator = CompositeType . getInstance ( Arrays . < AbstractType < ? > > asList ( UUIDType . instance , Int32Type . instance ) ) ; <nl> @ @ - 124 , 6 + 127 , 7 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean <nl> public void run ( ) <nl> { <nl> scheduleAllDeliveries ( ) ; <nl> + metrics . log ( ) ; <nl> } <nl> } ; <nl> StorageService . optionalTasks . scheduleWithFixedDelay ( runnable , 10 , 10 , TimeUnit . MINUTES ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / SystemTable . java b / src / java / org / apache / cassandra / db / SystemTable . java <nl> index 4f6234b . . 629defe 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SystemTable . java <nl> + + + b / src / java / org / apache / cassandra / db / SystemTable . java <nl> @ @ - 61 , 6 + 61 , 7 @ @ public class SystemTable <nl> <nl> / / see CFMetaData for schema definitions <nl> public static final String PEERS _ CF = " peers " ; <nl> + public static final String PEER _ EVENTS _ CF = " peer _ events " ; <nl> public static final String LOCAL _ CF = " local " ; <nl> public static final String INDEX _ CF = " IndexInfo " ; <nl> public static final String COUNTER _ ID _ CF = " NodeIdInfo " ; <nl> @ @ - 330 , 6 + 331 , 13 @ @ public class SystemTable <nl> processInternal ( String . format ( req , PEERS _ CF , columnName , ep . getHostAddress ( ) , value ) ) ; <nl> } <nl> <nl> + public static synchronized void updateHintsDropped ( InetAddress ep , UUID timePeriod , int value ) <nl> + { <nl> + / / with 30 day TTL <nl> + String req = " UPDATE system . % s USING TTL 2592000 SET hints _ dropped [ % s ] = % s WHERE peer = ' % s ' " ; <nl> + processInternal ( String . format ( req , PEER _ EVENTS _ CF , timePeriod . toString ( ) , value , ep . getHostAddress ( ) ) ) ; <nl> + } <nl> + <nl> public static synchronized void updateSchemaVersion ( UUID version ) <nl> { <nl> String req = " INSERT INTO system . % s ( key , schema _ version ) VALUES ( ' % s ' , % s ) " ; <nl> diff - - git a / src / java / org / apache / cassandra / metrics / HintedHandoffMetrics . java b / src / java / org / apache / cassandra / metrics / HintedHandoffMetrics . java <nl> new file mode 100644 <nl> index 0000000 . . a12be19 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / metrics / HintedHandoffMetrics . java <nl> @ @ - 0 , 0 + 1 , 108 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . metrics ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . Map . Entry ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + <nl> + import org . apache . cassandra . db . HintedHandOffManager ; <nl> + import org . apache . cassandra . db . SystemTable ; <nl> + import org . apache . cassandra . utils . UUIDGen ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import com . google . common . cache . CacheBuilder ; <nl> + import com . google . common . cache . CacheLoader ; <nl> + import com . google . common . cache . LoadingCache ; <nl> + import com . yammer . metrics . Metrics ; <nl> + import com . yammer . metrics . core . Counter ; <nl> + import com . yammer . metrics . core . MetricName ; <nl> + <nl> + / * * <nl> + * Metrics for { @ link HintedHandOffManager } . <nl> + * / <nl> + public class HintedHandoffMetrics <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( HintedHandoffMetrics . class ) ; <nl> + <nl> + public static final String GROUP _ NAME = " org . apache . cassandra . metrics " ; <nl> + public static final String TYPE _ NAME = " HintedHandOffManager " ; <nl> + <nl> + / * * Total number of hints which are not stored , This is not a cache . * / <nl> + private final LoadingCache < InetAddress , DifferencingCounter > notStored = CacheBuilder . newBuilder ( ) . build ( new CacheLoader < InetAddress , DifferencingCounter > ( ) <nl> + { <nl> + public DifferencingCounter load ( InetAddress address ) <nl> + { <nl> + return new DifferencingCounter ( address ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + public void incrPastWindow ( InetAddress address ) <nl> + { <nl> + try <nl> + { <nl> + notStored . get ( address ) . mark ( ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; / / this cannot happen <nl> + } <nl> + } <nl> + <nl> + public void log ( ) <nl> + { <nl> + for ( Entry < InetAddress , DifferencingCounter > entry : notStored . asMap ( ) . entrySet ( ) ) <nl> + { <nl> + long diffrence = entry . getValue ( ) . diffrence ( ) ; <nl> + if ( diffrence = = 0 ) <nl> + continue ; <nl> + logger . warn ( " { } has { } dropped hints , because node is down past configured hint window . " , entry . getKey ( ) , diffrence ) ; <nl> + SystemTable . updateHintsDropped ( entry . getKey ( ) , UUIDGen . getTimeUUID ( ) , ( int ) diffrence ) ; <nl> + } <nl> + } <nl> + <nl> + public class DifferencingCounter <nl> + { <nl> + private final Counter meter ; <nl> + private long reported = 0 ; <nl> + <nl> + public DifferencingCounter ( InetAddress address ) <nl> + { <nl> + this . meter = Metrics . newCounter ( new MetricName ( GROUP _ NAME , TYPE _ NAME , " Hints _ not _ stored - " + address . toString ( ) ) ) ; <nl> + } <nl> + <nl> + public long diffrence ( ) <nl> + { <nl> + long current = meter . count ( ) ; <nl> + long diffrence = current - reported ; <nl> + this . reported = current ; <nl> + return diffrence ; <nl> + } <nl> + <nl> + public long count ( ) <nl> + { <nl> + return meter . count ( ) ; <nl> + } <nl> + <nl> + public void mark ( ) <nl> + { <nl> + meter . inc ( ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index c234bd1 . . 272c52b 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 1486 , 11 + 1486 , 17 @ @ public class StorageProxy implements StorageProxyMBean <nl> public static boolean shouldHint ( InetAddress ep ) <nl> { <nl> if ( ! DatabaseDescriptor . hintedHandoffEnabled ( ) ) <nl> + { <nl> + HintedHandOffManager . instance . metrics . incrPastWindow ( ep ) ; <nl> return false ; <nl> + } <nl> <nl> boolean hintWindowExpired = Gossiper . instance . getEndpointDowntime ( ep ) > DatabaseDescriptor . getMaxHintWindow ( ) ; <nl> if ( hintWindowExpired ) <nl> + { <nl> + HintedHandOffManager . instance . metrics . incrPastWindow ( ep ) ; <nl> logger . trace ( " not hinting { } which has been down { } ms " , ep , Gossiper . instance . getEndpointDowntime ( ep ) ) ; <nl> + } <nl> return ! hintWindowExpired ; <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / db / HintedHandOffTest . java b / test / unit / org / apache / cassandra / db / HintedHandOffTest . java <nl> index 0b04250 . . 260f1c5 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / HintedHandOffTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / HintedHandOffTest . java <nl> @ @ - 21 , 19 + 21 , 27 @ @ package org . apache . cassandra . db ; <nl> * / <nl> <nl> <nl> + import java . net . InetAddress ; <nl> + import java . util . Map ; <nl> import java . util . UUID ; <nl> import java . util . concurrent . TimeUnit ; <nl> <nl> import org . junit . Test ; <nl> <nl> import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . cql3 . UntypedResultSet ; <nl> import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy ; <nl> import org . apache . cassandra . db . filter . QueryPath ; <nl> + import org . apache . cassandra . db . marshal . Int32Type ; <nl> + import org . apache . cassandra . db . marshal . UUIDType ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> + import com . google . common . collect . Iterators ; <nl> + <nl> import static junit . framework . Assert . assertEquals ; <nl> + import static org . apache . cassandra . cql3 . QueryProcessor . processInternal ; <nl> <nl> public class HintedHandOffTest extends SchemaLoader <nl> { <nl> @ @ - 77 , 4 + 85 , 16 @ @ public class HintedHandOffTest extends SchemaLoader <nl> / / is 10 hours and there are no any tombstones in sstable <nl> assertEquals ( 1 , hintStore . getSSTables ( ) . size ( ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testHintsMetrics ( ) throws Exception <nl> + { <nl> + for ( int i = 0 ; i < 99 ; i + + ) <nl> + HintedHandOffManager . instance . metrics . incrPastWindow ( InetAddress . getLocalHost ( ) ) ; <nl> + HintedHandOffManager . instance . metrics . log ( ) ; <nl> + <nl> + UntypedResultSet rows = processInternal ( " SELECT hints _ dropped FROM system . " + SystemTable . PEER _ EVENTS _ CF ) ; <nl> + Map < UUID , Integer > returned = rows . one ( ) . getMap ( " hints _ dropped " , UUIDType . instance , Int32Type . instance ) ; <nl> + assertEquals ( Iterators . getLast ( returned . values ( ) . iterator ( ) ) . intValue ( ) , 99 ) ; <nl> + } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 01ea887 . . 6a5ac0d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 12 : 
 + * Make LCS split compaction results over all data directories ( CASSANDRA - 8329 ) 
 * Fix some failing queries that use multi - column relations 
 on COMPACT STORAGE tables ( CASSANDRA - 8264 ) 
 * Fix InvalidRequestException with ORDER BY ( CASSANDRA - 8286 ) 
 diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java 
 index 0b186dc . . 425b352 100644 
 - - - a / src / java / org / apache / cassandra / db / Memtable . java 
 + + + b / src / java / org / apache / cassandra / db / Memtable . java 
 @ @ - 336 , 13 + 336 , 23 @ @ public class Memtable 
 return estimatedSize ; 
 } 
 
 - protected void runWith ( File sstableDirectory ) throws Exception 
 + protected void runMayThrow ( ) throws Exception 
 { 
 + long writeSize = getExpectedWriteSize ( ) ; 
 + Directories . DataDirectory dataDirectory = getWriteDirectory ( writeSize ) ; 
 + File sstableDirectory = cfs . directories . getLocationForDisk ( dataDirectory ) ; 
 assert sstableDirectory ! = null : " Flush task is not bound to any disk " ; 
 - 
 - SSTableReader sstable = writeSortedContents ( context , sstableDirectory ) ; 
 - cfs . replaceFlushed ( Memtable . this , sstable ) ; 
 - latch . countDown ( ) ; 
 + try 
 + { 
 + SSTableReader sstable = writeSortedContents ( context , sstableDirectory ) ; 
 + cfs . replaceFlushed ( Memtable . this , sstable ) ; 
 + latch . countDown ( ) ; 
 + } 
 + finally 
 + { 
 + if ( dataDirectory ! = null ) 
 + returnWriteDirectory ( dataDirectory , writeSize ) ; 
 + } 
 } 
 
 protected Directories getDirectories ( ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 index 5ef4aad . . 08fe81a 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 @ @ - 87 , 11 + 87 , 11 @ @ public class CompactionTask extends AbstractCompactionTask 
 * which are properly serialized . 
 * Caller is in charge of marking / unmarking the sstables as compacting . 
 * / 
 - protected void runWith ( File sstableDirectory ) throws Exception 
 + protected void runMayThrow ( ) throws Exception 
 { 
 / / The collection of sstables passed may be empty ( but not null ) ; even if 
 / / it is not empty , it may compact down to nothing if all rows are deleted . 
 - assert sstables ! = null & & sstableDirectory ! = null ; 
 + assert sstables ! = null ; 
 
 / / Note that the current compaction strategy , is not necessarily the one this task was created under . 
 / / This should be harmless ; see comments to CFS . maybeReloadCompactionStrategy . 
 @ @ - 149 , 45 + 149 , 60 @ @ public class CompactionTask extends AbstractCompactionTask 
 return ; 
 } 
 
 - SSTableWriter writer = createCompactionWriter ( sstableDirectory , keysPerSSTable ) ; 
 + long writeSize = getExpectedWriteSize ( ) / estimatedSSTables ; 
 + Directories . DataDirectory dataDirectory = getWriteDirectory ( writeSize ) ; 
 + SSTableWriter writer = createCompactionWriter ( cfs . directories . getLocationForDisk ( dataDirectory ) , keysPerSSTable ) ; 
 writers . add ( writer ) ; 
 - while ( iter . hasNext ( ) ) 
 + try 
 { 
 - if ( ci . isStopRequested ( ) ) 
 - throw new CompactionInterruptedException ( ci . getCompactionInfo ( ) ) ; 
 - 
 - AbstractCompactedRow row = iter . next ( ) ; 
 - RowIndexEntry indexEntry = writer . append ( row ) ; 
 - if ( indexEntry = = null ) 
 + while ( iter . hasNext ( ) ) 
 { 
 - controller . invalidateCachedRow ( row . key ) ; 
 - row . close ( ) ; 
 - continue ; 
 - } 
 + if ( ci . isStopRequested ( ) ) 
 + throw new CompactionInterruptedException ( ci . getCompactionInfo ( ) ) ; 
 
 - totalkeysWritten + + ; 
 + AbstractCompactedRow row = iter . next ( ) ; 
 + RowIndexEntry indexEntry = writer . append ( row ) ; 
 + if ( indexEntry = = null ) 
 + { 
 + controller . invalidateCachedRow ( row . key ) ; 
 + row . close ( ) ; 
 + continue ; 
 + } 
 
 - if ( DatabaseDescriptor . getPreheatKeyCache ( ) ) 
 - { 
 - for ( SSTableReader sstable : actuallyCompact ) 
 + totalkeysWritten + + ; 
 + 
 + if ( DatabaseDescriptor . getPreheatKeyCache ( ) ) 
 { 
 - if ( sstable . getCachedPosition ( row . key , false ) ! = null ) 
 + for ( SSTableReader sstable : actuallyCompact ) 
 { 
 - cachedKeys . put ( row . key , indexEntry ) ; 
 - break ; 
 + if ( sstable . getCachedPosition ( row . key , false ) ! = null ) 
 + { 
 + cachedKeys . put ( row . key , indexEntry ) ; 
 + break ; 
 + } 
 } 
 } 
 - } 
 
 - if ( newSSTableSegmentThresholdReached ( writer ) ) 
 - { 
 - / / tmp = false because later we want to query it with descriptor from SSTableReader 
 - cachedKeyMap . put ( writer . descriptor . asTemporary ( false ) , cachedKeys ) ; 
 - writer = createCompactionWriter ( sstableDirectory , keysPerSSTable ) ; 
 - writers . add ( writer ) ; 
 - cachedKeys = new HashMap < DecoratedKey , RowIndexEntry > ( ) ; 
 + if ( newSSTableSegmentThresholdReached ( writer ) ) 
 + { 
 + / / tmp = false because later we want to query it with descriptor from SSTableReader 
 + cachedKeyMap . put ( writer . descriptor . asTemporary ( false ) , cachedKeys ) ; 
 + returnWriteDirectory ( dataDirectory , writeSize ) ; 
 + / / make sure we don ' t try to call returnWriteDirectory in finally { . . } if we throw exception in getWriteDirectory ( ) below : 
 + dataDirectory = null ; 
 + writeSize = getExpectedWriteSize ( ) / estimatedSSTables ; 
 + dataDirectory = getWriteDirectory ( writeSize ) ; 
 + writer = createCompactionWriter ( cfs . directories . getLocationForDisk ( dataDirectory ) , keysPerSSTable ) ; 
 + writers . add ( writer ) ; 
 + cachedKeys = new HashMap < DecoratedKey , RowIndexEntry > ( ) ; 
 + } 
 } 
 } 
 + finally 
 + { 
 + if ( dataDirectory ! = null ) 
 + returnWriteDirectory ( dataDirectory , writeSize ) ; 
 + } 
 
 if ( writer . getFilePointer ( ) > 0 ) 
 { 
 @ @ - 291 , 6 + 306 , 7 @ @ public class CompactionTask extends AbstractCompactionTask 
 
 private SSTableWriter createCompactionWriter ( File sstableDirectory , long keysPerSSTable ) 
 { 
 + assert sstableDirectory ! = null ; 
 return new SSTableWriter ( cfs . getTempSSTablePath ( sstableDirectory ) , 
 keysPerSSTable , 
 cfs . metadata , 
 diff - - git a / src / java / org / apache / cassandra / io / util / DiskAwareRunnable . java b / src / java / org / apache / cassandra / io / util / DiskAwareRunnable . java 
 index 198a88d . . 93b06ab 100644 
 - - - a / src / java / org / apache / cassandra / io / util / DiskAwareRunnable . java 
 + + + b / src / java / org / apache / cassandra / io / util / DiskAwareRunnable . java 
 @ @ - 17 , 23 + 17 , 16 @ @ 
 * / 
 package org . apache . cassandra . io . util ; 
 
 - import java . io . File ; 
 - 
 import org . apache . cassandra . db . Directories ; 
 import org . apache . cassandra . utils . WrappedRunnable ; 
 
 public abstract class DiskAwareRunnable extends WrappedRunnable 
 { 
 - / * * 
 - * Run this task after selecting the optimal disk for it 
 - * / 
 - protected void runMayThrow ( ) throws Exception 
 + protected Directories . DataDirectory getWriteDirectory ( long writeSize ) 
 { 
 - long writeSize ; 
 Directories . DataDirectory directory ; 
 while ( true ) 
 { 
 - writeSize = getExpectedWriteSize ( ) ; 
 directory = getDirectories ( ) . getWriteableLocation ( ) ; 
 if ( directory ! = null | | ! reduceScopeForLimitedSpace ( ) ) 
 break ; 
 @ @ - 43 , 15 + 36 , 13 @ @ public abstract class DiskAwareRunnable extends WrappedRunnable 
 
 directory . currentTasks . incrementAndGet ( ) ; 
 directory . estimatedWorkingSize . addAndGet ( writeSize ) ; 
 - try 
 - { 
 - runWith ( getDirectories ( ) . getLocationForDisk ( directory ) ) ; 
 - } 
 - finally 
 - { 
 - directory . estimatedWorkingSize . addAndGet ( - 1 * writeSize ) ; 
 - directory . currentTasks . decrementAndGet ( ) ; 
 - } 
 + return directory ; 
 + } 
 + 
 + protected void returnWriteDirectory ( Directories . DataDirectory directory , long writeSize ) 
 + { 
 + directory . estimatedWorkingSize . addAndGet ( - 1 * writeSize ) ; 
 + directory . currentTasks . decrementAndGet ( ) ; 
 } 
 
 / * * 
 @ @ - 61 , 18 + 52 , 6 @ @ public abstract class DiskAwareRunnable extends WrappedRunnable 
 protected abstract Directories getDirectories ( ) ; 
 
 / * * 
 - * Executes this task on given { @ code sstableDirectory } . 
 - * @ param sstableDirectory sstable directory to work on 
 - * / 
 - protected abstract void runWith ( File sstableDirectory ) throws Exception ; 
 - 
 - / * * 
 - * Get expected write size to determine which disk to use for this task . 
 - * @ return expected size in bytes this task will write to disk . 
 - * / 
 - public abstract long getExpectedWriteSize ( ) ; 
 - 
 - / * * 
 * Called if no disk is available with free space for the full write size . 
 * @ return true if the scope of the task was successfully reduced . 
 * /

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index 21ca90a . . 1738d2d 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 174 , 6 + 174 , 11 @ @ public final class CFMetaData 
 + " rack text " 
 + " ) WITH COMMENT = ' known peers in the cluster ' " ) ; 
 
 + public static final CFMetaData PeerEventsCf = compile ( 12 , " CREATE TABLE " + SystemTable . PEER _ EVENTS _ CF + " ( " 
 + + " peer inet PRIMARY KEY , " 
 + + " hints _ dropped map < uuid , int > " 
 + + " ) WITH COMMENT = ' cf contains events related to peers ' " ) ; 
 + 
 public static final CFMetaData LocalCf = compile ( 13 , " CREATE TABLE " + SystemTable . LOCAL _ CF + " ( " 
 + " key text PRIMARY KEY , " 
 + " tokens set < varchar > , " 
 diff - - git a / src / java / org / apache / cassandra / config / KSMetaData . java b / src / java / org / apache / cassandra / config / KSMetaData . java 
 index cfb4aef . . de41f57 100644 
 - - - a / src / java / org / apache / cassandra / config / KSMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / KSMetaData . java 
 @ @ - 83 , 6 + 83 , 7 @ @ public final class KSMetaData 
 CFMetaData . RangeXfersCf , 
 CFMetaData . LocalCf , 
 CFMetaData . PeersCf , 
 + CFMetaData . PeerEventsCf , 
 CFMetaData . HintsCf , 
 CFMetaData . IndexCf , 
 CFMetaData . CounterIdCf , 
 diff - - git a / src / java / org / apache / cassandra / db / HintedHandOffManager . java b / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 index 8ca0281 . . 483d8cd 100644 
 - - - a / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 + + + b / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 @ @ - 52 , 6 + 52 , 7 @ @ import org . apache . cassandra . gms . FailureDetector ; 
 import org . apache . cassandra . gms . Gossiper ; 
 import org . apache . cassandra . io . sstable . Descriptor ; 
 import org . apache . cassandra . io . sstable . SSTable ; 
 + import org . apache . cassandra . metrics . HintedHandoffMetrics ; 
 import org . apache . cassandra . net . IAsyncCallback ; 
 import org . apache . cassandra . net . MessageOut ; 
 import org . apache . cassandra . net . MessagingService ; 
 @ @ - 94 , 6 + 95 , 8 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean 
 private static final int PAGE _ SIZE = 128 ; 
 private static final int LARGE _ NUMBER = 65536 ; / / 64k nodes ought to be enough for anybody . 
 
 + public final HintedHandoffMetrics metrics = new HintedHandoffMetrics ( ) ; 
 + 
 private volatile boolean hintedHandOffPaused = false ; 
 
 static final CompositeType comparator = CompositeType . getInstance ( Arrays . < AbstractType < ? > > asList ( UUIDType . instance , Int32Type . instance ) ) ; 
 @ @ - 124 , 6 + 127 , 7 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean 
 public void run ( ) 
 { 
 scheduleAllDeliveries ( ) ; 
 + metrics . log ( ) ; 
 } 
 } ; 
 StorageService . optionalTasks . scheduleWithFixedDelay ( runnable , 10 , 10 , TimeUnit . MINUTES ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / SystemTable . java b / src / java / org / apache / cassandra / db / SystemTable . java 
 index 4f6234b . . 629defe 100644 
 - - - a / src / java / org / apache / cassandra / db / SystemTable . java 
 + + + b / src / java / org / apache / cassandra / db / SystemTable . java 
 @ @ - 61 , 6 + 61 , 7 @ @ public class SystemTable 
 
 / / see CFMetaData for schema definitions 
 public static final String PEERS _ CF = " peers " ; 
 + public static final String PEER _ EVENTS _ CF = " peer _ events " ; 
 public static final String LOCAL _ CF = " local " ; 
 public static final String INDEX _ CF = " IndexInfo " ; 
 public static final String COUNTER _ ID _ CF = " NodeIdInfo " ; 
 @ @ - 330 , 6 + 331 , 13 @ @ public class SystemTable 
 processInternal ( String . format ( req , PEERS _ CF , columnName , ep . getHostAddress ( ) , value ) ) ; 
 } 
 
 + public static synchronized void updateHintsDropped ( InetAddress ep , UUID timePeriod , int value ) 
 + { 
 + / / with 30 day TTL 
 + String req = " UPDATE system . % s USING TTL 2592000 SET hints _ dropped [ % s ] = % s WHERE peer = ' % s ' " ; 
 + processInternal ( String . format ( req , PEER _ EVENTS _ CF , timePeriod . toString ( ) , value , ep . getHostAddress ( ) ) ) ; 
 + } 
 + 
 public static synchronized void updateSchemaVersion ( UUID version ) 
 { 
 String req = " INSERT INTO system . % s ( key , schema _ version ) VALUES ( ' % s ' , % s ) " ; 
 diff - - git a / src / java / org / apache / cassandra / metrics / HintedHandoffMetrics . java b / src / java / org / apache / cassandra / metrics / HintedHandoffMetrics . java 
 new file mode 100644 
 index 0000000 . . a12be19 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / metrics / HintedHandoffMetrics . java 
 @ @ - 0 , 0 + 1 , 108 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . metrics ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . Map . Entry ; 
 + import java . util . concurrent . ExecutionException ; 
 + 
 + import org . apache . cassandra . db . HintedHandOffManager ; 
 + import org . apache . cassandra . db . SystemTable ; 
 + import org . apache . cassandra . utils . UUIDGen ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import com . google . common . cache . CacheBuilder ; 
 + import com . google . common . cache . CacheLoader ; 
 + import com . google . common . cache . LoadingCache ; 
 + import com . yammer . metrics . Metrics ; 
 + import com . yammer . metrics . core . Counter ; 
 + import com . yammer . metrics . core . MetricName ; 
 + 
 + / * * 
 + * Metrics for { @ link HintedHandOffManager } . 
 + * / 
 + public class HintedHandoffMetrics 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( HintedHandoffMetrics . class ) ; 
 + 
 + public static final String GROUP _ NAME = " org . apache . cassandra . metrics " ; 
 + public static final String TYPE _ NAME = " HintedHandOffManager " ; 
 + 
 + / * * Total number of hints which are not stored , This is not a cache . * / 
 + private final LoadingCache < InetAddress , DifferencingCounter > notStored = CacheBuilder . newBuilder ( ) . build ( new CacheLoader < InetAddress , DifferencingCounter > ( ) 
 + { 
 + public DifferencingCounter load ( InetAddress address ) 
 + { 
 + return new DifferencingCounter ( address ) ; 
 + } 
 + } ) ; 
 + 
 + public void incrPastWindow ( InetAddress address ) 
 + { 
 + try 
 + { 
 + notStored . get ( address ) . mark ( ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + throw new RuntimeException ( e ) ; / / this cannot happen 
 + } 
 + } 
 + 
 + public void log ( ) 
 + { 
 + for ( Entry < InetAddress , DifferencingCounter > entry : notStored . asMap ( ) . entrySet ( ) ) 
 + { 
 + long diffrence = entry . getValue ( ) . diffrence ( ) ; 
 + if ( diffrence = = 0 ) 
 + continue ; 
 + logger . warn ( " { } has { } dropped hints , because node is down past configured hint window . " , entry . getKey ( ) , diffrence ) ; 
 + SystemTable . updateHintsDropped ( entry . getKey ( ) , UUIDGen . getTimeUUID ( ) , ( int ) diffrence ) ; 
 + } 
 + } 
 + 
 + public class DifferencingCounter 
 + { 
 + private final Counter meter ; 
 + private long reported = 0 ; 
 + 
 + public DifferencingCounter ( InetAddress address ) 
 + { 
 + this . meter = Metrics . newCounter ( new MetricName ( GROUP _ NAME , TYPE _ NAME , " Hints _ not _ stored - " + address . toString ( ) ) ) ; 
 + } 
 + 
 + public long diffrence ( ) 
 + { 
 + long current = meter . count ( ) ; 
 + long diffrence = current - reported ; 
 + this . reported = current ; 
 + return diffrence ; 
 + } 
 + 
 + public long count ( ) 
 + { 
 + return meter . count ( ) ; 
 + } 
 + 
 + public void mark ( ) 
 + { 
 + meter . inc ( ) ; 
 + } 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index c234bd1 . . 272c52b 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 1486 , 11 + 1486 , 17 @ @ public class StorageProxy implements StorageProxyMBean 
 public static boolean shouldHint ( InetAddress ep ) 
 { 
 if ( ! DatabaseDescriptor . hintedHandoffEnabled ( ) ) 
 + { 
 + HintedHandOffManager . instance . metrics . incrPastWindow ( ep ) ; 
 return false ; 
 + } 
 
 boolean hintWindowExpired = Gossiper . instance . getEndpointDowntime ( ep ) > DatabaseDescriptor . getMaxHintWindow ( ) ; 
 if ( hintWindowExpired ) 
 + { 
 + HintedHandOffManager . instance . metrics . incrPastWindow ( ep ) ; 
 logger . trace ( " not hinting { } which has been down { } ms " , ep , Gossiper . instance . getEndpointDowntime ( ep ) ) ; 
 + } 
 return ! hintWindowExpired ; 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / db / HintedHandOffTest . java b / test / unit / org / apache / cassandra / db / HintedHandOffTest . java 
 index 0b04250 . . 260f1c5 100644 
 - - - a / test / unit / org / apache / cassandra / db / HintedHandOffTest . java 
 + + + b / test / unit / org / apache / cassandra / db / HintedHandOffTest . java 
 @ @ - 21 , 19 + 21 , 27 @ @ package org . apache . cassandra . db ; 
 * / 
 
 
 + import java . net . InetAddress ; 
 + import java . util . Map ; 
 import java . util . UUID ; 
 import java . util . concurrent . TimeUnit ; 
 
 import org . junit . Test ; 
 
 import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . cql3 . UntypedResultSet ; 
 import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy ; 
 import org . apache . cassandra . db . filter . QueryPath ; 
 + import org . apache . cassandra . db . marshal . Int32Type ; 
 + import org . apache . cassandra . db . marshal . UUIDType ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 + import com . google . common . collect . Iterators ; 
 + 
 import static junit . framework . Assert . assertEquals ; 
 + import static org . apache . cassandra . cql3 . QueryProcessor . processInternal ; 
 
 public class HintedHandOffTest extends SchemaLoader 
 { 
 @ @ - 77 , 4 + 85 , 16 @ @ public class HintedHandOffTest extends SchemaLoader 
 / / is 10 hours and there are no any tombstones in sstable 
 assertEquals ( 1 , hintStore . getSSTables ( ) . size ( ) ) ; 
 } 
 + 
 + @ Test 
 + public void testHintsMetrics ( ) throws Exception 
 + { 
 + for ( int i = 0 ; i < 99 ; i + + ) 
 + HintedHandOffManager . instance . metrics . incrPastWindow ( InetAddress . getLocalHost ( ) ) ; 
 + HintedHandOffManager . instance . metrics . log ( ) ; 
 + 
 + UntypedResultSet rows = processInternal ( " SELECT hints _ dropped FROM system . " + SystemTable . PEER _ EVENTS _ CF ) ; 
 + Map < UUID , Integer > returned = rows . one ( ) . getMap ( " hints _ dropped " , UUIDType . instance , Int32Type . instance ) ; 
 + assertEquals ( Iterators . getLast ( returned . values ( ) . iterator ( ) ) . intValue ( ) , 99 ) ; 
 + } 
 }
