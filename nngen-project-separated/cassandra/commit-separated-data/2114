BLEU SCORE: 0.017081056798999895

TEST MSG: Invalidate prepared stmts when ks or table is dropped
GENERATED MSG: Workaround for netty issue causing corrupted data to come off the wire

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1764a20 . . ca578f3 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 1 . 1 <nl> + * Invalidate prepared statements when their keyspace or table is <nl> + dropped ( CASSANDRA - 7566 ) <nl> * cassandra - stress : fix support for NetworkTopologyStrategy ( CASSANDRA - 7945 ) <nl> * Fix saving caches when a table is dropped ( CASSANDRA - 7784 ) <nl> * Add better error checking of new stress profile ( CASSANDRA - 7716 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> index a5be108 . . efd1ebb 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> @ @ - 29 , 6 + 29 , 8 @ @ import com . googlecode . concurrentlinkedhashmap . ConcurrentLinkedHashMap ; <nl> import com . googlecode . concurrentlinkedhashmap . EntryWeigher ; <nl> import com . googlecode . concurrentlinkedhashmap . EvictionListener ; <nl> import org . antlr . runtime . * ; <nl> + import org . apache . cassandra . service . IMigrationListener ; <nl> + import org . apache . cassandra . service . MigrationManager ; <nl> import org . github . jamm . MemoryMeter ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> @ @ - 146 , 6 + 148 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> <nl> private QueryProcessor ( ) <nl> { <nl> + MigrationManager . instance . register ( new MigrationSubscriber ( ) ) ; <nl> } <nl> <nl> public ParsedStatement . Prepared getPrepared ( MD5Digest id ) <nl> @ @ - 508 , 4 + 511 , 68 @ @ public class QueryProcessor implements QueryHandler <nl> ? ( ( MeasurableForPreparedCache ) key ) . measureForPreparedCache ( meter ) <nl> : meter . measureDeep ( key ) ; <nl> } <nl> + <nl> + private static class MigrationSubscriber implements IMigrationListener <nl> + { <nl> + private void removeInvalidPreparedStatements ( String ksName , String cfName ) <nl> + { <nl> + Iterator < ParsedStatement . Prepared > iterator = preparedStatements . values ( ) . iterator ( ) ; <nl> + while ( iterator . hasNext ( ) ) <nl> + { <nl> + if ( shouldInvalidate ( ksName , cfName , iterator . next ( ) . statement ) ) <nl> + iterator . remove ( ) ; <nl> + } <nl> + <nl> + Iterator < CQLStatement > thriftIterator = thriftPreparedStatements . values ( ) . iterator ( ) ; <nl> + while ( thriftIterator . hasNext ( ) ) <nl> + { <nl> + if ( shouldInvalidate ( ksName , cfName , thriftIterator . next ( ) ) ) <nl> + thriftIterator . remove ( ) ; <nl> + } <nl> + } <nl> + <nl> + private boolean shouldInvalidate ( String ksName , String cfName , CQLStatement statement ) <nl> + { <nl> + String statementKsName ; <nl> + String statementCfName ; <nl> + <nl> + if ( statement instanceof ModificationStatement ) <nl> + { <nl> + ModificationStatement modificationStatement = ( ( ModificationStatement ) statement ) ; <nl> + statementKsName = modificationStatement . keyspace ( ) ; <nl> + statementCfName = modificationStatement . columnFamily ( ) ; <nl> + } <nl> + else if ( statement instanceof SelectStatement ) <nl> + { <nl> + SelectStatement selectStatement = ( ( SelectStatement ) statement ) ; <nl> + statementKsName = selectStatement . keyspace ( ) ; <nl> + statementCfName = selectStatement . columnFamily ( ) ; <nl> + } <nl> + else <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + return ksName . equals ( statementKsName ) & & ( cfName = = null | | cfName . equals ( statementCfName ) ) ; <nl> + } <nl> + <nl> + public void onCreateKeyspace ( String ksName ) { } <nl> + public void onCreateColumnFamily ( String ksName , String cfName ) { } <nl> + public void onCreateUserType ( String ksName , String typeName ) { } <nl> + public void onUpdateKeyspace ( String ksName ) { } <nl> + public void onUpdateColumnFamily ( String ksName , String cfName ) { } <nl> + public void onUpdateUserType ( String ksName , String typeName ) { } <nl> + <nl> + public void onDropKeyspace ( String ksName ) <nl> + { <nl> + removeInvalidPreparedStatements ( ksName , null ) ; <nl> + } <nl> + <nl> + public void onDropColumnFamily ( String ksName , String cfName ) <nl> + { <nl> + removeInvalidPreparedStatements ( ksName , cfName ) ; <nl> + } <nl> + <nl> + public void onDropUserType ( String ksName , String typeName ) { } <nl> + 	 } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / PreparedStatementCleanupTest . java b / test / unit / org / apache / cassandra / cql3 / PreparedStatementCleanupTest . java <nl> new file mode 100644 <nl> index 0000000 . . 3e725e9 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / PreparedStatementCleanupTest . java <nl> @ @ - 0 , 0 + 1 , 86 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import com . datastax . driver . core . Cluster ; <nl> + import com . datastax . driver . core . PreparedStatement ; <nl> + import com . datastax . driver . core . Session ; <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . config . Schema ; <nl> + import org . apache . cassandra . service . EmbeddedCassandraService ; <nl> + import org . junit . AfterClass ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + <nl> + public class PreparedStatementCleanupTest extends SchemaLoader <nl> + { <nl> + private static Cluster cluster ; <nl> + private static Session session ; <nl> + <nl> + private static final String KEYSPACE = " prepared _ stmt _ cleanup " ; <nl> + private static final String createKsStatement = " CREATE KEYSPACE " + KEYSPACE + <nl> + " WITH REPLICATION = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : 1 } ; " ; <nl> + private static final String dropKsStatement = " DROP KEYSPACE IF EXISTS " + KEYSPACE ; <nl> + <nl> + @ BeforeClass <nl> + public static void setup ( ) throws Exception <nl> + { <nl> + Schema . instance . clear ( ) ; <nl> + <nl> + EmbeddedCassandraService cassandra = new EmbeddedCassandraService ( ) ; <nl> + cassandra . start ( ) ; <nl> + <nl> + / / Currently the native server start method return before the server is fully binded to the socket , so we need <nl> + / / to wait slightly before trying to connect to it . We should fix this but in the meantime using a sleep . <nl> + Thread . sleep ( 500 ) ; <nl> + <nl> + 	 	 cluster = Cluster . builder ( ) . addContactPoint ( " 127 . 0 . 0 . 1 " ) <nl> + . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) <nl> + . build ( ) ; <nl> + session = cluster . connect ( ) ; <nl> + <nl> + session . execute ( dropKsStatement ) ; <nl> + session . execute ( createKsStatement ) ; <nl> + 	 } <nl> + <nl> + @ AfterClass <nl> + public static void tearDown ( ) throws Exception <nl> + { <nl> + cluster . close ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testInvalidatePreparedStatementsOnDrop ( ) <nl> + { <nl> + String createTableStatement = " CREATE TABLE IF NOT EXISTS " + KEYSPACE + " . qp _ cleanup ( id int PRIMARY KEY , cid int , val text ) ; " ; <nl> + String dropTableStatement = " DROP TABLE IF EXISTS " + KEYSPACE + " . qp _ cleanup ; " ; <nl> + <nl> + session . execute ( createTableStatement ) ; <nl> + PreparedStatement prepared = session . prepare ( " INSERT INTO " + KEYSPACE + " . qp _ cleanup ( id , cid , val ) VALUES ( ? , ? , ? ) " ) ; <nl> + session . execute ( dropTableStatement ) ; <nl> + session . execute ( createTableStatement ) ; <nl> + session . execute ( prepared . bind ( 1 , 1 , " value " ) ) ; <nl> + <nl> + session . execute ( dropKsStatement ) ; <nl> + session . execute ( createKsStatement ) ; <nl> + session . execute ( createTableStatement ) ; <nl> + session . execute ( prepared . bind ( 1 , 1 , " value " ) ) ; <nl> + session . execute ( dropKsStatement ) ; <nl> + 	 } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1764a20 . . ca578f3 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 1 . 1 
 + * Invalidate prepared statements when their keyspace or table is 
 + dropped ( CASSANDRA - 7566 ) 
 * cassandra - stress : fix support for NetworkTopologyStrategy ( CASSANDRA - 7945 ) 
 * Fix saving caches when a table is dropped ( CASSANDRA - 7784 ) 
 * Add better error checking of new stress profile ( CASSANDRA - 7716 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 index a5be108 . . efd1ebb 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 @ @ - 29 , 6 + 29 , 8 @ @ import com . googlecode . concurrentlinkedhashmap . ConcurrentLinkedHashMap ; 
 import com . googlecode . concurrentlinkedhashmap . EntryWeigher ; 
 import com . googlecode . concurrentlinkedhashmap . EvictionListener ; 
 import org . antlr . runtime . * ; 
 + import org . apache . cassandra . service . IMigrationListener ; 
 + import org . apache . cassandra . service . MigrationManager ; 
 import org . github . jamm . MemoryMeter ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 @ @ - 146 , 6 + 148 , 7 @ @ public class QueryProcessor implements QueryHandler 
 
 private QueryProcessor ( ) 
 { 
 + MigrationManager . instance . register ( new MigrationSubscriber ( ) ) ; 
 } 
 
 public ParsedStatement . Prepared getPrepared ( MD5Digest id ) 
 @ @ - 508 , 4 + 511 , 68 @ @ public class QueryProcessor implements QueryHandler 
 ? ( ( MeasurableForPreparedCache ) key ) . measureForPreparedCache ( meter ) 
 : meter . measureDeep ( key ) ; 
 } 
 + 
 + private static class MigrationSubscriber implements IMigrationListener 
 + { 
 + private void removeInvalidPreparedStatements ( String ksName , String cfName ) 
 + { 
 + Iterator < ParsedStatement . Prepared > iterator = preparedStatements . values ( ) . iterator ( ) ; 
 + while ( iterator . hasNext ( ) ) 
 + { 
 + if ( shouldInvalidate ( ksName , cfName , iterator . next ( ) . statement ) ) 
 + iterator . remove ( ) ; 
 + } 
 + 
 + Iterator < CQLStatement > thriftIterator = thriftPreparedStatements . values ( ) . iterator ( ) ; 
 + while ( thriftIterator . hasNext ( ) ) 
 + { 
 + if ( shouldInvalidate ( ksName , cfName , thriftIterator . next ( ) ) ) 
 + thriftIterator . remove ( ) ; 
 + } 
 + } 
 + 
 + private boolean shouldInvalidate ( String ksName , String cfName , CQLStatement statement ) 
 + { 
 + String statementKsName ; 
 + String statementCfName ; 
 + 
 + if ( statement instanceof ModificationStatement ) 
 + { 
 + ModificationStatement modificationStatement = ( ( ModificationStatement ) statement ) ; 
 + statementKsName = modificationStatement . keyspace ( ) ; 
 + statementCfName = modificationStatement . columnFamily ( ) ; 
 + } 
 + else if ( statement instanceof SelectStatement ) 
 + { 
 + SelectStatement selectStatement = ( ( SelectStatement ) statement ) ; 
 + statementKsName = selectStatement . keyspace ( ) ; 
 + statementCfName = selectStatement . columnFamily ( ) ; 
 + } 
 + else 
 + { 
 + return false ; 
 + } 
 + 
 + return ksName . equals ( statementKsName ) & & ( cfName = = null | | cfName . equals ( statementCfName ) ) ; 
 + } 
 + 
 + public void onCreateKeyspace ( String ksName ) { } 
 + public void onCreateColumnFamily ( String ksName , String cfName ) { } 
 + public void onCreateUserType ( String ksName , String typeName ) { } 
 + public void onUpdateKeyspace ( String ksName ) { } 
 + public void onUpdateColumnFamily ( String ksName , String cfName ) { } 
 + public void onUpdateUserType ( String ksName , String typeName ) { } 
 + 
 + public void onDropKeyspace ( String ksName ) 
 + { 
 + removeInvalidPreparedStatements ( ksName , null ) ; 
 + } 
 + 
 + public void onDropColumnFamily ( String ksName , String cfName ) 
 + { 
 + removeInvalidPreparedStatements ( ksName , cfName ) ; 
 + } 
 + 
 + public void onDropUserType ( String ksName , String typeName ) { } 
 + 	 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / PreparedStatementCleanupTest . java b / test / unit / org / apache / cassandra / cql3 / PreparedStatementCleanupTest . java 
 new file mode 100644 
 index 0000000 . . 3e725e9 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / PreparedStatementCleanupTest . java 
 @ @ - 0 , 0 + 1 , 86 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import com . datastax . driver . core . Cluster ; 
 + import com . datastax . driver . core . PreparedStatement ; 
 + import com . datastax . driver . core . Session ; 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . config . Schema ; 
 + import org . apache . cassandra . service . EmbeddedCassandraService ; 
 + import org . junit . AfterClass ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + 
 + public class PreparedStatementCleanupTest extends SchemaLoader 
 + { 
 + private static Cluster cluster ; 
 + private static Session session ; 
 + 
 + private static final String KEYSPACE = " prepared _ stmt _ cleanup " ; 
 + private static final String createKsStatement = " CREATE KEYSPACE " + KEYSPACE + 
 + " WITH REPLICATION = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : 1 } ; " ; 
 + private static final String dropKsStatement = " DROP KEYSPACE IF EXISTS " + KEYSPACE ; 
 + 
 + @ BeforeClass 
 + public static void setup ( ) throws Exception 
 + { 
 + Schema . instance . clear ( ) ; 
 + 
 + EmbeddedCassandraService cassandra = new EmbeddedCassandraService ( ) ; 
 + cassandra . start ( ) ; 
 + 
 + / / Currently the native server start method return before the server is fully binded to the socket , so we need 
 + / / to wait slightly before trying to connect to it . We should fix this but in the meantime using a sleep . 
 + Thread . sleep ( 500 ) ; 
 + 
 + 	 	 cluster = Cluster . builder ( ) . addContactPoint ( " 127 . 0 . 0 . 1 " ) 
 + . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) 
 + . build ( ) ; 
 + session = cluster . connect ( ) ; 
 + 
 + session . execute ( dropKsStatement ) ; 
 + session . execute ( createKsStatement ) ; 
 + 	 } 
 + 
 + @ AfterClass 
 + public static void tearDown ( ) throws Exception 
 + { 
 + cluster . close ( ) ; 
 + } 
 + 
 + @ Test 
 + public void testInvalidatePreparedStatementsOnDrop ( ) 
 + { 
 + String createTableStatement = " CREATE TABLE IF NOT EXISTS " + KEYSPACE + " . qp _ cleanup ( id int PRIMARY KEY , cid int , val text ) ; " ; 
 + String dropTableStatement = " DROP TABLE IF EXISTS " + KEYSPACE + " . qp _ cleanup ; " ; 
 + 
 + session . execute ( createTableStatement ) ; 
 + PreparedStatement prepared = session . prepare ( " INSERT INTO " + KEYSPACE + " . qp _ cleanup ( id , cid , val ) VALUES ( ? , ? , ? ) " ) ; 
 + session . execute ( dropTableStatement ) ; 
 + session . execute ( createTableStatement ) ; 
 + session . execute ( prepared . bind ( 1 , 1 , " value " ) ) ; 
 + 
 + session . execute ( dropKsStatement ) ; 
 + session . execute ( createKsStatement ) ; 
 + session . execute ( createTableStatement ) ; 
 + session . execute ( prepared . bind ( 1 , 1 , " value " ) ) ; 
 + session . execute ( dropKsStatement ) ; 
 + 	 } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
