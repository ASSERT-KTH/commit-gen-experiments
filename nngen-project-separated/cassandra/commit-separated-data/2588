BLEU SCORE: 0.08116697886877475

TEST MSG: Fix collection element access in IF
GENERATED MSG: Fix unintended update with conditional statement

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9bbcf07 . . 3a08c33 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 43 , 6 + 43 , 7 @ @ <nl> * Fix error with super columns in mixed 1 . 2 - 2 . 0 clusters ( CASSANDRA - 6966 ) <nl> * Fix bad skip of sstables on slice query with composite start / finish ( CASSANDRA - 6825 ) <nl> * Fix unintended update with conditional statement ( CASSANDRA - 6893 ) <nl> + * Fix map element access in IF ( CASSANDRA - 6914 ) <nl> Merged from 1 . 2 : <nl> * Add UNLOGGED , COUNTER options to BATCH documentation ( CASSANDRA - 6816 ) <nl> * add extra SSL cipher suites ( CASSANDRA - 6613 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / ColumnCondition . java b / src / java / org / apache / cassandra / cql3 / ColumnCondition . java <nl> index e6cdf43 . . 9fb3390 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / ColumnCondition . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / ColumnCondition . java <nl> @ @ - 28 , 6 + 28 , 7 @ @ import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> / * * <nl> * A CQL3 condition . <nl> @ @ - 35 , 18 + 36 , 27 @ @ import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> public class ColumnCondition <nl> { <nl> public final CFDefinition . Name column ; <nl> + <nl> + / / For collection , when testing the equality of a specific element , null otherwise . <nl> + private final Term collectionElement ; <nl> + <nl> private final Term value ; <nl> <nl> - private ColumnCondition ( CFDefinition . Name column , Term value ) <nl> + private ColumnCondition ( CFDefinition . Name column , Term collectionElement , Term value ) <nl> { <nl> this . column = column ; <nl> + this . collectionElement = collectionElement ; <nl> this . value = value ; <nl> } <nl> <nl> - / / The only ones we support so far <nl> public static ColumnCondition equal ( CFDefinition . Name column , Term value ) <nl> { <nl> - return new ColumnCondition ( column , value ) ; <nl> + return new ColumnCondition ( column , null , value ) ; <nl> + } <nl> + <nl> + public static ColumnCondition equal ( CFDefinition . Name column , Term collectionElement , Term value ) <nl> + { <nl> + return new ColumnCondition ( column , collectionElement , value ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 57 , 6 + 67 , 8 @ @ public class ColumnCondition <nl> * / <nl> public void collectMarkerSpecification ( VariableSpecifications boundNames ) <nl> { <nl> + if ( collectionElement ! = null ) <nl> + collectionElement . collectMarkerSpecification ( boundNames ) ; <nl> value . collectMarkerSpecification ( boundNames ) ; <nl> } <nl> <nl> @ @ - 74 , 12 + 86 , 26 @ @ public class ColumnCondition <nl> this . variables = variables ; <nl> } <nl> <nl> - / / Not overriding equals ( ) because we need the variables to have been attached when this is <nl> - / / called and so having a non standard method name might help avoid mistakes <nl> public boolean equalsTo ( WithVariables other ) throws InvalidRequestException <nl> { <nl> - return column . equals ( other . column ( ) ) <nl> - & & value . bindAndGet ( variables ) . equals ( other . value ( ) . bindAndGet ( other . variables ) ) ; <nl> + if ( ! column ( ) . equals ( other . column ( ) ) ) <nl> + return false ; <nl> + <nl> + if ( ( collectionElement ( ) = = null ) ! = ( other . collectionElement ( ) = = null ) ) <nl> + return false ; <nl> + <nl> + if ( collectionElement ( ) ! = null ) <nl> + { <nl> + assert column . type instanceof ListType | | column . type instanceof MapType ; <nl> + AbstractType < ? > comparator = column . type instanceof ListType <nl> + ? Int32Type . instance <nl> + : ( ( MapType ) column . type ) . keys ; <nl> + <nl> + if ( comparator . compare ( collectionElement ( ) . bindAndGet ( variables ) , other . collectionElement ( ) . bindAndGet ( variables ) ) ! = 0 ) <nl> + return false ; <nl> + } <nl> + <nl> + return value ( ) . bindAndGet ( variables ) . equals ( other . value ( ) . bindAndGet ( other . variables ) ) ; <nl> } <nl> <nl> private CFDefinition . Name column ( ) <nl> @ @ - 87 , 11 + 113 , 21 @ @ public class ColumnCondition <nl> return column ; <nl> } <nl> <nl> + private Term collectionElement ( ) <nl> + { <nl> + return collectionElement ; <nl> + } <nl> + <nl> private Term value ( ) <nl> { <nl> return value ; <nl> } <nl> <nl> + public ByteBuffer getCollectionElementValue ( ) throws InvalidRequestException <nl> + { <nl> + return collectionElement = = null ? null : collectionElement . bindAndGet ( variables ) ; <nl> + } <nl> + <nl> private ColumnNameBuilder copyOrUpdatePrefix ( CFMetaData cfm , ColumnNameBuilder rowPrefix ) <nl> { <nl> return column . kind = = CFDefinition . Name . Kind . STATIC ? cfm . getStaticColumnNameBuilder ( ) : rowPrefix . copy ( ) ; <nl> @ @ - 105 , 6 + 141 , 7 @ @ public class ColumnCondition <nl> if ( column . type instanceof CollectionType ) <nl> return collectionAppliesTo ( ( CollectionType ) column . type , rowPrefix , current , now ) ; <nl> <nl> + assert collectionElement = = null ; <nl> ColumnNameBuilder prefix = copyOrUpdatePrefix ( current . metadata ( ) , rowPrefix ) ; <nl> ByteBuffer columnName = column . kind = = CFDefinition . Name . Kind . VALUE _ ALIAS <nl> ? prefix . build ( ) <nl> @ @ - 120 , 6 + 157 , 17 @ @ public class ColumnCondition <nl> private boolean collectionAppliesTo ( CollectionType type , ColumnNameBuilder rowPrefix , ColumnFamily current , final long now ) throws InvalidRequestException <nl> { <nl> ColumnNameBuilder collectionPrefix = copyOrUpdatePrefix ( current . metadata ( ) , rowPrefix ) . add ( column . name . key ) ; <nl> + Term . Terminal v = value . bind ( variables ) ; <nl> + <nl> + / / For map element access , we won ' t iterate over the collection , so deal with that first . In other case , we do . <nl> + if ( collectionElement ! = null & & type instanceof MapType ) <nl> + { <nl> + ByteBuffer e = collectionElement . bindAndGet ( variables ) ; <nl> + if ( e = = null ) <nl> + throw new InvalidRequestException ( " Invalid null value for map access " ) ; <nl> + return mapElementAppliesTo ( ( MapType ) type , current , collectionPrefix , e , v . get ( ) , now ) ; <nl> + } <nl> + <nl> / / We are testing for collection equality , so we need to have the expected values * and * only those . <nl> ColumnSlice [ ] collectionSlice = new ColumnSlice [ ] { new ColumnSlice ( collectionPrefix . build ( ) , collectionPrefix . buildAsEndOfRange ( ) ) } ; <nl> / / Filter live columns , this makes things simpler afterwards <nl> @ @ - 132 , 10 + 180 , 19 @ @ public class ColumnCondition <nl> } <nl> } ) ; <nl> <nl> - Term . Terminal v = value . bind ( variables ) ; <nl> if ( v = = null ) <nl> return ! iter . hasNext ( ) ; <nl> <nl> + if ( collectionElement ! = null ) <nl> + { <nl> + assert type instanceof ListType ; <nl> + ByteBuffer e = collectionElement . bindAndGet ( variables ) ; <nl> + if ( e = = null ) <nl> + throw new InvalidRequestException ( " Invalid null value for list access " ) ; <nl> + <nl> + return listElementAppliesTo ( ( ListType ) type , iter , e , v . get ( ) ) ; <nl> + } <nl> + <nl> switch ( type . kind ) <nl> { <nl> case LIST : return listAppliesTo ( ( ListType ) type , current . metadata ( ) , iter , ( ( Lists . Value ) v ) . elements ) ; <nl> @ @ - 160 , 6 + 217 , 19 @ @ public class ColumnCondition <nl> return ! iter . hasNext ( ) ; <nl> } <nl> <nl> + private boolean listElementAppliesTo ( ListType type , Iterator < Column > iter , ByteBuffer element , ByteBuffer value ) throws InvalidRequestException <nl> + { <nl> + int idx = ByteBufferUtil . toInt ( element ) ; <nl> + if ( idx < 0 ) <nl> + throw new InvalidRequestException ( String . format ( " Invalid negative list index % d " , idx ) ) ; <nl> + <nl> + int adv = Iterators . advance ( iter , idx ) ; <nl> + if ( adv ! = idx | | ! iter . hasNext ( ) ) <nl> + throw new InvalidRequestException ( String . format ( " List index % d out of bound , list has size % d " , idx , adv ) ) ; <nl> + <nl> + return type . elements . compare ( iter . next ( ) . value ( ) , value ) = = 0 ; <nl> + } <nl> + <nl> private boolean setAppliesTo ( SetType type , CFMetaData cfm , Iterator < Column > iter , Set < ByteBuffer > elements ) <nl> { <nl> Set < ByteBuffer > remaining = new TreeSet < > ( type . elements ) ; <nl> @ @ - 191 , 15 + 261 , 36 @ @ public class ColumnCondition <nl> } <nl> return remaining . isEmpty ( ) ; <nl> } <nl> + <nl> + private boolean mapElementAppliesTo ( MapType type , ColumnFamily current , ColumnNameBuilder collectionPrefix , ByteBuffer element , ByteBuffer value , long now ) <nl> + { <nl> + ByteBuffer name = collectionPrefix . add ( element ) . build ( ) ; <nl> + Column c = current . getColumn ( name ) ; <nl> + return c ! = null & & c . isLive ( now ) & & type . values . compare ( c . value ( ) , value ) = = 0 ; <nl> + } <nl> } <nl> <nl> public static class Raw <nl> { <nl> private final Term . Raw value ; <nl> <nl> - public Raw ( Term . Raw value ) <nl> + / / Can be null , only used with the syntax " IF m [ e ] = . . . " ( in which case it ' s ' e ' ) <nl> + private final Term . Raw collectionElement ; <nl> + <nl> + private Raw ( Term . Raw value , Term . Raw collectionElement ) <nl> { <nl> this . value = value ; <nl> + this . collectionElement = collectionElement ; <nl> + } <nl> + <nl> + public static Raw simpleEqual ( Term . Raw value ) <nl> + { <nl> + return new Raw ( value , null ) ; <nl> + } <nl> + <nl> + public static Raw collectionEqual ( Term . Raw value , Term . Raw collectionElement ) <nl> + { <nl> + return new Raw ( value , collectionElement ) ; <nl> } <nl> <nl> public ColumnCondition prepare ( CFDefinition . Name receiver ) throws InvalidRequestException <nl> @ @ - 207 , 7 + 298 , 22 @ @ public class ColumnCondition <nl> if ( receiver . type instanceof CounterColumnType ) <nl> throw new InvalidRequestException ( " Condtions on counters are not supported " ) ; <nl> <nl> - return ColumnCondition . equal ( receiver , value . prepare ( receiver ) ) ; <nl> + if ( collectionElement = = null ) <nl> + return ColumnCondition . equal ( receiver , value . prepare ( receiver ) ) ; <nl> + <nl> + if ( ! ( receiver . type . isCollection ( ) ) ) <nl> + throw new InvalidRequestException ( String . format ( " Invalid element access syntax for non - collection column % s " , receiver . name ) ) ; <nl> + <nl> + switch ( ( ( CollectionType ) receiver . type ) . kind ) <nl> + { <nl> + case LIST : <nl> + return ColumnCondition . equal ( receiver , collectionElement . prepare ( Lists . indexSpecOf ( receiver ) ) , value . prepare ( Lists . valueSpecOf ( receiver ) ) ) ; <nl> + case SET : <nl> + throw new InvalidRequestException ( String . format ( " Invalid element access syntax for set column % s " , receiver . name ) ) ; <nl> + case MAP : <nl> + return ColumnCondition . equal ( receiver , collectionElement . prepare ( Maps . keySpecOf ( receiver ) ) , value . prepare ( Maps . valueSpecOf ( receiver ) ) ) ; <nl> + } <nl> + throw new AssertionError ( ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index ed482d0 . . 04f9f59 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 852 , 7 + 852 , 9 @ @ columnOperation [ List < Pair < ColumnIdentifier , Operation . RawUpdate > > operations ] <nl> ; <nl> <nl> columnCondition [ List < Pair < ColumnIdentifier , ColumnCondition . Raw > > conditions ] <nl> - : key = cident ' = ' t = term { conditions . add ( Pair . create ( key , new ColumnCondition . Raw ( t ) ) ) ; } / / Note : we ' ll reject duplicates later <nl> + / / Note : we ' ll reject duplicates later <nl> + : key = cident ' = ' t = term { conditions . add ( Pair . create ( key , ColumnCondition . Raw . simpleEqual ( t ) ) ) ; } <nl> + | key = cident ' [ ' element = term ' ] ' ' = ' t = term { conditions . add ( Pair . create ( key , ColumnCondition . Raw . collectionEqual ( t , element ) ) ) ; } <nl> ; <nl> <nl> properties [ PropertyDefinitions props ] <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java <nl> index 7d3c0f7 . . 9f67bc0 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . filter . * ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . service . CASConditions ; <nl> + import org . apache . cassandra . utils . Pair ; <nl> <nl> / * * <nl> * Processed CAS conditions on potentially multiple rows of the same partition . <nl> @ @ - 166 , 7 + 167 , 7 @ @ public class CQL3CasConditions implements CASConditions <nl> <nl> private static class ColumnsConditions extends RowCondition <nl> { <nl> - private final Map < ColumnIdentifier , ColumnCondition . WithVariables > conditions = new HashMap < > ( ) ; <nl> + private final Map < Pair < ColumnIdentifier , ByteBuffer > , ColumnCondition . WithVariables > conditions = new HashMap < > ( ) ; <nl> <nl> private ColumnsConditions ( ColumnNameBuilder rowPrefix , long now ) <nl> { <nl> @ @ - 180 , 7 + 181 , 7 @ @ public class CQL3CasConditions implements CASConditions <nl> / / We will need the variables in appliesTo but with protocol batches , each condition in this object can have a <nl> / / different list of variables . <nl> ColumnCondition . WithVariables current = condition . with ( variables ) ; <nl> - ColumnCondition . WithVariables previous = conditions . put ( condition . column . name , current ) ; <nl> + ColumnCondition . WithVariables previous = conditions . put ( Pair . create ( condition . column . name , current . getCollectionElementValue ( ) ) , current ) ; <nl> / / If 2 conditions are actually equal , let it slide <nl> if ( previous ! = null & & ! previous . equalsTo ( current ) ) <nl> throw new InvalidRequestException ( " Duplicate and incompatible conditions for column " + condition . column . name ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9bbcf07 . . 3a08c33 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 43 , 6 + 43 , 7 @ @ 
 * Fix error with super columns in mixed 1 . 2 - 2 . 0 clusters ( CASSANDRA - 6966 ) 
 * Fix bad skip of sstables on slice query with composite start / finish ( CASSANDRA - 6825 ) 
 * Fix unintended update with conditional statement ( CASSANDRA - 6893 ) 
 + * Fix map element access in IF ( CASSANDRA - 6914 ) 
 Merged from 1 . 2 : 
 * Add UNLOGGED , COUNTER options to BATCH documentation ( CASSANDRA - 6816 ) 
 * add extra SSL cipher suites ( CASSANDRA - 6613 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / ColumnCondition . java b / src / java / org / apache / cassandra / cql3 / ColumnCondition . java 
 index e6cdf43 . . 9fb3390 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / ColumnCondition . java 
 + + + b / src / java / org / apache / cassandra / cql3 / ColumnCondition . java 
 @ @ - 28 , 6 + 28 , 7 @ @ import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 / * * 
 * A CQL3 condition . 
 @ @ - 35 , 18 + 36 , 27 @ @ import org . apache . cassandra . exceptions . InvalidRequestException ; 
 public class ColumnCondition 
 { 
 public final CFDefinition . Name column ; 
 + 
 + / / For collection , when testing the equality of a specific element , null otherwise . 
 + private final Term collectionElement ; 
 + 
 private final Term value ; 
 
 - private ColumnCondition ( CFDefinition . Name column , Term value ) 
 + private ColumnCondition ( CFDefinition . Name column , Term collectionElement , Term value ) 
 { 
 this . column = column ; 
 + this . collectionElement = collectionElement ; 
 this . value = value ; 
 } 
 
 - / / The only ones we support so far 
 public static ColumnCondition equal ( CFDefinition . Name column , Term value ) 
 { 
 - return new ColumnCondition ( column , value ) ; 
 + return new ColumnCondition ( column , null , value ) ; 
 + } 
 + 
 + public static ColumnCondition equal ( CFDefinition . Name column , Term collectionElement , Term value ) 
 + { 
 + return new ColumnCondition ( column , collectionElement , value ) ; 
 } 
 
 / * * 
 @ @ - 57 , 6 + 67 , 8 @ @ public class ColumnCondition 
 * / 
 public void collectMarkerSpecification ( VariableSpecifications boundNames ) 
 { 
 + if ( collectionElement ! = null ) 
 + collectionElement . collectMarkerSpecification ( boundNames ) ; 
 value . collectMarkerSpecification ( boundNames ) ; 
 } 
 
 @ @ - 74 , 12 + 86 , 26 @ @ public class ColumnCondition 
 this . variables = variables ; 
 } 
 
 - / / Not overriding equals ( ) because we need the variables to have been attached when this is 
 - / / called and so having a non standard method name might help avoid mistakes 
 public boolean equalsTo ( WithVariables other ) throws InvalidRequestException 
 { 
 - return column . equals ( other . column ( ) ) 
 - & & value . bindAndGet ( variables ) . equals ( other . value ( ) . bindAndGet ( other . variables ) ) ; 
 + if ( ! column ( ) . equals ( other . column ( ) ) ) 
 + return false ; 
 + 
 + if ( ( collectionElement ( ) = = null ) ! = ( other . collectionElement ( ) = = null ) ) 
 + return false ; 
 + 
 + if ( collectionElement ( ) ! = null ) 
 + { 
 + assert column . type instanceof ListType | | column . type instanceof MapType ; 
 + AbstractType < ? > comparator = column . type instanceof ListType 
 + ? Int32Type . instance 
 + : ( ( MapType ) column . type ) . keys ; 
 + 
 + if ( comparator . compare ( collectionElement ( ) . bindAndGet ( variables ) , other . collectionElement ( ) . bindAndGet ( variables ) ) ! = 0 ) 
 + return false ; 
 + } 
 + 
 + return value ( ) . bindAndGet ( variables ) . equals ( other . value ( ) . bindAndGet ( other . variables ) ) ; 
 } 
 
 private CFDefinition . Name column ( ) 
 @ @ - 87 , 11 + 113 , 21 @ @ public class ColumnCondition 
 return column ; 
 } 
 
 + private Term collectionElement ( ) 
 + { 
 + return collectionElement ; 
 + } 
 + 
 private Term value ( ) 
 { 
 return value ; 
 } 
 
 + public ByteBuffer getCollectionElementValue ( ) throws InvalidRequestException 
 + { 
 + return collectionElement = = null ? null : collectionElement . bindAndGet ( variables ) ; 
 + } 
 + 
 private ColumnNameBuilder copyOrUpdatePrefix ( CFMetaData cfm , ColumnNameBuilder rowPrefix ) 
 { 
 return column . kind = = CFDefinition . Name . Kind . STATIC ? cfm . getStaticColumnNameBuilder ( ) : rowPrefix . copy ( ) ; 
 @ @ - 105 , 6 + 141 , 7 @ @ public class ColumnCondition 
 if ( column . type instanceof CollectionType ) 
 return collectionAppliesTo ( ( CollectionType ) column . type , rowPrefix , current , now ) ; 
 
 + assert collectionElement = = null ; 
 ColumnNameBuilder prefix = copyOrUpdatePrefix ( current . metadata ( ) , rowPrefix ) ; 
 ByteBuffer columnName = column . kind = = CFDefinition . Name . Kind . VALUE _ ALIAS 
 ? prefix . build ( ) 
 @ @ - 120 , 6 + 157 , 17 @ @ public class ColumnCondition 
 private boolean collectionAppliesTo ( CollectionType type , ColumnNameBuilder rowPrefix , ColumnFamily current , final long now ) throws InvalidRequestException 
 { 
 ColumnNameBuilder collectionPrefix = copyOrUpdatePrefix ( current . metadata ( ) , rowPrefix ) . add ( column . name . key ) ; 
 + Term . Terminal v = value . bind ( variables ) ; 
 + 
 + / / For map element access , we won ' t iterate over the collection , so deal with that first . In other case , we do . 
 + if ( collectionElement ! = null & & type instanceof MapType ) 
 + { 
 + ByteBuffer e = collectionElement . bindAndGet ( variables ) ; 
 + if ( e = = null ) 
 + throw new InvalidRequestException ( " Invalid null value for map access " ) ; 
 + return mapElementAppliesTo ( ( MapType ) type , current , collectionPrefix , e , v . get ( ) , now ) ; 
 + } 
 + 
 / / We are testing for collection equality , so we need to have the expected values * and * only those . 
 ColumnSlice [ ] collectionSlice = new ColumnSlice [ ] { new ColumnSlice ( collectionPrefix . build ( ) , collectionPrefix . buildAsEndOfRange ( ) ) } ; 
 / / Filter live columns , this makes things simpler afterwards 
 @ @ - 132 , 10 + 180 , 19 @ @ public class ColumnCondition 
 } 
 } ) ; 
 
 - Term . Terminal v = value . bind ( variables ) ; 
 if ( v = = null ) 
 return ! iter . hasNext ( ) ; 
 
 + if ( collectionElement ! = null ) 
 + { 
 + assert type instanceof ListType ; 
 + ByteBuffer e = collectionElement . bindAndGet ( variables ) ; 
 + if ( e = = null ) 
 + throw new InvalidRequestException ( " Invalid null value for list access " ) ; 
 + 
 + return listElementAppliesTo ( ( ListType ) type , iter , e , v . get ( ) ) ; 
 + } 
 + 
 switch ( type . kind ) 
 { 
 case LIST : return listAppliesTo ( ( ListType ) type , current . metadata ( ) , iter , ( ( Lists . Value ) v ) . elements ) ; 
 @ @ - 160 , 6 + 217 , 19 @ @ public class ColumnCondition 
 return ! iter . hasNext ( ) ; 
 } 
 
 + private boolean listElementAppliesTo ( ListType type , Iterator < Column > iter , ByteBuffer element , ByteBuffer value ) throws InvalidRequestException 
 + { 
 + int idx = ByteBufferUtil . toInt ( element ) ; 
 + if ( idx < 0 ) 
 + throw new InvalidRequestException ( String . format ( " Invalid negative list index % d " , idx ) ) ; 
 + 
 + int adv = Iterators . advance ( iter , idx ) ; 
 + if ( adv ! = idx | | ! iter . hasNext ( ) ) 
 + throw new InvalidRequestException ( String . format ( " List index % d out of bound , list has size % d " , idx , adv ) ) ; 
 + 
 + return type . elements . compare ( iter . next ( ) . value ( ) , value ) = = 0 ; 
 + } 
 + 
 private boolean setAppliesTo ( SetType type , CFMetaData cfm , Iterator < Column > iter , Set < ByteBuffer > elements ) 
 { 
 Set < ByteBuffer > remaining = new TreeSet < > ( type . elements ) ; 
 @ @ - 191 , 15 + 261 , 36 @ @ public class ColumnCondition 
 } 
 return remaining . isEmpty ( ) ; 
 } 
 + 
 + private boolean mapElementAppliesTo ( MapType type , ColumnFamily current , ColumnNameBuilder collectionPrefix , ByteBuffer element , ByteBuffer value , long now ) 
 + { 
 + ByteBuffer name = collectionPrefix . add ( element ) . build ( ) ; 
 + Column c = current . getColumn ( name ) ; 
 + return c ! = null & & c . isLive ( now ) & & type . values . compare ( c . value ( ) , value ) = = 0 ; 
 + } 
 } 
 
 public static class Raw 
 { 
 private final Term . Raw value ; 
 
 - public Raw ( Term . Raw value ) 
 + / / Can be null , only used with the syntax " IF m [ e ] = . . . " ( in which case it ' s ' e ' ) 
 + private final Term . Raw collectionElement ; 
 + 
 + private Raw ( Term . Raw value , Term . Raw collectionElement ) 
 { 
 this . value = value ; 
 + this . collectionElement = collectionElement ; 
 + } 
 + 
 + public static Raw simpleEqual ( Term . Raw value ) 
 + { 
 + return new Raw ( value , null ) ; 
 + } 
 + 
 + public static Raw collectionEqual ( Term . Raw value , Term . Raw collectionElement ) 
 + { 
 + return new Raw ( value , collectionElement ) ; 
 } 
 
 public ColumnCondition prepare ( CFDefinition . Name receiver ) throws InvalidRequestException 
 @ @ - 207 , 7 + 298 , 22 @ @ public class ColumnCondition 
 if ( receiver . type instanceof CounterColumnType ) 
 throw new InvalidRequestException ( " Condtions on counters are not supported " ) ; 
 
 - return ColumnCondition . equal ( receiver , value . prepare ( receiver ) ) ; 
 + if ( collectionElement = = null ) 
 + return ColumnCondition . equal ( receiver , value . prepare ( receiver ) ) ; 
 + 
 + if ( ! ( receiver . type . isCollection ( ) ) ) 
 + throw new InvalidRequestException ( String . format ( " Invalid element access syntax for non - collection column % s " , receiver . name ) ) ; 
 + 
 + switch ( ( ( CollectionType ) receiver . type ) . kind ) 
 + { 
 + case LIST : 
 + return ColumnCondition . equal ( receiver , collectionElement . prepare ( Lists . indexSpecOf ( receiver ) ) , value . prepare ( Lists . valueSpecOf ( receiver ) ) ) ; 
 + case SET : 
 + throw new InvalidRequestException ( String . format ( " Invalid element access syntax for set column % s " , receiver . name ) ) ; 
 + case MAP : 
 + return ColumnCondition . equal ( receiver , collectionElement . prepare ( Maps . keySpecOf ( receiver ) ) , value . prepare ( Maps . valueSpecOf ( receiver ) ) ) ; 
 + } 
 + throw new AssertionError ( ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index ed482d0 . . 04f9f59 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 852 , 7 + 852 , 9 @ @ columnOperation [ List < Pair < ColumnIdentifier , Operation . RawUpdate > > operations ] 
 ; 
 
 columnCondition [ List < Pair < ColumnIdentifier , ColumnCondition . Raw > > conditions ] 
 - : key = cident ' = ' t = term { conditions . add ( Pair . create ( key , new ColumnCondition . Raw ( t ) ) ) ; } / / Note : we ' ll reject duplicates later 
 + / / Note : we ' ll reject duplicates later 
 + : key = cident ' = ' t = term { conditions . add ( Pair . create ( key , ColumnCondition . Raw . simpleEqual ( t ) ) ) ; } 
 + | key = cident ' [ ' element = term ' ] ' ' = ' t = term { conditions . add ( Pair . create ( key , ColumnCondition . Raw . collectionEqual ( t , element ) ) ) ; } 
 ; 
 
 properties [ PropertyDefinitions props ] 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java 
 index 7d3c0f7 . . 9f67bc0 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasConditions . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . filter . * ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . service . CASConditions ; 
 + import org . apache . cassandra . utils . Pair ; 
 
 / * * 
 * Processed CAS conditions on potentially multiple rows of the same partition . 
 @ @ - 166 , 7 + 167 , 7 @ @ public class CQL3CasConditions implements CASConditions 
 
 private static class ColumnsConditions extends RowCondition 
 { 
 - private final Map < ColumnIdentifier , ColumnCondition . WithVariables > conditions = new HashMap < > ( ) ; 
 + private final Map < Pair < ColumnIdentifier , ByteBuffer > , ColumnCondition . WithVariables > conditions = new HashMap < > ( ) ; 
 
 private ColumnsConditions ( ColumnNameBuilder rowPrefix , long now ) 
 { 
 @ @ - 180 , 7 + 181 , 7 @ @ public class CQL3CasConditions implements CASConditions 
 / / We will need the variables in appliesTo but with protocol batches , each condition in this object can have a 
 / / different list of variables . 
 ColumnCondition . WithVariables current = condition . with ( variables ) ; 
 - ColumnCondition . WithVariables previous = conditions . put ( condition . column . name , current ) ; 
 + ColumnCondition . WithVariables previous = conditions . put ( Pair . create ( condition . column . name , current . getCollectionElementValue ( ) ) , current ) ; 
 / / If 2 conditions are actually equal , let it slide 
 if ( previous ! = null & & ! previous . equalsTo ( current ) ) 
 throw new InvalidRequestException ( " Duplicate and incompatible conditions for column " + condition . column . name ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
