BLEU SCORE: 0.021504238591261653

TEST MSG: CQL3 : improve support for paginating over composites
GENERATED MSG: Fix count ( * ) queries in a mixed cluster

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 571b8dd . . fd3b1b7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * Stop CommitLogSegment . close ( ) from calling sync ( ) ( CASSANDRA - 6652 ) <nl> * Make commitlog failure handling configurable ( CASSANDRA - 6364 ) <nl> * Avoid overlaps in LCS ( CASSANDRA - 6688 ) <nl> + * improve support for paginating over composites ( 4851 ) <nl> Merged from 1 . 2 : <nl> * Fix broken streams when replacing with same IP ( CASSANDRA - 6622 ) <nl> * Fix upgradesstables NPE for non - CF - based indexes ( CASSANDRA - 6645 ) <nl> diff - - git a / doc / cql3 / CQL . textile b / doc / cql3 / CQL . textile <nl> index f82fc19 . . 03b95e0 100644 <nl> - - - a / doc / cql3 / CQL . textile <nl> + + + b / doc / cql3 / CQL . textile <nl> @ @ - 1 , 6 + 1 , 6 @ @ <nl> < link rel = " StyleSheet " href = " CQL . css " type = " text / css " media = " screen " > <nl> <nl> - h1 . Cassandra Query Language ( CQL ) v3 . 1 . 4 <nl> + h1 . Cassandra Query Language ( CQL ) v3 . 1 . 5 <nl> <nl> <nl> < span id = " tableOfContents " > <nl> @ @ - 619 , 10 + 619 , 12 @ @ bc ( syntax ) . . <nl> <nl> < where - clause > : : = < relation > ( AND < relation > ) * <nl> <nl> - < relation > : : = < identifier > ( ' = ' | ' < ' | ' > ' | ' < = ' | ' > = ' ) < term > <nl> + < relation > : : = < identifier > < op > < term > <nl> + | ' ( ' < identifier > ( ' , ' < identifier > ) * ' ) ' < op > ' ( ' < term > ( ' , ' < term > ) * ' ) ' <nl> | < identifier > IN ' ( ' ( < term > ( ' , ' < term > ) * ) ? ' ) ' <nl> - | TOKEN ' ( ' < identifier > ( ' , ' < identifer > ) * ' ) ' ( ' = ' | ' < ' | ' > ' | ' < = ' | ' > = ' ) < term > <nl> + | TOKEN ' ( ' < identifier > ( ' , ' < identifer > ) * ' ) ' < op > < term > <nl> <nl> + < op > : : = ' = ' | ' < ' | ' > ' | ' < = ' | ' > = ' <nl> < order - by > : : = < ordering > ( ' , ' < odering > ) * <nl> < ordering > : : = < identifer > ( ASC | DESC ) ? <nl> p . <nl> @ @ - 676 , 7 + 678 , 7 @ @ CREATE TABLE posts ( <nl> The following query is allowed : <nl> <nl> bc ( sample ) . <nl> - SELECT entry _ title , content FROM posts WHERE userid = ' john doe ' AND blog _ title = ' John ' s Blog ' AND posted _ at > = ' 2012 - 01 - 01 ' AND posted _ at < ' 2012 - 01 - 31 ' <nl> + SELECT entry _ title , content FROM posts WHERE userid = ' john doe ' AND blog _ title = ' John ' ' s Blog ' AND posted _ at > = ' 2012 - 01 - 01 ' AND posted _ at < ' 2012 - 01 - 31 ' <nl> <nl> But the following one is not , as it does not select a contiguous set of rows ( and we suppose no secondary indexes are set ) : <nl> <nl> @ @ - 691 , 6 + 693 , 16 @ @ SELECT * FROM posts WHERE token ( userid ) > token ( ' tom ' ) AND token ( userid ) < token <nl> <nl> Moreover , the @ IN @ relation is only allowed on the last column of the partition key and on the last column of the full primary key . <nl> <nl> + It is also possible to " group " @ CLUSTERING COLUMNS @ together in a relation , for instance : <nl> + <nl> + bc ( sample ) . <nl> + SELECT * FROM posts WHERE userid = ' john doe ' AND ( blog _ title , posted _ at ) > ( ' John ' ' s Blog ' , ' 2012 - 01 - 01 ' ) <nl> + <nl> + will request all rows that sorts after the one having " John ' s Blog " as @ blog _ tile @ and ' 2012 - 01 - 01 ' for @ posted _ at @ in the clustering order . In particular , rows having a @ post _ at < = ' 2012 - 01 - 01 ' @ will be returned as long as their @ blog _ title > ' John ' ' s Blog ' @ , which wouldn ' t be the case for : <nl> + <nl> + bc ( sample ) . <nl> + SELECT * FROM posts WHERE userid = ' john doe ' AND blog _ title > ' John ' ' s Blog ' AND posted _ at > ' 2012 - 01 - 01 ' <nl> + <nl> h4 ( # selectOrderBy ) . @ < order - by > @ <nl> <nl> The @ ORDER BY @ option allows to select the order of the returned results . It takes as argument a list of column names along with the order for the column ( @ ASC @ for ascendant and @ DESC @ for descendant , omitting the order being equivalent to @ ASC @ ) . Currently the possible orderings are limited ( which depends on the table " @ CLUSTERING ORDER @ " : # createTableOptions ) : <nl> @ @ - 1101 , 6 + 1113 , 10 @ @ h2 ( # changes ) . Changes <nl> <nl> The following describes the addition / changes brought for each version of CQL . <nl> <nl> + h3 . 3 . 1 . 5 <nl> + <nl> + * It is now possible to group clustering columns in a relatiion , see " SELECT Where clauses " : # selectWhere . <nl> + <nl> h3 . 3 . 1 . 4 <nl> <nl> * @ CREATE INDEX @ now allows specifying options when creating CUSTOM indexes ( see " CREATE INDEX reference " : # createIndexStmt ) . <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / CFDefinition . java b / src / java / org / apache / cassandra / cql3 / CFDefinition . java <nl> index 54ca2b8 . . 638770d 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / CFDefinition . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / CFDefinition . java <nl> @ @ - 246 , 11 + 246 , 6 @ @ public class CFDefinition implements Iterable < CFDefinition . Name > <nl> return this ; <nl> } <nl> <nl> - public NonCompositeBuilder add ( ByteBuffer bb , Relation . Type op ) <nl> - { <nl> - return add ( bb ) ; <nl> - } <nl> - <nl> public int componentCount ( ) <nl> { <nl> return columnName = = null ? 0 : 1 ; <nl> @ @ - 279 , 6 + 274 , 11 @ @ public class CFDefinition implements Iterable < CFDefinition . Name > <nl> return build ( ) ; <nl> } <nl> <nl> + public ByteBuffer buildForRelation ( Relation . Type op ) <nl> + { <nl> + return build ( ) ; <nl> + } <nl> + <nl> public NonCompositeBuilder copy ( ) <nl> { <nl> NonCompositeBuilder newBuilder = new NonCompositeBuilder ( type ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / ColumnNameBuilder . java b / src / java / org / apache / cassandra / cql3 / ColumnNameBuilder . java <nl> index b6625ab . . 3d5eff6 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / ColumnNameBuilder . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / ColumnNameBuilder . java <nl> @ @ - 33 , 15 + 33 , 6 @ @ public interface ColumnNameBuilder <nl> public ColumnNameBuilder add ( ByteBuffer bb ) ; <nl> <nl> / * * <nl> - * Add a new ByteBuffer as the next component for this name . <nl> - * @ param t the ByteBuffer to add <nl> - * @ param op the relationship this component should respect . <nl> - * @ throws IllegalStateException if the builder if full , i . e . if enough component has been added . <nl> - * @ return this builder <nl> - * / <nl> - public ColumnNameBuilder add ( ByteBuffer t , Relation . Type op ) ; <nl> - <nl> - / * * <nl> * Returns the number of component already added to this builder . <nl> * @ return the number of component in this Builder <nl> * / <nl> @ @ - 70 , 6 + 61 , 8 @ @ public interface ColumnNameBuilder <nl> * / <nl> public ByteBuffer buildAsEndOfRange ( ) ; <nl> <nl> + public ByteBuffer buildForRelation ( Relation . Type op ) ; <nl> + <nl> / * * <nl> * Clone this builder . <nl> * @ return the cloned builder . <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index 53aebe7 . . 6e7cf1c 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 881 , 6 + 881 , 22 @ @ relation [ List < Relation > clauses ] <nl> { $ clauses . add ( new Relation ( name , Relation . Type . IN , marker ) ) ; } <nl> | name = cident K _ IN { Relation rel = Relation . createInRelation ( $ name . id ) ; } <nl> ' ( ' ( f1 = term { rel . addInValue ( f1 ) ; } ( ' , ' fN = term { rel . addInValue ( fN ) ; } ) * ) ? ' ) ' { $ clauses . add ( rel ) ; } <nl> + | { <nl> + List < ColumnIdentifier > ids = new ArrayList < ColumnIdentifier > ( ) ; <nl> + List < Term . Raw > terms = new ArrayList < Term . Raw > ( ) ; <nl> + } <nl> + ' ( ' n1 = cident { ids . add ( n1 ) ; } ( ' , ' ni = cident { ids . add ( ni ) ; } ) * ' ) ' <nl> + type = relationType <nl> + ' ( ' t1 = term { terms . add ( t1 ) ; } ( ' , ' ti = term { terms . add ( ti ) ; } ) * ' ) ' <nl> + { <nl> + if ( type = = Relation . Type . IN ) <nl> + addRecognitionError ( " Cannot use IN relation with tuple notation " ) ; <nl> + if ( ids . size ( ) ! = terms . size ( ) ) <nl> + addRecognitionError ( String . format ( " Number of values ( " + terms . size ( ) + " ) in tuple notation doesn ' t match the number of column names ( " + ids . size ( ) + " ) " ) ) ; <nl> + else <nl> + for ( int i = 0 ; i < ids . size ( ) ; i + + ) <nl> + $ clauses . add ( new Relation ( ids . get ( i ) , type , terms . get ( i ) , i = = 0 ? null : ids . get ( i - 1 ) ) ) ; <nl> + } <nl> | ' ( ' relation [ $ clauses ] ' ) ' <nl> ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> index 94c6da2 . . 167533f 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> @ @ - 44 , 7 + 44 , 7 @ @ import org . apache . cassandra . utils . SemanticVersion ; <nl> <nl> public class QueryProcessor <nl> { <nl> - public static final SemanticVersion CQL _ VERSION = new SemanticVersion ( " 3 . 1 . 4 " ) ; <nl> + public static final SemanticVersion CQL _ VERSION = new SemanticVersion ( " 3 . 1 . 5 " ) ; <nl> <nl> private static final Logger logger = LoggerFactory . getLogger ( QueryProcessor . class ) ; <nl> private static final MemoryMeter meter = new MemoryMeter ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Relation . java b / src / java / org / apache / cassandra / cql3 / Relation . java <nl> index 15ed540 . . 9d065bf 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Relation . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / Relation . java <nl> @ @ - 33 , 18 + 33 , 22 @ @ public class Relation <nl> private final List < Term . Raw > inValues ; <nl> public final boolean onToken ; <nl> <nl> + / / Will be null unless for tuple notations ( # 4851 ) <nl> + public final ColumnIdentifier previousInTuple ; <nl> + <nl> public static enum Type <nl> { <nl> EQ , LT , LTE , GTE , GT , IN ; <nl> } <nl> <nl> - private Relation ( ColumnIdentifier entity , Type type , Term . Raw value , List < Term . Raw > inValues , boolean onToken ) <nl> + private Relation ( ColumnIdentifier entity , Type type , Term . Raw value , List < Term . Raw > inValues , boolean onToken , ColumnIdentifier previousInTuple ) <nl> { <nl> this . entity = entity ; <nl> this . relationType = type ; <nl> this . value = value ; <nl> this . inValues = inValues ; <nl> this . onToken = onToken ; <nl> + this . previousInTuple = previousInTuple ; <nl> } <nl> <nl> / * * <nl> @ @ - 56 , 17 + 60 , 22 @ @ public class Relation <nl> * / <nl> public Relation ( ColumnIdentifier entity , Type type , Term . Raw value ) <nl> { <nl> - this ( entity , type , value , null , false ) ; <nl> + this ( entity , type , value , null , false , null ) ; <nl> } <nl> <nl> public Relation ( ColumnIdentifier entity , Type type , Term . Raw value , boolean onToken ) <nl> { <nl> - this ( entity , type , value , null , onToken ) ; <nl> + this ( entity , type , value , null , onToken , null ) ; <nl> + } <nl> + <nl> + public Relation ( ColumnIdentifier entity , Type type , Term . Raw value , ColumnIdentifier previousInTuple ) <nl> + { <nl> + this ( entity , type , value , null , false , previousInTuple ) ; <nl> } <nl> <nl> public static Relation createInRelation ( ColumnIdentifier entity ) <nl> { <nl> - return new Relation ( entity , Type . IN , null , new ArrayList < Term . Raw > ( ) , false ) ; <nl> + return new Relation ( entity , Type . IN , null , new ArrayList < Term . Raw > ( ) , false , null ) ; <nl> } <nl> <nl> public Type operator ( ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / Restriction . java b / src / java / org / apache / cassandra / cql3 / statements / Restriction . java <nl> index 3a3aa05 . . 6323acb 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / Restriction . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / Restriction . java <nl> @ @ - 22 , 6 + 22 , 8 @ @ import java . util . ArrayList ; <nl> import java . util . Collections ; <nl> import java . util . List ; <nl> <nl> + import com . google . common . base . Objects ; <nl> + <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . thrift . IndexOperator ; <nl> import org . apache . cassandra . cql3 . * ; <nl> @ @ - 188 , 10 + 190 , 16 @ @ public interface Restriction <nl> private final boolean [ ] boundInclusive ; <nl> private final boolean onToken ; <nl> <nl> + / / The name of the column that was preceding this one if the tuple notation of # 4851 was used <nl> + / / ( note : if it is set for both bound , we ' ll validate both have the same previous value , but we <nl> + / / still need to distinguish if it ' s set or not for both bound ) <nl> + private final ColumnIdentifier [ ] previous ; <nl> + <nl> public Slice ( boolean onToken ) <nl> { <nl> this . bounds = new Term [ 2 ] ; <nl> this . boundInclusive = new boolean [ 2 ] ; <nl> + this . previous = new ColumnIdentifier [ 2 ] ; <nl> this . onToken = onToken ; <nl> } <nl> <nl> @ @ - 259 , 7 + 267 , 7 @ @ public interface Restriction <nl> throw new AssertionError ( ) ; <nl> } <nl> <nl> - public void setBound ( ColumnIdentifier name , Relation . Type type , Term t ) throws InvalidRequestException <nl> + public void setBound ( ColumnIdentifier name , Relation . Type type , Term t , ColumnIdentifier previousName ) throws InvalidRequestException <nl> { <nl> Bound b ; <nl> boolean inclusive ; <nl> @ @ - 290 , 6 + 298 , 20 @ @ public interface Restriction <nl> <nl> bounds [ b . idx ] = t ; <nl> boundInclusive [ b . idx ] = inclusive ; <nl> + <nl> + / / If a bound is part of a tuple notation ( # 4851 ) , the other bound must either also be or must not be set at all , <nl> + / / and this even if there is a 2ndary index ( it ' s not supported by the 2ndary code ) . And it ' s easier to validate <nl> + / / this here so we do . <nl> + Bound reverse = Bound . reverse ( b ) ; <nl> + if ( hasBound ( reverse ) & & ! ( Objects . equal ( previousName , previous [ reverse . idx ] ) ) ) <nl> + throw new InvalidRequestException ( String . format ( " Clustering column % s cannot be restricted both inside a tuple notation and outside it " , name ) ) ; <nl> + <nl> + previous [ b . idx ] = previousName ; <nl> + } <nl> + <nl> + public boolean isPartOfTuple ( ) <nl> + { <nl> + return previous [ Bound . START . idx ] ! = null | | previous [ Bound . END . idx ] ! = null ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 307e668 . . d42fd76 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 667 , 14 + 667 , 16 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> / / to the component comparator but not to the end - of - component itself ) , <nl> / / it only depends on whether the slice is reversed <nl> Bound eocBound = isReversed ? Bound . reverse ( bound ) : bound ; <nl> - for ( CFDefinition . Name name : names ) <nl> + for ( Iterator < CFDefinition . Name > iter = names . iterator ( ) ; iter . hasNext ( ) ; ) <nl> { <nl> + CFDefinition . Name name = iter . next ( ) ; <nl> + <nl> / / In a restriction , we always have Bound . START < Bound . END for the " base " comparator . <nl> / / So if we ' re doing a reverse slice , we must inverse the bounds when giving them as start and end of the slice filter . <nl> / / But if the actual comparator itself is reversed , we must inversed the bounds too . <nl> Bound b = isReversed = = isReversedType ( name ) ? bound : Bound . reverse ( bound ) ; <nl> Restriction r = restrictions [ name . position ] ; <nl> - if ( r = = null | | ( r . isSlice ( ) & & ! ( ( Restriction . Slice ) r ) . hasBound ( b ) ) ) <nl> + if ( isNullRestriction ( r , b ) ) <nl> { <nl> / / There wasn ' t any non EQ relation on that key , we select all records having the preceding component as prefix . <nl> / / For composites , if there was preceding component and we ' re computing the end , we must change the last component <nl> @ @ - 686 , 12 + 688 , 21 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> <nl> if ( r . isSlice ( ) ) <nl> { <nl> - Restriction . Slice slice = ( Restriction . Slice ) r ; <nl> - assert slice . hasBound ( b ) ; <nl> - ByteBuffer val = slice . bound ( b , variables ) ; <nl> - if ( val = = null ) <nl> - throw new InvalidRequestException ( String . format ( " Invalid null clustering key part % s " , name ) ) ; <nl> - return Collections . singletonList ( builder . add ( val , slice . getRelation ( eocBound , b ) ) . build ( ) ) ; <nl> + builder . add ( getSliceValue ( name , r , b , variables ) ) ; <nl> + Relation . Type relType = ( ( Restriction . Slice ) r ) . getRelation ( eocBound , b ) ; <nl> + <nl> + / / We can have more non null restriction if the " scalar " notation was used for the bound
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 571b8dd . . fd3b1b7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * Stop CommitLogSegment . close ( ) from calling sync ( ) ( CASSANDRA - 6652 ) 
 * Make commitlog failure handling configurable ( CASSANDRA - 6364 ) 
 * Avoid overlaps in LCS ( CASSANDRA - 6688 ) 
 + * improve support for paginating over composites ( 4851 ) 
 Merged from 1 . 2 : 
 * Fix broken streams when replacing with same IP ( CASSANDRA - 6622 ) 
 * Fix upgradesstables NPE for non - CF - based indexes ( CASSANDRA - 6645 ) 
 diff - - git a / doc / cql3 / CQL . textile b / doc / cql3 / CQL . textile 
 index f82fc19 . . 03b95e0 100644 
 - - - a / doc / cql3 / CQL . textile 
 + + + b / doc / cql3 / CQL . textile 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 < link rel = " StyleSheet " href = " CQL . css " type = " text / css " media = " screen " > 
 
 - h1 . Cassandra Query Language ( CQL ) v3 . 1 . 4 
 + h1 . Cassandra Query Language ( CQL ) v3 . 1 . 5 
 
 
 < span id = " tableOfContents " > 
 @ @ - 619 , 10 + 619 , 12 @ @ bc ( syntax ) . . 
 
 < where - clause > : : = < relation > ( AND < relation > ) * 
 
 - < relation > : : = < identifier > ( ' = ' | ' < ' | ' > ' | ' < = ' | ' > = ' ) < term > 
 + < relation > : : = < identifier > < op > < term > 
 + | ' ( ' < identifier > ( ' , ' < identifier > ) * ' ) ' < op > ' ( ' < term > ( ' , ' < term > ) * ' ) ' 
 | < identifier > IN ' ( ' ( < term > ( ' , ' < term > ) * ) ? ' ) ' 
 - | TOKEN ' ( ' < identifier > ( ' , ' < identifer > ) * ' ) ' ( ' = ' | ' < ' | ' > ' | ' < = ' | ' > = ' ) < term > 
 + | TOKEN ' ( ' < identifier > ( ' , ' < identifer > ) * ' ) ' < op > < term > 
 
 + < op > : : = ' = ' | ' < ' | ' > ' | ' < = ' | ' > = ' 
 < order - by > : : = < ordering > ( ' , ' < odering > ) * 
 < ordering > : : = < identifer > ( ASC | DESC ) ? 
 p . 
 @ @ - 676 , 7 + 678 , 7 @ @ CREATE TABLE posts ( 
 The following query is allowed : 
 
 bc ( sample ) . 
 - SELECT entry _ title , content FROM posts WHERE userid = ' john doe ' AND blog _ title = ' John ' s Blog ' AND posted _ at > = ' 2012 - 01 - 01 ' AND posted _ at < ' 2012 - 01 - 31 ' 
 + SELECT entry _ title , content FROM posts WHERE userid = ' john doe ' AND blog _ title = ' John ' ' s Blog ' AND posted _ at > = ' 2012 - 01 - 01 ' AND posted _ at < ' 2012 - 01 - 31 ' 
 
 But the following one is not , as it does not select a contiguous set of rows ( and we suppose no secondary indexes are set ) : 
 
 @ @ - 691 , 6 + 693 , 16 @ @ SELECT * FROM posts WHERE token ( userid ) > token ( ' tom ' ) AND token ( userid ) < token 
 
 Moreover , the @ IN @ relation is only allowed on the last column of the partition key and on the last column of the full primary key . 
 
 + It is also possible to " group " @ CLUSTERING COLUMNS @ together in a relation , for instance : 
 + 
 + bc ( sample ) . 
 + SELECT * FROM posts WHERE userid = ' john doe ' AND ( blog _ title , posted _ at ) > ( ' John ' ' s Blog ' , ' 2012 - 01 - 01 ' ) 
 + 
 + will request all rows that sorts after the one having " John ' s Blog " as @ blog _ tile @ and ' 2012 - 01 - 01 ' for @ posted _ at @ in the clustering order . In particular , rows having a @ post _ at < = ' 2012 - 01 - 01 ' @ will be returned as long as their @ blog _ title > ' John ' ' s Blog ' @ , which wouldn ' t be the case for : 
 + 
 + bc ( sample ) . 
 + SELECT * FROM posts WHERE userid = ' john doe ' AND blog _ title > ' John ' ' s Blog ' AND posted _ at > ' 2012 - 01 - 01 ' 
 + 
 h4 ( # selectOrderBy ) . @ < order - by > @ 
 
 The @ ORDER BY @ option allows to select the order of the returned results . It takes as argument a list of column names along with the order for the column ( @ ASC @ for ascendant and @ DESC @ for descendant , omitting the order being equivalent to @ ASC @ ) . Currently the possible orderings are limited ( which depends on the table " @ CLUSTERING ORDER @ " : # createTableOptions ) : 
 @ @ - 1101 , 6 + 1113 , 10 @ @ h2 ( # changes ) . Changes 
 
 The following describes the addition / changes brought for each version of CQL . 
 
 + h3 . 3 . 1 . 5 
 + 
 + * It is now possible to group clustering columns in a relatiion , see " SELECT Where clauses " : # selectWhere . 
 + 
 h3 . 3 . 1 . 4 
 
 * @ CREATE INDEX @ now allows specifying options when creating CUSTOM indexes ( see " CREATE INDEX reference " : # createIndexStmt ) . 
 diff - - git a / src / java / org / apache / cassandra / cql3 / CFDefinition . java b / src / java / org / apache / cassandra / cql3 / CFDefinition . java 
 index 54ca2b8 . . 638770d 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / CFDefinition . java 
 + + + b / src / java / org / apache / cassandra / cql3 / CFDefinition . java 
 @ @ - 246 , 11 + 246 , 6 @ @ public class CFDefinition implements Iterable < CFDefinition . Name > 
 return this ; 
 } 
 
 - public NonCompositeBuilder add ( ByteBuffer bb , Relation . Type op ) 
 - { 
 - return add ( bb ) ; 
 - } 
 - 
 public int componentCount ( ) 
 { 
 return columnName = = null ? 0 : 1 ; 
 @ @ - 279 , 6 + 274 , 11 @ @ public class CFDefinition implements Iterable < CFDefinition . Name > 
 return build ( ) ; 
 } 
 
 + public ByteBuffer buildForRelation ( Relation . Type op ) 
 + { 
 + return build ( ) ; 
 + } 
 + 
 public NonCompositeBuilder copy ( ) 
 { 
 NonCompositeBuilder newBuilder = new NonCompositeBuilder ( type ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / ColumnNameBuilder . java b / src / java / org / apache / cassandra / cql3 / ColumnNameBuilder . java 
 index b6625ab . . 3d5eff6 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / ColumnNameBuilder . java 
 + + + b / src / java / org / apache / cassandra / cql3 / ColumnNameBuilder . java 
 @ @ - 33 , 15 + 33 , 6 @ @ public interface ColumnNameBuilder 
 public ColumnNameBuilder add ( ByteBuffer bb ) ; 
 
 / * * 
 - * Add a new ByteBuffer as the next component for this name . 
 - * @ param t the ByteBuffer to add 
 - * @ param op the relationship this component should respect . 
 - * @ throws IllegalStateException if the builder if full , i . e . if enough component has been added . 
 - * @ return this builder 
 - * / 
 - public ColumnNameBuilder add ( ByteBuffer t , Relation . Type op ) ; 
 - 
 - / * * 
 * Returns the number of component already added to this builder . 
 * @ return the number of component in this Builder 
 * / 
 @ @ - 70 , 6 + 61 , 8 @ @ public interface ColumnNameBuilder 
 * / 
 public ByteBuffer buildAsEndOfRange ( ) ; 
 
 + public ByteBuffer buildForRelation ( Relation . Type op ) ; 
 + 
 / * * 
 * Clone this builder . 
 * @ return the cloned builder . 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index 53aebe7 . . 6e7cf1c 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 881 , 6 + 881 , 22 @ @ relation [ List < Relation > clauses ] 
 { $ clauses . add ( new Relation ( name , Relation . Type . IN , marker ) ) ; } 
 | name = cident K _ IN { Relation rel = Relation . createInRelation ( $ name . id ) ; } 
 ' ( ' ( f1 = term { rel . addInValue ( f1 ) ; } ( ' , ' fN = term { rel . addInValue ( fN ) ; } ) * ) ? ' ) ' { $ clauses . add ( rel ) ; } 
 + | { 
 + List < ColumnIdentifier > ids = new ArrayList < ColumnIdentifier > ( ) ; 
 + List < Term . Raw > terms = new ArrayList < Term . Raw > ( ) ; 
 + } 
 + ' ( ' n1 = cident { ids . add ( n1 ) ; } ( ' , ' ni = cident { ids . add ( ni ) ; } ) * ' ) ' 
 + type = relationType 
 + ' ( ' t1 = term { terms . add ( t1 ) ; } ( ' , ' ti = term { terms . add ( ti ) ; } ) * ' ) ' 
 + { 
 + if ( type = = Relation . Type . IN ) 
 + addRecognitionError ( " Cannot use IN relation with tuple notation " ) ; 
 + if ( ids . size ( ) ! = terms . size ( ) ) 
 + addRecognitionError ( String . format ( " Number of values ( " + terms . size ( ) + " ) in tuple notation doesn ' t match the number of column names ( " + ids . size ( ) + " ) " ) ) ; 
 + else 
 + for ( int i = 0 ; i < ids . size ( ) ; i + + ) 
 + $ clauses . add ( new Relation ( ids . get ( i ) , type , terms . get ( i ) , i = = 0 ? null : ids . get ( i - 1 ) ) ) ; 
 + } 
 | ' ( ' relation [ $ clauses ] ' ) ' 
 ; 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 index 94c6da2 . . 167533f 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 @ @ - 44 , 7 + 44 , 7 @ @ import org . apache . cassandra . utils . SemanticVersion ; 
 
 public class QueryProcessor 
 { 
 - public static final SemanticVersion CQL _ VERSION = new SemanticVersion ( " 3 . 1 . 4 " ) ; 
 + public static final SemanticVersion CQL _ VERSION = new SemanticVersion ( " 3 . 1 . 5 " ) ; 
 
 private static final Logger logger = LoggerFactory . getLogger ( QueryProcessor . class ) ; 
 private static final MemoryMeter meter = new MemoryMeter ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Relation . java b / src / java / org / apache / cassandra / cql3 / Relation . java 
 index 15ed540 . . 9d065bf 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Relation . java 
 + + + b / src / java / org / apache / cassandra / cql3 / Relation . java 
 @ @ - 33 , 18 + 33 , 22 @ @ public class Relation 
 private final List < Term . Raw > inValues ; 
 public final boolean onToken ; 
 
 + / / Will be null unless for tuple notations ( # 4851 ) 
 + public final ColumnIdentifier previousInTuple ; 
 + 
 public static enum Type 
 { 
 EQ , LT , LTE , GTE , GT , IN ; 
 } 
 
 - private Relation ( ColumnIdentifier entity , Type type , Term . Raw value , List < Term . Raw > inValues , boolean onToken ) 
 + private Relation ( ColumnIdentifier entity , Type type , Term . Raw value , List < Term . Raw > inValues , boolean onToken , ColumnIdentifier previousInTuple ) 
 { 
 this . entity = entity ; 
 this . relationType = type ; 
 this . value = value ; 
 this . inValues = inValues ; 
 this . onToken = onToken ; 
 + this . previousInTuple = previousInTuple ; 
 } 
 
 / * * 
 @ @ - 56 , 17 + 60 , 22 @ @ public class Relation 
 * / 
 public Relation ( ColumnIdentifier entity , Type type , Term . Raw value ) 
 { 
 - this ( entity , type , value , null , false ) ; 
 + this ( entity , type , value , null , false , null ) ; 
 } 
 
 public Relation ( ColumnIdentifier entity , Type type , Term . Raw value , boolean onToken ) 
 { 
 - this ( entity , type , value , null , onToken ) ; 
 + this ( entity , type , value , null , onToken , null ) ; 
 + } 
 + 
 + public Relation ( ColumnIdentifier entity , Type type , Term . Raw value , ColumnIdentifier previousInTuple ) 
 + { 
 + this ( entity , type , value , null , false , previousInTuple ) ; 
 } 
 
 public static Relation createInRelation ( ColumnIdentifier entity ) 
 { 
 - return new Relation ( entity , Type . IN , null , new ArrayList < Term . Raw > ( ) , false ) ; 
 + return new Relation ( entity , Type . IN , null , new ArrayList < Term . Raw > ( ) , false , null ) ; 
 } 
 
 public Type operator ( ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / Restriction . java b / src / java / org / apache / cassandra / cql3 / statements / Restriction . java 
 index 3a3aa05 . . 6323acb 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / Restriction . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / Restriction . java 
 @ @ - 22 , 6 + 22 , 8 @ @ import java . util . ArrayList ; 
 import java . util . Collections ; 
 import java . util . List ; 
 
 + import com . google . common . base . Objects ; 
 + 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . thrift . IndexOperator ; 
 import org . apache . cassandra . cql3 . * ; 
 @ @ - 188 , 10 + 190 , 16 @ @ public interface Restriction 
 private final boolean [ ] boundInclusive ; 
 private final boolean onToken ; 
 
 + / / The name of the column that was preceding this one if the tuple notation of # 4851 was used 
 + / / ( note : if it is set for both bound , we ' ll validate both have the same previous value , but we 
 + / / still need to distinguish if it ' s set or not for both bound ) 
 + private final ColumnIdentifier [ ] previous ; 
 + 
 public Slice ( boolean onToken ) 
 { 
 this . bounds = new Term [ 2 ] ; 
 this . boundInclusive = new boolean [ 2 ] ; 
 + this . previous = new ColumnIdentifier [ 2 ] ; 
 this . onToken = onToken ; 
 } 
 
 @ @ - 259 , 7 + 267 , 7 @ @ public interface Restriction 
 throw new AssertionError ( ) ; 
 } 
 
 - public void setBound ( ColumnIdentifier name , Relation . Type type , Term t ) throws InvalidRequestException 
 + public void setBound ( ColumnIdentifier name , Relation . Type type , Term t , ColumnIdentifier previousName ) throws InvalidRequestException 
 { 
 Bound b ; 
 boolean inclusive ; 
 @ @ - 290 , 6 + 298 , 20 @ @ public interface Restriction 
 
 bounds [ b . idx ] = t ; 
 boundInclusive [ b . idx ] = inclusive ; 
 + 
 + / / If a bound is part of a tuple notation ( # 4851 ) , the other bound must either also be or must not be set at all , 
 + / / and this even if there is a 2ndary index ( it ' s not supported by the 2ndary code ) . And it ' s easier to validate 
 + / / this here so we do . 
 + Bound reverse = Bound . reverse ( b ) ; 
 + if ( hasBound ( reverse ) & & ! ( Objects . equal ( previousName , previous [ reverse . idx ] ) ) ) 
 + throw new InvalidRequestException ( String . format ( " Clustering column % s cannot be restricted both inside a tuple notation and outside it " , name ) ) ; 
 + 
 + previous [ b . idx ] = previousName ; 
 + } 
 + 
 + public boolean isPartOfTuple ( ) 
 + { 
 + return previous [ Bound . START . idx ] ! = null | | previous [ Bound . END . idx ] ! = null ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 307e668 . . d42fd76 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 667 , 14 + 667 , 16 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 / / to the component comparator but not to the end - of - component itself ) , 
 / / it only depends on whether the slice is reversed 
 Bound eocBound = isReversed ? Bound . reverse ( bound ) : bound ; 
 - for ( CFDefinition . Name name : names ) 
 + for ( Iterator < CFDefinition . Name > iter = names . iterator ( ) ; iter . hasNext ( ) ; ) 
 { 
 + CFDefinition . Name name = iter . next ( ) ; 
 + 
 / / In a restriction , we always have Bound . START < Bound . END for the " base " comparator . 
 / / So if we ' re doing a reverse slice , we must inverse the bounds when giving them as start and end of the slice filter . 
 / / But if the actual comparator itself is reversed , we must inversed the bounds too . 
 Bound b = isReversed = = isReversedType ( name ) ? bound : Bound . reverse ( bound ) ; 
 Restriction r = restrictions [ name . position ] ; 
 - if ( r = = null | | ( r . isSlice ( ) & & ! ( ( Restriction . Slice ) r ) . hasBound ( b ) ) ) 
 + if ( isNullRestriction ( r , b ) ) 
 { 
 / / There wasn ' t any non EQ relation on that key , we select all records having the preceding component as prefix . 
 / / For composites , if there was preceding component and we ' re computing the end , we must change the last component 
 @ @ - 686 , 12 + 688 , 21 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 
 if ( r . isSlice ( ) ) 
 { 
 - Restriction . Slice slice = ( Restriction . Slice ) r ; 
 - assert slice . hasBound ( b ) ; 
 - ByteBuffer val = slice . bound ( b , variables ) ; 
 - if ( val = = null ) 
 - throw new InvalidRequestException ( String . format ( " Invalid null clustering key part % s " , name ) ) ; 
 - return Collections . singletonList ( builder . add ( val , slice . getRelation ( eocBound , b ) ) . build ( ) ) ; 
 + builder . add ( getSliceValue ( name , r , b , variables ) ) ; 
 + Relation . Type relType = ( ( Restriction . Slice ) r ) . getRelation ( eocBound , b ) ; 
 + 
 + / / We can have more non null restriction if the " scalar " notation was used for the bound

NEAREST DIFF:
ELIMINATEDSENTENCE
