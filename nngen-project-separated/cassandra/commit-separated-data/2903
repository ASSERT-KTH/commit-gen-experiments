BLEU SCORE: 0.02931251013275449

TEST MSG: merge from 2 . 0
GENERATED MSG: cqlsh : look for cqlshlib relative to realpath

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 8d11a0a . . 81ba65a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 16 , 6 + 16 , 8 @ @ <nl> <nl> <nl> 2 . 0 . 4 <nl> + * Allow specifying datacenters to participate in a repair ( CASSANDRA - 6218 ) <nl> + * Fix divide - by - zero in PCI ( CASSANDRA - 6403 ) <nl> * Fix setting last compacted key in the wrong level for LCS ( CASSANDRA - 6284 ) <nl> * Add sub - ms precision formats to the timestamp parser ( CASSANDRA - 6395 ) <nl> * Add snapshot space used to cfstats ( CASSANDRA - 6231 ) <nl> diff - - git a / src / java / org / apache / cassandra / repair / RepairSession . java b / src / java / org / apache / cassandra / repair / RepairSession . java <nl> index d89cc27 . . 3933a88 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / RepairSession . java <nl> + + + b / src / java / org / apache / cassandra / repair / RepairSession . java <nl> @ @ - 102 , 15 + 102 , 15 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan <nl> * @ param range range to repair <nl> * @ param keyspace name of keyspace <nl> * @ param isSequential true if performing repair on snapshots sequentially <nl> - * @ param isLocal true if you want to perform repair only inside the data center <nl> + * @ param dataCenters the data centers that should be part of the repair ; null for all DCs <nl> * @ param cfnames names of columnfamilies <nl> * / <nl> - public RepairSession ( Range < Token > range , String keyspace , boolean isSequential , boolean isLocal , String . . . cfnames ) <nl> + public RepairSession ( Range < Token > range , String keyspace , boolean isSequential , Collection < String > dataCenters , String . . . cfnames ) <nl> { <nl> - this ( UUIDGen . getTimeUUID ( ) , range , keyspace , isSequential , isLocal , cfnames ) ; <nl> + this ( UUIDGen . getTimeUUID ( ) , range , keyspace , isSequential , dataCenters , cfnames ) ; <nl> } <nl> <nl> - public RepairSession ( UUID id , Range < Token > range , String keyspace , boolean isSequential , boolean isLocal , String [ ] cfnames ) <nl> + public RepairSession ( UUID id , Range < Token > range , String keyspace , boolean isSequential , Collection < String > dataCenters , String [ ] cfnames ) <nl> { <nl> this . id = id ; <nl> this . isSequential = isSequential ; <nl> @ @ - 118 , 7 + 118 , 7 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan <nl> this . cfnames = cfnames ; <nl> assert cfnames . length > 0 : " Repairing no column families seems pointless , doesn ' t it " ; <nl> this . range = range ; <nl> - this . endpoints = ActiveRepairService . getNeighbors ( keyspace , range , isLocal ) ; <nl> + this . endpoints = ActiveRepairService . getNeighbors ( keyspace , range , dataCenters ) ; <nl> } <nl> <nl> public UUID getId ( ) <nl> diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> index 2f16b31 . . b77f216 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ import java . net . InetAddress ; <nl> import java . util . * ; <nl> import java . util . concurrent . * ; <nl> <nl> + import com . google . common . collect . Multimap ; <nl> import com . google . common . collect . Sets ; <nl> <nl> import org . apache . cassandra . concurrent . JMXConfigurableThreadPoolExecutor ; <nl> @ @ - 90 , 9 + 91 , 9 @ @ public class ActiveRepairService <nl> * <nl> * @ return Future for asynchronous call or null if there is no need to repair <nl> * / <nl> - public RepairFuture submitRepairSession ( Range < Token > range , String keyspace , boolean isSequential , boolean isLocal , String . . . cfnames ) <nl> + public RepairFuture submitRepairSession ( Range < Token > range , String keyspace , boolean isSequential , Collection < String > dataCenters , String . . . cfnames ) <nl> { <nl> - RepairSession session = new RepairSession ( range , keyspace , isSequential , isLocal , cfnames ) ; <nl> + RepairSession session = new RepairSession ( range , keyspace , isSequential , dataCenters , cfnames ) ; <nl> if ( session . endpoints . isEmpty ( ) ) <nl> return null ; <nl> RepairFuture futureTask = new RepairFuture ( session ) ; <nl> @ @ - 126 , 7 + 127 , 7 @ @ public class ActiveRepairService <nl> / / add it to the sessions ( avoid NPE in tests ) <nl> RepairFuture submitArtificialRepairSession ( RepairJobDesc desc ) <nl> { <nl> - RepairSession session = new RepairSession ( desc . sessionId , desc . range , desc . keyspace , false , false , new String [ ] { desc . columnFamily } ) ; <nl> + RepairSession session = new RepairSession ( desc . sessionId , desc . range , desc . keyspace , false , null , new String [ ] { desc . columnFamily } ) ; <nl> sessions . put ( session . getId ( ) , session ) ; <nl> RepairFuture futureTask = new RepairFuture ( session ) ; <nl> executor . execute ( futureTask ) ; <nl> @ @ - 138 , 12 + 139 , 15 @ @ public class ActiveRepairService <nl> * <nl> * @ param keyspaceName keyspace to repair <nl> * @ param toRepair token to repair <nl> - * @ param isLocal need to use only nodes from local datacenter <nl> + * @ param dataCenters the data centers to involve in the repair <nl> * <nl> * @ return neighbors with whom we share the provided range <nl> * / <nl> - public static Set < InetAddress > getNeighbors ( String keyspaceName , Range < Token > toRepair , boolean isLocal ) <nl> + public static Set < InetAddress > getNeighbors ( String keyspaceName , Range < Token > toRepair , Collection < String > dataCenters ) <nl> { <nl> + if ( dataCenters ! = null & & ! dataCenters . contains ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) <nl> + throw new IllegalArgumentException ( " The local data center must be part of the repair " ) ; <nl> + <nl> StorageService ss = StorageService . instance ; <nl> Map < Range < Token > , List < InetAddress > > replicaSets = ss . getRangeToAddressMap ( keyspaceName ) ; <nl> Range < Token > rangeSuperSet = null ; <nl> @ @ - 165 , 11 + 169 , 18 @ @ public class ActiveRepairService <nl> Set < InetAddress > neighbors = new HashSet < > ( replicaSets . get ( rangeSuperSet ) ) ; <nl> neighbors . remove ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> <nl> - if ( isLocal ) <nl> + if ( dataCenters ! = null ) <nl> { <nl> TokenMetadata . Topology topology = ss . getTokenMetadata ( ) . cloneOnlyTokenMap ( ) . getTopology ( ) ; <nl> - Set < InetAddress > localEndpoints = Sets . newHashSet ( topology . getDatacenterEndpoints ( ) . get ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) ; <nl> - return Sets . intersection ( neighbors , localEndpoints ) ; <nl> + Set < InetAddress > dcEndpoints = Sets . newHashSet ( ) ; <nl> + Multimap < String , InetAddress > dcEndpointsMap = topology . getDatacenterEndpoints ( ) ; <nl> + for ( String dc : dataCenters ) <nl> + { <nl> + Collection < InetAddress > c = dcEndpointsMap . get ( dc ) ; <nl> + if ( c ! = null ) <nl> + dcEndpoints . addAll ( c ) ; <nl> + } <nl> + return Sets . intersection ( neighbors , dcEndpoints ) ; <nl> } <nl> <nl> return neighbors ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 3107b96 . . dc11427 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 2250 , 6 + 2250 , 26 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> jmxNotification . setUserData ( userObject ) ; <nl> sendNotification ( jmxNotification ) ; <nl> } <nl> + <nl> + public int forceRepairAsync ( final String keyspace , final boolean isSequential , final Collection < String > dataCenters , final boolean primaryRange , final String . . . columnFamilies ) <nl> + { <nl> + final Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; <nl> + return forceRepairAsync ( keyspace , isSequential , dataCenters , ranges , columnFamilies ) ; <nl> + } <nl> + <nl> + public int forceRepairAsync ( final String keyspace , final boolean isSequential , final Collection < String > dataCenters , final Collection < Range < Token > > ranges , final String . . . columnFamilies ) <nl> + { <nl> + if ( Keyspace . SYSTEM _ KS . equals ( keyspace ) | | ranges . isEmpty ( ) ) <nl> + return 0 ; <nl> + <nl> + final int cmd = nextRepairCommand . incrementAndGet ( ) ; <nl> + if ( ranges . size ( ) > 0 ) <nl> + { <nl> + new Thread ( createRepairTask ( cmd , keyspace , ranges , isSequential , dataCenters , columnFamilies ) ) . start ( ) ; <nl> + } <nl> + return cmd ; <nl> + } <nl> + <nl> public int forceRepairAsync ( final String keyspace , final boolean isSequential , final boolean isLocal , final boolean primaryRange , final String . . . columnFamilies ) <nl> { <nl> final Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; <nl> @ @ - 2269 , 6 + 2289 , 16 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return cmd ; <nl> } <nl> <nl> + public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , final String . . . columnFamilies ) <nl> + { <nl> + Token parsedBeginToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( beginToken ) ; <nl> + Token parsedEndToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( endToken ) ; <nl> + <nl> + logger . info ( " starting user - requested repair of range ( { } , { } ] for keyspace { } and column families { } " , <nl> + parsedBeginToken , parsedEndToken , keyspaceName , columnFamilies ) ; <nl> + return forceRepairAsync ( keyspaceName , isSequential , dataCenters , Collections . singleton ( new Range < Token > ( parsedBeginToken , parsedEndToken ) ) , columnFamilies ) ; <nl> + } <nl> + <nl> public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , boolean isLocal , final String . . . columnFamilies ) <nl> { <nl> Token parsedBeginToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( beginToken ) ; <nl> @ @ - 2315 , 6 + 2345 , 16 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private FutureTask < Object > createRepairTask ( final int cmd , final String keyspace , final Collection < Range < Token > > ranges , final boolean isSequential , final boolean isLocal , final String . . . columnFamilies ) <nl> { <nl> + Set < String > dataCenters = null ; <nl> + if ( isLocal ) <nl> + { <nl> + dataCenters = Sets . newHashSet ( DatabaseDescriptor . getLocalDataCenter ( ) ) ; <nl> + } <nl> + return createRepairTask ( cmd , keyspace , ranges , isSequential , dataCenters , columnFamilies ) ; <nl> + } <nl> + <nl> + private FutureTask < Object > createRepairTask ( final int cmd , final String keyspace , final Collection < Range < Token > > ranges , final boolean isSequential , final Collection < String > dataCenters , final String . . . columnFamilies ) <nl> + { <nl> return new FutureTask < Object > ( new WrappedRunnable ( ) <nl> { <nl> protected void runMayThrow ( ) throws Exception <nl> @ @ - 2323 , 13 + 2363 , 21 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> logger . info ( message ) ; <nl> sendNotification ( " repair " , message , new int [ ] { cmd , ActiveRepairService . Status . STARTED . ordinal ( ) } ) ; <nl> <nl> + if ( dataCenters ! = null & & ! dataCenters . contains ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) <nl> + { <nl> + message = String . format ( " Cancelling repair command # % d ( the local data center must be part of the repair ) " , cmd ) ; <nl> + logger . error ( message ) ; <nl> + sendNotification ( " repair " , message , new int [ ] { cmd , ActiveRepairService . Status . FINISHED . ordinal ( ) } ) ; <nl> + return ; <nl> + } <nl> + <nl> List < RepairFuture > futures = new ArrayList < RepairFuture > ( ranges . size ( ) ) ; <nl> for ( Range < Token > range : ranges ) <nl> { <nl> RepairFuture future ; <nl> try <nl> { <nl> - future = forceKeyspaceRepair ( range , keyspace , isSequential , isLocal , columnFamilies ) ; <nl> + future = forceKeyspaceRepair ( range , keyspace , isSequential , dataCenters , columnFamilies ) ; <nl> } <nl> catch ( IllegalArgumentException e ) <nl> { <nl> @ @ - 2379 , 7 + 2427 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } , null ) ; <nl> } <nl> <nl> - public RepairFuture forceKeyspaceRepair ( final Range < Token > range , final String keyspaceName , boolean isSequential , boolean isLocal , final String . . . columnFamilies ) throws IOException <nl> + public RepairFuture forceKeyspaceRepair ( final Range < Token > range , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , final String . . . columnFamilies ) throws IOException <nl> { <nl> ArrayList < String > names = new ArrayList < String > ( ) ; <nl> for ( ColumnFamilyStore cfStore : getValidColumnFamilies ( false , false , keyspaceName , columnFamilies ) ) <nl> @ @ - 2393 , 7 + 2441 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return null ; <nl> } <nl> <nl> - return ActiveRepairService . instance . submitRepairSession ( range , keyspaceName , isSequential , isLocal , names . toArray ( new String [ names . size ( ) ] ) ) ; <nl> + return ActiveRepairService . instance . submitRepairSession ( range , keyspaceName , isSequential , dataCenters , names . toArray ( new String [ names . size ( ) ] ) ) ; <nl> } <nl> <nl> public void forceTerminateAllRepairSessions ( ) { <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> index 8edadee . . 8da215b 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> @ @ - 256 , 6 + 256 , 23 @ @ public interface StorageServiceMBean extends NotificationEmitter <nl> * userObject : int array of length 2 , [ 0 ] = command number , [ 1 ] = ordinal of AntiEntropyService . Status <nl> * <nl> * @ return Repair command number , or 0 if nothing to repair <nl> + * / <nl> + public int forceRepairAsync ( String keyspace , boolean isSequential , Collection < String > dataCenters , boolean primaryRange , String . . . columnFamilies ) ; <nl> + <nl> + / * * <nl> + * Same as forceRepairAsync , but handles a specified range <nl> + * / <nl> + public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , final String . . . columnFamilies ) ; <nl> + <nl> + <nl> + / * * <nl> + * Invoke repair asynchronously . <nl> + * You can track repair progress by subscribing JMX notification sent from this StorageServiceMBean . <nl> + * Notification format is : <nl> + * type : " repair " <nl> + * userObject : int array of length 2 , [ 0 ] = command number , [ 1 ] = ordinal of AntiEntropyService . Status <nl> + * <nl> + * @ return Repair command number , or 0 if nothing to repair <nl> * @ see # forceKeyspaceRepair ( String , boolean , boolean , String . . . ) <nl> * / <nl> public int forceRepairAsync ( String keyspace , boolean isSequential , boolean isLocal , boolean primaryRange , String . . . columnFamilies ) ; <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index a6c0010 . . bb92502 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 68 , 6 + 68 , 7 @ @ public class NodeCmd <nl> private static final Pair < String , String > PRIMARY _ RANGE _ OPT = Pair . create ( " pr " , " partitioner - range " ) ; <nl> private static final Pair < String , String > PARALLEL _ REPAIR _ OPT = Pair . create ( " par " , " parallel " ) ; <nl> private static final Pair < String , String > LOCAL _ DC _ REPAIR _ OPT = Pair . create ( " local " , " in - local - dc " ) ; <nl> + private static final Pair < String , String > DC _ REPAIR _ OPT = Pair . create ( " dc " , " in - dc " ) ; <nl> private static final Pair < String , String > START _ TOKEN _ OPT = Pair . create ( " st " , " start - token " ) ; <nl> private static final Pair < String , String > END _ TOKEN _ OPT = Pair . create ( " et " , " end - token " ) ; <nl> private static final Pair < String , String > UPGRADE _ ALL _ SSTABLE _ OPT = Pair . create ( " a " , " include - all - sstables " ) ; <nl> @ @ - 93 , 6 + 94 , 7 @ @ public class NodeCmd <nl> options . addOption ( PRIMARY _ RANGE _ OPT , false , " only repair the first range returned by the partitioner for the node " ) ; <nl> options . addOption ( PARALLEL _ REPAIR _ OPT , false , " repair nodes in parallel . " ) ; <nl> options . addOption ( LOCAL _ DC _ REPAIR _ OPT , false , " only repair against nodes in the same datacenter " ) ; <nl> + options . addOption ( DC _ REPAIR _ OPT , true , " only repair against nodes in the specified datacenters ( comma separated ) " ) ; <nl> options . addOption ( START _ TOKEN _ OPT , true , " token at which repair range starts " ) ; <nl> options . addOption ( END _ TOKEN _ OPT , true , " token at which repair range ends " ) ; <nl> options . addOption ( UPGRADE _ ALL _ SSTABLE _ OPT , false , " includes sstables that are already on the most recent version during upgradesstables " ) ; <nl> @ @ - 1510 , 11 + 1512 , 17 @ @ public class NodeCmd <nl> case REPAIR : <nl> boolean sequential = ! cmd . hasOption ( PARALLEL _ REPAIR _ OPT . left ) ; <nl> boolean localDC = cmd . hasOption ( LOCAL _ DC _ REPAIR _ OPT . left ) ; <nl> + boolean specificDC = cmd . hasOption ( DC _ REPAIR _ OPT . left ) ; <nl> boolean primaryRange = cmd . hasOption ( PRIMARY _ RANGE _ OPT . left ) ; <nl> + Collection < String > dataCenters = null ; <nl> + if ( specificDC ) <nl> + dataCenters = Arrays . asList ( cmd . getOptionValue ( DC _ REPAIR _ OPT . left ) . split ( " , " ) ) ; <nl> + else if ( localDC ) <nl> + dataCenters = Arrays . asList ( probe . getDataCenter ( ) ) ; <nl> if ( cmd . hasOption ( START _ TOKEN _ OPT . left ) | | cmd . hasOption ( END _ TOKEN _ OPT . left ) ) <nl> - probe . forceRepairRangeAsync ( System . out , keyspace , sequential , localDC , cmd . getOptionValue ( START _ TOKEN _ OPT . left ) , cmd . getOptionValue ( END _ TOKEN _ OPT . left ) , columnFamilies ) ; <nl> + probe . forceRepairRangeAsync ( System . out , keyspace , sequential , dataCenters , cmd . getOptionValue ( START _ TOKEN _ OPT . left ) , cmd . getOptionValue ( END _ TOKEN _ OPT . left ) , columnFamilies ) ; <nl> else <nl> - probe . forceRepairAsync ( System . out , keyspace , sequential , localDC , primaryRange , columnFamilies ) ; <nl> + probe . forceRepairAsync ( System . out , keyspace , sequential , dataCenters , primaryRange , columnFamilies ) ; <nl> break ; <nl> case FLUSH : <nl> try { probe . forceKeyspaceFlush ( keyspace , columnFamilies ) ; } <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> index b755ff3 . . 790862b 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 216 , 14 + 216 , 14 @ @ public class NodeProbe <nl> ssProxy . forceKeyspaceRepair ( keyspaceName , isSequential , isLocal , columnFamilies ) ; <nl> } <nl> <nl> - public void forceRepairAsync ( final PrintStream out , final String keyspaceName , boolean isSequential , boolean isLocal , boolean primaryRange , String . . . columnFamilies ) throws IOException <nl> + public void forceRepairAsync ( final PrintStream out , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , boolean primaryRange , String . . . columnFamilies ) throws IOException <nl> { <nl> RepairRunner runner = new RepairRunner ( out , keyspaceName , columnFamilies ) ; <nl> try <nl> { <nl> jmxc . addConnectionNotificationListener ( runner , null , null ) ; <nl> ssProxy . addNotificationListener ( runner , null , null ) ; <nl> - if ( ! runner . repairAndWait ( ssProxy , isSequential , isLocal , primaryRange ) ) <nl> + if ( ! runner . repairAndWait ( ssProxy , isSequential , dataCenters , primaryRange ) ) <nl> failed = true ; <nl> } <nl> catch ( Exception e ) <nl> @ @ - 241 , 14 + 241 , 14 @ @ public class NodeProbe <nl> } <nl> } <nl> <nl> - public void forceRepairRangeAsync ( final PrintStream out , final String keyspaceName , boolean isSequential , boolean isLocal , final String startToken , final String endToken , String . . . columnFamilies ) throws IOException <nl> + public void forceRepairRangeAsync ( final PrintStream out , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , final String startToken , final String endToken , String . . . columnFamilies ) throws IOException <nl> { <nl> RepairRunner runner = new RepairRunner ( out , keyspaceName , columnFamilies ) ; <nl> try <nl> { <nl> jmxc . addConnectionNotificationListener ( runner , null , null ) ; <nl> ssProxy . addNotificationListener ( runner , null , null ) ; <nl> - if ( ! runner . repairRangeAndWait ( ssProxy , isSequential , isLocal , startToken , endToken ) ) <nl> + if ( ! runner . repairRangeAndWait ( ssProxy , isSequential , dataCenters , startToken , endToken ) ) <nl> failed = true ; <nl> } <nl> catch ( Exception e ) <nl> @ @ - 1183 , 16 + 1183 , 16 @ @ class RepairRunner implements NotificationListener <nl> this . columnFamilies = columnFamilies ; <nl> } <nl> <nl> - public boolean repairAndWait ( StorageServiceMBean ssProxy , boolean isSequential , boolean isLocal , boolean primaryRangeOnly ) throws Exception <nl> + public boolean repairAndWait ( StorageServiceMBean ssProxy , boolean isSequential , Collection < String > dataCenters , boolean primaryRangeOnly ) throws Exception <nl> { <nl> - cmd = ssProxy . forceRepairAsync ( keyspace , isSequential , isLocal , primaryRangeOnly , columnFamilies ) ; <nl> + cmd = ssProxy . forceRepairAsync ( keyspace , isSequential , dataCenters , primaryRangeOnly , columnFamilies ) ; <nl> waitForRepair ( ) ; <nl> return success ; <nl> } <nl> <nl> - public boolean repairRangeAndWait ( StorageServiceMBean ssProxy , boolean isSequential , boolean isLocal , String startToken , String endToken ) throws Exception <nl> + public boolean repairRangeAndWait ( StorageServiceMBean ssProxy , boolean isSequential , Collection < String > dataCenters , String startToken , String endToken ) throws Exception <nl> { <nl> - cmd = ssProxy . forceRepairRangeAsync ( startToken , endToken , keyspace , isSequential , isLocal , columnFamilies ) ; <nl> + cmd = ssProxy . forceRepairRangeAsync ( startToken , endToken , keyspace , isSequential , dataCenters , columnFamilies ) ; <nl> waitForRepair ( ) ; <nl> return success ; <nl> } <nl> diff - - git a / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml b / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml <nl> index 632d7e1 . . 54d0884 100644 <nl> - - - a / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml <nl> + + + b / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml <nl> @ @ - 148 , 8 + 148 , 12 @ @ commands : <nl> - name : repair [ keyspace ] [ cfnames ] <nl> help : | <nl> Repair one or more column families <nl> + Use - dc to repair specific datacenters ( csv list ) . <nl> + Use - et to specify a token at which repair range ends . <nl> + Use - local to only repair against nodes in the same datacenter . <nl> Use - pr to repair only the first range returned by the partitioner . <nl> Use - par to carry out a parallel repair . <nl> + Use - st to specify a token at which the repair range starts . <nl> - name : cleanup [ keyspace ] [ cfnames ] <nl> help : | <nl> Run cleanup on one or more column families <nl> diff - - git a / test / unit / org / apache / cassandra / service / AntiEntropyServiceTestAbstract . java b / test / unit / org / apache / cassandra / service / AntiEntropyServiceTestAbstract . java <nl> index 4023910 . . 1123fc0 100644 <nl> - - - a / test / unit / org / apache / cassandra / service / AntiEntropyServiceTestAbstract . java <nl> + + + b / test / unit / org / apache / cassandra / service / AntiEntropyServiceTestAbstract . java <nl> @ @ - 124 , 7 + 124 , 7 @ @ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader <nl> Set < InetAddress > neighbors = new HashSet < InetAddress > ( ) ; <nl> for ( Range < Token > range : ranges ) <nl> { <nl> - neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , false ) ) ; <nl> + neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , null ) ) ; <nl> } <nl> assertEquals ( expected , neighbors ) ; <nl> } <nl> @ @ - 147 , 7 + 147 , 7 @ @ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader <nl> Set < InetAddress > neighbors = new HashSet < InetAddress > ( ) ; <nl> for ( Range < Token > range : ranges ) <nl> { <nl> - neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , false ) ) ; <nl> + neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , null ) ) ; <nl> } <nl> assertEquals ( expected , neighbors ) ; <nl> } <nl> @ @ - 169 , 7 + 169 , 7 @ @ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader <nl> Set < InetAddress > neighbors = new HashSet < InetAddress > ( ) ; <nl> for ( Range < Token > range : ranges ) <nl> { <nl> - neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , true ) ) ; <nl> + neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , Arrays . asList ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) ) ; <nl> } <nl> assertEquals ( expected , neighbors ) ; <nl> } <nl> @ @ - 197 , 7 + 197 , 7 @ @ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader <nl> Set < InetAddress > neighbors = new HashSet < InetAddress > ( ) ; <nl> for ( Range < Token > range : ranges ) <nl> { <nl> - neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , true ) ) ; <nl> + neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , Arrays . asList ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) ) ; <nl> } <nl> assertEquals ( expected , neighbors ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 5869d32 . . 966f940 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 23 , 6 + 23 , 7 @ @ <nl> * remove the wait on hint future during write ( CASSANDRA - 3870 ) <nl> * ( cqlsh ) ignore missing CfDef opts ( CASSANDRA - 3933 ) <nl> * ( cqlsh ) look for cqlshlib relative to realpath ( CASSANDRA - 3767 ) <nl> + * Fix short read protection ( CASSANDRA - 3934 ) <nl> Merged from 0 . 8 : <nl> * ( Pig ) fix CassandraStorage to use correct comparator in Super ColumnFamily <nl> case ( CASSANDRA - 3251 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / RetriedSliceFromReadCommand . java b / src / java / org / apache / cassandra / db / RetriedSliceFromReadCommand . java <nl> index 6890f9d . . 5e0ca13 100644 <nl> - - - a / src / java / org / apache / cassandra / db / RetriedSliceFromReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / RetriedSliceFromReadCommand . java <nl> @ @ - 53 , 7 + 53 , 7 @ @ public class RetriedSliceFromReadCommand extends SliceFromReadCommand <nl> } <nl> <nl> @ Override <nl> - public int getRequestedCount ( ) <nl> + public int getOriginalRequestedCount ( ) <nl> { <nl> return originalCount ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / SliceFromReadCommand . java b / src / java / org / apache / cassandra / db / SliceFromReadCommand . java <nl> index 51c1602 . . 58b5e22 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SliceFromReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / SliceFromReadCommand . java <nl> @ @ - 76 , 10 + 76 , 16 @ @ public class SliceFromReadCommand extends ReadCommand <nl> int liveColumnsInRow = row ! = null ? row . cf . getLiveColumnCount ( ) : 0 ; <nl> <nl> assert maxLiveColumns < = count ; <nl> - if ( ( maxLiveColumns = = count ) & & ( liveColumnsInRow < count ) ) <nl> + / / We generate a retry if at least one node reply with count live columns but after merge we have less <nl> + / / than the total number of column we are interested in ( which may be < count on a retry ) <nl> + if ( ( maxLiveColumns = = count ) & & ( liveColumnsInRow < getOriginalRequestedCount ( ) ) ) <nl> { <nl> - int retryCount = count + count - liveColumnsInRow ; <nl> - return new RetriedSliceFromReadCommand ( table , key , queryPath , start , finish , reversed , count , retryCount ) ; <nl> + / / We asked t ( = count ) live columns and got l ( = liveColumnsInRow ) ones . <nl> + / / From that , we can estimate that on this row , for x requested <nl> + / / columns , only l / t end up live after reconciliation . So for next <nl> + / / round we want to ask x column so that x * ( l / t ) = = t , i . e . x = t ^ 2 / l . <nl> + int retryCount = ( ( count * count ) / liveColumnsInRow ) + 1 ; <nl> + return new RetriedSliceFromReadCommand ( table , key , queryPath , start , finish , reversed , getOriginalRequestedCount ( ) , retryCount ) ; <nl> } <nl> <nl> return null ; <nl> @ @ - 93 , 11 + 99 , 11 @ @ public class SliceFromReadCommand extends ReadCommand <nl> <nl> int liveColumnsInRow = row . cf . getLiveColumnCount ( ) ; <nl> <nl> - if ( liveColumnsInRow > getRequestedCount ( ) ) <nl> + if ( liveColumnsInRow > getOriginalRequestedCount ( ) ) <nl> { <nl> - int columnsToTrim = liveColumnsInRow - getRequestedCount ( ) ; <nl> + int columnsToTrim = liveColumnsInRow - getOriginalRequestedCount ( ) ; <nl> <nl> - logger . debug ( " trimming { } live columns to the originally requested { } " , row . cf . getLiveColumnCount ( ) , getRequestedCount ( ) ) ; <nl> + logger . debug ( " trimming { } live columns to the originally requested { } " , row . cf . getLiveColumnCount ( ) , getOriginalRequestedCount ( ) ) ; <nl> <nl> Collection < IColumn > columns ; <nl> if ( reversed ) <nl> @ @ - 122 , 7 + 128 , 12 @ @ public class SliceFromReadCommand extends ReadCommand <nl> } <nl> } <nl> <nl> - protected int getRequestedCount ( ) <nl> + / * * <nl> + * The original number of columns requested by the user . <nl> + * This can be different from count when the slice command is a retry ( see <nl> + * RetriedSliceFromReadCommand ) <nl> + * / <nl> + protected int getOriginalRequestedCount ( ) <nl> { <nl> return count ; <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 8d11a0a . . 81ba65a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 16 , 6 + 16 , 8 @ @ 
 
 
 2 . 0 . 4 
 + * Allow specifying datacenters to participate in a repair ( CASSANDRA - 6218 ) 
 + * Fix divide - by - zero in PCI ( CASSANDRA - 6403 ) 
 * Fix setting last compacted key in the wrong level for LCS ( CASSANDRA - 6284 ) 
 * Add sub - ms precision formats to the timestamp parser ( CASSANDRA - 6395 ) 
 * Add snapshot space used to cfstats ( CASSANDRA - 6231 ) 
 diff - - git a / src / java / org / apache / cassandra / repair / RepairSession . java b / src / java / org / apache / cassandra / repair / RepairSession . java 
 index d89cc27 . . 3933a88 100644 
 - - - a / src / java / org / apache / cassandra / repair / RepairSession . java 
 + + + b / src / java / org / apache / cassandra / repair / RepairSession . java 
 @ @ - 102 , 15 + 102 , 15 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan 
 * @ param range range to repair 
 * @ param keyspace name of keyspace 
 * @ param isSequential true if performing repair on snapshots sequentially 
 - * @ param isLocal true if you want to perform repair only inside the data center 
 + * @ param dataCenters the data centers that should be part of the repair ; null for all DCs 
 * @ param cfnames names of columnfamilies 
 * / 
 - public RepairSession ( Range < Token > range , String keyspace , boolean isSequential , boolean isLocal , String . . . cfnames ) 
 + public RepairSession ( Range < Token > range , String keyspace , boolean isSequential , Collection < String > dataCenters , String . . . cfnames ) 
 { 
 - this ( UUIDGen . getTimeUUID ( ) , range , keyspace , isSequential , isLocal , cfnames ) ; 
 + this ( UUIDGen . getTimeUUID ( ) , range , keyspace , isSequential , dataCenters , cfnames ) ; 
 } 
 
 - public RepairSession ( UUID id , Range < Token > range , String keyspace , boolean isSequential , boolean isLocal , String [ ] cfnames ) 
 + public RepairSession ( UUID id , Range < Token > range , String keyspace , boolean isSequential , Collection < String > dataCenters , String [ ] cfnames ) 
 { 
 this . id = id ; 
 this . isSequential = isSequential ; 
 @ @ - 118 , 7 + 118 , 7 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan 
 this . cfnames = cfnames ; 
 assert cfnames . length > 0 : " Repairing no column families seems pointless , doesn ' t it " ; 
 this . range = range ; 
 - this . endpoints = ActiveRepairService . getNeighbors ( keyspace , range , isLocal ) ; 
 + this . endpoints = ActiveRepairService . getNeighbors ( keyspace , range , dataCenters ) ; 
 } 
 
 public UUID getId ( ) 
 diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 index 2f16b31 . . b77f216 100644 
 - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 @ @ - 21 , 6 + 21 , 7 @ @ import java . net . InetAddress ; 
 import java . util . * ; 
 import java . util . concurrent . * ; 
 
 + import com . google . common . collect . Multimap ; 
 import com . google . common . collect . Sets ; 
 
 import org . apache . cassandra . concurrent . JMXConfigurableThreadPoolExecutor ; 
 @ @ - 90 , 9 + 91 , 9 @ @ public class ActiveRepairService 
 * 
 * @ return Future for asynchronous call or null if there is no need to repair 
 * / 
 - public RepairFuture submitRepairSession ( Range < Token > range , String keyspace , boolean isSequential , boolean isLocal , String . . . cfnames ) 
 + public RepairFuture submitRepairSession ( Range < Token > range , String keyspace , boolean isSequential , Collection < String > dataCenters , String . . . cfnames ) 
 { 
 - RepairSession session = new RepairSession ( range , keyspace , isSequential , isLocal , cfnames ) ; 
 + RepairSession session = new RepairSession ( range , keyspace , isSequential , dataCenters , cfnames ) ; 
 if ( session . endpoints . isEmpty ( ) ) 
 return null ; 
 RepairFuture futureTask = new RepairFuture ( session ) ; 
 @ @ - 126 , 7 + 127 , 7 @ @ public class ActiveRepairService 
 / / add it to the sessions ( avoid NPE in tests ) 
 RepairFuture submitArtificialRepairSession ( RepairJobDesc desc ) 
 { 
 - RepairSession session = new RepairSession ( desc . sessionId , desc . range , desc . keyspace , false , false , new String [ ] { desc . columnFamily } ) ; 
 + RepairSession session = new RepairSession ( desc . sessionId , desc . range , desc . keyspace , false , null , new String [ ] { desc . columnFamily } ) ; 
 sessions . put ( session . getId ( ) , session ) ; 
 RepairFuture futureTask = new RepairFuture ( session ) ; 
 executor . execute ( futureTask ) ; 
 @ @ - 138 , 12 + 139 , 15 @ @ public class ActiveRepairService 
 * 
 * @ param keyspaceName keyspace to repair 
 * @ param toRepair token to repair 
 - * @ param isLocal need to use only nodes from local datacenter 
 + * @ param dataCenters the data centers to involve in the repair 
 * 
 * @ return neighbors with whom we share the provided range 
 * / 
 - public static Set < InetAddress > getNeighbors ( String keyspaceName , Range < Token > toRepair , boolean isLocal ) 
 + public static Set < InetAddress > getNeighbors ( String keyspaceName , Range < Token > toRepair , Collection < String > dataCenters ) 
 { 
 + if ( dataCenters ! = null & & ! dataCenters . contains ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) 
 + throw new IllegalArgumentException ( " The local data center must be part of the repair " ) ; 
 + 
 StorageService ss = StorageService . instance ; 
 Map < Range < Token > , List < InetAddress > > replicaSets = ss . getRangeToAddressMap ( keyspaceName ) ; 
 Range < Token > rangeSuperSet = null ; 
 @ @ - 165 , 11 + 169 , 18 @ @ public class ActiveRepairService 
 Set < InetAddress > neighbors = new HashSet < > ( replicaSets . get ( rangeSuperSet ) ) ; 
 neighbors . remove ( FBUtilities . getBroadcastAddress ( ) ) ; 
 
 - if ( isLocal ) 
 + if ( dataCenters ! = null ) 
 { 
 TokenMetadata . Topology topology = ss . getTokenMetadata ( ) . cloneOnlyTokenMap ( ) . getTopology ( ) ; 
 - Set < InetAddress > localEndpoints = Sets . newHashSet ( topology . getDatacenterEndpoints ( ) . get ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) ; 
 - return Sets . intersection ( neighbors , localEndpoints ) ; 
 + Set < InetAddress > dcEndpoints = Sets . newHashSet ( ) ; 
 + Multimap < String , InetAddress > dcEndpointsMap = topology . getDatacenterEndpoints ( ) ; 
 + for ( String dc : dataCenters ) 
 + { 
 + Collection < InetAddress > c = dcEndpointsMap . get ( dc ) ; 
 + if ( c ! = null ) 
 + dcEndpoints . addAll ( c ) ; 
 + } 
 + return Sets . intersection ( neighbors , dcEndpoints ) ; 
 } 
 
 return neighbors ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 3107b96 . . dc11427 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 2250 , 6 + 2250 , 26 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 jmxNotification . setUserData ( userObject ) ; 
 sendNotification ( jmxNotification ) ; 
 } 
 + 
 + public int forceRepairAsync ( final String keyspace , final boolean isSequential , final Collection < String > dataCenters , final boolean primaryRange , final String . . . columnFamilies ) 
 + { 
 + final Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; 
 + return forceRepairAsync ( keyspace , isSequential , dataCenters , ranges , columnFamilies ) ; 
 + } 
 + 
 + public int forceRepairAsync ( final String keyspace , final boolean isSequential , final Collection < String > dataCenters , final Collection < Range < Token > > ranges , final String . . . columnFamilies ) 
 + { 
 + if ( Keyspace . SYSTEM _ KS . equals ( keyspace ) | | ranges . isEmpty ( ) ) 
 + return 0 ; 
 + 
 + final int cmd = nextRepairCommand . incrementAndGet ( ) ; 
 + if ( ranges . size ( ) > 0 ) 
 + { 
 + new Thread ( createRepairTask ( cmd , keyspace , ranges , isSequential , dataCenters , columnFamilies ) ) . start ( ) ; 
 + } 
 + return cmd ; 
 + } 
 + 
 public int forceRepairAsync ( final String keyspace , final boolean isSequential , final boolean isLocal , final boolean primaryRange , final String . . . columnFamilies ) 
 { 
 final Collection < Range < Token > > ranges = primaryRange ? getLocalPrimaryRanges ( keyspace ) : getLocalRanges ( keyspace ) ; 
 @ @ - 2269 , 6 + 2289 , 16 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return cmd ; 
 } 
 
 + public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , final String . . . columnFamilies ) 
 + { 
 + Token parsedBeginToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( beginToken ) ; 
 + Token parsedEndToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( endToken ) ; 
 + 
 + logger . info ( " starting user - requested repair of range ( { } , { } ] for keyspace { } and column families { } " , 
 + parsedBeginToken , parsedEndToken , keyspaceName , columnFamilies ) ; 
 + return forceRepairAsync ( keyspaceName , isSequential , dataCenters , Collections . singleton ( new Range < Token > ( parsedBeginToken , parsedEndToken ) ) , columnFamilies ) ; 
 + } 
 + 
 public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , boolean isLocal , final String . . . columnFamilies ) 
 { 
 Token parsedBeginToken = getPartitioner ( ) . getTokenFactory ( ) . fromString ( beginToken ) ; 
 @ @ - 2315 , 6 + 2345 , 16 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private FutureTask < Object > createRepairTask ( final int cmd , final String keyspace , final Collection < Range < Token > > ranges , final boolean isSequential , final boolean isLocal , final String . . . columnFamilies ) 
 { 
 + Set < String > dataCenters = null ; 
 + if ( isLocal ) 
 + { 
 + dataCenters = Sets . newHashSet ( DatabaseDescriptor . getLocalDataCenter ( ) ) ; 
 + } 
 + return createRepairTask ( cmd , keyspace , ranges , isSequential , dataCenters , columnFamilies ) ; 
 + } 
 + 
 + private FutureTask < Object > createRepairTask ( final int cmd , final String keyspace , final Collection < Range < Token > > ranges , final boolean isSequential , final Collection < String > dataCenters , final String . . . columnFamilies ) 
 + { 
 return new FutureTask < Object > ( new WrappedRunnable ( ) 
 { 
 protected void runMayThrow ( ) throws Exception 
 @ @ - 2323 , 13 + 2363 , 21 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 logger . info ( message ) ; 
 sendNotification ( " repair " , message , new int [ ] { cmd , ActiveRepairService . Status . STARTED . ordinal ( ) } ) ; 
 
 + if ( dataCenters ! = null & & ! dataCenters . contains ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) 
 + { 
 + message = String . format ( " Cancelling repair command # % d ( the local data center must be part of the repair ) " , cmd ) ; 
 + logger . error ( message ) ; 
 + sendNotification ( " repair " , message , new int [ ] { cmd , ActiveRepairService . Status . FINISHED . ordinal ( ) } ) ; 
 + return ; 
 + } 
 + 
 List < RepairFuture > futures = new ArrayList < RepairFuture > ( ranges . size ( ) ) ; 
 for ( Range < Token > range : ranges ) 
 { 
 RepairFuture future ; 
 try 
 { 
 - future = forceKeyspaceRepair ( range , keyspace , isSequential , isLocal , columnFamilies ) ; 
 + future = forceKeyspaceRepair ( range , keyspace , isSequential , dataCenters , columnFamilies ) ; 
 } 
 catch ( IllegalArgumentException e ) 
 { 
 @ @ - 2379 , 7 + 2427 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } , null ) ; 
 } 
 
 - public RepairFuture forceKeyspaceRepair ( final Range < Token > range , final String keyspaceName , boolean isSequential , boolean isLocal , final String . . . columnFamilies ) throws IOException 
 + public RepairFuture forceKeyspaceRepair ( final Range < Token > range , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , final String . . . columnFamilies ) throws IOException 
 { 
 ArrayList < String > names = new ArrayList < String > ( ) ; 
 for ( ColumnFamilyStore cfStore : getValidColumnFamilies ( false , false , keyspaceName , columnFamilies ) ) 
 @ @ - 2393 , 7 + 2441 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return null ; 
 } 
 
 - return ActiveRepairService . instance . submitRepairSession ( range , keyspaceName , isSequential , isLocal , names . toArray ( new String [ names . size ( ) ] ) ) ; 
 + return ActiveRepairService . instance . submitRepairSession ( range , keyspaceName , isSequential , dataCenters , names . toArray ( new String [ names . size ( ) ] ) ) ; 
 } 
 
 public void forceTerminateAllRepairSessions ( ) { 
 diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 index 8edadee . . 8da215b 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 @ @ - 256 , 6 + 256 , 23 @ @ public interface StorageServiceMBean extends NotificationEmitter 
 * userObject : int array of length 2 , [ 0 ] = command number , [ 1 ] = ordinal of AntiEntropyService . Status 
 * 
 * @ return Repair command number , or 0 if nothing to repair 
 + * / 
 + public int forceRepairAsync ( String keyspace , boolean isSequential , Collection < String > dataCenters , boolean primaryRange , String . . . columnFamilies ) ; 
 + 
 + / * * 
 + * Same as forceRepairAsync , but handles a specified range 
 + * / 
 + public int forceRepairRangeAsync ( String beginToken , String endToken , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , final String . . . columnFamilies ) ; 
 + 
 + 
 + / * * 
 + * Invoke repair asynchronously . 
 + * You can track repair progress by subscribing JMX notification sent from this StorageServiceMBean . 
 + * Notification format is : 
 + * type : " repair " 
 + * userObject : int array of length 2 , [ 0 ] = command number , [ 1 ] = ordinal of AntiEntropyService . Status 
 + * 
 + * @ return Repair command number , or 0 if nothing to repair 
 * @ see # forceKeyspaceRepair ( String , boolean , boolean , String . . . ) 
 * / 
 public int forceRepairAsync ( String keyspace , boolean isSequential , boolean isLocal , boolean primaryRange , String . . . columnFamilies ) ; 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index a6c0010 . . bb92502 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 68 , 6 + 68 , 7 @ @ public class NodeCmd 
 private static final Pair < String , String > PRIMARY _ RANGE _ OPT = Pair . create ( " pr " , " partitioner - range " ) ; 
 private static final Pair < String , String > PARALLEL _ REPAIR _ OPT = Pair . create ( " par " , " parallel " ) ; 
 private static final Pair < String , String > LOCAL _ DC _ REPAIR _ OPT = Pair . create ( " local " , " in - local - dc " ) ; 
 + private static final Pair < String , String > DC _ REPAIR _ OPT = Pair . create ( " dc " , " in - dc " ) ; 
 private static final Pair < String , String > START _ TOKEN _ OPT = Pair . create ( " st " , " start - token " ) ; 
 private static final Pair < String , String > END _ TOKEN _ OPT = Pair . create ( " et " , " end - token " ) ; 
 private static final Pair < String , String > UPGRADE _ ALL _ SSTABLE _ OPT = Pair . create ( " a " , " include - all - sstables " ) ; 
 @ @ - 93 , 6 + 94 , 7 @ @ public class NodeCmd 
 options . addOption ( PRIMARY _ RANGE _ OPT , false , " only repair the first range returned by the partitioner for the node " ) ; 
 options . addOption ( PARALLEL _ REPAIR _ OPT , false , " repair nodes in parallel . " ) ; 
 options . addOption ( LOCAL _ DC _ REPAIR _ OPT , false , " only repair against nodes in the same datacenter " ) ; 
 + options . addOption ( DC _ REPAIR _ OPT , true , " only repair against nodes in the specified datacenters ( comma separated ) " ) ; 
 options . addOption ( START _ TOKEN _ OPT , true , " token at which repair range starts " ) ; 
 options . addOption ( END _ TOKEN _ OPT , true , " token at which repair range ends " ) ; 
 options . addOption ( UPGRADE _ ALL _ SSTABLE _ OPT , false , " includes sstables that are already on the most recent version during upgradesstables " ) ; 
 @ @ - 1510 , 11 + 1512 , 17 @ @ public class NodeCmd 
 case REPAIR : 
 boolean sequential = ! cmd . hasOption ( PARALLEL _ REPAIR _ OPT . left ) ; 
 boolean localDC = cmd . hasOption ( LOCAL _ DC _ REPAIR _ OPT . left ) ; 
 + boolean specificDC = cmd . hasOption ( DC _ REPAIR _ OPT . left ) ; 
 boolean primaryRange = cmd . hasOption ( PRIMARY _ RANGE _ OPT . left ) ; 
 + Collection < String > dataCenters = null ; 
 + if ( specificDC ) 
 + dataCenters = Arrays . asList ( cmd . getOptionValue ( DC _ REPAIR _ OPT . left ) . split ( " , " ) ) ; 
 + else if ( localDC ) 
 + dataCenters = Arrays . asList ( probe . getDataCenter ( ) ) ; 
 if ( cmd . hasOption ( START _ TOKEN _ OPT . left ) | | cmd . hasOption ( END _ TOKEN _ OPT . left ) ) 
 - probe . forceRepairRangeAsync ( System . out , keyspace , sequential , localDC , cmd . getOptionValue ( START _ TOKEN _ OPT . left ) , cmd . getOptionValue ( END _ TOKEN _ OPT . left ) , columnFamilies ) ; 
 + probe . forceRepairRangeAsync ( System . out , keyspace , sequential , dataCenters , cmd . getOptionValue ( START _ TOKEN _ OPT . left ) , cmd . getOptionValue ( END _ TOKEN _ OPT . left ) , columnFamilies ) ; 
 else 
 - probe . forceRepairAsync ( System . out , keyspace , sequential , localDC , primaryRange , columnFamilies ) ; 
 + probe . forceRepairAsync ( System . out , keyspace , sequential , dataCenters , primaryRange , columnFamilies ) ; 
 break ; 
 case FLUSH : 
 try { probe . forceKeyspaceFlush ( keyspace , columnFamilies ) ; } 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 index b755ff3 . . 790862b 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 216 , 14 + 216 , 14 @ @ public class NodeProbe 
 ssProxy . forceKeyspaceRepair ( keyspaceName , isSequential , isLocal , columnFamilies ) ; 
 } 
 
 - public void forceRepairAsync ( final PrintStream out , final String keyspaceName , boolean isSequential , boolean isLocal , boolean primaryRange , String . . . columnFamilies ) throws IOException 
 + public void forceRepairAsync ( final PrintStream out , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , boolean primaryRange , String . . . columnFamilies ) throws IOException 
 { 
 RepairRunner runner = new RepairRunner ( out , keyspaceName , columnFamilies ) ; 
 try 
 { 
 jmxc . addConnectionNotificationListener ( runner , null , null ) ; 
 ssProxy . addNotificationListener ( runner , null , null ) ; 
 - if ( ! runner . repairAndWait ( ssProxy , isSequential , isLocal , primaryRange ) ) 
 + if ( ! runner . repairAndWait ( ssProxy , isSequential , dataCenters , primaryRange ) ) 
 failed = true ; 
 } 
 catch ( Exception e ) 
 @ @ - 241 , 14 + 241 , 14 @ @ public class NodeProbe 
 } 
 } 
 
 - public void forceRepairRangeAsync ( final PrintStream out , final String keyspaceName , boolean isSequential , boolean isLocal , final String startToken , final String endToken , String . . . columnFamilies ) throws IOException 
 + public void forceRepairRangeAsync ( final PrintStream out , final String keyspaceName , boolean isSequential , Collection < String > dataCenters , final String startToken , final String endToken , String . . . columnFamilies ) throws IOException 
 { 
 RepairRunner runner = new RepairRunner ( out , keyspaceName , columnFamilies ) ; 
 try 
 { 
 jmxc . addConnectionNotificationListener ( runner , null , null ) ; 
 ssProxy . addNotificationListener ( runner , null , null ) ; 
 - if ( ! runner . repairRangeAndWait ( ssProxy , isSequential , isLocal , startToken , endToken ) ) 
 + if ( ! runner . repairRangeAndWait ( ssProxy , isSequential , dataCenters , startToken , endToken ) ) 
 failed = true ; 
 } 
 catch ( Exception e ) 
 @ @ - 1183 , 16 + 1183 , 16 @ @ class RepairRunner implements NotificationListener 
 this . columnFamilies = columnFamilies ; 
 } 
 
 - public boolean repairAndWait ( StorageServiceMBean ssProxy , boolean isSequential , boolean isLocal , boolean primaryRangeOnly ) throws Exception 
 + public boolean repairAndWait ( StorageServiceMBean ssProxy , boolean isSequential , Collection < String > dataCenters , boolean primaryRangeOnly ) throws Exception 
 { 
 - cmd = ssProxy . forceRepairAsync ( keyspace , isSequential , isLocal , primaryRangeOnly , columnFamilies ) ; 
 + cmd = ssProxy . forceRepairAsync ( keyspace , isSequential , dataCenters , primaryRangeOnly , columnFamilies ) ; 
 waitForRepair ( ) ; 
 return success ; 
 } 
 
 - public boolean repairRangeAndWait ( StorageServiceMBean ssProxy , boolean isSequential , boolean isLocal , String startToken , String endToken ) throws Exception 
 + public boolean repairRangeAndWait ( StorageServiceMBean ssProxy , boolean isSequential , Collection < String > dataCenters , String startToken , String endToken ) throws Exception 
 { 
 - cmd = ssProxy . forceRepairRangeAsync ( startToken , endToken , keyspace , isSequential , isLocal , columnFamilies ) ; 
 + cmd = ssProxy . forceRepairRangeAsync ( startToken , endToken , keyspace , isSequential , dataCenters , columnFamilies ) ; 
 waitForRepair ( ) ; 
 return success ; 
 } 
 diff - - git a / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml b / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml 
 index 632d7e1 . . 54d0884 100644 
 - - - a / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml 
 + + + b / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml 
 @ @ - 148 , 8 + 148 , 12 @ @ commands : 
 - name : repair [ keyspace ] [ cfnames ] 
 help : | 
 Repair one or more column families 
 + Use - dc to repair specific datacenters ( csv list ) . 
 + Use - et to specify a token at which repair range ends . 
 + Use - local to only repair against nodes in the same datacenter . 
 Use - pr to repair only the first range returned by the partitioner . 
 Use - par to carry out a parallel repair . 
 + Use - st to specify a token at which the repair range starts . 
 - name : cleanup [ keyspace ] [ cfnames ] 
 help : | 
 Run cleanup on one or more column families 
 diff - - git a / test / unit / org / apache / cassandra / service / AntiEntropyServiceTestAbstract . java b / test / unit / org / apache / cassandra / service / AntiEntropyServiceTestAbstract . java 
 index 4023910 . . 1123fc0 100644 
 - - - a / test / unit / org / apache / cassandra / service / AntiEntropyServiceTestAbstract . java 
 + + + b / test / unit / org / apache / cassandra / service / AntiEntropyServiceTestAbstract . java 
 @ @ - 124 , 7 + 124 , 7 @ @ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader 
 Set < InetAddress > neighbors = new HashSet < InetAddress > ( ) ; 
 for ( Range < Token > range : ranges ) 
 { 
 - neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , false ) ) ; 
 + neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , null ) ) ; 
 } 
 assertEquals ( expected , neighbors ) ; 
 } 
 @ @ - 147 , 7 + 147 , 7 @ @ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader 
 Set < InetAddress > neighbors = new HashSet < InetAddress > ( ) ; 
 for ( Range < Token > range : ranges ) 
 { 
 - neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , false ) ) ; 
 + neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , null ) ) ; 
 } 
 assertEquals ( expected , neighbors ) ; 
 } 
 @ @ - 169 , 7 + 169 , 7 @ @ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader 
 Set < InetAddress > neighbors = new HashSet < InetAddress > ( ) ; 
 for ( Range < Token > range : ranges ) 
 { 
 - neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , true ) ) ; 
 + neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , Arrays . asList ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) ) ; 
 } 
 assertEquals ( expected , neighbors ) ; 
 } 
 @ @ - 197 , 7 + 197 , 7 @ @ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader 
 Set < InetAddress > neighbors = new HashSet < InetAddress > ( ) ; 
 for ( Range < Token > range : ranges ) 
 { 
 - neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , true ) ) ; 
 + neighbors . addAll ( ActiveRepairService . getNeighbors ( keyspaceName , range , Arrays . asList ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) ) ; 
 } 
 assertEquals ( expected , neighbors ) ; 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 5869d32 . . 966f940 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 23 , 6 + 23 , 7 @ @ 
 * remove the wait on hint future during write ( CASSANDRA - 3870 ) 
 * ( cqlsh ) ignore missing CfDef opts ( CASSANDRA - 3933 ) 
 * ( cqlsh ) look for cqlshlib relative to realpath ( CASSANDRA - 3767 ) 
 + * Fix short read protection ( CASSANDRA - 3934 ) 
 Merged from 0 . 8 : 
 * ( Pig ) fix CassandraStorage to use correct comparator in Super ColumnFamily 
 case ( CASSANDRA - 3251 ) 
 diff - - git a / src / java / org / apache / cassandra / db / RetriedSliceFromReadCommand . java b / src / java / org / apache / cassandra / db / RetriedSliceFromReadCommand . java 
 index 6890f9d . . 5e0ca13 100644 
 - - - a / src / java / org / apache / cassandra / db / RetriedSliceFromReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / RetriedSliceFromReadCommand . java 
 @ @ - 53 , 7 + 53 , 7 @ @ public class RetriedSliceFromReadCommand extends SliceFromReadCommand 
 } 
 
 @ Override 
 - public int getRequestedCount ( ) 
 + public int getOriginalRequestedCount ( ) 
 { 
 return originalCount ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / SliceFromReadCommand . java b / src / java / org / apache / cassandra / db / SliceFromReadCommand . java 
 index 51c1602 . . 58b5e22 100644 
 - - - a / src / java / org / apache / cassandra / db / SliceFromReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / SliceFromReadCommand . java 
 @ @ - 76 , 10 + 76 , 16 @ @ public class SliceFromReadCommand extends ReadCommand 
 int liveColumnsInRow = row ! = null ? row . cf . getLiveColumnCount ( ) : 0 ; 
 
 assert maxLiveColumns < = count ; 
 - if ( ( maxLiveColumns = = count ) & & ( liveColumnsInRow < count ) ) 
 + / / We generate a retry if at least one node reply with count live columns but after merge we have less 
 + / / than the total number of column we are interested in ( which may be < count on a retry ) 
 + if ( ( maxLiveColumns = = count ) & & ( liveColumnsInRow < getOriginalRequestedCount ( ) ) ) 
 { 
 - int retryCount = count + count - liveColumnsInRow ; 
 - return new RetriedSliceFromReadCommand ( table , key , queryPath , start , finish , reversed , count , retryCount ) ; 
 + / / We asked t ( = count ) live columns and got l ( = liveColumnsInRow ) ones . 
 + / / From that , we can estimate that on this row , for x requested 
 + / / columns , only l / t end up live after reconciliation . So for next 
 + / / round we want to ask x column so that x * ( l / t ) = = t , i . e . x = t ^ 2 / l . 
 + int retryCount = ( ( count * count ) / liveColumnsInRow ) + 1 ; 
 + return new RetriedSliceFromReadCommand ( table , key , queryPath , start , finish , reversed , getOriginalRequestedCount ( ) , retryCount ) ; 
 } 
 
 return null ; 
 @ @ - 93 , 11 + 99 , 11 @ @ public class SliceFromReadCommand extends ReadCommand 
 
 int liveColumnsInRow = row . cf . getLiveColumnCount ( ) ; 
 
 - if ( liveColumnsInRow > getRequestedCount ( ) ) 
 + if ( liveColumnsInRow > getOriginalRequestedCount ( ) ) 
 { 
 - int columnsToTrim = liveColumnsInRow - getRequestedCount ( ) ; 
 + int columnsToTrim = liveColumnsInRow - getOriginalRequestedCount ( ) ; 
 
 - logger . debug ( " trimming { } live columns to the originally requested { } " , row . cf . getLiveColumnCount ( ) , getRequestedCount ( ) ) ; 
 + logger . debug ( " trimming { } live columns to the originally requested { } " , row . cf . getLiveColumnCount ( ) , getOriginalRequestedCount ( ) ) ; 
 
 Collection < IColumn > columns ; 
 if ( reversed ) 
 @ @ - 122 , 7 + 128 , 12 @ @ public class SliceFromReadCommand extends ReadCommand 
 } 
 } 
 
 - protected int getRequestedCount ( ) 
 + / * * 
 + * The original number of columns requested by the user . 
 + * This can be different from count when the slice command is a retry ( see 
 + * RetriedSliceFromReadCommand ) 
 + * / 
 + protected int getOriginalRequestedCount ( ) 
 { 
 return count ; 
 }
