BLEU SCORE: 0.018738883683389617

TEST MSG: Read repair is not blocking repair to finish in foreground repair
GENERATED MSG: formatting + cleanup . patch by jbellis for CASSANDRA - 462

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 97d49af . . 6293cfa 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 11 <nl> + * Read repair is not blocking repair to finish in foreground repair ( CASSANDRA - 13115 ) <nl> * Stress daemon help is incorrect ( CASSANDRA - 12563 ) <nl> * Remove ALTER TYPE support ( CASSANDRA - 12443 ) <nl> * Fix assertion for certain legacy range tombstone pattern ( CASSANDRA - 12203 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / partitions / UnfilteredPartitionIterators . java b / src / java / org / apache / cassandra / db / partitions / UnfilteredPartitionIterators . java <nl> index 41b1424 . . 1abbb19 100644 <nl> - - - a / src / java / org / apache / cassandra / db / partitions / UnfilteredPartitionIterators . java <nl> + + + b / src / java / org / apache / cassandra / db / partitions / UnfilteredPartitionIterators . java <nl> @ @ - 159 , 6 + 159 , 7 @ @ public abstract class UnfilteredPartitionIterators <nl> public void close ( ) <nl> { <nl> merged . close ( ) ; <nl> + listener . close ( ) ; <nl> } <nl> } ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / AsyncRepairCallback . java b / src / java / org / apache / cassandra / service / AsyncRepairCallback . java <nl> index dec5319 . . d613f3d 100644 <nl> - - - a / src / java / org / apache / cassandra / service / AsyncRepairCallback . java <nl> + + + b / src / java / org / apache / cassandra / service / AsyncRepairCallback . java <nl> @ @ - 17 , 7 + 17 , 6 @ @ <nl> * / <nl> package org . apache . cassandra . service ; <nl> <nl> - import java . io . IOException ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> import org . apache . cassandra . concurrent . Stage ; <nl> @ @ - 46 , 9 + 45 , 9 @ @ public class AsyncRepairCallback implements IAsyncCallback < ReadResponse > <nl> { <nl> StageManager . getStage ( Stage . READ _ REPAIR ) . execute ( new WrappedRunnable ( ) <nl> { <nl> - protected void runMayThrow ( ) throws DigestMismatchException , IOException <nl> + protected void runMayThrow ( ) <nl> { <nl> - repairResolver . resolve ( ) ; <nl> + repairResolver . compareResponses ( ) ; <nl> } <nl> } ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / DataResolver . java b / src / java / org / apache / cassandra / service / DataResolver . java <nl> index 4e5bfb8 . . 01953e1 100644 <nl> - - - a / src / java / org / apache / cassandra / service / DataResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / DataResolver . java <nl> @ @ - 21 , 6 + 21 , 8 @ @ import java . net . InetAddress ; <nl> import java . util . * ; <nl> import java . util . concurrent . TimeoutException ; <nl> <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> + <nl> import org . apache . cassandra . concurrent . Stage ; <nl> import org . apache . cassandra . concurrent . StageManager ; <nl> import org . apache . cassandra . config . CFMetaData ; <nl> @ @ - 40 , 7 + 42 , 8 @ @ import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> public class DataResolver extends ResponseResolver <nl> { <nl> - private final List < AsyncOneResponse > repairResults = Collections . synchronizedList ( new ArrayList < > ( ) ) ; <nl> + @ VisibleForTesting <nl> + final List < AsyncOneResponse > repairResults = Collections . synchronizedList ( new ArrayList < > ( ) ) ; <nl> <nl> public DataResolver ( Keyspace keyspace , ReadCommand command , ConsistencyLevel consistency , int maxResponseCount ) <nl> { <nl> @ @ - 73 , 6 + 76 , 15 @ @ public class DataResolver extends ResponseResolver <nl> return counter . applyTo ( mergeWithShortReadProtection ( iters , sources , counter ) ) ; <nl> } <nl> <nl> + public void compareResponses ( ) <nl> + { <nl> + / / We need to fully consume the results to trigger read repairs if appropriate <nl> + try ( PartitionIterator iterator = resolve ( ) ) <nl> + { <nl> + PartitionIterators . consume ( iterator ) ; <nl> + } <nl> + } <nl> + <nl> private PartitionIterator mergeWithShortReadProtection ( List < UnfilteredPartitionIterator > results , InetAddress [ ] sources , DataLimits . Counter resultCounter ) <nl> { <nl> / / If we have only one results , there is no read repair to do and we can ' t get short reads <nl> diff - - git a / src / java / org / apache / cassandra / service / DigestResolver . java b / src / java / org / apache / cassandra / service / DigestResolver . java <nl> index 4a918a3 . . 6a528e9 100644 <nl> - - - a / src / java / org / apache / cassandra / service / DigestResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / DigestResolver . java <nl> @ @ - 69 , 6 + 69 , 13 @ @ public class DigestResolver extends ResponseResolver <nl> if ( logger . isTraceEnabled ( ) ) <nl> logger . trace ( " resolving { } responses " , responses . size ( ) ) ; <nl> <nl> + compareResponses ( ) ; <nl> + <nl> + return UnfilteredPartitionIterators . filter ( dataResponse . makeIterator ( command ) , command . nowInSec ( ) ) ; <nl> + } <nl> + <nl> + public void compareResponses ( ) throws DigestMismatchException <nl> + { <nl> long start = System . nanoTime ( ) ; <nl> <nl> / / validate digests against each other ; throw immediately on mismatch . <nl> @ @ - 87 , 8 + 94 , 6 @ @ public class DigestResolver extends ResponseResolver <nl> <nl> if ( logger . isTraceEnabled ( ) ) <nl> logger . trace ( " resolve : { } ms . " , TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; <nl> - <nl> - return UnfilteredPartitionIterators . filter ( dataResponse . makeIterator ( command ) , command . nowInSec ( ) ) ; <nl> } <nl> <nl> public boolean isDataPresent ( ) <nl> diff - - git a / src / java / org / apache / cassandra / service / ReadCallback . java b / src / java / org / apache / cassandra / service / ReadCallback . java <nl> index 8747004 . . 516384a 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ReadCallback . java <nl> + + + b / src / java / org / apache / cassandra / service / ReadCallback . java <nl> @ @ - 219 , 10 + 219 , 10 @ @ public class ReadCallback implements IAsyncCallbackWithFailure < ReadResponse > <nl> { <nl> / / If the resolver is a DigestResolver , we need to do a full data read if there is a mismatch . <nl> / / Otherwise , resolve will send the repairs directly if needs be ( and in that case we should never <nl> - / / get a digest mismatch ) <nl> + / / get a digest mismatch ) . <nl> try <nl> { <nl> - resolver . resolve ( ) ; <nl> + resolver . compareResponses ( ) ; <nl> } <nl> catch ( DigestMismatchException e ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / ResponseResolver . java b / src / java / org / apache / cassandra / service / ResponseResolver . java <nl> index e7c94a1 . . 81b18b6 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ResponseResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / ResponseResolver . java <nl> @ @ - 47 , 6 + 47 , 18 @ @ public abstract class ResponseResolver <nl> public abstract PartitionIterator getData ( ) ; <nl> public abstract PartitionIterator resolve ( ) throws DigestMismatchException ; <nl> <nl> + / * * <nl> + * Compares received responses , potentially triggering a digest mismatch ( for a digest resolver ) and read - repairs <nl> + * ( for a data resolver ) . <nl> + * < p > <nl> + * This is functionally equivalent to calling { @ link # resolve ( ) } and consuming the result , but can be slightly more <nl> + * efficient in some case due to the fact that we don ' t care about the result itself . This is used when doing <nl> + * asynchronous read - repairs . <nl> + * <nl> + * @ throws DigestMismatchException if it ' s a digest resolver and the responses don ' t match . <nl> + * / <nl> + public abstract void compareResponses ( ) throws DigestMismatchException ; <nl> + <nl> public abstract boolean isDataPresent ( ) ; <nl> <nl> public void preprocess ( MessageIn < ReadResponse > message ) <nl> diff - - git a / test / unit / org / apache / cassandra / service / DataResolverTest . java b / test / unit / org / apache / cassandra / service / DataResolverTest . java <nl> index c9878d4 . . fd1e54e 100644 <nl> - - - a / test / unit / org / apache / cassandra / service / DataResolverTest . java <nl> + + + b / test / unit / org / apache / cassandra / service / DataResolverTest . java <nl> @ @ - 129 , 6 + 129 , 21 @ @ public class DataResolverTest <nl> MessagingService . instance ( ) . clearMessageSinks ( ) ; <nl> } <nl> <nl> + / * * <nl> + * Checks that the provided data resolver has the expected number of repair futures created . <nl> + * This method also " release " those future by faking replica responses to those repair , which is necessary or <nl> + * every test would timeout when closing the result of resolver . resolve ( ) , since it waits on those futures . <nl> + * / <nl> + private void assertRepairFuture ( DataResolver resolver , int expectedRepairs ) <nl> + { <nl> + assertEquals ( expectedRepairs , resolver . repairResults . size ( ) ) ; <nl> + <nl> + / / Signal all future . We pass a completely fake response message , but it doesn ' t matter as we just want <nl> + / / AsyncOneResponse to signal success , and it only cares about a non - null MessageIn ( it collects the payload ) . <nl> + for ( AsyncOneResponse < ? > future : resolver . repairResults ) <nl> + future . response ( MessageIn . create ( null , null , null , null , - 1 ) ) ; <nl> + } <nl> + <nl> @ Test <nl> public void testResolveNewerSingleRow ( ) throws UnknownHostException <nl> { <nl> @ @ - 142 , 12 + 157 , 15 @ @ public class DataResolverTest <nl> . add ( " c1 " , " v2 " ) <nl> . buildUpdate ( ) ) ) ) ; <nl> <nl> - try ( PartitionIterator data = resolver . resolve ( ) ; <nl> - RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> - Row row = Iterators . getOnlyElement ( rows ) ; <nl> - assertColumns ( row , " c1 " ) ; <nl> - assertColumn ( cfm , row , " c1 " , " v2 " , 1 ) ; <nl> + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + { <nl> + Row row = Iterators . getOnlyElement ( rows ) ; <nl> + assertColumns ( row , " c1 " ) ; <nl> + assertColumn ( cfm , row , " c1 " , " v2 " , 1 ) ; <nl> + } <nl> + assertRepairFuture ( resolver , 1 ) ; <nl> } <nl> <nl> assertEquals ( 1 , messageRecorder . sent . size ( ) ) ; <nl> @ @ - 172 , 13 + 190 , 16 @ @ public class DataResolverTest <nl> . add ( " c2 " , " v2 " ) <nl> . buildUpdate ( ) ) ) ) ; <nl> <nl> - try ( PartitionIterator data = resolver . resolve ( ) ; <nl> - RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> - Row row = Iterators . getOnlyElement ( rows ) ; <nl> - assertColumns ( row , " c1 " , " c2 " ) ; <nl> - assertColumn ( cfm , row , " c1 " , " v1 " , 0 ) ; <nl> - assertColumn ( cfm , row , " c2 " , " v2 " , 1 ) ; <nl> + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + { <nl> + Row row = Iterators . getOnlyElement ( rows ) ; <nl> + assertColumns ( row , " c1 " , " c2 " ) ; <nl> + assertColumn ( cfm , row , " c1 " , " v1 " , 0 ) ; <nl> + assertColumn ( cfm , row , " c2 " , " v2 " , 1 ) ; <nl> + } <nl> + assertRepairFuture ( resolver , 2 ) ; <nl> } <nl> <nl> assertEquals ( 2 , messageRecorder . sent . size ( ) ) ; <nl> @ @ - 224 , 6 + 245 , 7 @ @ public class DataResolverTest <nl> assertFalse ( rows . hasNext ( ) ) ; <nl> assertFalse ( data . hasNext ( ) ) ; <nl> } <nl> + assertRepairFuture ( resolver , 2 ) ; <nl> } <nl> <nl> assertEquals ( 2 , messageRecorder . sent . size ( ) ) ; <nl> @ @ - 289 , 6 + 311 , 7 @ @ public class DataResolverTest <nl> <nl> assertFalse ( rows . hasNext ( ) ) ; <nl> } <nl> + assertRepairFuture ( resolver , 4 ) ; <nl> } <nl> <nl> assertEquals ( 4 , messageRecorder . sent . size ( ) ) ; <nl> @ @ - 330 , 12 + 353 , 15 @ @ public class DataResolverTest <nl> InetAddress peer2 = peer ( ) ; <nl> resolver . preprocess ( readResponseMessage ( peer2 , EmptyIterators . unfilteredPartition ( cfm , false ) ) ) ; <nl> <nl> - try ( PartitionIterator data = resolver . resolve ( ) ; <nl> - RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> - Row row = Iterators . getOnlyElement ( rows ) ; <nl> - assertColumns ( row , " c2 " ) ; <nl> - assertColumn ( cfm , row , " c2 " , " v2 " , 1 ) ; <nl> + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + { <nl> + Row row = Iterators . getOnlyElement ( rows ) ; <nl> + assertColumns ( row , " c2 " ) ; <nl> + assertColumn ( cfm , row , " c2 " , " v2 " , 1 ) ; <nl> + } <nl> + assertRepairFuture ( resolver , 1 ) ; <nl> } <nl> <nl> assertEquals ( 1 , messageRecorder . sent . size ( ) ) ; <nl> @ @ - 356 , 6 + 382 , 7 @ @ public class DataResolverTest <nl> try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> assertFalse ( data . hasNext ( ) ) ; <nl> + assertRepairFuture ( resolver , 0 ) ; <nl> } <nl> <nl> assertTrue ( messageRecorder . sent . isEmpty ( ) ) ; <nl> @ @ - 376 , 6 + 403 , 7 @ @ public class DataResolverTest <nl> try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> assertFalse ( data . hasNext ( ) ) ; <nl> + assertRepairFuture ( resolver , 1 ) ; <nl> } <nl> <nl> / / peer1 should get the deletion from peer2 <nl> @ @ - 407 , 12 + 435 , 15 @ @ public class DataResolverTest <nl> InetAddress peer4 = peer ( ) ; <nl> resolver . preprocess ( readResponseMessage ( peer4 , fullPartitionDelete ( cfm , dk , 2 , nowInSec ) ) ) ; <nl> <nl> - try ( PartitionIterator data = resolver . resolve ( ) ; <nl> - RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> - Row row = Iterators . getOnlyElement ( rows ) ; <nl> - assertColumns ( row , " two " ) ; <nl> - assertColumn ( cfm , row , " two " , " B " , 3 ) ; <nl> + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + { <nl> + Row row = Iterators . getOnlyElement ( rows ) ; <nl> + assertColumns ( row , " two " ) ; <nl> + assertColumn ( cfm , row , " two " , " B " , 3 ) ; <nl> + } <nl> + assertRepairFuture ( resolver , 4 ) ; <nl> } <nl> <nl> / / peer 1 needs to get the partition delete from peer 4 and the row from peer 3 <nl> @ @ - 498 , 6 + 529 , 7 @ @ public class DataResolverTest <nl> try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> assertFalse ( data . hasNext ( ) ) ; <nl> + assertRepairFuture ( resolver , 2 ) ; <nl> } <nl> <nl> assertEquals ( 2 , messageRecorder . sent . size ( ) ) ; <nl> @ @ - 575 , 12 + 607 , 16 @ @ public class DataResolverTest <nl> InetAddress peer2 = peer ( ) ; <nl> resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; <nl> <nl> - try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> - Row row = Iterators . getOnlyElement ( rows ) ; <nl> - assertColumns ( row , " m " ) ; <nl> - Assert . assertNull ( row . getCell ( m , CellPath . create ( bb ( 0 ) ) ) ) ; <nl> - Assert . assertNotNull ( row . getCell ( m , CellPath . create ( bb ( 1 ) ) ) ) ; <nl> + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + { <nl> + Row row = Iterators . getOnlyElement ( rows ) ; <nl> + assertColumns ( row , " m " ) ; <nl> + Assert . assertNull ( row . getCell ( m , CellPath . create ( bb ( 0 ) ) ) ) ; <nl> + Assert . assertNotNull ( row . getCell ( m , CellPath . create ( bb ( 1 ) ) ) ) ; <nl> + } <nl> + assertRepairFuture ( resolver , 1 ) ; <nl> } <nl> <nl> MessageOut < Mutation > msg ; <nl> @ @ - 625 , 6 + 661 , 7 @ @ public class DataResolverTest <nl> try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> assertFalse ( data . hasNext ( ) ) ; <nl> + assertRepairFuture ( resolver , 1 ) ; <nl> } <nl> <nl> MessageOut < Mutation > msg ; <nl> @ @ - 665 , 12 + 702 , 16 @ @ public class DataResolverTest <nl> InetAddress peer2 = peer ( ) ; <nl> resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . emptyUpdate ( cfm2 , dk ) ) ) ) ; <nl> <nl> - try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> - Row row = Iterators . getOnlyElement ( rows ) ; <nl> - assertColumns ( row , " m " ) ; <nl> - ComplexColumnData cd = row . getComplexColumnData ( m ) ; <nl> - assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; <nl> + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + { <nl> + Row row = Iterators . getOnlyElement ( rows ) ; <nl> + assertColumns ( row , " m " ) ; <nl> + ComplexColumnData cd = row . getComplexColumnData ( m ) ; <nl> + assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; <nl> + } <nl> + assertRepairFuture ( resolver , 1 ) ; <nl> } <nl> <nl> Assert . assertNull ( messageRecorder . sent . get ( peer1 ) ) ; <nl> @ @ - 714 , 12 + 755 , 16 @ @ public class DataResolverTest <nl> InetAddress peer2 = peer ( ) ; <nl> resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; <nl> <nl> - try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + try ( PartitionIterator data = resolver . resolve ( ) ) <nl> { <nl> - Row row = Iterators . getOnlyElement ( rows ) ; <nl> - assertColumns ( row , " m " ) ; <nl> - ComplexColumnData cd = row . getComplexColumnData ( m ) ; <nl> - assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; <nl> + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) <nl> + { <nl> + Row row = Iterators . getOnlyElement ( rows ) ; <nl> + assertColumns ( row , " m " ) ; <nl> + ComplexColumnData cd = row . getComplexColumnData ( m ) ; <nl> + assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; <nl> + } <nl> + assertRepairFuture ( resolver , 1 ) ; <nl> } <nl> <nl> MessageOut < Mutation > msg ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / Column . java b / src / java / org / apache / cassandra / db / Column . java <nl> index 3de7f14 . . ea67ca4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Column . java <nl> + + + b / src / java / org / apache / cassandra / db / Column . java <nl> @ @ - 23 , 6 + 23 , 7 @ @ import java . nio . ByteBuffer ; <nl> import java . security . MessageDigest ; <nl> import java . io . IOException ; <nl> <nl> + import org . apache . log4j . Logger ; <nl> import org . apache . commons . lang . ArrayUtils ; <nl> <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> @ @ - 37 , 6 + 38 , 8 @ @ import org . apache . cassandra . io . DataOutputBuffer ; <nl> <nl> public final class Column implements IColumn <nl> { <nl> + private static Logger logger _ = Logger . getLogger ( Column . class ) ; <nl> + <nl> private static ColumnSerializer serializer _ = new ColumnSerializer ( ) ; <nl> <nl> public static ColumnSerializer serializer ( ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadResponse . java b / src / java / org / apache / cassandra / db / ReadResponse . java <nl> index 2fde8b4 . . 5eb94f5 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadResponse . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadResponse . java <nl> @ @ - 115 , 20 + 115 , 12 @ @ class ReadResponseSerializer implements ICompactSerializer < ReadResponse > <nl> boolean isDigest = dis . readBoolean ( ) ; <nl> <nl> Row row = null ; <nl> - if ( ! isDigest ) <nl> + if ( ! isDigest ) <nl> { <nl> row = Row . serializer ( ) . deserialize ( dis ) ; <nl> } <nl> - 	 	 <nl> - 	 	 ReadResponse rmsg = null ; <nl> - 	 if ( isDigest ) <nl> - { <nl> - 	 	 rmsg = new ReadResponse ( digest ) ; <nl> - } <nl> - 	 else <nl> - { <nl> - 	 	 rmsg = new ReadResponse ( row ) ; <nl> - } <nl> + <nl> + ReadResponse rmsg = isDigest ? new ReadResponse ( digest ) : new ReadResponse ( row ) ; <nl> rmsg . setIsDigestQuery ( isDigest ) ; <nl> 	 return rmsg ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadVerbHandler . java b / src / java / org / apache / cassandra / db / ReadVerbHandler . java <nl> index 9370705 . . d02422f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadVerbHandler . java <nl> @ @ - 75 , 9 + 75 , 8 @ @ public class ReadVerbHandler implements IVerbHandler <nl> } <nl> ReadCommand readCommand = ReadCommand . serializer ( ) . deserialize ( readCtx . bufIn _ ) ; <nl> Table table = Table . open ( readCommand . table ) ; <nl> - Row row = null ; <nl> - row = readCommand . getRow ( table ) ; <nl> - ReadResponse readResponse = null ; <nl> + Row row = readCommand . getRow ( table ) ; <nl> + ReadResponse readResponse ; <nl> if ( readCommand . isDigestQuery ( ) ) <nl> { <nl> readResponse = new ReadResponse ( row . digest ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / Row . java b / src / java / org / apache / cassandra / db / Row . java <nl> index 13e5877 . . 5f7c6ba 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Row . java <nl> + + + b / src / java / org / apache / cassandra / db / Row . java <nl> @ @ - 29 , 13 + 29 , 11 @ @ import java . util . Arrays ; <nl> import java . security . MessageDigest ; <nl> import java . security . NoSuchAlgorithmException ; <nl> <nl> - import org . apache . commons . lang . ArrayUtils ; <nl> import org . apache . commons . lang . StringUtils ; <nl> import org . apache . log4j . Logger ; <nl> <nl> import org . apache . cassandra . io . ICompactSerializer ; <nl> import org . apache . cassandra . io . DataOutputBuffer ; <nl> - import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> public class Row <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / ConsistencyManager . java b / src / java / org / apache / cassandra / service / ConsistencyManager . java <nl> index 69c3296 . . 3eafee6 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ConsistencyManager . java <nl> + + + b / src / java / org / apache / cassandra / service / ConsistencyManager . java <nl> @ @ - 23 , 7 + 23 , 6 @ @ import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . List ; <nl> <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . ReadCommand ; <nl> import org . apache . cassandra . db . ReadResponse ; <nl> import org . apache . cassandra . db . Row ; <nl> @ @ - 129 , 21 + 128 , 17 @ @ class ConsistencyManager implements Runnable <nl> 	 	 <nl> 	 	 public void callMe ( String key , String value ) <nl> 	 	 { <nl> - 	 	 	 handleResponses ( ) ; <nl> - 	 	 } <nl> - 	 	 <nl> - 	 	 private void handleResponses ( ) <nl> - 	 	 { <nl> - 	 	 	 try <nl> + try <nl> 	 	 	 { <nl> 	 	 	 	 readResponseResolver _ . resolve ( new ArrayList < Message > ( responses _ ) ) ; <nl> - 	 	 	 } <nl> - 	 	 	 catch ( DigestMismatchException ex ) <nl> - 	 	 	 { <nl> - 	 	 	 	 throw new RuntimeException ( ex ) ; <nl> - 	 	 	 } <nl> - 	 	 } <nl> - 	 } <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + throw new RuntimeException ( ex ) ; <nl> + } <nl> + } <nl> + <nl> + } <nl> <nl> 	 private static long scheduledTimeMillis _ = 600 ; <nl> 	 private static ICachetable < String , String > readRepairTable _ = new Cachetable < String , String > ( scheduledTimeMillis _ ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / IResponseResolver . java b / src / java / org / apache / cassandra / service / IResponseResolver . java <nl> index 8b897f7 . . 0daf593 100644 <nl> - - - a / src / java / org / apache / cassandra / service / IResponseResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / IResponseResolver . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ <nl> package org . apache . cassandra . service ; <nl> <nl> import java . util . List ; <nl> + import java . io . IOException ; <nl> <nl> import org . apache . cassandra . net . Message ; <nl> <nl> @ @ - 32 , 7 + 33 , 7 @ @ public interface IResponseResolver < T > { <nl> 	 * repairs . Hence you need to derive a response resolver based on your <nl> 	 * needs from this interface . <nl> 	 * / <nl> - 	 public T resolve ( List < Message > responses ) throws DigestMismatchException ; <nl> + 	 public T resolve ( List < Message > responses ) throws DigestMismatchException , IOException ; <nl> 	 public boolean isDataPresent ( List < Message > responses ) ; <nl> <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / QuorumResponseHandler . java b / src / java / org / apache / cassandra / service / QuorumResponseHandler . java <nl> index 840d9a0 . . 3e9c595 100644 <nl> - - - a / src / java / org / apache / cassandra / service / QuorumResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / QuorumResponseHandler . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import java . util . concurrent . atomic . AtomicBoolean ; <nl> import java . util . concurrent . locks . * ; <nl> import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . TimeoutException ; <nl> + import java . io . IOException ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . net . IAsyncCallback ; <nl> @ @ - 55 , 64 + 56 , 67 @ @ public class QuorumResponseHandler < T > implements IAsyncCallback <nl> startTime _ = System . currentTimeMillis ( ) ; <nl> } <nl> <nl> - public T get ( ) throws TimeoutException , DigestMismatchException <nl> + public T get ( ) throws TimeoutException , DigestMismatchException , IOException <nl> { <nl> - 	 lock _ . lock ( ) ; <nl> + lock _ . lock ( ) ; <nl> try <nl> - { <nl> - boolean bVal = true ; <nl> + { <nl> + boolean bVal = true ; <nl> try <nl> { <nl> - 	 if ( ! done _ . get ( ) ) <nl> + if ( ! done _ . get ( ) ) <nl> { <nl> long timeout = System . currentTimeMillis ( ) - startTime _ + DatabaseDescriptor . getRpcTimeout ( ) ; <nl> - if ( timeout > 0 ) <nl> + if ( timeout > 0 ) <nl> + { <nl> bVal = condition _ . await ( timeout , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> else <nl> + { <nl> bVal = false ; <nl> + } <nl> } <nl> } <nl> - catch ( InterruptedException ex ) <nl> + catch ( InterruptedException ex ) <nl> { <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( LogUtil . throwableToString ( ex ) ) ; <nl> + throw new AssertionError ( ex ) ; <nl> } <nl> - <nl> - if ( ! bVal & & ! done _ . get ( ) ) <nl> + <nl> + if ( ! bVal & & ! done _ . get ( ) ) <nl> { <nl> StringBuilder sb = new StringBuilder ( " " ) ; <nl> - for ( Message message : responses _ ) <nl> + for ( Message message : responses _ ) <nl> { <nl> - sb . append ( message . getFrom ( ) ) ; <nl> - } <nl> - throw new TimeoutException ( " Operation timed out - received only " + responses _ . size ( ) + " responses from " + sb . toString ( ) + " . " ) ; <nl> + sb . append ( message . getFrom ( ) ) ; <nl> + } <nl> + throw new TimeoutException ( " Operation timed out - received only " + responses _ . size ( ) + " responses from " + sb . toString ( ) + " . " ) ; <nl> } <nl> } <nl> finally <nl> { <nl> lock _ . unlock ( ) ; <nl> - for ( Message response : responses _ ) <nl> + for ( Message response : responses _ ) <nl> { <nl> - 	 MessagingService . removeRegisteredCallback ( response . getMessageId ( ) ) ; <nl> + MessagingService . removeRegisteredCallback ( response . getMessageId ( ) ) ; <nl> } <nl> } <nl> <nl> - 	 return responseResolver _ . resolve ( responses _ ) ; <nl> + return responseResolver _ . resolve ( responses _ ) ; <nl> } <nl> <nl> public void response ( Message message ) <nl> { <nl> lock _ . lock ( ) ; <nl> try <nl> - { <nl> - if ( ! done _ . get ( ) ) <nl> + { <nl> + if ( ! done _ . get ( ) ) <nl> { <nl> - 	 responses _ . add ( message ) ; <nl> - 	 if ( responses _ . size ( ) > = responseCount _ & & responseResolver _ . isDataPresent ( responses _ ) ) <nl> - 	 { <nl> - 	 	 done _ . set ( true ) ; <nl> - 	 	 condition _ . signal ( ) ; 	 <nl> - 	 } <nl> + responses _ . add ( message ) ; <nl> + if ( responses _ . size ( ) > = responseCount _ & & responseResolver _ . isDataPresent ( responses _ ) ) <nl> + { <nl> + done _ . set ( true ) ; <nl> + condition _ . signal ( ) ; <nl> + } <nl> } <nl> } <nl> finally <nl> diff - - git a / src / java / org / apache / cassandra / service / ReadResponseResolver . java b / src / java / org / apache / cassandra / service / ReadResponseResolver . java <nl> index f02c017 . . 2d06f48 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ReadResponseResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / ReadResponseResolver . java <nl> @ @ - 54 , 8 + 54 , 8 @ @ public class ReadResponseResolver implements IResponseResolver < Row > <nl> 	 * repair request should be scheduled . <nl> 	 * <nl> 	 * / <nl> - 	 public Row resolve ( List < Message > responses ) throws DigestMismatchException <nl> - 	 { <nl> + 	 public Row resolve ( List < Message > responses ) throws DigestMismatchException , IOException <nl> + { <nl> long startTime = System . currentTimeMillis ( ) ; <nl> 	 	 Row retRow = null ; <nl> 	 	 List < Row > rowList = new ArrayList < Row > ( ) ; <nl> @ @ - 76 , 38 + 76 , 31 @ @ public class ReadResponseResolver implements IResponseResolver < Row > <nl> 	 	 { 	 	 	 	 	 <nl> byte [ ] body = response . getMessageBody ( ) ; <nl> bufIn . reset ( body , body . length ) ; <nl> - try <nl> + long start = System . currentTimeMillis ( ) ; <nl> + ReadResponse result = ReadResponse . serializer ( ) . deserialize ( bufIn ) ; <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( " Response deserialization time : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; <nl> + if ( result . isDigestQuery ( ) ) <nl> { <nl> - long start = System . currentTimeMillis ( ) ; <nl> - ReadResponse result = ReadResponse . serializer ( ) . deserialize ( bufIn ) ; <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " Response deserialization time : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; <nl> - 	 	 	 if ( ! result . isDigestQuery ( ) ) <nl> - 	 	 	 { <nl> - 	 	 	 	 rowList . add ( result . row ( ) ) ; <nl> - 	 	 	 	 endPoints . add ( response . getFrom ( ) ) ; <nl> - 	 	 	 	 key = result . row ( ) . key ( ) ; <nl> - 	 	 	 	 table = result . row ( ) . getTable ( ) ; <nl> - 	 	 	 } <nl> - 	 	 	 else <nl> - 	 	 	 { <nl> - 	 	 	 	 digest = result . digest ( ) ; <nl> - 	 	 	 	 isDigestQuery = true ; <nl> - 	 	 	 } <nl> + digest = result . digest ( ) ; <nl> + isDigestQuery = true ; <nl> } <nl> - catch ( IOException ex ) <nl> + else <nl> { <nl> - logger _ . info ( LogUtil . throwableToString ( ex ) ) ; <nl> + rowList . add ( result . row ( ) ) ; <nl> + endPoints . add ( response . getFrom ( ) ) ; <nl> + key = result . row ( ) . key ( ) ; <nl> + table = result . row ( ) . getTable ( ) ; <nl> } <nl> - 	 	 } <nl> + } <nl> 	 	 / / If there was a digest query compare it with all the data digests <nl> 	 	 / / If there is a mismatch then throw an exception so that read repair can happen . <nl> - 	 	 if ( isDigestQuery ) <nl> - 	 	 { <nl> - 	 	 	 for ( Row row : rowList ) <nl> - 	 	 	 { <nl> - 	 	 	 	 if ( ! Arrays . equals ( row . digest ( ) , digest ) ) <nl> - 	 	 	 	 { <nl> + if ( isDigestQuery ) <nl> + { <nl> + for ( Row row : rowList ) <nl> + { <nl> + if ( ! Arrays . equals ( row . digest ( ) , digest ) ) <nl> + { <nl> / * Wrap the key as the context in this exception * / <nl> 	 	 	 	 	 throw new DigestMismatchException ( row . key ( ) ) ; <nl> 	 	 	 	 } <nl> @ @ - 115 , 36 + 108 , 36 @ @ public class ReadResponseResolver implements IResponseResolver < Row > <nl> 	 	 } <nl> 	 	 <nl> / * If the rowList is empty then we had some exception above . * / <nl> - if ( rowList . size ( ) = = 0 ) <nl> + if ( rowList . size ( ) = = 0 ) <nl> { <nl> return retRow ; <nl> } <nl> - <nl> + <nl> / * Now calculate the resolved row * / <nl> - 	 	 retRow = new Row ( table , key ) ; <nl> - 	 	 for ( int i = 0 ; i < rowList . size ( ) ; i + + ) <nl> - 	 	 { <nl> - 	 	 	 retRow . repair ( rowList . get ( i ) ) ; 	 	 	 <nl> - 	 	 } <nl> + retRow = new Row ( table , key ) ; <nl> + for ( int i = 0 ; i < rowList . size ( ) ; i + + ) <nl> + { <nl> + retRow . repair ( rowList . get ( i ) ) ; <nl> + } <nl> <nl> / / At this point we have the return row . <nl> - 	 	 / / Now we need to calculate the difference <nl> - 	 	 / / so that we can schedule read repairs <nl> - 	 	 for ( int i = 0 ; i < rowList . size ( ) ; i + + ) <nl> - 	 	 { <nl> - 	 	 	 / / since retRow is the resolved row it can be used as the super set <nl> - 	 	 	 Row diffRow = rowList . get ( i ) . diff ( retRow ) ; <nl> - 	 	 	 if ( diffRow = = null ) / / no repair needs to happen <nl> - 	 	 	 	 continue ; <nl> - 	 	 	 / / create the row mutation message based on the diff and schedule a read repair <nl> - 	 	 	 RowMutation rowMutation = new RowMutation ( table , key ) ; 	 	 	 <nl> - 	 for ( ColumnFamily cf : diffRow . getColumnFamilies ( ) ) <nl> - 	 { <nl> - 	 rowMutation . add ( cf ) ; <nl> - 	 } <nl> + / / Now we need to calculate the difference <nl> + / / so that we can schedule read repairs <nl> + for ( int i = 0 ; i < rowList . size ( ) ; i + + ) <nl> + { <nl> + / / since retRow is the resolved row it can be used as the super set <nl> + Row diffRow = rowList . get ( i ) . diff ( retRow ) ; <nl> + if ( diffRow = = null ) / / no repair needs to happen <nl> + continue ; <nl> + / / create the row mutation message based on the diff and schedule a read repair <nl> + RowMutation rowMutation = new RowMutation ( table , key ) ; <nl> + for ( ColumnFamily cf : diffRow . getColumnFamilies ( ) ) <nl> + { <nl> + rowMutation . add ( cf ) ; <nl> + } <nl> RowMutationMessage rowMutationMessage = new RowMutationMessage ( rowMutation ) ; <nl> - 	 ReadRepairManager . instance ( ) . schedule ( endPoints . get ( i ) , rowMutationMessage ) ; <nl> - 	 	 } <nl> + ReadRepairManager . instance ( ) . schedule ( endPoints . get ( i ) , rowMutationMessage ) ; <nl> + } <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " resolve : " + ( System . currentTimeMillis ( ) - startTime ) + " ms . " ) ; <nl> 	 	 return retRow ; <nl> @ @ - 152 , 26 + 145 , 26 @ @ public class ReadResponseResolver implements IResponseResolver < Row > <nl> <nl> 	 public boolean isDataPresent ( List < Message > responses ) <nl> 	 { <nl> - 	 	 boolean isDataPresent = false ; <nl> - 	 	 for ( Message response : responses ) <nl> - 	 	 { <nl> + boolean isDataPresent = false ; <nl> + for ( Message response : responses ) <nl> + { <nl> byte [ ] body = response . getMessageBody ( ) ; <nl> - 	 	 	 DataInputBuffer bufIn = new DataInputBuffer ( ) ; <nl> + DataInputBuffer bufIn = new DataInputBuffer ( ) ; <nl> bufIn . reset ( body , body . length ) ; <nl> try <nl> { <nl> - 	 	 	 ReadResponse result = ReadResponse . serializer ( ) . deserialize ( bufIn ) ; <nl> - 	 	 	 if ( ! result . isDigestQuery ( ) ) <nl> - 	 	 	 { <nl> - 	 	 	 	 isDataPresent = true ; <nl> - 	 	 	 } <nl> + ReadResponse result = ReadResponse . serializer ( ) . deserialize ( bufIn ) ; <nl> + if ( ! result . isDigestQuery ( ) ) <nl> + { <nl> + isDataPresent = true ; <nl> + } <nl> bufIn . close ( ) ; <nl> } <nl> - catch ( IOException ex ) <nl> + catch ( IOException ex ) <nl> { <nl> logger _ . info ( LogUtil . throwableToString ( ex ) ) ; <nl> - } <nl> - 	 	 } <nl> - 	 	 return isDataPresent ; <nl> - 	 } <nl> + } <nl> + } <nl> + return isDataPresent ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index e3e2e27 . . d183f3e 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 352 , 10 + 352 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> Message message = command . makeReadMessage ( ) ; <nl> Message messageDigestOnly = readMessageDigestOnly . makeReadMessage ( ) ; <nl> <nl> - IResponseResolver < Row > readResponseResolver = new ReadResponseResolver ( ) ; <nl> - QuorumResponseHandler < Row > quorumResponseHandler = new QuorumResponseHandler < Row > ( <nl> - DatabaseDescriptor . getQuorum ( ) , <nl> - readResponseResolver ) ; <nl> + QuorumResponseHandler < Row > quorumResponseHandler = new QuorumResponseHandler < Row > ( DatabaseDescriptor . getQuorum ( ) , new ReadResponseResolver ( ) ) ; <nl> EndPoint dataPoint = StorageService . instance ( ) . findSuitableEndPoint ( command . key ) ; <nl> List < EndPoint > endpointList = new ArrayList < EndPoint > ( Arrays . asList ( StorageService . instance ( ) . getReadStorageEndPoints ( command . key ) ) ) ; <nl> / * Remove the local storage endpoint from the list . * / <nl> @ @ - 401 , 7 + 398 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> catch ( DigestMismatchException ex ) <nl> { <nl> - if ( DatabaseDescriptor . getConsistencyCheck ( ) ) <nl> + if ( DatabaseDescriptor . getConsistencyCheck ( ) ) <nl> { <nl> IResponseResolver < Row > readResponseResolverRepair = new ReadResponseResolver ( ) ; <nl> QuorumResponseHandler < Row > quorumResponseHandlerRepair = new QuorumResponseHandler < Row > ( <nl> @ @ - 409 , 8 + 406 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> readResponseResolverRepair ) ; <nl> logger . info ( " DigestMismatchException : " + command . key ) ; <nl> Message messageRepair = command . makeReadMessage ( ) ; <nl> - MessagingService . getMessagingInstance ( ) . sendRR ( messageRepair , commandEndPoints . get ( commandIndex ) , <nl> - quorumResponseHandlerRepair ) ; <nl> + MessagingService . getMessagingInstance ( ) . sendRR ( messageRepair , commandEndPoints . get ( commandIndex ) , quorumResponseHandlerRepair ) ; <nl> try <nl> { <nl> row = quorumResponseHandlerRepair . get ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / utils / FBUtilities . java b / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> index b85f57a . . dc158eb 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> + + + b / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> @ @ - 398 , 15 + 398 , 12 @ @ public class FBUtilities <nl> return bytes ; <nl> } <nl> <nl> - public static String bytesToHex ( byte [ ] buf ) <nl> + public static String bytesToHex ( byte [ ] bytes ) <nl> { <nl> - char [ ] chars = new char [ 2 * buf . length ] ; <nl> - for ( int i = 0 ; i < buf . length ; i + + ) <nl> - { <nl> - chars [ i * 2 ] = HEX _ CHARS [ ( buf [ i ] & 0xF0 ) > > > 4 ] ; <nl> - chars [ i * 2 + 1 ] = HEX _ CHARS [ buf [ i ] & 0x0F ] ; <nl> - } <nl> - return new String ( chars ) ; <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + for ( byte b : bytes ) <nl> + sb . append ( Integer . toHexString ( b & 0xff ) ) ; <nl> + return sb . toString ( ) ; <nl> } <nl> <nl> public static String mapToString ( Map < ? , ? > map )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 97d49af . . 6293cfa 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 11 
 + * Read repair is not blocking repair to finish in foreground repair ( CASSANDRA - 13115 ) 
 * Stress daemon help is incorrect ( CASSANDRA - 12563 ) 
 * Remove ALTER TYPE support ( CASSANDRA - 12443 ) 
 * Fix assertion for certain legacy range tombstone pattern ( CASSANDRA - 12203 ) 
 diff - - git a / src / java / org / apache / cassandra / db / partitions / UnfilteredPartitionIterators . java b / src / java / org / apache / cassandra / db / partitions / UnfilteredPartitionIterators . java 
 index 41b1424 . . 1abbb19 100644 
 - - - a / src / java / org / apache / cassandra / db / partitions / UnfilteredPartitionIterators . java 
 + + + b / src / java / org / apache / cassandra / db / partitions / UnfilteredPartitionIterators . java 
 @ @ - 159 , 6 + 159 , 7 @ @ public abstract class UnfilteredPartitionIterators 
 public void close ( ) 
 { 
 merged . close ( ) ; 
 + listener . close ( ) ; 
 } 
 } ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / AsyncRepairCallback . java b / src / java / org / apache / cassandra / service / AsyncRepairCallback . java 
 index dec5319 . . d613f3d 100644 
 - - - a / src / java / org / apache / cassandra / service / AsyncRepairCallback . java 
 + + + b / src / java / org / apache / cassandra / service / AsyncRepairCallback . java 
 @ @ - 17 , 7 + 17 , 6 @ @ 
 * / 
 package org . apache . cassandra . service ; 
 
 - import java . io . IOException ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 
 import org . apache . cassandra . concurrent . Stage ; 
 @ @ - 46 , 9 + 45 , 9 @ @ public class AsyncRepairCallback implements IAsyncCallback < ReadResponse > 
 { 
 StageManager . getStage ( Stage . READ _ REPAIR ) . execute ( new WrappedRunnable ( ) 
 { 
 - protected void runMayThrow ( ) throws DigestMismatchException , IOException 
 + protected void runMayThrow ( ) 
 { 
 - repairResolver . resolve ( ) ; 
 + repairResolver . compareResponses ( ) ; 
 } 
 } ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / DataResolver . java b / src / java / org / apache / cassandra / service / DataResolver . java 
 index 4e5bfb8 . . 01953e1 100644 
 - - - a / src / java / org / apache / cassandra / service / DataResolver . java 
 + + + b / src / java / org / apache / cassandra / service / DataResolver . java 
 @ @ - 21 , 6 + 21 , 8 @ @ import java . net . InetAddress ; 
 import java . util . * ; 
 import java . util . concurrent . TimeoutException ; 
 
 + import com . google . common . annotations . VisibleForTesting ; 
 + 
 import org . apache . cassandra . concurrent . Stage ; 
 import org . apache . cassandra . concurrent . StageManager ; 
 import org . apache . cassandra . config . CFMetaData ; 
 @ @ - 40 , 7 + 42 , 8 @ @ import org . apache . cassandra . utils . FBUtilities ; 
 
 public class DataResolver extends ResponseResolver 
 { 
 - private final List < AsyncOneResponse > repairResults = Collections . synchronizedList ( new ArrayList < > ( ) ) ; 
 + @ VisibleForTesting 
 + final List < AsyncOneResponse > repairResults = Collections . synchronizedList ( new ArrayList < > ( ) ) ; 
 
 public DataResolver ( Keyspace keyspace , ReadCommand command , ConsistencyLevel consistency , int maxResponseCount ) 
 { 
 @ @ - 73 , 6 + 76 , 15 @ @ public class DataResolver extends ResponseResolver 
 return counter . applyTo ( mergeWithShortReadProtection ( iters , sources , counter ) ) ; 
 } 
 
 + public void compareResponses ( ) 
 + { 
 + / / We need to fully consume the results to trigger read repairs if appropriate 
 + try ( PartitionIterator iterator = resolve ( ) ) 
 + { 
 + PartitionIterators . consume ( iterator ) ; 
 + } 
 + } 
 + 
 private PartitionIterator mergeWithShortReadProtection ( List < UnfilteredPartitionIterator > results , InetAddress [ ] sources , DataLimits . Counter resultCounter ) 
 { 
 / / If we have only one results , there is no read repair to do and we can ' t get short reads 
 diff - - git a / src / java / org / apache / cassandra / service / DigestResolver . java b / src / java / org / apache / cassandra / service / DigestResolver . java 
 index 4a918a3 . . 6a528e9 100644 
 - - - a / src / java / org / apache / cassandra / service / DigestResolver . java 
 + + + b / src / java / org / apache / cassandra / service / DigestResolver . java 
 @ @ - 69 , 6 + 69 , 13 @ @ public class DigestResolver extends ResponseResolver 
 if ( logger . isTraceEnabled ( ) ) 
 logger . trace ( " resolving { } responses " , responses . size ( ) ) ; 
 
 + compareResponses ( ) ; 
 + 
 + return UnfilteredPartitionIterators . filter ( dataResponse . makeIterator ( command ) , command . nowInSec ( ) ) ; 
 + } 
 + 
 + public void compareResponses ( ) throws DigestMismatchException 
 + { 
 long start = System . nanoTime ( ) ; 
 
 / / validate digests against each other ; throw immediately on mismatch . 
 @ @ - 87 , 8 + 94 , 6 @ @ public class DigestResolver extends ResponseResolver 
 
 if ( logger . isTraceEnabled ( ) ) 
 logger . trace ( " resolve : { } ms . " , TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ; 
 - 
 - return UnfilteredPartitionIterators . filter ( dataResponse . makeIterator ( command ) , command . nowInSec ( ) ) ; 
 } 
 
 public boolean isDataPresent ( ) 
 diff - - git a / src / java / org / apache / cassandra / service / ReadCallback . java b / src / java / org / apache / cassandra / service / ReadCallback . java 
 index 8747004 . . 516384a 100644 
 - - - a / src / java / org / apache / cassandra / service / ReadCallback . java 
 + + + b / src / java / org / apache / cassandra / service / ReadCallback . java 
 @ @ - 219 , 10 + 219 , 10 @ @ public class ReadCallback implements IAsyncCallbackWithFailure < ReadResponse > 
 { 
 / / If the resolver is a DigestResolver , we need to do a full data read if there is a mismatch . 
 / / Otherwise , resolve will send the repairs directly if needs be ( and in that case we should never 
 - / / get a digest mismatch ) 
 + / / get a digest mismatch ) . 
 try 
 { 
 - resolver . resolve ( ) ; 
 + resolver . compareResponses ( ) ; 
 } 
 catch ( DigestMismatchException e ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / ResponseResolver . java b / src / java / org / apache / cassandra / service / ResponseResolver . java 
 index e7c94a1 . . 81b18b6 100644 
 - - - a / src / java / org / apache / cassandra / service / ResponseResolver . java 
 + + + b / src / java / org / apache / cassandra / service / ResponseResolver . java 
 @ @ - 47 , 6 + 47 , 18 @ @ public abstract class ResponseResolver 
 public abstract PartitionIterator getData ( ) ; 
 public abstract PartitionIterator resolve ( ) throws DigestMismatchException ; 
 
 + / * * 
 + * Compares received responses , potentially triggering a digest mismatch ( for a digest resolver ) and read - repairs 
 + * ( for a data resolver ) . 
 + * < p > 
 + * This is functionally equivalent to calling { @ link # resolve ( ) } and consuming the result , but can be slightly more 
 + * efficient in some case due to the fact that we don ' t care about the result itself . This is used when doing 
 + * asynchronous read - repairs . 
 + * 
 + * @ throws DigestMismatchException if it ' s a digest resolver and the responses don ' t match . 
 + * / 
 + public abstract void compareResponses ( ) throws DigestMismatchException ; 
 + 
 public abstract boolean isDataPresent ( ) ; 
 
 public void preprocess ( MessageIn < ReadResponse > message ) 
 diff - - git a / test / unit / org / apache / cassandra / service / DataResolverTest . java b / test / unit / org / apache / cassandra / service / DataResolverTest . java 
 index c9878d4 . . fd1e54e 100644 
 - - - a / test / unit / org / apache / cassandra / service / DataResolverTest . java 
 + + + b / test / unit / org / apache / cassandra / service / DataResolverTest . java 
 @ @ - 129 , 6 + 129 , 21 @ @ public class DataResolverTest 
 MessagingService . instance ( ) . clearMessageSinks ( ) ; 
 } 
 
 + / * * 
 + * Checks that the provided data resolver has the expected number of repair futures created . 
 + * This method also " release " those future by faking replica responses to those repair , which is necessary or 
 + * every test would timeout when closing the result of resolver . resolve ( ) , since it waits on those futures . 
 + * / 
 + private void assertRepairFuture ( DataResolver resolver , int expectedRepairs ) 
 + { 
 + assertEquals ( expectedRepairs , resolver . repairResults . size ( ) ) ; 
 + 
 + / / Signal all future . We pass a completely fake response message , but it doesn ' t matter as we just want 
 + / / AsyncOneResponse to signal success , and it only cares about a non - null MessageIn ( it collects the payload ) . 
 + for ( AsyncOneResponse < ? > future : resolver . repairResults ) 
 + future . response ( MessageIn . create ( null , null , null , null , - 1 ) ) ; 
 + } 
 + 
 @ Test 
 public void testResolveNewerSingleRow ( ) throws UnknownHostException 
 { 
 @ @ - 142 , 12 + 157 , 15 @ @ public class DataResolverTest 
 . add ( " c1 " , " v2 " ) 
 . buildUpdate ( ) ) ) ) ; 
 
 - try ( PartitionIterator data = resolver . resolve ( ) ; 
 - RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 - Row row = Iterators . getOnlyElement ( rows ) ; 
 - assertColumns ( row , " c1 " ) ; 
 - assertColumn ( cfm , row , " c1 " , " v2 " , 1 ) ; 
 + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + { 
 + Row row = Iterators . getOnlyElement ( rows ) ; 
 + assertColumns ( row , " c1 " ) ; 
 + assertColumn ( cfm , row , " c1 " , " v2 " , 1 ) ; 
 + } 
 + assertRepairFuture ( resolver , 1 ) ; 
 } 
 
 assertEquals ( 1 , messageRecorder . sent . size ( ) ) ; 
 @ @ - 172 , 13 + 190 , 16 @ @ public class DataResolverTest 
 . add ( " c2 " , " v2 " ) 
 . buildUpdate ( ) ) ) ) ; 
 
 - try ( PartitionIterator data = resolver . resolve ( ) ; 
 - RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 - Row row = Iterators . getOnlyElement ( rows ) ; 
 - assertColumns ( row , " c1 " , " c2 " ) ; 
 - assertColumn ( cfm , row , " c1 " , " v1 " , 0 ) ; 
 - assertColumn ( cfm , row , " c2 " , " v2 " , 1 ) ; 
 + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + { 
 + Row row = Iterators . getOnlyElement ( rows ) ; 
 + assertColumns ( row , " c1 " , " c2 " ) ; 
 + assertColumn ( cfm , row , " c1 " , " v1 " , 0 ) ; 
 + assertColumn ( cfm , row , " c2 " , " v2 " , 1 ) ; 
 + } 
 + assertRepairFuture ( resolver , 2 ) ; 
 } 
 
 assertEquals ( 2 , messageRecorder . sent . size ( ) ) ; 
 @ @ - 224 , 6 + 245 , 7 @ @ public class DataResolverTest 
 assertFalse ( rows . hasNext ( ) ) ; 
 assertFalse ( data . hasNext ( ) ) ; 
 } 
 + assertRepairFuture ( resolver , 2 ) ; 
 } 
 
 assertEquals ( 2 , messageRecorder . sent . size ( ) ) ; 
 @ @ - 289 , 6 + 311 , 7 @ @ public class DataResolverTest 
 
 assertFalse ( rows . hasNext ( ) ) ; 
 } 
 + assertRepairFuture ( resolver , 4 ) ; 
 } 
 
 assertEquals ( 4 , messageRecorder . sent . size ( ) ) ; 
 @ @ - 330 , 12 + 353 , 15 @ @ public class DataResolverTest 
 InetAddress peer2 = peer ( ) ; 
 resolver . preprocess ( readResponseMessage ( peer2 , EmptyIterators . unfilteredPartition ( cfm , false ) ) ) ; 
 
 - try ( PartitionIterator data = resolver . resolve ( ) ; 
 - RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 - Row row = Iterators . getOnlyElement ( rows ) ; 
 - assertColumns ( row , " c2 " ) ; 
 - assertColumn ( cfm , row , " c2 " , " v2 " , 1 ) ; 
 + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + { 
 + Row row = Iterators . getOnlyElement ( rows ) ; 
 + assertColumns ( row , " c2 " ) ; 
 + assertColumn ( cfm , row , " c2 " , " v2 " , 1 ) ; 
 + } 
 + assertRepairFuture ( resolver , 1 ) ; 
 } 
 
 assertEquals ( 1 , messageRecorder . sent . size ( ) ) ; 
 @ @ - 356 , 6 + 382 , 7 @ @ public class DataResolverTest 
 try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 assertFalse ( data . hasNext ( ) ) ; 
 + assertRepairFuture ( resolver , 0 ) ; 
 } 
 
 assertTrue ( messageRecorder . sent . isEmpty ( ) ) ; 
 @ @ - 376 , 6 + 403 , 7 @ @ public class DataResolverTest 
 try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 assertFalse ( data . hasNext ( ) ) ; 
 + assertRepairFuture ( resolver , 1 ) ; 
 } 
 
 / / peer1 should get the deletion from peer2 
 @ @ - 407 , 12 + 435 , 15 @ @ public class DataResolverTest 
 InetAddress peer4 = peer ( ) ; 
 resolver . preprocess ( readResponseMessage ( peer4 , fullPartitionDelete ( cfm , dk , 2 , nowInSec ) ) ) ; 
 
 - try ( PartitionIterator data = resolver . resolve ( ) ; 
 - RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 - Row row = Iterators . getOnlyElement ( rows ) ; 
 - assertColumns ( row , " two " ) ; 
 - assertColumn ( cfm , row , " two " , " B " , 3 ) ; 
 + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + { 
 + Row row = Iterators . getOnlyElement ( rows ) ; 
 + assertColumns ( row , " two " ) ; 
 + assertColumn ( cfm , row , " two " , " B " , 3 ) ; 
 + } 
 + assertRepairFuture ( resolver , 4 ) ; 
 } 
 
 / / peer 1 needs to get the partition delete from peer 4 and the row from peer 3 
 @ @ - 498 , 6 + 529 , 7 @ @ public class DataResolverTest 
 try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 assertFalse ( data . hasNext ( ) ) ; 
 + assertRepairFuture ( resolver , 2 ) ; 
 } 
 
 assertEquals ( 2 , messageRecorder . sent . size ( ) ) ; 
 @ @ - 575 , 12 + 607 , 16 @ @ public class DataResolverTest 
 InetAddress peer2 = peer ( ) ; 
 resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; 
 
 - try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 - Row row = Iterators . getOnlyElement ( rows ) ; 
 - assertColumns ( row , " m " ) ; 
 - Assert . assertNull ( row . getCell ( m , CellPath . create ( bb ( 0 ) ) ) ) ; 
 - Assert . assertNotNull ( row . getCell ( m , CellPath . create ( bb ( 1 ) ) ) ) ; 
 + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + { 
 + Row row = Iterators . getOnlyElement ( rows ) ; 
 + assertColumns ( row , " m " ) ; 
 + Assert . assertNull ( row . getCell ( m , CellPath . create ( bb ( 0 ) ) ) ) ; 
 + Assert . assertNotNull ( row . getCell ( m , CellPath . create ( bb ( 1 ) ) ) ) ; 
 + } 
 + assertRepairFuture ( resolver , 1 ) ; 
 } 
 
 MessageOut < Mutation > msg ; 
 @ @ - 625 , 6 + 661 , 7 @ @ public class DataResolverTest 
 try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 assertFalse ( data . hasNext ( ) ) ; 
 + assertRepairFuture ( resolver , 1 ) ; 
 } 
 
 MessageOut < Mutation > msg ; 
 @ @ - 665 , 12 + 702 , 16 @ @ public class DataResolverTest 
 InetAddress peer2 = peer ( ) ; 
 resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . emptyUpdate ( cfm2 , dk ) ) ) ) ; 
 
 - try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 - Row row = Iterators . getOnlyElement ( rows ) ; 
 - assertColumns ( row , " m " ) ; 
 - ComplexColumnData cd = row . getComplexColumnData ( m ) ; 
 - assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; 
 + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + { 
 + Row row = Iterators . getOnlyElement ( rows ) ; 
 + assertColumns ( row , " m " ) ; 
 + ComplexColumnData cd = row . getComplexColumnData ( m ) ; 
 + assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; 
 + } 
 + assertRepairFuture ( resolver , 1 ) ; 
 } 
 
 Assert . assertNull ( messageRecorder . sent . get ( peer1 ) ) ; 
 @ @ - 714 , 12 + 755 , 16 @ @ public class DataResolverTest 
 InetAddress peer2 = peer ( ) ; 
 resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; 
 
 - try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + try ( PartitionIterator data = resolver . resolve ( ) ) 
 { 
 - Row row = Iterators . getOnlyElement ( rows ) ; 
 - assertColumns ( row , " m " ) ; 
 - ComplexColumnData cd = row . getComplexColumnData ( m ) ; 
 - assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; 
 + try ( RowIterator rows = Iterators . getOnlyElement ( data ) ) 
 + { 
 + Row row = Iterators . getOnlyElement ( rows ) ; 
 + assertColumns ( row , " m " ) ; 
 + ComplexColumnData cd = row . getComplexColumnData ( m ) ; 
 + assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; 
 + } 
 + assertRepairFuture ( resolver , 1 ) ; 
 } 
 
 MessageOut < Mutation > msg ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / Column . java b / src / java / org / apache / cassandra / db / Column . java 
 index 3de7f14 . . ea67ca4 100644 
 - - - a / src / java / org / apache / cassandra / db / Column . java 
 + + + b / src / java / org / apache / cassandra / db / Column . java 
 @ @ - 23 , 6 + 23 , 7 @ @ import java . nio . ByteBuffer ; 
 import java . security . MessageDigest ; 
 import java . io . IOException ; 
 
 + import org . apache . log4j . Logger ; 
 import org . apache . commons . lang . ArrayUtils ; 
 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 @ @ - 37 , 6 + 38 , 8 @ @ import org . apache . cassandra . io . DataOutputBuffer ; 
 
 public final class Column implements IColumn 
 { 
 + private static Logger logger _ = Logger . getLogger ( Column . class ) ; 
 + 
 private static ColumnSerializer serializer _ = new ColumnSerializer ( ) ; 
 
 public static ColumnSerializer serializer ( ) 
 diff - - git a / src / java / org / apache / cassandra / db / ReadResponse . java b / src / java / org / apache / cassandra / db / ReadResponse . java 
 index 2fde8b4 . . 5eb94f5 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadResponse . java 
 + + + b / src / java / org / apache / cassandra / db / ReadResponse . java 
 @ @ - 115 , 20 + 115 , 12 @ @ class ReadResponseSerializer implements ICompactSerializer < ReadResponse > 
 boolean isDigest = dis . readBoolean ( ) ; 
 
 Row row = null ; 
 - if ( ! isDigest ) 
 + if ( ! isDigest ) 
 { 
 row = Row . serializer ( ) . deserialize ( dis ) ; 
 } 
 - 	 	 
 - 	 	 ReadResponse rmsg = null ; 
 - 	 if ( isDigest ) 
 - { 
 - 	 	 rmsg = new ReadResponse ( digest ) ; 
 - } 
 - 	 else 
 - { 
 - 	 	 rmsg = new ReadResponse ( row ) ; 
 - } 
 + 
 + ReadResponse rmsg = isDigest ? new ReadResponse ( digest ) : new ReadResponse ( row ) ; 
 rmsg . setIsDigestQuery ( isDigest ) ; 
 	 return rmsg ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / ReadVerbHandler . java b / src / java / org / apache / cassandra / db / ReadVerbHandler . java 
 index 9370705 . . d02422f 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / db / ReadVerbHandler . java 
 @ @ - 75 , 9 + 75 , 8 @ @ public class ReadVerbHandler implements IVerbHandler 
 } 
 ReadCommand readCommand = ReadCommand . serializer ( ) . deserialize ( readCtx . bufIn _ ) ; 
 Table table = Table . open ( readCommand . table ) ; 
 - Row row = null ; 
 - row = readCommand . getRow ( table ) ; 
 - ReadResponse readResponse = null ; 
 + Row row = readCommand . getRow ( table ) ; 
 + ReadResponse readResponse ; 
 if ( readCommand . isDigestQuery ( ) ) 
 { 
 readResponse = new ReadResponse ( row . digest ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / Row . java b / src / java / org / apache / cassandra / db / Row . java 
 index 13e5877 . . 5f7c6ba 100644 
 - - - a / src / java / org / apache / cassandra / db / Row . java 
 + + + b / src / java / org / apache / cassandra / db / Row . java 
 @ @ - 29 , 13 + 29 , 11 @ @ import java . util . Arrays ; 
 import java . security . MessageDigest ; 
 import java . security . NoSuchAlgorithmException ; 
 
 - import org . apache . commons . lang . ArrayUtils ; 
 import org . apache . commons . lang . StringUtils ; 
 import org . apache . log4j . Logger ; 
 
 import org . apache . cassandra . io . ICompactSerializer ; 
 import org . apache . cassandra . io . DataOutputBuffer ; 
 - import org . apache . cassandra . utils . FBUtilities ; 
 
 public class Row 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / ConsistencyManager . java b / src / java / org / apache / cassandra / service / ConsistencyManager . java 
 index 69c3296 . . 3eafee6 100644 
 - - - a / src / java / org / apache / cassandra / service / ConsistencyManager . java 
 + + + b / src / java / org / apache / cassandra / service / ConsistencyManager . java 
 @ @ - 23 , 7 + 23 , 6 @ @ import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . List ; 
 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . ReadCommand ; 
 import org . apache . cassandra . db . ReadResponse ; 
 import org . apache . cassandra . db . Row ; 
 @ @ - 129 , 21 + 128 , 17 @ @ class ConsistencyManager implements Runnable 
 	 	 
 	 	 public void callMe ( String key , String value ) 
 	 	 { 
 - 	 	 	 handleResponses ( ) ; 
 - 	 	 } 
 - 	 	 
 - 	 	 private void handleResponses ( ) 
 - 	 	 { 
 - 	 	 	 try 
 + try 
 	 	 	 { 
 	 	 	 	 readResponseResolver _ . resolve ( new ArrayList < Message > ( responses _ ) ) ; 
 - 	 	 	 } 
 - 	 	 	 catch ( DigestMismatchException ex ) 
 - 	 	 	 { 
 - 	 	 	 	 throw new RuntimeException ( ex ) ; 
 - 	 	 	 } 
 - 	 	 } 
 - 	 } 
 + } 
 + catch ( Exception ex ) 
 + { 
 + throw new RuntimeException ( ex ) ; 
 + } 
 + } 
 + 
 + } 
 
 	 private static long scheduledTimeMillis _ = 600 ; 
 	 private static ICachetable < String , String > readRepairTable _ = new Cachetable < String , String > ( scheduledTimeMillis _ ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / IResponseResolver . java b / src / java / org / apache / cassandra / service / IResponseResolver . java 
 index 8b897f7 . . 0daf593 100644 
 - - - a / src / java / org / apache / cassandra / service / IResponseResolver . java 
 + + + b / src / java / org / apache / cassandra / service / IResponseResolver . java 
 @ @ - 19 , 6 + 19 , 7 @ @ 
 package org . apache . cassandra . service ; 
 
 import java . util . List ; 
 + import java . io . IOException ; 
 
 import org . apache . cassandra . net . Message ; 
 
 @ @ - 32 , 7 + 33 , 7 @ @ public interface IResponseResolver < T > { 
 	 * repairs . Hence you need to derive a response resolver based on your 
 	 * needs from this interface . 
 	 * / 
 - 	 public T resolve ( List < Message > responses ) throws DigestMismatchException ; 
 + 	 public T resolve ( List < Message > responses ) throws DigestMismatchException , IOException ; 
 	 public boolean isDataPresent ( List < Message > responses ) ; 
 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / QuorumResponseHandler . java b / src / java / org / apache / cassandra / service / QuorumResponseHandler . java 
 index 840d9a0 . . 3e9c595 100644 
 - - - a / src / java / org / apache / cassandra / service / QuorumResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / QuorumResponseHandler . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import java . util . concurrent . atomic . AtomicBoolean ; 
 import java . util . concurrent . locks . * ; 
 import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . TimeoutException ; 
 + import java . io . IOException ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . net . IAsyncCallback ; 
 @ @ - 55 , 64 + 56 , 67 @ @ public class QuorumResponseHandler < T > implements IAsyncCallback 
 startTime _ = System . currentTimeMillis ( ) ; 
 } 
 
 - public T get ( ) throws TimeoutException , DigestMismatchException 
 + public T get ( ) throws TimeoutException , DigestMismatchException , IOException 
 { 
 - 	 lock _ . lock ( ) ; 
 + lock _ . lock ( ) ; 
 try 
 - { 
 - boolean bVal = true ; 
 + { 
 + boolean bVal = true ; 
 try 
 { 
 - 	 if ( ! done _ . get ( ) ) 
 + if ( ! done _ . get ( ) ) 
 { 
 long timeout = System . currentTimeMillis ( ) - startTime _ + DatabaseDescriptor . getRpcTimeout ( ) ; 
 - if ( timeout > 0 ) 
 + if ( timeout > 0 ) 
 + { 
 bVal = condition _ . await ( timeout , TimeUnit . MILLISECONDS ) ; 
 + } 
 else 
 + { 
 bVal = false ; 
 + } 
 } 
 } 
 - catch ( InterruptedException ex ) 
 + catch ( InterruptedException ex ) 
 { 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( LogUtil . throwableToString ( ex ) ) ; 
 + throw new AssertionError ( ex ) ; 
 } 
 - 
 - if ( ! bVal & & ! done _ . get ( ) ) 
 + 
 + if ( ! bVal & & ! done _ . get ( ) ) 
 { 
 StringBuilder sb = new StringBuilder ( " " ) ; 
 - for ( Message message : responses _ ) 
 + for ( Message message : responses _ ) 
 { 
 - sb . append ( message . getFrom ( ) ) ; 
 - } 
 - throw new TimeoutException ( " Operation timed out - received only " + responses _ . size ( ) + " responses from " + sb . toString ( ) + " . " ) ; 
 + sb . append ( message . getFrom ( ) ) ; 
 + } 
 + throw new TimeoutException ( " Operation timed out - received only " + responses _ . size ( ) + " responses from " + sb . toString ( ) + " . " ) ; 
 } 
 } 
 finally 
 { 
 lock _ . unlock ( ) ; 
 - for ( Message response : responses _ ) 
 + for ( Message response : responses _ ) 
 { 
 - 	 MessagingService . removeRegisteredCallback ( response . getMessageId ( ) ) ; 
 + MessagingService . removeRegisteredCallback ( response . getMessageId ( ) ) ; 
 } 
 } 
 
 - 	 return responseResolver _ . resolve ( responses _ ) ; 
 + return responseResolver _ . resolve ( responses _ ) ; 
 } 
 
 public void response ( Message message ) 
 { 
 lock _ . lock ( ) ; 
 try 
 - { 
 - if ( ! done _ . get ( ) ) 
 + { 
 + if ( ! done _ . get ( ) ) 
 { 
 - 	 responses _ . add ( message ) ; 
 - 	 if ( responses _ . size ( ) > = responseCount _ & & responseResolver _ . isDataPresent ( responses _ ) ) 
 - 	 { 
 - 	 	 done _ . set ( true ) ; 
 - 	 	 condition _ . signal ( ) ; 	 
 - 	 } 
 + responses _ . add ( message ) ; 
 + if ( responses _ . size ( ) > = responseCount _ & & responseResolver _ . isDataPresent ( responses _ ) ) 
 + { 
 + done _ . set ( true ) ; 
 + condition _ . signal ( ) ; 
 + } 
 } 
 } 
 finally 
 diff - - git a / src / java / org / apache / cassandra / service / ReadResponseResolver . java b / src / java / org / apache / cassandra / service / ReadResponseResolver . java 
 index f02c017 . . 2d06f48 100644 
 - - - a / src / java / org / apache / cassandra / service / ReadResponseResolver . java 
 + + + b / src / java / org / apache / cassandra / service / ReadResponseResolver . java 
 @ @ - 54 , 8 + 54 , 8 @ @ public class ReadResponseResolver implements IResponseResolver < Row > 
 	 * repair request should be scheduled . 
 	 * 
 	 * / 
 - 	 public Row resolve ( List < Message > responses ) throws DigestMismatchException 
 - 	 { 
 + 	 public Row resolve ( List < Message > responses ) throws DigestMismatchException , IOException 
 + { 
 long startTime = System . currentTimeMillis ( ) ; 
 	 	 Row retRow = null ; 
 	 	 List < Row > rowList = new ArrayList < Row > ( ) ; 
 @ @ - 76 , 38 + 76 , 31 @ @ public class ReadResponseResolver implements IResponseResolver < Row > 
 	 	 { 	 	 	 	 	 
 byte [ ] body = response . getMessageBody ( ) ; 
 bufIn . reset ( body , body . length ) ; 
 - try 
 + long start = System . currentTimeMillis ( ) ; 
 + ReadResponse result = ReadResponse . serializer ( ) . deserialize ( bufIn ) ; 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( " Response deserialization time : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; 
 + if ( result . isDigestQuery ( ) ) 
 { 
 - long start = System . currentTimeMillis ( ) ; 
 - ReadResponse result = ReadResponse . serializer ( ) . deserialize ( bufIn ) ; 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " Response deserialization time : " + ( System . currentTimeMillis ( ) - start ) + " ms . " ) ; 
 - 	 	 	 if ( ! result . isDigestQuery ( ) ) 
 - 	 	 	 { 
 - 	 	 	 	 rowList . add ( result . row ( ) ) ; 
 - 	 	 	 	 endPoints . add ( response . getFrom ( ) ) ; 
 - 	 	 	 	 key = result . row ( ) . key ( ) ; 
 - 	 	 	 	 table = result . row ( ) . getTable ( ) ; 
 - 	 	 	 } 
 - 	 	 	 else 
 - 	 	 	 { 
 - 	 	 	 	 digest = result . digest ( ) ; 
 - 	 	 	 	 isDigestQuery = true ; 
 - 	 	 	 } 
 + digest = result . digest ( ) ; 
 + isDigestQuery = true ; 
 } 
 - catch ( IOException ex ) 
 + else 
 { 
 - logger _ . info ( LogUtil . throwableToString ( ex ) ) ; 
 + rowList . add ( result . row ( ) ) ; 
 + endPoints . add ( response . getFrom ( ) ) ; 
 + key = result . row ( ) . key ( ) ; 
 + table = result . row ( ) . getTable ( ) ; 
 } 
 - 	 	 } 
 + } 
 	 	 / / If there was a digest query compare it with all the data digests 
 	 	 / / If there is a mismatch then throw an exception so that read repair can happen . 
 - 	 	 if ( isDigestQuery ) 
 - 	 	 { 
 - 	 	 	 for ( Row row : rowList ) 
 - 	 	 	 { 
 - 	 	 	 	 if ( ! Arrays . equals ( row . digest ( ) , digest ) ) 
 - 	 	 	 	 { 
 + if ( isDigestQuery ) 
 + { 
 + for ( Row row : rowList ) 
 + { 
 + if ( ! Arrays . equals ( row . digest ( ) , digest ) ) 
 + { 
 / * Wrap the key as the context in this exception * / 
 	 	 	 	 	 throw new DigestMismatchException ( row . key ( ) ) ; 
 	 	 	 	 } 
 @ @ - 115 , 36 + 108 , 36 @ @ public class ReadResponseResolver implements IResponseResolver < Row > 
 	 	 } 
 	 	 
 / * If the rowList is empty then we had some exception above . * / 
 - if ( rowList . size ( ) = = 0 ) 
 + if ( rowList . size ( ) = = 0 ) 
 { 
 return retRow ; 
 } 
 - 
 + 
 / * Now calculate the resolved row * / 
 - 	 	 retRow = new Row ( table , key ) ; 
 - 	 	 for ( int i = 0 ; i < rowList . size ( ) ; i + + ) 
 - 	 	 { 
 - 	 	 	 retRow . repair ( rowList . get ( i ) ) ; 	 	 	 
 - 	 	 } 
 + retRow = new Row ( table , key ) ; 
 + for ( int i = 0 ; i < rowList . size ( ) ; i + + ) 
 + { 
 + retRow . repair ( rowList . get ( i ) ) ; 
 + } 
 
 / / At this point we have the return row . 
 - 	 	 / / Now we need to calculate the difference 
 - 	 	 / / so that we can schedule read repairs 
 - 	 	 for ( int i = 0 ; i < rowList . size ( ) ; i + + ) 
 - 	 	 { 
 - 	 	 	 / / since retRow is the resolved row it can be used as the super set 
 - 	 	 	 Row diffRow = rowList . get ( i ) . diff ( retRow ) ; 
 - 	 	 	 if ( diffRow = = null ) / / no repair needs to happen 
 - 	 	 	 	 continue ; 
 - 	 	 	 / / create the row mutation message based on the diff and schedule a read repair 
 - 	 	 	 RowMutation rowMutation = new RowMutation ( table , key ) ; 	 	 	 
 - 	 for ( ColumnFamily cf : diffRow . getColumnFamilies ( ) ) 
 - 	 { 
 - 	 rowMutation . add ( cf ) ; 
 - 	 } 
 + / / Now we need to calculate the difference 
 + / / so that we can schedule read repairs 
 + for ( int i = 0 ; i < rowList . size ( ) ; i + + ) 
 + { 
 + / / since retRow is the resolved row it can be used as the super set 
 + Row diffRow = rowList . get ( i ) . diff ( retRow ) ; 
 + if ( diffRow = = null ) / / no repair needs to happen 
 + continue ; 
 + / / create the row mutation message based on the diff and schedule a read repair 
 + RowMutation rowMutation = new RowMutation ( table , key ) ; 
 + for ( ColumnFamily cf : diffRow . getColumnFamilies ( ) ) 
 + { 
 + rowMutation . add ( cf ) ; 
 + } 
 RowMutationMessage rowMutationMessage = new RowMutationMessage ( rowMutation ) ; 
 - 	 ReadRepairManager . instance ( ) . schedule ( endPoints . get ( i ) , rowMutationMessage ) ; 
 - 	 	 } 
 + ReadRepairManager . instance ( ) . schedule ( endPoints . get ( i ) , rowMutationMessage ) ; 
 + } 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " resolve : " + ( System . currentTimeMillis ( ) - startTime ) + " ms . " ) ; 
 	 	 return retRow ; 
 @ @ - 152 , 26 + 145 , 26 @ @ public class ReadResponseResolver implements IResponseResolver < Row > 
 
 	 public boolean isDataPresent ( List < Message > responses ) 
 	 { 
 - 	 	 boolean isDataPresent = false ; 
 - 	 	 for ( Message response : responses ) 
 - 	 	 { 
 + boolean isDataPresent = false ; 
 + for ( Message response : responses ) 
 + { 
 byte [ ] body = response . getMessageBody ( ) ; 
 - 	 	 	 DataInputBuffer bufIn = new DataInputBuffer ( ) ; 
 + DataInputBuffer bufIn = new DataInputBuffer ( ) ; 
 bufIn . reset ( body , body . length ) ; 
 try 
 { 
 - 	 	 	 ReadResponse result = ReadResponse . serializer ( ) . deserialize ( bufIn ) ; 
 - 	 	 	 if ( ! result . isDigestQuery ( ) ) 
 - 	 	 	 { 
 - 	 	 	 	 isDataPresent = true ; 
 - 	 	 	 } 
 + ReadResponse result = ReadResponse . serializer ( ) . deserialize ( bufIn ) ; 
 + if ( ! result . isDigestQuery ( ) ) 
 + { 
 + isDataPresent = true ; 
 + } 
 bufIn . close ( ) ; 
 } 
 - catch ( IOException ex ) 
 + catch ( IOException ex ) 
 { 
 logger _ . info ( LogUtil . throwableToString ( ex ) ) ; 
 - } 
 - 	 	 } 
 - 	 	 return isDataPresent ; 
 - 	 } 
 + } 
 + } 
 + return isDataPresent ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index e3e2e27 . . d183f3e 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 352 , 10 + 352 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 Message message = command . makeReadMessage ( ) ; 
 Message messageDigestOnly = readMessageDigestOnly . makeReadMessage ( ) ; 
 
 - IResponseResolver < Row > readResponseResolver = new ReadResponseResolver ( ) ; 
 - QuorumResponseHandler < Row > quorumResponseHandler = new QuorumResponseHandler < Row > ( 
 - DatabaseDescriptor . getQuorum ( ) , 
 - readResponseResolver ) ; 
 + QuorumResponseHandler < Row > quorumResponseHandler = new QuorumResponseHandler < Row > ( DatabaseDescriptor . getQuorum ( ) , new ReadResponseResolver ( ) ) ; 
 EndPoint dataPoint = StorageService . instance ( ) . findSuitableEndPoint ( command . key ) ; 
 List < EndPoint > endpointList = new ArrayList < EndPoint > ( Arrays . asList ( StorageService . instance ( ) . getReadStorageEndPoints ( command . key ) ) ) ; 
 / * Remove the local storage endpoint from the list . * / 
 @ @ - 401 , 7 + 398 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 catch ( DigestMismatchException ex ) 
 { 
 - if ( DatabaseDescriptor . getConsistencyCheck ( ) ) 
 + if ( DatabaseDescriptor . getConsistencyCheck ( ) ) 
 { 
 IResponseResolver < Row > readResponseResolverRepair = new ReadResponseResolver ( ) ; 
 QuorumResponseHandler < Row > quorumResponseHandlerRepair = new QuorumResponseHandler < Row > ( 
 @ @ - 409 , 8 + 406 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 readResponseResolverRepair ) ; 
 logger . info ( " DigestMismatchException : " + command . key ) ; 
 Message messageRepair = command . makeReadMessage ( ) ; 
 - MessagingService . getMessagingInstance ( ) . sendRR ( messageRepair , commandEndPoints . get ( commandIndex ) , 
 - quorumResponseHandlerRepair ) ; 
 + MessagingService . getMessagingInstance ( ) . sendRR ( messageRepair , commandEndPoints . get ( commandIndex ) , quorumResponseHandlerRepair ) ; 
 try 
 { 
 row = quorumResponseHandlerRepair . get ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / utils / FBUtilities . java b / src / java / org / apache / cassandra / utils / FBUtilities . java 
 index b85f57a . . dc158eb 100644 
 - - - a / src / java / org / apache / cassandra / utils / FBUtilities . java 
 + + + b / src / java / org / apache / cassandra / utils / FBUtilities . java 
 @ @ - 398 , 15 + 398 , 12 @ @ public class FBUtilities 
 return bytes ; 
 } 
 
 - public static String bytesToHex ( byte [ ] buf ) 
 + public static String bytesToHex ( byte [ ] bytes ) 
 { 
 - char [ ] chars = new char [ 2 * buf . length ] ; 
 - for ( int i = 0 ; i < buf . length ; i + + ) 
 - { 
 - chars [ i * 2 ] = HEX _ CHARS [ ( buf [ i ] & 0xF0 ) > > > 4 ] ; 
 - chars [ i * 2 + 1 ] = HEX _ CHARS [ buf [ i ] & 0x0F ] ; 
 - } 
 - return new String ( chars ) ; 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + for ( byte b : bytes ) 
 + sb . append ( Integer . toHexString ( b & 0xff ) ) ; 
 + return sb . toString ( ) ; 
 } 
 
 public static String mapToString ( Map < ? , ? > map )
