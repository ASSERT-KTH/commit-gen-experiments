BLEU SCORE: 0.03057230827292727

TEST MSG: fix bad rebase
GENERATED MSG: custom CommitLogExecutorService that can fsync per multiple CL additions

TEST DIFF (one line): diff - - git a / test / unit / org / apache / cassandra / db / rows / RowBuilder . java b / test / unit / org / apache / cassandra / db / rows / RowBuilder . java <nl> index caa5c40 . . b1223f1 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / rows / RowBuilder . java <nl> + + + b / test / unit / org / apache / cassandra / db / rows / RowBuilder . java <nl> @ @ - 36 , 7 + 36 , 7 @ @ public class RowBuilder implements Row . Builder <nl> public List < Cell > cells = new LinkedList < > ( ) ; <nl> public Clustering clustering = null ; <nl> public LivenessInfo livenessInfo = null ; <nl> - public DeletionTime deletionTime = null ; <nl> + public Row . Deletion deletionTime = null ; <nl> public List < Pair < ColumnDefinition , DeletionTime > > complexDeletions = new LinkedList < > ( ) ; <nl> <nl> public void addCell ( Cell cell ) <nl> @ @ - 66 , 13 + 66 , 12 @ @ public class RowBuilder implements Row . Builder <nl> livenessInfo = info ; <nl> } <nl> <nl> - public void addRowDeletion ( DeletionTime deletion ) <nl> + public void addRowDeletion ( Row . Deletion deletion ) <nl> { <nl> assert deletionTime = = null ; <nl> deletionTime = deletion ; <nl> } <nl> <nl> - <nl> public void addComplexDeletion ( ColumnDefinition column , DeletionTime complexDeletion ) <nl> { <nl> complexDeletions . add ( Pair . create ( column , complexDeletion ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / rows / RowsTest . java b / test / unit / org / apache / cassandra / db / rows / RowsTest . java <nl> index 306d687 . . 7ee2d0a 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / rows / RowsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / rows / RowsTest . java <nl> @ @ - 149 , 8 + 149 , 8 @ @ public class RowsTest <nl> updates + + ; <nl> } <nl> <nl> - List < MergedPair < DeletionTime > > deletions = new LinkedList < > ( ) ; <nl> - public void onDeletion ( int i , Clustering clustering , DeletionTime merged , DeletionTime original ) <nl> + List < MergedPair < Row . Deletion > > deletions = new LinkedList < > ( ) ; <nl> + public void onDeletion ( int i , Clustering clustering , Row . Deletion merged , Row . Deletion original ) <nl> { <nl> updateClustering ( clustering ) ; <nl> deletions . add ( MergedPair . create ( i , merged , original ) ) ; <nl> @ @ - 240 , 7 + 240 , 7 @ @ public class RowsTest <nl> BufferCell . live ( kcvm , m , secondToTs ( now ) , BB1 , CellPath . create ( BB1 ) ) , <nl> BufferCell . live ( kcvm , m , secondToTs ( now ) , BB2 , CellPath . create ( BB2 ) ) ) ; <nl> expectedCells . forEach ( originalBuilder : : addCell ) ; <nl> - DeletionTime rowDeletion = new DeletionTime ( ts , now ) ; <nl> + Row . Deletion rowDeletion = new Row . Deletion ( new DeletionTime ( ts , now ) , false ) ; <nl> originalBuilder . addRowDeletion ( rowDeletion ) ; <nl> <nl> RowBuilder builder = new RowBuilder ( ) ; <nl> @ @ - 268 , 14 + 268 , 14 @ @ public class RowsTest <nl> BufferCell . live ( kcvm , m , ts , BB1 , CellPath . create ( BB1 ) ) , <nl> BufferCell . live ( kcvm , m , ts , BB2 , CellPath . create ( BB2 ) ) ) ; <nl> expectedCells . forEach ( builder : : addCell ) ; <nl> - DeletionTime rowDeletion = new DeletionTime ( ts , now ) ; <nl> + Row . Deletion rowDeletion = new Row . Deletion ( new DeletionTime ( ts , now ) , false ) ; <nl> builder . addRowDeletion ( rowDeletion ) ; <nl> <nl> StatsCollector collector = new StatsCollector ( ) ; <nl> Rows . collectStats ( builder . build ( ) , collector ) ; <nl> <nl> Assert . assertEquals ( Lists . newArrayList ( liveness ) , collector . liveness ) ; <nl> - Assert . assertEquals ( Sets . newHashSet ( rowDeletion , complexDeletion ) , Sets . newHashSet ( collector . deletions ) ) ; <nl> + Assert . assertEquals ( Sets . newHashSet ( rowDeletion . time ( ) , complexDeletion ) , Sets . newHashSet ( collector . deletions ) ) ; <nl> Assert . assertEquals ( Sets . newHashSet ( expectedCells ) , Sets . newHashSet ( collector . cells ) ) ; <nl> Assert . assertEquals ( 2 , collector . columnCount ) ; <nl> Assert . assertFalse ( collector . hasLegacyCounterShards ) ; <nl> @ @ - 322 , 7 + 322 , 7 @ @ public class RowsTest <nl> List < Cell > r2ExpectedCells = Lists . newArrayList ( r2v , r2m2 , r2m3 , r2m4 ) ; <nl> <nl> r2ExpectedCells . forEach ( r2Builder : : addCell ) ; <nl> - DeletionTime r2RowDeletion = new DeletionTime ( ts1 - 2 , now2 ) ; <nl> + Row . Deletion r2RowDeletion = new Row . Deletion ( new DeletionTime ( ts1 - 2 , now2 ) , false ) ; <nl> r2Builder . addRowDeletion ( r2RowDeletion ) ; <nl> <nl> Row r1 = r1Builder . build ( ) ; <nl> @ @ - 353 , 7 + 353 , 7 @ @ public class RowsTest <nl> Assert . assertEquals ( expectedLiveness , listener . liveness ) ; <nl> <nl> / / deletions <nl> - List < MergedPair < DeletionTime > > expectedDeletions = Lists . newArrayList ( MergedPair . create ( 0 , r2RowDeletion , null ) , <nl> + List < MergedPair < Row . Deletion > > expectedDeletions = Lists . newArrayList ( MergedPair . create ( 0 , r2RowDeletion , null ) , <nl> MergedPair . create ( 1 , r2RowDeletion , r2RowDeletion ) ) ; <nl> Assert . assertEquals ( expectedDeletions , listener . deletions ) ; <nl> <nl> @ @ - 392 , 7 + 392 , 7 @ @ public class RowsTest <nl> List < Cell > r2ExpectedCells = Lists . newArrayList ( r2v , r2m2 , r2m3 , r2m4 ) ; <nl> <nl> r2ExpectedCells . forEach ( r2Builder : : addCell ) ; <nl> - DeletionTime r2RowDeletion = new DeletionTime ( ts1 - 1 , now2 ) ; <nl> + Row . Deletion r2RowDeletion = new Row . Deletion ( new DeletionTime ( ts1 - 1 , now2 ) , false ) ; <nl> r2Builder . addRowDeletion ( r2RowDeletion ) ; <nl> <nl> Row r1 = r1Builder . build ( ) ; <nl> @ @ - 446 , 7 + 446 , 7 @ @ public class RowsTest <nl> List < Cell > r2ExpectedCells = Lists . newArrayList ( r2v , r2m2 , r2m3 , r2m4 ) ; <nl> <nl> r2ExpectedCells . forEach ( r2Builder : : addCell ) ; <nl> - DeletionTime r2RowDeletion = new DeletionTime ( ts1 - 1 , now2 ) ; <nl> + Row . Deletion r2RowDeletion = new Row . Deletion ( new DeletionTime ( ts1 - 1 , now2 ) , false ) ; <nl> r2Builder . addRowDeletion ( r2RowDeletion ) ; <nl> <nl> Row r1 = r1Builder . build ( ) ; <nl> @ @ - 510 , 7 + 510 , 7 @ @ public class RowsTest <nl> int now2 = now1 + 1 ; <nl> Row . Builder updateBuilder = createBuilder ( c1 , now2 , null , BB1 , BB1 ) ; <nl> int now3 = now2 + 1 ; <nl> - DeletionTime expectedDeletion = new DeletionTime ( secondToTs ( now3 ) , now3 ) ; <nl> + Row . Deletion expectedDeletion = new Row . Deletion ( new DeletionTime ( secondToTs ( now3 ) , now3 ) , false ) ; <nl> updateBuilder . addRowDeletion ( expectedDeletion ) ; <nl> <nl> RowBuilder builder = new RowBuilder ( ) ; <nl> @ @ - 534 , 7 + 534 , 7 @ @ public class RowsTest <nl> int now2 = now1 + 1 ; <nl> Row . Builder updateBuilder = createBuilder ( c1 , now2 , BB1 , BB1 , BB1 ) ; <nl> int now3 = now2 + 1 ; <nl> - DeletionTime expectedDeletion = new DeletionTime ( secondToTs ( now3 ) , now3 ) ; <nl> + Row . Deletion expectedDeletion = new Row . Deletion ( new DeletionTime ( secondToTs ( now3 ) , now3 ) , false ) ; <nl> updateBuilder . addRowDeletion ( expectedDeletion ) ; <nl> <nl> RowBuilder builder = new RowBuilder ( ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / CommitLog . java b / src / java / org / apache / cassandra / db / CommitLog . java <nl> index c6d0c88 . . f7bc4f9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / CommitLog . java <nl> @ @ - 182 , 7 + 182 , 7 @ @ public class CommitLog <nl> { <nl> if ( ! recoveryMode ) <nl> { <nl> - executor = new DebuggableThreadPoolExecutor ( " COMMITLOG - POOL " ) ; <nl> + executor = new CommitLogExecutorService ( ) ; <nl> setNextFileName ( ) ; <nl> logWriter _ = CommitLog . createWriter ( logFile _ ) ; <nl> writeCommitLogHeader ( ) ; <nl> @ @ - 372 , 36 + 372 , 7 @ @ public class CommitLog <nl> * / <nl> CommitLogContext add ( final Row row ) throws IOException <nl> { <nl> - Callable < CommitLogContext > task = new Callable < CommitLogContext > ( ) <nl> - { <nl> - public CommitLogContext call ( ) throws Exception <nl> - { <nl> - long currentPosition = - 1L ; <nl> - DataOutputBuffer cfBuffer = new DataOutputBuffer ( ) ; <nl> - try <nl> - { <nl> - / * serialize the row * / <nl> - Row . serializer ( ) . serialize ( row , cfBuffer ) ; <nl> - currentPosition = logWriter _ . getCurrentPosition ( ) ; <nl> - CommitLogContext cLogCtx = new CommitLogContext ( logFile _ , currentPosition ) ; <nl> - / * Update the header * / <nl> - maybeUpdateHeader ( row ) ; <nl> - logWriter _ . writeLong ( cfBuffer . getLength ( ) ) ; <nl> - logWriter _ . append ( cfBuffer ) ; <nl> - if ( ! maybeRollLog ( ) ) <nl> - { <nl> - logWriter _ . sync ( ) ; <nl> - } <nl> - return cLogCtx ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - if ( currentPosition ! = - 1 ) <nl> - logWriter _ . seek ( currentPosition ) ; <nl> - throw e ; <nl> - } <nl> - } <nl> - } ; <nl> + Callable < CommitLogContext > task = new LogRecordAdder ( row ) ; <nl> <nl> try <nl> { <nl> @ @ - 552 , 4 + 523 , 44 @ @ public class CommitLog <nl> } <nl> return false ; <nl> } <nl> - } <nl> \ No newline at end of file <nl> + <nl> + void sync ( ) throws IOException <nl> + { <nl> + logWriter _ . sync ( ) ; <nl> + } <nl> + <nl> + class LogRecordAdder implements Callable < CommitLog . CommitLogContext > <nl> + { <nl> + Row row ; <nl> + <nl> + LogRecordAdder ( Row row ) <nl> + { <nl> + this . row = row ; <nl> + } <nl> + <nl> + public CommitLog . CommitLogContext call ( ) throws Exception <nl> + { <nl> + long currentPosition = - 1L ; <nl> + DataOutputBuffer cfBuffer = new DataOutputBuffer ( ) ; <nl> + try <nl> + { <nl> + / * serialize the row * / <nl> + Row . serializer ( ) . serialize ( row , cfBuffer ) ; <nl> + currentPosition = logWriter _ . getCurrentPosition ( ) ; <nl> + CommitLogContext cLogCtx = new CommitLogContext ( logFile _ , currentPosition ) ; <nl> + / * Update the header * / <nl> + maybeUpdateHeader ( row ) ; <nl> + logWriter _ . writeLong ( cfBuffer . getLength ( ) ) ; <nl> + logWriter _ . append ( cfBuffer ) ; <nl> + maybeRollLog ( ) ; <nl> + return cLogCtx ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + if ( currentPosition ! = - 1 ) <nl> + logWriter _ . seek ( currentPosition ) ; <nl> + throw e ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / db / CommitLogExecutorService . java b / src / java / org / apache / cassandra / db / CommitLogExecutorService . java <nl> new file mode 100644 <nl> index 0000000 . . 238ad5a <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / db / CommitLogExecutorService . java <nl> @ @ - 0 , 0 + 1 , 153 @ @ <nl> + package org . apache . cassandra . db ; <nl> + <nl> + import java . util . concurrent . * ; <nl> + import java . util . List ; <nl> + import java . util . Queue ; <nl> + import java . util . ArrayList ; <nl> + import java . io . IOException ; <nl> + <nl> + public class CommitLogExecutorService extends AbstractExecutorService <nl> + { <nl> + Queue < CheaterFutureTask > queue ; <nl> + <nl> + public CommitLogExecutorService ( ) <nl> + { <nl> + queue = new ConcurrentLinkedQueue < CheaterFutureTask > ( ) ; <nl> + Runnable runnable = new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + while ( true ) <nl> + { <nl> + process ( ) ; <nl> + } <nl> + } <nl> + } ; <nl> + new Thread ( runnable ) . start ( ) ; <nl> + } <nl> + <nl> + private ArrayList < CheaterFutureTask > incompleteTasks = new ArrayList < CheaterFutureTask > ( ) ; <nl> + private ArrayList taskValues = new ArrayList ( ) ; / / TODO not sure how to generify this <nl> + void process ( ) <nl> + { <nl> + while ( queue . isEmpty ( ) ) <nl> + { <nl> + try <nl> + { <nl> + Thread . sleep ( 1 ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + / / attempt to do a bunch of LogRecordAdder ops before syncing <nl> + incompleteTasks . clear ( ) ; <nl> + taskValues . clear ( ) ; <nl> + while ( ! queue . isEmpty ( ) <nl> + & & queue . peek ( ) . getRawCallable ( ) instanceof CommitLog . LogRecordAdder <nl> + & & incompleteTasks . size ( ) < 20 ) <nl> + { <nl> + CheaterFutureTask task = queue . remove ( ) ; <nl> + incompleteTasks . add ( task ) ; <nl> + try <nl> + { <nl> + taskValues . add ( task . getRawCallable ( ) . call ( ) ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + / / it doesn ' t seem worth bothering future - izing the exception <nl> + / / since if a commitlog op throws , we ' re probably screwed anyway <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + if ( incompleteTasks . size ( ) = = 0 ) <nl> + { <nl> + / / no LRAs ; just run the task <nl> + queue . remove ( ) . run ( ) ; <nl> + } <nl> + else <nl> + { <nl> + / / now sync and set the tasks ' values ( which allows thread calling get ( ) to proceed ) <nl> + try <nl> + { <nl> + CommitLog . open ( ) . sync ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + for ( int i = 0 ; i < incompleteTasks . size ( ) ; i + + ) <nl> + { <nl> + incompleteTasks . get ( i ) . set ( taskValues . get ( i ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + protected < T > RunnableFuture < T > newTaskFor ( Runnable runnable , T value ) <nl> + { <nl> + return newTaskFor ( Executors . callable ( runnable , value ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected < T > RunnableFuture < T > newTaskFor ( Callable < T > callable ) <nl> + { <nl> + return new CheaterFutureTask ( callable ) ; <nl> + } <nl> + <nl> + public void execute ( Runnable command ) <nl> + { <nl> + queue . add ( ( CheaterFutureTask ) command ) ; <nl> + } <nl> + <nl> + public boolean isShutdown ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + public boolean isTerminated ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + / / cassandra is crash - only so there ' s no need to implement the shutdown methods <nl> + public void shutdown ( ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + public List < Runnable > shutdownNow ( ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + } <nl> + <nl> + class CheaterFutureTask < V > extends FutureTask < V > <nl> + { <nl> + private Callable rawCallable ; <nl> + <nl> + public CheaterFutureTask ( Callable < V > callable ) <nl> + { <nl> + super ( callable ) ; <nl> + rawCallable = callable ; <nl> + } <nl> + <nl> + public Callable getRawCallable ( ) <nl> + { <nl> + return rawCallable ; <nl> + } <nl> + <nl> + @ Override <nl> + public void set ( V v ) <nl> + { <nl> + super . set ( v ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / test / unit / org / apache / cassandra / db / rows / RowBuilder . java b / test / unit / org / apache / cassandra / db / rows / RowBuilder . java 
 index caa5c40 . . b1223f1 100644 
 - - - a / test / unit / org / apache / cassandra / db / rows / RowBuilder . java 
 + + + b / test / unit / org / apache / cassandra / db / rows / RowBuilder . java 
 @ @ - 36 , 7 + 36 , 7 @ @ public class RowBuilder implements Row . Builder 
 public List < Cell > cells = new LinkedList < > ( ) ; 
 public Clustering clustering = null ; 
 public LivenessInfo livenessInfo = null ; 
 - public DeletionTime deletionTime = null ; 
 + public Row . Deletion deletionTime = null ; 
 public List < Pair < ColumnDefinition , DeletionTime > > complexDeletions = new LinkedList < > ( ) ; 
 
 public void addCell ( Cell cell ) 
 @ @ - 66 , 13 + 66 , 12 @ @ public class RowBuilder implements Row . Builder 
 livenessInfo = info ; 
 } 
 
 - public void addRowDeletion ( DeletionTime deletion ) 
 + public void addRowDeletion ( Row . Deletion deletion ) 
 { 
 assert deletionTime = = null ; 
 deletionTime = deletion ; 
 } 
 
 - 
 public void addComplexDeletion ( ColumnDefinition column , DeletionTime complexDeletion ) 
 { 
 complexDeletions . add ( Pair . create ( column , complexDeletion ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / rows / RowsTest . java b / test / unit / org / apache / cassandra / db / rows / RowsTest . java 
 index 306d687 . . 7ee2d0a 100644 
 - - - a / test / unit / org / apache / cassandra / db / rows / RowsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / rows / RowsTest . java 
 @ @ - 149 , 8 + 149 , 8 @ @ public class RowsTest 
 updates + + ; 
 } 
 
 - List < MergedPair < DeletionTime > > deletions = new LinkedList < > ( ) ; 
 - public void onDeletion ( int i , Clustering clustering , DeletionTime merged , DeletionTime original ) 
 + List < MergedPair < Row . Deletion > > deletions = new LinkedList < > ( ) ; 
 + public void onDeletion ( int i , Clustering clustering , Row . Deletion merged , Row . Deletion original ) 
 { 
 updateClustering ( clustering ) ; 
 deletions . add ( MergedPair . create ( i , merged , original ) ) ; 
 @ @ - 240 , 7 + 240 , 7 @ @ public class RowsTest 
 BufferCell . live ( kcvm , m , secondToTs ( now ) , BB1 , CellPath . create ( BB1 ) ) , 
 BufferCell . live ( kcvm , m , secondToTs ( now ) , BB2 , CellPath . create ( BB2 ) ) ) ; 
 expectedCells . forEach ( originalBuilder : : addCell ) ; 
 - DeletionTime rowDeletion = new DeletionTime ( ts , now ) ; 
 + Row . Deletion rowDeletion = new Row . Deletion ( new DeletionTime ( ts , now ) , false ) ; 
 originalBuilder . addRowDeletion ( rowDeletion ) ; 
 
 RowBuilder builder = new RowBuilder ( ) ; 
 @ @ - 268 , 14 + 268 , 14 @ @ public class RowsTest 
 BufferCell . live ( kcvm , m , ts , BB1 , CellPath . create ( BB1 ) ) , 
 BufferCell . live ( kcvm , m , ts , BB2 , CellPath . create ( BB2 ) ) ) ; 
 expectedCells . forEach ( builder : : addCell ) ; 
 - DeletionTime rowDeletion = new DeletionTime ( ts , now ) ; 
 + Row . Deletion rowDeletion = new Row . Deletion ( new DeletionTime ( ts , now ) , false ) ; 
 builder . addRowDeletion ( rowDeletion ) ; 
 
 StatsCollector collector = new StatsCollector ( ) ; 
 Rows . collectStats ( builder . build ( ) , collector ) ; 
 
 Assert . assertEquals ( Lists . newArrayList ( liveness ) , collector . liveness ) ; 
 - Assert . assertEquals ( Sets . newHashSet ( rowDeletion , complexDeletion ) , Sets . newHashSet ( collector . deletions ) ) ; 
 + Assert . assertEquals ( Sets . newHashSet ( rowDeletion . time ( ) , complexDeletion ) , Sets . newHashSet ( collector . deletions ) ) ; 
 Assert . assertEquals ( Sets . newHashSet ( expectedCells ) , Sets . newHashSet ( collector . cells ) ) ; 
 Assert . assertEquals ( 2 , collector . columnCount ) ; 
 Assert . assertFalse ( collector . hasLegacyCounterShards ) ; 
 @ @ - 322 , 7 + 322 , 7 @ @ public class RowsTest 
 List < Cell > r2ExpectedCells = Lists . newArrayList ( r2v , r2m2 , r2m3 , r2m4 ) ; 
 
 r2ExpectedCells . forEach ( r2Builder : : addCell ) ; 
 - DeletionTime r2RowDeletion = new DeletionTime ( ts1 - 2 , now2 ) ; 
 + Row . Deletion r2RowDeletion = new Row . Deletion ( new DeletionTime ( ts1 - 2 , now2 ) , false ) ; 
 r2Builder . addRowDeletion ( r2RowDeletion ) ; 
 
 Row r1 = r1Builder . build ( ) ; 
 @ @ - 353 , 7 + 353 , 7 @ @ public class RowsTest 
 Assert . assertEquals ( expectedLiveness , listener . liveness ) ; 
 
 / / deletions 
 - List < MergedPair < DeletionTime > > expectedDeletions = Lists . newArrayList ( MergedPair . create ( 0 , r2RowDeletion , null ) , 
 + List < MergedPair < Row . Deletion > > expectedDeletions = Lists . newArrayList ( MergedPair . create ( 0 , r2RowDeletion , null ) , 
 MergedPair . create ( 1 , r2RowDeletion , r2RowDeletion ) ) ; 
 Assert . assertEquals ( expectedDeletions , listener . deletions ) ; 
 
 @ @ - 392 , 7 + 392 , 7 @ @ public class RowsTest 
 List < Cell > r2ExpectedCells = Lists . newArrayList ( r2v , r2m2 , r2m3 , r2m4 ) ; 
 
 r2ExpectedCells . forEach ( r2Builder : : addCell ) ; 
 - DeletionTime r2RowDeletion = new DeletionTime ( ts1 - 1 , now2 ) ; 
 + Row . Deletion r2RowDeletion = new Row . Deletion ( new DeletionTime ( ts1 - 1 , now2 ) , false ) ; 
 r2Builder . addRowDeletion ( r2RowDeletion ) ; 
 
 Row r1 = r1Builder . build ( ) ; 
 @ @ - 446 , 7 + 446 , 7 @ @ public class RowsTest 
 List < Cell > r2ExpectedCells = Lists . newArrayList ( r2v , r2m2 , r2m3 , r2m4 ) ; 
 
 r2ExpectedCells . forEach ( r2Builder : : addCell ) ; 
 - DeletionTime r2RowDeletion = new DeletionTime ( ts1 - 1 , now2 ) ; 
 + Row . Deletion r2RowDeletion = new Row . Deletion ( new DeletionTime ( ts1 - 1 , now2 ) , false ) ; 
 r2Builder . addRowDeletion ( r2RowDeletion ) ; 
 
 Row r1 = r1Builder . build ( ) ; 
 @ @ - 510 , 7 + 510 , 7 @ @ public class RowsTest 
 int now2 = now1 + 1 ; 
 Row . Builder updateBuilder = createBuilder ( c1 , now2 , null , BB1 , BB1 ) ; 
 int now3 = now2 + 1 ; 
 - DeletionTime expectedDeletion = new DeletionTime ( secondToTs ( now3 ) , now3 ) ; 
 + Row . Deletion expectedDeletion = new Row . Deletion ( new DeletionTime ( secondToTs ( now3 ) , now3 ) , false ) ; 
 updateBuilder . addRowDeletion ( expectedDeletion ) ; 
 
 RowBuilder builder = new RowBuilder ( ) ; 
 @ @ - 534 , 7 + 534 , 7 @ @ public class RowsTest 
 int now2 = now1 + 1 ; 
 Row . Builder updateBuilder = createBuilder ( c1 , now2 , BB1 , BB1 , BB1 ) ; 
 int now3 = now2 + 1 ; 
 - DeletionTime expectedDeletion = new DeletionTime ( secondToTs ( now3 ) , now3 ) ; 
 + Row . Deletion expectedDeletion = new Row . Deletion ( new DeletionTime ( secondToTs ( now3 ) , now3 ) , false ) ; 
 updateBuilder . addRowDeletion ( expectedDeletion ) ; 
 
 RowBuilder builder = new RowBuilder ( ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / CommitLog . java b / src / java / org / apache / cassandra / db / CommitLog . java 
 index c6d0c88 . . f7bc4f9 100644 
 - - - a / src / java / org / apache / cassandra / db / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / CommitLog . java 
 @ @ - 182 , 7 + 182 , 7 @ @ public class CommitLog 
 { 
 if ( ! recoveryMode ) 
 { 
 - executor = new DebuggableThreadPoolExecutor ( " COMMITLOG - POOL " ) ; 
 + executor = new CommitLogExecutorService ( ) ; 
 setNextFileName ( ) ; 
 logWriter _ = CommitLog . createWriter ( logFile _ ) ; 
 writeCommitLogHeader ( ) ; 
 @ @ - 372 , 36 + 372 , 7 @ @ public class CommitLog 
 * / 
 CommitLogContext add ( final Row row ) throws IOException 
 { 
 - Callable < CommitLogContext > task = new Callable < CommitLogContext > ( ) 
 - { 
 - public CommitLogContext call ( ) throws Exception 
 - { 
 - long currentPosition = - 1L ; 
 - DataOutputBuffer cfBuffer = new DataOutputBuffer ( ) ; 
 - try 
 - { 
 - / * serialize the row * / 
 - Row . serializer ( ) . serialize ( row , cfBuffer ) ; 
 - currentPosition = logWriter _ . getCurrentPosition ( ) ; 
 - CommitLogContext cLogCtx = new CommitLogContext ( logFile _ , currentPosition ) ; 
 - / * Update the header * / 
 - maybeUpdateHeader ( row ) ; 
 - logWriter _ . writeLong ( cfBuffer . getLength ( ) ) ; 
 - logWriter _ . append ( cfBuffer ) ; 
 - if ( ! maybeRollLog ( ) ) 
 - { 
 - logWriter _ . sync ( ) ; 
 - } 
 - return cLogCtx ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - if ( currentPosition ! = - 1 ) 
 - logWriter _ . seek ( currentPosition ) ; 
 - throw e ; 
 - } 
 - } 
 - } ; 
 + Callable < CommitLogContext > task = new LogRecordAdder ( row ) ; 
 
 try 
 { 
 @ @ - 552 , 4 + 523 , 44 @ @ public class CommitLog 
 } 
 return false ; 
 } 
 - } 
 \ No newline at end of file 
 + 
 + void sync ( ) throws IOException 
 + { 
 + logWriter _ . sync ( ) ; 
 + } 
 + 
 + class LogRecordAdder implements Callable < CommitLog . CommitLogContext > 
 + { 
 + Row row ; 
 + 
 + LogRecordAdder ( Row row ) 
 + { 
 + this . row = row ; 
 + } 
 + 
 + public CommitLog . CommitLogContext call ( ) throws Exception 
 + { 
 + long currentPosition = - 1L ; 
 + DataOutputBuffer cfBuffer = new DataOutputBuffer ( ) ; 
 + try 
 + { 
 + / * serialize the row * / 
 + Row . serializer ( ) . serialize ( row , cfBuffer ) ; 
 + currentPosition = logWriter _ . getCurrentPosition ( ) ; 
 + CommitLogContext cLogCtx = new CommitLogContext ( logFile _ , currentPosition ) ; 
 + / * Update the header * / 
 + maybeUpdateHeader ( row ) ; 
 + logWriter _ . writeLong ( cfBuffer . getLength ( ) ) ; 
 + logWriter _ . append ( cfBuffer ) ; 
 + maybeRollLog ( ) ; 
 + return cLogCtx ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + if ( currentPosition ! = - 1 ) 
 + logWriter _ . seek ( currentPosition ) ; 
 + throw e ; 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / db / CommitLogExecutorService . java b / src / java / org / apache / cassandra / db / CommitLogExecutorService . java 
 new file mode 100644 
 index 0000000 . . 238ad5a 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / db / CommitLogExecutorService . java 
 @ @ - 0 , 0 + 1 , 153 @ @ 
 + package org . apache . cassandra . db ; 
 + 
 + import java . util . concurrent . * ; 
 + import java . util . List ; 
 + import java . util . Queue ; 
 + import java . util . ArrayList ; 
 + import java . io . IOException ; 
 + 
 + public class CommitLogExecutorService extends AbstractExecutorService 
 + { 
 + Queue < CheaterFutureTask > queue ; 
 + 
 + public CommitLogExecutorService ( ) 
 + { 
 + queue = new ConcurrentLinkedQueue < CheaterFutureTask > ( ) ; 
 + Runnable runnable = new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + while ( true ) 
 + { 
 + process ( ) ; 
 + } 
 + } 
 + } ; 
 + new Thread ( runnable ) . start ( ) ; 
 + } 
 + 
 + private ArrayList < CheaterFutureTask > incompleteTasks = new ArrayList < CheaterFutureTask > ( ) ; 
 + private ArrayList taskValues = new ArrayList ( ) ; / / TODO not sure how to generify this 
 + void process ( ) 
 + { 
 + while ( queue . isEmpty ( ) ) 
 + { 
 + try 
 + { 
 + Thread . sleep ( 1 ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + / / attempt to do a bunch of LogRecordAdder ops before syncing 
 + incompleteTasks . clear ( ) ; 
 + taskValues . clear ( ) ; 
 + while ( ! queue . isEmpty ( ) 
 + & & queue . peek ( ) . getRawCallable ( ) instanceof CommitLog . LogRecordAdder 
 + & & incompleteTasks . size ( ) < 20 ) 
 + { 
 + CheaterFutureTask task = queue . remove ( ) ; 
 + incompleteTasks . add ( task ) ; 
 + try 
 + { 
 + taskValues . add ( task . getRawCallable ( ) . call ( ) ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + / / it doesn ' t seem worth bothering future - izing the exception 
 + / / since if a commitlog op throws , we ' re probably screwed anyway 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + if ( incompleteTasks . size ( ) = = 0 ) 
 + { 
 + / / no LRAs ; just run the task 
 + queue . remove ( ) . run ( ) ; 
 + } 
 + else 
 + { 
 + / / now sync and set the tasks ' values ( which allows thread calling get ( ) to proceed ) 
 + try 
 + { 
 + CommitLog . open ( ) . sync ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + for ( int i = 0 ; i < incompleteTasks . size ( ) ; i + + ) 
 + { 
 + incompleteTasks . get ( i ) . set ( taskValues . get ( i ) ) ; 
 + } 
 + } 
 + } 
 + 
 + @ Override 
 + protected < T > RunnableFuture < T > newTaskFor ( Runnable runnable , T value ) 
 + { 
 + return newTaskFor ( Executors . callable ( runnable , value ) ) ; 
 + } 
 + 
 + @ Override 
 + protected < T > RunnableFuture < T > newTaskFor ( Callable < T > callable ) 
 + { 
 + return new CheaterFutureTask ( callable ) ; 
 + } 
 + 
 + public void execute ( Runnable command ) 
 + { 
 + queue . add ( ( CheaterFutureTask ) command ) ; 
 + } 
 + 
 + public boolean isShutdown ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + public boolean isTerminated ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + / / cassandra is crash - only so there ' s no need to implement the shutdown methods 
 + public void shutdown ( ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + public List < Runnable > shutdownNow ( ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + } 
 + 
 + class CheaterFutureTask < V > extends FutureTask < V > 
 + { 
 + private Callable rawCallable ; 
 + 
 + public CheaterFutureTask ( Callable < V > callable ) 
 + { 
 + super ( callable ) ; 
 + rawCallable = callable ; 
 + } 
 + 
 + public Callable getRawCallable ( ) 
 + { 
 + return rawCallable ; 
 + } 
 + 
 + @ Override 
 + public void set ( V v ) 
 + { 
 + super . set ( v ) ; 
 + } 
 + }
