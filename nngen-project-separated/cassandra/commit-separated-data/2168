BLEU SCORE: 0.02383853510228548

TEST MSG: Add syntax to remove multiple elements from a map
GENERATED MSG: conforming single - statement UPDATE impl

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b5c3a32 . . 0f1adf0 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 1 <nl> + * Add syntax to remove multiple elements from a map ( CASSANDRA - 6599 ) <nl> * Support non - equals conditions in lightweight transactions ( CASSANDRA - 6839 ) <nl> * Add IF [ NOT ] EXISTS to create / drop triggers ( CASSANDRA - 7606 ) <nl> * ( cqlsh ) Display the current logged - in user ( CASSANDRA - 7785 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Operation . java b / src / java / org / apache / cassandra / cql3 / Operation . java <nl> index 103606f . . ace466c 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Operation . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / Operation . java <nl> @ @ - 22 , 9 + 22 , 7 @ @ import java . nio . ByteBuffer ; <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> import org . apache . cassandra . db . ColumnFamily ; <nl> import org . apache . cassandra . db . composites . Composite ; <nl> - import org . apache . cassandra . db . marshal . CollectionType ; <nl> - import org . apache . cassandra . db . marshal . CounterColumnType ; <nl> - import org . apache . cassandra . db . marshal . ListType ; <nl> + import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> <nl> / * * <nl> @ @ - 291 , 23 + 289 , 26 @ @ public abstract class Operation <nl> <nl> public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException <nl> { <nl> - Term v = value . prepare ( keyspace , receiver ) ; <nl> - <nl> if ( ! ( receiver . type instanceof CollectionType ) ) <nl> { <nl> if ( ! ( receiver . type instanceof CounterColumnType ) ) <nl> throw new InvalidRequestException ( String . format ( " Invalid operation ( % s ) for non counter column % s " , toString ( receiver ) , receiver . name ) ) ; <nl> - return new Constants . Substracter ( receiver , v ) ; <nl> + return new Constants . Substracter ( receiver , value . prepare ( keyspace , receiver ) ) ; <nl> } <nl> <nl> switch ( ( ( CollectionType ) receiver . type ) . kind ) <nl> { <nl> case LIST : <nl> - return new Lists . Discarder ( receiver , v ) ; <nl> + return new Lists . Discarder ( receiver , value . prepare ( keyspace , receiver ) ) ; <nl> case SET : <nl> - return new Sets . Discarder ( receiver , v ) ; <nl> + return new Sets . Discarder ( receiver , value . prepare ( keyspace , receiver ) ) ; <nl> case MAP : <nl> - throw new InvalidRequestException ( String . format ( " Invalid operation ( % s ) for map column % s " , toString ( receiver ) , receiver ) ) ; <nl> + / / The value for a map substraction is actually a set <nl> + ColumnSpecification vr = new ColumnSpecification ( receiver . ksName , <nl> + receiver . cfName , <nl> + receiver . name , <nl> + SetType . getInstance ( ( ( MapType ) receiver . type ) . keys ) ) ; <nl> + return new Sets . Discarder ( receiver , value . prepare ( keyspace , vr ) ) ; <nl> } <nl> throw new AssertionError ( ) ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> index cb32577 . . c8401d2 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> @ @ - 43 , 6 + 43 , 7 @ @ import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . exceptions . * ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> + import org . apache . cassandra . serializers . TypeSerializer ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> @ @ - 142 , 6 + 143 , 11 @ @ public abstract class CQLTester <nl> } <nl> } <nl> <nl> + public boolean usePrepared ( ) <nl> + { <nl> + return USE _ PREPARED _ VALUES ; <nl> + } <nl> + <nl> private static void removeAllSSTables ( String ks , String table ) <nl> { <nl> / / clean up data directory which are stored as data directory / keyspace / data files <nl> @ @ - 272 , 8 + 278 , 8 @ @ public abstract class CQLTester <nl> ByteBuffer actualValue = actual . getBytes ( column . name . toString ( ) ) ; <nl> <nl> if ( ! Objects . equal ( expectedByteValue , actualValue ) ) <nl> - Assert . fail ( String . format ( " Invalid value for row % d column % d ( % s ) , expected < % s > but got < % s > " , <nl> - i , j , column . name , formatValue ( expectedByteValue , column . type ) , formatValue ( actualValue , column . type ) ) ) ; <nl> + Assert . fail ( String . format ( " Invalid value for row % d column % d ( % s of type % s ) , expected < % s > but got < % s > " , <nl> + i , j , column . name , column . type . asCQL3Type ( ) , formatValue ( expectedByteValue , column . type ) , formatValue ( actualValue , column . type ) ) ) ; <nl> } <nl> } <nl> <nl> @ @ - 311 , 9 + 317 , 28 @ @ public abstract class CQLTester <nl> try <nl> { <nl> execute ( query , values ) ; <nl> - Assert . fail ( " Query should be invalid but no error was thrown . Query is : " + query ) ; <nl> + String q = USE _ PREPARED _ VALUES <nl> + ? query + " ( values : " + formatAllValues ( values ) + " ) " <nl> + : replaceValues ( query , values ) ; <nl> + Assert . fail ( " Query should be invalid but no error was thrown . Query is : " + q ) ; <nl> } <nl> - catch ( SyntaxException | InvalidRequestException e ) <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + / / This is what we expect <nl> + } <nl> + } <nl> + <nl> + protected void assertInvalidSyntax ( String query , Object . . . values ) throws Throwable <nl> + { <nl> + try <nl> + { <nl> + execute ( query , values ) ; <nl> + String q = USE _ PREPARED _ VALUES <nl> + ? query + " ( values : " + formatAllValues ( values ) + " ) " <nl> + : replaceValues ( query , values ) ; <nl> + Assert . fail ( " Query should have invalid syntax but no error was thrown . Query is : " + q ) ; <nl> + } <nl> + catch ( SyntaxException e ) <nl> { <nl> / / This is what we expect <nl> } <nl> @ @ - 447 , 7 + 472 , 7 @ @ public abstract class CQLTester <nl> <nl> / / We need to reach inside collections for TupleValue . Besides , for some reason the format <nl> / / of collection that CollectionType . getString gives us is not at all ' CQL compatible ' <nl> - if ( value instanceof Collection ) <nl> + if ( value instanceof Collection | | value instanceof Map ) <nl> { <nl> StringBuilder sb = new StringBuilder ( ) ; <nl> if ( value instanceof List ) <nl> @ @ - 460 , 7 + 485 , 7 @ @ public abstract class CQLTester <nl> sb . append ( " , " ) ; <nl> sb . append ( formatForCQL ( l . get ( i ) ) ) ; <nl> } <nl> - sb . append ( " [ " ) ; <nl> + sb . append ( " ] " ) ; <nl> } <nl> else if ( value instanceof Set ) <nl> { <nl> @ @ - 520 , 7 + 545 , 19 @ @ public abstract class CQLTester <nl> <nl> private static String formatValue ( ByteBuffer bb , AbstractType < ? > type ) <nl> { <nl> - return bb = = null ? " null " : type . getString ( bb ) ; <nl> + if ( bb = = null ) <nl> + return " null " ; <nl> + <nl> + if ( type instanceof CollectionType ) <nl> + { <nl> + / / CollectionType override getString ( ) to use hexToBytes . We can ' t change that <nl> + / / without breaking SSTable2json , but the serializer for collection have the <nl> + / / right getString so using it directly instead . <nl> + TypeSerializer ser = type . getSerializer ( ) ; <nl> + return ser . toString ( ser . deserialize ( bb ) ) ; <nl> + } <nl> + <nl> + return type . getString ( bb ) ; <nl> } <nl> <nl> protected Object tuple ( Object . . . values ) <nl> @ @ - 544 , 7 + 581 , 7 @ @ public abstract class CQLTester <nl> throw new IllegalArgumentException ( ) ; <nl> <nl> int size = values . length / 2 ; <nl> - Map m = new HashMap ( size ) ; <nl> + Map m = new LinkedHashMap ( size ) ; <nl> for ( int i = 0 ; i < size ; i + + ) <nl> m . put ( values [ 2 * i ] , values [ ( 2 * i ) + 1 ] ) ; <nl> return m ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / CollectionsTest . java b / test / unit / org / apache / cassandra / cql3 / CollectionsTest . java <nl> new file mode 100644 <nl> index 0000000 . . 72a24f0 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / CollectionsTest . java <nl> @ @ - 0 , 0 + 1 , 227 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + public class CollectionsTest extends CQLTester <nl> + { <nl> + @ Test <nl> + public void testMapBulkRemoval ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , m map < text , text > ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( k , m ) VALUES ( ? , ? ) " , 0 , map ( " k1 " , " v1 " , " k2 " , " v2 " , " k3 " , " v3 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s " ) , <nl> + row ( 0 , map ( " k1 " , " v1 " , " k2 " , " v2 " , " k3 " , " v3 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET m = m - ? WHERE k = ? " , set ( " k2 " ) , 0 ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s " ) , <nl> + row ( 0 , map ( " k1 " , " v1 " , " k3 " , " v3 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET m = m + ? , m = m - ? WHERE k = ? " , map ( " k4 " , " v4 " ) , set ( " k3 " ) , 0 ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s " ) , <nl> + row ( 0 , map ( " k1 " , " v1 " , " k4 " , " v4 " ) ) <nl> + ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testInvalidCollectionsMix ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , l list < text > , s set < text > , m map < text , text > ) " ) ; <nl> + <nl> + / / Note : we force the non - prepared form for some of those tests because a list and a set <nl> + / / have the same serialized format in practice and CQLTester don ' t validate that the type <nl> + / / of what ' s passed as a value in the prepared case , so the queries would work ( which is ok , <nl> + / / CQLTester is just a " dumb " client ) . <nl> + <nl> + assertInvalid ( " UPDATE % s SET l = l + { ' a ' , ' b ' } WHERE k = 0 " ) ; <nl> + assertInvalid ( " UPDATE % s SET l = l - { ' a ' , ' b ' } WHERE k = 0 " ) ; <nl> + / / TODO : We should remove this ' if ' once # 7833 is resolved <nl> + if ( ! usePrepared ( ) ) <nl> + { <nl> + assertInvalid ( " UPDATE % s SET l = l + ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; <nl> + assertInvalid ( " UPDATE % s SET l = l - ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; <nl> + } <nl> + <nl> + assertInvalid ( " UPDATE % s SET s = s + [ ' a ' , ' b ' ] WHERE k = 0 " ) ; <nl> + assertInvalid ( " UPDATE % s SET s = s - [ ' a ' , ' b ' ] WHERE k = 0 " ) ; <nl> + / / TODO : We should remove this ' if ' once # 7833 is resolved <nl> + if ( ! usePrepared ( ) ) <nl> + { <nl> + assertInvalid ( " UPDATE % s SET s = s + ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; <nl> + assertInvalid ( " UPDATE % s SET s = s - ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; <nl> + } <nl> + <nl> + assertInvalid ( " UPDATE % s SET m = m + ? WHERE k = 0 " , list ( " a " , " b " ) ) ; <nl> + assertInvalid ( " UPDATE % s SET m = m - [ ' a ' , ' b ' ] WHERE k = 0 " ) ; <nl> + assertInvalid ( " UPDATE % s SET m = m + ? WHERE k = 0 " , set ( " a " , " b " ) ) ; <nl> + / / Note that we do allow substracting a set from a map , but not a map from a map <nl> + / / TODO : We should remove this ' if ' once # 7833 is resolved <nl> + if ( ! usePrepared ( ) ) <nl> + assertInvalid ( " UPDATE % s SET m = m - ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSets ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , s set < text > ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( k , s ) VALUES ( 0 , ? ) " , set ( " v1 " , " v2 " , " v3 " , " v4 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , <nl> + row ( set ( " v1 " , " v2 " , " v3 " , " v4 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " DELETE s [ ? ] FROM % s WHERE k = 0 " , " v1 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , <nl> + row ( set ( " v2 " , " v3 " , " v4 " ) ) <nl> + ) ; <nl> + <nl> + / / Full overwrite <nl> + execute ( " UPDATE % s SET s = ? WHERE k = 0 " , set ( " v6 " , " v5 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , <nl> + row ( set ( " v5 " , " v6 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET s = s + ? WHERE k = 0 " , set ( " v7 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , <nl> + row ( set ( " v5 " , " v6 " , " v7 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET s = s - ? WHERE k = 0 " , set ( " v6 " , " v5 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , <nl> + row ( set ( " v7 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " DELETE s FROM % s WHERE k = 0 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , <nl> + row ( ( Object ) null ) <nl> + ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testMaps ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , m map < text , int > ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( k , m ) VALUES ( 0 , ? ) " , map ( " v1 " , 1 , " v2 " , 2 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , <nl> + row ( map ( " v1 " , 1 , " v2 " , 2 ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET m [ ? ] = ? , m [ ? ] = ? WHERE k = 0 " , " v3 " , 3 , " v4 " , 4 ) ; <nl> + <nl> + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , <nl> + row ( map ( " v1 " , 1 , " v2 " , 2 , " v3 " , 3 , " v4 " , 4 ) ) <nl> + ) ; <nl> + <nl> + execute ( " DELETE m [ ? ] FROM % s WHERE k = 0 " , " v1 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , <nl> + row ( map ( " v2 " , 2 , " v3 " , 3 , " v4 " , 4 ) ) <nl> + ) ; <nl> + <nl> + / / Full overwrite <nl> + execute ( " UPDATE % s SET m = ? WHERE k = 0 " , map ( " v6 " , 6 , " v5 " , 5 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , <nl> + row ( map ( " v5 " , 5 , " v6 " , 6 ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET m = m + ? WHERE k = 0 " , map ( " v7 " , 7 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , <nl> + row ( map ( " v5 " , 5 , " v6 " , 6 , " v7 " , 7 ) ) <nl> + ) ; <nl> + <nl> + / / The empty map is parsed as an empty set ( because we don ' t have enough info at parsing <nl> + / / time when we see a { } ) and special cased later . This test checks this work properly <nl> + execute ( " UPDATE % s SET m = { } WHERE k = 0 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , <nl> + row ( ( Object ) null ) <nl> + ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testLists ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , l list < text > ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( k , l ) VALUES ( 0 , ? ) " , list ( " v1 " , " v2 " , " v3 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , <nl> + row ( list ( " v1 " , " v2 " , " v3 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " DELETE l [ ? ] FROM % s WHERE k = 0 " , 1 ) ; <nl> + <nl> + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , <nl> + row ( list ( " v1 " , " v3 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET l [ ? ] = ? WHERE k = 0 " , 1 , " v4 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , <nl> + row ( list ( " v1 " , " v4 " ) ) <nl> + ) ; <nl> + <nl> + / / Full overwrite <nl> + execute ( " UPDATE % s SET l = ? WHERE k = 0 " , list ( " v6 " , " v5 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , <nl> + row ( list ( " v6 " , " v5 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET l = l + ? WHERE k = 0 " , list ( " v7 " , " v8 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , <nl> + row ( list ( " v6 " , " v5 " , " v7 " , " v8 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET l = ? + l WHERE k = 0 " , list ( " v9 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , <nl> + row ( list ( " v9 " , " v6 " , " v5 " , " v7 " , " v8 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " UPDATE % s SET l = l - ? WHERE k = 0 " , list ( " v5 " , " v8 " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , <nl> + row ( list ( " v9 " , " v6 " , " v7 " ) ) <nl> + ) ; <nl> + <nl> + execute ( " DELETE l FROM % s WHERE k = 0 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , <nl> + row ( ( Object ) null ) <nl> + ) ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / MultiColumnRelationTest . java b / test / unit / org / apache / cassandra / cql3 / MultiColumnRelationTest . java <nl> index daf0835 . . bfc6d2d 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / MultiColumnRelationTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / MultiColumnRelationTest . java <nl> @ @ - 26 , 7 + 26 , 7 @ @ public class MultiColumnRelationTest extends CQLTester <nl> { <nl> createTable ( " CREATE TABLE % s ( a int , b int , c int , PRIMARY KEY ( a , b ) ) " ) ; <nl> <nl> - assertInvalid ( " SELECT * FROM % s WHERE ( ) = ( ? , ? ) " , 1 , 2 ) ; <nl> + assertInvalidSyntax ( " SELECT * FROM % s WHERE ( ) = ( ? , ? ) " , 1 , 2 ) ; <nl> assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b ) = ( ? ) AND ( b ) > ( ? ) " , 0 , 0 ) ; <nl> assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b ) > ( ? ) AND ( b ) > ( ? ) " , 0 , 1 ) ; <nl> assertInvalid ( " SELECT * FROM % s WHERE ( a , b ) = ( ? , ? ) " , 0 , 0 ) ; <nl> @ @ - 37 , 7 + 37 , 7 @ @ public class MultiColumnRelationTest extends CQLTester <nl> { <nl> createTable ( " CREATE TABLE % s ( a int , b int , c int , d int , PRIMARY KEY ( a , b , c , d ) ) " ) ; <nl> <nl> - assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b , c ) > ( ) " ) ; <nl> + assertInvalidSyntax ( " SELECT * FROM % s WHERE a = 0 AND ( b , c ) > ( ) " ) ; <nl> assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b , c ) > ( ? , ? , ? ) " , 1 , 2 , 3 ) ; <nl> assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b , c ) > ( ? , ? ) " , 1 , null ) ; <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / TupleTypeTest . java b / test / unit / org / apache / cassandra / cql3 / TupleTypeTest . java <nl> index 84512a5 . . 354a8f9 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / TupleTypeTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / TupleTypeTest . java <nl> @ @ - 91 , 7 + 91 , 7 @ @ public class TupleTypeTest extends CQLTester <nl> { <nl> createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , t tuple < int , text , double > ) " ) ; <nl> <nl> - assertInvalid ( " INSERT INTO % s ( k , t ) VALUES ( 0 , ( ) ) " ) ; <nl> + assertInvalidSyntax ( " INSERT INTO % s ( k , t ) VALUES ( 0 , ( ) ) " ) ; <nl> assertInvalid ( " INSERT INTO % s ( k , t ) VALUES ( 0 , ( 2 , ' foo ' , 3 . 1 , ' bar ' ) ) " ) ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / UserTypesTest . java b / test / unit / org / apache / cassandra / cql3 / UserTypesTest . java <nl> index c7f1851 . . 0dfb6f7 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / UserTypesTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / UserTypesTest . java <nl> @ @ - 41 , 14 + 41 , 12 @ @ public class UserTypesTest extends CQLTester <nl> execute ( " INSERT INTO % s ( k , v ) VALUES ( ? , { x : ? } ) " , 1 , - 104 . 99251 ) ; <nl> execute ( " UPDATE % s SET b = ? WHERE k = ? " , true , 1 ) ; <nl> <nl> - System . out . println ( " - - First query " ) ; <nl> assertRows ( execute ( " SELECT v . x FROM % s WHERE k = ? AND v = { x : ? } " , 1 , - 104 . 99251 ) , <nl> row ( - 104 . 99251 ) <nl> ) ; <nl> <nl> flush ( ) ; <nl> <nl> - System . out . println ( " - - 2nd query " ) ; <nl> assertRows ( execute ( " SELECT v . x FROM % s WHERE k = ? AND v = { x : ? } " , 1 , - 104 . 99251 ) , <nl> row ( - 104 . 99251 ) <nl> ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql / Column . java b / src / java / org / apache / cassandra / cql / Column . java <nl> deleted file mode 100644 <nl> index bcfc913 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / cql / Column . java <nl> + + + / dev / null <nl> @ @ - 1 , 47 + 0 , 0 @ @ <nl> - / * <nl> - * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , <nl> - * software distributed under the License is distributed on an <nl> - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> - * KIND , either express or implied . See the License for the <nl> - * specific language governing permissions and limitations <nl> - * under the License . <nl> - * <nl> - * / <nl> - package org . apache . cassandra . cql ; <nl> - <nl> - / * * <nl> - * Represents a column definition parsed from CQL query statement . <nl> - * <nl> - * / <nl> - public class Column <nl> - { <nl> - private final Term name ; <nl> - private final Term value ; <nl> - <nl> - public Column ( Term name , Term value ) <nl> - { <nl> - this . name = name ; <nl> - this . value = value ; <nl> - } <nl> - <nl> - public Term getName ( ) <nl> - { <nl> - return name ; <nl> - } <nl> - <nl> - public Term getValue ( ) <nl> - { <nl> - return value ; <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / cql / Cql . g b / src / java / org / apache / cassandra / cql / Cql . g <nl> index 0f0327b . . a584f23 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql / Cql . g <nl> @ @ - 6 , 7 + 6 , 8 @ @ options { <nl> <nl> @ header { <nl> package org . apache . cassandra . cql ; <nl> - import java . util . ArrayList ; <nl> + import java . util . Map ; <nl> + import java . util . HashMap ; <nl> import org . apache . cassandra . thrift . ConsistencyLevel ; <nl> import org . apache . cassandra . avro . InvalidRequestException ; <nl> } <nl> @ @ - 93 , 17 + 94 , 24 @ @ selectStatement returns [ SelectStatement expr ] <nl> * < CF > <nl> * USING <nl> * CONSISTENCY . ONE <nl> - * WITH <nl> - * ROW ( " key1 " , COL ( " col1 " , " val1 " ) , . . . ) AND <nl> - * ROW ( " key2 " , COL ( " col1 " , " val1 " ) , . . . ) AND <nl> - * ROW ( " key3 " , COLUMN ( " col1 " , " val1 " ) , . . . ) <nl> + * SET <nl> + * name1 = value1 , <nl> + * name2 = value2 <nl> + * WHERE <nl> + * KEY = keyname ; <nl> * / <nl> updateStatement returns [ UpdateStatement expr ] <nl> - : { ConsistencyLevel cLevel = ConsistencyLevel . ONE ; } <nl> - K _ UPDATE IDENT <nl> + : { <nl> + ConsistencyLevel cLevel = ConsistencyLevel . ONE ; <nl> + Map < Term , Term > columns = new HashMap < Term , Term > ( ) ; <nl> + } <nl> + K _ UPDATE columnFamily = IDENT <nl> ( K _ USING K _ CONSISTENCY ' . ' K _ LEVEL { cLevel = ConsistencyLevel . valueOf ( $ K _ LEVEL . text ) ; } ) ? <nl> - K _ WITH first = rowDef { $ expr = new UpdateStatement ( $ IDENT . text , first , cLevel ) ; } <nl> - ( K _ AND next = rowDef { $ expr . and ( next ) ; } ) * endStmnt <nl> + K _ SET c1 = term ' = ' v1 = term { columns . put ( c1 , v1 ) ; } ( ' , ' cN = term ' = ' vN = term { columns . put ( cN , vN ) ; } ) * <nl> + K _ WHERE K _ KEY ' = ' key = term endStmnt <nl> + { <nl> + return new UpdateStatement ( $ columnFamily . text , cLevel , columns , key ) ; <nl> + } <nl> ; <nl> <nl> / / TODO : date / time , utf8 <nl> @ @ - 139 , 15 + 147 , 6 @ @ selectExpression returns [ SelectExpression expr ] <nl> | start = term ' . . ' finish = term { $ expr = new SelectExpression ( start , finish , count , reversed ) ; } <nl> ) <nl> ; <nl> - <nl> - columnDef returns [ Column column ] <nl> - : K _ COLUMN ' ( ' n = term ' , ' v = term ' ) ' { $ column = new Column ( $ n . item , $ v . item ) ; } <nl> - ; <nl> - <nl> - rowDef returns [ Row row ] <nl> - : K _ ROW ' ( ' key = term ' , ' first = columnDef { $ row = new Row ( $ key . item , first ) ; } <nl> - ( ' , ' next = columnDef { $ row . and ( next ) ; } ) * ' ) ' <nl> - ; <nl> <nl> endStmnt <nl> : ( EOF | ' ; ' ) <nl> @ @ - 177 , 6 + 176 , 7 @ @ K _ USE : U S E ; <nl> K _ FIRST : F I R S T ; <nl> K _ REVERSED : R E V E R S E D ; <nl> K _ COUNT : C O U N T ; <nl> + K _ SET : S E T ; <nl> <nl> / / Case - insensitive alpha characters <nl> fragment A : ( ' a ' | ' A ' ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql / QueryProcessor . java b / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> index 8a32b72 . . 32ac6aa 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> @ @ - 24 , 9 + 24 , 11 @ @ package org . apache . cassandra . cql ; <nl> import java . io . IOException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> + import java . util . Arrays ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> import java . util . List ; <nl> + import java . util . Map ; <nl> import java . util . Set ; <nl> import java . util . concurrent . TimeoutException ; <nl> <nl> @ @ - 56 , 6 + 58 , 7 @ @ import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . StorageProxy ; <nl> import org . apache . cassandra . service . StorageService ; <nl> + import org . apache . cassandra . thrift . ConsistencyLevel ; <nl> import org . apache . cassandra . thrift . IndexClause ; <nl> import org . apache . cassandra . thrift . IndexExpression ; <nl> import org . apache . cassandra . thrift . IndexOperator ; <nl> @ @ - 208 , 6 + 211 , 43 @ @ public class QueryProcessor <nl> return rows ; <nl> } <nl> <nl> + private static void batchUpdate ( String keyspace , List < UpdateStatement > updateStatements ) <nl> + throws InvalidRequestException , UnavailableException , TimedOutException <nl> + { <nl> + ConsistencyLevel consistency = updateStatements . get ( 0 ) . getConsistencyLevel ( ) ; <nl> + List < RowMutation > rowMutations = new ArrayList < RowMutation > ( ) ; <nl> + <nl> + for ( UpdateStatement update : updateStatements ) <nl> + { <nl> + ByteBuffer key = update . getKey ( ) . getByteBuffer ( ) ; <nl> + validateKey ( key ) ; <nl> + validateColumnFamily ( keyspace , update . getColumnFamily ( ) ) ; <nl> + <nl> + RowMutation rm = new RowMutation ( keyspace , key ) ; <nl> + for ( Map . Entry < Term , Term > column : update . getColumns ( ) . entrySet ( ) ) <nl> + { <nl> + rm . add ( new QueryPath ( update . getColumnFamily ( ) , null , column . getKey ( ) . getByteBuffer ( ) ) , <nl> + column . getValue ( ) . getByteBuffer ( ) , <nl> + System . currentTimeMillis ( ) ) ; <nl> + } <nl> + <nl> + rowMutations . add ( rm ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + StorageProxy . mutate ( rowMutations , consistency ) ; <nl> + } <nl> + catch ( org . apache . cassandra . thrift . UnavailableException e ) <nl> + { <nl> + throw new UnavailableException ( ) ; <nl> + } <nl> + catch ( TimeoutException e ) <nl> + { <nl> + throw new TimedOutException ( ) ; <nl> + } <nl> + } <nl> + <nl> private static SlicePredicate slicePredicateFromSelect ( SelectStatement select ) <nl> { <nl> SlicePredicate thriftSlicePredicate = new SlicePredicate ( ) ; <nl> @ @ - 352 , 40 + 392 , 8 @ @ public class QueryProcessor <nl> <nl> case UPDATE : <nl> UpdateStatement update = ( UpdateStatement ) statement . statement ; <nl> - validateColumnFamily ( keyspace , update . getColumnFamily ( ) ) ; <nl> - <nl> + batchUpdate ( keyspace , Collections . singletonList ( update ) ) ; <nl> avroResult . type = CqlResultType . VOID ; <nl> - <nl> - List < RowMutation > rowMutations = new ArrayList < RowMutation > ( ) ; <nl> - <nl> - for ( Row row : update . getRows ( ) ) <nl> - { <nl> - validateKey ( row . getKey ( ) . getByteBuffer ( ) ) ; <nl> - RowMutation rm = new RowMutation ( keyspace , row . getKey ( ) . getByteBuffer ( ) ) ; <nl> - <nl> - for ( org . apache . cassandra . cql . Column col : row . getColumns ( ) ) <nl> - { <nl> - rm . add ( new QueryPath ( update . getColumnFamily ( ) , null , col . getName ( ) . getByteBuffer ( ) ) , <nl> - col . getValue ( ) . getByteBuffer ( ) , <nl> - System . currentTimeMillis ( ) ) ; <nl> - } <nl> - <nl> - rowMutations . add ( rm ) ; <nl> - } <nl> - <nl> - try <nl> - { <nl> - StorageProxy . mutate ( rowMutations , update . getConsistencyLevel ( ) ) ; <nl> - } <nl> - catch ( org . apache . cassandra . thrift . UnavailableException e ) <nl> - { <nl> - throw new UnavailableException ( ) ; <nl> - } <nl> - catch ( TimeoutException e ) <nl> - { <nl> - throw new TimedOutException ( ) ; <nl> - } <nl> - <nl> return avroResult ; <nl> <nl> case USE : <nl> diff - - git a / src / java / org / apache / cassandra / cql / Row . java b / src / java / org / apache / cassandra / cql / Row . java <nl> deleted file mode 100644 <nl> index 1ab7390 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / cql / Row . java <nl> + + + / dev / null <nl> @ @ - 1 , 60 + 0 , 0 @ @ <nl> - / * <nl> - * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , <nl> - * software distributed under the License is distributed on an <nl> - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> - * KIND , either express or implied . See the License for the <nl> - * specific language governing permissions and limitations <nl> - * under the License . <nl> - * <nl> - * / <nl> - package org . apache . cassandra . cql ; <nl> - <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> - <nl> - / * * <nl> - * Represents a row parsed from a CQL statement . <nl> - * <nl> - * / <nl> - public class Row <nl> - { <nl> - private final Term key ; <nl> - private List < Column > columns = new ArrayList < Column > ( ) ; <nl> - <nl> - public Row ( Term key , Column firstColumn ) <nl> - { <nl> - this . key = key ; <nl> - columns . add ( firstColumn ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Add a new column definition to this row . <nl> - * <nl> - * @ param col the CQL column to add . <nl> - * / <nl> - public void and ( Column col ) <nl> - { <nl> - columns . add ( col ) ; <nl> - } <nl> - <nl> - public Term getKey ( ) <nl> - { <nl> - return key ; <nl> - } <nl> - <nl> - public List < Column > getColumns ( ) <nl> - { <nl> - return columns ; <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / cql / UpdateStatement . java b / src / java / org / apache / cassandra / cql / UpdateStatement . java <nl> index 64eef3f . . 26f572b 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / UpdateStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql / UpdateStatement . java <nl> @ @ - 20 , 8 + 20 , 8 @ @ <nl> * / <nl> package org . apache . cassandra . cql ; <nl> <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> + import java . util . Map ; <nl> + <nl> import org . apache . cassandra . thrift . ConsistencyLevel ; <nl> <nl> / * * <nl> @ @ - 31 , 37 + 31 , 25 @ @ import org . apache . cassandra . thrift . ConsistencyLevel ; <nl> public class UpdateStatement <nl> { <nl> private String columnFamily ; <nl> - private List < Row > rows = new ArrayList < Row > ( ) ; <nl> private ConsistencyLevel cLevel ; <nl> + private Map < Term , Term > columns ; <nl> + private Term key ; <nl> <nl> / * * <nl> - * Creates a new UpdateStatement from a column family name , a row definition , <nl> - * and a consistency level . <nl> + * Creates a new UpdateStatement from a column family name , columns map , consistency <nl> + * level , and key term . <nl> * <nl> * @ param columnFamily column family name <nl> - * @ param first a row definition instance <nl> * @ param cLevel the thrift consistency level <nl> + * @ param columns a map of column name / values pairs <nl> + * @ param key the key name <nl> * / <nl> - public UpdateStatement ( String columnFamily , Row first , ConsistencyLevel cLevel ) <nl> + public UpdateStatement ( String columnFamily , ConsistencyLevel cLevel , Map < Term , Term > columns , Term key ) <nl> { <nl> this . columnFamily = columnFamily ; <nl> this . cLevel = cLevel ; <nl> - and ( first ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Adds a new row definition to this < code > UPDATE < / code > . <nl> - * <nl> - * @ param row the row definition to add . <nl> - * / <nl> - public void and ( Row row ) <nl> - { <nl> - rows . add ( row ) ; <nl> - } <nl> - <nl> - public List < Row > getRows ( ) <nl> - { <nl> - return rows ; <nl> + this . columns = columns ; <nl> + this . key = key ; <nl> } <nl> <nl> public ConsistencyLevel getConsistencyLevel ( ) <nl> @ @ - 74 , 9 + 62 , 22 @ @ public class UpdateStatement <nl> return columnFamily ; <nl> } <nl> <nl> + public Term getKey ( ) <nl> + { <nl> + return key ; <nl> + } <nl> + <nl> + public Map < Term , Term > getColumns ( ) <nl> + { <nl> + return columns ; <nl> + } <nl> + <nl> public String toString ( ) <nl> { <nl> - return " UpdateStatement ( columnFamily = " + columnFamily + " , " + <nl> - " row = " + rows + " , " + " consistency = " + cLevel + " ) " ; <nl> + return String . format ( " UpdateStatement ( columnFamily = % s , key = % s , columns = % s , consistency = % s ) " , <nl> + columnFamily , <nl> + key , <nl> + columns , <nl> + cLevel ) ; <nl> } <nl> } <nl> diff - - git a / test / system / test _ cql . py b / test / system / test _ cql . py <nl> index 89f044f . . 381da6f 100644 <nl> - - - a / test / system / test _ cql . py <nl> + + + b / test / system / test _ cql . py <nl> @ @ - 10 , 35 + 10 , 66 @ @ from avro _ utils import assert _ raises <nl> <nl> def load _ sample ( dbconn ) : <nl> dbconn . execute ( " " " <nl> - UPDATE <nl> - Standard1 <nl> - WITH <nl> - ROW ( " ka " , COL ( " ca1 " , " va1 " ) , COL ( " col " , " val " ) ) AND <nl> - ROW ( " kb " , COL ( " cb1 " , " vb1 " ) , COL ( " col " , " val " ) ) AND <nl> - ROW ( " kc " , COL ( " cc1 " , " vc1 " ) , COL ( " col " , " val " ) ) AND <nl> - ROW ( " kd " , COL ( " cd1 " , " vd1 " ) , COL ( " col " , " val " ) ) ; <nl> - " " " ) <nl> - dbconn . execute ( " " " <nl> - UPDATE <nl> - StandardLong1 <nl> - WITH <nl> - ROW ( " aa " , COL ( 1L , " 1 " ) , COL ( 2L , " 2 " ) , COL ( 3L , " 3 " ) , COL ( 4L , " 4 " ) ) AND <nl> - ROW ( " ab " , COL ( 5L , " 5 " ) , COL ( 6L , " 6 " ) , COL ( 7L , " 8 " ) , COL ( 9L , " 9 " ) ) AND <nl> - ROW ( " ac " , COL ( 9L , " 9 " ) , COL ( 8L , " 8 " ) , COL ( 7L , " 7 " ) , COL ( 6L , " 6 " ) ) AND <nl> - ROW ( " ad " , COL ( 5L , " 5 " ) , COL ( 4L , " 4 " ) , COL ( 3L , " 3 " ) , COL ( 2L , " 2 " ) ) AND <nl> - ROW ( " ae " , COL ( 1L , " 1 " ) , COL ( 2L , " 2 " ) , COL ( 3L , " 3 " ) , COL ( 4L , " 4 " ) ) AND <nl> - ROW ( " af " , COL ( 1L , " 1 " ) , COL ( 2L , " 2 " ) , COL ( 3L , " 3 " ) , COL ( 4L , " 4 " ) ) AND <nl> - ROW ( " ag " , COL ( 5L , " 5 " ) , COL ( 6L , " 6 " ) , COL ( 7L , " 8 " ) , COL ( 9L , " 9 " ) ) ; <nl> - " " " ) <nl> - dbconn . execute ( " " " <nl> - UPDATE <nl> - Indexed1 <nl> - WITH <nl> - ROW ( " asmith " , COL ( " birthdate " , 100L ) , COL ( " unindexed " , 250L ) ) AND <nl> - ROW ( " dozer " , COL ( " birthdate " , 100L ) , COL ( " unindexed " , 200L ) ) AND <nl> - ROW ( " morpheus " , COL ( " birthdate " , 175L ) , COL ( " unindexed " , 200L ) ) AND <nl> - ROW ( " neo " , COL ( " birthdate " , 150L ) , COL ( " unindexed " , 250L ) ) AND <nl> - ROW ( " trinity " , COL ( " birthdate " , 125L ) , COL ( " unindexed " , 200L ) ) ; <nl> + UPDATE Standard1 SET " ca1 " = " va1 " , " col " = " val " WHERE KEY = " ka " <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE Standard1 SET " cb1 " = " vb1 " , " col " = " val " WHERE KEY = " kb " <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE Standard1 SET " cc1 " = " vc1 " , " col " = " val " WHERE KEY = " kc " <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE Standard1 SET " cd1 " = " vd1 " , " col " = " val " WHERE KEY = " kd " <nl> + " " " ) <nl> + <nl> + dbconn . execute ( " " " <nl> + UPDATE StandardLong1 SET 1L = " 1 " , 2L = " 2 " , 3L = " 3 " , 4L = " 4 " <nl> + WHERE KEY = " aa " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE StandardLong1 SET 5L = " 5 " , 6L = " 6 " , 7L = " 8 " , 9L = " 9 " <nl> + WHERE KEY = " ab " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE StandardLong1 SET 9L = " 9 " , 8L = " 8 " , 7L = " 7 " , 6L = " 6 " <nl> + WHERE KEY = " ac " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE StandardLong1 SET 5L = " 5 " , 4L = " 4 " , 3L = " 3 " , 2L = " 2 " <nl> + WHERE KEY = " ad " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE StandardLong1 SET 1L = " 1 " , 2L = " 2 " , 3L = " 3 " , 4L = " 4 " <nl> + WHERE KEY = " ae " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE StandardLong1 SET 1L = " 1 " , 2L = " 2 " , 3L = " 3 " , 4L = " 4 " <nl> + WHERE KEY = " af " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE StandardLong1 SET 5L = " 5 " , 6L = " 6 " , 7L = " 8 " , 9L = " 9 " <nl> + WHERE KEY = " ag " ; <nl> + " " " ) <nl> + <nl> + dbconn . execute ( " " " <nl> + UPDATE Indexed1 SET " birthdate " = 100L , " unindexed " = 250L <nl> + WHERE KEY = " asmith " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE Indexed1 SET " birthdate " = 100L , " unindexed " = 200L <nl> + WHERE KEY = " dozer " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE Indexed1 SET " birthdate " = 175L , " unindexed " = 200L <nl> + WHERE KEY = " morpheus " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE Indexed1 SET " birthdate " = 150L , " unindexed " = 250L <nl> + WHERE KEY = " neo " ; <nl> + " " " ) <nl> + dbconn . execute ( " " " <nl> + UPDATE Indexed1 SET " birthdate " = 125L , " unindexed " = 200L <nl> + WHERE KEY = " trinity " ; <nl> " " " ) <nl> <nl> def init ( keyspace = " Keyspace1 " ) :

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b5c3a32 . . 0f1adf0 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 1 
 + * Add syntax to remove multiple elements from a map ( CASSANDRA - 6599 ) 
 * Support non - equals conditions in lightweight transactions ( CASSANDRA - 6839 ) 
 * Add IF [ NOT ] EXISTS to create / drop triggers ( CASSANDRA - 7606 ) 
 * ( cqlsh ) Display the current logged - in user ( CASSANDRA - 7785 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Operation . java b / src / java / org / apache / cassandra / cql3 / Operation . java 
 index 103606f . . ace466c 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Operation . java 
 + + + b / src / java / org / apache / cassandra / cql3 / Operation . java 
 @ @ - 22 , 9 + 22 , 7 @ @ import java . nio . ByteBuffer ; 
 import org . apache . cassandra . config . ColumnDefinition ; 
 import org . apache . cassandra . db . ColumnFamily ; 
 import org . apache . cassandra . db . composites . Composite ; 
 - import org . apache . cassandra . db . marshal . CollectionType ; 
 - import org . apache . cassandra . db . marshal . CounterColumnType ; 
 - import org . apache . cassandra . db . marshal . ListType ; 
 + import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 
 / * * 
 @ @ - 291 , 23 + 289 , 26 @ @ public abstract class Operation 
 
 public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException 
 { 
 - Term v = value . prepare ( keyspace , receiver ) ; 
 - 
 if ( ! ( receiver . type instanceof CollectionType ) ) 
 { 
 if ( ! ( receiver . type instanceof CounterColumnType ) ) 
 throw new InvalidRequestException ( String . format ( " Invalid operation ( % s ) for non counter column % s " , toString ( receiver ) , receiver . name ) ) ; 
 - return new Constants . Substracter ( receiver , v ) ; 
 + return new Constants . Substracter ( receiver , value . prepare ( keyspace , receiver ) ) ; 
 } 
 
 switch ( ( ( CollectionType ) receiver . type ) . kind ) 
 { 
 case LIST : 
 - return new Lists . Discarder ( receiver , v ) ; 
 + return new Lists . Discarder ( receiver , value . prepare ( keyspace , receiver ) ) ; 
 case SET : 
 - return new Sets . Discarder ( receiver , v ) ; 
 + return new Sets . Discarder ( receiver , value . prepare ( keyspace , receiver ) ) ; 
 case MAP : 
 - throw new InvalidRequestException ( String . format ( " Invalid operation ( % s ) for map column % s " , toString ( receiver ) , receiver ) ) ; 
 + / / The value for a map substraction is actually a set 
 + ColumnSpecification vr = new ColumnSpecification ( receiver . ksName , 
 + receiver . cfName , 
 + receiver . name , 
 + SetType . getInstance ( ( ( MapType ) receiver . type ) . keys ) ) ; 
 + return new Sets . Discarder ( receiver , value . prepare ( keyspace , vr ) ) ; 
 } 
 throw new AssertionError ( ) ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 index cb32577 . . c8401d2 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 @ @ - 43 , 6 + 43 , 7 @ @ import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . exceptions . * ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 + import org . apache . cassandra . serializers . TypeSerializer ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 @ @ - 142 , 6 + 143 , 11 @ @ public abstract class CQLTester 
 } 
 } 
 
 + public boolean usePrepared ( ) 
 + { 
 + return USE _ PREPARED _ VALUES ; 
 + } 
 + 
 private static void removeAllSSTables ( String ks , String table ) 
 { 
 / / clean up data directory which are stored as data directory / keyspace / data files 
 @ @ - 272 , 8 + 278 , 8 @ @ public abstract class CQLTester 
 ByteBuffer actualValue = actual . getBytes ( column . name . toString ( ) ) ; 
 
 if ( ! Objects . equal ( expectedByteValue , actualValue ) ) 
 - Assert . fail ( String . format ( " Invalid value for row % d column % d ( % s ) , expected < % s > but got < % s > " , 
 - i , j , column . name , formatValue ( expectedByteValue , column . type ) , formatValue ( actualValue , column . type ) ) ) ; 
 + Assert . fail ( String . format ( " Invalid value for row % d column % d ( % s of type % s ) , expected < % s > but got < % s > " , 
 + i , j , column . name , column . type . asCQL3Type ( ) , formatValue ( expectedByteValue , column . type ) , formatValue ( actualValue , column . type ) ) ) ; 
 } 
 } 
 
 @ @ - 311 , 9 + 317 , 28 @ @ public abstract class CQLTester 
 try 
 { 
 execute ( query , values ) ; 
 - Assert . fail ( " Query should be invalid but no error was thrown . Query is : " + query ) ; 
 + String q = USE _ PREPARED _ VALUES 
 + ? query + " ( values : " + formatAllValues ( values ) + " ) " 
 + : replaceValues ( query , values ) ; 
 + Assert . fail ( " Query should be invalid but no error was thrown . Query is : " + q ) ; 
 } 
 - catch ( SyntaxException | InvalidRequestException e ) 
 + catch ( InvalidRequestException e ) 
 + { 
 + / / This is what we expect 
 + } 
 + } 
 + 
 + protected void assertInvalidSyntax ( String query , Object . . . values ) throws Throwable 
 + { 
 + try 
 + { 
 + execute ( query , values ) ; 
 + String q = USE _ PREPARED _ VALUES 
 + ? query + " ( values : " + formatAllValues ( values ) + " ) " 
 + : replaceValues ( query , values ) ; 
 + Assert . fail ( " Query should have invalid syntax but no error was thrown . Query is : " + q ) ; 
 + } 
 + catch ( SyntaxException e ) 
 { 
 / / This is what we expect 
 } 
 @ @ - 447 , 7 + 472 , 7 @ @ public abstract class CQLTester 
 
 / / We need to reach inside collections for TupleValue . Besides , for some reason the format 
 / / of collection that CollectionType . getString gives us is not at all ' CQL compatible ' 
 - if ( value instanceof Collection ) 
 + if ( value instanceof Collection | | value instanceof Map ) 
 { 
 StringBuilder sb = new StringBuilder ( ) ; 
 if ( value instanceof List ) 
 @ @ - 460 , 7 + 485 , 7 @ @ public abstract class CQLTester 
 sb . append ( " , " ) ; 
 sb . append ( formatForCQL ( l . get ( i ) ) ) ; 
 } 
 - sb . append ( " [ " ) ; 
 + sb . append ( " ] " ) ; 
 } 
 else if ( value instanceof Set ) 
 { 
 @ @ - 520 , 7 + 545 , 19 @ @ public abstract class CQLTester 
 
 private static String formatValue ( ByteBuffer bb , AbstractType < ? > type ) 
 { 
 - return bb = = null ? " null " : type . getString ( bb ) ; 
 + if ( bb = = null ) 
 + return " null " ; 
 + 
 + if ( type instanceof CollectionType ) 
 + { 
 + / / CollectionType override getString ( ) to use hexToBytes . We can ' t change that 
 + / / without breaking SSTable2json , but the serializer for collection have the 
 + / / right getString so using it directly instead . 
 + TypeSerializer ser = type . getSerializer ( ) ; 
 + return ser . toString ( ser . deserialize ( bb ) ) ; 
 + } 
 + 
 + return type . getString ( bb ) ; 
 } 
 
 protected Object tuple ( Object . . . values ) 
 @ @ - 544 , 7 + 581 , 7 @ @ public abstract class CQLTester 
 throw new IllegalArgumentException ( ) ; 
 
 int size = values . length / 2 ; 
 - Map m = new HashMap ( size ) ; 
 + Map m = new LinkedHashMap ( size ) ; 
 for ( int i = 0 ; i < size ; i + + ) 
 m . put ( values [ 2 * i ] , values [ ( 2 * i ) + 1 ] ) ; 
 return m ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / CollectionsTest . java b / test / unit / org / apache / cassandra / cql3 / CollectionsTest . java 
 new file mode 100644 
 index 0000000 . . 72a24f0 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / CollectionsTest . java 
 @ @ - 0 , 0 + 1 , 227 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import org . junit . Test ; 
 + 
 + public class CollectionsTest extends CQLTester 
 + { 
 + @ Test 
 + public void testMapBulkRemoval ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , m map < text , text > ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( k , m ) VALUES ( ? , ? ) " , 0 , map ( " k1 " , " v1 " , " k2 " , " v2 " , " k3 " , " v3 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s " ) , 
 + row ( 0 , map ( " k1 " , " v1 " , " k2 " , " v2 " , " k3 " , " v3 " ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET m = m - ? WHERE k = ? " , set ( " k2 " ) , 0 ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s " ) , 
 + row ( 0 , map ( " k1 " , " v1 " , " k3 " , " v3 " ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET m = m + ? , m = m - ? WHERE k = ? " , map ( " k4 " , " v4 " ) , set ( " k3 " ) , 0 ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s " ) , 
 + row ( 0 , map ( " k1 " , " v1 " , " k4 " , " v4 " ) ) 
 + ) ; 
 + } 
 + 
 + @ Test 
 + public void testInvalidCollectionsMix ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , l list < text > , s set < text > , m map < text , text > ) " ) ; 
 + 
 + / / Note : we force the non - prepared form for some of those tests because a list and a set 
 + / / have the same serialized format in practice and CQLTester don ' t validate that the type 
 + / / of what ' s passed as a value in the prepared case , so the queries would work ( which is ok , 
 + / / CQLTester is just a " dumb " client ) . 
 + 
 + assertInvalid ( " UPDATE % s SET l = l + { ' a ' , ' b ' } WHERE k = 0 " ) ; 
 + assertInvalid ( " UPDATE % s SET l = l - { ' a ' , ' b ' } WHERE k = 0 " ) ; 
 + / / TODO : We should remove this ' if ' once # 7833 is resolved 
 + if ( ! usePrepared ( ) ) 
 + { 
 + assertInvalid ( " UPDATE % s SET l = l + ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; 
 + assertInvalid ( " UPDATE % s SET l = l - ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; 
 + } 
 + 
 + assertInvalid ( " UPDATE % s SET s = s + [ ' a ' , ' b ' ] WHERE k = 0 " ) ; 
 + assertInvalid ( " UPDATE % s SET s = s - [ ' a ' , ' b ' ] WHERE k = 0 " ) ; 
 + / / TODO : We should remove this ' if ' once # 7833 is resolved 
 + if ( ! usePrepared ( ) ) 
 + { 
 + assertInvalid ( " UPDATE % s SET s = s + ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; 
 + assertInvalid ( " UPDATE % s SET s = s - ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; 
 + } 
 + 
 + assertInvalid ( " UPDATE % s SET m = m + ? WHERE k = 0 " , list ( " a " , " b " ) ) ; 
 + assertInvalid ( " UPDATE % s SET m = m - [ ' a ' , ' b ' ] WHERE k = 0 " ) ; 
 + assertInvalid ( " UPDATE % s SET m = m + ? WHERE k = 0 " , set ( " a " , " b " ) ) ; 
 + / / Note that we do allow substracting a set from a map , but not a map from a map 
 + / / TODO : We should remove this ' if ' once # 7833 is resolved 
 + if ( ! usePrepared ( ) ) 
 + assertInvalid ( " UPDATE % s SET m = m - ? WHERE k = 0 " , map ( " a " , " b " , " c " , " d " ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testSets ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , s set < text > ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( k , s ) VALUES ( 0 , ? ) " , set ( " v1 " , " v2 " , " v3 " , " v4 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , 
 + row ( set ( " v1 " , " v2 " , " v3 " , " v4 " ) ) 
 + ) ; 
 + 
 + execute ( " DELETE s [ ? ] FROM % s WHERE k = 0 " , " v1 " ) ; 
 + 
 + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , 
 + row ( set ( " v2 " , " v3 " , " v4 " ) ) 
 + ) ; 
 + 
 + / / Full overwrite 
 + execute ( " UPDATE % s SET s = ? WHERE k = 0 " , set ( " v6 " , " v5 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , 
 + row ( set ( " v5 " , " v6 " ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET s = s + ? WHERE k = 0 " , set ( " v7 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , 
 + row ( set ( " v5 " , " v6 " , " v7 " ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET s = s - ? WHERE k = 0 " , set ( " v6 " , " v5 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , 
 + row ( set ( " v7 " ) ) 
 + ) ; 
 + 
 + execute ( " DELETE s FROM % s WHERE k = 0 " ) ; 
 + 
 + assertRows ( execute ( " SELECT s FROM % s WHERE k = 0 " ) , 
 + row ( ( Object ) null ) 
 + ) ; 
 + } 
 + 
 + @ Test 
 + public void testMaps ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , m map < text , int > ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( k , m ) VALUES ( 0 , ? ) " , map ( " v1 " , 1 , " v2 " , 2 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , 
 + row ( map ( " v1 " , 1 , " v2 " , 2 ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET m [ ? ] = ? , m [ ? ] = ? WHERE k = 0 " , " v3 " , 3 , " v4 " , 4 ) ; 
 + 
 + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , 
 + row ( map ( " v1 " , 1 , " v2 " , 2 , " v3 " , 3 , " v4 " , 4 ) ) 
 + ) ; 
 + 
 + execute ( " DELETE m [ ? ] FROM % s WHERE k = 0 " , " v1 " ) ; 
 + 
 + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , 
 + row ( map ( " v2 " , 2 , " v3 " , 3 , " v4 " , 4 ) ) 
 + ) ; 
 + 
 + / / Full overwrite 
 + execute ( " UPDATE % s SET m = ? WHERE k = 0 " , map ( " v6 " , 6 , " v5 " , 5 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , 
 + row ( map ( " v5 " , 5 , " v6 " , 6 ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET m = m + ? WHERE k = 0 " , map ( " v7 " , 7 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , 
 + row ( map ( " v5 " , 5 , " v6 " , 6 , " v7 " , 7 ) ) 
 + ) ; 
 + 
 + / / The empty map is parsed as an empty set ( because we don ' t have enough info at parsing 
 + / / time when we see a { } ) and special cased later . This test checks this work properly 
 + execute ( " UPDATE % s SET m = { } WHERE k = 0 " ) ; 
 + 
 + assertRows ( execute ( " SELECT m FROM % s WHERE k = 0 " ) , 
 + row ( ( Object ) null ) 
 + ) ; 
 + } 
 + 
 + @ Test 
 + public void testLists ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , l list < text > ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( k , l ) VALUES ( 0 , ? ) " , list ( " v1 " , " v2 " , " v3 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , 
 + row ( list ( " v1 " , " v2 " , " v3 " ) ) 
 + ) ; 
 + 
 + execute ( " DELETE l [ ? ] FROM % s WHERE k = 0 " , 1 ) ; 
 + 
 + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , 
 + row ( list ( " v1 " , " v3 " ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET l [ ? ] = ? WHERE k = 0 " , 1 , " v4 " ) ; 
 + 
 + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , 
 + row ( list ( " v1 " , " v4 " ) ) 
 + ) ; 
 + 
 + / / Full overwrite 
 + execute ( " UPDATE % s SET l = ? WHERE k = 0 " , list ( " v6 " , " v5 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , 
 + row ( list ( " v6 " , " v5 " ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET l = l + ? WHERE k = 0 " , list ( " v7 " , " v8 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , 
 + row ( list ( " v6 " , " v5 " , " v7 " , " v8 " ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET l = ? + l WHERE k = 0 " , list ( " v9 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , 
 + row ( list ( " v9 " , " v6 " , " v5 " , " v7 " , " v8 " ) ) 
 + ) ; 
 + 
 + execute ( " UPDATE % s SET l = l - ? WHERE k = 0 " , list ( " v5 " , " v8 " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , 
 + row ( list ( " v9 " , " v6 " , " v7 " ) ) 
 + ) ; 
 + 
 + execute ( " DELETE l FROM % s WHERE k = 0 " ) ; 
 + 
 + assertRows ( execute ( " SELECT l FROM % s WHERE k = 0 " ) , 
 + row ( ( Object ) null ) 
 + ) ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / MultiColumnRelationTest . java b / test / unit / org / apache / cassandra / cql3 / MultiColumnRelationTest . java 
 index daf0835 . . bfc6d2d 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / MultiColumnRelationTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / MultiColumnRelationTest . java 
 @ @ - 26 , 7 + 26 , 7 @ @ public class MultiColumnRelationTest extends CQLTester 
 { 
 createTable ( " CREATE TABLE % s ( a int , b int , c int , PRIMARY KEY ( a , b ) ) " ) ; 
 
 - assertInvalid ( " SELECT * FROM % s WHERE ( ) = ( ? , ? ) " , 1 , 2 ) ; 
 + assertInvalidSyntax ( " SELECT * FROM % s WHERE ( ) = ( ? , ? ) " , 1 , 2 ) ; 
 assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b ) = ( ? ) AND ( b ) > ( ? ) " , 0 , 0 ) ; 
 assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b ) > ( ? ) AND ( b ) > ( ? ) " , 0 , 1 ) ; 
 assertInvalid ( " SELECT * FROM % s WHERE ( a , b ) = ( ? , ? ) " , 0 , 0 ) ; 
 @ @ - 37 , 7 + 37 , 7 @ @ public class MultiColumnRelationTest extends CQLTester 
 { 
 createTable ( " CREATE TABLE % s ( a int , b int , c int , d int , PRIMARY KEY ( a , b , c , d ) ) " ) ; 
 
 - assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b , c ) > ( ) " ) ; 
 + assertInvalidSyntax ( " SELECT * FROM % s WHERE a = 0 AND ( b , c ) > ( ) " ) ; 
 assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b , c ) > ( ? , ? , ? ) " , 1 , 2 , 3 ) ; 
 assertInvalid ( " SELECT * FROM % s WHERE a = 0 AND ( b , c ) > ( ? , ? ) " , 1 , null ) ; 
 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / TupleTypeTest . java b / test / unit / org / apache / cassandra / cql3 / TupleTypeTest . java 
 index 84512a5 . . 354a8f9 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / TupleTypeTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / TupleTypeTest . java 
 @ @ - 91 , 7 + 91 , 7 @ @ public class TupleTypeTest extends CQLTester 
 { 
 createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , t tuple < int , text , double > ) " ) ; 
 
 - assertInvalid ( " INSERT INTO % s ( k , t ) VALUES ( 0 , ( ) ) " ) ; 
 + assertInvalidSyntax ( " INSERT INTO % s ( k , t ) VALUES ( 0 , ( ) ) " ) ; 
 assertInvalid ( " INSERT INTO % s ( k , t ) VALUES ( 0 , ( 2 , ' foo ' , 3 . 1 , ' bar ' ) ) " ) ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / UserTypesTest . java b / test / unit / org / apache / cassandra / cql3 / UserTypesTest . java 
 index c7f1851 . . 0dfb6f7 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / UserTypesTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / UserTypesTest . java 
 @ @ - 41 , 14 + 41 , 12 @ @ public class UserTypesTest extends CQLTester 
 execute ( " INSERT INTO % s ( k , v ) VALUES ( ? , { x : ? } ) " , 1 , - 104 . 99251 ) ; 
 execute ( " UPDATE % s SET b = ? WHERE k = ? " , true , 1 ) ; 
 
 - System . out . println ( " - - First query " ) ; 
 assertRows ( execute ( " SELECT v . x FROM % s WHERE k = ? AND v = { x : ? } " , 1 , - 104 . 99251 ) , 
 row ( - 104 . 99251 ) 
 ) ; 
 
 flush ( ) ; 
 
 - System . out . println ( " - - 2nd query " ) ; 
 assertRows ( execute ( " SELECT v . x FROM % s WHERE k = ? AND v = { x : ? } " , 1 , - 104 . 99251 ) , 
 row ( - 104 . 99251 ) 
 ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql / Column . java b / src / java / org / apache / cassandra / cql / Column . java 
 deleted file mode 100644 
 index bcfc913 . . 0000000 
 - - - a / src / java / org / apache / cassandra / cql / Column . java 
 + + + / dev / null 
 @ @ - 1 , 47 + 0 , 0 @ @ 
 - / * 
 - * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , 
 - * software distributed under the License is distributed on an 
 - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 - * KIND , either express or implied . See the License for the 
 - * specific language governing permissions and limitations 
 - * under the License . 
 - * 
 - * / 
 - package org . apache . cassandra . cql ; 
 - 
 - / * * 
 - * Represents a column definition parsed from CQL query statement . 
 - * 
 - * / 
 - public class Column 
 - { 
 - private final Term name ; 
 - private final Term value ; 
 - 
 - public Column ( Term name , Term value ) 
 - { 
 - this . name = name ; 
 - this . value = value ; 
 - } 
 - 
 - public Term getName ( ) 
 - { 
 - return name ; 
 - } 
 - 
 - public Term getValue ( ) 
 - { 
 - return value ; 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / cql / Cql . g b / src / java / org / apache / cassandra / cql / Cql . g 
 index 0f0327b . . a584f23 100644 
 - - - a / src / java / org / apache / cassandra / cql / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql / Cql . g 
 @ @ - 6 , 7 + 6 , 8 @ @ options { 
 
 @ header { 
 package org . apache . cassandra . cql ; 
 - import java . util . ArrayList ; 
 + import java . util . Map ; 
 + import java . util . HashMap ; 
 import org . apache . cassandra . thrift . ConsistencyLevel ; 
 import org . apache . cassandra . avro . InvalidRequestException ; 
 } 
 @ @ - 93 , 17 + 94 , 24 @ @ selectStatement returns [ SelectStatement expr ] 
 * < CF > 
 * USING 
 * CONSISTENCY . ONE 
 - * WITH 
 - * ROW ( " key1 " , COL ( " col1 " , " val1 " ) , . . . ) AND 
 - * ROW ( " key2 " , COL ( " col1 " , " val1 " ) , . . . ) AND 
 - * ROW ( " key3 " , COLUMN ( " col1 " , " val1 " ) , . . . ) 
 + * SET 
 + * name1 = value1 , 
 + * name2 = value2 
 + * WHERE 
 + * KEY = keyname ; 
 * / 
 updateStatement returns [ UpdateStatement expr ] 
 - : { ConsistencyLevel cLevel = ConsistencyLevel . ONE ; } 
 - K _ UPDATE IDENT 
 + : { 
 + ConsistencyLevel cLevel = ConsistencyLevel . ONE ; 
 + Map < Term , Term > columns = new HashMap < Term , Term > ( ) ; 
 + } 
 + K _ UPDATE columnFamily = IDENT 
 ( K _ USING K _ CONSISTENCY ' . ' K _ LEVEL { cLevel = ConsistencyLevel . valueOf ( $ K _ LEVEL . text ) ; } ) ? 
 - K _ WITH first = rowDef { $ expr = new UpdateStatement ( $ IDENT . text , first , cLevel ) ; } 
 - ( K _ AND next = rowDef { $ expr . and ( next ) ; } ) * endStmnt 
 + K _ SET c1 = term ' = ' v1 = term { columns . put ( c1 , v1 ) ; } ( ' , ' cN = term ' = ' vN = term { columns . put ( cN , vN ) ; } ) * 
 + K _ WHERE K _ KEY ' = ' key = term endStmnt 
 + { 
 + return new UpdateStatement ( $ columnFamily . text , cLevel , columns , key ) ; 
 + } 
 ; 
 
 / / TODO : date / time , utf8 
 @ @ - 139 , 15 + 147 , 6 @ @ selectExpression returns [ SelectExpression expr ] 
 | start = term ' . . ' finish = term { $ expr = new SelectExpression ( start , finish , count , reversed ) ; } 
 ) 
 ; 
 - 
 - columnDef returns [ Column column ] 
 - : K _ COLUMN ' ( ' n = term ' , ' v = term ' ) ' { $ column = new Column ( $ n . item , $ v . item ) ; } 
 - ; 
 - 
 - rowDef returns [ Row row ] 
 - : K _ ROW ' ( ' key = term ' , ' first = columnDef { $ row = new Row ( $ key . item , first ) ; } 
 - ( ' , ' next = columnDef { $ row . and ( next ) ; } ) * ' ) ' 
 - ; 
 
 endStmnt 
 : ( EOF | ' ; ' ) 
 @ @ - 177 , 6 + 176 , 7 @ @ K _ USE : U S E ; 
 K _ FIRST : F I R S T ; 
 K _ REVERSED : R E V E R S E D ; 
 K _ COUNT : C O U N T ; 
 + K _ SET : S E T ; 
 
 / / Case - insensitive alpha characters 
 fragment A : ( ' a ' | ' A ' ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql / QueryProcessor . java b / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 index 8a32b72 . . 32ac6aa 100644 
 - - - a / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 @ @ - 24 , 9 + 24 , 11 @ @ package org . apache . cassandra . cql ; 
 import java . io . IOException ; 
 import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 + import java . util . Arrays ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 import java . util . List ; 
 + import java . util . Map ; 
 import java . util . Set ; 
 import java . util . concurrent . TimeoutException ; 
 
 @ @ - 56 , 6 + 58 , 7 @ @ import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . StorageProxy ; 
 import org . apache . cassandra . service . StorageService ; 
 + import org . apache . cassandra . thrift . ConsistencyLevel ; 
 import org . apache . cassandra . thrift . IndexClause ; 
 import org . apache . cassandra . thrift . IndexExpression ; 
 import org . apache . cassandra . thrift . IndexOperator ; 
 @ @ - 208 , 6 + 211 , 43 @ @ public class QueryProcessor 
 return rows ; 
 } 
 
 + private static void batchUpdate ( String keyspace , List < UpdateStatement > updateStatements ) 
 + throws InvalidRequestException , UnavailableException , TimedOutException 
 + { 
 + ConsistencyLevel consistency = updateStatements . get ( 0 ) . getConsistencyLevel ( ) ; 
 + List < RowMutation > rowMutations = new ArrayList < RowMutation > ( ) ; 
 + 
 + for ( UpdateStatement update : updateStatements ) 
 + { 
 + ByteBuffer key = update . getKey ( ) . getByteBuffer ( ) ; 
 + validateKey ( key ) ; 
 + validateColumnFamily ( keyspace , update . getColumnFamily ( ) ) ; 
 + 
 + RowMutation rm = new RowMutation ( keyspace , key ) ; 
 + for ( Map . Entry < Term , Term > column : update . getColumns ( ) . entrySet ( ) ) 
 + { 
 + rm . add ( new QueryPath ( update . getColumnFamily ( ) , null , column . getKey ( ) . getByteBuffer ( ) ) , 
 + column . getValue ( ) . getByteBuffer ( ) , 
 + System . currentTimeMillis ( ) ) ; 
 + } 
 + 
 + rowMutations . add ( rm ) ; 
 + } 
 + 
 + try 
 + { 
 + StorageProxy . mutate ( rowMutations , consistency ) ; 
 + } 
 + catch ( org . apache . cassandra . thrift . UnavailableException e ) 
 + { 
 + throw new UnavailableException ( ) ; 
 + } 
 + catch ( TimeoutException e ) 
 + { 
 + throw new TimedOutException ( ) ; 
 + } 
 + } 
 + 
 private static SlicePredicate slicePredicateFromSelect ( SelectStatement select ) 
 { 
 SlicePredicate thriftSlicePredicate = new SlicePredicate ( ) ; 
 @ @ - 352 , 40 + 392 , 8 @ @ public class QueryProcessor 
 
 case UPDATE : 
 UpdateStatement update = ( UpdateStatement ) statement . statement ; 
 - validateColumnFamily ( keyspace , update . getColumnFamily ( ) ) ; 
 - 
 + batchUpdate ( keyspace , Collections . singletonList ( update ) ) ; 
 avroResult . type = CqlResultType . VOID ; 
 - 
 - List < RowMutation > rowMutations = new ArrayList < RowMutation > ( ) ; 
 - 
 - for ( Row row : update . getRows ( ) ) 
 - { 
 - validateKey ( row . getKey ( ) . getByteBuffer ( ) ) ; 
 - RowMutation rm = new RowMutation ( keyspace , row . getKey ( ) . getByteBuffer ( ) ) ; 
 - 
 - for ( org . apache . cassandra . cql . Column col : row . getColumns ( ) ) 
 - { 
 - rm . add ( new QueryPath ( update . getColumnFamily ( ) , null , col . getName ( ) . getByteBuffer ( ) ) , 
 - col . getValue ( ) . getByteBuffer ( ) , 
 - System . currentTimeMillis ( ) ) ; 
 - } 
 - 
 - rowMutations . add ( rm ) ; 
 - } 
 - 
 - try 
 - { 
 - StorageProxy . mutate ( rowMutations , update . getConsistencyLevel ( ) ) ; 
 - } 
 - catch ( org . apache . cassandra . thrift . UnavailableException e ) 
 - { 
 - throw new UnavailableException ( ) ; 
 - } 
 - catch ( TimeoutException e ) 
 - { 
 - throw new TimedOutException ( ) ; 
 - } 
 - 
 return avroResult ; 
 
 case USE : 
 diff - - git a / src / java / org / apache / cassandra / cql / Row . java b / src / java / org / apache / cassandra / cql / Row . java 
 deleted file mode 100644 
 index 1ab7390 . . 0000000 
 - - - a / src / java / org / apache / cassandra / cql / Row . java 
 + + + / dev / null 
 @ @ - 1 , 60 + 0 , 0 @ @ 
 - / * 
 - * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , 
 - * software distributed under the License is distributed on an 
 - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 - * KIND , either express or implied . See the License for the 
 - * specific language governing permissions and limitations 
 - * under the License . 
 - * 
 - * / 
 - package org . apache . cassandra . cql ; 
 - 
 - import java . util . ArrayList ; 
 - import java . util . List ; 
 - 
 - / * * 
 - * Represents a row parsed from a CQL statement . 
 - * 
 - * / 
 - public class Row 
 - { 
 - private final Term key ; 
 - private List < Column > columns = new ArrayList < Column > ( ) ; 
 - 
 - public Row ( Term key , Column firstColumn ) 
 - { 
 - this . key = key ; 
 - columns . add ( firstColumn ) ; 
 - } 
 - 
 - / * * 
 - * Add a new column definition to this row . 
 - * 
 - * @ param col the CQL column to add . 
 - * / 
 - public void and ( Column col ) 
 - { 
 - columns . add ( col ) ; 
 - } 
 - 
 - public Term getKey ( ) 
 - { 
 - return key ; 
 - } 
 - 
 - public List < Column > getColumns ( ) 
 - { 
 - return columns ; 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / cql / UpdateStatement . java b / src / java / org / apache / cassandra / cql / UpdateStatement . java 
 index 64eef3f . . 26f572b 100644 
 - - - a / src / java / org / apache / cassandra / cql / UpdateStatement . java 
 + + + b / src / java / org / apache / cassandra / cql / UpdateStatement . java 
 @ @ - 20 , 8 + 20 , 8 @ @ 
 * / 
 package org . apache . cassandra . cql ; 
 
 - import java . util . ArrayList ; 
 - import java . util . List ; 
 + import java . util . Map ; 
 + 
 import org . apache . cassandra . thrift . ConsistencyLevel ; 
 
 / * * 
 @ @ - 31 , 37 + 31 , 25 @ @ import org . apache . cassandra . thrift . ConsistencyLevel ; 
 public class UpdateStatement 
 { 
 private String columnFamily ; 
 - private List < Row > rows = new ArrayList < Row > ( ) ; 
 private ConsistencyLevel cLevel ; 
 + private Map < Term , Term > columns ; 
 + private Term key ; 
 
 / * * 
 - * Creates a new UpdateStatement from a column family name , a row definition , 
 - * and a consistency level . 
 + * Creates a new UpdateStatement from a column family name , columns map , consistency 
 + * level , and key term . 
 * 
 * @ param columnFamily column family name 
 - * @ param first a row definition instance 
 * @ param cLevel the thrift consistency level 
 + * @ param columns a map of column name / values pairs 
 + * @ param key the key name 
 * / 
 - public UpdateStatement ( String columnFamily , Row first , ConsistencyLevel cLevel ) 
 + public UpdateStatement ( String columnFamily , ConsistencyLevel cLevel , Map < Term , Term > columns , Term key ) 
 { 
 this . columnFamily = columnFamily ; 
 this . cLevel = cLevel ; 
 - and ( first ) ; 
 - } 
 - 
 - / * * 
 - * Adds a new row definition to this < code > UPDATE < / code > . 
 - * 
 - * @ param row the row definition to add . 
 - * / 
 - public void and ( Row row ) 
 - { 
 - rows . add ( row ) ; 
 - } 
 - 
 - public List < Row > getRows ( ) 
 - { 
 - return rows ; 
 + this . columns = columns ; 
 + this . key = key ; 
 } 
 
 public ConsistencyLevel getConsistencyLevel ( ) 
 @ @ - 74 , 9 + 62 , 22 @ @ public class UpdateStatement 
 return columnFamily ; 
 } 
 
 + public Term getKey ( ) 
 + { 
 + return key ; 
 + } 
 + 
 + public Map < Term , Term > getColumns ( ) 
 + { 
 + return columns ; 
 + } 
 + 
 public String toString ( ) 
 { 
 - return " UpdateStatement ( columnFamily = " + columnFamily + " , " + 
 - " row = " + rows + " , " + " consistency = " + cLevel + " ) " ; 
 + return String . format ( " UpdateStatement ( columnFamily = % s , key = % s , columns = % s , consistency = % s ) " , 
 + columnFamily , 
 + key , 
 + columns , 
 + cLevel ) ; 
 } 
 } 
 diff - - git a / test / system / test _ cql . py b / test / system / test _ cql . py 
 index 89f044f . . 381da6f 100644 
 - - - a / test / system / test _ cql . py 
 + + + b / test / system / test _ cql . py 
 @ @ - 10 , 35 + 10 , 66 @ @ from avro _ utils import assert _ raises 
 
 def load _ sample ( dbconn ) : 
 dbconn . execute ( " " " 
 - UPDATE 
 - Standard1 
 - WITH 
 - ROW ( " ka " , COL ( " ca1 " , " va1 " ) , COL ( " col " , " val " ) ) AND 
 - ROW ( " kb " , COL ( " cb1 " , " vb1 " ) , COL ( " col " , " val " ) ) AND 
 - ROW ( " kc " , COL ( " cc1 " , " vc1 " ) , COL ( " col " , " val " ) ) AND 
 - ROW ( " kd " , COL ( " cd1 " , " vd1 " ) , COL ( " col " , " val " ) ) ; 
 - " " " ) 
 - dbconn . execute ( " " " 
 - UPDATE 
 - StandardLong1 
 - WITH 
 - ROW ( " aa " , COL ( 1L , " 1 " ) , COL ( 2L , " 2 " ) , COL ( 3L , " 3 " ) , COL ( 4L , " 4 " ) ) AND 
 - ROW ( " ab " , COL ( 5L , " 5 " ) , COL ( 6L , " 6 " ) , COL ( 7L , " 8 " ) , COL ( 9L , " 9 " ) ) AND 
 - ROW ( " ac " , COL ( 9L , " 9 " ) , COL ( 8L , " 8 " ) , COL ( 7L , " 7 " ) , COL ( 6L , " 6 " ) ) AND 
 - ROW ( " ad " , COL ( 5L , " 5 " ) , COL ( 4L , " 4 " ) , COL ( 3L , " 3 " ) , COL ( 2L , " 2 " ) ) AND 
 - ROW ( " ae " , COL ( 1L , " 1 " ) , COL ( 2L , " 2 " ) , COL ( 3L , " 3 " ) , COL ( 4L , " 4 " ) ) AND 
 - ROW ( " af " , COL ( 1L , " 1 " ) , COL ( 2L , " 2 " ) , COL ( 3L , " 3 " ) , COL ( 4L , " 4 " ) ) AND 
 - ROW ( " ag " , COL ( 5L , " 5 " ) , COL ( 6L , " 6 " ) , COL ( 7L , " 8 " ) , COL ( 9L , " 9 " ) ) ; 
 - " " " ) 
 - dbconn . execute ( " " " 
 - UPDATE 
 - Indexed1 
 - WITH 
 - ROW ( " asmith " , COL ( " birthdate " , 100L ) , COL ( " unindexed " , 250L ) ) AND 
 - ROW ( " dozer " , COL ( " birthdate " , 100L ) , COL ( " unindexed " , 200L ) ) AND 
 - ROW ( " morpheus " , COL ( " birthdate " , 175L ) , COL ( " unindexed " , 200L ) ) AND 
 - ROW ( " neo " , COL ( " birthdate " , 150L ) , COL ( " unindexed " , 250L ) ) AND 
 - ROW ( " trinity " , COL ( " birthdate " , 125L ) , COL ( " unindexed " , 200L ) ) ; 
 + UPDATE Standard1 SET " ca1 " = " va1 " , " col " = " val " WHERE KEY = " ka " 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE Standard1 SET " cb1 " = " vb1 " , " col " = " val " WHERE KEY = " kb " 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE Standard1 SET " cc1 " = " vc1 " , " col " = " val " WHERE KEY = " kc " 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE Standard1 SET " cd1 " = " vd1 " , " col " = " val " WHERE KEY = " kd " 
 + " " " ) 
 + 
 + dbconn . execute ( " " " 
 + UPDATE StandardLong1 SET 1L = " 1 " , 2L = " 2 " , 3L = " 3 " , 4L = " 4 " 
 + WHERE KEY = " aa " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE StandardLong1 SET 5L = " 5 " , 6L = " 6 " , 7L = " 8 " , 9L = " 9 " 
 + WHERE KEY = " ab " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE StandardLong1 SET 9L = " 9 " , 8L = " 8 " , 7L = " 7 " , 6L = " 6 " 
 + WHERE KEY = " ac " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE StandardLong1 SET 5L = " 5 " , 4L = " 4 " , 3L = " 3 " , 2L = " 2 " 
 + WHERE KEY = " ad " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE StandardLong1 SET 1L = " 1 " , 2L = " 2 " , 3L = " 3 " , 4L = " 4 " 
 + WHERE KEY = " ae " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE StandardLong1 SET 1L = " 1 " , 2L = " 2 " , 3L = " 3 " , 4L = " 4 " 
 + WHERE KEY = " af " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE StandardLong1 SET 5L = " 5 " , 6L = " 6 " , 7L = " 8 " , 9L = " 9 " 
 + WHERE KEY = " ag " ; 
 + " " " ) 
 + 
 + dbconn . execute ( " " " 
 + UPDATE Indexed1 SET " birthdate " = 100L , " unindexed " = 250L 
 + WHERE KEY = " asmith " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE Indexed1 SET " birthdate " = 100L , " unindexed " = 200L 
 + WHERE KEY = " dozer " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE Indexed1 SET " birthdate " = 175L , " unindexed " = 200L 
 + WHERE KEY = " morpheus " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE Indexed1 SET " birthdate " = 150L , " unindexed " = 250L 
 + WHERE KEY = " neo " ; 
 + " " " ) 
 + dbconn . execute ( " " " 
 + UPDATE Indexed1 SET " birthdate " = 125L , " unindexed " = 200L 
 + WHERE KEY = " trinity " ; 
 " " " ) 
 
 def init ( keyspace = " Keyspace1 " ) :
