BLEU SCORE: 0.02133165846478451

TEST MSG: Fix potential loss of 2ndary index entry during compaction
GENERATED MSG: hsha server may stop responding and will not close selectors

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7f23a3f . . 6ca163a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 48 , 6 + 48 , 7 @ @ <nl> * sstables from stalled repair sessions can resurrect deleted data ( CASSANDRA - 6503 ) <nl> * Switch stress to use ITransportFactory ( CASSANDRA - 6641 ) <nl> * Fix IllegalArgumentException during prepare ( CASSANDRA - 6592 ) <nl> + * Fix possible loss of 2ndary index entries during compaction ( CASSANDRA - 6517 ) <nl> Merged from 1 . 2 : <nl> * fsync compression metadata ( CASSANDRA - 6531 ) <nl> * Validate CF existence on execution for prepared statement ( CASSANDRA - 6535 ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java b / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java <nl> index 74bc098 . . b859023 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java <nl> @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy ; <nl> import org . apache . cassandra . db . filter . * ; <nl> import org . apache . cassandra . db . index . * ; <nl> + import org . apache . cassandra . db . marshal . Int32Type ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> @ @ - 302 , 6 + 303 , 59 @ @ public class RangeTombstoneTest extends SchemaLoader <nl> assertEquals ( index . deletes . get ( 0 ) , index . inserts . get ( 0 ) ) ; <nl> } <nl> <nl> + @ Test <nl> + public void testOverwritesToDeletedColumns ( ) throws Exception <nl> + { <nl> + Keyspace table = Keyspace . open ( KSNAME ) ; <nl> + ColumnFamilyStore cfs = table . getColumnFamilyStore ( CFNAME ) ; <nl> + ByteBuffer key = ByteBufferUtil . bytes ( " k6 " ) ; <nl> + ByteBuffer indexedColumnName = ByteBufferUtil . bytes ( 1 ) ; <nl> + <nl> + cfs . truncateBlocking ( ) ; <nl> + cfs . disableAutoCompaction ( ) ; <nl> + cfs . setCompactionStrategyClass ( SizeTieredCompactionStrategy . class . getCanonicalName ( ) ) ; <nl> + if ( cfs . indexManager . getIndexForColumn ( indexedColumnName ) = = null ) <nl> + { <nl> + ColumnDefinition cd = new ColumnDefinition ( cfs . metadata , indexedColumnName , Int32Type . instance , null , ColumnDefinition . Kind . REGULAR ) ; <nl> + cd . setIndex ( " test _ index " , IndexType . CUSTOM , ImmutableMap . of ( SecondaryIndex . CUSTOM _ INDEX _ OPTION _ NAME , TestIndex . class . getName ( ) ) ) ; <nl> + cfs . indexManager . addIndexedColumn ( cd ) ; <nl> + } <nl> + <nl> + TestIndex index = ( ( TestIndex ) cfs . indexManager . getIndexForColumn ( indexedColumnName ) ) ; <nl> + index . resetCounts ( ) ; <nl> + <nl> + Mutation rm = new Mutation ( KSNAME , key ) ; <nl> + add ( rm , 1 , 0 ) ; <nl> + rm . apply ( ) ; <nl> + <nl> + / / add a RT which hides the column we just inserted <nl> + rm = new Mutation ( KSNAME , key ) ; <nl> + ColumnFamily cf = rm . addOrGet ( CFNAME ) ; <nl> + delete ( cf , 0 , 1 , 1 ) ; <nl> + rm . apply ( ) ; <nl> + <nl> + / / now re - insert that column <nl> + rm = new Mutation ( KSNAME , key ) ; <nl> + add ( rm , 1 , 2 ) ; <nl> + rm . apply ( ) ; <nl> + <nl> + cfs . forceBlockingFlush ( ) ; <nl> + <nl> + / / We should have 2 updates to the indexed " 1 " column <nl> + assertEquals ( 2 , index . inserts . size ( ) ) ; <nl> + <nl> + CompactionManager . instance . performMaximal ( cfs ) ; <nl> + <nl> + / / verify that the " 1 " indexed column removed from the index twice : <nl> + / / the first time by processing the RT , the second time by the <nl> + / / re - indexing caused by the second insertion . This second write <nl> + / / deletes from the 2i because the original column was still in the <nl> + / / main cf ' s memtable ( shadowed by the RT ) . One thing we ' re checking <nl> + / / for here is that there wasn ' t an additional , bogus delete issued <nl> + / / to the 2i ( CASSANDRA - 6517 ) <nl> + assertEquals ( 2 , index . deletes . size ( ) ) ; <nl> + } <nl> + <nl> private void runCompactionWithRangeTombstoneAndCheckSecondaryIndex ( ) throws Exception <nl> { <nl> Keyspace table = Keyspace . open ( KSNAME ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / thrift / CustomTHsHaServer . java b / src / java / org / apache / cassandra / thrift / CustomTHsHaServer . java <nl> index 9f7b0cf . . 350a13d 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / CustomTHsHaServer . java <nl> + + + b / src / java / org / apache / cassandra / thrift / CustomTHsHaServer . java <nl> @ @ - 177 , 6 + 177 , 13 @ @ public class CustomTHsHaServer extends TNonblockingServer <nl> { <nl> select ( ) ; <nl> } <nl> + } <nl> + catch ( Throwable t ) <nl> + { <nl> + LOGGER . error ( " Uncaught Exception : " , t ) ; <nl> + } <nl> + finally <nl> + { <nl> try <nl> { <nl> selector . close ( ) ; / / CASSANDRA - 3867 <nl> @ @ - 186 , 10 + 193 , 6 @ @ public class CustomTHsHaServer extends TNonblockingServer <nl> / / ignore this exception . <nl> } <nl> } <nl> - catch ( Throwable t ) <nl> - { <nl> - LOGGER . error ( " Uncaught Exception : " , t ) ; <nl> - } <nl> } <nl> <nl> private void select ( ) throws InterruptedException , IOException <nl> @ @ - 201 , 21 + 204 , 30 @ @ public class CustomTHsHaServer extends TNonblockingServer <nl> { <nl> SelectionKey key = keyIterator . next ( ) ; <nl> keyIterator . remove ( ) ; <nl> - if ( ! key . isValid ( ) ) <nl> + <nl> + try <nl> { <nl> - / / if invalid cleanup . <nl> + if ( ! key . isValid ( ) ) <nl> + { <nl> + / / if invalid cleanup . <nl> + cleanupSelectionkey ( key ) ; <nl> + continue ; <nl> + } <nl> + <nl> + if ( key . isAcceptable ( ) ) <nl> + handleAccept ( ) ; <nl> + if ( key . isReadable ( ) ) <nl> + handleRead ( key ) ; <nl> + else if ( key . isWritable ( ) ) <nl> + handleWrite ( key ) ; <nl> + else <nl> + LOGGER . debug ( " Unexpected state " + key . interestOps ( ) ) ; <nl> + } <nl> + catch ( Exception io ) <nl> + { <nl> + / / just ignore ( ? ) <nl> cleanupSelectionkey ( key ) ; <nl> - continue ; <nl> } <nl> - <nl> - if ( key . isAcceptable ( ) ) <nl> - handleAccept ( ) ; <nl> - if ( key . isReadable ( ) ) <nl> - handleRead ( key ) ; <nl> - else if ( key . isWritable ( ) ) <nl> - handleWrite ( key ) ; <nl> - else <nl> - LOGGER . debug ( " Unexpected state " + key . interestOps ( ) ) ; <nl> } <nl> / / process the changes which are inserted after completion . <nl> processInterestChanges ( ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7f23a3f . . 6ca163a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 48 , 6 + 48 , 7 @ @ 
 * sstables from stalled repair sessions can resurrect deleted data ( CASSANDRA - 6503 ) 
 * Switch stress to use ITransportFactory ( CASSANDRA - 6641 ) 
 * Fix IllegalArgumentException during prepare ( CASSANDRA - 6592 ) 
 + * Fix possible loss of 2ndary index entries during compaction ( CASSANDRA - 6517 ) 
 Merged from 1 . 2 : 
 * fsync compression metadata ( CASSANDRA - 6531 ) 
 * Validate CF existence on execution for prepared statement ( CASSANDRA - 6535 ) 
 diff - - git a / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java b / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java 
 index 74bc098 . . b859023 100644 
 - - - a / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java 
 + + + b / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java 
 @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy ; 
 import org . apache . cassandra . db . filter . * ; 
 import org . apache . cassandra . db . index . * ; 
 + import org . apache . cassandra . db . marshal . Int32Type ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 @ @ - 302 , 6 + 303 , 59 @ @ public class RangeTombstoneTest extends SchemaLoader 
 assertEquals ( index . deletes . get ( 0 ) , index . inserts . get ( 0 ) ) ; 
 } 
 
 + @ Test 
 + public void testOverwritesToDeletedColumns ( ) throws Exception 
 + { 
 + Keyspace table = Keyspace . open ( KSNAME ) ; 
 + ColumnFamilyStore cfs = table . getColumnFamilyStore ( CFNAME ) ; 
 + ByteBuffer key = ByteBufferUtil . bytes ( " k6 " ) ; 
 + ByteBuffer indexedColumnName = ByteBufferUtil . bytes ( 1 ) ; 
 + 
 + cfs . truncateBlocking ( ) ; 
 + cfs . disableAutoCompaction ( ) ; 
 + cfs . setCompactionStrategyClass ( SizeTieredCompactionStrategy . class . getCanonicalName ( ) ) ; 
 + if ( cfs . indexManager . getIndexForColumn ( indexedColumnName ) = = null ) 
 + { 
 + ColumnDefinition cd = new ColumnDefinition ( cfs . metadata , indexedColumnName , Int32Type . instance , null , ColumnDefinition . Kind . REGULAR ) ; 
 + cd . setIndex ( " test _ index " , IndexType . CUSTOM , ImmutableMap . of ( SecondaryIndex . CUSTOM _ INDEX _ OPTION _ NAME , TestIndex . class . getName ( ) ) ) ; 
 + cfs . indexManager . addIndexedColumn ( cd ) ; 
 + } 
 + 
 + TestIndex index = ( ( TestIndex ) cfs . indexManager . getIndexForColumn ( indexedColumnName ) ) ; 
 + index . resetCounts ( ) ; 
 + 
 + Mutation rm = new Mutation ( KSNAME , key ) ; 
 + add ( rm , 1 , 0 ) ; 
 + rm . apply ( ) ; 
 + 
 + / / add a RT which hides the column we just inserted 
 + rm = new Mutation ( KSNAME , key ) ; 
 + ColumnFamily cf = rm . addOrGet ( CFNAME ) ; 
 + delete ( cf , 0 , 1 , 1 ) ; 
 + rm . apply ( ) ; 
 + 
 + / / now re - insert that column 
 + rm = new Mutation ( KSNAME , key ) ; 
 + add ( rm , 1 , 2 ) ; 
 + rm . apply ( ) ; 
 + 
 + cfs . forceBlockingFlush ( ) ; 
 + 
 + / / We should have 2 updates to the indexed " 1 " column 
 + assertEquals ( 2 , index . inserts . size ( ) ) ; 
 + 
 + CompactionManager . instance . performMaximal ( cfs ) ; 
 + 
 + / / verify that the " 1 " indexed column removed from the index twice : 
 + / / the first time by processing the RT , the second time by the 
 + / / re - indexing caused by the second insertion . This second write 
 + / / deletes from the 2i because the original column was still in the 
 + / / main cf ' s memtable ( shadowed by the RT ) . One thing we ' re checking 
 + / / for here is that there wasn ' t an additional , bogus delete issued 
 + / / to the 2i ( CASSANDRA - 6517 ) 
 + assertEquals ( 2 , index . deletes . size ( ) ) ; 
 + } 
 + 
 private void runCompactionWithRangeTombstoneAndCheckSecondaryIndex ( ) throws Exception 
 { 
 Keyspace table = Keyspace . open ( KSNAME ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / thrift / CustomTHsHaServer . java b / src / java / org / apache / cassandra / thrift / CustomTHsHaServer . java 
 index 9f7b0cf . . 350a13d 100644 
 - - - a / src / java / org / apache / cassandra / thrift / CustomTHsHaServer . java 
 + + + b / src / java / org / apache / cassandra / thrift / CustomTHsHaServer . java 
 @ @ - 177 , 6 + 177 , 13 @ @ public class CustomTHsHaServer extends TNonblockingServer 
 { 
 select ( ) ; 
 } 
 + } 
 + catch ( Throwable t ) 
 + { 
 + LOGGER . error ( " Uncaught Exception : " , t ) ; 
 + } 
 + finally 
 + { 
 try 
 { 
 selector . close ( ) ; / / CASSANDRA - 3867 
 @ @ - 186 , 10 + 193 , 6 @ @ public class CustomTHsHaServer extends TNonblockingServer 
 / / ignore this exception . 
 } 
 } 
 - catch ( Throwable t ) 
 - { 
 - LOGGER . error ( " Uncaught Exception : " , t ) ; 
 - } 
 } 
 
 private void select ( ) throws InterruptedException , IOException 
 @ @ - 201 , 21 + 204 , 30 @ @ public class CustomTHsHaServer extends TNonblockingServer 
 { 
 SelectionKey key = keyIterator . next ( ) ; 
 keyIterator . remove ( ) ; 
 - if ( ! key . isValid ( ) ) 
 + 
 + try 
 { 
 - / / if invalid cleanup . 
 + if ( ! key . isValid ( ) ) 
 + { 
 + / / if invalid cleanup . 
 + cleanupSelectionkey ( key ) ; 
 + continue ; 
 + } 
 + 
 + if ( key . isAcceptable ( ) ) 
 + handleAccept ( ) ; 
 + if ( key . isReadable ( ) ) 
 + handleRead ( key ) ; 
 + else if ( key . isWritable ( ) ) 
 + handleWrite ( key ) ; 
 + else 
 + LOGGER . debug ( " Unexpected state " + key . interestOps ( ) ) ; 
 + } 
 + catch ( Exception io ) 
 + { 
 + / / just ignore ( ? ) 
 cleanupSelectionkey ( key ) ; 
 - continue ; 
 } 
 - 
 - if ( key . isAcceptable ( ) ) 
 - handleAccept ( ) ; 
 - if ( key . isReadable ( ) ) 
 - handleRead ( key ) ; 
 - else if ( key . isWritable ( ) ) 
 - handleWrite ( key ) ; 
 - else 
 - LOGGER . debug ( " Unexpected state " + key . interestOps ( ) ) ; 
 } 
 / / process the changes which are inserted after completion . 
 processInterestChanges ( ) ;
