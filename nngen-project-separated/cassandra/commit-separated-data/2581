BLEU SCORE: 0.027611988917697356

TEST MSG: optimize fetching multiple cells by name from CF
GENERATED MSG: range query support

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index e04867a . . 0fe4448 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 35 , 6 + 35 , 7 @ @ import org . apache . cassandra . db . composites . CellNameType ; <nl> import org . apache . cassandra . db . composites . Composite ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> import org . apache . cassandra . utils . memory . AbstractAllocator ; <nl> + import org . apache . cassandra . utils . SearchIterator ; <nl> <nl> / * * <nl> * A ColumnFamily backed by an array . <nl> @ @ - 437 , 6 + 438 , 57 @ @ public class ArrayBackedSortedColumns extends ColumnFamily <nl> return new SlicesIterator ( Arrays . asList ( cells ) . subList ( 0 , size ) , getComparator ( ) , slices , ! reversed ) ; <nl> } <nl> <nl> + public SearchIterator < CellName , Cell > searchIterator ( ) <nl> + { <nl> + maybeSortCells ( ) ; <nl> + return new SearchIterator < CellName , Cell > ( ) <nl> + { <nl> + / / the first index that we could find the next key at , i . e . one larger <nl> + / / than the last key ' s location <nl> + private int i = 0 ; <nl> + <nl> + / / We assume a uniform distribution of keys , <nl> + / / so we keep track of how many keys were skipped to satisfy last lookup , and only look at twice that <nl> + / / many keys for next lookup initially , extending to whole range only if we couldn ' t find it in that subrange <nl> + private int range = size / 2 ; <nl> + <nl> + public boolean hasNext ( ) <nl> + { <nl> + return i < size ; <nl> + } <nl> + <nl> + public Cell next ( CellName name ) <nl> + { <nl> + assert sortedSize = = size ; <nl> + assert hasNext ( ) ; <nl> + <nl> + / / optimize for runs of sequential matches , as in CollationController <nl> + / / checking to see if we ' ve found the desired cells yet ( CASSANDRA - 6933 ) <nl> + if ( metadata . comparator . compare ( name , cells [ i ] . name ( ) ) = = 0 ) <nl> + return cells [ i + + ] ; <nl> + <nl> + / / use range to manually force a better bsearch " pivot " by breaking it into two calls : <nl> + / / first for i . . i + range , then i + range . . size if necessary . <nl> + / / https : / / issues . apache . org / jira / browse / CASSANDRA - 6933 ? focusedCommentId = 13958264 & page = com . atlassian . jira . plugin . system . issuetabpanels : comment - tabpanel # comment - 13958264 <nl> + int limit = Math . min ( size , i + range ) ; <nl> + int i2 = binarySearch ( i + 1 , limit , name , internalComparator ( ) ) ; <nl> + if ( - 1 - i2 = = limit ) <nl> + i2 = binarySearch ( limit , size , name , internalComparator ( ) ) ; <nl> + / / i2 can ' t be zero since we already checked cells [ i ] above <nl> + if ( i2 > 0 ) <nl> + { <nl> + range = i2 - i ; <nl> + i = i2 + 1 ; <nl> + return cells [ i2 ] ; <nl> + } <nl> + i2 = - 1 - i2 ; <nl> + range = i2 - i ; <nl> + i = i2 ; <nl> + return null ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> private static class SlicesIterator extends AbstractIterator < Cell > <nl> { <nl> private final List < Cell > cells ; <nl> diff - - git a / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java b / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java <nl> index 8cbeb83 . . 8419235 100644 <nl> - - - a / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java <nl> @ @ - 36 , 7 + 36 , 9 @ @ import org . apache . cassandra . db . composites . Composite ; <nl> import org . apache . cassandra . db . index . SecondaryIndexManager ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> import org . apache . cassandra . utils . ObjectSizes ; <nl> + import org . apache . cassandra . utils . SearchIterator ; <nl> import org . apache . cassandra . utils . btree . BTree ; <nl> + import org . apache . cassandra . utils . btree . BTreeSearchIterator ; <nl> import org . apache . cassandra . utils . btree . BTreeSet ; <nl> import org . apache . cassandra . utils . btree . UpdateFunction ; <nl> <nl> @ @ - 119 , 6 + 121 , 11 @ @ public class AtomicBTreeColumns extends ColumnFamily <nl> delete ( new DeletionInfo ( tombstone , getComparator ( ) ) ) ; <nl> } <nl> <nl> + public SearchIterator < CellName , Cell > searchIterator ( ) <nl> + { <nl> + return new BTreeSearchIterator < > ( ref . tree , asymmetricComparator ( ) ) ; <nl> + } <nl> + <nl> public void delete ( DeletionInfo info ) <nl> { <nl> if ( info . isLive ( ) ) <nl> diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java <nl> index 151a7c5 . . 74113e0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CollationController . java <nl> + + + b / src / java / org / apache / cassandra / db / CollationController . java <nl> @ @ - 34 , 6 + 34 , 7 @ @ import org . apache . cassandra . db . marshal . CounterColumnType ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . tracing . Tracing ; <nl> + import org . apache . cassandra . utils . SearchIterator ; <nl> import org . apache . cassandra . utils . memory . HeapAllocator ; <nl> <nl> public class CollationController <nl> @ @ - 171 , 10 + 172 , 11 @ @ public class CollationController <nl> if ( container = = null ) <nl> return ; <nl> <nl> - for ( Iterator < CellName > iterator = ( ( NamesQueryFilter ) filter . filter ) . columns . iterator ( ) ; iterator . hasNext ( ) ; ) <nl> + SearchIterator < CellName , Cell > searchIter = container . searchIterator ( ) ; <nl> + for ( Iterator < CellName > iterator = ( ( NamesQueryFilter ) filter . filter ) . columns . iterator ( ) ; iterator . hasNext ( ) & & searchIter . hasNext ( ) ; ) <nl> { <nl> CellName filterColumn = iterator . next ( ) ; <nl> - Cell cell = container . getColumn ( filterColumn ) ; <nl> + Cell cell = searchIter . next ( filterColumn ) ; <nl> if ( cell ! = null & & cell . timestamp ( ) > sstableTimestamp ) <nl> iterator . remove ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index e7aab37 . . e9eb05a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 189 , 6 + 189 , 8 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry <nl> public abstract void delete ( DeletionTime deletionTime ) ; <nl> protected abstract void delete ( RangeTombstone tombstone ) ; <nl> <nl> + public abstract SearchIterator < CellName , Cell > searchIterator ( ) ; <nl> + <nl> / * * <nl> * Purges top - level and range tombstones whose localDeletionTime is older than gcBefore . <nl> * @ param gcBefore a timestamp ( in seconds ) before which tombstones should be purged <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / NamesQueryFilter . java b / src / java / org / apache / cassandra / db / filter / NamesQueryFilter . java <nl> index d6d1332 . . 03e3f12 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / NamesQueryFilter . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / NamesQueryFilter . java <nl> @ @ - 39 , 6 + 39 , 7 @ @ import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> import org . apache . cassandra . io . util . FileDataInput ; <nl> + import org . apache . cassandra . utils . SearchIterator ; <nl> <nl> public class NamesQueryFilter implements IDiskAtomFilter <nl> { <nl> @ @ - 183 , 13 + 184 , 15 @ @ public class NamesQueryFilter implements IDiskAtomFilter <nl> { <nl> private final ColumnFamily cf ; <nl> private final DecoratedKey key ; <nl> - private final Iterator < CellName > iter ; <nl> + private final Iterator < CellName > names ; <nl> + private final SearchIterator < CellName , Cell > cells ; <nl> <nl> - public ByNameColumnIterator ( Iterator < CellName > iter , ColumnFamily cf , DecoratedKey key ) <nl> + public ByNameColumnIterator ( Iterator < CellName > names , ColumnFamily cf , DecoratedKey key ) <nl> { <nl> - this . iter = iter ; <nl> + this . names = names ; <nl> this . cf = cf ; <nl> this . key = key ; <nl> + this . cells = cf . searchIterator ( ) ; <nl> } <nl> <nl> public ColumnFamily getColumnFamily ( ) <nl> @ @ - 204 , 10 + 207 , 10 @ @ public class NamesQueryFilter implements IDiskAtomFilter <nl> <nl> protected OnDiskAtom computeNext ( ) <nl> { <nl> - while ( iter . hasNext ( ) ) <nl> + while ( names . hasNext ( ) & & cells . hasNext ( ) ) <nl> { <nl> - CellName current = iter . next ( ) ; <nl> - Cell cell = cf . getColumn ( current ) ; <nl> + CellName current = names . next ( ) ; <nl> + Cell cell = cells . next ( current ) ; <nl> if ( cell ! = null ) <nl> return cell ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / AbstractRowResolver . java b / src / java / org / apache / cassandra / service / AbstractRowResolver . java <nl> index 47a00da . . e27dc00 100644 <nl> - - - a / src / java / org / apache / cassandra / service / AbstractRowResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / AbstractRowResolver . java <nl> @ @ - 18 , 9 + 18 , 10 @ @ <nl> package org . apache . cassandra . service ; <nl> <nl> import java . nio . ByteBuffer ; <nl> - import java . util . Set ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> <nl> - import org . cliffc . high _ scale _ lib . NonBlockingHashSet ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 34 , 7 + 35 , 7 @ @ public abstract class AbstractRowResolver implements IResponseResolver < ReadRespo <nl> protected static final Logger logger = LoggerFactory . getLogger ( AbstractRowResolver . class ) ; <nl> <nl> protected final String keyspaceName ; <nl> - protected final Set < MessageIn < ReadResponse > > replies = new NonBlockingHashSet < MessageIn < ReadResponse > > ( ) ; <nl> + protected final List < MessageIn < ReadResponse > > replies = Collections . synchronizedList ( new ArrayList < MessageIn < ReadResponse > > ( ) ) ; <nl> protected final DecoratedKey key ; <nl> <nl> public AbstractRowResolver ( ByteBuffer key , String keyspaceName ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / SearchIterator . java b / src / java / org / apache / cassandra / utils / SearchIterator . java <nl> new file mode 100644 <nl> index 0000000 . . 004b02a <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / SearchIterator . java <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + public interface SearchIterator < K , V > <nl> + { <nl> + <nl> + public boolean hasNext ( ) ; <nl> + public V next ( K key ) ; <nl> + <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java b / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java <nl> new file mode 100644 <nl> index 0000000 . . 7a83238 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java <nl> @ @ - 0 , 0 + 1 , 67 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . utils . btree ; <nl> + <nl> + import java . util . Comparator ; <nl> + <nl> + import org . apache . cassandra . utils . SearchIterator ; <nl> + <nl> + import static org . apache . cassandra . utils . btree . BTree . getKeyEnd ; <nl> + <nl> + public class BTreeSearchIterator < CK , K extends CK , V > extends Path implements SearchIterator < K , V > <nl> + { <nl> + <nl> + final Comparator < CK > comparator ; <nl> + public BTreeSearchIterator ( Object [ ] btree , Comparator < CK > comparator ) <nl> + { <nl> + init ( btree ) ; <nl> + this . comparator = comparator ; <nl> + } <nl> + <nl> + public V next ( K target ) <nl> + { <nl> + while ( depth > 0 ) <nl> + { <nl> + byte successorParentDepth = findSuccessorParentDepth ( ) ; <nl> + if ( successorParentDepth < 0 ) <nl> + break ; / / we ' re in last section of tree , so can only search down <nl> + int successorParentIndex = indexes [ successorParentDepth ] + 1 ; <nl> + Object [ ] successParentNode = path [ successorParentDepth ] ; <nl> + Object successorParentKey = successParentNode [ successorParentIndex ] ; <nl> + int c = BTree . compare ( comparator , target , successorParentKey ) ; <nl> + if ( c < 0 ) <nl> + break ; <nl> + if ( c = = 0 ) <nl> + { <nl> + depth = successorParentDepth ; <nl> + indexes [ successorParentDepth ] + + ; <nl> + return ( V ) successorParentKey ; <nl> + } <nl> + depth = successorParentDepth ; <nl> + indexes [ successorParentDepth ] + + ; <nl> + } <nl> + if ( find ( comparator , target , Op . CEIL , true ) ) <nl> + return ( V ) currentKey ( ) ; <nl> + return null ; <nl> + } <nl> + <nl> + public boolean hasNext ( ) <nl> + { <nl> + return depth ! = 0 | | indexes [ 0 ] ! = getKeyEnd ( path [ 0 ] ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / Cursor . java b / src / java / org / apache / cassandra / utils / btree / Cursor . java <nl> index bc88442 . . 132a776 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / Cursor . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / Cursor . java <nl> @ @ - 93 , 7 + 93 , 7 @ @ public final class Cursor < V > extends Path implements Iterator < V > <nl> <nl> private void _ reset ( Object [ ] btree , Comparator < V > comparator , Object lowerBound , boolean inclusiveLowerBound , Object upperBound , boolean inclusiveUpperBound , boolean forwards ) <nl> { <nl> - ensureDepth ( btree ) ; <nl> + init ( btree ) ; <nl> if ( lowerBound = = null ) <nl> lowerBound = NEGATIVE _ INFINITY ; <nl> if ( upperBound = = null ) <nl> @ @ - 101 , 16 + 101 , 16 @ @ public final class Cursor < V > extends Path implements Iterator < V > <nl> <nl> this . forwards = forwards ; <nl> <nl> - Path findLast = new Path ( this . path . length ) ; <nl> + Path findLast = new Path ( this . path . length , btree ) ; <nl> if ( forwards ) <nl> { <nl> - findLast . find ( btree , comparator , upperBound , inclusiveUpperBound ? Op . HIGHER : Op . CEIL , true ) ; <nl> - find ( btree , comparator , lowerBound , inclusiveLowerBound ? Op . CEIL : Op . HIGHER , true ) ; <nl> + findLast . find ( comparator , upperBound , inclusiveUpperBound ? Op . HIGHER : Op . CEIL , true ) ; <nl> + find ( comparator , lowerBound , inclusiveLowerBound ? Op . CEIL : Op . HIGHER , true ) ; <nl> } <nl> else <nl> { <nl> - findLast . find ( btree , comparator , lowerBound , inclusiveLowerBound ? Op . LOWER : Op . FLOOR , false ) ; <nl> - find ( btree , comparator , upperBound , inclusiveUpperBound ? Op . FLOOR : Op . LOWER , false ) ; <nl> + findLast . find ( comparator , lowerBound , inclusiveLowerBound ? Op . LOWER : Op . FLOOR , false ) ; <nl> + find ( comparator , upperBound , inclusiveUpperBound ? Op . FLOOR : Op . LOWER , false ) ; <nl> } <nl> int c = this . compareTo ( findLast , forwards ) ; <nl> if ( forwards ? c > 0 : c < 0 ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / Path . java b / src / java / org / apache / cassandra / utils / btree / Path . java <nl> index 148c713 . . 49e2d4b 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / Path . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / Path . java <nl> @ @ - 34 , 7 + 34 , 7 @ @ import static org . apache . cassandra . utils . btree . BTree . isLeaf ; <nl> * <nl> * Path is only intended to be used via Cursor . <nl> * / <nl> - class Path <nl> + public class Path < V > <nl> { <nl> / / operations corresponding to the ones in NavigableSet <nl> static enum Op <nl> @ @ - 50 , 16 + 50 , 17 @ @ class Path <nl> / / the index within the node of our path at a given depth <nl> byte [ ] indexes ; <nl> / / current depth . nothing in path [ i ] for i > depth is valid . <nl> - byte depth = - 1 ; <nl> + byte depth ; <nl> <nl> Path ( ) { } <nl> - Path ( int depth ) <nl> + Path ( int depth , Object [ ] btree ) <nl> { <nl> this . path = new Object [ depth ] [ ] ; <nl> this . indexes = new byte [ depth ] ; <nl> + this . path [ 0 ] = btree ; <nl> } <nl> <nl> - void ensureDepth ( Object [ ] btree ) <nl> + void init ( Object [ ] btree ) <nl> { <nl> int depth = BTree . depth ( btree ) ; <nl> if ( path = = null | | path . length < depth ) <nl> @ @ - 67 , 32 + 68 , 36 @ @ class Path <nl> path = new Object [ depth ] [ ] ; <nl> indexes = new byte [ depth ] ; <nl> } <nl> + path [ 0 ] = btree ; <nl> } <nl> <nl> / * * <nl> * Find the provided key in the tree rooted at node , and store the root to it in the path <nl> * <nl> - * @ param node the tree to search in <nl> * @ param comparator the comparator defining the order on the tree <nl> * @ param target the key to search for <nl> * @ param mode the type of search to perform <nl> * @ param forwards if the path should be setup for forward or backward iteration <nl> * @ param < V > <nl> * / <nl> - < V > void find ( Object [ ] node , Comparator < V > comparator , Object target , Op mode , boolean forwards ) <nl> + < V > boolean find ( Comparator < V > comparator , Object target , Op mode , boolean forwards ) <nl> { <nl> / / TODO : should not require parameter ' forwards ' - consider modifying index to represent both <nl> / / child and key position , as opposed to just key position ( which necessitates a different value depending <nl> / / on which direction you ' re moving in . Prerequisite for making Path public and using to implement general <nl> / / search <nl> <nl> - depth = - 1 ; <nl> + Object [ ] node = path [ depth ] ; <nl> + int lb = indexes [ depth ] ; <nl> + assert lb = = 0 | | forwards ; <nl> + pop ( ) ; <nl> while ( true ) <nl> { <nl> int keyEnd = getKeyEnd ( node ) ; <nl> <nl> / / search for the target in the current node <nl> - int i = BTree . find ( comparator , target , node , 0 , keyEnd ) ; <nl> + int i = BTree . find ( comparator , target , node , lb , keyEnd ) ; <nl> + lb = 0 ; <nl> if ( i > = 0 ) <nl> { <nl> / / exact match . transform exclusive bounds into the correct index by moving back or forwards one <nl> @ @ - 105 , 7 + 110 , 7 @ @ class Path <nl> case LOWER : <nl> predecessor ( ) ; <nl> } <nl> - return ; <nl> + return true ; <nl> } <nl> <nl> / / traverse into the appropriate child <nl> @ @ - 141 , 16 + 146 , 16 @ @ class Path <nl> push ( node , i ) ; <nl> } <nl> <nl> - return ; <nl> + return false ; <nl> } <nl> } <nl> <nl> - private boolean isRoot ( ) <nl> + boolean isRoot ( ) <nl> { <nl> return depth = = 0 ; <nl> } <nl> <nl> - private void pop ( ) <nl> + void pop ( ) <nl> { <nl> depth - - ; <nl> } <nl> @ @ - 165 , 7 + 170 , 7 @ @ class Path <nl> return indexes [ depth ] ; <nl> } <nl> <nl> - private void push ( Object [ ] node , int index ) <nl> + void push ( Object [ ] node , int index ) <nl> { <nl> path [ + + depth ] = node ; <nl> indexes [ depth ] = ( byte ) index ; <nl> @ @ - 176 , 6 + 181 , 21 @ @ class Path <nl> indexes [ depth ] = ( byte ) index ; <nl> } <nl> <nl> + byte findSuccessorParentDepth ( ) <nl> + { <nl> + byte depth = this . depth ; <nl> + depth - - ; <nl> + while ( depth > = 0 ) <nl> + { <nl> + int ub = indexes [ depth ] + 1 ; <nl> + Object [ ] node = path [ depth ] ; <nl> + if ( ub < getBranchKeyEnd ( node ) ) <nl> + return depth ; <nl> + depth - - ; <nl> + } <nl> + return - 1 ; <nl> + } <nl> + <nl> / / move to the next key in the tree <nl> void successor ( ) <nl> { <nl> diff - - git a / test / long / org / apache / cassandra / utils / LongBTreeTest . java b / test / long / org / apache / cassandra / utils / LongBTreeTest . java <nl> index 514d166 . . 498a9c9 100644 <nl> - - - a / test / long / org / apache / cassandra / utils / LongBTreeTest . java <nl> + + + b / test / long / org / apache / cassandra / utils / LongBTreeTest . java <nl> @ @ - 20 , 11 + 20 , 21 @ @ package org . apache . cassandra . utils ; <nl> <nl> import java . util . * ; <nl> import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . CountDownLatch ; <nl> import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . ExecutorService ; <nl> import java . util . concurrent . Executors ; <nl> + import java . util . concurrent . Semaphore ; <nl> + import java . util . concurrent . ThreadLocalRandom ; <nl> import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . atomic . AtomicLong ; <nl> <nl> + import javax . annotation . Nullable ; <nl> + <nl> + import com . google . common . base . Function ; <nl> + import com . google . common . base . Predicate ; <nl> + import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . Iterators ; <nl> import com . google . common . util . concurrent . Futures ; <nl> import com . google . common . util . concurrent . ListenableFuture ; <nl> import com . google . common . util . concurrent . ListenableFutureTask ; <nl> @ @ - 37 , 7 + 47 , 9 @ @ import com . yammer . metrics . core . TimerContext ; <nl> import com . yammer . metrics . stats . Snapshot ; <nl> import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> import org . apache . cassandra . utils . btree . BTree ; <nl> + import org . apache . cassandra . utils . btree . BTreeSearchIterator ; <nl> import org . apache . cassandra . utils . btree . BTreeSet ; <nl> + import org . apache . cassandra . utils . btree . UpdateFunction ; <nl> <nl> / / TODO : should probably lower fan - factor for tests to make them more intensive <nl> public class LongBTreeTest <nl> @ @ - 103 , 6 + 115 , 51 @ @ public class LongBTreeTest <nl> testInsertions ( 10000 , 50 , 10 , 10 , false ) ; <nl> } <nl> <nl> + @ Test <nl> + public void testSearchIterator ( ) throws InterruptedException <nl> + { <nl> + int threads = Runtime . getRuntime ( ) . availableProcessors ( ) ; <nl> + final CountDownLatch latch = new CountDownLatch ( threads ) ; <nl> + final AtomicLong errors = new AtomicLong ( ) ; <nl> + final AtomicLong count = new AtomicLong ( ) ; <nl> + final int perThreadTrees = 100 ; <nl> + final int perTreeSelections = 100 ; <nl> + final long totalCount = threads * perThreadTrees * perTreeSelections ; <nl> + for ( int t = 0 ; t < threads ; t + + ) <nl> + { <nl> + MODIFY . execute ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; <nl> + for ( int i = 0 ; i < perThreadTrees ; i + + ) <nl> + { <nl> + Object [ ] tree = randomTree ( 10000 , random ) ; <nl> + for ( int j = 0 ; j < perTreeSelections ; j + + ) <nl> + { <nl> + BTreeSearchIterator < Integer , Integer , Integer > searchIterator = new BTreeSearchIterator < > ( tree , ICMP ) ; <nl> + for ( Integer key : randomSelection ( tree , random ) ) <nl> + if ( key ! = searchIterator . next ( key ) ) <nl> + errors . incrementAndGet ( ) ; <nl> + for ( Integer key : randomMix ( tree , random ) ) <nl> + if ( key ! = searchIterator . next ( key ) ) <nl> + if ( BTree . find ( tree , ICMP , key ) = = key ) <nl> + errors . incrementAndGet ( ) ; <nl> + count . incrementAndGet ( ) ; <nl> + } <nl> + } <nl> + latch . countDown ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + while ( latch . getCount ( ) > 0 ) <nl> + { <nl> + latch . await ( 10L , TimeUnit . SECONDS ) ; <nl> + System . out . println ( String . format ( " % . 0f % % complete % s " , 100 * count . get ( ) / ( double ) totalCount , errors . get ( ) > 0 ? ( " Errors : " + errors . get ( ) ) : " " ) ) ; <nl> + assert errors . get ( ) = = 0 ; <nl> + } <nl> + } <nl> + <nl> private static void testInsertions ( int totalCount , int perTestCount , int testKeyRatio , int modificationBatchSize , boolean quickEquality ) throws ExecutionException , InterruptedException <nl> { <nl> int batchesPerTest = perTestCount / modificationBatchSize ; <nl> @ @ - 354 , 4 + 411 , 43 @ @ public class LongBTreeTest <nl> } ; <nl> } <nl> <nl> + private static Object [ ] randomTree ( int maxSize , Random random ) <nl> + { <nl> + TreeSet < Integer > build = new TreeSet < > ( ) ; <nl> + int size = random . nextInt ( maxSize ) ; <nl> + for ( int i = 0 ; i < size ; i + + ) <nl> + { <nl> + build . add ( random . nextInt ( ) ) ; <nl> + } <nl> + return BTree . build ( build , ICMP , true , UpdateFunction . NoOp . < Integer > instance ( ) ) ; <nl> + } <nl> + <nl> + private static Iterable < Integer > randomSelection ( Object [ ] iter , final Random rnd ) <nl> + { <nl> + final float proportion = rnd . nextFloat ( ) ; <nl> + return Iterables . filter ( new BTreeSet < > ( iter , ICMP ) , new Predicate < Integer > ( ) <nl> + { <nl> + public boolean apply ( @ Nullable Integer integer ) <nl> + { <nl> + return rnd . nextFloat ( ) < proportion ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + private static Iterable < Integer > randomMix ( Object [ ] iter , final Random rnd ) <nl> + { <nl> + final float proportion = rnd . nextFloat ( ) ; <nl> + return Iterables . transform ( new BTreeSet < > ( iter , ICMP ) , new Function < Integer , Integer > ( ) <nl> + { <nl> + int last = Integer . MIN _ VALUE ; <nl> + <nl> + public Integer apply ( Integer v ) <nl> + { <nl> + if ( rnd . nextFloat ( ) < proportion ) <nl> + return last = v ; <nl> + return last = ( v - last ) / 2 ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java b / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java <nl> index a1c98f3 . . 33d3599 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . db . composites . * ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> import org . apache . cassandra . db . marshal . Int32Type ; <nl> + import org . apache . cassandra . utils . SearchIterator ; <nl> <nl> public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> { <nl> @ @ - 213 , 6 + 214 , 43 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> assertSame ( map . iterator ( ) , map . iterator ( ColumnSlice . ALL _ COLUMNS _ ARRAY ) ) ; <nl> } <nl> <nl> + @ Test <nl> + public void testSearchIterator ( ) <nl> + { <nl> + CellNameType type = new SimpleDenseCellNameType ( Int32Type . instance ) ; <nl> + ColumnFamily map = ArrayBackedSortedColumns . factory . create ( metadata ( ) , false ) ; <nl> + <nl> + int [ ] values = new int [ ] { 1 , 2 , 3 , 5 , 9 , 15 , 21 , 22 } ; <nl> + <nl> + for ( int i = 0 ; i < values . length ; + + i ) <nl> + map . addColumn ( new Cell ( type . makeCellName ( values [ i ] ) ) ) ; <nl> + <nl> + SearchIterator < CellName , Cell > iter = map . searchIterator ( ) ; <nl> + for ( int i = 0 ; i < values . length ; i + + ) <nl> + assertSame ( values [ i ] , iter . next ( type . makeCellName ( values [ i ] ) ) ) ; <nl> + <nl> + iter = map . searchIterator ( ) ; <nl> + for ( int i = 0 ; i < values . length ; i + = 2 ) <nl> + assertSame ( values [ i ] , iter . next ( type . makeCellName ( values [ i ] ) ) ) ; <nl> + <nl> + iter = map . searchIterator ( ) ; <nl> + for ( int i = 0 ; i < values . length ; i + = 4 ) <nl> + assertSame ( values [ i ] , iter . next ( type . makeCellName ( values [ i ] ) ) ) ; <nl> + <nl> + iter = map . searchIterator ( ) ; <nl> + for ( int i = 0 ; i < values . length ; i + = 1 ) <nl> + { <nl> + if ( i % 2 = = 0 ) <nl> + { <nl> + Cell cell = iter . next ( type . makeCellName ( values [ i ] - 1 ) ) ; <nl> + if ( i > 0 & & values [ i - 1 ] = = values [ i ] - 1 ) <nl> + assertSame ( values [ i - 1 ] , cell ) ; <nl> + else <nl> + assertNull ( cell ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> private < T > void assertSame ( Iterable < T > c1 , Iterable < T > c2 ) <nl> { <nl> assertSame ( c1 . iterator ( ) , c2 . iterator ( ) ) ; <nl> @ @ - 226 , 6 + 264 , 11 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> fail ( " The collection don ' t have the same size " ) ; <nl> } <nl> <nl> + private void assertSame ( int name , Cell cell ) <nl> + { <nl> + int value = ByteBufferUtil . toInt ( cell . name ( ) . toByteBuffer ( ) ) ; <nl> + assert name = = value : " Expected " + name + " but got " + value ; <nl> + } <nl> private void assertSame ( int [ ] names , Iterator < Cell > iter ) <nl> { <nl> for ( int name : names )
NEAREST DIFF (one line): diff - - git a / src / org / apache / cassandra / config / DatabaseDescriptor . java b / src / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 683009c . . 73cf3a6 100644 <nl> - - - a / src / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 18 , 21 + 18 , 24 @ @ <nl> <nl> package org . apache . cassandra . config ; <nl> <nl> - import java . util . * ; <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + import java . util . ArrayList ; <nl> + import java . util . HashMap ; <nl> + import java . util . HashSet ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> - import java . io . * ; <nl> <nl> import org . apache . cassandra . db . ColumnFamily ; <nl> + import org . apache . cassandra . db . SystemTable ; <nl> import org . apache . cassandra . db . Table ; <nl> import org . apache . cassandra . db . TypeInfo ; <nl> - import org . apache . cassandra . db . DBManager ; <nl> - import org . apache . cassandra . db . SystemTable ; <nl> - import org . apache . cassandra . db . Table . TableMetadata ; <nl> import org . apache . cassandra . utils . FileUtils ; <nl> import org . apache . cassandra . utils . XMLUtils ; <nl> import org . w3c . dom . Node ; <nl> import org . w3c . dom . NodeList ; <nl> - import org . apache . cassandra . io . * ; <nl> <nl> <nl> / * * <nl> @ @ - 306 , 6 + 309 , 9 @ @ public class DatabaseDescriptor <nl> / * Read the table related stuff from config * / <nl> NodeList tables = xmlUtils . getRequestedNodeList ( " / Storage / Tables / Table " ) ; <nl> int size = tables . getLength ( ) ; <nl> + if ( size = = 0 ) { <nl> + throw new UnsupportedOperationException ( " A Table must be configured " ) ; <nl> + } <nl> for ( int i = 0 ; i < size ; + + i ) <nl> { <nl> Node table = tables . item ( i ) ; <nl> @ @ - 785 , 4 + 791 , 9 @ @ public class DatabaseDescriptor <nl> { <nl> return tableToCFMetaDataMap _ ; <nl> } <nl> + <nl> + public static String getTableName ( ) <nl> + { <nl> + return tables _ . get ( 0 ) ; <nl> + } <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / ColumnFamily . java b / src / org / apache / cassandra / db / ColumnFamily . java <nl> index 51ac744 . . a2ac3a2 100644 <nl> - - - a / src / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 288 , 7 + 288 , 7 @ @ public final class ColumnFamily <nl> return columns _ . getSortedColumns ( ) ; <nl> } <nl> <nl> - Map < String , IColumn > getColumns ( ) <nl> + public Map < String , IColumn > getColumns ( ) <nl> { <nl> return columns _ . getColumns ( ) ; <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / ColumnFamilyStore . java b / src / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index be7c245 . . 28bb3f7 100644 <nl> - - - a / src / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1384 , 4 + 1384 , 14 @ @ public class ColumnFamilyStore <nl> { <nl> memtable _ . get ( ) . flushOnRecovery ( ) ; <nl> } <nl> + <nl> + public Object getMemtable ( ) <nl> + { <nl> + return memtable _ . get ( ) ; <nl> + } <nl> + <nl> + public Set < String > getSSTableFilenames ( ) <nl> + { <nl> + return Collections . unmodifiableSet ( ssTables _ ) ; <nl> + } <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / Memtable . java b / src / org / apache / cassandra / db / Memtable . java <nl> index 2bdad37 . . 567b829 100644 <nl> - - - a / src / org / apache / cassandra / db / Memtable . java <nl> + + + b / src / org / apache / cassandra / db / Memtable . java <nl> @ @ - 26 , 6 + 26 , 8 @ @ import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . Set ; <nl> + import java . util . Iterator ; <nl> + import java . util . PriorityQueue ; <nl> import java . util . concurrent . Callable ; <nl> import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . ExecutorService ; <nl> @ @ - 45 , 6 + 47 , 7 @ @ import org . apache . cassandra . io . DataOutputBuffer ; <nl> import org . apache . cassandra . io . SSTable ; <nl> import org . apache . cassandra . utils . BloomFilter ; <nl> import org . apache . cassandra . utils . LogUtil ; <nl> + import org . apache . cassandra . utils . DestructivePQIterator ; <nl> <nl> / * * <nl> * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) <nl> @ @ - 419 , 4 + 422 , 9 @ @ public class Memtable implements MemtableMBean , Comparable < Memtable > <nl> columnFamilies _ . clear ( ) ; <nl> } <nl> <nl> + public Iterator < String > sortedKeyIterator ( ) <nl> + { <nl> + return new DestructivePQIterator < String > ( new PriorityQueue < String > ( columnFamilies _ . keySet ( ) ) ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / MemtableManager . java b / src / org / apache / cassandra / db / MemtableManager . java <nl> index 997bbd3 . . 54242d1 100644 <nl> - - - a / src / org / apache / cassandra / db / MemtableManager . java <nl> + + + b / src / org / apache / cassandra / db / MemtableManager . java <nl> @ @ - 40 , 7 + 40 , 7 @ @ public class MemtableManager <nl> private static Lock lock _ = new ReentrantLock ( ) ; <nl> private static Logger logger _ = Logger . getLogger ( MemtableManager . class ) ; <nl> private ReentrantReadWriteLock rwLock _ = new ReentrantReadWriteLock ( true ) ; <nl> - static MemtableManager instance ( ) <nl> + public static MemtableManager instance ( ) <nl> { <nl> if ( instance _ = = null ) <nl> { <nl> @ @ - 157 , 7 + 157 , 22 @ @ public class MemtableManager <nl> 	 } <nl> } <nl> <nl> - <nl> - <nl> + public List < Memtable > getUnflushedMemtables ( String cfName ) <nl> + { <nl> + rwLock _ . readLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + List < Memtable > memtables = history _ . get ( cfName ) ; <nl> + if ( memtables ! = null ) <nl> + { <nl> + return new ArrayList < Memtable > ( memtables ) ; <nl> + } <nl> + return Arrays . asList ( new Memtable [ 0 ] ) ; <nl> + } <nl> + finally <nl> + { <nl> + rwLock _ . readLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> <nl> } <nl> diff - - git a / src / org / apache / cassandra / db / Table . java b / src / org / apache / cassandra / db / Table . java <nl> index 9c84b42 . . f1b260a 100644 <nl> - - - a / src / org / apache / cassandra / db / Table . java <nl> + + + b / src / org / apache / cassandra / db / Table . java <nl> @ @ - 60 , 7 + 60 , 7 @ @ public class Table <nl> * is basically the column family name and the ID associated with <nl> * this column family . We use this ID in the Commit Log header to <nl> * determine when a log file that has been rolled can be deleted . <nl> - * / <nl> + * / <nl> public static class TableMetadata <nl> { <nl> / * Name of the column family * / <nl> @ @ - 454 , 7 + 454 , 7 @ @ public class Table <nl> return columnFamilyStores _ ; <nl> } <nl> <nl> - ColumnFamilyStore getColumnFamilyStore ( String cfName ) <nl> + public ColumnFamilyStore getColumnFamilyStore ( String cfName ) <nl> { <nl> return columnFamilyStores _ . get ( cfName ) ; <nl> } <nl> @ @ - 875 , 4 + 875 , 17 @ @ public class Table <nl> long timeTaken = System . currentTimeMillis ( ) - start ; <nl> dbAnalyticsSource _ . updateWriteStatistics ( timeTaken ) ; <nl> } <nl> + <nl> + public Set < String > getApplicationColumnFamilies ( ) <nl> + { <nl> + Set < String > set = new HashSet < String > ( ) ; <nl> + for ( String cfName : getColumnFamilies ( ) ) <nl> + { <nl> + if ( DatabaseDescriptor . isApplicationColumnFamily ( cfName ) ) <nl> + { <nl> + set . add ( cfName ) ; <nl> + } <nl> + } <nl> + return set ; <nl> + } <nl> } <nl> diff - - git a / src / org / apache / cassandra / service / CassandraServer . java b / src / org / apache / cassandra / service / CassandraServer . java <nl> index 93b62e7 . . c2d5f66 100644 <nl> - - - a / src / org / apache / cassandra / service / CassandraServer . java <nl> + + + b / src / org / apache / cassandra / service / CassandraServer . java <nl> @ @ - 817 , 6 + 817 , 71 @ @ public class CassandraServer extends FacebookBase implements <nl> return result ; <nl> } <nl> <nl> + public List < String > get _ range ( String tablename , final String startkey ) throws CassandraException <nl> + { <nl> + logger _ . debug ( " get _ range " ) ; <nl> + <nl> + / / send request <nl> + Message message ; <nl> + DataOutputBuffer dob = new DataOutputBuffer ( ) ; <nl> + try <nl> + { <nl> + dob . writeUTF ( startkey ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + logger _ . error ( " unable to write startkey " , e ) ; <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + byte [ ] messageBody = Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ; <nl> + message = new Message ( StorageService . getLocalStorageEndPoint ( ) , <nl> + StorageService . readStage _ , <nl> + StorageService . rangeVerbHandler _ , <nl> + messageBody ) ; <nl> + EndPoint endPoint ; <nl> + try <nl> + { <nl> + endPoint = StorageService . instance ( ) . findSuitableEndPoint ( startkey ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new CassandraException ( " Unable to find endpoint for " + startkey ) ; <nl> + } <nl> + IAsyncResult iar = MessagingService . getMessagingInstance ( ) . sendRR ( message , endPoint ) ; <nl> + <nl> + / / read response <nl> + / / TODO send more requests if we need to span multiple nodes ( or can we just let client worry about that , <nl> + / / since they have to handle multiple requests anyway ? ) <nl> + byte [ ] responseBody ; <nl> + try <nl> + { <nl> + responseBody = ( byte [ ] ) iar . get ( 2 * DatabaseDescriptor . getRpcTimeout ( ) , TimeUnit . MILLISECONDS ) [ 0 ] ; <nl> + } <nl> + catch ( TimeoutException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + DataInputBuffer bufIn = new DataInputBuffer ( ) ; <nl> + bufIn . reset ( responseBody , responseBody . length ) ; <nl> + <nl> + / / turn into List <nl> + List < String > keys = new ArrayList < String > ( ) ; <nl> + while ( bufIn . getPosition ( ) < responseBody . length ) <nl> + { <nl> + try <nl> + { <nl> + keys . add ( bufIn . readUTF ( ) ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + logger _ . error ( " bad utf " , e ) ; <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + return keys ; <nl> + } <nl> + <nl> / * <nl> * This method is used to ensure that all keys <nl> * prior to the specified key , as dtermined by <nl> diff - - git a / src / org / apache / cassandra / service / RangeVerbHandler . java b / src / org / apache / cassandra / service / RangeVerbHandler . java <nl> new file mode 100644 <nl> index 0000000 . . 3587907 <nl> - - - / dev / null <nl> + + + b / src / org / apache / cassandra / service / RangeVerbHandler . java <nl> @ @ - 0 , 0 + 1 , 152 @ @ <nl> + package org . apache . cassandra . service ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + import java . util . Iterator ; <nl> + import java . util . Comparator ; <nl> + import java . util . Arrays ; <nl> + import java . io . FileNotFoundException ; <nl> + import java . io . IOException ; <nl> + <nl> + import org . apache . commons . collections . IteratorUtils ; <nl> + import org . apache . commons . collections . Predicate ; <nl> + <nl> + import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . net . IVerbHandler ; <nl> + import org . apache . cassandra . net . Message ; <nl> + import org . apache . cassandra . db . IdentityFilter ; <nl> + import org . apache . cassandra . db . ColumnFamily ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . FileStruct ; <nl> + import org . apache . cassandra . db . Table ; <nl> + import org . apache . cassandra . db . Memtable ; <nl> + import org . apache . cassandra . db . MemtableManager ; <nl> + import org . apache . cassandra . io . SequenceFile ; <nl> + import org . apache . cassandra . io . DataInputBuffer ; <nl> + import org . apache . cassandra . io . DataOutputBuffer ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + <nl> + public class RangeVerbHandler implements IVerbHandler <nl> + { <nl> + public static final Comparator < String > STRING _ COMPARATOR = new Comparator < String > ( ) <nl> + { <nl> + public int compare ( String o1 , String o2 ) <nl> + { <nl> + return o1 . compareTo ( o2 ) ; <nl> + } <nl> + } ; <nl> + <nl> + public void doVerb ( Message message ) <nl> + { <nl> + byte [ ] bytes = ( byte [ ] ) message . getMessageBody ( ) [ 0 ] ; <nl> + final String startkey ; <nl> + if ( bytes . length = = 0 ) <nl> + { <nl> + startkey = " " ; <nl> + } <nl> + else <nl> + { <nl> + DataInputBuffer dib = new DataInputBuffer ( ) ; <nl> + dib . reset ( bytes , bytes . length ) ; <nl> + try <nl> + { <nl> + startkey = dib . readUTF ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + List < Iterator < String > > iterators = new ArrayList < Iterator < String > > ( ) ; <nl> + Table table = Table . open ( DatabaseDescriptor . getTableName ( ) ) ; <nl> + for ( String cfName : table . getApplicationColumnFamilies ( ) ) <nl> + { <nl> + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; <nl> + <nl> + / / memtable keys : current and historical <nl> + Iterator < Memtable > it = ( Iterator < Memtable > ) IteratorUtils . chainedIterator ( <nl> + IteratorUtils . singletonIterator ( cfs . getMemtable ( ) ) , <nl> + MemtableManager . instance ( ) . getUnflushedMemtables ( cfName ) . iterator ( ) ) ; <nl> + while ( it . hasNext ( ) ) <nl> + { <nl> + iterators . add ( IteratorUtils . filteredIterator ( it . next ( ) . sortedKeyIterator ( ) , new Predicate ( ) <nl> + { <nl> + public boolean evaluate ( Object key ) <nl> + { <nl> + return ( ( String ) key ) . compareTo ( startkey ) > = 0 ; <nl> + } <nl> + } ) ) ; <nl> + } <nl> + <nl> + / / sstables <nl> + for ( String filename : cfs . getSSTableFilenames ( ) ) <nl> + { <nl> + try <nl> + { <nl> + FileStruct fs = new FileStruct ( SequenceFile . reader ( filename ) ) ; <nl> + fs . seekTo ( startkey ) ; <nl> + iterators . add ( fs . iterator ( ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + Iterator < String > iter = IteratorUtils . collatedIterator ( STRING _ COMPARATOR , iterators ) ; <nl> + List < String > keys = new ArrayList < String > ( ) ; <nl> + String last = null , current = null ; <nl> + <nl> + while ( keys . size ( ) < 1000 ) <nl> + { <nl> + if ( ! iter . hasNext ( ) ) <nl> + { <nl> + break ; <nl> + } <nl> + current = iter . next ( ) ; <nl> + if ( ! current . equals ( last ) ) <nl> + { <nl> + last = current ; <nl> + for ( String cfName : table . getApplicationColumnFamilies ( ) ) <nl> + { <nl> + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; <nl> + try <nl> + { <nl> + ColumnFamily cf = cfs . getColumnFamily ( current , cfName , new IdentityFilter ( ) ) ; <nl> + if ( cf ! = null & & cf . getColumns ( ) . size ( ) > 0 ) <nl> + { <nl> + keys . add ( current ) ; <nl> + break ; <nl> + } <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + DataOutputBuffer dob = new DataOutputBuffer ( ) ; <nl> + for ( String key : keys ) <nl> + { <nl> + try <nl> + { <nl> + dob . writeUTF ( key ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + byte [ ] data = Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ; <nl> + Message response = message . getReply ( StorageService . getLocalStorageEndPoint ( ) , data ) ; <nl> + MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; <nl> + } <nl> + } <nl> diff - - git a / src / org / apache / cassandra / service / StorageService . java b / src / org / apache / cassandra / service / StorageService . java <nl> index 409cd5f . . 95de5c6 100644 <nl> - - - a / src / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / org / apache / cassandra / service / StorageService . java <nl> @ @ - 138 , 6 + 138 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> public final static String bsMetadataVerbHandler _ = " BS - METADATA - VERB - HANDLER " ; <nl> public final static String calloutDeployVerbHandler _ = " CALLOUT - DEPLOY - VERB - HANDLER " ; <nl> public final static String touchVerbHandler _ = " TOUCH - VERB - HANDLER " ; <nl> + public static String rangeVerbHandler _ = " RANGE - VERB - HANDLER " ; <nl> <nl> public static enum ConsistencyLevel <nl> { <nl> diff - - git a / src / org / apache / cassandra / utils / DestructivePQIterator . java b / src / org / apache / cassandra / utils / DestructivePQIterator . java <nl> new file mode 100644 <nl> index 0000000 . . 0ed96f8 <nl> - - - / dev / null <nl> + + + b / src / org / apache / cassandra / utils / DestructivePQIterator . java <nl> @ @ - 0 , 0 + 1 , 25 @ @ <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . Iterator ; <nl> + import java . util . PriorityQueue ; <nl> + <nl> + public class DestructivePQIterator < T > implements Iterator < T > { <nl> + private PriorityQueue < T > pq ; <nl> + <nl> + public DestructivePQIterator ( PriorityQueue < T > pq ) { <nl> + this . pq = pq ; <nl> + } <nl> + <nl> + public boolean hasNext ( ) { <nl> + return pq . size ( ) > 0 ; <nl> + } <nl> + <nl> + public T next ( ) { <nl> + return pq . poll ( ) ; <nl> + } <nl> + <nl> + public void remove ( ) { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + } <nl> + <nl> diff - - git a / test / org / apache / cassandra / service / CassandraServerTest . java b / test / org / apache / cassandra / service / CassandraServerTest . java <nl> index 07c7dfe . . 762bbb5 100644 <nl> - - - a / test / org / apache / cassandra / service / CassandraServerTest . java <nl> + + + b / test / org / apache / cassandra / service / CassandraServerTest . java <nl> @ @ - 9 , 8 + 9 , 50 @ @ import org . testng . annotations . Test ; <nl> import java . io . IOException ; <nl> import java . util . * ; <nl> <nl> + import com . facebook . thrift . TException ; <nl> + <nl> public class CassandraServerTest extends ServerTest { <nl> / * <nl> + TODO fix resetting server so this works <nl> + @ Test <nl> + public void test _ get _ range _ empty ( ) throws IOException , TException { <nl> + CassandraServer server = new CassandraServer ( ) ; <nl> + server . start ( ) ; <nl> + <nl> + assert CollectionUtils . EMPTY _ COLLECTION . equals ( server . get _ range ( DatabaseDescriptor . getTableName ( ) , " " ) ) ; <nl> + } <nl> + * / <nl> + <nl> + / * <nl> + @ Test <nl> + public void test _ get _ range ( ) throws IOException , TException , CassandraException <nl> + { <nl> + CassandraServer server = new CassandraServer ( ) ; <nl> + try <nl> + { <nl> + server . start ( ) ; <nl> + } <nl> + catch ( Throwable throwable ) <nl> + { <nl> + throw new RuntimeException ( throwable ) ; <nl> + } <nl> + <nl> + / / TODO insert some data <nl> + try { <nl> + String last = null ; <nl> + for ( String key : server . get _ range ( DatabaseDescriptor . getTableName ( ) , " key1 " ) ) { <nl> + if ( last ! = null ) { <nl> + assert last . compareTo ( key ) < 0 ; <nl> + } <nl> + last = key ; <nl> + } <nl> + } finally { <nl> + server . shutdown ( ) ; <nl> + } <nl> + } <nl> + * / <nl> + <nl> + / * <nl> @ Test <nl> public void test _ get _ column ( ) throws Throwable { <nl> CassandraServer server = new CassandraServer ( ) ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index e04867a . . 0fe4448 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 35 , 6 + 35 , 7 @ @ import org . apache . cassandra . db . composites . CellNameType ; 
 import org . apache . cassandra . db . composites . Composite ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 import org . apache . cassandra . utils . memory . AbstractAllocator ; 
 + import org . apache . cassandra . utils . SearchIterator ; 
 
 / * * 
 * A ColumnFamily backed by an array . 
 @ @ - 437 , 6 + 438 , 57 @ @ public class ArrayBackedSortedColumns extends ColumnFamily 
 return new SlicesIterator ( Arrays . asList ( cells ) . subList ( 0 , size ) , getComparator ( ) , slices , ! reversed ) ; 
 } 
 
 + public SearchIterator < CellName , Cell > searchIterator ( ) 
 + { 
 + maybeSortCells ( ) ; 
 + return new SearchIterator < CellName , Cell > ( ) 
 + { 
 + / / the first index that we could find the next key at , i . e . one larger 
 + / / than the last key ' s location 
 + private int i = 0 ; 
 + 
 + / / We assume a uniform distribution of keys , 
 + / / so we keep track of how many keys were skipped to satisfy last lookup , and only look at twice that 
 + / / many keys for next lookup initially , extending to whole range only if we couldn ' t find it in that subrange 
 + private int range = size / 2 ; 
 + 
 + public boolean hasNext ( ) 
 + { 
 + return i < size ; 
 + } 
 + 
 + public Cell next ( CellName name ) 
 + { 
 + assert sortedSize = = size ; 
 + assert hasNext ( ) ; 
 + 
 + / / optimize for runs of sequential matches , as in CollationController 
 + / / checking to see if we ' ve found the desired cells yet ( CASSANDRA - 6933 ) 
 + if ( metadata . comparator . compare ( name , cells [ i ] . name ( ) ) = = 0 ) 
 + return cells [ i + + ] ; 
 + 
 + / / use range to manually force a better bsearch " pivot " by breaking it into two calls : 
 + / / first for i . . i + range , then i + range . . size if necessary . 
 + / / https : / / issues . apache . org / jira / browse / CASSANDRA - 6933 ? focusedCommentId = 13958264 & page = com . atlassian . jira . plugin . system . issuetabpanels : comment - tabpanel # comment - 13958264 
 + int limit = Math . min ( size , i + range ) ; 
 + int i2 = binarySearch ( i + 1 , limit , name , internalComparator ( ) ) ; 
 + if ( - 1 - i2 = = limit ) 
 + i2 = binarySearch ( limit , size , name , internalComparator ( ) ) ; 
 + / / i2 can ' t be zero since we already checked cells [ i ] above 
 + if ( i2 > 0 ) 
 + { 
 + range = i2 - i ; 
 + i = i2 + 1 ; 
 + return cells [ i2 ] ; 
 + } 
 + i2 = - 1 - i2 ; 
 + range = i2 - i ; 
 + i = i2 ; 
 + return null ; 
 + } 
 + } ; 
 + } 
 + 
 private static class SlicesIterator extends AbstractIterator < Cell > 
 { 
 private final List < Cell > cells ; 
 diff - - git a / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java b / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java 
 index 8cbeb83 . . 8419235 100644 
 - - - a / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java 
 + + + b / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java 
 @ @ - 36 , 7 + 36 , 9 @ @ import org . apache . cassandra . db . composites . Composite ; 
 import org . apache . cassandra . db . index . SecondaryIndexManager ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 import org . apache . cassandra . utils . ObjectSizes ; 
 + import org . apache . cassandra . utils . SearchIterator ; 
 import org . apache . cassandra . utils . btree . BTree ; 
 + import org . apache . cassandra . utils . btree . BTreeSearchIterator ; 
 import org . apache . cassandra . utils . btree . BTreeSet ; 
 import org . apache . cassandra . utils . btree . UpdateFunction ; 
 
 @ @ - 119 , 6 + 121 , 11 @ @ public class AtomicBTreeColumns extends ColumnFamily 
 delete ( new DeletionInfo ( tombstone , getComparator ( ) ) ) ; 
 } 
 
 + public SearchIterator < CellName , Cell > searchIterator ( ) 
 + { 
 + return new BTreeSearchIterator < > ( ref . tree , asymmetricComparator ( ) ) ; 
 + } 
 + 
 public void delete ( DeletionInfo info ) 
 { 
 if ( info . isLive ( ) ) 
 diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java 
 index 151a7c5 . . 74113e0 100644 
 - - - a / src / java / org / apache / cassandra / db / CollationController . java 
 + + + b / src / java / org / apache / cassandra / db / CollationController . java 
 @ @ - 34 , 6 + 34 , 7 @ @ import org . apache . cassandra . db . marshal . CounterColumnType ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . tracing . Tracing ; 
 + import org . apache . cassandra . utils . SearchIterator ; 
 import org . apache . cassandra . utils . memory . HeapAllocator ; 
 
 public class CollationController 
 @ @ - 171 , 10 + 172 , 11 @ @ public class CollationController 
 if ( container = = null ) 
 return ; 
 
 - for ( Iterator < CellName > iterator = ( ( NamesQueryFilter ) filter . filter ) . columns . iterator ( ) ; iterator . hasNext ( ) ; ) 
 + SearchIterator < CellName , Cell > searchIter = container . searchIterator ( ) ; 
 + for ( Iterator < CellName > iterator = ( ( NamesQueryFilter ) filter . filter ) . columns . iterator ( ) ; iterator . hasNext ( ) & & searchIter . hasNext ( ) ; ) 
 { 
 CellName filterColumn = iterator . next ( ) ; 
 - Cell cell = container . getColumn ( filterColumn ) ; 
 + Cell cell = searchIter . next ( filterColumn ) ; 
 if ( cell ! = null & & cell . timestamp ( ) > sstableTimestamp ) 
 iterator . remove ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index e7aab37 . . e9eb05a 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 189 , 6 + 189 , 8 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry 
 public abstract void delete ( DeletionTime deletionTime ) ; 
 protected abstract void delete ( RangeTombstone tombstone ) ; 
 
 + public abstract SearchIterator < CellName , Cell > searchIterator ( ) ; 
 + 
 / * * 
 * Purges top - level and range tombstones whose localDeletionTime is older than gcBefore . 
 * @ param gcBefore a timestamp ( in seconds ) before which tombstones should be purged 
 diff - - git a / src / java / org / apache / cassandra / db / filter / NamesQueryFilter . java b / src / java / org / apache / cassandra / db / filter / NamesQueryFilter . java 
 index d6d1332 . . 03e3f12 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / NamesQueryFilter . java 
 + + + b / src / java / org / apache / cassandra / db / filter / NamesQueryFilter . java 
 @ @ - 39 , 6 + 39 , 7 @ @ import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 import org . apache . cassandra . io . util . FileDataInput ; 
 + import org . apache . cassandra . utils . SearchIterator ; 
 
 public class NamesQueryFilter implements IDiskAtomFilter 
 { 
 @ @ - 183 , 13 + 184 , 15 @ @ public class NamesQueryFilter implements IDiskAtomFilter 
 { 
 private final ColumnFamily cf ; 
 private final DecoratedKey key ; 
 - private final Iterator < CellName > iter ; 
 + private final Iterator < CellName > names ; 
 + private final SearchIterator < CellName , Cell > cells ; 
 
 - public ByNameColumnIterator ( Iterator < CellName > iter , ColumnFamily cf , DecoratedKey key ) 
 + public ByNameColumnIterator ( Iterator < CellName > names , ColumnFamily cf , DecoratedKey key ) 
 { 
 - this . iter = iter ; 
 + this . names = names ; 
 this . cf = cf ; 
 this . key = key ; 
 + this . cells = cf . searchIterator ( ) ; 
 } 
 
 public ColumnFamily getColumnFamily ( ) 
 @ @ - 204 , 10 + 207 , 10 @ @ public class NamesQueryFilter implements IDiskAtomFilter 
 
 protected OnDiskAtom computeNext ( ) 
 { 
 - while ( iter . hasNext ( ) ) 
 + while ( names . hasNext ( ) & & cells . hasNext ( ) ) 
 { 
 - CellName current = iter . next ( ) ; 
 - Cell cell = cf . getColumn ( current ) ; 
 + CellName current = names . next ( ) ; 
 + Cell cell = cells . next ( current ) ; 
 if ( cell ! = null ) 
 return cell ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / AbstractRowResolver . java b / src / java / org / apache / cassandra / service / AbstractRowResolver . java 
 index 47a00da . . e27dc00 100644 
 - - - a / src / java / org / apache / cassandra / service / AbstractRowResolver . java 
 + + + b / src / java / org / apache / cassandra / service / AbstractRowResolver . java 
 @ @ - 18 , 9 + 18 , 10 @ @ 
 package org . apache . cassandra . service ; 
 
 import java . nio . ByteBuffer ; 
 - import java . util . Set ; 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 
 - import org . cliffc . high _ scale _ lib . NonBlockingHashSet ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 34 , 7 + 35 , 7 @ @ public abstract class AbstractRowResolver implements IResponseResolver < ReadRespo 
 protected static final Logger logger = LoggerFactory . getLogger ( AbstractRowResolver . class ) ; 
 
 protected final String keyspaceName ; 
 - protected final Set < MessageIn < ReadResponse > > replies = new NonBlockingHashSet < MessageIn < ReadResponse > > ( ) ; 
 + protected final List < MessageIn < ReadResponse > > replies = Collections . synchronizedList ( new ArrayList < MessageIn < ReadResponse > > ( ) ) ; 
 protected final DecoratedKey key ; 
 
 public AbstractRowResolver ( ByteBuffer key , String keyspaceName ) 
 diff - - git a / src / java / org / apache / cassandra / utils / SearchIterator . java b / src / java / org / apache / cassandra / utils / SearchIterator . java 
 new file mode 100644 
 index 0000000 . . 004b02a 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / SearchIterator . java 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + public interface SearchIterator < K , V > 
 + { 
 + 
 + public boolean hasNext ( ) ; 
 + public V next ( K key ) ; 
 + 
 + } 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java b / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java 
 new file mode 100644 
 index 0000000 . . 7a83238 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java 
 @ @ - 0 , 0 + 1 , 67 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . utils . btree ; 
 + 
 + import java . util . Comparator ; 
 + 
 + import org . apache . cassandra . utils . SearchIterator ; 
 + 
 + import static org . apache . cassandra . utils . btree . BTree . getKeyEnd ; 
 + 
 + public class BTreeSearchIterator < CK , K extends CK , V > extends Path implements SearchIterator < K , V > 
 + { 
 + 
 + final Comparator < CK > comparator ; 
 + public BTreeSearchIterator ( Object [ ] btree , Comparator < CK > comparator ) 
 + { 
 + init ( btree ) ; 
 + this . comparator = comparator ; 
 + } 
 + 
 + public V next ( K target ) 
 + { 
 + while ( depth > 0 ) 
 + { 
 + byte successorParentDepth = findSuccessorParentDepth ( ) ; 
 + if ( successorParentDepth < 0 ) 
 + break ; / / we ' re in last section of tree , so can only search down 
 + int successorParentIndex = indexes [ successorParentDepth ] + 1 ; 
 + Object [ ] successParentNode = path [ successorParentDepth ] ; 
 + Object successorParentKey = successParentNode [ successorParentIndex ] ; 
 + int c = BTree . compare ( comparator , target , successorParentKey ) ; 
 + if ( c < 0 ) 
 + break ; 
 + if ( c = = 0 ) 
 + { 
 + depth = successorParentDepth ; 
 + indexes [ successorParentDepth ] + + ; 
 + return ( V ) successorParentKey ; 
 + } 
 + depth = successorParentDepth ; 
 + indexes [ successorParentDepth ] + + ; 
 + } 
 + if ( find ( comparator , target , Op . CEIL , true ) ) 
 + return ( V ) currentKey ( ) ; 
 + return null ; 
 + } 
 + 
 + public boolean hasNext ( ) 
 + { 
 + return depth ! = 0 | | indexes [ 0 ] ! = getKeyEnd ( path [ 0 ] ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / Cursor . java b / src / java / org / apache / cassandra / utils / btree / Cursor . java 
 index bc88442 . . 132a776 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / Cursor . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / Cursor . java 
 @ @ - 93 , 7 + 93 , 7 @ @ public final class Cursor < V > extends Path implements Iterator < V > 
 
 private void _ reset ( Object [ ] btree , Comparator < V > comparator , Object lowerBound , boolean inclusiveLowerBound , Object upperBound , boolean inclusiveUpperBound , boolean forwards ) 
 { 
 - ensureDepth ( btree ) ; 
 + init ( btree ) ; 
 if ( lowerBound = = null ) 
 lowerBound = NEGATIVE _ INFINITY ; 
 if ( upperBound = = null ) 
 @ @ - 101 , 16 + 101 , 16 @ @ public final class Cursor < V > extends Path implements Iterator < V > 
 
 this . forwards = forwards ; 
 
 - Path findLast = new Path ( this . path . length ) ; 
 + Path findLast = new Path ( this . path . length , btree ) ; 
 if ( forwards ) 
 { 
 - findLast . find ( btree , comparator , upperBound , inclusiveUpperBound ? Op . HIGHER : Op . CEIL , true ) ; 
 - find ( btree , comparator , lowerBound , inclusiveLowerBound ? Op . CEIL : Op . HIGHER , true ) ; 
 + findLast . find ( comparator , upperBound , inclusiveUpperBound ? Op . HIGHER : Op . CEIL , true ) ; 
 + find ( comparator , lowerBound , inclusiveLowerBound ? Op . CEIL : Op . HIGHER , true ) ; 
 } 
 else 
 { 
 - findLast . find ( btree , comparator , lowerBound , inclusiveLowerBound ? Op . LOWER : Op . FLOOR , false ) ; 
 - find ( btree , comparator , upperBound , inclusiveUpperBound ? Op . FLOOR : Op . LOWER , false ) ; 
 + findLast . find ( comparator , lowerBound , inclusiveLowerBound ? Op . LOWER : Op . FLOOR , false ) ; 
 + find ( comparator , upperBound , inclusiveUpperBound ? Op . FLOOR : Op . LOWER , false ) ; 
 } 
 int c = this . compareTo ( findLast , forwards ) ; 
 if ( forwards ? c > 0 : c < 0 ) 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / Path . java b / src / java / org / apache / cassandra / utils / btree / Path . java 
 index 148c713 . . 49e2d4b 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / Path . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / Path . java 
 @ @ - 34 , 7 + 34 , 7 @ @ import static org . apache . cassandra . utils . btree . BTree . isLeaf ; 
 * 
 * Path is only intended to be used via Cursor . 
 * / 
 - class Path 
 + public class Path < V > 
 { 
 / / operations corresponding to the ones in NavigableSet 
 static enum Op 
 @ @ - 50 , 16 + 50 , 17 @ @ class Path 
 / / the index within the node of our path at a given depth 
 byte [ ] indexes ; 
 / / current depth . nothing in path [ i ] for i > depth is valid . 
 - byte depth = - 1 ; 
 + byte depth ; 
 
 Path ( ) { } 
 - Path ( int depth ) 
 + Path ( int depth , Object [ ] btree ) 
 { 
 this . path = new Object [ depth ] [ ] ; 
 this . indexes = new byte [ depth ] ; 
 + this . path [ 0 ] = btree ; 
 } 
 
 - void ensureDepth ( Object [ ] btree ) 
 + void init ( Object [ ] btree ) 
 { 
 int depth = BTree . depth ( btree ) ; 
 if ( path = = null | | path . length < depth ) 
 @ @ - 67 , 32 + 68 , 36 @ @ class Path 
 path = new Object [ depth ] [ ] ; 
 indexes = new byte [ depth ] ; 
 } 
 + path [ 0 ] = btree ; 
 } 
 
 / * * 
 * Find the provided key in the tree rooted at node , and store the root to it in the path 
 * 
 - * @ param node the tree to search in 
 * @ param comparator the comparator defining the order on the tree 
 * @ param target the key to search for 
 * @ param mode the type of search to perform 
 * @ param forwards if the path should be setup for forward or backward iteration 
 * @ param < V > 
 * / 
 - < V > void find ( Object [ ] node , Comparator < V > comparator , Object target , Op mode , boolean forwards ) 
 + < V > boolean find ( Comparator < V > comparator , Object target , Op mode , boolean forwards ) 
 { 
 / / TODO : should not require parameter ' forwards ' - consider modifying index to represent both 
 / / child and key position , as opposed to just key position ( which necessitates a different value depending 
 / / on which direction you ' re moving in . Prerequisite for making Path public and using to implement general 
 / / search 
 
 - depth = - 1 ; 
 + Object [ ] node = path [ depth ] ; 
 + int lb = indexes [ depth ] ; 
 + assert lb = = 0 | | forwards ; 
 + pop ( ) ; 
 while ( true ) 
 { 
 int keyEnd = getKeyEnd ( node ) ; 
 
 / / search for the target in the current node 
 - int i = BTree . find ( comparator , target , node , 0 , keyEnd ) ; 
 + int i = BTree . find ( comparator , target , node , lb , keyEnd ) ; 
 + lb = 0 ; 
 if ( i > = 0 ) 
 { 
 / / exact match . transform exclusive bounds into the correct index by moving back or forwards one 
 @ @ - 105 , 7 + 110 , 7 @ @ class Path 
 case LOWER : 
 predecessor ( ) ; 
 } 
 - return ; 
 + return true ; 
 } 
 
 / / traverse into the appropriate child 
 @ @ - 141 , 16 + 146 , 16 @ @ class Path 
 push ( node , i ) ; 
 } 
 
 - return ; 
 + return false ; 
 } 
 } 
 
 - private boolean isRoot ( ) 
 + boolean isRoot ( ) 
 { 
 return depth = = 0 ; 
 } 
 
 - private void pop ( ) 
 + void pop ( ) 
 { 
 depth - - ; 
 } 
 @ @ - 165 , 7 + 170 , 7 @ @ class Path 
 return indexes [ depth ] ; 
 } 
 
 - private void push ( Object [ ] node , int index ) 
 + void push ( Object [ ] node , int index ) 
 { 
 path [ + + depth ] = node ; 
 indexes [ depth ] = ( byte ) index ; 
 @ @ - 176 , 6 + 181 , 21 @ @ class Path 
 indexes [ depth ] = ( byte ) index ; 
 } 
 
 + byte findSuccessorParentDepth ( ) 
 + { 
 + byte depth = this . depth ; 
 + depth - - ; 
 + while ( depth > = 0 ) 
 + { 
 + int ub = indexes [ depth ] + 1 ; 
 + Object [ ] node = path [ depth ] ; 
 + if ( ub < getBranchKeyEnd ( node ) ) 
 + return depth ; 
 + depth - - ; 
 + } 
 + return - 1 ; 
 + } 
 + 
 / / move to the next key in the tree 
 void successor ( ) 
 { 
 diff - - git a / test / long / org / apache / cassandra / utils / LongBTreeTest . java b / test / long / org / apache / cassandra / utils / LongBTreeTest . java 
 index 514d166 . . 498a9c9 100644 
 - - - a / test / long / org / apache / cassandra / utils / LongBTreeTest . java 
 + + + b / test / long / org / apache / cassandra / utils / LongBTreeTest . java 
 @ @ - 20 , 11 + 20 , 21 @ @ package org . apache . cassandra . utils ; 
 
 import java . util . * ; 
 import java . util . concurrent . Callable ; 
 + import java . util . concurrent . CountDownLatch ; 
 import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . ExecutorService ; 
 import java . util . concurrent . Executors ; 
 + import java . util . concurrent . Semaphore ; 
 + import java . util . concurrent . ThreadLocalRandom ; 
 import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . atomic . AtomicLong ; 
 
 + import javax . annotation . Nullable ; 
 + 
 + import com . google . common . base . Function ; 
 + import com . google . common . base . Predicate ; 
 + import com . google . common . collect . Iterables ; 
 + import com . google . common . collect . Iterators ; 
 import com . google . common . util . concurrent . Futures ; 
 import com . google . common . util . concurrent . ListenableFuture ; 
 import com . google . common . util . concurrent . ListenableFutureTask ; 
 @ @ - 37 , 7 + 47 , 9 @ @ import com . yammer . metrics . core . TimerContext ; 
 import com . yammer . metrics . stats . Snapshot ; 
 import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 import org . apache . cassandra . utils . btree . BTree ; 
 + import org . apache . cassandra . utils . btree . BTreeSearchIterator ; 
 import org . apache . cassandra . utils . btree . BTreeSet ; 
 + import org . apache . cassandra . utils . btree . UpdateFunction ; 
 
 / / TODO : should probably lower fan - factor for tests to make them more intensive 
 public class LongBTreeTest 
 @ @ - 103 , 6 + 115 , 51 @ @ public class LongBTreeTest 
 testInsertions ( 10000 , 50 , 10 , 10 , false ) ; 
 } 
 
 + @ Test 
 + public void testSearchIterator ( ) throws InterruptedException 
 + { 
 + int threads = Runtime . getRuntime ( ) . availableProcessors ( ) ; 
 + final CountDownLatch latch = new CountDownLatch ( threads ) ; 
 + final AtomicLong errors = new AtomicLong ( ) ; 
 + final AtomicLong count = new AtomicLong ( ) ; 
 + final int perThreadTrees = 100 ; 
 + final int perTreeSelections = 100 ; 
 + final long totalCount = threads * perThreadTrees * perTreeSelections ; 
 + for ( int t = 0 ; t < threads ; t + + ) 
 + { 
 + MODIFY . execute ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; 
 + for ( int i = 0 ; i < perThreadTrees ; i + + ) 
 + { 
 + Object [ ] tree = randomTree ( 10000 , random ) ; 
 + for ( int j = 0 ; j < perTreeSelections ; j + + ) 
 + { 
 + BTreeSearchIterator < Integer , Integer , Integer > searchIterator = new BTreeSearchIterator < > ( tree , ICMP ) ; 
 + for ( Integer key : randomSelection ( tree , random ) ) 
 + if ( key ! = searchIterator . next ( key ) ) 
 + errors . incrementAndGet ( ) ; 
 + for ( Integer key : randomMix ( tree , random ) ) 
 + if ( key ! = searchIterator . next ( key ) ) 
 + if ( BTree . find ( tree , ICMP , key ) = = key ) 
 + errors . incrementAndGet ( ) ; 
 + count . incrementAndGet ( ) ; 
 + } 
 + } 
 + latch . countDown ( ) ; 
 + } 
 + } ) ; 
 + } 
 + while ( latch . getCount ( ) > 0 ) 
 + { 
 + latch . await ( 10L , TimeUnit . SECONDS ) ; 
 + System . out . println ( String . format ( " % . 0f % % complete % s " , 100 * count . get ( ) / ( double ) totalCount , errors . get ( ) > 0 ? ( " Errors : " + errors . get ( ) ) : " " ) ) ; 
 + assert errors . get ( ) = = 0 ; 
 + } 
 + } 
 + 
 private static void testInsertions ( int totalCount , int perTestCount , int testKeyRatio , int modificationBatchSize , boolean quickEquality ) throws ExecutionException , InterruptedException 
 { 
 int batchesPerTest = perTestCount / modificationBatchSize ; 
 @ @ - 354 , 4 + 411 , 43 @ @ public class LongBTreeTest 
 } ; 
 } 
 
 + private static Object [ ] randomTree ( int maxSize , Random random ) 
 + { 
 + TreeSet < Integer > build = new TreeSet < > ( ) ; 
 + int size = random . nextInt ( maxSize ) ; 
 + for ( int i = 0 ; i < size ; i + + ) 
 + { 
 + build . add ( random . nextInt ( ) ) ; 
 + } 
 + return BTree . build ( build , ICMP , true , UpdateFunction . NoOp . < Integer > instance ( ) ) ; 
 + } 
 + 
 + private static Iterable < Integer > randomSelection ( Object [ ] iter , final Random rnd ) 
 + { 
 + final float proportion = rnd . nextFloat ( ) ; 
 + return Iterables . filter ( new BTreeSet < > ( iter , ICMP ) , new Predicate < Integer > ( ) 
 + { 
 + public boolean apply ( @ Nullable Integer integer ) 
 + { 
 + return rnd . nextFloat ( ) < proportion ; 
 + } 
 + } ) ; 
 + } 
 + 
 + private static Iterable < Integer > randomMix ( Object [ ] iter , final Random rnd ) 
 + { 
 + final float proportion = rnd . nextFloat ( ) ; 
 + return Iterables . transform ( new BTreeSet < > ( iter , ICMP ) , new Function < Integer , Integer > ( ) 
 + { 
 + int last = Integer . MIN _ VALUE ; 
 + 
 + public Integer apply ( Integer v ) 
 + { 
 + if ( rnd . nextFloat ( ) < proportion ) 
 + return last = v ; 
 + return last = ( v - last ) / 2 ; 
 + } 
 + } ) ; 
 + } 
 + 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java b / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java 
 index a1c98f3 . . 33d3599 100644 
 - - - a / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . db . composites . * ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 import org . apache . cassandra . db . marshal . Int32Type ; 
 + import org . apache . cassandra . utils . SearchIterator ; 
 
 public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 { 
 @ @ - 213 , 6 + 214 , 43 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 assertSame ( map . iterator ( ) , map . iterator ( ColumnSlice . ALL _ COLUMNS _ ARRAY ) ) ; 
 } 
 
 + @ Test 
 + public void testSearchIterator ( ) 
 + { 
 + CellNameType type = new SimpleDenseCellNameType ( Int32Type . instance ) ; 
 + ColumnFamily map = ArrayBackedSortedColumns . factory . create ( metadata ( ) , false ) ; 
 + 
 + int [ ] values = new int [ ] { 1 , 2 , 3 , 5 , 9 , 15 , 21 , 22 } ; 
 + 
 + for ( int i = 0 ; i < values . length ; + + i ) 
 + map . addColumn ( new Cell ( type . makeCellName ( values [ i ] ) ) ) ; 
 + 
 + SearchIterator < CellName , Cell > iter = map . searchIterator ( ) ; 
 + for ( int i = 0 ; i < values . length ; i + + ) 
 + assertSame ( values [ i ] , iter . next ( type . makeCellName ( values [ i ] ) ) ) ; 
 + 
 + iter = map . searchIterator ( ) ; 
 + for ( int i = 0 ; i < values . length ; i + = 2 ) 
 + assertSame ( values [ i ] , iter . next ( type . makeCellName ( values [ i ] ) ) ) ; 
 + 
 + iter = map . searchIterator ( ) ; 
 + for ( int i = 0 ; i < values . length ; i + = 4 ) 
 + assertSame ( values [ i ] , iter . next ( type . makeCellName ( values [ i ] ) ) ) ; 
 + 
 + iter = map . searchIterator ( ) ; 
 + for ( int i = 0 ; i < values . length ; i + = 1 ) 
 + { 
 + if ( i % 2 = = 0 ) 
 + { 
 + Cell cell = iter . next ( type . makeCellName ( values [ i ] - 1 ) ) ; 
 + if ( i > 0 & & values [ i - 1 ] = = values [ i ] - 1 ) 
 + assertSame ( values [ i - 1 ] , cell ) ; 
 + else 
 + assertNull ( cell ) ; 
 + } 
 + } 
 + } 
 + 
 private < T > void assertSame ( Iterable < T > c1 , Iterable < T > c2 ) 
 { 
 assertSame ( c1 . iterator ( ) , c2 . iterator ( ) ) ; 
 @ @ - 226 , 6 + 264 , 11 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 fail ( " The collection don ' t have the same size " ) ; 
 } 
 
 + private void assertSame ( int name , Cell cell ) 
 + { 
 + int value = ByteBufferUtil . toInt ( cell . name ( ) . toByteBuffer ( ) ) ; 
 + assert name = = value : " Expected " + name + " but got " + value ; 
 + } 
 private void assertSame ( int [ ] names , Iterator < Cell > iter ) 
 { 
 for ( int name : names )

NEAREST DIFF:
diff - - git a / src / org / apache / cassandra / config / DatabaseDescriptor . java b / src / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 683009c . . 73cf3a6 100644 
 - - - a / src / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 18 , 21 + 18 , 24 @ @ 
 
 package org . apache . cassandra . config ; 
 
 - import java . util . * ; 
 + import java . io . File ; 
 + import java . io . IOException ; 
 + import java . util . ArrayList ; 
 + import java . util . HashMap ; 
 + import java . util . HashSet ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 - import java . io . * ; 
 
 import org . apache . cassandra . db . ColumnFamily ; 
 + import org . apache . cassandra . db . SystemTable ; 
 import org . apache . cassandra . db . Table ; 
 import org . apache . cassandra . db . TypeInfo ; 
 - import org . apache . cassandra . db . DBManager ; 
 - import org . apache . cassandra . db . SystemTable ; 
 - import org . apache . cassandra . db . Table . TableMetadata ; 
 import org . apache . cassandra . utils . FileUtils ; 
 import org . apache . cassandra . utils . XMLUtils ; 
 import org . w3c . dom . Node ; 
 import org . w3c . dom . NodeList ; 
 - import org . apache . cassandra . io . * ; 
 
 
 / * * 
 @ @ - 306 , 6 + 309 , 9 @ @ public class DatabaseDescriptor 
 / * Read the table related stuff from config * / 
 NodeList tables = xmlUtils . getRequestedNodeList ( " / Storage / Tables / Table " ) ; 
 int size = tables . getLength ( ) ; 
 + if ( size = = 0 ) { 
 + throw new UnsupportedOperationException ( " A Table must be configured " ) ; 
 + } 
 for ( int i = 0 ; i < size ; + + i ) 
 { 
 Node table = tables . item ( i ) ; 
 @ @ - 785 , 4 + 791 , 9 @ @ public class DatabaseDescriptor 
 { 
 return tableToCFMetaDataMap _ ; 
 } 
 + 
 + public static String getTableName ( ) 
 + { 
 + return tables _ . get ( 0 ) ; 
 + } 
 } 
 diff - - git a / src / org / apache / cassandra / db / ColumnFamily . java b / src / org / apache / cassandra / db / ColumnFamily . java 
 index 51ac744 . . a2ac3a2 100644 
 - - - a / src / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 288 , 7 + 288 , 7 @ @ public final class ColumnFamily 
 return columns _ . getSortedColumns ( ) ; 
 } 
 
 - Map < String , IColumn > getColumns ( ) 
 + public Map < String , IColumn > getColumns ( ) 
 { 
 return columns _ . getColumns ( ) ; 
 } 
 diff - - git a / src / org / apache / cassandra / db / ColumnFamilyStore . java b / src / org / apache / cassandra / db / ColumnFamilyStore . java 
 index be7c245 . . 28bb3f7 100644 
 - - - a / src / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1384 , 4 + 1384 , 14 @ @ public class ColumnFamilyStore 
 { 
 memtable _ . get ( ) . flushOnRecovery ( ) ; 
 } 
 + 
 + public Object getMemtable ( ) 
 + { 
 + return memtable _ . get ( ) ; 
 + } 
 + 
 + public Set < String > getSSTableFilenames ( ) 
 + { 
 + return Collections . unmodifiableSet ( ssTables _ ) ; 
 + } 
 } 
 diff - - git a / src / org / apache / cassandra / db / Memtable . java b / src / org / apache / cassandra / db / Memtable . java 
 index 2bdad37 . . 567b829 100644 
 - - - a / src / org / apache / cassandra / db / Memtable . java 
 + + + b / src / org / apache / cassandra / db / Memtable . java 
 @ @ - 26 , 6 + 26 , 8 @ @ import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 import java . util . Set ; 
 + import java . util . Iterator ; 
 + import java . util . PriorityQueue ; 
 import java . util . concurrent . Callable ; 
 import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . ExecutorService ; 
 @ @ - 45 , 6 + 47 , 7 @ @ import org . apache . cassandra . io . DataOutputBuffer ; 
 import org . apache . cassandra . io . SSTable ; 
 import org . apache . cassandra . utils . BloomFilter ; 
 import org . apache . cassandra . utils . LogUtil ; 
 + import org . apache . cassandra . utils . DestructivePQIterator ; 
 
 / * * 
 * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) 
 @ @ - 419 , 4 + 422 , 9 @ @ public class Memtable implements MemtableMBean , Comparable < Memtable > 
 columnFamilies _ . clear ( ) ; 
 } 
 
 + public Iterator < String > sortedKeyIterator ( ) 
 + { 
 + return new DestructivePQIterator < String > ( new PriorityQueue < String > ( columnFamilies _ . keySet ( ) ) ) ; 
 + } 
 + 
 } 
 diff - - git a / src / org / apache / cassandra / db / MemtableManager . java b / src / org / apache / cassandra / db / MemtableManager . java 
 index 997bbd3 . . 54242d1 100644 
 - - - a / src / org / apache / cassandra / db / MemtableManager . java 
 + + + b / src / org / apache / cassandra / db / MemtableManager . java 
 @ @ - 40 , 7 + 40 , 7 @ @ public class MemtableManager 
 private static Lock lock _ = new ReentrantLock ( ) ; 
 private static Logger logger _ = Logger . getLogger ( MemtableManager . class ) ; 
 private ReentrantReadWriteLock rwLock _ = new ReentrantReadWriteLock ( true ) ; 
 - static MemtableManager instance ( ) 
 + public static MemtableManager instance ( ) 
 { 
 if ( instance _ = = null ) 
 { 
 @ @ - 157 , 7 + 157 , 22 @ @ public class MemtableManager 
 	 } 
 } 
 
 - 
 - 
 + public List < Memtable > getUnflushedMemtables ( String cfName ) 
 + { 
 + rwLock _ . readLock ( ) . lock ( ) ; 
 + try 
 + { 
 + List < Memtable > memtables = history _ . get ( cfName ) ; 
 + if ( memtables ! = null ) 
 + { 
 + return new ArrayList < Memtable > ( memtables ) ; 
 + } 
 + return Arrays . asList ( new Memtable [ 0 ] ) ; 
 + } 
 + finally 
 + { 
 + rwLock _ . readLock ( ) . unlock ( ) ; 
 + } 
 + } 
 
 } 
 diff - - git a / src / org / apache / cassandra / db / Table . java b / src / org / apache / cassandra / db / Table . java 
 index 9c84b42 . . f1b260a 100644 
 - - - a / src / org / apache / cassandra / db / Table . java 
 + + + b / src / org / apache / cassandra / db / Table . java 
 @ @ - 60 , 7 + 60 , 7 @ @ public class Table 
 * is basically the column family name and the ID associated with 
 * this column family . We use this ID in the Commit Log header to 
 * determine when a log file that has been rolled can be deleted . 
 - * / 
 + * / 
 public static class TableMetadata 
 { 
 / * Name of the column family * / 
 @ @ - 454 , 7 + 454 , 7 @ @ public class Table 
 return columnFamilyStores _ ; 
 } 
 
 - ColumnFamilyStore getColumnFamilyStore ( String cfName ) 
 + public ColumnFamilyStore getColumnFamilyStore ( String cfName ) 
 { 
 return columnFamilyStores _ . get ( cfName ) ; 
 } 
 @ @ - 875 , 4 + 875 , 17 @ @ public class Table 
 long timeTaken = System . currentTimeMillis ( ) - start ; 
 dbAnalyticsSource _ . updateWriteStatistics ( timeTaken ) ; 
 } 
 + 
 + public Set < String > getApplicationColumnFamilies ( ) 
 + { 
 + Set < String > set = new HashSet < String > ( ) ; 
 + for ( String cfName : getColumnFamilies ( ) ) 
 + { 
 + if ( DatabaseDescriptor . isApplicationColumnFamily ( cfName ) ) 
 + { 
 + set . add ( cfName ) ; 
 + } 
 + } 
 + return set ; 
 + } 
 } 
 diff - - git a / src / org / apache / cassandra / service / CassandraServer . java b / src / org / apache / cassandra / service / CassandraServer . java 
 index 93b62e7 . . c2d5f66 100644 
 - - - a / src / org / apache / cassandra / service / CassandraServer . java 
 + + + b / src / org / apache / cassandra / service / CassandraServer . java 
 @ @ - 817 , 6 + 817 , 71 @ @ public class CassandraServer extends FacebookBase implements 
 return result ; 
 } 
 
 + public List < String > get _ range ( String tablename , final String startkey ) throws CassandraException 
 + { 
 + logger _ . debug ( " get _ range " ) ; 
 + 
 + / / send request 
 + Message message ; 
 + DataOutputBuffer dob = new DataOutputBuffer ( ) ; 
 + try 
 + { 
 + dob . writeUTF ( startkey ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + logger _ . error ( " unable to write startkey " , e ) ; 
 + throw new RuntimeException ( e ) ; 
 + } 
 + byte [ ] messageBody = Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ; 
 + message = new Message ( StorageService . getLocalStorageEndPoint ( ) , 
 + StorageService . readStage _ , 
 + StorageService . rangeVerbHandler _ , 
 + messageBody ) ; 
 + EndPoint endPoint ; 
 + try 
 + { 
 + endPoint = StorageService . instance ( ) . findSuitableEndPoint ( startkey ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new CassandraException ( " Unable to find endpoint for " + startkey ) ; 
 + } 
 + IAsyncResult iar = MessagingService . getMessagingInstance ( ) . sendRR ( message , endPoint ) ; 
 + 
 + / / read response 
 + / / TODO send more requests if we need to span multiple nodes ( or can we just let client worry about that , 
 + / / since they have to handle multiple requests anyway ? ) 
 + byte [ ] responseBody ; 
 + try 
 + { 
 + responseBody = ( byte [ ] ) iar . get ( 2 * DatabaseDescriptor . getRpcTimeout ( ) , TimeUnit . MILLISECONDS ) [ 0 ] ; 
 + } 
 + catch ( TimeoutException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + DataInputBuffer bufIn = new DataInputBuffer ( ) ; 
 + bufIn . reset ( responseBody , responseBody . length ) ; 
 + 
 + / / turn into List 
 + List < String > keys = new ArrayList < String > ( ) ; 
 + while ( bufIn . getPosition ( ) < responseBody . length ) 
 + { 
 + try 
 + { 
 + keys . add ( bufIn . readUTF ( ) ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + logger _ . error ( " bad utf " , e ) ; 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + return keys ; 
 + } 
 + 
 / * 
 * This method is used to ensure that all keys 
 * prior to the specified key , as dtermined by 
 diff - - git a / src / org / apache / cassandra / service / RangeVerbHandler . java b / src / org / apache / cassandra / service / RangeVerbHandler . java 
 new file mode 100644 
 index 0000000 . . 3587907 
 - - - / dev / null 
 + + + b / src / org / apache / cassandra / service / RangeVerbHandler . java 
 @ @ - 0 , 0 + 1 , 152 @ @ 
 + package org . apache . cassandra . service ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + import java . util . Iterator ; 
 + import java . util . Comparator ; 
 + import java . util . Arrays ; 
 + import java . io . FileNotFoundException ; 
 + import java . io . IOException ; 
 + 
 + import org . apache . commons . collections . IteratorUtils ; 
 + import org . apache . commons . collections . Predicate ; 
 + 
 + import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . net . IVerbHandler ; 
 + import org . apache . cassandra . net . Message ; 
 + import org . apache . cassandra . db . IdentityFilter ; 
 + import org . apache . cassandra . db . ColumnFamily ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . FileStruct ; 
 + import org . apache . cassandra . db . Table ; 
 + import org . apache . cassandra . db . Memtable ; 
 + import org . apache . cassandra . db . MemtableManager ; 
 + import org . apache . cassandra . io . SequenceFile ; 
 + import org . apache . cassandra . io . DataInputBuffer ; 
 + import org . apache . cassandra . io . DataOutputBuffer ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + 
 + public class RangeVerbHandler implements IVerbHandler 
 + { 
 + public static final Comparator < String > STRING _ COMPARATOR = new Comparator < String > ( ) 
 + { 
 + public int compare ( String o1 , String o2 ) 
 + { 
 + return o1 . compareTo ( o2 ) ; 
 + } 
 + } ; 
 + 
 + public void doVerb ( Message message ) 
 + { 
 + byte [ ] bytes = ( byte [ ] ) message . getMessageBody ( ) [ 0 ] ; 
 + final String startkey ; 
 + if ( bytes . length = = 0 ) 
 + { 
 + startkey = " " ; 
 + } 
 + else 
 + { 
 + DataInputBuffer dib = new DataInputBuffer ( ) ; 
 + dib . reset ( bytes , bytes . length ) ; 
 + try 
 + { 
 + startkey = dib . readUTF ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + List < Iterator < String > > iterators = new ArrayList < Iterator < String > > ( ) ; 
 + Table table = Table . open ( DatabaseDescriptor . getTableName ( ) ) ; 
 + for ( String cfName : table . getApplicationColumnFamilies ( ) ) 
 + { 
 + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; 
 + 
 + / / memtable keys : current and historical 
 + Iterator < Memtable > it = ( Iterator < Memtable > ) IteratorUtils . chainedIterator ( 
 + IteratorUtils . singletonIterator ( cfs . getMemtable ( ) ) , 
 + MemtableManager . instance ( ) . getUnflushedMemtables ( cfName ) . iterator ( ) ) ; 
 + while ( it . hasNext ( ) ) 
 + { 
 + iterators . add ( IteratorUtils . filteredIterator ( it . next ( ) . sortedKeyIterator ( ) , new Predicate ( ) 
 + { 
 + public boolean evaluate ( Object key ) 
 + { 
 + return ( ( String ) key ) . compareTo ( startkey ) > = 0 ; 
 + } 
 + } ) ) ; 
 + } 
 + 
 + / / sstables 
 + for ( String filename : cfs . getSSTableFilenames ( ) ) 
 + { 
 + try 
 + { 
 + FileStruct fs = new FileStruct ( SequenceFile . reader ( filename ) ) ; 
 + fs . seekTo ( startkey ) ; 
 + iterators . add ( fs . iterator ( ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + } 
 + 
 + Iterator < String > iter = IteratorUtils . collatedIterator ( STRING _ COMPARATOR , iterators ) ; 
 + List < String > keys = new ArrayList < String > ( ) ; 
 + String last = null , current = null ; 
 + 
 + while ( keys . size ( ) < 1000 ) 
 + { 
 + if ( ! iter . hasNext ( ) ) 
 + { 
 + break ; 
 + } 
 + current = iter . next ( ) ; 
 + if ( ! current . equals ( last ) ) 
 + { 
 + last = current ; 
 + for ( String cfName : table . getApplicationColumnFamilies ( ) ) 
 + { 
 + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; 
 + try 
 + { 
 + ColumnFamily cf = cfs . getColumnFamily ( current , cfName , new IdentityFilter ( ) ) ; 
 + if ( cf ! = null & & cf . getColumns ( ) . size ( ) > 0 ) 
 + { 
 + keys . add ( current ) ; 
 + break ; 
 + } 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + DataOutputBuffer dob = new DataOutputBuffer ( ) ; 
 + for ( String key : keys ) 
 + { 
 + try 
 + { 
 + dob . writeUTF ( key ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + byte [ ] data = Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ; 
 + Message response = message . getReply ( StorageService . getLocalStorageEndPoint ( ) , data ) ; 
 + MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; 
 + } 
 + } 
 diff - - git a / src / org / apache / cassandra / service / StorageService . java b / src / org / apache / cassandra / service / StorageService . java 
 index 409cd5f . . 95de5c6 100644 
 - - - a / src / org / apache / cassandra / service / StorageService . java 
 + + + b / src / org / apache / cassandra / service / StorageService . java 
 @ @ - 138 , 6 + 138 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 public final static String bsMetadataVerbHandler _ = " BS - METADATA - VERB - HANDLER " ; 
 public final static String calloutDeployVerbHandler _ = " CALLOUT - DEPLOY - VERB - HANDLER " ; 
 public final static String touchVerbHandler _ = " TOUCH - VERB - HANDLER " ; 
 + public static String rangeVerbHandler _ = " RANGE - VERB - HANDLER " ; 
 
 public static enum ConsistencyLevel 
 { 
 diff - - git a / src / org / apache / cassandra / utils / DestructivePQIterator . java b / src / org / apache / cassandra / utils / DestructivePQIterator . java 
 new file mode 100644 
 index 0000000 . . 0ed96f8 
 - - - / dev / null 
 + + + b / src / org / apache / cassandra / utils / DestructivePQIterator . java 
 @ @ - 0 , 0 + 1 , 25 @ @ 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . Iterator ; 
 + import java . util . PriorityQueue ; 
 + 
 + public class DestructivePQIterator < T > implements Iterator < T > { 
 + private PriorityQueue < T > pq ; 
 + 
 + public DestructivePQIterator ( PriorityQueue < T > pq ) { 
 + this . pq = pq ; 
 + } 
 + 
 + public boolean hasNext ( ) { 
 + return pq . size ( ) > 0 ; 
 + } 
 + 
 + public T next ( ) { 
 + return pq . poll ( ) ; 
 + } 
 + 
 + public void remove ( ) { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + } 
 + 
 diff - - git a / test / org / apache / cassandra / service / CassandraServerTest . java b / test / org / apache / cassandra / service / CassandraServerTest . java 
 index 07c7dfe . . 762bbb5 100644 
 - - - a / test / org / apache / cassandra / service / CassandraServerTest . java 
 + + + b / test / org / apache / cassandra / service / CassandraServerTest . java 
 @ @ - 9 , 8 + 9 , 50 @ @ import org . testng . annotations . Test ; 
 import java . io . IOException ; 
 import java . util . * ; 
 
 + import com . facebook . thrift . TException ; 
 + 
 public class CassandraServerTest extends ServerTest { 
 / * 
 + TODO fix resetting server so this works 
 + @ Test 
 + public void test _ get _ range _ empty ( ) throws IOException , TException { 
 + CassandraServer server = new CassandraServer ( ) ; 
 + server . start ( ) ; 
 + 
 + assert CollectionUtils . EMPTY _ COLLECTION . equals ( server . get _ range ( DatabaseDescriptor . getTableName ( ) , " " ) ) ; 
 + } 
 + * / 
 + 
 + / * 
 + @ Test 
 + public void test _ get _ range ( ) throws IOException , TException , CassandraException 
 + { 
 + CassandraServer server = new CassandraServer ( ) ; 
 + try 
 + { 
 + server . start ( ) ; 
 + } 
 + catch ( Throwable throwable ) 
 + { 
 + throw new RuntimeException ( throwable ) ; 
 + } 
 + 
 + / / TODO insert some data 
 + try { 
 + String last = null ; 
 + for ( String key : server . get _ range ( DatabaseDescriptor . getTableName ( ) , " key1 " ) ) { 
 + if ( last ! = null ) { 
 + assert last . compareTo ( key ) < 0 ; 
 + } 
 + last = key ; 
 + } 
 + } finally { 
 + server . shutdown ( ) ; 
 + } 
 + } 
 + * / 
 + 
 + / * 
 @ Test 
 public void test _ get _ column ( ) throws Throwable { 
 CassandraServer server = new CassandraServer ( ) ;
