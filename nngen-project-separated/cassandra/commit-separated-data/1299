BLEU SCORE: 0.04513617516969123

TEST MSG: Preserve the names of query parameters in QueryOptions
GENERATED MSG: add WriteResponseHandler combining the important parts of QuorumResponseHandler and WriteResponseResolver .

TEST DIFF (one line): diff - - git a / NEWS . txt b / NEWS . txt <nl> index 198e8e9 . . 49744cf 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 33 , 6 + 33 , 12 @ @ Changed Defaults <nl> - Parallel repairs are the default since 2 . 2 . 0 , run sequential repairs <nl> by providing the ' - seq ' parameter to nodetool repair . <nl> <nl> + New features <nl> + - - - - - - - - - - - - <nl> + - Custom QueryHandlers can retrieve the column specifications for the bound <nl> + variables from QueryOptions by using the hasColumnSpecifications ( ) <nl> + and getColumnSpecifications ( ) methods . <nl> + <nl> <nl> 2 . 2 . 1 <nl> = = = = = <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> index 2fcee5b . . db7fa39 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> @ @ - 22 , 6 + 22 , 8 @ @ import java . util . ArrayList ; <nl> import java . util . Collections ; <nl> import java . util . List ; <nl> <nl> + import org . apache . cassandra . utils . MD5Digest ; <nl> + <nl> import org . apache . cassandra . db . ConsistencyLevel ; <nl> import org . apache . cassandra . service . QueryState ; <nl> <nl> @ @ - 50 , 6 + 52 , 11 @ @ public abstract class BatchQueryOptions <nl> <nl> public abstract QueryOptions forStatement ( int i ) ; <nl> <nl> + public void prepareStatement ( int i , List < ColumnSpecification > boundNames ) <nl> + { <nl> + forStatement ( i ) . prepare ( boundNames ) ; <nl> + } <nl> + <nl> public ConsistencyLevel getConsistency ( ) <nl> { <nl> return wrapped . getConsistency ( ) ; <nl> @ @ - 107 , 5 + 114 , 26 @ @ public abstract class BatchQueryOptions <nl> { <nl> return perStatementOptions . get ( i ) ; <nl> } <nl> + <nl> + @ Override <nl> + public void prepareStatement ( int i , List < ColumnSpecification > boundNames ) <nl> + { <nl> + if ( isPreparedStatement ( i ) ) <nl> + { <nl> + QueryOptions options = perStatementOptions . get ( i ) ; <nl> + options . prepare ( boundNames ) ; <nl> + options = QueryOptions . addColumnSpecifications ( options , boundNames ) ; <nl> + perStatementOptions . set ( i , options ) ; <nl> + } <nl> + else <nl> + { <nl> + super . prepareStatement ( i , boundNames ) ; <nl> + } <nl> + } <nl> + <nl> + private boolean isPreparedStatement ( int i ) <nl> + { <nl> + return getQueryOrIdList ( ) . get ( i ) instanceof MD5Digest ; <nl> + } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / ColumnSpecification . java b / src / java / org / apache / cassandra / cql3 / ColumnSpecification . java <nl> index e12a57e . . e64f5f9 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / ColumnSpecification . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / ColumnSpecification . java <nl> @ @ - 18 , 6 + 18 , 7 @ @ <nl> package org . apache . cassandra . cql3 ; <nl> <nl> import com . google . common . base . Objects ; <nl> + <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . db . marshal . ReversedType ; <nl> <nl> @ @ - 91 , 4 + 92 , 13 @ @ public class ColumnSpecification <nl> { <nl> return Objects . hashCode ( ksName , cfName , name , type ) ; <nl> } <nl> + <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + return Objects . toStringHelper ( this ) <nl> + . add ( " name " , name ) <nl> + . add ( " type " , type ) <nl> + . toString ( ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryOptions . java b / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> index fb46b9b . . 7fc0997 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> @ @ - 23 , 8 + 23 , 9 @ @ import java . util . Collections ; <nl> import java . util . EnumSet ; <nl> import java . util . List ; <nl> <nl> - import io . netty . buffer . ByteBuf ; <nl> + import com . google . common . collect . ImmutableList ; <nl> <nl> + import io . netty . buffer . ByteBuf ; <nl> import org . apache . cassandra . db . ConsistencyLevel ; <nl> import org . apache . cassandra . service . QueryState ; <nl> import org . apache . cassandra . service . pager . PagingState ; <nl> @ @ - 82 , 10 + 83 , 43 @ @ public abstract class QueryOptions <nl> return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L ) , 0 ) ; <nl> } <nl> <nl> + public static QueryOptions addColumnSpecifications ( QueryOptions options , List < ColumnSpecification > columnSpecs ) <nl> + { <nl> + return new OptionsWithColumnSpecifications ( options , columnSpecs ) ; <nl> + } <nl> + <nl> public abstract ConsistencyLevel getConsistency ( ) ; <nl> public abstract List < ByteBuffer > getValues ( ) ; <nl> public abstract boolean skipMetadata ( ) ; <nl> <nl> + / * * <nl> + * Tells whether or not this < code > QueryOptions < / code > contains the column specifications for the bound variables . <nl> + * < p > The column specifications will be present only for prepared statements . < / p > <nl> + * @ return < code > true < / code > this < code > QueryOptions < / code > contains the column specifications for the bound <nl> + * variables , < code > false < / code > otherwise . <nl> + * / <nl> + public boolean hasColumnSpecifications ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the column specifications for the bound variables ( < i > optional operation < / i > ) . <nl> + * <nl> + * < p > The column specifications will be present only for prepared statements . < / p > <nl> + * <nl> + * < p > Invoke the { @ link hasColumnSpecifications } method before invoking this method in order to ensure that this <nl> + * < code > QueryOptions < / code > contains the column specifications . < / p > <nl> + * <nl> + * @ return the option names <nl> + * @ throws UnsupportedOperationException If this < code > QueryOptions < / code > does not contains the column <nl> + * specifications . <nl> + * / <nl> + public ImmutableList < ColumnSpecification > getColumnSpecifications ( ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> / * * The pageSize for this query . Will be < = 0 if not relevant for the query . * / <nl> public int getPageSize ( ) <nl> { <nl> @ @ - 169 , 7 + 203 , 7 @ @ public abstract class QueryOptions <nl> } <nl> } <nl> <nl> - static abstract class QueryOptionsWrapper extends QueryOptions <nl> + static class QueryOptionsWrapper extends QueryOptions <nl> { <nl> protected final QueryOptions wrapped ; <nl> <nl> @ @ - 178 , 6 + 212 , 11 @ @ public abstract class QueryOptions <nl> this . wrapped = wrapped ; <nl> } <nl> <nl> + public List < ByteBuffer > getValues ( ) <nl> + { <nl> + return this . wrapped . getValues ( ) ; <nl> + } <nl> + <nl> public ConsistencyLevel getConsistency ( ) <nl> { <nl> return wrapped . getConsistency ( ) ; <nl> @ @ - 206 , 6 + 245 , 32 @ @ public abstract class QueryOptions <nl> } <nl> } <nl> <nl> + / * * <nl> + * < code > QueryOptions < / code > decorator that provides access to the column specifications . <nl> + * / <nl> + static class OptionsWithColumnSpecifications extends QueryOptionsWrapper <nl> + { <nl> + private final ImmutableList < ColumnSpecification > columnSpecs ; <nl> + <nl> + OptionsWithColumnSpecifications ( QueryOptions wrapped , List < ColumnSpecification > columnSpecs ) <nl> + { <nl> + super ( wrapped ) ; <nl> + this . columnSpecs = ImmutableList . copyOf ( columnSpecs ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasColumnSpecifications ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> + @ Override <nl> + public ImmutableList < ColumnSpecification > getColumnSpecifications ( ) <nl> + { <nl> + return columnSpecs ; <nl> + } <nl> + } <nl> + <nl> static class OptionsWithNames extends QueryOptionsWrapper <nl> { <nl> private final List < String > names ; <nl> @ @ - 238 , 6 + 303 , 7 @ @ public abstract class QueryOptions <nl> return this ; <nl> } <nl> <nl> + @ Override <nl> public List < ByteBuffer > getValues ( ) <nl> { <nl> assert orderedValues ! = null ; / / We should have called prepare first ! <nl> diff - - git a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> index 2db380b . . d86bb1a 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> + + + b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> @ @ - 208 , 7 + 208 , 7 @ @ public class BatchMessage extends Message . Request <nl> for ( int i = 0 ; i < prepared . size ( ) ; i + + ) <nl> { <nl> ParsedStatement . Prepared p = prepared . get ( i ) ; <nl> - batchOptions . forStatement ( i ) . prepare ( p . boundNames ) ; <nl> + batchOptions . prepareStatement ( i , p . boundNames ) ; <nl> <nl> if ( ! ( p . statement instanceof ModificationStatement ) ) <nl> throw new InvalidRequestException ( " Invalid statement in batch : only UPDATE , INSERT and DELETE statements are allowed . " ) ; <nl> diff - - git a / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java b / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java <nl> index 718595c . . 11a227c 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java <nl> + + + b / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java <nl> @ @ - 136 , 7 + 136 , 10 @ @ public class ExecuteMessage extends Message . Request <nl> Tracing . instance . begin ( " Execute CQL3 prepared query " , state . getClientAddress ( ) , builder . build ( ) ) ; <nl> } <nl> <nl> - Message . Response response = handler . processPrepared ( statement , state , options , getCustomPayload ( ) ) ; <nl> + / / Some custom QueryHandlers are interested by the bound names . We provide them this information <nl> + / / by wrapping the QueryOptions . <nl> + QueryOptions queryOptions = QueryOptions . addColumnSpecifications ( options , prepared . boundNames ) ; <nl> + Message . Response response = handler . processPrepared ( statement , state , queryOptions , getCustomPayload ( ) ) ; <nl> if ( options . skipMetadata ( ) & & response instanceof ResultMessage . Rows ) <nl> ( ( ResultMessage . Rows ) response ) . result . metadata . setSkipMetadata ( ) ; <nl>
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 201863a . . 9160630 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 41 , 7 + 41 , 8 @ @ <nl> interfaces ( CASSANDRA - 546 ) <nl> * stress . py benchmarking tool improvements ( several tickets ) <nl> * optimized replica placement code ( CASSANDRA - 525 ) <nl> - * faster log replay on restart ( CASSANDRA - 539 , - 540 ) <nl> + * faster log replay on restart ( CASSANDRA - 539 , CASSANDRA - 540 ) <nl> + * optimized local - node writes ( CASSANDRA - 558 ) <nl> <nl> <nl> 0 . 4 . 2 <nl> diff - - git a / src / java / org / apache / cassandra / db / HintedHandOffManager . java b / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> index 7cd4662 . . f3a6c66 100644 <nl> - - - a / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> + + + b / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> @ @ - 101 , 7 + 101 , 7 @ @ public class HintedHandOffManager <nl> return instance _ ; <nl> } <nl> <nl> - private static boolean sendMessage ( InetAddress endPoint , String tableName , String key ) throws DigestMismatchException , TimeoutException , IOException , InvalidRequestException <nl> + private static boolean sendMessage ( InetAddress endPoint , String tableName , String key ) throws IOException <nl> { <nl> if ( ! FailureDetector . instance ( ) . isAlive ( endPoint ) ) <nl> { <nl> @ @ - 112 , 10 + 112 , 18 @ @ public class HintedHandOffManager <nl> Row row = table . get ( key ) ; <nl> RowMutation rm = new RowMutation ( tableName , row ) ; <nl> Message message = rm . makeRowMutationMessage ( ) ; <nl> - QuorumResponseHandler < Boolean > quorumResponseHandler = new QuorumResponseHandler < Boolean > ( 1 , new WriteResponseResolver ( ) ) ; <nl> - MessagingService . instance ( ) . sendRR ( message , new InetAddress [ ] { endPoint } , quorumResponseHandler ) ; <nl> + WriteResponseHandler responseHandler = new WriteResponseHandler ( 1 ) ; <nl> + MessagingService . instance ( ) . sendRR ( message , new InetAddress [ ] { endPoint } , responseHandler ) ; <nl> <nl> - return quorumResponseHandler . get ( ) ; <nl> + try <nl> + { <nl> + responseHandler . get ( ) ; <nl> + } <nl> + catch ( TimeoutException e ) <nl> + { <nl> + return false ; <nl> + } <nl> + return true ; <nl> } <nl> <nl> private static void deleteEndPoint ( byte [ ] endpointAddress , String tableName , byte [ ] key , long timestamp ) throws IOException <nl> @ @ - 205 , 7 + 213 , 7 @ @ public class HintedHandOffManager <nl> Collection < IColumn > endpoints = keyColumn . getSubColumns ( ) ; <nl> for ( IColumn hintEndPoint : endpoints ) <nl> { <nl> - if ( Arrays . equals ( hintEndPoint . name ( ) , targetEPBytes ) & & sendMessage ( endPoint , null , keyStr ) ) <nl> + if ( Arrays . equals ( hintEndPoint . name ( ) , targetEPBytes ) & & sendMessage ( endPoint , tableName , keyStr ) ) <nl> { <nl> if ( endpoints . size ( ) = = 1 ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> index 4cd6479 . . aa5f8fd 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . gms . FailureDetector ; <nl> import org . apache . cassandra . service . IResponseResolver ; <nl> import org . apache . cassandra . service . QuorumResponseHandler ; <nl> + import org . apache . cassandra . service . WriteResponseHandler ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> / * * <nl> @ @ - 55 , 9 + 56 , 9 @ @ public abstract class AbstractReplicationStrategy <nl> <nl> public abstract ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) ; <nl> <nl> - public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) <nl> + public WriteResponseHandler getWriteResponseHandler ( int blockFor , int consistency _ level ) <nl> { <nl> - return new QuorumResponseHandler < T > ( blockFor , responseResolver ) ; <nl> + return new WriteResponseHandler ( blockFor ) ; <nl> } <nl> <nl> public ArrayList < InetAddress > getNaturalEndpoints ( Token token ) <nl> diff - - git a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> index f07123b . . 01aae88 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> @ @ - 202 , 17 + 202 , 16 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> * return a DCQRH with a map of all the DC rep facor . <nl> * / <nl> @ Override <nl> - public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) <nl> + public WriteResponseHandler getWriteResponseHandler ( int blockFor , int consistency _ level ) <nl> { <nl> if ( consistency _ level = = ConsistencyLevel . DCQUORUM ) <nl> { <nl> - List < InetAddress > endpoints = getLocalEndPoints ( ) ; <nl> - return new DatacenterQuorumResponseHandler < T > ( locQFactor , responseResolver ) ; <nl> + return new DatacenterQuorumResponseHandler ( locQFactor ) ; <nl> } <nl> else if ( consistency _ level = = ConsistencyLevel . DCQUORUMSYNC ) <nl> { <nl> - return new DatacenterQuorumSyncResponseHandler < T > ( getQuorumRepFactor ( ) , responseResolver ) ; <nl> + return new DatacenterQuorumSyncResponseHandler ( getQuorumRepFactor ( ) ) ; <nl> } <nl> - return super . getResponseHandler ( responseResolver , blockFor , consistency _ level ) ; <nl> + return super . getWriteResponseHandler ( blockFor , consistency _ level ) ; <nl> } <nl> } <nl> \ No newline at end of file <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index b975979 . . cabb375 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 322 , 15 + 322 , 20 @ @ public class MessagingService <nl> * / <nl> public String sendRR ( Message message , InetAddress [ ] to , IAsyncCallback cb ) <nl> { <nl> - String messageId = message . getMessageId ( ) ; <nl> - callbackMap _ . put ( messageId , cb ) ; <nl> + String messageId = message . getMessageId ( ) ; <nl> + addCallback ( cb , messageId ) ; <nl> for ( int i = 0 ; i < to . length ; + + i ) <nl> { <nl> sendOneWay ( message , to [ i ] ) ; <nl> } <nl> return messageId ; <nl> } <nl> - <nl> + <nl> + public void addCallback ( IAsyncCallback cb , String messageId ) <nl> + { <nl> + callbackMap _ . put ( messageId , cb ) ; <nl> + } <nl> + <nl> / * * <nl> * Send a message to a given endpoint . This method specifies a callback <nl> * which is invoked with the actual response . <nl> @ @ - 344 , 7 + 349 , 7 @ @ public class MessagingService <nl> public String sendRR ( Message message , InetAddress to , IAsyncCallback cb ) <nl> { <nl> String messageId = message . getMessageId ( ) ; <nl> - callbackMap _ . put ( messageId , cb ) ; <nl> + addCallback ( cb , messageId ) ; <nl> sendOneWay ( message , to ) ; <nl> return messageId ; <nl> } <nl> @ @ - 369 , 7 + 374 , 7 @ @ public class MessagingService <nl> throw new IllegalArgumentException ( " Number of messages and the number of endpoints need to be same . " ) ; <nl> } <nl> String groupId = GuidGenerator . guid ( ) ; <nl> - callbackMap _ . put ( groupId , cb ) ; <nl> + addCallback ( cb , groupId ) ; <nl> for ( int i = 0 ; i < messages . length ; + + i ) <nl> { <nl> messages [ i ] . setMessageId ( groupId ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / DatacenterQuorumResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterQuorumResponseHandler . java <nl> index 7ab4e62 . . 7ba1541 100644 <nl> - - - a / src / java / org / apache / cassandra / service / DatacenterQuorumResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / DatacenterQuorumResponseHandler . java <nl> @ @ - 16 , 16 + 16 , 16 @ @ import org . apache . cassandra . utils . FBUtilities ; <nl> * provided in the input map . it will block till we recive response from ( DC , n ) <nl> * nodes . <nl> * / <nl> - public class DatacenterQuorumResponseHandler < T > extends QuorumResponseHandler < T > <nl> + public class DatacenterQuorumResponseHandler extends WriteResponseHandler <nl> { <nl> private int blockFor ; <nl> private IEndPointSnitch endpointsnitch ; <nl> private InetAddress localEndpoint ; <nl> <nl> - public DatacenterQuorumResponseHandler ( int blockFor , IResponseResolver < T > responseResolver ) <nl> + public DatacenterQuorumResponseHandler ( int blockFor ) <nl> { <nl> / / Response is been managed by the map so the waitlist size really doesnt matter . <nl> - super ( blockFor , responseResolver ) ; <nl> + super ( blockFor ) ; <nl> this . blockFor = blockFor ; <nl> endpointsnitch = DatabaseDescriptor . getEndPointSnitch ( ) ; <nl> localEndpoint = FBUtilities . getLocalAddress ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / DatacenterQuorumSyncResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterQuorumSyncResponseHandler . java <nl> index ac9c61c . . 20c07de 100644 <nl> - - - a / src / java / org / apache / cassandra / service / DatacenterQuorumSyncResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / DatacenterQuorumSyncResponseHandler . java <nl> @ @ - 15 , 15 + 15 , 15 @ @ import org . apache . cassandra . net . Message ; <nl> * provided in the input map . it will block till we recive response from <nl> * n nodes in each of our data centers . <nl> * / <nl> - public class DatacenterQuorumSyncResponseHandler < T > extends QuorumResponseHandler < T > <nl> + public class DatacenterQuorumSyncResponseHandler extends WriteResponseHandler <nl> { <nl> private final Map < String , Integer > dcResponses = new HashMap < String , Integer > ( ) ; <nl> private final Map < String , Integer > responseCounts ; <nl> <nl> - public DatacenterQuorumSyncResponseHandler ( Map < String , Integer > responseCounts , IResponseResolver < T > responseResolver ) <nl> + public DatacenterQuorumSyncResponseHandler ( Map < String , Integer > responseCounts ) <nl> { <nl> / / Response is been managed by the map so make it 1 for the superclass . <nl> - super ( 1 , responseResolver ) ; <nl> + super ( 1 ) ; <nl> this . responseCounts = responseCounts ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / ReadResponseResolver . java b / src / java / org / apache / cassandra / service / ReadResponseResolver . java <nl> index 2464751 . . 48df440 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ReadResponseResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / ReadResponseResolver . java <nl> @ @ - 47 , 7 + 47 , 7 @ @ import org . apache . log4j . Logger ; <nl> * / <nl> public class ReadResponseResolver implements IResponseResolver < Row > <nl> { <nl> - 	 private static Logger logger _ = Logger . getLogger ( WriteResponseResolver . class ) ; <nl> + 	 private static Logger logger _ = Logger . getLogger ( ReadResponseResolver . class ) ; <nl> <nl> 	 / * <nl> 	 * This method for resolving read data should look at the timestamps of each <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index bd2be67 . . 9e28465 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 19 , 7 + 19 , 6 @ @ package org . apache . cassandra . service ; <nl> <nl> import java . io . IOError ; <nl> import java . io . IOException ; <nl> - import java . io . IOError ; <nl> import java . util . * ; <nl> import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . TimeoutException ; <nl> @ @ - 149 , 53 + 148 , 85 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> } <nl> <nl> - public static void insertBlocking ( RowMutation rm , int consistency _ level ) throws UnavailableException <nl> + public static void insertBlocking ( final RowMutation rm , int consistency _ level ) throws UnavailableException <nl> { <nl> long startTime = System . currentTimeMillis ( ) ; <nl> - Message message ; <nl> - try <nl> - { <nl> - message = rm . makeRowMutationMessage ( ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> try <nl> { <nl> List < InetAddress > naturalEndpoints = StorageService . instance ( ) . getNaturalEndpoints ( rm . key ( ) ) ; <nl> Map < InetAddress , InetAddress > endpointMap = StorageService . instance ( ) . getHintedEndpointMap ( rm . key ( ) , naturalEndpoints ) ; <nl> int blockFor = determineBlockFor ( naturalEndpoints . size ( ) , endpointMap . size ( ) , consistency _ level ) ; <nl> - List < InetAddress > primaryNodes = getUnhintedNodes ( endpointMap ) ; <nl> - if ( primaryNodes . size ( ) < blockFor ) / / guarantee blockFor = W live nodes . <nl> - { <nl> - throw new UnavailableException ( ) ; <nl> - } <nl> - QuorumResponseHandler < Boolean > quorumResponseHandler = StorageService . instance ( ) . getResponseHandler ( new WriteResponseResolver ( ) , blockFor , consistency _ level ) ; <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " insertBlocking writing key " + rm . key ( ) + " to " + message . getMessageId ( ) + " @ [ " + StringUtils . join ( endpointMap . values ( ) , " , " ) + " ] " ) ; <nl> <nl> - / / Get all the targets and stick them in an array <nl> - MessagingService . instance ( ) . sendRR ( message , primaryNodes . toArray ( new InetAddress [ primaryNodes . size ( ) ] ) , quorumResponseHandler ) ; <nl> - try <nl> + / / avoid starting a write we know can ' t achieve the required consistency <nl> + int liveNodes = 0 ; <nl> + for ( Map . Entry < InetAddress , InetAddress > entry : endpointMap . entrySet ( ) ) <nl> { <nl> - if ( ! quorumResponseHandler . get ( ) ) <nl> - throw new UnavailableException ( ) ; <nl> + if ( entry . getKey ( ) . equals ( entry . getValue ( ) ) ) <nl> + { <nl> + liveNodes + + ; <nl> + } <nl> } <nl> - catch ( DigestMismatchException e ) <nl> + if ( liveNodes < blockFor ) <nl> { <nl> - throw new AssertionError ( e ) ; <nl> + throw new UnavailableException ( ) ; <nl> } <nl> - if ( primaryNodes . size ( ) < endpointMap . size ( ) ) / / Do we need to bother with Hinted Handoff ? <nl> + <nl> + / / send out the writes , as in insert ( ) above , but this time with a callback that tracks responses <nl> + final WriteResponseHandler responseHandler = StorageService . instance ( ) . getWriteResponseHandler ( blockFor , consistency _ level ) ; <nl> + Message unhintedMessage = null ; <nl> + for ( Map . Entry < InetAddress , InetAddress > entry : endpointMap . entrySet ( ) ) <nl> { <nl> - for ( Map . Entry < InetAddress , InetAddress > e : endpointMap . entrySet ( ) ) <nl> + InetAddress target = entry . getKey ( ) ; <nl> + InetAddress hintedTarget = entry . getValue ( ) ; <nl> + <nl> + if ( target . equals ( hintedTarget ) ) <nl> { <nl> - if ( ! e . getKey ( ) . equals ( e . getValue ( ) ) ) / / Hinted Handoff to target <nl> + if ( target . equals ( FBUtilities . getLocalAddress ( ) ) ) <nl> + { <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " insert writing local key " + rm . key ( ) ) ; <nl> + Runnable runnable = new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + try <nl> + { <nl> + rm . apply ( ) ; <nl> + responseHandler . localResponse ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new IOError ( e ) ; <nl> + } <nl> + } <nl> + } ; <nl> + StageManager . getStage ( StageManager . mutationStage _ ) . execute ( runnable ) ; <nl> + } <nl> + else <nl> { <nl> - MessagingService . instance ( ) . sendOneWay ( message , e . getValue ( ) ) ; <nl> + if ( unhintedMessage = = null ) <nl> + { <nl> + unhintedMessage = rm . makeRowMutationMessage ( ) ; <nl> + MessagingService . instance ( ) . addCallback ( responseHandler , unhintedMessage . getMessageId ( ) ) ; <nl> + } <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " insert writing key " + rm . key ( ) + " to " + unhintedMessage . getMessageId ( ) + " @ " + target ) ; <nl> + MessagingService . instance ( ) . sendOneWay ( unhintedMessage , target ) ; <nl> } <nl> } <nl> + else <nl> + { <nl> + / / ( hints aren ' t part of the callback since they don ' t count towards consistency until they are on the final destination node ) <nl> + Message hintedMessage = rm . makeRowMutationMessage ( ) ; <nl> + hintedMessage . addHeader ( RowMutation . HINT , target . getAddress ( ) ) ; <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " insert writing key " + rm . key ( ) + " to " + hintedMessage . getMessageId ( ) + " @ " + hintedTarget + " for " + target ) ; <nl> + MessagingService . instance ( ) . sendOneWay ( hintedMessage , hintedTarget ) ; <nl> + } <nl> } <nl> + <nl> + / / wait for writes . throws timeoutexception if necessary <nl> + responseHandler . get ( ) ; <nl> } <nl> catch ( TimeoutException e ) <nl> { <nl> @ @ - 211 , 19 + 242 , 6 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> } <nl> <nl> - private static List < InetAddress > getUnhintedNodes ( Map < InetAddress , InetAddress > endpointMap ) <nl> - { <nl> - List < InetAddress > liveEndPoints = new ArrayList < InetAddress > ( endpointMap . size ( ) ) ; <nl> - for ( Map . Entry < InetAddress , InetAddress > e : endpointMap . entrySet ( ) ) <nl> - { <nl> - if ( e . getKey ( ) . equals ( e . getValue ( ) ) ) <nl> - { <nl> - liveEndPoints . add ( e . getKey ( ) ) ; <nl> - } <nl> - } <nl> - return liveEndPoints ; <nl> - } <nl> - <nl> private static int determineBlockFor ( int naturalTargets , int hintedTargets , int consistency _ level ) <nl> { <nl> assert naturalTargets > = 1 ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index d4beeb8 . . e6b7eed 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 1037 , 9 + 1037 , 9 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> unbootstrap ( finishMoving ) ; <nl> } <nl> <nl> - public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) <nl> + public WriteResponseHandler getWriteResponseHandler ( int blockFor , int consistency _ level ) <nl> { <nl> - return replicationStrategy _ . getResponseHandler ( responseResolver , blockFor , consistency _ level ) ; <nl> + return replicationStrategy _ . getWriteResponseHandler ( blockFor , consistency _ level ) ; <nl> } <nl> <nl> public AbstractReplicationStrategy getReplicationStrategy ( ) <nl> diff - - git a / src / java / org / apache / cassandra / service / WriteResponseHandler . java b / src / java / org / apache / cassandra / service / WriteResponseHandler . java <nl> new file mode 100644 <nl> index 0000000 . . 76c543c <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / service / WriteResponseHandler . java <nl> @ @ - 0 , 0 + 1 , 106 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . service ; <nl> + <nl> + import java . util . List ; <nl> + import java . util . ArrayList ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . TimeoutException ; <nl> + import java . io . IOException ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . net . IAsyncCallback ; <nl> + import org . apache . cassandra . net . Message ; <nl> + import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . utils . SimpleCondition ; <nl> + <nl> + import org . apache . log4j . Logger ; <nl> + <nl> + public class WriteResponseHandler implements IAsyncCallback <nl> + { <nl> + protected static final Logger logger = Logger . getLogger ( WriteResponseHandler . class ) ; <nl> + protected final SimpleCondition condition = new SimpleCondition ( ) ; <nl> + private final int responseCount ; <nl> + protected final List < Message > responses ; <nl> + protected int localResponses ; <nl> + private final long startTime ; <nl> + <nl> + public WriteResponseHandler ( int responseCount ) <nl> + { <nl> + assert 1 < = responseCount & & responseCount < = DatabaseDescriptor . getReplicationFactor ( ) <nl> + : " invalid response count " + responseCount ; <nl> + <nl> + this . responseCount = responseCount ; <nl> + responses = new ArrayList < Message > ( responseCount ) ; <nl> + startTime = System . currentTimeMillis ( ) ; <nl> + } <nl> + <nl> + public void get ( ) throws TimeoutException <nl> + { <nl> + try <nl> + { <nl> + long timeout = System . currentTimeMillis ( ) - startTime + DatabaseDescriptor . getRpcTimeout ( ) ; <nl> + boolean success ; <nl> + try <nl> + { <nl> + success = condition . await ( timeout , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> + catch ( InterruptedException ex ) <nl> + { <nl> + throw new AssertionError ( ex ) ; <nl> + } <nl> + <nl> + if ( ! success ) <nl> + { <nl> + throw new TimeoutException ( " Operation timed out - received only " + responses . size ( ) + localResponses + " responses " ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + for ( Message response : responses ) <nl> + { <nl> + MessagingService . removeRegisteredCallback ( response . getMessageId ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public synchronized void response ( Message message ) <nl> + { <nl> + if ( condition . isSignaled ( ) ) <nl> + return ; <nl> + responses . add ( message ) ; <nl> + maybeSignal ( ) ; <nl> + } <nl> + <nl> + public synchronized void localResponse ( ) <nl> + { <nl> + if ( condition . isSignaled ( ) ) <nl> + return ; <nl> + localResponses + + ; <nl> + maybeSignal ( ) ; <nl> + } <nl> + <nl> + private void maybeSignal ( ) <nl> + { <nl> + if ( responses . size ( ) + localResponses > = responseCount ) <nl> + { <nl> + condition . signal ( ) ; <nl> + } <nl> + } <nl> + } <nl> \ No newline at end of file <nl> diff - - git a / src / java / org / apache / cassandra / service / WriteResponseResolver . java b / src / java / org / apache / cassandra / service / WriteResponseResolver . java <nl> deleted file mode 100644 <nl> index cd96644 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / service / WriteResponseResolver . java <nl> + + + / dev / null <nl> @ @ - 1 , 73 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . service ; <nl> - <nl> - import java . util . List ; <nl> - import java . io . DataInputStream ; <nl> - import java . io . ByteArrayInputStream ; <nl> - import java . io . IOException ; <nl> - <nl> - import org . apache . cassandra . db . WriteResponse ; <nl> - import org . apache . cassandra . net . Message ; <nl> - import org . apache . log4j . Logger ; <nl> - <nl> - public class WriteResponseResolver implements IResponseResolver < Boolean > { <nl> - <nl> - 	 private static Logger logger _ = Logger . getLogger ( WriteResponseResolver . class ) ; <nl> - <nl> - 	 / * <nl> - 	 * The resolve function for the Write looks at all the responses if all the <nl> - 	 * responses returned are false then we have a problem since that means the <nl> - 	 * key was not written to any of the servers we want to notify the client of <nl> - 	 * this so in that case we should return a false saying that the write <nl> - 	 * failed . <nl> - 	 * <nl> - 	 * / <nl> - 	 public Boolean resolve ( List < Message > responses ) throws DigestMismatchException <nl> - 	 { <nl> - 	 	 / / TODO : We need to log error responses here for example <nl> - 	 	 / / if a write fails for a key log that the key could not be replicated <nl> - 	 	 boolean returnValue = false ; <nl> - 	 	 for ( Message response : responses ) { <nl> - WriteResponse writeResponseMessage = null ; <nl> - try <nl> - { <nl> - writeResponseMessage = WriteResponse . serializer ( ) . deserialize ( new DataInputStream ( new ByteArrayInputStream ( response . getMessageBody ( ) ) ) ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - boolean result = writeResponseMessage . isSuccess ( ) ; <nl> - if ( ! result ) { <nl> - 	 	 	 	 if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " Write at " + response . getFrom ( ) <nl> - 	 	 	 	 	 	 + " may have failed for the key " + writeResponseMessage . key ( ) ) ; <nl> - 	 	 	 } <nl> - 	 	 	 returnValue | = result ; <nl> - 	 	 } <nl> - 	 	 return returnValue ; <nl> - 	 } <nl> - <nl> - 	 public boolean isDataPresent ( List < Message > responses ) <nl> - 	 { <nl> - 	 	 return true ; <nl> - 	 } <nl> - 	 <nl> - }

TEST DIFF:
diff - - git a / NEWS . txt b / NEWS . txt 
 index 198e8e9 . . 49744cf 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 33 , 6 + 33 , 12 @ @ Changed Defaults 
 - Parallel repairs are the default since 2 . 2 . 0 , run sequential repairs 
 by providing the ' - seq ' parameter to nodetool repair . 
 
 + New features 
 + - - - - - - - - - - - - 
 + - Custom QueryHandlers can retrieve the column specifications for the bound 
 + variables from QueryOptions by using the hasColumnSpecifications ( ) 
 + and getColumnSpecifications ( ) methods . 
 + 
 
 2 . 2 . 1 
 = = = = = 
 diff - - git a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 index 2fcee5b . . db7fa39 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 @ @ - 22 , 6 + 22 , 8 @ @ import java . util . ArrayList ; 
 import java . util . Collections ; 
 import java . util . List ; 
 
 + import org . apache . cassandra . utils . MD5Digest ; 
 + 
 import org . apache . cassandra . db . ConsistencyLevel ; 
 import org . apache . cassandra . service . QueryState ; 
 
 @ @ - 50 , 6 + 52 , 11 @ @ public abstract class BatchQueryOptions 
 
 public abstract QueryOptions forStatement ( int i ) ; 
 
 + public void prepareStatement ( int i , List < ColumnSpecification > boundNames ) 
 + { 
 + forStatement ( i ) . prepare ( boundNames ) ; 
 + } 
 + 
 public ConsistencyLevel getConsistency ( ) 
 { 
 return wrapped . getConsistency ( ) ; 
 @ @ - 107 , 5 + 114 , 26 @ @ public abstract class BatchQueryOptions 
 { 
 return perStatementOptions . get ( i ) ; 
 } 
 + 
 + @ Override 
 + public void prepareStatement ( int i , List < ColumnSpecification > boundNames ) 
 + { 
 + if ( isPreparedStatement ( i ) ) 
 + { 
 + QueryOptions options = perStatementOptions . get ( i ) ; 
 + options . prepare ( boundNames ) ; 
 + options = QueryOptions . addColumnSpecifications ( options , boundNames ) ; 
 + perStatementOptions . set ( i , options ) ; 
 + } 
 + else 
 + { 
 + super . prepareStatement ( i , boundNames ) ; 
 + } 
 + } 
 + 
 + private boolean isPreparedStatement ( int i ) 
 + { 
 + return getQueryOrIdList ( ) . get ( i ) instanceof MD5Digest ; 
 + } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / ColumnSpecification . java b / src / java / org / apache / cassandra / cql3 / ColumnSpecification . java 
 index e12a57e . . e64f5f9 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / ColumnSpecification . java 
 + + + b / src / java / org / apache / cassandra / cql3 / ColumnSpecification . java 
 @ @ - 18 , 6 + 18 , 7 @ @ 
 package org . apache . cassandra . cql3 ; 
 
 import com . google . common . base . Objects ; 
 + 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . db . marshal . ReversedType ; 
 
 @ @ - 91 , 4 + 92 , 13 @ @ public class ColumnSpecification 
 { 
 return Objects . hashCode ( ksName , cfName , name , type ) ; 
 } 
 + 
 + @ Override 
 + public String toString ( ) 
 + { 
 + return Objects . toStringHelper ( this ) 
 + . add ( " name " , name ) 
 + . add ( " type " , type ) 
 + . toString ( ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryOptions . java b / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 index fb46b9b . . 7fc0997 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 @ @ - 23 , 8 + 23 , 9 @ @ import java . util . Collections ; 
 import java . util . EnumSet ; 
 import java . util . List ; 
 
 - import io . netty . buffer . ByteBuf ; 
 + import com . google . common . collect . ImmutableList ; 
 
 + import io . netty . buffer . ByteBuf ; 
 import org . apache . cassandra . db . ConsistencyLevel ; 
 import org . apache . cassandra . service . QueryState ; 
 import org . apache . cassandra . service . pager . PagingState ; 
 @ @ - 82 , 10 + 83 , 43 @ @ public abstract class QueryOptions 
 return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L ) , 0 ) ; 
 } 
 
 + public static QueryOptions addColumnSpecifications ( QueryOptions options , List < ColumnSpecification > columnSpecs ) 
 + { 
 + return new OptionsWithColumnSpecifications ( options , columnSpecs ) ; 
 + } 
 + 
 public abstract ConsistencyLevel getConsistency ( ) ; 
 public abstract List < ByteBuffer > getValues ( ) ; 
 public abstract boolean skipMetadata ( ) ; 
 
 + / * * 
 + * Tells whether or not this < code > QueryOptions < / code > contains the column specifications for the bound variables . 
 + * < p > The column specifications will be present only for prepared statements . < / p > 
 + * @ return < code > true < / code > this < code > QueryOptions < / code > contains the column specifications for the bound 
 + * variables , < code > false < / code > otherwise . 
 + * / 
 + public boolean hasColumnSpecifications ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + / * * 
 + * Returns the column specifications for the bound variables ( < i > optional operation < / i > ) . 
 + * 
 + * < p > The column specifications will be present only for prepared statements . < / p > 
 + * 
 + * < p > Invoke the { @ link hasColumnSpecifications } method before invoking this method in order to ensure that this 
 + * < code > QueryOptions < / code > contains the column specifications . < / p > 
 + * 
 + * @ return the option names 
 + * @ throws UnsupportedOperationException If this < code > QueryOptions < / code > does not contains the column 
 + * specifications . 
 + * / 
 + public ImmutableList < ColumnSpecification > getColumnSpecifications ( ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 / * * The pageSize for this query . Will be < = 0 if not relevant for the query . * / 
 public int getPageSize ( ) 
 { 
 @ @ - 169 , 7 + 203 , 7 @ @ public abstract class QueryOptions 
 } 
 } 
 
 - static abstract class QueryOptionsWrapper extends QueryOptions 
 + static class QueryOptionsWrapper extends QueryOptions 
 { 
 protected final QueryOptions wrapped ; 
 
 @ @ - 178 , 6 + 212 , 11 @ @ public abstract class QueryOptions 
 this . wrapped = wrapped ; 
 } 
 
 + public List < ByteBuffer > getValues ( ) 
 + { 
 + return this . wrapped . getValues ( ) ; 
 + } 
 + 
 public ConsistencyLevel getConsistency ( ) 
 { 
 return wrapped . getConsistency ( ) ; 
 @ @ - 206 , 6 + 245 , 32 @ @ public abstract class QueryOptions 
 } 
 } 
 
 + / * * 
 + * < code > QueryOptions < / code > decorator that provides access to the column specifications . 
 + * / 
 + static class OptionsWithColumnSpecifications extends QueryOptionsWrapper 
 + { 
 + private final ImmutableList < ColumnSpecification > columnSpecs ; 
 + 
 + OptionsWithColumnSpecifications ( QueryOptions wrapped , List < ColumnSpecification > columnSpecs ) 
 + { 
 + super ( wrapped ) ; 
 + this . columnSpecs = ImmutableList . copyOf ( columnSpecs ) ; 
 + } 
 + 
 + @ Override 
 + public boolean hasColumnSpecifications ( ) 
 + { 
 + return true ; 
 + } 
 + 
 + @ Override 
 + public ImmutableList < ColumnSpecification > getColumnSpecifications ( ) 
 + { 
 + return columnSpecs ; 
 + } 
 + } 
 + 
 static class OptionsWithNames extends QueryOptionsWrapper 
 { 
 private final List < String > names ; 
 @ @ - 238 , 6 + 303 , 7 @ @ public abstract class QueryOptions 
 return this ; 
 } 
 
 + @ Override 
 public List < ByteBuffer > getValues ( ) 
 { 
 assert orderedValues ! = null ; / / We should have called prepare first ! 
 diff - - git a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 index 2db380b . . d86bb1a 100644 
 - - - a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 + + + b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 @ @ - 208 , 7 + 208 , 7 @ @ public class BatchMessage extends Message . Request 
 for ( int i = 0 ; i < prepared . size ( ) ; i + + ) 
 { 
 ParsedStatement . Prepared p = prepared . get ( i ) ; 
 - batchOptions . forStatement ( i ) . prepare ( p . boundNames ) ; 
 + batchOptions . prepareStatement ( i , p . boundNames ) ; 
 
 if ( ! ( p . statement instanceof ModificationStatement ) ) 
 throw new InvalidRequestException ( " Invalid statement in batch : only UPDATE , INSERT and DELETE statements are allowed . " ) ; 
 diff - - git a / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java b / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java 
 index 718595c . . 11a227c 100644 
 - - - a / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java 
 + + + b / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java 
 @ @ - 136 , 7 + 136 , 10 @ @ public class ExecuteMessage extends Message . Request 
 Tracing . instance . begin ( " Execute CQL3 prepared query " , state . getClientAddress ( ) , builder . build ( ) ) ; 
 } 
 
 - Message . Response response = handler . processPrepared ( statement , state , options , getCustomPayload ( ) ) ; 
 + / / Some custom QueryHandlers are interested by the bound names . We provide them this information 
 + / / by wrapping the QueryOptions . 
 + QueryOptions queryOptions = QueryOptions . addColumnSpecifications ( options , prepared . boundNames ) ; 
 + Message . Response response = handler . processPrepared ( statement , state , queryOptions , getCustomPayload ( ) ) ; 
 if ( options . skipMetadata ( ) & & response instanceof ResultMessage . Rows ) 
 ( ( ResultMessage . Rows ) response ) . result . metadata . setSkipMetadata ( ) ; 


NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 201863a . . 9160630 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 41 , 7 + 41 , 8 @ @ 
 interfaces ( CASSANDRA - 546 ) 
 * stress . py benchmarking tool improvements ( several tickets ) 
 * optimized replica placement code ( CASSANDRA - 525 ) 
 - * faster log replay on restart ( CASSANDRA - 539 , - 540 ) 
 + * faster log replay on restart ( CASSANDRA - 539 , CASSANDRA - 540 ) 
 + * optimized local - node writes ( CASSANDRA - 558 ) 
 
 
 0 . 4 . 2 
 diff - - git a / src / java / org / apache / cassandra / db / HintedHandOffManager . java b / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 index 7cd4662 . . f3a6c66 100644 
 - - - a / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 + + + b / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 @ @ - 101 , 7 + 101 , 7 @ @ public class HintedHandOffManager 
 return instance _ ; 
 } 
 
 - private static boolean sendMessage ( InetAddress endPoint , String tableName , String key ) throws DigestMismatchException , TimeoutException , IOException , InvalidRequestException 
 + private static boolean sendMessage ( InetAddress endPoint , String tableName , String key ) throws IOException 
 { 
 if ( ! FailureDetector . instance ( ) . isAlive ( endPoint ) ) 
 { 
 @ @ - 112 , 10 + 112 , 18 @ @ public class HintedHandOffManager 
 Row row = table . get ( key ) ; 
 RowMutation rm = new RowMutation ( tableName , row ) ; 
 Message message = rm . makeRowMutationMessage ( ) ; 
 - QuorumResponseHandler < Boolean > quorumResponseHandler = new QuorumResponseHandler < Boolean > ( 1 , new WriteResponseResolver ( ) ) ; 
 - MessagingService . instance ( ) . sendRR ( message , new InetAddress [ ] { endPoint } , quorumResponseHandler ) ; 
 + WriteResponseHandler responseHandler = new WriteResponseHandler ( 1 ) ; 
 + MessagingService . instance ( ) . sendRR ( message , new InetAddress [ ] { endPoint } , responseHandler ) ; 
 
 - return quorumResponseHandler . get ( ) ; 
 + try 
 + { 
 + responseHandler . get ( ) ; 
 + } 
 + catch ( TimeoutException e ) 
 + { 
 + return false ; 
 + } 
 + return true ; 
 } 
 
 private static void deleteEndPoint ( byte [ ] endpointAddress , String tableName , byte [ ] key , long timestamp ) throws IOException 
 @ @ - 205 , 7 + 213 , 7 @ @ public class HintedHandOffManager 
 Collection < IColumn > endpoints = keyColumn . getSubColumns ( ) ; 
 for ( IColumn hintEndPoint : endpoints ) 
 { 
 - if ( Arrays . equals ( hintEndPoint . name ( ) , targetEPBytes ) & & sendMessage ( endPoint , null , keyStr ) ) 
 + if ( Arrays . equals ( hintEndPoint . name ( ) , targetEPBytes ) & & sendMessage ( endPoint , tableName , keyStr ) ) 
 { 
 if ( endpoints . size ( ) = = 1 ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 index 4cd6479 . . aa5f8fd 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . gms . FailureDetector ; 
 import org . apache . cassandra . service . IResponseResolver ; 
 import org . apache . cassandra . service . QuorumResponseHandler ; 
 + import org . apache . cassandra . service . WriteResponseHandler ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 / * * 
 @ @ - 55 , 9 + 56 , 9 @ @ public abstract class AbstractReplicationStrategy 
 
 public abstract ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) ; 
 
 - public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) 
 + public WriteResponseHandler getWriteResponseHandler ( int blockFor , int consistency _ level ) 
 { 
 - return new QuorumResponseHandler < T > ( blockFor , responseResolver ) ; 
 + return new WriteResponseHandler ( blockFor ) ; 
 } 
 
 public ArrayList < InetAddress > getNaturalEndpoints ( Token token ) 
 diff - - git a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 index f07123b . . 01aae88 100644 
 - - - a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 + + + b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 @ @ - 202 , 17 + 202 , 16 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 * return a DCQRH with a map of all the DC rep facor . 
 * / 
 @ Override 
 - public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) 
 + public WriteResponseHandler getWriteResponseHandler ( int blockFor , int consistency _ level ) 
 { 
 if ( consistency _ level = = ConsistencyLevel . DCQUORUM ) 
 { 
 - List < InetAddress > endpoints = getLocalEndPoints ( ) ; 
 - return new DatacenterQuorumResponseHandler < T > ( locQFactor , responseResolver ) ; 
 + return new DatacenterQuorumResponseHandler ( locQFactor ) ; 
 } 
 else if ( consistency _ level = = ConsistencyLevel . DCQUORUMSYNC ) 
 { 
 - return new DatacenterQuorumSyncResponseHandler < T > ( getQuorumRepFactor ( ) , responseResolver ) ; 
 + return new DatacenterQuorumSyncResponseHandler ( getQuorumRepFactor ( ) ) ; 
 } 
 - return super . getResponseHandler ( responseResolver , blockFor , consistency _ level ) ; 
 + return super . getWriteResponseHandler ( blockFor , consistency _ level ) ; 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index b975979 . . cabb375 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 322 , 15 + 322 , 20 @ @ public class MessagingService 
 * / 
 public String sendRR ( Message message , InetAddress [ ] to , IAsyncCallback cb ) 
 { 
 - String messageId = message . getMessageId ( ) ; 
 - callbackMap _ . put ( messageId , cb ) ; 
 + String messageId = message . getMessageId ( ) ; 
 + addCallback ( cb , messageId ) ; 
 for ( int i = 0 ; i < to . length ; + + i ) 
 { 
 sendOneWay ( message , to [ i ] ) ; 
 } 
 return messageId ; 
 } 
 - 
 + 
 + public void addCallback ( IAsyncCallback cb , String messageId ) 
 + { 
 + callbackMap _ . put ( messageId , cb ) ; 
 + } 
 + 
 / * * 
 * Send a message to a given endpoint . This method specifies a callback 
 * which is invoked with the actual response . 
 @ @ - 344 , 7 + 349 , 7 @ @ public class MessagingService 
 public String sendRR ( Message message , InetAddress to , IAsyncCallback cb ) 
 { 
 String messageId = message . getMessageId ( ) ; 
 - callbackMap _ . put ( messageId , cb ) ; 
 + addCallback ( cb , messageId ) ; 
 sendOneWay ( message , to ) ; 
 return messageId ; 
 } 
 @ @ - 369 , 7 + 374 , 7 @ @ public class MessagingService 
 throw new IllegalArgumentException ( " Number of messages and the number of endpoints need to be same . " ) ; 
 } 
 String groupId = GuidGenerator . guid ( ) ; 
 - callbackMap _ . put ( groupId , cb ) ; 
 + addCallback ( cb , groupId ) ; 
 for ( int i = 0 ; i < messages . length ; + + i ) 
 { 
 messages [ i ] . setMessageId ( groupId ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / DatacenterQuorumResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterQuorumResponseHandler . java 
 index 7ab4e62 . . 7ba1541 100644 
 - - - a / src / java / org / apache / cassandra / service / DatacenterQuorumResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / DatacenterQuorumResponseHandler . java 
 @ @ - 16 , 16 + 16 , 16 @ @ import org . apache . cassandra . utils . FBUtilities ; 
 * provided in the input map . it will block till we recive response from ( DC , n ) 
 * nodes . 
 * / 
 - public class DatacenterQuorumResponseHandler < T > extends QuorumResponseHandler < T > 
 + public class DatacenterQuorumResponseHandler extends WriteResponseHandler 
 { 
 private int blockFor ; 
 private IEndPointSnitch endpointsnitch ; 
 private InetAddress localEndpoint ; 
 
 - public DatacenterQuorumResponseHandler ( int blockFor , IResponseResolver < T > responseResolver ) 
 + public DatacenterQuorumResponseHandler ( int blockFor ) 
 { 
 / / Response is been managed by the map so the waitlist size really doesnt matter . 
 - super ( blockFor , responseResolver ) ; 
 + super ( blockFor ) ; 
 this . blockFor = blockFor ; 
 endpointsnitch = DatabaseDescriptor . getEndPointSnitch ( ) ; 
 localEndpoint = FBUtilities . getLocalAddress ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / DatacenterQuorumSyncResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterQuorumSyncResponseHandler . java 
 index ac9c61c . . 20c07de 100644 
 - - - a / src / java / org / apache / cassandra / service / DatacenterQuorumSyncResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / DatacenterQuorumSyncResponseHandler . java 
 @ @ - 15 , 15 + 15 , 15 @ @ import org . apache . cassandra . net . Message ; 
 * provided in the input map . it will block till we recive response from 
 * n nodes in each of our data centers . 
 * / 
 - public class DatacenterQuorumSyncResponseHandler < T > extends QuorumResponseHandler < T > 
 + public class DatacenterQuorumSyncResponseHandler extends WriteResponseHandler 
 { 
 private final Map < String , Integer > dcResponses = new HashMap < String , Integer > ( ) ; 
 private final Map < String , Integer > responseCounts ; 
 
 - public DatacenterQuorumSyncResponseHandler ( Map < String , Integer > responseCounts , IResponseResolver < T > responseResolver ) 
 + public DatacenterQuorumSyncResponseHandler ( Map < String , Integer > responseCounts ) 
 { 
 / / Response is been managed by the map so make it 1 for the superclass . 
 - super ( 1 , responseResolver ) ; 
 + super ( 1 ) ; 
 this . responseCounts = responseCounts ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / service / ReadResponseResolver . java b / src / java / org / apache / cassandra / service / ReadResponseResolver . java 
 index 2464751 . . 48df440 100644 
 - - - a / src / java / org / apache / cassandra / service / ReadResponseResolver . java 
 + + + b / src / java / org / apache / cassandra / service / ReadResponseResolver . java 
 @ @ - 47 , 7 + 47 , 7 @ @ import org . apache . log4j . Logger ; 
 * / 
 public class ReadResponseResolver implements IResponseResolver < Row > 
 { 
 - 	 private static Logger logger _ = Logger . getLogger ( WriteResponseResolver . class ) ; 
 + 	 private static Logger logger _ = Logger . getLogger ( ReadResponseResolver . class ) ; 
 
 	 / * 
 	 * This method for resolving read data should look at the timestamps of each 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index bd2be67 . . 9e28465 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 19 , 7 + 19 , 6 @ @ package org . apache . cassandra . service ; 
 
 import java . io . IOError ; 
 import java . io . IOException ; 
 - import java . io . IOError ; 
 import java . util . * ; 
 import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . TimeoutException ; 
 @ @ - 149 , 53 + 148 , 85 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 } 
 
 - public static void insertBlocking ( RowMutation rm , int consistency _ level ) throws UnavailableException 
 + public static void insertBlocking ( final RowMutation rm , int consistency _ level ) throws UnavailableException 
 { 
 long startTime = System . currentTimeMillis ( ) ; 
 - Message message ; 
 - try 
 - { 
 - message = rm . makeRowMutationMessage ( ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 try 
 { 
 List < InetAddress > naturalEndpoints = StorageService . instance ( ) . getNaturalEndpoints ( rm . key ( ) ) ; 
 Map < InetAddress , InetAddress > endpointMap = StorageService . instance ( ) . getHintedEndpointMap ( rm . key ( ) , naturalEndpoints ) ; 
 int blockFor = determineBlockFor ( naturalEndpoints . size ( ) , endpointMap . size ( ) , consistency _ level ) ; 
 - List < InetAddress > primaryNodes = getUnhintedNodes ( endpointMap ) ; 
 - if ( primaryNodes . size ( ) < blockFor ) / / guarantee blockFor = W live nodes . 
 - { 
 - throw new UnavailableException ( ) ; 
 - } 
 - QuorumResponseHandler < Boolean > quorumResponseHandler = StorageService . instance ( ) . getResponseHandler ( new WriteResponseResolver ( ) , blockFor , consistency _ level ) ; 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " insertBlocking writing key " + rm . key ( ) + " to " + message . getMessageId ( ) + " @ [ " + StringUtils . join ( endpointMap . values ( ) , " , " ) + " ] " ) ; 
 
 - / / Get all the targets and stick them in an array 
 - MessagingService . instance ( ) . sendRR ( message , primaryNodes . toArray ( new InetAddress [ primaryNodes . size ( ) ] ) , quorumResponseHandler ) ; 
 - try 
 + / / avoid starting a write we know can ' t achieve the required consistency 
 + int liveNodes = 0 ; 
 + for ( Map . Entry < InetAddress , InetAddress > entry : endpointMap . entrySet ( ) ) 
 { 
 - if ( ! quorumResponseHandler . get ( ) ) 
 - throw new UnavailableException ( ) ; 
 + if ( entry . getKey ( ) . equals ( entry . getValue ( ) ) ) 
 + { 
 + liveNodes + + ; 
 + } 
 } 
 - catch ( DigestMismatchException e ) 
 + if ( liveNodes < blockFor ) 
 { 
 - throw new AssertionError ( e ) ; 
 + throw new UnavailableException ( ) ; 
 } 
 - if ( primaryNodes . size ( ) < endpointMap . size ( ) ) / / Do we need to bother with Hinted Handoff ? 
 + 
 + / / send out the writes , as in insert ( ) above , but this time with a callback that tracks responses 
 + final WriteResponseHandler responseHandler = StorageService . instance ( ) . getWriteResponseHandler ( blockFor , consistency _ level ) ; 
 + Message unhintedMessage = null ; 
 + for ( Map . Entry < InetAddress , InetAddress > entry : endpointMap . entrySet ( ) ) 
 { 
 - for ( Map . Entry < InetAddress , InetAddress > e : endpointMap . entrySet ( ) ) 
 + InetAddress target = entry . getKey ( ) ; 
 + InetAddress hintedTarget = entry . getValue ( ) ; 
 + 
 + if ( target . equals ( hintedTarget ) ) 
 { 
 - if ( ! e . getKey ( ) . equals ( e . getValue ( ) ) ) / / Hinted Handoff to target 
 + if ( target . equals ( FBUtilities . getLocalAddress ( ) ) ) 
 + { 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " insert writing local key " + rm . key ( ) ) ; 
 + Runnable runnable = new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + try 
 + { 
 + rm . apply ( ) ; 
 + responseHandler . localResponse ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new IOError ( e ) ; 
 + } 
 + } 
 + } ; 
 + StageManager . getStage ( StageManager . mutationStage _ ) . execute ( runnable ) ; 
 + } 
 + else 
 { 
 - MessagingService . instance ( ) . sendOneWay ( message , e . getValue ( ) ) ; 
 + if ( unhintedMessage = = null ) 
 + { 
 + unhintedMessage = rm . makeRowMutationMessage ( ) ; 
 + MessagingService . instance ( ) . addCallback ( responseHandler , unhintedMessage . getMessageId ( ) ) ; 
 + } 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " insert writing key " + rm . key ( ) + " to " + unhintedMessage . getMessageId ( ) + " @ " + target ) ; 
 + MessagingService . instance ( ) . sendOneWay ( unhintedMessage , target ) ; 
 } 
 } 
 + else 
 + { 
 + / / ( hints aren ' t part of the callback since they don ' t count towards consistency until they are on the final destination node ) 
 + Message hintedMessage = rm . makeRowMutationMessage ( ) ; 
 + hintedMessage . addHeader ( RowMutation . HINT , target . getAddress ( ) ) ; 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " insert writing key " + rm . key ( ) + " to " + hintedMessage . getMessageId ( ) + " @ " + hintedTarget + " for " + target ) ; 
 + MessagingService . instance ( ) . sendOneWay ( hintedMessage , hintedTarget ) ; 
 + } 
 } 
 + 
 + / / wait for writes . throws timeoutexception if necessary 
 + responseHandler . get ( ) ; 
 } 
 catch ( TimeoutException e ) 
 { 
 @ @ - 211 , 19 + 242 , 6 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 } 
 
 - private static List < InetAddress > getUnhintedNodes ( Map < InetAddress , InetAddress > endpointMap ) 
 - { 
 - List < InetAddress > liveEndPoints = new ArrayList < InetAddress > ( endpointMap . size ( ) ) ; 
 - for ( Map . Entry < InetAddress , InetAddress > e : endpointMap . entrySet ( ) ) 
 - { 
 - if ( e . getKey ( ) . equals ( e . getValue ( ) ) ) 
 - { 
 - liveEndPoints . add ( e . getKey ( ) ) ; 
 - } 
 - } 
 - return liveEndPoints ; 
 - } 
 - 
 private static int determineBlockFor ( int naturalTargets , int hintedTargets , int consistency _ level ) 
 { 
 assert naturalTargets > = 1 ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index d4beeb8 . . e6b7eed 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 1037 , 9 + 1037 , 9 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 unbootstrap ( finishMoving ) ; 
 } 
 
 - public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) 
 + public WriteResponseHandler getWriteResponseHandler ( int blockFor , int consistency _ level ) 
 { 
 - return replicationStrategy _ . getResponseHandler ( responseResolver , blockFor , consistency _ level ) ; 
 + return replicationStrategy _ . getWriteResponseHandler ( blockFor , consistency _ level ) ; 
 } 
 
 public AbstractReplicationStrategy getReplicationStrategy ( ) 
 diff - - git a / src / java / org / apache / cassandra / service / WriteResponseHandler . java b / src / java / org / apache / cassandra / service / WriteResponseHandler . java 
 new file mode 100644 
 index 0000000 . . 76c543c 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / service / WriteResponseHandler . java 
 @ @ - 0 , 0 + 1 , 106 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . service ; 
 + 
 + import java . util . List ; 
 + import java . util . ArrayList ; 
 + import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . TimeoutException ; 
 + import java . io . IOException ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . net . IAsyncCallback ; 
 + import org . apache . cassandra . net . Message ; 
 + import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . utils . SimpleCondition ; 
 + 
 + import org . apache . log4j . Logger ; 
 + 
 + public class WriteResponseHandler implements IAsyncCallback 
 + { 
 + protected static final Logger logger = Logger . getLogger ( WriteResponseHandler . class ) ; 
 + protected final SimpleCondition condition = new SimpleCondition ( ) ; 
 + private final int responseCount ; 
 + protected final List < Message > responses ; 
 + protected int localResponses ; 
 + private final long startTime ; 
 + 
 + public WriteResponseHandler ( int responseCount ) 
 + { 
 + assert 1 < = responseCount & & responseCount < = DatabaseDescriptor . getReplicationFactor ( ) 
 + : " invalid response count " + responseCount ; 
 + 
 + this . responseCount = responseCount ; 
 + responses = new ArrayList < Message > ( responseCount ) ; 
 + startTime = System . currentTimeMillis ( ) ; 
 + } 
 + 
 + public void get ( ) throws TimeoutException 
 + { 
 + try 
 + { 
 + long timeout = System . currentTimeMillis ( ) - startTime + DatabaseDescriptor . getRpcTimeout ( ) ; 
 + boolean success ; 
 + try 
 + { 
 + success = condition . await ( timeout , TimeUnit . MILLISECONDS ) ; 
 + } 
 + catch ( InterruptedException ex ) 
 + { 
 + throw new AssertionError ( ex ) ; 
 + } 
 + 
 + if ( ! success ) 
 + { 
 + throw new TimeoutException ( " Operation timed out - received only " + responses . size ( ) + localResponses + " responses " ) ; 
 + } 
 + } 
 + finally 
 + { 
 + for ( Message response : responses ) 
 + { 
 + MessagingService . removeRegisteredCallback ( response . getMessageId ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 + public synchronized void response ( Message message ) 
 + { 
 + if ( condition . isSignaled ( ) ) 
 + return ; 
 + responses . add ( message ) ; 
 + maybeSignal ( ) ; 
 + } 
 + 
 + public synchronized void localResponse ( ) 
 + { 
 + if ( condition . isSignaled ( ) ) 
 + return ; 
 + localResponses + + ; 
 + maybeSignal ( ) ; 
 + } 
 + 
 + private void maybeSignal ( ) 
 + { 
 + if ( responses . size ( ) + localResponses > = responseCount ) 
 + { 
 + condition . signal ( ) ; 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / src / java / org / apache / cassandra / service / WriteResponseResolver . java b / src / java / org / apache / cassandra / service / WriteResponseResolver . java 
 deleted file mode 100644 
 index cd96644 . . 0000000 
 - - - a / src / java / org / apache / cassandra / service / WriteResponseResolver . java 
 + + + / dev / null 
 @ @ - 1 , 73 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . service ; 
 - 
 - import java . util . List ; 
 - import java . io . DataInputStream ; 
 - import java . io . ByteArrayInputStream ; 
 - import java . io . IOException ; 
 - 
 - import org . apache . cassandra . db . WriteResponse ; 
 - import org . apache . cassandra . net . Message ; 
 - import org . apache . log4j . Logger ; 
 - 
 - public class WriteResponseResolver implements IResponseResolver < Boolean > { 
 - 
 - 	 private static Logger logger _ = Logger . getLogger ( WriteResponseResolver . class ) ; 
 - 
 - 	 / * 
 - 	 * The resolve function for the Write looks at all the responses if all the 
 - 	 * responses returned are false then we have a problem since that means the 
 - 	 * key was not written to any of the servers we want to notify the client of 
 - 	 * this so in that case we should return a false saying that the write 
 - 	 * failed . 
 - 	 * 
 - 	 * / 
 - 	 public Boolean resolve ( List < Message > responses ) throws DigestMismatchException 
 - 	 { 
 - 	 	 / / TODO : We need to log error responses here for example 
 - 	 	 / / if a write fails for a key log that the key could not be replicated 
 - 	 	 boolean returnValue = false ; 
 - 	 	 for ( Message response : responses ) { 
 - WriteResponse writeResponseMessage = null ; 
 - try 
 - { 
 - writeResponseMessage = WriteResponse . serializer ( ) . deserialize ( new DataInputStream ( new ByteArrayInputStream ( response . getMessageBody ( ) ) ) ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - boolean result = writeResponseMessage . isSuccess ( ) ; 
 - if ( ! result ) { 
 - 	 	 	 	 if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " Write at " + response . getFrom ( ) 
 - 	 	 	 	 	 	 + " may have failed for the key " + writeResponseMessage . key ( ) ) ; 
 - 	 	 	 } 
 - 	 	 	 returnValue | = result ; 
 - 	 	 } 
 - 	 	 return returnValue ; 
 - 	 } 
 - 
 - 	 public boolean isDataPresent ( List < Message > responses ) 
 - 	 { 
 - 	 	 return true ; 
 - 	 } 
 - 	 
 - }
