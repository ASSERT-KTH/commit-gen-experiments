BLEU SCORE: 0.004526870957721523

TEST MSG: remove unnecessary anonymous class creation and generic parameters from NetworkTopologyStrategy
GENERATED MSG: clean up NTS and remove DSS - > NTS migration since replicas chosen may be different ( see # 1103 ) . patch by jbellis ; reviewed by Stu Hood for CASSANDRA - 1593

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java b / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java <nl> index b0d540c . . fb291b5 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java <nl> @ @ - 81 , 13 + 81 , 12 @ @ public class NetworkTopologyStrategy extends AbstractReplicationStrategy <nl> public List < InetAddress > calculateNaturalEndpoints ( Token searchToken , TokenMetadata tokenMetadata ) <nl> { <nl> / / we want to preserve insertion order so that the first added endpoint becomes primary <nl> - Set < InetAddress > replicas = new LinkedHashSet < InetAddress > ( ) ; <nl> + Set < InetAddress > replicas = new LinkedHashSet < > ( ) ; <nl> / / replicas we have found in each DC <nl> - Map < String , Set < InetAddress > > dcReplicas = new HashMap < String , Set < InetAddress > > ( datacenters . size ( ) ) <nl> - { { <nl> - for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) <nl> - put ( dc . getKey ( ) , new HashSet < InetAddress > ( dc . getValue ( ) ) ) ; <nl> - } } ; <nl> + Map < String , Set < InetAddress > > dcReplicas = new HashMap < > ( datacenters . size ( ) ) ; <nl> + for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) <nl> + dcReplicas . put ( dc . getKey ( ) , new HashSet < > ( dc . getValue ( ) ) ) ; <nl> + <nl> Topology topology = tokenMetadata . getTopology ( ) ; <nl> / / all endpoints in each DC , so we can check when we have exhausted all the members of a DC <nl> Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; <nl> @ @ - 96 , 18 + 95 , 16 @ @ public class NetworkTopologyStrategy extends AbstractReplicationStrategy <nl> assert ! allEndpoints . isEmpty ( ) & & ! racks . isEmpty ( ) : " not aware of any cluster members " ; <nl> <nl> / / tracks the racks we have already placed replicas in <nl> - Map < String , Set < String > > seenRacks = new HashMap < String , Set < String > > ( datacenters . size ( ) ) <nl> - { { <nl> - for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) <nl> - put ( dc . getKey ( ) , new HashSet < String > ( ) ) ; <nl> - } } ; <nl> + Map < String , Set < String > > seenRacks = new HashMap < > ( datacenters . size ( ) ) ; <nl> + for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) <nl> + seenRacks . put ( dc . getKey ( ) , new HashSet < > ( ) ) ; <nl> + <nl> / / tracks the endpoints that we skipped over while looking for unique racks <nl> / / when we relax the rack uniqueness we can append this to the current result so we don ' t have to wind back the iterator <nl> - Map < String , Set < InetAddress > > skippedDcEndpoints = new HashMap < String , Set < InetAddress > > ( datacenters . size ( ) ) <nl> - { { <nl> - for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) <nl> - put ( dc . getKey ( ) , new LinkedHashSet < InetAddress > ( ) ) ; <nl> - } } ; <nl> + Map < String , Set < InetAddress > > skippedDcEndpoints = new HashMap < > ( datacenters . size ( ) ) ; <nl> + for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) <nl> + skippedDcEndpoints . put ( dc . getKey ( ) , new LinkedHashSet < > ( ) ) ; <nl> + <nl> Iterator < Token > tokenIter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , searchToken , false ) ; <nl> while ( tokenIter . hasNext ( ) & & ! hasSufficientReplicas ( dcReplicas , allEndpoints ) ) <nl> {
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / config / KSMetaData . java b / src / java / org / apache / cassandra / config / KSMetaData . java <nl> index 9029e76 . . bf295d1 100644 <nl> - - - a / src / java / org / apache / cassandra / config / KSMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / KSMetaData . java <nl> @ @ - 124 , 7 + 124 , 6 @ @ public final class KSMetaData <nl> public static String convertOldStrategyName ( String name ) <nl> { <nl> return name . replace ( " RackUnawareStrategy " , " SimpleStrategy " ) <nl> - . replace ( " RackAwareStrategy " , " OldNetworkTopologyStrategy " ) <nl> - . replace ( " DatacenterShardStrategy " , " NetworkTopologyStrategy " ) ; <nl> + . replace ( " RackAwareStrategy " , " OldNetworkTopologyStrategy " ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java b / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java <nl> index fb4ba26 . . ec18cd4 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java <nl> @ @ - 69 , 59 + 69 , 51 @ @ public class NetworkTopologyStrategy extends AbstractReplicationStrategy <nl> <nl> public List < InetAddress > calculateNaturalEndpoints ( Token searchToken , TokenMetadata tokenMetadata ) <nl> { <nl> - int totalReplicas = getReplicationFactor ( ) ; <nl> - Map < String , Integer > remainingReplicas = new HashMap < String , Integer > ( datacenters ) ; <nl> - Map < String , Set < String > > dcUsedRacks = new HashMap < String , Set < String > > ( ) ; <nl> - List < InetAddress > endpoints = new ArrayList < InetAddress > ( totalReplicas ) ; <nl> - <nl> - / / first pass : only collect replicas on unique racks <nl> - for ( Iterator < Token > iter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , searchToken ) ; <nl> - endpoints . size ( ) < totalReplicas & & iter . hasNext ( ) ; ) <nl> + List < InetAddress > endpoints = new ArrayList < InetAddress > ( getReplicationFactor ( ) ) ; <nl> + <nl> + for ( Entry < String , Integer > dcEntry : datacenters . entrySet ( ) ) <nl> { <nl> - Token token = iter . next ( ) ; <nl> - InetAddress endpoint = tokenMetadata . getEndpoint ( token ) ; <nl> - String datacenter = snitch . getDatacenter ( endpoint ) ; <nl> - int remaining = remainingReplicas . containsKey ( datacenter ) ? remainingReplicas . get ( datacenter ) : 0 ; <nl> - if ( remaining > 0 ) <nl> + String dcName = dcEntry . getKey ( ) ; <nl> + int dcReplicas = dcEntry . getValue ( ) ; <nl> + <nl> + / / collect endpoints in this DC <nl> + TokenMetadata dcTokens = new TokenMetadata ( ) ; <nl> + for ( Entry < Token , InetAddress > tokenEntry : tokenMetadata . entrySet ( ) ) <nl> { <nl> - Set < String > usedRacks = dcUsedRacks . get ( datacenter ) ; <nl> - if ( usedRacks = = null ) <nl> - { <nl> - usedRacks = new HashSet < String > ( ) ; <nl> - dcUsedRacks . put ( datacenter , usedRacks ) ; <nl> - } <nl> + if ( snitch . getDatacenter ( tokenEntry . getValue ( ) ) . equals ( dcName ) ) <nl> + dcTokens . updateNormalToken ( tokenEntry . getKey ( ) , tokenEntry . getValue ( ) ) ; <nl> + } <nl> + <nl> + List < InetAddress > dcEndpoints = new ArrayList < InetAddress > ( dcReplicas ) ; <nl> + Set < String > racks = new HashSet < String > ( ) ; <nl> + / / first pass : only collect replicas on unique racks <nl> + for ( Iterator < Token > iter = TokenMetadata . ringIterator ( dcTokens . sortedTokens ( ) , searchToken ) ; <nl> + dcEndpoints . size ( ) < dcReplicas & & iter . hasNext ( ) ; ) <nl> + { <nl> + Token token = iter . next ( ) ; <nl> + InetAddress endpoint = dcTokens . getEndpoint ( token ) ; <nl> String rack = snitch . getRack ( endpoint ) ; <nl> - if ( ! usedRacks . contains ( rack ) ) <nl> + if ( ! racks . contains ( rack ) ) <nl> { <nl> - endpoints . add ( endpoint ) ; <nl> - usedRacks . add ( rack ) ; <nl> - remainingReplicas . put ( datacenter , remaining - 1 ) ; <nl> + dcEndpoints . add ( endpoint ) ; <nl> + racks . add ( rack ) ; <nl> } <nl> } <nl> - } <nl> <nl> - / / second pass : if replica count has not been achieved from unique racks , add nodes from the same racks <nl> - for ( Iterator < Token > iter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , searchToken ) ; <nl> - endpoints . size ( ) < totalReplicas & & iter . hasNext ( ) ; ) <nl> - { <nl> - Token token = iter . next ( ) ; <nl> - InetAddress endpoint = tokenMetadata . getEndpoint ( token ) ; <nl> - if ( endpoints . contains ( endpoint ) ) <nl> - continue ; <nl> - <nl> - String datacenter = snitch . getDatacenter ( endpoint ) ; <nl> - int remaining = remainingReplicas . containsKey ( datacenter ) ? remainingReplicas . get ( datacenter ) : 0 ; <nl> - if ( remaining > 0 ) <nl> + / / second pass : if replica count has not been achieved from unique racks , add nodes from duplicate racks <nl> + for ( Iterator < Token > iter = TokenMetadata . ringIterator ( dcTokens . sortedTokens ( ) , searchToken ) ; <nl> + dcEndpoints . size ( ) < dcReplicas & & iter . hasNext ( ) ; ) <nl> { <nl> - endpoints . add ( endpoint ) ; <nl> - remainingReplicas . put ( datacenter , remaining - 1 ) ; <nl> + Token token = iter . next ( ) ; <nl> + InetAddress endpoint = dcTokens . getEndpoint ( token ) ; <nl> + if ( ! dcEndpoints . contains ( endpoint ) ) <nl> + dcEndpoints . add ( endpoint ) ; <nl> } <nl> - } <nl> <nl> - for ( Map . Entry < String , Integer > entry : remainingReplicas . entrySet ( ) ) <nl> - { <nl> - if ( entry . getValue ( ) > 0 ) <nl> - throw new IllegalStateException ( String . format ( " datacenter ( % s ) has no more endpoints , ( % s ) replicas still needed " , entry . getKey ( ) , entry . getValue ( ) ) ) ; <nl> + if ( dcEndpoints . size ( ) < dcReplicas ) <nl> + throw new IllegalStateException ( String . format ( " datacenter ( % s ) has no more endpoints , ( % s ) replicas still needed " , <nl> + dcName , dcReplicas - dcEndpoints . size ( ) ) ) ; <nl> + endpoints . addAll ( dcEndpoints ) ; <nl> } <nl> <nl> return endpoints ; <nl> diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> index 28d6274 . . 35d4b4b 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> @ @ - 287 , 6 + 287 , 11 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> + public Set < Map . Entry < Token , InetAddress > > entrySet ( ) <nl> + { <nl> + return tokenToEndpointMap . entrySet ( ) ; <nl> + } <nl> + <nl> public InetAddress getEndpoint ( Token token ) <nl> { <nl> lock . readLock ( ) . lock ( ) ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java b / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java 
 index b0d540c . . fb291b5 100644 
 - - - a / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java 
 @ @ - 81 , 13 + 81 , 12 @ @ public class NetworkTopologyStrategy extends AbstractReplicationStrategy 
 public List < InetAddress > calculateNaturalEndpoints ( Token searchToken , TokenMetadata tokenMetadata ) 
 { 
 / / we want to preserve insertion order so that the first added endpoint becomes primary 
 - Set < InetAddress > replicas = new LinkedHashSet < InetAddress > ( ) ; 
 + Set < InetAddress > replicas = new LinkedHashSet < > ( ) ; 
 / / replicas we have found in each DC 
 - Map < String , Set < InetAddress > > dcReplicas = new HashMap < String , Set < InetAddress > > ( datacenters . size ( ) ) 
 - { { 
 - for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) 
 - put ( dc . getKey ( ) , new HashSet < InetAddress > ( dc . getValue ( ) ) ) ; 
 - } } ; 
 + Map < String , Set < InetAddress > > dcReplicas = new HashMap < > ( datacenters . size ( ) ) ; 
 + for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) 
 + dcReplicas . put ( dc . getKey ( ) , new HashSet < > ( dc . getValue ( ) ) ) ; 
 + 
 Topology topology = tokenMetadata . getTopology ( ) ; 
 / / all endpoints in each DC , so we can check when we have exhausted all the members of a DC 
 Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; 
 @ @ - 96 , 18 + 95 , 16 @ @ public class NetworkTopologyStrategy extends AbstractReplicationStrategy 
 assert ! allEndpoints . isEmpty ( ) & & ! racks . isEmpty ( ) : " not aware of any cluster members " ; 
 
 / / tracks the racks we have already placed replicas in 
 - Map < String , Set < String > > seenRacks = new HashMap < String , Set < String > > ( datacenters . size ( ) ) 
 - { { 
 - for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) 
 - put ( dc . getKey ( ) , new HashSet < String > ( ) ) ; 
 - } } ; 
 + Map < String , Set < String > > seenRacks = new HashMap < > ( datacenters . size ( ) ) ; 
 + for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) 
 + seenRacks . put ( dc . getKey ( ) , new HashSet < > ( ) ) ; 
 + 
 / / tracks the endpoints that we skipped over while looking for unique racks 
 / / when we relax the rack uniqueness we can append this to the current result so we don ' t have to wind back the iterator 
 - Map < String , Set < InetAddress > > skippedDcEndpoints = new HashMap < String , Set < InetAddress > > ( datacenters . size ( ) ) 
 - { { 
 - for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) 
 - put ( dc . getKey ( ) , new LinkedHashSet < InetAddress > ( ) ) ; 
 - } } ; 
 + Map < String , Set < InetAddress > > skippedDcEndpoints = new HashMap < > ( datacenters . size ( ) ) ; 
 + for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) 
 + skippedDcEndpoints . put ( dc . getKey ( ) , new LinkedHashSet < > ( ) ) ; 
 + 
 Iterator < Token > tokenIter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , searchToken , false ) ; 
 while ( tokenIter . hasNext ( ) & & ! hasSufficientReplicas ( dcReplicas , allEndpoints ) ) 
 {

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / config / KSMetaData . java b / src / java / org / apache / cassandra / config / KSMetaData . java 
 index 9029e76 . . bf295d1 100644 
 - - - a / src / java / org / apache / cassandra / config / KSMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / KSMetaData . java 
 @ @ - 124 , 7 + 124 , 6 @ @ public final class KSMetaData 
 public static String convertOldStrategyName ( String name ) 
 { 
 return name . replace ( " RackUnawareStrategy " , " SimpleStrategy " ) 
 - . replace ( " RackAwareStrategy " , " OldNetworkTopologyStrategy " ) 
 - . replace ( " DatacenterShardStrategy " , " NetworkTopologyStrategy " ) ; 
 + . replace ( " RackAwareStrategy " , " OldNetworkTopologyStrategy " ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java b / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java 
 index fb4ba26 . . ec18cd4 100644 
 - - - a / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / NetworkTopologyStrategy . java 
 @ @ - 69 , 59 + 69 , 51 @ @ public class NetworkTopologyStrategy extends AbstractReplicationStrategy 
 
 public List < InetAddress > calculateNaturalEndpoints ( Token searchToken , TokenMetadata tokenMetadata ) 
 { 
 - int totalReplicas = getReplicationFactor ( ) ; 
 - Map < String , Integer > remainingReplicas = new HashMap < String , Integer > ( datacenters ) ; 
 - Map < String , Set < String > > dcUsedRacks = new HashMap < String , Set < String > > ( ) ; 
 - List < InetAddress > endpoints = new ArrayList < InetAddress > ( totalReplicas ) ; 
 - 
 - / / first pass : only collect replicas on unique racks 
 - for ( Iterator < Token > iter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , searchToken ) ; 
 - endpoints . size ( ) < totalReplicas & & iter . hasNext ( ) ; ) 
 + List < InetAddress > endpoints = new ArrayList < InetAddress > ( getReplicationFactor ( ) ) ; 
 + 
 + for ( Entry < String , Integer > dcEntry : datacenters . entrySet ( ) ) 
 { 
 - Token token = iter . next ( ) ; 
 - InetAddress endpoint = tokenMetadata . getEndpoint ( token ) ; 
 - String datacenter = snitch . getDatacenter ( endpoint ) ; 
 - int remaining = remainingReplicas . containsKey ( datacenter ) ? remainingReplicas . get ( datacenter ) : 0 ; 
 - if ( remaining > 0 ) 
 + String dcName = dcEntry . getKey ( ) ; 
 + int dcReplicas = dcEntry . getValue ( ) ; 
 + 
 + / / collect endpoints in this DC 
 + TokenMetadata dcTokens = new TokenMetadata ( ) ; 
 + for ( Entry < Token , InetAddress > tokenEntry : tokenMetadata . entrySet ( ) ) 
 { 
 - Set < String > usedRacks = dcUsedRacks . get ( datacenter ) ; 
 - if ( usedRacks = = null ) 
 - { 
 - usedRacks = new HashSet < String > ( ) ; 
 - dcUsedRacks . put ( datacenter , usedRacks ) ; 
 - } 
 + if ( snitch . getDatacenter ( tokenEntry . getValue ( ) ) . equals ( dcName ) ) 
 + dcTokens . updateNormalToken ( tokenEntry . getKey ( ) , tokenEntry . getValue ( ) ) ; 
 + } 
 + 
 + List < InetAddress > dcEndpoints = new ArrayList < InetAddress > ( dcReplicas ) ; 
 + Set < String > racks = new HashSet < String > ( ) ; 
 + / / first pass : only collect replicas on unique racks 
 + for ( Iterator < Token > iter = TokenMetadata . ringIterator ( dcTokens . sortedTokens ( ) , searchToken ) ; 
 + dcEndpoints . size ( ) < dcReplicas & & iter . hasNext ( ) ; ) 
 + { 
 + Token token = iter . next ( ) ; 
 + InetAddress endpoint = dcTokens . getEndpoint ( token ) ; 
 String rack = snitch . getRack ( endpoint ) ; 
 - if ( ! usedRacks . contains ( rack ) ) 
 + if ( ! racks . contains ( rack ) ) 
 { 
 - endpoints . add ( endpoint ) ; 
 - usedRacks . add ( rack ) ; 
 - remainingReplicas . put ( datacenter , remaining - 1 ) ; 
 + dcEndpoints . add ( endpoint ) ; 
 + racks . add ( rack ) ; 
 } 
 } 
 - } 
 
 - / / second pass : if replica count has not been achieved from unique racks , add nodes from the same racks 
 - for ( Iterator < Token > iter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , searchToken ) ; 
 - endpoints . size ( ) < totalReplicas & & iter . hasNext ( ) ; ) 
 - { 
 - Token token = iter . next ( ) ; 
 - InetAddress endpoint = tokenMetadata . getEndpoint ( token ) ; 
 - if ( endpoints . contains ( endpoint ) ) 
 - continue ; 
 - 
 - String datacenter = snitch . getDatacenter ( endpoint ) ; 
 - int remaining = remainingReplicas . containsKey ( datacenter ) ? remainingReplicas . get ( datacenter ) : 0 ; 
 - if ( remaining > 0 ) 
 + / / second pass : if replica count has not been achieved from unique racks , add nodes from duplicate racks 
 + for ( Iterator < Token > iter = TokenMetadata . ringIterator ( dcTokens . sortedTokens ( ) , searchToken ) ; 
 + dcEndpoints . size ( ) < dcReplicas & & iter . hasNext ( ) ; ) 
 { 
 - endpoints . add ( endpoint ) ; 
 - remainingReplicas . put ( datacenter , remaining - 1 ) ; 
 + Token token = iter . next ( ) ; 
 + InetAddress endpoint = dcTokens . getEndpoint ( token ) ; 
 + if ( ! dcEndpoints . contains ( endpoint ) ) 
 + dcEndpoints . add ( endpoint ) ; 
 } 
 - } 
 
 - for ( Map . Entry < String , Integer > entry : remainingReplicas . entrySet ( ) ) 
 - { 
 - if ( entry . getValue ( ) > 0 ) 
 - throw new IllegalStateException ( String . format ( " datacenter ( % s ) has no more endpoints , ( % s ) replicas still needed " , entry . getKey ( ) , entry . getValue ( ) ) ) ; 
 + if ( dcEndpoints . size ( ) < dcReplicas ) 
 + throw new IllegalStateException ( String . format ( " datacenter ( % s ) has no more endpoints , ( % s ) replicas still needed " , 
 + dcName , dcReplicas - dcEndpoints . size ( ) ) ) ; 
 + endpoints . addAll ( dcEndpoints ) ; 
 } 
 
 return endpoints ; 
 diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 index 28d6274 . . 35d4b4b 100644 
 - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 @ @ - 287 , 6 + 287 , 11 @ @ public class TokenMetadata 
 } 
 } 
 
 + public Set < Map . Entry < Token , InetAddress > > entrySet ( ) 
 + { 
 + return tokenToEndpointMap . entrySet ( ) ; 
 + } 
 + 
 public InetAddress getEndpoint ( Token token ) 
 { 
 lock . readLock ( ) . lock ( ) ;
