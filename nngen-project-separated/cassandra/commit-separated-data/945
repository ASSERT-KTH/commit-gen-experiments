BLEU SCORE: 0.016074772865287294

TEST MSG: Make value of LIKE relations a Term
GENERATED MSG: Fix issues w / CONTAINS ( KEY ) queries on 2ary indexes

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 0401357 . . cf05d7b 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 6 <nl> + * Support LIKE operator in prepared statements ( CASSANDRA - 11456 ) <nl> * Add a command to see if a Materialized View has finished building ( CASSANDRA - 9967 ) <nl> * Log endpoint and port associated with streaming operation ( CASSANDRA - 8777 ) <nl> * Print sensible units for all log messages ( CASSANDRA - 9692 ) <nl> diff - - git a / src / antlr / Parser . g b / src / antlr / Parser . g <nl> index b4aa235 . . 78a2d0d 100644 <nl> - - - a / src / antlr / Parser . g <nl> + + + b / src / antlr / Parser . g <nl> @ @ - 156 , 45 + 156 , 6 @ @ options { <nl> return filtered ; <nl> } <nl> <nl> - public void buildLIKERelation ( WhereClause . Builder whereClause , ColumnIdentifier . Raw name , String likeValue ) <nl> - { <nl> - Operator operator ; <nl> - int beginIndex = 0 ; <nl> - int endIndex = likeValue . length ( ) - 1 ; <nl> - <nl> - if ( likeValue . charAt ( endIndex ) = = ' \ % ' ) <nl> - { <nl> - if ( likeValue . charAt ( beginIndex ) = = ' \ % ' ) <nl> - { <nl> - operator = Operator . LIKE _ CONTAINS ; <nl> - beginIndex = + 1 ; <nl> - } <nl> - else <nl> - { <nl> - operator = Operator . LIKE _ PREFIX ; <nl> - } <nl> - } <nl> - else if ( likeValue . charAt ( beginIndex ) = = ' \ % ' ) <nl> - { <nl> - operator = Operator . LIKE _ SUFFIX ; <nl> - beginIndex + = 1 ; <nl> - endIndex + = 1 ; <nl> - } <nl> - else <nl> - { <nl> - operator = Operator . LIKE _ MATCHES ; <nl> - endIndex + = 1 ; <nl> - } <nl> - <nl> - if ( endIndex = = 0 | | beginIndex = = endIndex ) <nl> - { <nl> - addRecognitionError ( " LIKE value can ' t be empty . " ) ; <nl> - return ; <nl> - } <nl> - <nl> - String value = likeValue . substring ( beginIndex , endIndex ) ; <nl> - whereClause . add ( new SingleColumnRelation ( name , operator , Constants . Literal . string ( value ) ) ) ; <nl> - } <nl> } <nl> <nl> / * * STATEMENTS * * / <nl> @ @ - 1402 , 7 + 1363 , 7 @ @ relationType returns [ Operator op ] <nl> <nl> relation [ WhereClause . Builder clauses ] <nl> : name = cident type = relationType t = term { $ clauses . add ( new SingleColumnRelation ( name , type , t ) ) ; } <nl> - | name = cident K _ LIKE v = STRING _ LITERAL { buildLIKERelation ( $ clauses , name , $ v . text ) ; } <nl> + | name = cident K _ LIKE t = term { $ clauses . add ( new SingleColumnRelation ( name , Operator . LIKE , t ) ) ; } <nl> | name = cident K _ IS K _ NOT K _ NULL { $ clauses . add ( new SingleColumnRelation ( name , Operator . IS _ NOT , Constants . NULL _ LITERAL ) ) ; } <nl> | K _ TOKEN l = tupleOfIdentifiers type = relationType t = term <nl> { $ clauses . add ( new TokenRelation ( l , type , t ) ) ; } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Operator . java b / src / java / org / apache / cassandra / cql3 / Operator . java <nl> index accb786 . . 07c92f0 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Operator . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / Operator . java <nl> @ @ - 25 , 10 + 25 , 7 @ @ import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . Set ; <nl> <nl> - import org . apache . cassandra . db . marshal . AbstractType ; <nl> - import org . apache . cassandra . db . marshal . ListType ; <nl> - import org . apache . cassandra . db . marshal . MapType ; <nl> - import org . apache . cassandra . db . marshal . SetType ; <nl> + import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> public enum Operator <nl> @ @ - 134 , 6 + 131 , 14 @ @ public enum Operator <nl> { <nl> return " LIKE ' < term > ' " ; <nl> } <nl> + } , <nl> + LIKE ( 14 ) <nl> + { <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + return " LIKE " ; <nl> + } <nl> } ; <nl> <nl> / * * <nl> @ @ - 234 , 7 + 239 , 7 @ @ public enum Operator <nl> case LIKE _ CONTAINS : <nl> return ByteBufferUtil . contains ( leftOperand , rightOperand ) ; <nl> default : <nl> - / / we shouldn ' t get CONTAINS , CONTAINS KEY , or IS NOT here <nl> + / / we shouldn ' t get LIKE , CONTAINS , CONTAINS KEY , or IS NOT here <nl> throw new AssertionError ( ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Relation . java b / src / java / org / apache / cassandra / cql3 / Relation . java <nl> index 616fd30 . . bc986f6 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Relation . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / Relation . java <nl> @ @ - 113 , 7 + 113 , 8 @ @ public abstract class Relation { <nl> return relationType = = Operator . LIKE _ PREFIX <nl> | | relationType = = Operator . LIKE _ SUFFIX <nl> | | relationType = = Operator . LIKE _ CONTAINS <nl> - | | relationType = = Operator . LIKE _ MATCHES ; <nl> + | | relationType = = Operator . LIKE _ MATCHES <nl> + | | relationType = = Operator . LIKE ; <nl> } <nl> <nl> / * * <nl> @ @ - 155 , 6 + 156 , 7 @ @ public abstract class Relation { <nl> case LIKE _ SUFFIX : <nl> case LIKE _ CONTAINS : <nl> case LIKE _ MATCHES : <nl> + case LIKE : <nl> return newLikeRestriction ( cfm , boundNames , relationType ) ; <nl> default : throw invalidRequest ( " Unsupported \ " ! = \ " relation : % s " , this ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java b / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java <nl> index f61225b . . 3cb07b9 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java <nl> @ @ - 151 , 9 + 151 , 6 @ @ public final class SingleColumnRelation extends Relation <nl> if ( isIN ( ) ) <nl> return String . format ( " % s IN % s " , entityAsString , inValues ) ; <nl> <nl> - if ( isLIKE ( ) ) <nl> - return String . format ( " % s % s " , entityAsString , relationType ) ; <nl> - <nl> return String . format ( " % s % s % s " , entityAsString , relationType , value ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnRestriction . java b / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnRestriction . java <nl> index ab4815a . . a5804be 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnRestriction . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnRestriction . java <nl> @ @ - 18 , 7 + 18 , 9 @ @ <nl> package org . apache . cassandra . cql3 . restrictions ; <nl> <nl> import java . nio . ByteBuffer ; <nl> - import java . util . * ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> <nl> import com . google . common . collect . Iterables ; <nl> <nl> @ @ - 32 , 6 + 34 , 8 @ @ import org . apache . cassandra . db . filter . RowFilter ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . index . Index ; <nl> import org . apache . cassandra . index . SecondaryIndexManager ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . Pair ; <nl> <nl> import static org . apache . cassandra . cql3 . statements . RequestValidations . checkBindValueSet ; <nl> import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; <nl> @ @ - 653 , 6 + 657 , 7 @ @ public abstract class SingleColumnRestriction extends AbstractRestriction <nl> <nl> public static final class LikeRestriction extends SingleColumnRestriction <nl> { <nl> + private static final ByteBuffer LIKE _ WILDCARD = ByteBufferUtil . bytes ( " % " ) ; <nl> private final Operator operator ; <nl> private final Term value ; <nl> <nl> @ @ - 698 , 7 + 703 , 14 @ @ public abstract class SingleColumnRestriction extends AbstractRestriction <nl> SecondaryIndexManager indexManager , <nl> QueryOptions options ) <nl> { <nl> - filter . add ( columnDef , operator , value . bindAndGet ( options ) ) ; <nl> + Pair < Operator , ByteBuffer > operation = makeSpecific ( value . bindAndGet ( options ) ) ; <nl> + <nl> + / / there must be a suitable INDEX for LIKE _ XXX expressions <nl> + RowFilter . SimpleExpression expression = filter . add ( columnDef , operation . left , operation . right ) ; <nl> + indexManager . getBestIndexFor ( expression ) <nl> + . orElseThrow ( ( ) - > new InvalidRequestException ( expression . toString ( ) + <nl> + " is only supported on properly " + <nl> + " indexed columns " ) ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 727 , 5 + 739 , 51 @ @ public abstract class SingleColumnRestriction extends AbstractRestriction <nl> { <nl> return index . supportsExpression ( columnDef , operator ) ; <nl> } <nl> + <nl> + / * * <nl> + * As the specific subtype of LIKE ( LIKE _ PREFIX , LIKE _ SUFFIX , LIKE _ CONTAINS , LIKE _ MATCHES ) can only be <nl> + * determined by examining the value , which in turn can only be known after binding , all LIKE restrictions <nl> + * are initially created with the generic LIKE operator . This function takes the bound value , trims the <nl> + * wildcard ' % ' chars from it and returns a tuple of the inferred operator subtype and the final value <nl> + * @ param value the bound value for the LIKE operation <nl> + * @ return Pair containing the inferred LIKE subtype and the value with wildcards removed <nl> + * / <nl> + private static Pair < Operator , ByteBuffer > makeSpecific ( ByteBuffer value ) <nl> + { <nl> + Operator operator ; <nl> + int beginIndex = value . position ( ) ; <nl> + int endIndex = value . limit ( ) - 1 ; <nl> + if ( ByteBufferUtil . endsWith ( value , LIKE _ WILDCARD ) ) <nl> + { <nl> + if ( ByteBufferUtil . startsWith ( value , LIKE _ WILDCARD ) ) <nl> + { <nl> + operator = Operator . LIKE _ CONTAINS ; <nl> + beginIndex = + 1 ; <nl> + } <nl> + else <nl> + { <nl> + operator = Operator . LIKE _ PREFIX ; <nl> + } <nl> + } <nl> + else if ( ByteBufferUtil . startsWith ( value , LIKE _ WILDCARD ) ) <nl> + { <nl> + operator = Operator . LIKE _ SUFFIX ; <nl> + beginIndex + = 1 ; <nl> + endIndex + = 1 ; <nl> + } <nl> + else <nl> + { <nl> + operator = Operator . LIKE _ MATCHES ; <nl> + endIndex + = 1 ; <nl> + } <nl> + <nl> + if ( endIndex = = 0 | | beginIndex = = endIndex ) <nl> + throw new InvalidRequestException ( " LIKE value can ' t be empty . " ) ; <nl> + <nl> + ByteBuffer newValue = value . duplicate ( ) ; <nl> + newValue . position ( beginIndex ) ; <nl> + newValue . limit ( endIndex ) ; <nl> + return Pair . create ( operator , newValue ) ; <nl> + } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> index 0672a99 . . a35d86b 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> @ @ - 164 , 7 + 164 , 9 @ @ public final class StatementRestrictions <nl> Restriction restriction = relation . toRestriction ( cfm , boundNames ) ; <nl> <nl> if ( ! type . allowUseOfSecondaryIndices ( ) | | ! restriction . hasSupportingIndex ( secondaryIndexManager ) ) <nl> - throw new InvalidRequestException ( relation + " restriction is only supported on properly indexed columns " ) ; <nl> + throw new InvalidRequestException ( String . format ( " LIKE restriction is only supported on properly " + <nl> + " indexed columns . % s is not valid . " , <nl> + relation . toString ( ) ) ) ; <nl> <nl> addRestriction ( restriction ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / RowFilter . java b / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> index c96820e . . fea8ea8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / RowFilter . java <nl> @ @ - 78 , 9 + 78 , 11 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> return new ThriftFilter ( new ArrayList < > ( capacity ) ) ; <nl> } <nl> <nl> - public void add ( ColumnDefinition def , Operator op , ByteBuffer value ) <nl> + public SimpleExpression add ( ColumnDefinition def , Operator op , ByteBuffer value ) <nl> { <nl> - add ( new SimpleExpression ( def , op , value ) ) ; <nl> + SimpleExpression expression = new SimpleExpression ( def , op , value ) ; <nl> + add ( expression ) ; <nl> + return expression ; <nl> } <nl> <nl> public void addMapEquality ( ColumnDefinition def , ByteBuffer key , Operator op , ByteBuffer value ) <nl> @ @ - 593 , 9 + 595 , 9 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > <nl> / * * <nl> * An expression of the form ' column ' ' op ' ' value ' . <nl> * / <nl> - private static class SimpleExpression extends Expression <nl> + public static class SimpleExpression extends Expression <nl> { <nl> - public SimpleExpression ( ColumnDefinition column , Operator operator , ByteBuffer value ) <nl> + SimpleExpression ( ColumnDefinition column , Operator operator , ByteBuffer value ) <nl> { <nl> super ( column , operator , value ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> index 76ab968 . . 89129e7 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> @ @ - 212 , 6 + 212 , 9 @ @ public class ColumnIndex <nl> <nl> public boolean supports ( Operator op ) <nl> { <nl> + if ( op = = Operator . LIKE ) <nl> + return isLiteral ( ) ; <nl> + <nl> Op operator = Op . valueOf ( op ) ; <nl> return ! ( isTokenized & & operator = = Op . EQ ) / / EQ is only applicable to non - tokenized indexes <nl> & & ! ( isLiteral ( ) & & operator = = Op . RANGE ) / / RANGE only applicable to indexes non - literal indexes <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java <nl> index b6c786e . . e357d74 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java <nl> @ @ - 44 , 6 + 44 , 7 @ @ import org . apache . cassandra . index . IndexNotAvailableException ; <nl> import org . apache . cassandra . index . SecondaryIndexManager ; <nl> import org . apache . cassandra . index . StubIndex ; <nl> import org . apache . cassandra . index . internal . CustomCassandraIndex ; <nl> + import org . apache . cassandra . index . sasi . SASIIndex ; <nl> import org . apache . cassandra . schema . IndexMetadata ; <nl> import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> @ @ - 685 , 6 + 686 , 69 @ @ public class SecondaryIndexTest extends CQLTester <nl> " APPLY BATCH " , map ) ; <nl> } <nl> <nl> + @ Test <nl> + public void prepareStatementsWithLIKEClauses ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( a int , c1 text , c2 text , v1 text , v2 text , v3 int , PRIMARY KEY ( a , c1 , c2 ) ) " ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX c1 _ idx on % % s ( c1 ) USING ' % s ' WITH OPTIONS = { ' mode ' : ' PREFIX ' } " , <nl> + SASIIndex . class . getName ( ) ) ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX c2 _ idx on % % s ( c2 ) USING ' % s ' WITH OPTIONS = { ' mode ' : ' CONTAINS ' } " , <nl> + SASIIndex . class . getName ( ) ) ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX v1 _ idx on % % s ( v1 ) USING ' % s ' WITH OPTIONS = { ' mode ' : ' PREFIX ' } " , <nl> + SASIIndex . class . getName ( ) ) ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX v2 _ idx on % % s ( v2 ) USING ' % s ' WITH OPTIONS = { ' mode ' : ' CONTAINS ' } " , <nl> + SASIIndex . class . getName ( ) ) ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX v3 _ idx on % % s ( v3 ) USING ' % s ' " , SASIIndex . class . getName ( ) ) ) ; <nl> + <nl> + forcePreparedValues ( ) ; <nl> + / / prefix mode indexes support prefix / contains / matches <nl> + assertInvalidMessage ( " c1 LIKE ' % < term > ' abc is only supported on properly indexed columns " , <nl> + " SELECT * FROM % s WHERE c1 LIKE ? " , <nl> + " % abc " ) ; <nl> + assertInvalidMessage ( " c1 LIKE ' % < term > % ' abc is only supported on properly indexed columns " , <nl> + " SELECT * FROM % s WHERE c1 LIKE ? " , <nl> + " % abc % " ) ; <nl> + execute ( " SELECT * FROM % s WHERE c1 LIKE ? " , " abc % " ) ; <nl> + execute ( " SELECT * FROM % s WHERE c1 LIKE ? " , " abc " ) ; <nl> + assertInvalidMessage ( " v1 LIKE ' % < term > ' abc is only supported on properly indexed columns " , <nl> + " SELECT * FROM % s WHERE v1 LIKE ? " , <nl> + " % abc " ) ; <nl> + assertInvalidMessage ( " v1 LIKE ' % < term > % ' abc is only supported on properly indexed columns " , <nl> + " SELECT * FROM % s WHERE v1 LIKE ? " , <nl> + " % abc % " ) ; <nl> + execute ( " SELECT * FROM % s WHERE v1 LIKE ? " , " abc % " ) ; <nl> + execute ( " SELECT * FROM % s WHERE v1 LIKE ? " , " abc " ) ; <nl> + <nl> + / / contains mode indexes support suffix / contains / matches <nl> + assertInvalidMessage ( " c2 LIKE ' < term > % ' abc is only supported on properly indexed columns " , <nl> + " SELECT * FROM % s WHERE c2 LIKE ? " , <nl> + " abc % " ) ; <nl> + execute ( " SELECT * FROM % s WHERE c2 LIKE ? " , " % abc " ) ; <nl> + execute ( " SELECT * FROM % s WHERE c2 LIKE ? " , " % abc % " ) ; <nl> + execute ( " SELECT * FROM % s WHERE c2 LIKE ? " , " abc " ) ; <nl> + assertInvalidMessage ( " v2 LIKE ' < term > % ' abc is only supported on properly indexed columns " , <nl> + " SELECT * FROM % s WHERE v2 LIKE ? " , <nl> + " abc % " ) ; <nl> + execute ( " SELECT * FROM % s WHERE v2 LIKE ? " , " % abc " ) ; <nl> + execute ( " SELECT * FROM % s WHERE v2 LIKE ? " , " % abc % " ) ; <nl> + execute ( " SELECT * FROM % s WHERE v2 LIKE ? " , " abc " ) ; <nl> + <nl> + / / LIKE is not supported on indexes of non - literal values <nl> + / / this is rejected before binding , so the value isn ' t available in the error message <nl> + assertInvalidMessage ( " LIKE restriction is only supported on properly indexed columns . v3 LIKE ? is not valid " , <nl> + " SELECT * FROM % s WHERE v3 LIKE ? " , <nl> + " % abc " ) ; <nl> + assertInvalidMessage ( " LIKE restriction is only supported on properly indexed columns . v3 LIKE ? is not valid " , <nl> + " SELECT * FROM % s WHERE v3 LIKE ? " , <nl> + " % abc % " ) ; <nl> + assertInvalidMessage ( " LIKE restriction is only supported on properly indexed columns . v3 LIKE ? is not valid " , <nl> + " SELECT * FROM % s WHERE v3 LIKE ? " , <nl> + " % abc % " ) ; <nl> + assertInvalidMessage ( " LIKE restriction is only supported on properly indexed columns . v3 LIKE ? is not valid " , <nl> + " SELECT * FROM % s WHERE v3 LIKE ? " , <nl> + " abc " ) ; <nl> + } <nl> + <nl> public void failInsert ( String insertCQL , Object . . . args ) throws Throwable <nl> { <nl> try <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> index c5feccb . . 077712e 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java <nl> @ @ - 23 , 10 + 23 , 10 @ @ import java . util . UUID ; <nl> import org . junit . Test ; <nl> <nl> import junit . framework . Assert ; <nl> + import org . apache . cassandra . cql3 . CQLTester ; <nl> import org . apache . cassandra . cql3 . UntypedResultSet ; <nl> import org . apache . cassandra . cql3 . restrictions . StatementRestrictions ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> - import org . apache . cassandra . cql3 . CQLTester ; <nl> <nl> import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertTrue ; <nl> @ @ - 2353 , 5 + 2353 , 4 @ @ public class SelectTest extends CQLTester <nl> " SELECT * FROM % s WHERE c CONTAINS KEY ? ALLOW FILTERING " , <nl> unset ( ) ) ; <nl> } <nl> - <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> index 4b9c3f9 . . b3d641c 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> + + + b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> @ @ - 1694 , 7 + 1694 , 7 @ @ public class SASIIndexTest <nl> executeCQL ( CLUSTERING _ CF _ NAME _ 1 , " SELECT * FROM % s . % s WHERE location LIKE ' % % ' ALLOW FILTERING " ) ; <nl> Assert . fail ( ) ; <nl> } <nl> - catch ( SyntaxException e ) <nl> + catch ( InvalidRequestException e ) <nl> { <nl> Assert . assertTrue ( e . getMessage ( ) . contains ( " empty " ) ) ; <nl> / / expected <nl> @ @ - 1705 , 7 + 1705 , 7 @ @ public class SASIIndexTest <nl> executeCQL ( CLUSTERING _ CF _ NAME _ 1 , " SELECT * FROM % s . % s WHERE location LIKE ' % % % % ' ALLOW FILTERING " ) ; <nl> Assert . fail ( ) ; <nl> } <nl> - catch ( SyntaxException e ) <nl> + catch ( InvalidRequestException e ) <nl> { <nl> Assert . assertTrue ( e . getMessage ( ) . contains ( " empty " ) ) ; <nl> / / expected <nl> diff - - git a / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java b / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java <nl> index 22d5c88 . . 52cee3b 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java <nl> + + + b / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java <nl> @ @ - 577 , 7 + 577 , 7 @ @ public class OperationTest extends SchemaLoader <nl> <nl> private static class SimpleExpression extends RowFilter . Expression <nl> { <nl> - protected SimpleExpression ( ColumnDefinition column , Operator operator , ByteBuffer value ) <nl> + SimpleExpression ( ColumnDefinition column , Operator operator , ByteBuffer value ) <nl> { <nl> super ( column , operator , value ) ; <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 0401357 . . cf05d7b 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 6 
 + * Support LIKE operator in prepared statements ( CASSANDRA - 11456 ) 
 * Add a command to see if a Materialized View has finished building ( CASSANDRA - 9967 ) 
 * Log endpoint and port associated with streaming operation ( CASSANDRA - 8777 ) 
 * Print sensible units for all log messages ( CASSANDRA - 9692 ) 
 diff - - git a / src / antlr / Parser . g b / src / antlr / Parser . g 
 index b4aa235 . . 78a2d0d 100644 
 - - - a / src / antlr / Parser . g 
 + + + b / src / antlr / Parser . g 
 @ @ - 156 , 45 + 156 , 6 @ @ options { 
 return filtered ; 
 } 
 
 - public void buildLIKERelation ( WhereClause . Builder whereClause , ColumnIdentifier . Raw name , String likeValue ) 
 - { 
 - Operator operator ; 
 - int beginIndex = 0 ; 
 - int endIndex = likeValue . length ( ) - 1 ; 
 - 
 - if ( likeValue . charAt ( endIndex ) = = ' \ % ' ) 
 - { 
 - if ( likeValue . charAt ( beginIndex ) = = ' \ % ' ) 
 - { 
 - operator = Operator . LIKE _ CONTAINS ; 
 - beginIndex = + 1 ; 
 - } 
 - else 
 - { 
 - operator = Operator . LIKE _ PREFIX ; 
 - } 
 - } 
 - else if ( likeValue . charAt ( beginIndex ) = = ' \ % ' ) 
 - { 
 - operator = Operator . LIKE _ SUFFIX ; 
 - beginIndex + = 1 ; 
 - endIndex + = 1 ; 
 - } 
 - else 
 - { 
 - operator = Operator . LIKE _ MATCHES ; 
 - endIndex + = 1 ; 
 - } 
 - 
 - if ( endIndex = = 0 | | beginIndex = = endIndex ) 
 - { 
 - addRecognitionError ( " LIKE value can ' t be empty . " ) ; 
 - return ; 
 - } 
 - 
 - String value = likeValue . substring ( beginIndex , endIndex ) ; 
 - whereClause . add ( new SingleColumnRelation ( name , operator , Constants . Literal . string ( value ) ) ) ; 
 - } 
 } 
 
 / * * STATEMENTS * * / 
 @ @ - 1402 , 7 + 1363 , 7 @ @ relationType returns [ Operator op ] 
 
 relation [ WhereClause . Builder clauses ] 
 : name = cident type = relationType t = term { $ clauses . add ( new SingleColumnRelation ( name , type , t ) ) ; } 
 - | name = cident K _ LIKE v = STRING _ LITERAL { buildLIKERelation ( $ clauses , name , $ v . text ) ; } 
 + | name = cident K _ LIKE t = term { $ clauses . add ( new SingleColumnRelation ( name , Operator . LIKE , t ) ) ; } 
 | name = cident K _ IS K _ NOT K _ NULL { $ clauses . add ( new SingleColumnRelation ( name , Operator . IS _ NOT , Constants . NULL _ LITERAL ) ) ; } 
 | K _ TOKEN l = tupleOfIdentifiers type = relationType t = term 
 { $ clauses . add ( new TokenRelation ( l , type , t ) ) ; } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Operator . java b / src / java / org / apache / cassandra / cql3 / Operator . java 
 index accb786 . . 07c92f0 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Operator . java 
 + + + b / src / java / org / apache / cassandra / cql3 / Operator . java 
 @ @ - 25 , 10 + 25 , 7 @ @ import java . util . List ; 
 import java . util . Map ; 
 import java . util . Set ; 
 
 - import org . apache . cassandra . db . marshal . AbstractType ; 
 - import org . apache . cassandra . db . marshal . ListType ; 
 - import org . apache . cassandra . db . marshal . MapType ; 
 - import org . apache . cassandra . db . marshal . SetType ; 
 + import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 public enum Operator 
 @ @ - 134 , 6 + 131 , 14 @ @ public enum Operator 
 { 
 return " LIKE ' < term > ' " ; 
 } 
 + } , 
 + LIKE ( 14 ) 
 + { 
 + @ Override 
 + public String toString ( ) 
 + { 
 + return " LIKE " ; 
 + } 
 } ; 
 
 / * * 
 @ @ - 234 , 7 + 239 , 7 @ @ public enum Operator 
 case LIKE _ CONTAINS : 
 return ByteBufferUtil . contains ( leftOperand , rightOperand ) ; 
 default : 
 - / / we shouldn ' t get CONTAINS , CONTAINS KEY , or IS NOT here 
 + / / we shouldn ' t get LIKE , CONTAINS , CONTAINS KEY , or IS NOT here 
 throw new AssertionError ( ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Relation . java b / src / java / org / apache / cassandra / cql3 / Relation . java 
 index 616fd30 . . bc986f6 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Relation . java 
 + + + b / src / java / org / apache / cassandra / cql3 / Relation . java 
 @ @ - 113 , 7 + 113 , 8 @ @ public abstract class Relation { 
 return relationType = = Operator . LIKE _ PREFIX 
 | | relationType = = Operator . LIKE _ SUFFIX 
 | | relationType = = Operator . LIKE _ CONTAINS 
 - | | relationType = = Operator . LIKE _ MATCHES ; 
 + | | relationType = = Operator . LIKE _ MATCHES 
 + | | relationType = = Operator . LIKE ; 
 } 
 
 / * * 
 @ @ - 155 , 6 + 156 , 7 @ @ public abstract class Relation { 
 case LIKE _ SUFFIX : 
 case LIKE _ CONTAINS : 
 case LIKE _ MATCHES : 
 + case LIKE : 
 return newLikeRestriction ( cfm , boundNames , relationType ) ; 
 default : throw invalidRequest ( " Unsupported \ " ! = \ " relation : % s " , this ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java b / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java 
 index f61225b . . 3cb07b9 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java 
 + + + b / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java 
 @ @ - 151 , 9 + 151 , 6 @ @ public final class SingleColumnRelation extends Relation 
 if ( isIN ( ) ) 
 return String . format ( " % s IN % s " , entityAsString , inValues ) ; 
 
 - if ( isLIKE ( ) ) 
 - return String . format ( " % s % s " , entityAsString , relationType ) ; 
 - 
 return String . format ( " % s % s % s " , entityAsString , relationType , value ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnRestriction . java b / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnRestriction . java 
 index ab4815a . . a5804be 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnRestriction . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnRestriction . java 
 @ @ - 18 , 7 + 18 , 9 @ @ 
 package org . apache . cassandra . cql3 . restrictions ; 
 
 import java . nio . ByteBuffer ; 
 - import java . util . * ; 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 
 import com . google . common . collect . Iterables ; 
 
 @ @ - 32 , 6 + 34 , 8 @ @ import org . apache . cassandra . db . filter . RowFilter ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . index . Index ; 
 import org . apache . cassandra . index . SecondaryIndexManager ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . Pair ; 
 
 import static org . apache . cassandra . cql3 . statements . RequestValidations . checkBindValueSet ; 
 import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; 
 @ @ - 653 , 6 + 657 , 7 @ @ public abstract class SingleColumnRestriction extends AbstractRestriction 
 
 public static final class LikeRestriction extends SingleColumnRestriction 
 { 
 + private static final ByteBuffer LIKE _ WILDCARD = ByteBufferUtil . bytes ( " % " ) ; 
 private final Operator operator ; 
 private final Term value ; 
 
 @ @ - 698 , 7 + 703 , 14 @ @ public abstract class SingleColumnRestriction extends AbstractRestriction 
 SecondaryIndexManager indexManager , 
 QueryOptions options ) 
 { 
 - filter . add ( columnDef , operator , value . bindAndGet ( options ) ) ; 
 + Pair < Operator , ByteBuffer > operation = makeSpecific ( value . bindAndGet ( options ) ) ; 
 + 
 + / / there must be a suitable INDEX for LIKE _ XXX expressions 
 + RowFilter . SimpleExpression expression = filter . add ( columnDef , operation . left , operation . right ) ; 
 + indexManager . getBestIndexFor ( expression ) 
 + . orElseThrow ( ( ) - > new InvalidRequestException ( expression . toString ( ) + 
 + " is only supported on properly " + 
 + " indexed columns " ) ) ; 
 } 
 
 @ Override 
 @ @ - 727 , 5 + 739 , 51 @ @ public abstract class SingleColumnRestriction extends AbstractRestriction 
 { 
 return index . supportsExpression ( columnDef , operator ) ; 
 } 
 + 
 + / * * 
 + * As the specific subtype of LIKE ( LIKE _ PREFIX , LIKE _ SUFFIX , LIKE _ CONTAINS , LIKE _ MATCHES ) can only be 
 + * determined by examining the value , which in turn can only be known after binding , all LIKE restrictions 
 + * are initially created with the generic LIKE operator . This function takes the bound value , trims the 
 + * wildcard ' % ' chars from it and returns a tuple of the inferred operator subtype and the final value 
 + * @ param value the bound value for the LIKE operation 
 + * @ return Pair containing the inferred LIKE subtype and the value with wildcards removed 
 + * / 
 + private static Pair < Operator , ByteBuffer > makeSpecific ( ByteBuffer value ) 
 + { 
 + Operator operator ; 
 + int beginIndex = value . position ( ) ; 
 + int endIndex = value . limit ( ) - 1 ; 
 + if ( ByteBufferUtil . endsWith ( value , LIKE _ WILDCARD ) ) 
 + { 
 + if ( ByteBufferUtil . startsWith ( value , LIKE _ WILDCARD ) ) 
 + { 
 + operator = Operator . LIKE _ CONTAINS ; 
 + beginIndex = + 1 ; 
 + } 
 + else 
 + { 
 + operator = Operator . LIKE _ PREFIX ; 
 + } 
 + } 
 + else if ( ByteBufferUtil . startsWith ( value , LIKE _ WILDCARD ) ) 
 + { 
 + operator = Operator . LIKE _ SUFFIX ; 
 + beginIndex + = 1 ; 
 + endIndex + = 1 ; 
 + } 
 + else 
 + { 
 + operator = Operator . LIKE _ MATCHES ; 
 + endIndex + = 1 ; 
 + } 
 + 
 + if ( endIndex = = 0 | | beginIndex = = endIndex ) 
 + throw new InvalidRequestException ( " LIKE value can ' t be empty . " ) ; 
 + 
 + ByteBuffer newValue = value . duplicate ( ) ; 
 + newValue . position ( beginIndex ) ; 
 + newValue . limit ( endIndex ) ; 
 + return Pair . create ( operator , newValue ) ; 
 + } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 index 0672a99 . . a35d86b 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 @ @ - 164 , 7 + 164 , 9 @ @ public final class StatementRestrictions 
 Restriction restriction = relation . toRestriction ( cfm , boundNames ) ; 
 
 if ( ! type . allowUseOfSecondaryIndices ( ) | | ! restriction . hasSupportingIndex ( secondaryIndexManager ) ) 
 - throw new InvalidRequestException ( relation + " restriction is only supported on properly indexed columns " ) ; 
 + throw new InvalidRequestException ( String . format ( " LIKE restriction is only supported on properly " + 
 + " indexed columns . % s is not valid . " , 
 + relation . toString ( ) ) ) ; 
 
 addRestriction ( restriction ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / filter / RowFilter . java b / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 index c96820e . . fea8ea8 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 + + + b / src / java / org / apache / cassandra / db / filter / RowFilter . java 
 @ @ - 78 , 9 + 78 , 11 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 return new ThriftFilter ( new ArrayList < > ( capacity ) ) ; 
 } 
 
 - public void add ( ColumnDefinition def , Operator op , ByteBuffer value ) 
 + public SimpleExpression add ( ColumnDefinition def , Operator op , ByteBuffer value ) 
 { 
 - add ( new SimpleExpression ( def , op , value ) ) ; 
 + SimpleExpression expression = new SimpleExpression ( def , op , value ) ; 
 + add ( expression ) ; 
 + return expression ; 
 } 
 
 public void addMapEquality ( ColumnDefinition def , ByteBuffer key , Operator op , ByteBuffer value ) 
 @ @ - 593 , 9 + 595 , 9 @ @ public abstract class RowFilter implements Iterable < RowFilter . Expression > 
 / * * 
 * An expression of the form ' column ' ' op ' ' value ' . 
 * / 
 - private static class SimpleExpression extends Expression 
 + public static class SimpleExpression extends Expression 
 { 
 - public SimpleExpression ( ColumnDefinition column , Operator operator , ByteBuffer value ) 
 + SimpleExpression ( ColumnDefinition column , Operator operator , ByteBuffer value ) 
 { 
 super ( column , operator , value ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 index 76ab968 . . 89129e7 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 @ @ - 212 , 6 + 212 , 9 @ @ public class ColumnIndex 
 
 public boolean supports ( Operator op ) 
 { 
 + if ( op = = Operator . LIKE ) 
 + return isLiteral ( ) ; 
 + 
 Op operator = Op . valueOf ( op ) ; 
 return ! ( isTokenized & & operator = = Op . EQ ) / / EQ is only applicable to non - tokenized indexes 
 & & ! ( isLiteral ( ) & & operator = = Op . RANGE ) / / RANGE only applicable to indexes non - literal indexes 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java 
 index b6c786e . . e357d74 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java 
 @ @ - 44 , 6 + 44 , 7 @ @ import org . apache . cassandra . index . IndexNotAvailableException ; 
 import org . apache . cassandra . index . SecondaryIndexManager ; 
 import org . apache . cassandra . index . StubIndex ; 
 import org . apache . cassandra . index . internal . CustomCassandraIndex ; 
 + import org . apache . cassandra . index . sasi . SASIIndex ; 
 import org . apache . cassandra . schema . IndexMetadata ; 
 import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 @ @ - 685 , 6 + 686 , 69 @ @ public class SecondaryIndexTest extends CQLTester 
 " APPLY BATCH " , map ) ; 
 } 
 
 + @ Test 
 + public void prepareStatementsWithLIKEClauses ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( a int , c1 text , c2 text , v1 text , v2 text , v3 int , PRIMARY KEY ( a , c1 , c2 ) ) " ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX c1 _ idx on % % s ( c1 ) USING ' % s ' WITH OPTIONS = { ' mode ' : ' PREFIX ' } " , 
 + SASIIndex . class . getName ( ) ) ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX c2 _ idx on % % s ( c2 ) USING ' % s ' WITH OPTIONS = { ' mode ' : ' CONTAINS ' } " , 
 + SASIIndex . class . getName ( ) ) ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX v1 _ idx on % % s ( v1 ) USING ' % s ' WITH OPTIONS = { ' mode ' : ' PREFIX ' } " , 
 + SASIIndex . class . getName ( ) ) ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX v2 _ idx on % % s ( v2 ) USING ' % s ' WITH OPTIONS = { ' mode ' : ' CONTAINS ' } " , 
 + SASIIndex . class . getName ( ) ) ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX v3 _ idx on % % s ( v3 ) USING ' % s ' " , SASIIndex . class . getName ( ) ) ) ; 
 + 
 + forcePreparedValues ( ) ; 
 + / / prefix mode indexes support prefix / contains / matches 
 + assertInvalidMessage ( " c1 LIKE ' % < term > ' abc is only supported on properly indexed columns " , 
 + " SELECT * FROM % s WHERE c1 LIKE ? " , 
 + " % abc " ) ; 
 + assertInvalidMessage ( " c1 LIKE ' % < term > % ' abc is only supported on properly indexed columns " , 
 + " SELECT * FROM % s WHERE c1 LIKE ? " , 
 + " % abc % " ) ; 
 + execute ( " SELECT * FROM % s WHERE c1 LIKE ? " , " abc % " ) ; 
 + execute ( " SELECT * FROM % s WHERE c1 LIKE ? " , " abc " ) ; 
 + assertInvalidMessage ( " v1 LIKE ' % < term > ' abc is only supported on properly indexed columns " , 
 + " SELECT * FROM % s WHERE v1 LIKE ? " , 
 + " % abc " ) ; 
 + assertInvalidMessage ( " v1 LIKE ' % < term > % ' abc is only supported on properly indexed columns " , 
 + " SELECT * FROM % s WHERE v1 LIKE ? " , 
 + " % abc % " ) ; 
 + execute ( " SELECT * FROM % s WHERE v1 LIKE ? " , " abc % " ) ; 
 + execute ( " SELECT * FROM % s WHERE v1 LIKE ? " , " abc " ) ; 
 + 
 + / / contains mode indexes support suffix / contains / matches 
 + assertInvalidMessage ( " c2 LIKE ' < term > % ' abc is only supported on properly indexed columns " , 
 + " SELECT * FROM % s WHERE c2 LIKE ? " , 
 + " abc % " ) ; 
 + execute ( " SELECT * FROM % s WHERE c2 LIKE ? " , " % abc " ) ; 
 + execute ( " SELECT * FROM % s WHERE c2 LIKE ? " , " % abc % " ) ; 
 + execute ( " SELECT * FROM % s WHERE c2 LIKE ? " , " abc " ) ; 
 + assertInvalidMessage ( " v2 LIKE ' < term > % ' abc is only supported on properly indexed columns " , 
 + " SELECT * FROM % s WHERE v2 LIKE ? " , 
 + " abc % " ) ; 
 + execute ( " SELECT * FROM % s WHERE v2 LIKE ? " , " % abc " ) ; 
 + execute ( " SELECT * FROM % s WHERE v2 LIKE ? " , " % abc % " ) ; 
 + execute ( " SELECT * FROM % s WHERE v2 LIKE ? " , " abc " ) ; 
 + 
 + / / LIKE is not supported on indexes of non - literal values 
 + / / this is rejected before binding , so the value isn ' t available in the error message 
 + assertInvalidMessage ( " LIKE restriction is only supported on properly indexed columns . v3 LIKE ? is not valid " , 
 + " SELECT * FROM % s WHERE v3 LIKE ? " , 
 + " % abc " ) ; 
 + assertInvalidMessage ( " LIKE restriction is only supported on properly indexed columns . v3 LIKE ? is not valid " , 
 + " SELECT * FROM % s WHERE v3 LIKE ? " , 
 + " % abc % " ) ; 
 + assertInvalidMessage ( " LIKE restriction is only supported on properly indexed columns . v3 LIKE ? is not valid " , 
 + " SELECT * FROM % s WHERE v3 LIKE ? " , 
 + " % abc % " ) ; 
 + assertInvalidMessage ( " LIKE restriction is only supported on properly indexed columns . v3 LIKE ? is not valid " , 
 + " SELECT * FROM % s WHERE v3 LIKE ? " , 
 + " abc " ) ; 
 + } 
 + 
 public void failInsert ( String insertCQL , Object . . . args ) throws Throwable 
 { 
 try 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 index c5feccb . . 077712e 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectTest . java 
 @ @ - 23 , 10 + 23 , 10 @ @ import java . util . UUID ; 
 import org . junit . Test ; 
 
 import junit . framework . Assert ; 
 + import org . apache . cassandra . cql3 . CQLTester ; 
 import org . apache . cassandra . cql3 . UntypedResultSet ; 
 import org . apache . cassandra . cql3 . restrictions . StatementRestrictions ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 - import org . apache . cassandra . cql3 . CQLTester ; 
 
 import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertTrue ; 
 @ @ - 2353 , 5 + 2353 , 4 @ @ public class SelectTest extends CQLTester 
 " SELECT * FROM % s WHERE c CONTAINS KEY ? ALLOW FILTERING " , 
 unset ( ) ) ; 
 } 
 - 
 } 
 diff - - git a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 index 4b9c3f9 . . b3d641c 100644 
 - - - a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 + + + b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 @ @ - 1694 , 7 + 1694 , 7 @ @ public class SASIIndexTest 
 executeCQL ( CLUSTERING _ CF _ NAME _ 1 , " SELECT * FROM % s . % s WHERE location LIKE ' % % ' ALLOW FILTERING " ) ; 
 Assert . fail ( ) ; 
 } 
 - catch ( SyntaxException e ) 
 + catch ( InvalidRequestException e ) 
 { 
 Assert . assertTrue ( e . getMessage ( ) . contains ( " empty " ) ) ; 
 / / expected 
 @ @ - 1705 , 7 + 1705 , 7 @ @ public class SASIIndexTest 
 executeCQL ( CLUSTERING _ CF _ NAME _ 1 , " SELECT * FROM % s . % s WHERE location LIKE ' % % % % ' ALLOW FILTERING " ) ; 
 Assert . fail ( ) ; 
 } 
 - catch ( SyntaxException e ) 
 + catch ( InvalidRequestException e ) 
 { 
 Assert . assertTrue ( e . getMessage ( ) . contains ( " empty " ) ) ; 
 / / expected 
 diff - - git a / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java b / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java 
 index 22d5c88 . . 52cee3b 100644 
 - - - a / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java 
 + + + b / test / unit / org / apache / cassandra / index / sasi / plan / OperationTest . java 
 @ @ - 577 , 7 + 577 , 7 @ @ public class OperationTest extends SchemaLoader 
 
 private static class SimpleExpression extends RowFilter . Expression 
 { 
 - protected SimpleExpression ( ColumnDefinition column , Operator operator , ByteBuffer value ) 
 + SimpleExpression ( ColumnDefinition column , Operator operator , ByteBuffer value ) 
 { 
 super ( column , operator , value ) ; 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
