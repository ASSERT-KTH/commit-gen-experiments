BLEU SCORE: 0.018738883683389617

TEST MSG: Remove Index . indexes ( ) method from 2ndary index API
GENERATED MSG: Give more control over building to 2i impls

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 4dd1b97 . . 507a709 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 1 <nl> + * Remove unclear Indexer . indexes ( ) method ( CASSANDRA - 10690 ) <nl> * Fix NPE on stream read error ( CASSANDRA - 10771 ) <nl> * Normalize cqlsh DESC output ( CASSANDRA - 10431 ) <nl> * Rejects partition range deletions when columns are specified ( CASSANDRA - 10739 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 9cebf58 . . b3c304a 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 20 , 6 + 20 , 9 @ @ Upgrading <nl> - - - - - - - - - <nl> - The return value of SelectStatement : : getLimit as been changed from DataLimits <nl> to int . <nl> + - Custom index implementation should be aware that the method Indexer : : indexes ( ) <nl> + has been removed as its contract was misleading and all custom implementation <nl> + should have almost surely returned true inconditionally for that method . <nl> <nl> <nl> 3 . 0 <nl> diff - - git a / src / java / org / apache / cassandra / index / Index . java b / src / java / org / apache / cassandra / index / Index . java <nl> index b6c12a9 . . 084d0e3 100644 <nl> - - - a / src / java / org / apache / cassandra / index / Index . java <nl> + + + b / src / java / org / apache / cassandra / index / Index . java <nl> @ @ - 191 , 13 + 191 , 6 @ @ public interface Index <nl> * / <nl> <nl> / * * <nl> - * Called to determine whether this index should process a particular partition update . <nl> - * @ param columns <nl> - * @ return <nl> - * / <nl> - public boolean indexes ( PartitionColumns columns ) ; <nl> - <nl> - / * * <nl> * Called to determine whether this index targets a specific column . <nl> * Used during schema operations such as when dropping or renaming a column , to check if <nl> * the index will be affected by the change . Typically , if an index answers that it does <nl> @ @ - 275 , 19 + 268 , 22 @ @ public interface Index <nl> * / <nl> <nl> / * * <nl> - * Factory method for write time event handlers . <nl> - * Callers should check the indexes method first and only get a new <nl> - * handler when the index claims an interest in the specific update <nl> - * otherwise work may be done unnecessarily <nl> + * Creates an new { @ code Indexer } object for updates to a given partition . <nl> * <nl> * @ param key key of the partition being modified <nl> + * @ param columns the regular and static columns the created indexer will have to deal with . <nl> + * This can be empty as an update might only contain partition , range and row deletions , but <nl> + * the indexer is guaranteed to not get any cells for a column that is not part of { @ code columns } . <nl> * @ param nowInSec current time of the update operation <nl> * @ param opGroup operation group spanning the update operation <nl> * @ param transactionType indicates what kind of update is being performed on the base data <nl> * i . e . a write time insert / update / delete or the result of compaction <nl> - * @ return <nl> + * @ return the newly created indexer or { @ code null } if the index is not interested by the update <nl> + * ( this could be because the index doesn ' t care about that particular partition , doesn ' t care about <nl> + * that type of transaction , . . . ) . <nl> * / <nl> public Indexer indexerFor ( DecoratedKey key , <nl> + PartitionColumns columns , <nl> int nowInSec , <nl> OpOrder . Group opGroup , <nl> IndexTransaction . Type transactionType ) ; <nl> diff - - git a / src / java / org / apache / cassandra / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / index / SecondaryIndexManager . java <nl> index ba2c680 . . 16cb9c4 100644 <nl> - - - a / src / java / org / apache / cassandra / index / SecondaryIndexManager . java <nl> + + + b / src / java / org / apache / cassandra / index / SecondaryIndexManager . java <nl> @ @ - 524 , 9 + 524 , 11 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> DecoratedKey key = partition . partitionKey ( ) ; <nl> Set < Index . Indexer > indexers = indexes . stream ( ) <nl> . map ( index - > index . indexerFor ( key , <nl> + partition . columns ( ) , <nl> nowInSec , <nl> opGroup , <nl> IndexTransaction . Type . UPDATE ) ) <nl> + . filter ( Objects : : nonNull ) <nl> . collect ( Collectors . toSet ( ) ) ; <nl> <nl> indexers . forEach ( Index . Indexer : : begin ) ; <nl> @ @ - 666 , 10 + 668 , 8 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> * / <nl> public void validate ( PartitionUpdate update ) throws InvalidRequestException <nl> { <nl> - indexes . values ( ) <nl> - . stream ( ) <nl> - . filter ( i - > i . indexes ( update . columns ( ) ) ) <nl> - . forEach ( i - > i . validate ( update ) ) ; <nl> + for ( Index index : indexes . values ( ) ) <nl> + index . validate ( update ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 720 , 15 + 720 , 13 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> if ( ! hasIndexes ( ) ) <nl> return UpdateTransaction . NO _ OP ; <nl> <nl> - / / todo : optimize lookup , we can probably cache quite a bit of stuff , rather than doing <nl> - / / a linear scan every time . Holding off that though until CASSANDRA - 7771 to figure out <nl> - / / exactly how indexes are to be identified & associated with a given partition update <nl> Index . Indexer [ ] indexers = indexes . values ( ) . stream ( ) <nl> - . filter ( i - > i . indexes ( update . columns ( ) ) ) <nl> . map ( i - > i . indexerFor ( update . partitionKey ( ) , <nl> + update . columns ( ) , <nl> nowInSec , <nl> opGroup , <nl> IndexTransaction . Type . UPDATE ) ) <nl> + . filter ( Objects : : nonNull ) <nl> . toArray ( Index . Indexer [ ] : : new ) ; <nl> <nl> return indexers . length = = 0 ? UpdateTransaction . NO _ OP : new WriteTimeTransaction ( indexers ) ; <nl> @ @ - 743 , 14 + 741 , 7 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> int nowInSec ) <nl> { <nl> / / the check for whether there are any registered indexes is already done in CompactionIterator <nl> - <nl> - Index [ ] interestedIndexes = indexes . values ( ) . stream ( ) <nl> - . filter ( i - > i . indexes ( partitionColumns ) ) <nl> - . toArray ( Index [ ] : : new ) ; <nl> - <nl> - return interestedIndexes . length = = 0 <nl> - ? CompactionTransaction . NO _ OP <nl> - : new IndexGCTransaction ( key , versions , nowInSec , interestedIndexes ) ; <nl> + return new IndexGCTransaction ( key , partitionColumns , versions , nowInSec , listIndexes ( ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 760 , 17 + 751 , 10 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> PartitionColumns partitionColumns , <nl> int nowInSec ) <nl> { <nl> - / / <nl> if ( ! hasIndexes ( ) ) <nl> return CleanupTransaction . NO _ OP ; <nl> <nl> - Index [ ] interestedIndexes = indexes . values ( ) . stream ( ) <nl> - . filter ( i - > i . indexes ( partitionColumns ) ) <nl> - . toArray ( Index [ ] : : new ) ; <nl> - <nl> - return interestedIndexes . length = = 0 <nl> - ? CleanupTransaction . NO _ OP <nl> - : new CleanupGCTransaction ( key , nowInSec , interestedIndexes ) ; <nl> + return new CleanupGCTransaction ( key , partitionColumns , nowInSec , listIndexes ( ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 807 , 7 + 791 , 8 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> <nl> public void onInserted ( Row row ) <nl> { <nl> - Arrays . stream ( indexers ) . forEach ( h - > h . insertRow ( row ) ) ; <nl> + for ( Index . Indexer indexer : indexers ) <nl> + indexer . insertRow ( row ) ; <nl> } <nl> <nl> public void onUpdated ( Row existing , Row updated ) <nl> @ @ - 882 , 21 + 867 , 21 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> private static final class IndexGCTransaction implements CompactionTransaction <nl> { <nl> private final DecoratedKey key ; <nl> + private final PartitionColumns columns ; <nl> private final int versions ; <nl> private final int nowInSec ; <nl> - private final Index [ ] indexes ; <nl> + private final Collection < Index > indexes ; <nl> <nl> private Row [ ] rows ; <nl> <nl> private IndexGCTransaction ( DecoratedKey key , <nl> + PartitionColumns columns , <nl> int versions , <nl> int nowInSec , <nl> - Index . . . indexes ) <nl> + Collection < Index > indexes ) <nl> { <nl> - / / don ' t allow null indexers , if we don ' t have any , use a noop transaction <nl> - for ( Index index : indexes ) assert index ! = null ; <nl> - <nl> this . key = key ; <nl> + this . columns = columns ; <nl> this . versions = versions ; <nl> this . indexes = indexes ; <nl> this . nowInSec = nowInSec ; <nl> @ @ - 957 , 7 + 942 , 10 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> { <nl> for ( Index index : indexes ) <nl> { <nl> - Index . Indexer indexer = index . indexerFor ( key , nowInSec , opGroup , Type . COMPACTION ) ; <nl> + Index . Indexer indexer = index . indexerFor ( key , columns , nowInSec , opGroup , Type . COMPACTION ) ; <nl> + if ( indexer = = null ) <nl> + continue ; <nl> + <nl> indexer . begin ( ) ; <nl> for ( Row row : rows ) <nl> if ( row ! = null ) <nl> @ @ - 977 , 20 + 965 , 20 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> private static final class CleanupGCTransaction implements CleanupTransaction <nl> { <nl> private final DecoratedKey key ; <nl> + private final PartitionColumns columns ; <nl> private final int nowInSec ; <nl> - private final Index [ ] indexes ; <nl> + private final Collection < Index > indexes ; <nl> <nl> private Row row ; <nl> private DeletionTime partitionDelete ; <nl> <nl> private CleanupGCTransaction ( DecoratedKey key , <nl> + PartitionColumns columns , <nl> int nowInSec , <nl> - Index . . . indexes ) <nl> + Collection < Index > indexes ) <nl> { <nl> - / / don ' t allow null indexers , if we don ' t have any , use a noop transaction <nl> - for ( Index index : indexes ) assert index ! = null ; <nl> - <nl> this . key = key ; <nl> + this . columns = columns ; <nl> this . indexes = indexes ; <nl> this . nowInSec = nowInSec ; <nl> } <nl> @ @ - 1018 , 7 + 1006 , 10 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> { <nl> for ( Index index : indexes ) <nl> { <nl> - Index . Indexer indexer = index . indexerFor ( key , nowInSec , opGroup , Type . CLEANUP ) ; <nl> + Index . Indexer indexer = index . indexerFor ( key , columns , nowInSec , opGroup , Type . CLEANUP ) ; <nl> + if ( indexer = = null ) <nl> + continue ; <nl> + <nl> indexer . begin ( ) ; <nl> <nl> if ( partitionDelete ! = null ) <nl> diff - - git a / src / java / org / apache / cassandra / index / internal / CassandraIndex . java b / src / java / org / apache / cassandra / index / internal / CassandraIndex . java <nl> index 717126b . . 6223d8a 100644 <nl> - - - a / src / java / org / apache / cassandra / index / internal / CassandraIndex . java <nl> + + + b / src / java / org / apache / cassandra / index / internal / CassandraIndex . java <nl> @ @ - 217 , 12 + 217 , 6 @ @ public abstract class CassandraIndex implements Index <nl> return true ; <nl> } <nl> <nl> - public boolean indexes ( PartitionColumns columns ) <nl> - { <nl> - / / if we have indexes on the partition key or clustering columns , return true <nl> - return isPrimaryKeyIndex ( ) | | columns . contains ( indexedColumn ) ; <nl> - } <nl> - <nl> public boolean dependsOn ( ColumnDefinition column ) <nl> { <nl> return indexedColumn . name . equals ( column . name ) ; <nl> @ @ - 304 , 19 + 298 , 34 @ @ public abstract class CassandraIndex implements Index <nl> validateClusterings ( update ) ; <nl> break ; <nl> case REGULAR : <nl> - validateRows ( update ) ; <nl> + if ( update . columns ( ) . regulars . contains ( indexedColumn ) ) <nl> + validateRows ( update ) ; <nl> break ; <nl> case STATIC : <nl> - validateRows ( Collections . singleton ( update . staticRow ( ) ) ) ; <nl> + if ( update . columns ( ) . statics . contains ( indexedColumn ) ) <nl> + validateRows ( Collections . singleton ( update . staticRow ( ) ) ) ; <nl> break ; <nl> } <nl> } <nl> <nl> public Indexer indexerFor ( final DecoratedKey key , <nl> + final PartitionColumns columns , <nl> final int nowInSec , <nl> final OpOrder . Group opGroup , <nl> final IndexTransaction . Type transactionType ) <nl> { <nl> + / * * <nl> + * Indexes on regular and static columns ( the non primary - key ones ) only care about updates with live <nl> + * data for the column they index . In particular , they don ' t care about having just row or range deletions <nl> + * as they don ' t know how to update the index table unless they know exactly the value that is deleted . <nl> + * <nl> + * Note that in practice this means that those indexes are only purged of stale entries on compaction , <nl> + * when we resolve both the deletion and the prior data it deletes . Of course , such stale entries are also <nl> + * filtered on read . <nl> + * / <nl> + if ( ! isPrimaryKeyIndex ( ) & & ! columns . contains ( indexedColumn ) ) <nl> + return null ; <nl> + <nl> return new Indexer ( ) <nl> { <nl> public void begin ( ) <nl> @ @ - 359 , 7 + 368 , 6 @ @ public abstract class CassandraIndex implements Index <nl> removeCell ( row . clustering ( ) , row . getCell ( indexedColumn ) ) ; <nl> } <nl> <nl> - <nl> public void updateRow ( Row oldRow , Row newRow ) <nl> { <nl> if ( isPrimaryKeyIndex ( ) ) <nl> diff - - git a / test / unit / org / apache / cassandra / index / StubIndex . java b / test / unit / org / apache / cassandra / index / StubIndex . java <nl> index 834ff87 . . cd0541f 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / StubIndex . java <nl> + + + b / test / unit / org / apache / cassandra / index / StubIndex . java <nl> @ @ - 69 , 11 + 69 , 6 @ @ public class StubIndex implements Index <nl> this . indexMetadata = metadata ; <nl> } <nl> <nl> - public boolean indexes ( PartitionColumns columns ) <nl> - { <nl> - return true ; <nl> - } <nl> - <nl> public boolean shouldBuildBlocking ( ) <nl> { <nl> return false ; <nl> @ @ - 100 , 6 + 95 , 7 @ @ public class StubIndex implements Index <nl> } <nl> <nl> public Indexer indexerFor ( final DecoratedKey key , <nl> + PartitionColumns columns , <nl> int nowInSec , <nl> OpOrder . Group opGroup , <nl> IndexTransaction . Type transactionType ) <nl> diff - - git a / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java b / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java <nl> index 3bce683 . . a30cf4e 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java <nl> + + + b / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java <nl> @ @ - 162 , 12 + 162 , 6 @ @ public class CustomCassandraIndex implements Index <nl> return true ; <nl> } <nl> <nl> - public boolean indexes ( PartitionColumns columns ) <nl> - { <nl> - / / if we have indexes on the partition key or clustering columns , return true <nl> - return isPrimaryKeyIndex ( ) | | columns . contains ( indexedColumn ) ; <nl> - } <nl> - <nl> public boolean dependsOn ( ColumnDefinition column ) <nl> { <nl> return column . equals ( indexedColumn ) ; <nl> @ @ - 271 , 10 + 265 , 14 @ @ public class CustomCassandraIndex implements Index <nl> } <nl> <nl> public Indexer indexerFor ( final DecoratedKey key , <nl> + final PartitionColumns columns , <nl> final int nowInSec , <nl> final OpOrder . Group opGroup , <nl> final IndexTransaction . Type transactionType ) <nl> { <nl> + if ( ! isPrimaryKeyIndex ( ) & & ! columns . contains ( indexedColumn ) ) <nl> + return null ; <nl> + <nl> return new Indexer ( ) <nl> { <nl> public void begin ( )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 4dd1b97 . . 507a709 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 1 
 + * Remove unclear Indexer . indexes ( ) method ( CASSANDRA - 10690 ) 
 * Fix NPE on stream read error ( CASSANDRA - 10771 ) 
 * Normalize cqlsh DESC output ( CASSANDRA - 10431 ) 
 * Rejects partition range deletions when columns are specified ( CASSANDRA - 10739 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 9cebf58 . . b3c304a 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 20 , 6 + 20 , 9 @ @ Upgrading 
 - - - - - - - - - 
 - The return value of SelectStatement : : getLimit as been changed from DataLimits 
 to int . 
 + - Custom index implementation should be aware that the method Indexer : : indexes ( ) 
 + has been removed as its contract was misleading and all custom implementation 
 + should have almost surely returned true inconditionally for that method . 
 
 
 3 . 0 
 diff - - git a / src / java / org / apache / cassandra / index / Index . java b / src / java / org / apache / cassandra / index / Index . java 
 index b6c12a9 . . 084d0e3 100644 
 - - - a / src / java / org / apache / cassandra / index / Index . java 
 + + + b / src / java / org / apache / cassandra / index / Index . java 
 @ @ - 191 , 13 + 191 , 6 @ @ public interface Index 
 * / 
 
 / * * 
 - * Called to determine whether this index should process a particular partition update . 
 - * @ param columns 
 - * @ return 
 - * / 
 - public boolean indexes ( PartitionColumns columns ) ; 
 - 
 - / * * 
 * Called to determine whether this index targets a specific column . 
 * Used during schema operations such as when dropping or renaming a column , to check if 
 * the index will be affected by the change . Typically , if an index answers that it does 
 @ @ - 275 , 19 + 268 , 22 @ @ public interface Index 
 * / 
 
 / * * 
 - * Factory method for write time event handlers . 
 - * Callers should check the indexes method first and only get a new 
 - * handler when the index claims an interest in the specific update 
 - * otherwise work may be done unnecessarily 
 + * Creates an new { @ code Indexer } object for updates to a given partition . 
 * 
 * @ param key key of the partition being modified 
 + * @ param columns the regular and static columns the created indexer will have to deal with . 
 + * This can be empty as an update might only contain partition , range and row deletions , but 
 + * the indexer is guaranteed to not get any cells for a column that is not part of { @ code columns } . 
 * @ param nowInSec current time of the update operation 
 * @ param opGroup operation group spanning the update operation 
 * @ param transactionType indicates what kind of update is being performed on the base data 
 * i . e . a write time insert / update / delete or the result of compaction 
 - * @ return 
 + * @ return the newly created indexer or { @ code null } if the index is not interested by the update 
 + * ( this could be because the index doesn ' t care about that particular partition , doesn ' t care about 
 + * that type of transaction , . . . ) . 
 * / 
 public Indexer indexerFor ( DecoratedKey key , 
 + PartitionColumns columns , 
 int nowInSec , 
 OpOrder . Group opGroup , 
 IndexTransaction . Type transactionType ) ; 
 diff - - git a / src / java / org / apache / cassandra / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / index / SecondaryIndexManager . java 
 index ba2c680 . . 16cb9c4 100644 
 - - - a / src / java / org / apache / cassandra / index / SecondaryIndexManager . java 
 + + + b / src / java / org / apache / cassandra / index / SecondaryIndexManager . java 
 @ @ - 524 , 9 + 524 , 11 @ @ public class SecondaryIndexManager implements IndexRegistry 
 DecoratedKey key = partition . partitionKey ( ) ; 
 Set < Index . Indexer > indexers = indexes . stream ( ) 
 . map ( index - > index . indexerFor ( key , 
 + partition . columns ( ) , 
 nowInSec , 
 opGroup , 
 IndexTransaction . Type . UPDATE ) ) 
 + . filter ( Objects : : nonNull ) 
 . collect ( Collectors . toSet ( ) ) ; 
 
 indexers . forEach ( Index . Indexer : : begin ) ; 
 @ @ - 666 , 10 + 668 , 8 @ @ public class SecondaryIndexManager implements IndexRegistry 
 * / 
 public void validate ( PartitionUpdate update ) throws InvalidRequestException 
 { 
 - indexes . values ( ) 
 - . stream ( ) 
 - . filter ( i - > i . indexes ( update . columns ( ) ) ) 
 - . forEach ( i - > i . validate ( update ) ) ; 
 + for ( Index index : indexes . values ( ) ) 
 + index . validate ( update ) ; 
 } 
 
 / * * 
 @ @ - 720 , 15 + 720 , 13 @ @ public class SecondaryIndexManager implements IndexRegistry 
 if ( ! hasIndexes ( ) ) 
 return UpdateTransaction . NO _ OP ; 
 
 - / / todo : optimize lookup , we can probably cache quite a bit of stuff , rather than doing 
 - / / a linear scan every time . Holding off that though until CASSANDRA - 7771 to figure out 
 - / / exactly how indexes are to be identified & associated with a given partition update 
 Index . Indexer [ ] indexers = indexes . values ( ) . stream ( ) 
 - . filter ( i - > i . indexes ( update . columns ( ) ) ) 
 . map ( i - > i . indexerFor ( update . partitionKey ( ) , 
 + update . columns ( ) , 
 nowInSec , 
 opGroup , 
 IndexTransaction . Type . UPDATE ) ) 
 + . filter ( Objects : : nonNull ) 
 . toArray ( Index . Indexer [ ] : : new ) ; 
 
 return indexers . length = = 0 ? UpdateTransaction . NO _ OP : new WriteTimeTransaction ( indexers ) ; 
 @ @ - 743 , 14 + 741 , 7 @ @ public class SecondaryIndexManager implements IndexRegistry 
 int nowInSec ) 
 { 
 / / the check for whether there are any registered indexes is already done in CompactionIterator 
 - 
 - Index [ ] interestedIndexes = indexes . values ( ) . stream ( ) 
 - . filter ( i - > i . indexes ( partitionColumns ) ) 
 - . toArray ( Index [ ] : : new ) ; 
 - 
 - return interestedIndexes . length = = 0 
 - ? CompactionTransaction . NO _ OP 
 - : new IndexGCTransaction ( key , versions , nowInSec , interestedIndexes ) ; 
 + return new IndexGCTransaction ( key , partitionColumns , versions , nowInSec , listIndexes ( ) ) ; 
 } 
 
 / * * 
 @ @ - 760 , 17 + 751 , 10 @ @ public class SecondaryIndexManager implements IndexRegistry 
 PartitionColumns partitionColumns , 
 int nowInSec ) 
 { 
 - / / 
 if ( ! hasIndexes ( ) ) 
 return CleanupTransaction . NO _ OP ; 
 
 - Index [ ] interestedIndexes = indexes . values ( ) . stream ( ) 
 - . filter ( i - > i . indexes ( partitionColumns ) ) 
 - . toArray ( Index [ ] : : new ) ; 
 - 
 - return interestedIndexes . length = = 0 
 - ? CleanupTransaction . NO _ OP 
 - : new CleanupGCTransaction ( key , nowInSec , interestedIndexes ) ; 
 + return new CleanupGCTransaction ( key , partitionColumns , nowInSec , listIndexes ( ) ) ; 
 } 
 
 / * * 
 @ @ - 807 , 7 + 791 , 8 @ @ public class SecondaryIndexManager implements IndexRegistry 
 
 public void onInserted ( Row row ) 
 { 
 - Arrays . stream ( indexers ) . forEach ( h - > h . insertRow ( row ) ) ; 
 + for ( Index . Indexer indexer : indexers ) 
 + indexer . insertRow ( row ) ; 
 } 
 
 public void onUpdated ( Row existing , Row updated ) 
 @ @ - 882 , 21 + 867 , 21 @ @ public class SecondaryIndexManager implements IndexRegistry 
 private static final class IndexGCTransaction implements CompactionTransaction 
 { 
 private final DecoratedKey key ; 
 + private final PartitionColumns columns ; 
 private final int versions ; 
 private final int nowInSec ; 
 - private final Index [ ] indexes ; 
 + private final Collection < Index > indexes ; 
 
 private Row [ ] rows ; 
 
 private IndexGCTransaction ( DecoratedKey key , 
 + PartitionColumns columns , 
 int versions , 
 int nowInSec , 
 - Index . . . indexes ) 
 + Collection < Index > indexes ) 
 { 
 - / / don ' t allow null indexers , if we don ' t have any , use a noop transaction 
 - for ( Index index : indexes ) assert index ! = null ; 
 - 
 this . key = key ; 
 + this . columns = columns ; 
 this . versions = versions ; 
 this . indexes = indexes ; 
 this . nowInSec = nowInSec ; 
 @ @ - 957 , 7 + 942 , 10 @ @ public class SecondaryIndexManager implements IndexRegistry 
 { 
 for ( Index index : indexes ) 
 { 
 - Index . Indexer indexer = index . indexerFor ( key , nowInSec , opGroup , Type . COMPACTION ) ; 
 + Index . Indexer indexer = index . indexerFor ( key , columns , nowInSec , opGroup , Type . COMPACTION ) ; 
 + if ( indexer = = null ) 
 + continue ; 
 + 
 indexer . begin ( ) ; 
 for ( Row row : rows ) 
 if ( row ! = null ) 
 @ @ - 977 , 20 + 965 , 20 @ @ public class SecondaryIndexManager implements IndexRegistry 
 private static final class CleanupGCTransaction implements CleanupTransaction 
 { 
 private final DecoratedKey key ; 
 + private final PartitionColumns columns ; 
 private final int nowInSec ; 
 - private final Index [ ] indexes ; 
 + private final Collection < Index > indexes ; 
 
 private Row row ; 
 private DeletionTime partitionDelete ; 
 
 private CleanupGCTransaction ( DecoratedKey key , 
 + PartitionColumns columns , 
 int nowInSec , 
 - Index . . . indexes ) 
 + Collection < Index > indexes ) 
 { 
 - / / don ' t allow null indexers , if we don ' t have any , use a noop transaction 
 - for ( Index index : indexes ) assert index ! = null ; 
 - 
 this . key = key ; 
 + this . columns = columns ; 
 this . indexes = indexes ; 
 this . nowInSec = nowInSec ; 
 } 
 @ @ - 1018 , 7 + 1006 , 10 @ @ public class SecondaryIndexManager implements IndexRegistry 
 { 
 for ( Index index : indexes ) 
 { 
 - Index . Indexer indexer = index . indexerFor ( key , nowInSec , opGroup , Type . CLEANUP ) ; 
 + Index . Indexer indexer = index . indexerFor ( key , columns , nowInSec , opGroup , Type . CLEANUP ) ; 
 + if ( indexer = = null ) 
 + continue ; 
 + 
 indexer . begin ( ) ; 
 
 if ( partitionDelete ! = null ) 
 diff - - git a / src / java / org / apache / cassandra / index / internal / CassandraIndex . java b / src / java / org / apache / cassandra / index / internal / CassandraIndex . java 
 index 717126b . . 6223d8a 100644 
 - - - a / src / java / org / apache / cassandra / index / internal / CassandraIndex . java 
 + + + b / src / java / org / apache / cassandra / index / internal / CassandraIndex . java 
 @ @ - 217 , 12 + 217 , 6 @ @ public abstract class CassandraIndex implements Index 
 return true ; 
 } 
 
 - public boolean indexes ( PartitionColumns columns ) 
 - { 
 - / / if we have indexes on the partition key or clustering columns , return true 
 - return isPrimaryKeyIndex ( ) | | columns . contains ( indexedColumn ) ; 
 - } 
 - 
 public boolean dependsOn ( ColumnDefinition column ) 
 { 
 return indexedColumn . name . equals ( column . name ) ; 
 @ @ - 304 , 19 + 298 , 34 @ @ public abstract class CassandraIndex implements Index 
 validateClusterings ( update ) ; 
 break ; 
 case REGULAR : 
 - validateRows ( update ) ; 
 + if ( update . columns ( ) . regulars . contains ( indexedColumn ) ) 
 + validateRows ( update ) ; 
 break ; 
 case STATIC : 
 - validateRows ( Collections . singleton ( update . staticRow ( ) ) ) ; 
 + if ( update . columns ( ) . statics . contains ( indexedColumn ) ) 
 + validateRows ( Collections . singleton ( update . staticRow ( ) ) ) ; 
 break ; 
 } 
 } 
 
 public Indexer indexerFor ( final DecoratedKey key , 
 + final PartitionColumns columns , 
 final int nowInSec , 
 final OpOrder . Group opGroup , 
 final IndexTransaction . Type transactionType ) 
 { 
 + / * * 
 + * Indexes on regular and static columns ( the non primary - key ones ) only care about updates with live 
 + * data for the column they index . In particular , they don ' t care about having just row or range deletions 
 + * as they don ' t know how to update the index table unless they know exactly the value that is deleted . 
 + * 
 + * Note that in practice this means that those indexes are only purged of stale entries on compaction , 
 + * when we resolve both the deletion and the prior data it deletes . Of course , such stale entries are also 
 + * filtered on read . 
 + * / 
 + if ( ! isPrimaryKeyIndex ( ) & & ! columns . contains ( indexedColumn ) ) 
 + return null ; 
 + 
 return new Indexer ( ) 
 { 
 public void begin ( ) 
 @ @ - 359 , 7 + 368 , 6 @ @ public abstract class CassandraIndex implements Index 
 removeCell ( row . clustering ( ) , row . getCell ( indexedColumn ) ) ; 
 } 
 
 - 
 public void updateRow ( Row oldRow , Row newRow ) 
 { 
 if ( isPrimaryKeyIndex ( ) ) 
 diff - - git a / test / unit / org / apache / cassandra / index / StubIndex . java b / test / unit / org / apache / cassandra / index / StubIndex . java 
 index 834ff87 . . cd0541f 100644 
 - - - a / test / unit / org / apache / cassandra / index / StubIndex . java 
 + + + b / test / unit / org / apache / cassandra / index / StubIndex . java 
 @ @ - 69 , 11 + 69 , 6 @ @ public class StubIndex implements Index 
 this . indexMetadata = metadata ; 
 } 
 
 - public boolean indexes ( PartitionColumns columns ) 
 - { 
 - return true ; 
 - } 
 - 
 public boolean shouldBuildBlocking ( ) 
 { 
 return false ; 
 @ @ - 100 , 6 + 95 , 7 @ @ public class StubIndex implements Index 
 } 
 
 public Indexer indexerFor ( final DecoratedKey key , 
 + PartitionColumns columns , 
 int nowInSec , 
 OpOrder . Group opGroup , 
 IndexTransaction . Type transactionType ) 
 diff - - git a / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java b / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java 
 index 3bce683 . . a30cf4e 100644 
 - - - a / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java 
 + + + b / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java 
 @ @ - 162 , 12 + 162 , 6 @ @ public class CustomCassandraIndex implements Index 
 return true ; 
 } 
 
 - public boolean indexes ( PartitionColumns columns ) 
 - { 
 - / / if we have indexes on the partition key or clustering columns , return true 
 - return isPrimaryKeyIndex ( ) | | columns . contains ( indexedColumn ) ; 
 - } 
 - 
 public boolean dependsOn ( ColumnDefinition column ) 
 { 
 return column . equals ( indexedColumn ) ; 
 @ @ - 271 , 10 + 265 , 14 @ @ public class CustomCassandraIndex implements Index 
 } 
 
 public Indexer indexerFor ( final DecoratedKey key , 
 + final PartitionColumns columns , 
 final int nowInSec , 
 final OpOrder . Group opGroup , 
 final IndexTransaction . Type transactionType ) 
 { 
 + if ( ! isPrimaryKeyIndex ( ) & & ! columns . contains ( indexedColumn ) ) 
 + return null ; 
 + 
 return new Indexer ( ) 
 { 
 public void begin ( )

NEAREST DIFF:
ELIMINATEDSENTENCE
