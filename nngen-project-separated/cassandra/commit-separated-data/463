BLEU SCORE: 0.0241596535992123

TEST MSG: add ns timeunit marker to logger output
GENERATED MSG: Fix bug where the FailureDetector can take a very long time to mark a

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / gms / FailureDetector . java b / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> index c73cc07 . . e5a29d6 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> + + + b / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> @ @ - 270 , 7 + 270 , 7 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean <nl> } <nl> <nl> if ( logger . isTraceEnabled ( ) & & heartbeatWindow ! = null ) <nl> - logger . trace ( " Average for { } is { } " , ep , heartbeatWindow . mean ( ) ) ; <nl> + logger . trace ( " Average for { } is { } ns " , ep , heartbeatWindow . mean ( ) ) ; <nl> } <nl> <nl> public void interpret ( InetAddress ep ) <nl> @ @ - 285 , 7 + 285 , 7 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean <nl> lastInterpret = now ; <nl> if ( diff > MAX _ LOCAL _ PAUSE _ IN _ NANOS ) <nl> { <nl> - logger . warn ( " Not marking nodes down due to local pause of { } > { } " , diff , MAX _ LOCAL _ PAUSE _ IN _ NANOS ) ; <nl> + logger . warn ( " Not marking nodes down due to local pause of { } ns > { } ns " , diff , MAX _ LOCAL _ PAUSE _ IN _ NANOS ) ; <nl> lastPause = now ; <nl> return ; <nl> } <nl> @ @ - 301 , 7 + 301 , 7 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean <nl> if ( PHI _ FACTOR * phi > getPhiConvictThreshold ( ) ) <nl> { <nl> if ( logger . isTraceEnabled ( ) ) <nl> - logger . trace ( " Node { } phi { } > { } ; intervals : { } mean : { } " , new Object [ ] { ep , PHI _ FACTOR * phi , getPhiConvictThreshold ( ) , hbWnd , hbWnd . mean ( ) } ) ; <nl> + logger . trace ( " Node { } phi { } > { } ; intervals : { } mean : { } ns " , new Object [ ] { ep , PHI _ FACTOR * phi , getPhiConvictThreshold ( ) , hbWnd , hbWnd . mean ( ) } ) ; <nl> for ( IFailureDetectionEventListener listener : fdEvntListeners ) <nl> { <nl> listener . convict ( ep , phi ) ; <nl> @ @ - 314 , 7 + 314 , 7 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean <nl> else if ( logger . isTraceEnabled ( ) ) <nl> { <nl> logger . trace ( " PHI for { } : { } " , ep , phi ) ; <nl> - logger . trace ( " mean for { } : { } " , ep , hbWnd . mean ( ) ) ; <nl> + logger . trace ( " mean for { } : { } ns " , ep , hbWnd . mean ( ) ) ; <nl> } <nl> } <nl> <nl> @ @ - 450 , 11 + 450 , 11 @ @ class ArrivalWindow <nl> if ( interArrivalTime < = MAX _ INTERVAL _ IN _ NANO ) <nl> { <nl> arrivalIntervals . add ( interArrivalTime ) ; <nl> - logger . trace ( " Reporting interval time of { } for { } " , interArrivalTime , ep ) ; <nl> + logger . trace ( " Reporting interval time of { } ns for { } " , interArrivalTime , ep ) ; <nl> } <nl> else <nl> { <nl> - logger . debug ( " Ignoring interval time of { } for { } " , interArrivalTime , ep ) ; <nl> + logger . debug ( " Ignoring interval time of { } ns for { } " , interArrivalTime , ep ) ; <nl> } <nl> } <nl> else
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 0e028f5 . . 47b7366 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 18 , 6 + 18 , 8 @ @ <nl> * ( Hadoop ) allow wrapping ranges in queries ( CASSANDRA - 3137 ) <nl> * ( Hadoop ) check all interfaces for a match with split location <nl> before falling back to random replica ( CASSANDRA - 3211 ) <nl> + * Fix bug where the failure detector can take too long to mark a host <nl> + down ( CASSANDRA - 3273 ) <nl> <nl> <nl> 0 . 8 . 6 <nl> diff - - git a / src / java / org / apache / cassandra / gms / FailureDetector . java b / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> index 2f045ef . . ebe5132 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> + + + b / src / java / org / apache / cassandra / gms / FailureDetector . java <nl> @ @ - 121 , 7 + 121 , 14 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean <nl> logger _ . error ( " unknown endpoint " + ep ) ; <nl> return epState ! = null & & epState . isAlive ( ) ; <nl> } <nl> - <nl> + <nl> + public void clear ( InetAddress ep ) <nl> + { <nl> + ArrivalWindow heartbeatWindow = arrivalSamples _ . get ( ep ) ; <nl> + if ( heartbeatWindow ! = null ) <nl> + heartbeatWindow . clear ( ) ; <nl> + } <nl> + <nl> public void report ( InetAddress ep ) <nl> { <nl> if ( logger _ . isTraceEnabled ( ) ) <nl> @ @ - 149 , 7 + 156 , 9 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean <nl> logger _ . trace ( " PHI for " + ep + " : " + phi ) ; <nl> <nl> if ( phi > phiConvictThreshold _ ) <nl> - { <nl> + { <nl> + logger _ . trace ( " notifying listeners that { } is down " , ep ) ; <nl> + logger _ . trace ( " intervals : { } mean : { } " , hbWnd , hbWnd . mean ( ) ) ; <nl> for ( IFailureDetectionEventListener listener : fdEvntListeners _ ) <nl> { <nl> listener . convict ( ep , phi ) ; <nl> @ @ - 206 , 6 + 215 , 11 @ @ class ArrivalWindow <nl> / / change . <nl> private final double PHI _ FACTOR = 1 . 0 / Math . log ( 10 . 0 ) ; <nl> <nl> + / / in the event of a long partition , never record an interval longer than the rpc timeout , <nl> + / / since if a host is regularly experiencing connectivity problems lasting this long we ' d <nl> + / / rather mark it down quickly instead of adapting <nl> + private final double MAX _ INTERVAL _ IN _ MS = DatabaseDescriptor . getRpcTimeout ( ) ; <nl> + <nl> ArrivalWindow ( int size ) <nl> { <nl> arrivalIntervals _ = new BoundedStatsDeque ( size ) ; <nl> @ @ - 216 , 14 + 230 , 17 @ @ class ArrivalWindow <nl> double interArrivalTime ; <nl> if ( tLast _ > 0L ) <nl> { <nl> - interArrivalTime = ( value - tLast _ ) ; <nl> + interArrivalTime = ( value - tLast _ ) ; <nl> } <nl> else <nl> { <nl> interArrivalTime = Gossiper . intervalInMillis / 2 ; <nl> } <nl> - tLast _ = value ; <nl> - arrivalIntervals _ . add ( interArrivalTime ) ; <nl> + if ( interArrivalTime < = MAX _ INTERVAL _ IN _ MS ) <nl> + arrivalIntervals _ . add ( interArrivalTime ) ; <nl> + else <nl> + logger _ . debug ( " Ignoring interval time of { } " , interArrivalTime ) ; <nl> + tLast _ = value ; <nl> } <nl> <nl> synchronized double sum ( ) <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index 0efb94f . . 3c92aaf 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 665 , 6 + 665 , 13 @ @ public class Gossiper implements IFailureDetectionEventListener <nl> if ( remoteGeneration > localGeneration ) <nl> { <nl> localEndpointState . updateTimestamp ( ) ; <nl> + / / this node was dead and the generation changed , this indicates a reboot , or possibly a takeover <nl> + / / we will clean the fd intervals for it and relearn them <nl> + if ( ! localEndpointState . isAlive ( ) ) <nl> + { <nl> + logger . debug ( " Clearing interval times for { } due to generation change " , endpoint ) ; <nl> + fd . clear ( endpoint ) ; <nl> + } <nl> fd . report ( endpoint ) ; <nl> return ; <nl> } <nl> @ @ - 676 , 6 + 683 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener <nl> if ( remoteVersion > localVersion ) <nl> { <nl> localEndpointState . updateTimestamp ( ) ; <nl> + / / just a version change , report to the fd <nl> fd . report ( endpoint ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / gms / IFailureDetector . java b / src / java / org / apache / cassandra / gms / IFailureDetector . java <nl> index 426eec8 . . df12bb4 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / IFailureDetector . java <nl> + + + b / src / java / org / apache / cassandra / gms / IFailureDetector . java <nl> @ @ - 37 , 7 + 37 , 13 @ @ public interface IFailureDetector <nl> * @ return true if UP and false if DOWN . <nl> * / <nl> public boolean isAlive ( InetAddress ep ) ; <nl> - <nl> + <nl> + / * * <nl> + * Clear any existing interval timings for this endpoint <nl> + * @ param ep <nl> + * / <nl> + public void clear ( InetAddress ep ) ; <nl> + <nl> / * * <nl> * This method is invoked by any entity wanting to interrogate the status of an endpoint . <nl> * In our case it would be the Gossiper . The Failure Detector will then calculate Phi and

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / gms / FailureDetector . java b / src / java / org / apache / cassandra / gms / FailureDetector . java 
 index c73cc07 . . e5a29d6 100644 
 - - - a / src / java / org / apache / cassandra / gms / FailureDetector . java 
 + + + b / src / java / org / apache / cassandra / gms / FailureDetector . java 
 @ @ - 270 , 7 + 270 , 7 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean 
 } 
 
 if ( logger . isTraceEnabled ( ) & & heartbeatWindow ! = null ) 
 - logger . trace ( " Average for { } is { } " , ep , heartbeatWindow . mean ( ) ) ; 
 + logger . trace ( " Average for { } is { } ns " , ep , heartbeatWindow . mean ( ) ) ; 
 } 
 
 public void interpret ( InetAddress ep ) 
 @ @ - 285 , 7 + 285 , 7 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean 
 lastInterpret = now ; 
 if ( diff > MAX _ LOCAL _ PAUSE _ IN _ NANOS ) 
 { 
 - logger . warn ( " Not marking nodes down due to local pause of { } > { } " , diff , MAX _ LOCAL _ PAUSE _ IN _ NANOS ) ; 
 + logger . warn ( " Not marking nodes down due to local pause of { } ns > { } ns " , diff , MAX _ LOCAL _ PAUSE _ IN _ NANOS ) ; 
 lastPause = now ; 
 return ; 
 } 
 @ @ - 301 , 7 + 301 , 7 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean 
 if ( PHI _ FACTOR * phi > getPhiConvictThreshold ( ) ) 
 { 
 if ( logger . isTraceEnabled ( ) ) 
 - logger . trace ( " Node { } phi { } > { } ; intervals : { } mean : { } " , new Object [ ] { ep , PHI _ FACTOR * phi , getPhiConvictThreshold ( ) , hbWnd , hbWnd . mean ( ) } ) ; 
 + logger . trace ( " Node { } phi { } > { } ; intervals : { } mean : { } ns " , new Object [ ] { ep , PHI _ FACTOR * phi , getPhiConvictThreshold ( ) , hbWnd , hbWnd . mean ( ) } ) ; 
 for ( IFailureDetectionEventListener listener : fdEvntListeners ) 
 { 
 listener . convict ( ep , phi ) ; 
 @ @ - 314 , 7 + 314 , 7 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean 
 else if ( logger . isTraceEnabled ( ) ) 
 { 
 logger . trace ( " PHI for { } : { } " , ep , phi ) ; 
 - logger . trace ( " mean for { } : { } " , ep , hbWnd . mean ( ) ) ; 
 + logger . trace ( " mean for { } : { } ns " , ep , hbWnd . mean ( ) ) ; 
 } 
 } 
 
 @ @ - 450 , 11 + 450 , 11 @ @ class ArrivalWindow 
 if ( interArrivalTime < = MAX _ INTERVAL _ IN _ NANO ) 
 { 
 arrivalIntervals . add ( interArrivalTime ) ; 
 - logger . trace ( " Reporting interval time of { } for { } " , interArrivalTime , ep ) ; 
 + logger . trace ( " Reporting interval time of { } ns for { } " , interArrivalTime , ep ) ; 
 } 
 else 
 { 
 - logger . debug ( " Ignoring interval time of { } for { } " , interArrivalTime , ep ) ; 
 + logger . debug ( " Ignoring interval time of { } ns for { } " , interArrivalTime , ep ) ; 
 } 
 } 
 else

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 0e028f5 . . 47b7366 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 18 , 6 + 18 , 8 @ @ 
 * ( Hadoop ) allow wrapping ranges in queries ( CASSANDRA - 3137 ) 
 * ( Hadoop ) check all interfaces for a match with split location 
 before falling back to random replica ( CASSANDRA - 3211 ) 
 + * Fix bug where the failure detector can take too long to mark a host 
 + down ( CASSANDRA - 3273 ) 
 
 
 0 . 8 . 6 
 diff - - git a / src / java / org / apache / cassandra / gms / FailureDetector . java b / src / java / org / apache / cassandra / gms / FailureDetector . java 
 index 2f045ef . . ebe5132 100644 
 - - - a / src / java / org / apache / cassandra / gms / FailureDetector . java 
 + + + b / src / java / org / apache / cassandra / gms / FailureDetector . java 
 @ @ - 121 , 7 + 121 , 14 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean 
 logger _ . error ( " unknown endpoint " + ep ) ; 
 return epState ! = null & & epState . isAlive ( ) ; 
 } 
 - 
 + 
 + public void clear ( InetAddress ep ) 
 + { 
 + ArrivalWindow heartbeatWindow = arrivalSamples _ . get ( ep ) ; 
 + if ( heartbeatWindow ! = null ) 
 + heartbeatWindow . clear ( ) ; 
 + } 
 + 
 public void report ( InetAddress ep ) 
 { 
 if ( logger _ . isTraceEnabled ( ) ) 
 @ @ - 149 , 7 + 156 , 9 @ @ public class FailureDetector implements IFailureDetector , FailureDetectorMBean 
 logger _ . trace ( " PHI for " + ep + " : " + phi ) ; 
 
 if ( phi > phiConvictThreshold _ ) 
 - { 
 + { 
 + logger _ . trace ( " notifying listeners that { } is down " , ep ) ; 
 + logger _ . trace ( " intervals : { } mean : { } " , hbWnd , hbWnd . mean ( ) ) ; 
 for ( IFailureDetectionEventListener listener : fdEvntListeners _ ) 
 { 
 listener . convict ( ep , phi ) ; 
 @ @ - 206 , 6 + 215 , 11 @ @ class ArrivalWindow 
 / / change . 
 private final double PHI _ FACTOR = 1 . 0 / Math . log ( 10 . 0 ) ; 
 
 + / / in the event of a long partition , never record an interval longer than the rpc timeout , 
 + / / since if a host is regularly experiencing connectivity problems lasting this long we ' d 
 + / / rather mark it down quickly instead of adapting 
 + private final double MAX _ INTERVAL _ IN _ MS = DatabaseDescriptor . getRpcTimeout ( ) ; 
 + 
 ArrivalWindow ( int size ) 
 { 
 arrivalIntervals _ = new BoundedStatsDeque ( size ) ; 
 @ @ - 216 , 14 + 230 , 17 @ @ class ArrivalWindow 
 double interArrivalTime ; 
 if ( tLast _ > 0L ) 
 { 
 - interArrivalTime = ( value - tLast _ ) ; 
 + interArrivalTime = ( value - tLast _ ) ; 
 } 
 else 
 { 
 interArrivalTime = Gossiper . intervalInMillis / 2 ; 
 } 
 - tLast _ = value ; 
 - arrivalIntervals _ . add ( interArrivalTime ) ; 
 + if ( interArrivalTime < = MAX _ INTERVAL _ IN _ MS ) 
 + arrivalIntervals _ . add ( interArrivalTime ) ; 
 + else 
 + logger _ . debug ( " Ignoring interval time of { } " , interArrivalTime ) ; 
 + tLast _ = value ; 
 } 
 
 synchronized double sum ( ) 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index 0efb94f . . 3c92aaf 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 665 , 6 + 665 , 13 @ @ public class Gossiper implements IFailureDetectionEventListener 
 if ( remoteGeneration > localGeneration ) 
 { 
 localEndpointState . updateTimestamp ( ) ; 
 + / / this node was dead and the generation changed , this indicates a reboot , or possibly a takeover 
 + / / we will clean the fd intervals for it and relearn them 
 + if ( ! localEndpointState . isAlive ( ) ) 
 + { 
 + logger . debug ( " Clearing interval times for { } due to generation change " , endpoint ) ; 
 + fd . clear ( endpoint ) ; 
 + } 
 fd . report ( endpoint ) ; 
 return ; 
 } 
 @ @ - 676 , 6 + 683 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener 
 if ( remoteVersion > localVersion ) 
 { 
 localEndpointState . updateTimestamp ( ) ; 
 + / / just a version change , report to the fd 
 fd . report ( endpoint ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / gms / IFailureDetector . java b / src / java / org / apache / cassandra / gms / IFailureDetector . java 
 index 426eec8 . . df12bb4 100644 
 - - - a / src / java / org / apache / cassandra / gms / IFailureDetector . java 
 + + + b / src / java / org / apache / cassandra / gms / IFailureDetector . java 
 @ @ - 37 , 7 + 37 , 13 @ @ public interface IFailureDetector 
 * @ return true if UP and false if DOWN . 
 * / 
 public boolean isAlive ( InetAddress ep ) ; 
 - 
 + 
 + / * * 
 + * Clear any existing interval timings for this endpoint 
 + * @ param ep 
 + * / 
 + public void clear ( InetAddress ep ) ; 
 + 
 / * * 
 * This method is invoked by any entity wanting to interrogate the status of an endpoint . 
 * In our case it would be the Gossiper . The Failure Detector will then calculate Phi and
