BLEU SCORE: 0.11386050660556932

TEST MSG: Ensure atomicity inside thrift and stream session
GENERATED MSG: Fix SSTable not released if stream session fails

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 4ef77ed . . 5cfc347 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 10 , 6 + 10 , 7 @ @ <nl> config file or environment variables ( CASSANDRA - 9544 ) <nl> * Remove repair snapshot leftover on startup ( CASSANDRA - 7357 ) <nl> * Use random nodes for batch log when only 2 racks ( CASSANDRA - 8735 ) <nl> + * Ensure atomicity inside thrift and stream session ( CASSANDRA - 7757 ) <nl> Merged from 2 . 0 : <nl> * Log when messages are dropped due to cross _ node _ timeout ( CASSANDRA - 9793 ) <nl> * checkForEndpointCollision fails for legitimate collisions ( CASSANDRA - 9765 ) <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> index 1edfedb . . 63219d8 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> @ @ - 137 , 7 + 137 , 7 @ @ public class StreamSession implements IEndpointStateChangeSubscriber <nl> / / stream requests to send to the peer <nl> private final Set < StreamRequest > requests = Sets . newConcurrentHashSet ( ) ; <nl> / / streaming tasks are created and managed per ColumnFamily ID <nl> - private final Map < UUID , StreamTransferTask > transfers = new ConcurrentHashMap < > ( ) ; <nl> + private final ConcurrentHashMap < UUID , StreamTransferTask > transfers = new ConcurrentHashMap < > ( ) ; <nl> / / data receivers , filled after receiving prepare message <nl> private final Map < UUID , StreamReceiveTask > receivers = new ConcurrentHashMap < > ( ) ; <nl> private final StreamingMetrics metrics ; <nl> @ @ - 369 , 8 + 369 , 11 @ @ public class StreamSession implements IEndpointStateChangeSubscriber <nl> StreamTransferTask task = transfers . get ( cfId ) ; <nl> if ( task = = null ) <nl> { <nl> - task = new StreamTransferTask ( this , cfId ) ; <nl> - transfers . put ( cfId , task ) ; <nl> + / / guarantee atomicity <nl> + StreamTransferTask newTask = new StreamTransferTask ( this , cfId ) ; <nl> + task = transfers . putIfAbsent ( cfId , newTask ) ; <nl> + if ( task = = null ) <nl> + task = newTask ; <nl> } <nl> task . addTransferFile ( details . ref , details . estimatedKeys , details . sections , details . repairedAt ) ; <nl> iter . remove ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / thrift / ThriftSessionManager . java b / src / java / org / apache / cassandra / thrift / ThriftSessionManager . java <nl> index ed3df6d . . 6caa558 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / ThriftSessionManager . java <nl> + + + b / src / java / org / apache / cassandra / thrift / ThriftSessionManager . java <nl> @ @ - 36 , 7 + 36 , 7 @ @ public class ThriftSessionManager <nl> public final static ThriftSessionManager instance = new ThriftSessionManager ( ) ; <nl> <nl> private final ThreadLocal < SocketAddress > remoteSocket = new ThreadLocal < > ( ) ; <nl> - private final Map < SocketAddress , ThriftClientState > activeSocketSessions = new ConcurrentHashMap < > ( ) ; <nl> + private final ConcurrentHashMap < SocketAddress , ThriftClientState > activeSocketSessions = new ConcurrentHashMap < > ( ) ; <nl> <nl> / * * <nl> * @ param socket the address on which the current thread will work on requests for until further notice <nl> @ @ - 57 , 8 + 57 , 11 @ @ public class ThriftSessionManager <nl> ThriftClientState cState = activeSocketSessions . get ( socket ) ; <nl> if ( cState = = null ) <nl> { <nl> - cState = new ThriftClientState ( socket ) ; <nl> - activeSocketSessions . put ( socket , cState ) ; <nl> + / / guarantee atomicity <nl> + ThriftClientState newState = new ThriftClientState ( socket ) ; <nl> + cState = activeSocketSessions . putIfAbsent ( socket , newState ) ; <nl> + if ( cState = = null ) <nl> + cState = newState ; <nl> } <nl> return cState ; <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 4ef77ed . . 5cfc347 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 10 , 6 + 10 , 7 @ @ 
 config file or environment variables ( CASSANDRA - 9544 ) 
 * Remove repair snapshot leftover on startup ( CASSANDRA - 7357 ) 
 * Use random nodes for batch log when only 2 racks ( CASSANDRA - 8735 ) 
 + * Ensure atomicity inside thrift and stream session ( CASSANDRA - 7757 ) 
 Merged from 2 . 0 : 
 * Log when messages are dropped due to cross _ node _ timeout ( CASSANDRA - 9793 ) 
 * checkForEndpointCollision fails for legitimate collisions ( CASSANDRA - 9765 ) 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 index 1edfedb . . 63219d8 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 @ @ - 137 , 7 + 137 , 7 @ @ public class StreamSession implements IEndpointStateChangeSubscriber 
 / / stream requests to send to the peer 
 private final Set < StreamRequest > requests = Sets . newConcurrentHashSet ( ) ; 
 / / streaming tasks are created and managed per ColumnFamily ID 
 - private final Map < UUID , StreamTransferTask > transfers = new ConcurrentHashMap < > ( ) ; 
 + private final ConcurrentHashMap < UUID , StreamTransferTask > transfers = new ConcurrentHashMap < > ( ) ; 
 / / data receivers , filled after receiving prepare message 
 private final Map < UUID , StreamReceiveTask > receivers = new ConcurrentHashMap < > ( ) ; 
 private final StreamingMetrics metrics ; 
 @ @ - 369 , 8 + 369 , 11 @ @ public class StreamSession implements IEndpointStateChangeSubscriber 
 StreamTransferTask task = transfers . get ( cfId ) ; 
 if ( task = = null ) 
 { 
 - task = new StreamTransferTask ( this , cfId ) ; 
 - transfers . put ( cfId , task ) ; 
 + / / guarantee atomicity 
 + StreamTransferTask newTask = new StreamTransferTask ( this , cfId ) ; 
 + task = transfers . putIfAbsent ( cfId , newTask ) ; 
 + if ( task = = null ) 
 + task = newTask ; 
 } 
 task . addTransferFile ( details . ref , details . estimatedKeys , details . sections , details . repairedAt ) ; 
 iter . remove ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / thrift / ThriftSessionManager . java b / src / java / org / apache / cassandra / thrift / ThriftSessionManager . java 
 index ed3df6d . . 6caa558 100644 
 - - - a / src / java / org / apache / cassandra / thrift / ThriftSessionManager . java 
 + + + b / src / java / org / apache / cassandra / thrift / ThriftSessionManager . java 
 @ @ - 36 , 7 + 36 , 7 @ @ public class ThriftSessionManager 
 public final static ThriftSessionManager instance = new ThriftSessionManager ( ) ; 
 
 private final ThreadLocal < SocketAddress > remoteSocket = new ThreadLocal < > ( ) ; 
 - private final Map < SocketAddress , ThriftClientState > activeSocketSessions = new ConcurrentHashMap < > ( ) ; 
 + private final ConcurrentHashMap < SocketAddress , ThriftClientState > activeSocketSessions = new ConcurrentHashMap < > ( ) ; 
 
 / * * 
 * @ param socket the address on which the current thread will work on requests for until further notice 
 @ @ - 57 , 8 + 57 , 11 @ @ public class ThriftSessionManager 
 ThriftClientState cState = activeSocketSessions . get ( socket ) ; 
 if ( cState = = null ) 
 { 
 - cState = new ThriftClientState ( socket ) ; 
 - activeSocketSessions . put ( socket , cState ) ; 
 + / / guarantee atomicity 
 + ThriftClientState newState = new ThriftClientState ( socket ) ; 
 + cState = activeSocketSessions . putIfAbsent ( socket , newState ) ; 
 + if ( cState = = null ) 
 + cState = newState ; 
 } 
 return cState ; 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
