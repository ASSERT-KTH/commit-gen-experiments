BLEU SCORE: 0.027611988917697356

TEST MSG: used text container for content in file container
GENERATED MSG: parse handler with dynamic parse

TEST DIFF (one line): diff - - git a / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / FileContainer . java b / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / FileContainer . java <nl> index dcb6406 . . cbc5aac 100644 <nl> - - - a / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / FileContainer . java <nl> + + + b / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / FileContainer . java <nl> @ @ - 2 , 11 + 2 , 13 @ @ package com . github . dreamhead . moco . parser . model ; <nl> <nl> import com . fasterxml . jackson . databind . annotation . JsonDeserialize ; <nl> import com . github . dreamhead . moco . parser . deserializer . FileContainerDeserializer ; <nl> + import com . github . dreamhead . moco . resource . ContentResource ; <nl> import com . google . common . base . MoreObjects ; <nl> import com . google . common . base . Optional ; <nl> <nl> import java . nio . charset . Charset ; <nl> import java . nio . charset . UnsupportedCharsetException ; <nl> + import java . util . Map ; <nl> <nl> import static com . google . common . base . Optional . absent ; <nl> import static com . google . common . base . Optional . of ; <nl> @ @ - 15 , 16 + 17 , 19 @ @ import static com . google . common . base . Optional . of ; <nl> public final class FileContainer extends TextContainer { <nl> private TextContainer name ; <nl> private Optional < Charset > charset ; <nl> + private TextContainer content ; <nl> <nl> private FileContainer ( final TextContainer container ) { <nl> - super ( container . getText ( ) , container . getOperation ( ) , container . getProps ( ) ) ; <nl> + / / super ( container . getText ( ) , container . getOperation ( ) , container . getProps ( ) ) ; <nl> this . name = container ; <nl> this . charset = absent ( ) ; <nl> + this . content = container ; <nl> } <nl> <nl> private FileContainer ( final TextContainer name , final Optional < Charset > charset ) { <nl> this . name = name ; <nl> this . charset = charset ; <nl> + this . content = null ; <nl> } <nl> <nl> public TextContainer getName ( ) { <nl> @ @ - 36 , 6 + 41 , 76 @ @ public final class FileContainer extends TextContainer { <nl> } <nl> <nl> @ Override <nl> + public ContentResource asResource ( ) { <nl> + if ( this . content = = null ) { <nl> + return null ; <nl> + } <nl> + <nl> + return this . content . asResource ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public ContentResource asTemplateResource ( ) { <nl> + if ( this . content = = null ) { <nl> + return null ; <nl> + } <nl> + <nl> + return this . content . asTemplateResource ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public ContentResource asTemplateResource ( final String resourceName ) { <nl> + if ( this . content = = null ) { <nl> + return null ; <nl> + } <nl> + <nl> + return this . content . asTemplateResource ( resourceName ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isRawText ( ) { <nl> + return this . content ! = null & & this . content . isRawText ( ) ; <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public String getText ( ) { <nl> + if ( this . content = = null ) { <nl> + return null ; <nl> + } <nl> + <nl> + return this . content . getText ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getOperation ( ) { <nl> + if ( this . content = = null ) { <nl> + return null ; <nl> + } <nl> + <nl> + return this . content . getOperation ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasProperties ( ) { <nl> + return this . content ! = null & & this . content . hasProperties ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Map < String , TextContainer > getProps ( ) { <nl> + if ( this . content = = null ) { <nl> + return null ; <nl> + } <nl> + <nl> + return this . content . getProps ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isForTemplate ( ) { <nl> + return this . content ! = null & & this . content . isForTemplate ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> public String toString ( ) { <nl> return MoreObjects . toStringHelper ( this ) <nl> . omitNullValues ( )
NEAREST DIFF (one line): diff - - git a / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / ResponseSetting . java b / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / ResponseSetting . java <nl> index 3f7c242 . . 70ec966 100644 <nl> - - - a / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / ResponseSetting . java <nl> + + + b / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / ResponseSetting . java <nl> @ @ - 2 , 22 + 2 , 43 @ @ package com . github . dreamhead . moco . parser . model ; <nl> <nl> import com . fasterxml . jackson . annotation . JsonAutoDetect ; <nl> import com . fasterxml . jackson . annotation . JsonProperty ; <nl> + import com . github . dreamhead . moco . Moco ; <nl> import com . github . dreamhead . moco . ResponseHandler ; <nl> import com . github . dreamhead . moco . handler . AndResponseHandler ; <nl> + import com . github . dreamhead . moco . resource . ContentResource ; <nl> import com . github . dreamhead . moco . resource . Resource ; <nl> import com . google . common . base . Function ; <nl> import com . google . common . base . Objects ; <nl> + import com . google . common . base . Predicate ; <nl> + import com . google . common . collect . FluentIterable ; <nl> + import com . google . common . collect . ImmutableMap ; <nl> + import com . google . common . collect . ImmutableSet ; <nl> <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . InvocationTargetException ; <nl> + import java . lang . reflect . Method ; <nl> + import java . lang . reflect . Modifier ; <nl> + import java . util . Arrays ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> <nl> import static com . github . dreamhead . moco . Moco . * ; <nl> import static com . github . dreamhead . moco . handler . ResponseHandlers . responseHandler ; <nl> + import static com . google . common . base . Predicates . and ; <nl> + import static com . google . common . base . Predicates . * ; <nl> + import static com . google . common . base . Predicates . or ; <nl> import static com . google . common . collect . FluentIterable . from ; <nl> - import static com . google . common . collect . Lists . newArrayList ; <nl> + import static com . google . common . collect . ImmutableSet . of ; <nl> + import static java . lang . String . format ; <nl> <nl> @ JsonAutoDetect ( fieldVisibility = JsonAutoDetect . Visibility . ANY ) <nl> public class ResponseSetting { <nl> + private static final ImmutableSet < String > RESOURCES = of ( " text " , " file " , " pathResource " , " version " ) ; <nl> + private static final ImmutableMap < String , String > COMPOSITES = ImmutableMap . < String , String > builder ( ) <nl> + . put ( " headers " , " header " ) <nl> + . put ( " cookies " , " cookie " ) <nl> + . build ( ) ; <nl> + <nl> private String status ; <nl> private ProxyContainer proxy ; <nl> private Map < String , String > headers ; <nl> @ @ - 26 , 41 + 47 , 8 @ @ public class ResponseSetting { <nl> private TextContainer text ; <nl> private TextContainer file ; <nl> @ JsonProperty ( " path _ resource " ) <nl> - private String pathResource ; <nl> - private String version ; <nl> - <nl> - public Resource retrieveResource ( ) { <nl> - if ( text ! = null ) { <nl> - if ( text . isRawText ( ) ) { <nl> - return text ( text . getText ( ) ) ; <nl> - } <nl> - <nl> - if ( " template " . equalsIgnoreCase ( text . getOperation ( ) ) ) { <nl> - return template ( text . getText ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - if ( file ! = null ) { <nl> - if ( file . isRawText ( ) ) { <nl> - return file ( file . getText ( ) ) ; <nl> - } <nl> - <nl> - if ( " template " . equalsIgnoreCase ( file . getOperation ( ) ) ) { <nl> - return template ( file ( file . getText ( ) ) ) ; <nl> - } <nl> - } <nl> - <nl> - if ( pathResource ! = null ) { <nl> - return pathResource ( pathResource ) ; <nl> - } <nl> - <nl> - if ( version ! = null ) { <nl> - return version ( version ) ; <nl> - } <nl> - <nl> - throw new IllegalArgumentException ( " unknown response setting with " + this ) ; <nl> - } <nl> - <nl> + private TextContainer pathResource ; <nl> + private TextContainer version ; <nl> <nl> @ Override <nl> public String toString ( ) { <nl> @ @ - 77 , 74 + 65 , 193 @ @ public class ResponseSetting { <nl> . toString ( ) ; <nl> } <nl> <nl> - public boolean isResource ( ) { <nl> - return ( text ! = null ) <nl> - | | ( file ! = null ) <nl> - | | ( pathResource ! = null ) <nl> - | | ( version ! = null ) ; <nl> + private Iterable < Field > getFields ( Class < ? > clazz ) { <nl> + Field [ ] fields = clazz . getDeclaredFields ( ) ; <nl> + for ( Field field : fields ) { <nl> + field . setAccessible ( true ) ; <nl> + } <nl> + return Arrays . asList ( fields ) ; <nl> + } <nl> + <nl> + private Predicate < Field > isClassField ( ) { <nl> + return new Predicate < Field > ( ) { <nl> + @ Override <nl> + public boolean apply ( Field field ) { <nl> + return " class " . equals ( field . getName ( ) ) ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + private Predicate < Field > isFinalField ( ) { <nl> + return new Predicate < Field > ( ) { <nl> + @ Override <nl> + public boolean apply ( Field field ) { <nl> + return Modifier . isFinal ( field . getModifiers ( ) ) ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + private < T > Predicate < Field > fieldExist ( final T request ) { <nl> + return new Predicate < Field > ( ) { <nl> + @ Override <nl> + public boolean apply ( Field field ) { <nl> + try { <nl> + return field . get ( request ) ! = null ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + } ; <nl> } <nl> <nl> public ResponseHandler getResponseHandler ( ) { <nl> - List < ResponseHandler > handlers = newArrayList ( ) ; <nl> - if ( isResource ( ) ) { <nl> - handlers . add ( responseHandler ( retrieveResource ( ) ) ) ; <nl> - } <nl> + FluentIterable < ResponseHandler > handlers = from ( getFields ( this . getClass ( ) ) ) . filter ( and ( not ( or ( isClassField ( ) , isFinalField ( ) ) ) , fieldExist ( this ) ) ) . transform ( fieldToResponseHandler ( this ) ) ; <nl> + List < ResponseHandler > list = handlers . toList ( ) ; <nl> + return getResponseHandler ( list ) ; <nl> + } <nl> <nl> - if ( status ! = null ) { <nl> - handlers . add ( status ( Integer . parseInt ( status ) ) ) ; <nl> + private ResponseHandler getResponseHandler ( List < ResponseHandler > list ) { <nl> + if ( list . size ( ) = = 1 ) { <nl> + return list . get ( 0 ) ; <nl> } <nl> <nl> - if ( headers ! = null ) { <nl> - handlers . add ( toResponseHandler ( headers , toHeaderResponseHandler ( ) ) ) ; <nl> - } <nl> + return new AndResponseHandler ( list ) ; <nl> + } <nl> <nl> - if ( latency ! = null ) { <nl> - handlers . add ( latency ( latency ) ) ; <nl> - } <nl> + private boolean isResource ( String name ) { <nl> + return RESOURCES . contains ( name ) ; <nl> + } <nl> <nl> - if ( cookies ! = null ) { <nl> - handlers . add ( toResponseHandler ( cookies , toCookieResponseHandler ( ) ) ) ; <nl> + private Function < Field , ResponseHandler > fieldToResponseHandler ( final ResponseSetting response ) { <nl> + return new Function < Field , ResponseHandler > ( ) { <nl> + @ Override <nl> + public ResponseHandler apply ( Field field ) { <nl> + try { <nl> + Object value = field . get ( response ) ; <nl> + return createResponseHandler ( field . getName ( ) , value ) ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + private ResponseHandler createResponseHandler ( String name , Object value ) { <nl> + if ( isResource ( name ) & & TextContainer . class . isInstance ( value ) ) { <nl> + TextContainer container = TextContainer . class . cast ( value ) ; <nl> + return responseHandler ( resourceFrom ( name , container ) ) ; <nl> } <nl> <nl> - if ( proxy ! = null ) { <nl> - handlers . add ( createProxy ( proxy ) ) ; <nl> + if ( Map . class . isInstance ( value ) ) { <nl> + return createCompositeHandler ( name , castToMap ( value ) ) ; <nl> } <nl> <nl> - if ( handlers . isEmpty ( ) ) { <nl> - throw new IllegalArgumentException ( " unknown response setting with " + this ) ; <nl> + <nl> + if ( " status " . equalsIgnoreCase ( name ) ) { <nl> + return invokeTarget ( name , Integer . parseInt ( value . toString ( ) ) , ResponseHandler . class ) ; <nl> } <nl> <nl> - return handlers . size ( ) = = 1 ? handlers . get ( 0 ) : new AndResponseHandler ( handlers ) ; <nl> - } <nl> + if ( " latency " . equalsIgnoreCase ( name ) ) { <nl> + return invokeTarget ( name , Long . parseLong ( value . toString ( ) ) , ResponseHandler . class ) ; <nl> + } <nl> <nl> - private ResponseHandler createProxy ( ProxyContainer proxy ) { <nl> - if ( proxy . getFailover ( ) ! = null ) { <nl> - return proxy ( proxy . getUrl ( ) , failover ( proxy . getFailover ( ) ) ) ; <nl> + if ( ProxyContainer . class . isInstance ( value ) ) { <nl> + return createProxy ( ( ProxyContainer ) value ) ; <nl> } <nl> <nl> - return proxy ( proxy . getUrl ( ) ) ; <nl> + throw new IllegalArgumentException ( format ( " unknown field [ % s ] " , name ) ) ; <nl> } <nl> <nl> - private AndResponseHandler toResponseHandler ( Map < String , String > map , <nl> - Function < Map . Entry < String , String > , ResponseHandler > function ) { <nl> - return new AndResponseHandler ( from ( map . entrySet ( ) ) . transform ( function ) ) ; <nl> + private ResponseHandler createCompositeHandler ( String name , Map < String , String > map ) { <nl> + List < ResponseHandler > handlers = from ( map . entrySet ( ) ) . transform ( toTargetHandler ( getMethodForCompositeHandler ( name ) ) ) . toList ( ) ; <nl> + return getResponseHandler ( handlers ) ; <nl> } <nl> <nl> - private Function < Map . Entry < String , String > , ResponseHandler > toHeaderResponseHandler ( ) { <nl> + private Function < Map . Entry < String , String > , ResponseHandler > toTargetHandler ( final Method method ) { <nl> return new Function < Map . Entry < String , String > , ResponseHandler > ( ) { <nl> @ Override <nl> - public ResponseHandler apply ( Map . Entry < String , String > entry ) { <nl> - return header ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + public ResponseHandler apply ( Map . Entry < String , String > pair ) { <nl> + try { <nl> + return ( ResponseHandler ) method . invoke ( null , pair . getKey ( ) , pair . getValue ( ) ) ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } catch ( InvocationTargetException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> } <nl> } ; <nl> } <nl> <nl> - private Function < Map . Entry < String , String > , ResponseHandler > toCookieResponseHandler ( ) { <nl> - return new Function < Map . Entry < String , String > , ResponseHandler > ( ) { <nl> - @ Override <nl> - public ResponseHandler apply ( Map . Entry < String , String > entry ) { <nl> - return cookie ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + private Method getMethodForCompositeHandler ( String name ) { <nl> + try { <nl> + String result = COMPOSITES . get ( name ) ; <nl> + if ( result = = null ) { <nl> + throw new RuntimeException ( " unknown composite handler name [ " + name + " ] " ) ; <nl> } <nl> - } ; <nl> + return Moco . class . getMethod ( result , String . class , String . class ) ; <nl> + <nl> + } catch ( NoSuchMethodException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + private Map < String , String > castToMap ( Object value ) { <nl> + return Map . class . cast ( value ) ; <nl> + } <nl> + <nl> + private Resource resourceFrom ( String name , TextContainer container ) { <nl> + if ( container . isRawText ( ) ) { <nl> + return invokeTarget ( name , container . getText ( ) , Resource . class ) ; <nl> + } <nl> + <nl> + if ( " template " . equalsIgnoreCase ( container . getOperation ( ) ) ) { <nl> + if ( " version " . equalsIgnoreCase ( name ) ) { <nl> + return version ( template ( container . getText ( ) ) ) ; <nl> + } <nl> + <nl> + return template ( invokeTarget ( name , container . getText ( ) , ContentResource . class ) ) ; <nl> + } <nl> + <nl> + throw new IllegalArgumentException ( format ( " unknown operation [ % s ] " , container . getOperation ( ) ) ) ; <nl> + } <nl> + <nl> + private < T > T invokeTarget ( String name , Object value , Class < T > clazz ) { <nl> + try { <nl> + Method method = Moco . class . getMethod ( name , value . getClass ( ) ) ; <nl> + Object result = method . invoke ( null , value ) ; <nl> + return clazz . cast ( result ) ; <nl> + } catch ( Exception e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + private < T > T invokeTarget ( String name , int value , Class < T > clazz ) { <nl> + try { <nl> + Method method = Moco . class . getMethod ( name , Integer . TYPE ) ; <nl> + Object result = method . invoke ( null , value ) ; <nl> + return clazz . cast ( result ) ; <nl> + } catch ( Exception e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + private < T > T invokeTarget ( String name , long value , Class < T > clazz ) { <nl> + try { <nl> + Method method = Moco . class . getMethod ( name , Long . TYPE ) ; <nl> + Object result = method . invoke ( null , value ) ; <nl> + return clazz . cast ( result ) ; <nl> + } catch ( Exception e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + private ResponseHandler createProxy ( ProxyContainer proxy ) { <nl> + if ( proxy . getFailover ( ) ! = null ) { <nl> + return proxy ( proxy . getUrl ( ) , failover ( proxy . getFailover ( ) ) ) ; <nl> + } <nl> + <nl> + return proxy ( proxy . getUrl ( ) ) ; <nl> } <nl> } <nl> diff - - git a / moco - runner / src / test / java / com / github / dreamhead / moco / MocoTemplateStandaloneTest . java b / moco - runner / src / test / java / com / github / dreamhead / moco / MocoTemplateStandaloneTest . java <nl> index 96a8c3b . . f81b26c 100644 <nl> - - - a / moco - runner / src / test / java / com / github / dreamhead / moco / MocoTemplateStandaloneTest . java <nl> + + + b / moco - runner / src / test / java / com / github / dreamhead / moco / MocoTemplateStandaloneTest . java <nl> @ @ - 1 , 5 + 1 , 8 @ @ <nl> package com . github . dreamhead . moco ; <nl> <nl> + import org . apache . http . HttpVersion ; <nl> + import org . apache . http . ProtocolVersion ; <nl> + import org . apache . http . client . fluent . Request ; <nl> import org . junit . Test ; <nl> <nl> import java . io . IOException ; <nl> @ @ - 20 , 4 + 23 , 17 @ @ public class MocoTemplateStandaloneTest extends AbstractMocoStandaloneTest { <nl> runWithConfiguration ( " template . json " ) ; <nl> assertThat ( helper . get ( remoteUrl ( " / file _ template " ) ) , is ( " GET " ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void should _ return _ content _ from _ path _ resource _ template ( ) throws IOException { <nl> + runWithConfiguration ( " template . json " ) ; <nl> + assertThat ( helper . get ( remoteUrl ( " / file _ template " ) ) , is ( " GET " ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void should _ return _ version _ from _ template ( ) throws IOException { <nl> + runWithConfiguration ( " template . json " ) ; <nl> + ProtocolVersion version = Request . Get ( remoteUrl ( " / version _ template " ) ) . version ( HttpVersion . HTTP _ 1 _ 0 ) . execute ( ) . returnResponse ( ) . getProtocolVersion ( ) ; <nl> + assertThat ( version . toString ( ) , is ( " HTTP / 1 . 0 " ) ) ; <nl> + } <nl> } <nl> diff - - git a / moco - runner / src / test / resources / template . json b / moco - runner / src / test / resources / template . json <nl> index 91f3e05 . . 3894d6d 100644 <nl> - - - a / moco - runner / src / test / resources / template . json <nl> + + + b / moco - runner / src / test / resources / template . json <nl> @ @ - 18 , 5 + 18 , 25 @ @ <nl> " template " : " src / test / resources / template . foo " <nl> } <nl> } <nl> + } , <nl> + { <nl> + " request " : { <nl> + " uri " : " / path _ resource _ template " <nl> + } , <nl> + " response " : { <nl> + " path _ resource " : { <nl> + " template " : " template . foo " <nl> + } <nl> + } <nl> + } , <nl> + { <nl> + " request " : { <nl> + " uri " : " / version _ template " <nl> + } , <nl> + " response " : { <nl> + " version " : { <nl> + " template " : " $ { req . version } " <nl> + } <nl> + } <nl> } <nl> ] <nl> \ No newline at end of file

TEST DIFF:
diff - - git a / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / FileContainer . java b / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / FileContainer . java 
 index dcb6406 . . cbc5aac 100644 
 - - - a / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / FileContainer . java 
 + + + b / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / FileContainer . java 
 @ @ - 2 , 11 + 2 , 13 @ @ package com . github . dreamhead . moco . parser . model ; 
 
 import com . fasterxml . jackson . databind . annotation . JsonDeserialize ; 
 import com . github . dreamhead . moco . parser . deserializer . FileContainerDeserializer ; 
 + import com . github . dreamhead . moco . resource . ContentResource ; 
 import com . google . common . base . MoreObjects ; 
 import com . google . common . base . Optional ; 
 
 import java . nio . charset . Charset ; 
 import java . nio . charset . UnsupportedCharsetException ; 
 + import java . util . Map ; 
 
 import static com . google . common . base . Optional . absent ; 
 import static com . google . common . base . Optional . of ; 
 @ @ - 15 , 16 + 17 , 19 @ @ import static com . google . common . base . Optional . of ; 
 public final class FileContainer extends TextContainer { 
 private TextContainer name ; 
 private Optional < Charset > charset ; 
 + private TextContainer content ; 
 
 private FileContainer ( final TextContainer container ) { 
 - super ( container . getText ( ) , container . getOperation ( ) , container . getProps ( ) ) ; 
 + / / super ( container . getText ( ) , container . getOperation ( ) , container . getProps ( ) ) ; 
 this . name = container ; 
 this . charset = absent ( ) ; 
 + this . content = container ; 
 } 
 
 private FileContainer ( final TextContainer name , final Optional < Charset > charset ) { 
 this . name = name ; 
 this . charset = charset ; 
 + this . content = null ; 
 } 
 
 public TextContainer getName ( ) { 
 @ @ - 36 , 6 + 41 , 76 @ @ public final class FileContainer extends TextContainer { 
 } 
 
 @ Override 
 + public ContentResource asResource ( ) { 
 + if ( this . content = = null ) { 
 + return null ; 
 + } 
 + 
 + return this . content . asResource ( ) ; 
 + } 
 + 
 + @ Override 
 + public ContentResource asTemplateResource ( ) { 
 + if ( this . content = = null ) { 
 + return null ; 
 + } 
 + 
 + return this . content . asTemplateResource ( ) ; 
 + } 
 + 
 + @ Override 
 + public ContentResource asTemplateResource ( final String resourceName ) { 
 + if ( this . content = = null ) { 
 + return null ; 
 + } 
 + 
 + return this . content . asTemplateResource ( resourceName ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isRawText ( ) { 
 + return this . content ! = null & & this . content . isRawText ( ) ; 
 + 
 + } 
 + 
 + @ Override 
 + public String getText ( ) { 
 + if ( this . content = = null ) { 
 + return null ; 
 + } 
 + 
 + return this . content . getText ( ) ; 
 + } 
 + 
 + @ Override 
 + public String getOperation ( ) { 
 + if ( this . content = = null ) { 
 + return null ; 
 + } 
 + 
 + return this . content . getOperation ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean hasProperties ( ) { 
 + return this . content ! = null & & this . content . hasProperties ( ) ; 
 + } 
 + 
 + @ Override 
 + public Map < String , TextContainer > getProps ( ) { 
 + if ( this . content = = null ) { 
 + return null ; 
 + } 
 + 
 + return this . content . getProps ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isForTemplate ( ) { 
 + return this . content ! = null & & this . content . isForTemplate ( ) ; 
 + } 
 + 
 + @ Override 
 public String toString ( ) { 
 return MoreObjects . toStringHelper ( this ) 
 . omitNullValues ( )

NEAREST DIFF:
diff - - git a / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / ResponseSetting . java b / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / ResponseSetting . java 
 index 3f7c242 . . 70ec966 100644 
 - - - a / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / ResponseSetting . java 
 + + + b / moco - runner / src / main / java / com / github / dreamhead / moco / parser / model / ResponseSetting . java 
 @ @ - 2 , 22 + 2 , 43 @ @ package com . github . dreamhead . moco . parser . model ; 
 
 import com . fasterxml . jackson . annotation . JsonAutoDetect ; 
 import com . fasterxml . jackson . annotation . JsonProperty ; 
 + import com . github . dreamhead . moco . Moco ; 
 import com . github . dreamhead . moco . ResponseHandler ; 
 import com . github . dreamhead . moco . handler . AndResponseHandler ; 
 + import com . github . dreamhead . moco . resource . ContentResource ; 
 import com . github . dreamhead . moco . resource . Resource ; 
 import com . google . common . base . Function ; 
 import com . google . common . base . Objects ; 
 + import com . google . common . base . Predicate ; 
 + import com . google . common . collect . FluentIterable ; 
 + import com . google . common . collect . ImmutableMap ; 
 + import com . google . common . collect . ImmutableSet ; 
 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . InvocationTargetException ; 
 + import java . lang . reflect . Method ; 
 + import java . lang . reflect . Modifier ; 
 + import java . util . Arrays ; 
 import java . util . List ; 
 import java . util . Map ; 
 
 import static com . github . dreamhead . moco . Moco . * ; 
 import static com . github . dreamhead . moco . handler . ResponseHandlers . responseHandler ; 
 + import static com . google . common . base . Predicates . and ; 
 + import static com . google . common . base . Predicates . * ; 
 + import static com . google . common . base . Predicates . or ; 
 import static com . google . common . collect . FluentIterable . from ; 
 - import static com . google . common . collect . Lists . newArrayList ; 
 + import static com . google . common . collect . ImmutableSet . of ; 
 + import static java . lang . String . format ; 
 
 @ JsonAutoDetect ( fieldVisibility = JsonAutoDetect . Visibility . ANY ) 
 public class ResponseSetting { 
 + private static final ImmutableSet < String > RESOURCES = of ( " text " , " file " , " pathResource " , " version " ) ; 
 + private static final ImmutableMap < String , String > COMPOSITES = ImmutableMap . < String , String > builder ( ) 
 + . put ( " headers " , " header " ) 
 + . put ( " cookies " , " cookie " ) 
 + . build ( ) ; 
 + 
 private String status ; 
 private ProxyContainer proxy ; 
 private Map < String , String > headers ; 
 @ @ - 26 , 41 + 47 , 8 @ @ public class ResponseSetting { 
 private TextContainer text ; 
 private TextContainer file ; 
 @ JsonProperty ( " path _ resource " ) 
 - private String pathResource ; 
 - private String version ; 
 - 
 - public Resource retrieveResource ( ) { 
 - if ( text ! = null ) { 
 - if ( text . isRawText ( ) ) { 
 - return text ( text . getText ( ) ) ; 
 - } 
 - 
 - if ( " template " . equalsIgnoreCase ( text . getOperation ( ) ) ) { 
 - return template ( text . getText ( ) ) ; 
 - } 
 - } 
 - 
 - if ( file ! = null ) { 
 - if ( file . isRawText ( ) ) { 
 - return file ( file . getText ( ) ) ; 
 - } 
 - 
 - if ( " template " . equalsIgnoreCase ( file . getOperation ( ) ) ) { 
 - return template ( file ( file . getText ( ) ) ) ; 
 - } 
 - } 
 - 
 - if ( pathResource ! = null ) { 
 - return pathResource ( pathResource ) ; 
 - } 
 - 
 - if ( version ! = null ) { 
 - return version ( version ) ; 
 - } 
 - 
 - throw new IllegalArgumentException ( " unknown response setting with " + this ) ; 
 - } 
 - 
 + private TextContainer pathResource ; 
 + private TextContainer version ; 
 
 @ Override 
 public String toString ( ) { 
 @ @ - 77 , 74 + 65 , 193 @ @ public class ResponseSetting { 
 . toString ( ) ; 
 } 
 
 - public boolean isResource ( ) { 
 - return ( text ! = null ) 
 - | | ( file ! = null ) 
 - | | ( pathResource ! = null ) 
 - | | ( version ! = null ) ; 
 + private Iterable < Field > getFields ( Class < ? > clazz ) { 
 + Field [ ] fields = clazz . getDeclaredFields ( ) ; 
 + for ( Field field : fields ) { 
 + field . setAccessible ( true ) ; 
 + } 
 + return Arrays . asList ( fields ) ; 
 + } 
 + 
 + private Predicate < Field > isClassField ( ) { 
 + return new Predicate < Field > ( ) { 
 + @ Override 
 + public boolean apply ( Field field ) { 
 + return " class " . equals ( field . getName ( ) ) ; 
 + } 
 + } ; 
 + } 
 + 
 + private Predicate < Field > isFinalField ( ) { 
 + return new Predicate < Field > ( ) { 
 + @ Override 
 + public boolean apply ( Field field ) { 
 + return Modifier . isFinal ( field . getModifiers ( ) ) ; 
 + } 
 + } ; 
 + } 
 + 
 + private < T > Predicate < Field > fieldExist ( final T request ) { 
 + return new Predicate < Field > ( ) { 
 + @ Override 
 + public boolean apply ( Field field ) { 
 + try { 
 + return field . get ( request ) ! = null ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + } ; 
 } 
 
 public ResponseHandler getResponseHandler ( ) { 
 - List < ResponseHandler > handlers = newArrayList ( ) ; 
 - if ( isResource ( ) ) { 
 - handlers . add ( responseHandler ( retrieveResource ( ) ) ) ; 
 - } 
 + FluentIterable < ResponseHandler > handlers = from ( getFields ( this . getClass ( ) ) ) . filter ( and ( not ( or ( isClassField ( ) , isFinalField ( ) ) ) , fieldExist ( this ) ) ) . transform ( fieldToResponseHandler ( this ) ) ; 
 + List < ResponseHandler > list = handlers . toList ( ) ; 
 + return getResponseHandler ( list ) ; 
 + } 
 
 - if ( status ! = null ) { 
 - handlers . add ( status ( Integer . parseInt ( status ) ) ) ; 
 + private ResponseHandler getResponseHandler ( List < ResponseHandler > list ) { 
 + if ( list . size ( ) = = 1 ) { 
 + return list . get ( 0 ) ; 
 } 
 
 - if ( headers ! = null ) { 
 - handlers . add ( toResponseHandler ( headers , toHeaderResponseHandler ( ) ) ) ; 
 - } 
 + return new AndResponseHandler ( list ) ; 
 + } 
 
 - if ( latency ! = null ) { 
 - handlers . add ( latency ( latency ) ) ; 
 - } 
 + private boolean isResource ( String name ) { 
 + return RESOURCES . contains ( name ) ; 
 + } 
 
 - if ( cookies ! = null ) { 
 - handlers . add ( toResponseHandler ( cookies , toCookieResponseHandler ( ) ) ) ; 
 + private Function < Field , ResponseHandler > fieldToResponseHandler ( final ResponseSetting response ) { 
 + return new Function < Field , ResponseHandler > ( ) { 
 + @ Override 
 + public ResponseHandler apply ( Field field ) { 
 + try { 
 + Object value = field . get ( response ) ; 
 + return createResponseHandler ( field . getName ( ) , value ) ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + } ; 
 + } 
 + 
 + private ResponseHandler createResponseHandler ( String name , Object value ) { 
 + if ( isResource ( name ) & & TextContainer . class . isInstance ( value ) ) { 
 + TextContainer container = TextContainer . class . cast ( value ) ; 
 + return responseHandler ( resourceFrom ( name , container ) ) ; 
 } 
 
 - if ( proxy ! = null ) { 
 - handlers . add ( createProxy ( proxy ) ) ; 
 + if ( Map . class . isInstance ( value ) ) { 
 + return createCompositeHandler ( name , castToMap ( value ) ) ; 
 } 
 
 - if ( handlers . isEmpty ( ) ) { 
 - throw new IllegalArgumentException ( " unknown response setting with " + this ) ; 
 + 
 + if ( " status " . equalsIgnoreCase ( name ) ) { 
 + return invokeTarget ( name , Integer . parseInt ( value . toString ( ) ) , ResponseHandler . class ) ; 
 } 
 
 - return handlers . size ( ) = = 1 ? handlers . get ( 0 ) : new AndResponseHandler ( handlers ) ; 
 - } 
 + if ( " latency " . equalsIgnoreCase ( name ) ) { 
 + return invokeTarget ( name , Long . parseLong ( value . toString ( ) ) , ResponseHandler . class ) ; 
 + } 
 
 - private ResponseHandler createProxy ( ProxyContainer proxy ) { 
 - if ( proxy . getFailover ( ) ! = null ) { 
 - return proxy ( proxy . getUrl ( ) , failover ( proxy . getFailover ( ) ) ) ; 
 + if ( ProxyContainer . class . isInstance ( value ) ) { 
 + return createProxy ( ( ProxyContainer ) value ) ; 
 } 
 
 - return proxy ( proxy . getUrl ( ) ) ; 
 + throw new IllegalArgumentException ( format ( " unknown field [ % s ] " , name ) ) ; 
 } 
 
 - private AndResponseHandler toResponseHandler ( Map < String , String > map , 
 - Function < Map . Entry < String , String > , ResponseHandler > function ) { 
 - return new AndResponseHandler ( from ( map . entrySet ( ) ) . transform ( function ) ) ; 
 + private ResponseHandler createCompositeHandler ( String name , Map < String , String > map ) { 
 + List < ResponseHandler > handlers = from ( map . entrySet ( ) ) . transform ( toTargetHandler ( getMethodForCompositeHandler ( name ) ) ) . toList ( ) ; 
 + return getResponseHandler ( handlers ) ; 
 } 
 
 - private Function < Map . Entry < String , String > , ResponseHandler > toHeaderResponseHandler ( ) { 
 + private Function < Map . Entry < String , String > , ResponseHandler > toTargetHandler ( final Method method ) { 
 return new Function < Map . Entry < String , String > , ResponseHandler > ( ) { 
 @ Override 
 - public ResponseHandler apply ( Map . Entry < String , String > entry ) { 
 - return header ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + public ResponseHandler apply ( Map . Entry < String , String > pair ) { 
 + try { 
 + return ( ResponseHandler ) method . invoke ( null , pair . getKey ( ) , pair . getValue ( ) ) ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } catch ( InvocationTargetException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 } 
 } ; 
 } 
 
 - private Function < Map . Entry < String , String > , ResponseHandler > toCookieResponseHandler ( ) { 
 - return new Function < Map . Entry < String , String > , ResponseHandler > ( ) { 
 - @ Override 
 - public ResponseHandler apply ( Map . Entry < String , String > entry ) { 
 - return cookie ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + private Method getMethodForCompositeHandler ( String name ) { 
 + try { 
 + String result = COMPOSITES . get ( name ) ; 
 + if ( result = = null ) { 
 + throw new RuntimeException ( " unknown composite handler name [ " + name + " ] " ) ; 
 } 
 - } ; 
 + return Moco . class . getMethod ( result , String . class , String . class ) ; 
 + 
 + } catch ( NoSuchMethodException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + private Map < String , String > castToMap ( Object value ) { 
 + return Map . class . cast ( value ) ; 
 + } 
 + 
 + private Resource resourceFrom ( String name , TextContainer container ) { 
 + if ( container . isRawText ( ) ) { 
 + return invokeTarget ( name , container . getText ( ) , Resource . class ) ; 
 + } 
 + 
 + if ( " template " . equalsIgnoreCase ( container . getOperation ( ) ) ) { 
 + if ( " version " . equalsIgnoreCase ( name ) ) { 
 + return version ( template ( container . getText ( ) ) ) ; 
 + } 
 + 
 + return template ( invokeTarget ( name , container . getText ( ) , ContentResource . class ) ) ; 
 + } 
 + 
 + throw new IllegalArgumentException ( format ( " unknown operation [ % s ] " , container . getOperation ( ) ) ) ; 
 + } 
 + 
 + private < T > T invokeTarget ( String name , Object value , Class < T > clazz ) { 
 + try { 
 + Method method = Moco . class . getMethod ( name , value . getClass ( ) ) ; 
 + Object result = method . invoke ( null , value ) ; 
 + return clazz . cast ( result ) ; 
 + } catch ( Exception e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + private < T > T invokeTarget ( String name , int value , Class < T > clazz ) { 
 + try { 
 + Method method = Moco . class . getMethod ( name , Integer . TYPE ) ; 
 + Object result = method . invoke ( null , value ) ; 
 + return clazz . cast ( result ) ; 
 + } catch ( Exception e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + private < T > T invokeTarget ( String name , long value , Class < T > clazz ) { 
 + try { 
 + Method method = Moco . class . getMethod ( name , Long . TYPE ) ; 
 + Object result = method . invoke ( null , value ) ; 
 + return clazz . cast ( result ) ; 
 + } catch ( Exception e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + 
 + private ResponseHandler createProxy ( ProxyContainer proxy ) { 
 + if ( proxy . getFailover ( ) ! = null ) { 
 + return proxy ( proxy . getUrl ( ) , failover ( proxy . getFailover ( ) ) ) ; 
 + } 
 + 
 + return proxy ( proxy . getUrl ( ) ) ; 
 } 
 } 
 diff - - git a / moco - runner / src / test / java / com / github / dreamhead / moco / MocoTemplateStandaloneTest . java b / moco - runner / src / test / java / com / github / dreamhead / moco / MocoTemplateStandaloneTest . java 
 index 96a8c3b . . f81b26c 100644 
 - - - a / moco - runner / src / test / java / com / github / dreamhead / moco / MocoTemplateStandaloneTest . java 
 + + + b / moco - runner / src / test / java / com / github / dreamhead / moco / MocoTemplateStandaloneTest . java 
 @ @ - 1 , 5 + 1 , 8 @ @ 
 package com . github . dreamhead . moco ; 
 
 + import org . apache . http . HttpVersion ; 
 + import org . apache . http . ProtocolVersion ; 
 + import org . apache . http . client . fluent . Request ; 
 import org . junit . Test ; 
 
 import java . io . IOException ; 
 @ @ - 20 , 4 + 23 , 17 @ @ public class MocoTemplateStandaloneTest extends AbstractMocoStandaloneTest { 
 runWithConfiguration ( " template . json " ) ; 
 assertThat ( helper . get ( remoteUrl ( " / file _ template " ) ) , is ( " GET " ) ) ; 
 } 
 + 
 + @ Test 
 + public void should _ return _ content _ from _ path _ resource _ template ( ) throws IOException { 
 + runWithConfiguration ( " template . json " ) ; 
 + assertThat ( helper . get ( remoteUrl ( " / file _ template " ) ) , is ( " GET " ) ) ; 
 + } 
 + 
 + @ Test 
 + public void should _ return _ version _ from _ template ( ) throws IOException { 
 + runWithConfiguration ( " template . json " ) ; 
 + ProtocolVersion version = Request . Get ( remoteUrl ( " / version _ template " ) ) . version ( HttpVersion . HTTP _ 1 _ 0 ) . execute ( ) . returnResponse ( ) . getProtocolVersion ( ) ; 
 + assertThat ( version . toString ( ) , is ( " HTTP / 1 . 0 " ) ) ; 
 + } 
 } 
 diff - - git a / moco - runner / src / test / resources / template . json b / moco - runner / src / test / resources / template . json 
 index 91f3e05 . . 3894d6d 100644 
 - - - a / moco - runner / src / test / resources / template . json 
 + + + b / moco - runner / src / test / resources / template . json 
 @ @ - 18 , 5 + 18 , 25 @ @ 
 " template " : " src / test / resources / template . foo " 
 } 
 } 
 + } , 
 + { 
 + " request " : { 
 + " uri " : " / path _ resource _ template " 
 + } , 
 + " response " : { 
 + " path _ resource " : { 
 + " template " : " template . foo " 
 + } 
 + } 
 + } , 
 + { 
 + " request " : { 
 + " uri " : " / version _ template " 
 + } , 
 + " response " : { 
 + " version " : { 
 + " template " : " $ { req . version } " 
 + } 
 + } 
 } 
 ] 
 \ No newline at end of file
