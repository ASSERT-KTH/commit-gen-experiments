BLEU SCORE: 0.016466642419110007

TEST MSG: Loading screen : moved config file to the standard config directory ; added the option to load textures from the custom resource pack
GENERATED MSG: Commit the start of some pluggable transformers

TEST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java b / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java <nl> index defb8df . . 2e6dd0e 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java <nl> @ @ - 4 , 6 + 4 , 9 @ @ import static org . lwjgl . opengl . GL11 . * ; <nl> import static org . lwjgl . opengl . GL12 . * ; <nl> <nl> import java . awt . image . BufferedImage ; <nl> + import java . io . File ; <nl> + import java . io . FileReader ; <nl> + import java . io . FileWriter ; <nl> import java . io . IOException ; <nl> import java . io . InputStream ; <nl> import java . lang . Thread . UncaughtExceptionHandler ; <nl> @ @ - 39 , 6 + 42 , 7 @ @ import org . lwjgl . util . glu . GLU ; <nl> import cpw . mods . fml . common . FMLCommonHandler ; <nl> import cpw . mods . fml . common . FMLLog ; <nl> import cpw . mods . fml . common . ICrashCallable ; <nl> + import cpw . mods . fml . common . Loader ; <nl> import cpw . mods . fml . common . ProgressManager ; <nl> import cpw . mods . fml . common . ProgressManager . ProgressBar ; <nl> import cpw . mods . fml . common . asm . FMLSanityChecker ; <nl> @ @ - 59 , 26 + 63 , 97 @ @ public class SplashProgress <nl> private static SplashFontRenderer fontRenderer ; <nl> <nl> private static final IResourcePack mcPack = Minecraft . getMinecraft ( ) . mcDefaultResourcePack ; <nl> - private static final IResourcePack fmlPack = createFmlResourcePack ( ) ; <nl> + private static final IResourcePack fmlPack = createResourcePack ( FMLSanityChecker . fmlLocation ) ; <nl> + private static IResourcePack miscPack ; <nl> <nl> private static Texture fontTexture ; <nl> private static Texture logoTexture ; <nl> private static Texture forgeTexture ; <nl> <nl> - private static ResourceLocation configLocation = new ResourceLocation ( " fml " , " splash . properties " ) ; <nl> - private static final Properties config = loadConfig ( ) ; <nl> + private static Properties config ; <nl> <nl> - private static final boolean enabled = Boolean . parseBoolean ( config . getProperty ( " enabled " ) ) & & ! FMLClientHandler . instance ( ) . hasOptifine ( ) ; <nl> - private static final boolean rotate = Boolean . parseBoolean ( config . getProperty ( " rotate " ) ) ; <nl> - private static final int logoOffset = getInt ( " logoOffset " ) ; <nl> - private static final int backgroundColor = getInt ( " background " ) ; <nl> - private static final int fontColor = getInt ( " font " ) ; <nl> - private static final int barBorderColor = getInt ( " barBorder " ) ; <nl> - private static final int barColor = getInt ( " bar " ) ; <nl> - private static final int barBackgroundColor = getInt ( " barBackground " ) ; <nl> + private static boolean enabled ; <nl> + private static boolean rotate ; <nl> + private static int logoOffset ; <nl> + private static int backgroundColor ; <nl> + private static int fontColor ; <nl> + private static int barBorderColor ; <nl> + private static int barColor ; <nl> + private static int barBackgroundColor ; <nl> + <nl> + private static String getString ( String name , String def ) <nl> + { <nl> + String value = config . getProperty ( name , def ) ; <nl> + config . setProperty ( name , value ) ; <nl> + return value ; <nl> + } <nl> + <nl> + private static boolean getBool ( String name , boolean def ) <nl> + { <nl> + return Boolean . parseBoolean ( getString ( name , Boolean . toString ( def ) ) ) ; <nl> + } <nl> + <nl> + private static int getInt ( String name , int def ) <nl> + { <nl> + return Integer . decode ( getString ( name , Integer . toString ( def ) ) ) ; <nl> + } <nl> + <nl> + private static int getHex ( String name , int def ) <nl> + { <nl> + return Integer . decode ( getString ( name , " 0x " + Integer . toString ( def , 16 ) . toUpperCase ( ) ) ) ; <nl> + } <nl> <nl> public static void start ( ) <nl> { <nl> + File configFile = new File ( Minecraft . getMinecraft ( ) . mcDataDir , " config / splash . properties " ) ; <nl> + FileReader r = null ; <nl> + config = new Properties ( ) ; <nl> + try <nl> + { <nl> + r = new FileReader ( configFile ) ; <nl> + config . load ( r ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + FMLLog . info ( " Could not load splash . properties , will create a default one " ) ; <nl> + } <nl> + finally <nl> + { <nl> + IOUtils . closeQuietly ( r ) ; <nl> + } <nl> + <nl> + enabled = getBool ( " enabled " , true ) & & ! FMLClientHandler . instance ( ) . hasOptifine ( ) ; <nl> + rotate = getBool ( " rotate " , true ) ; <nl> + logoOffset = getInt ( " logoOffset " , 10 ) ; <nl> + backgroundColor = getHex ( " background " , 0xFFFFFF ) ; <nl> + fontColor = getHex ( " font " , 0x000000 ) ; <nl> + barBorderColor = getHex ( " barBorder " , 0xC0C0C0 ) ; <nl> + barColor = getHex ( " bar " , 0xCB3D35 ) ; <nl> + barBackgroundColor = getHex ( " barBackground " , 0xFFFFFF ) ; <nl> + <nl> + final ResourceLocation fontLoc = new ResourceLocation ( getString ( " fontTexture " , " textures / font / ascii . png " ) ) ; <nl> + final ResourceLocation logoLoc = new ResourceLocation ( getString ( " logoTexture " , " textures / gui / title / mojang . png " ) ) ; <nl> + final ResourceLocation forgeLoc = new ResourceLocation ( getString ( " forgeTexture " , " fml : textures / gui / forge . png " ) ) ; <nl> + <nl> + File miscPackFile = new File ( Minecraft . getMinecraft ( ) . mcDataDir , getString ( " resourcePackPath " , " resources " ) ) ; <nl> + <nl> + FileWriter w = null ; <nl> + try <nl> + { <nl> + w = new FileWriter ( configFile ) ; <nl> + config . store ( w , " Splash screen properties " ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + FMLLog . log ( Level . ERROR , e , " Could not save the splash . properties file " ) ; <nl> + } <nl> + finally <nl> + { <nl> + IOUtils . closeQuietly ( w ) ; <nl> + } <nl> + <nl> + miscPack = createResourcePack ( miscPackFile ) ; <nl> + <nl> if ( ! enabled ) return ; <nl> / / getting debug info out of the way , while we still can <nl> FMLCommonHandler . instance ( ) . registerCrashCallable ( new ICrashCallable ( ) <nl> @ @ - 121 , 9 + 196 , 9 @ @ public class SplashProgress <nl> public void run ( ) <nl> { <nl> setGL ( ) ; <nl> - fontTexture = new Texture ( mcPack , new ResourceLocation ( " textures / font / ascii . png " ) ) ; <nl> - logoTexture = new Texture ( mcPack , new ResourceLocation ( " textures / gui / title / mojang . png " ) ) ; <nl> - forgeTexture = new Texture ( fmlPack , new ResourceLocation ( config . getProperty ( " forgeTexture " ) ) ) ; <nl> + fontTexture = new Texture ( fontLoc ) ; <nl> + logoTexture = new Texture ( logoLoc ) ; <nl> + forgeTexture = new Texture ( forgeLoc ) ; <nl> glEnable ( GL _ TEXTURE _ 2D ) ; <nl> fontRenderer = new SplashFontRenderer ( ) ; <nl> glDisable ( GL _ TEXTURE _ 2D ) ; <nl> @ @ - 409 , 44 + 484 , 18 @ @ public class SplashProgress <nl> } <nl> } <nl> <nl> - private static IResourcePack createFmlResourcePack ( ) <nl> + private static IResourcePack createResourcePack ( File file ) <nl> { <nl> - if ( FMLSanityChecker . fmlLocation . isDirectory ( ) ) <nl> + if ( file . isDirectory ( ) ) <nl> { <nl> - return new FolderResourcePack ( FMLSanityChecker . fmlLocation ) ; <nl> + return new FolderResourcePack ( file ) ; <nl> } <nl> else <nl> { <nl> - return new FileResourcePack ( FMLSanityChecker . fmlLocation ) ; <nl> - } <nl> - } <nl> - <nl> - private static Properties loadConfig ( ) <nl> - { <nl> - InputStream s = null ; <nl> - try <nl> - { <nl> - s = fmlPack . getInputStream ( configLocation ) ; <nl> - Properties config = new Properties ( ) ; <nl> - config . load ( s ) ; <nl> - return config ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - e . printStackTrace ( ) ; <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - finally <nl> - { <nl> - IOUtils . closeQuietly ( s ) ; <nl> + return new FileResourcePack ( file ) ; <nl> } <nl> } <nl> <nl> - private static int getInt ( String name ) <nl> - { <nl> - return Integer . decode ( config . getProperty ( name ) ) ; <nl> - } <nl> - <nl> private static final IntBuffer buf = BufferUtils . createIntBuffer ( 4 * 1024 * 1024 ) ; <nl> <nl> private static class Texture <nl> @ @ - 458 , 13 + 507 , 13 @ @ public class SplashProgress <nl> private final int frames ; <nl> private final int size ; <nl> <nl> - public Texture ( IResourcePack pack , ResourceLocation location ) <nl> + public Texture ( ResourceLocation location ) <nl> { <nl> InputStream s = null ; <nl> try <nl> { <nl> this . location = location ; <nl> - s = pack . getInputStream ( location ) ; <nl> + s = open ( location ) ; <nl> ImageInputStream stream = ImageIO . createImageInputStream ( s ) ; <nl> Iterator < ImageReader > readers = ImageIO . getImageReaders ( stream ) ; <nl> if ( ! readers . hasNext ( ) ) throw new IOException ( " No suitable reader found for image " + location ) ; <nl> @ @ - 493 , 7 + 542 , 6 @ @ public class SplashProgress <nl> { <nl> for ( int j = 0 ; i * ( size / width ) + j < frames & & j < size / width ; j + + ) <nl> { <nl> - FMLLog . info ( " loc : % s , i : % s , j : % s , size : % s , width : % s , height : % s " , location , i , j , size , width , height ) ; <nl> buf . clear ( ) ; <nl> BufferedImage image = images [ i * ( size / width ) + j ] ; <nl> for ( int k = 0 ; k < height ; k + + ) <nl> @ @ - 624 , 4 + 672 , 17 @ @ public class SplashProgress <nl> throw new IllegalStateException ( where + " : " + GLU . gluErrorString ( err ) ) ; <nl> } <nl> } <nl> + <nl> + private static InputStream open ( ResourceLocation loc ) throws IOException <nl> + { <nl> + if ( miscPack . resourceExists ( loc ) ) <nl> + { <nl> + return miscPack . getInputStream ( loc ) ; <nl> + } <nl> + else if ( fmlPack . resourceExists ( loc ) ) <nl> + { <nl> + return fmlPack . getInputStream ( loc ) ; <nl> + } <nl> + return mcPack . getInputStream ( loc ) ; <nl> + } <nl> } <nl> diff - - git a / fml / src / main / resources / assets / fml / splash . properties b / fml / src / main / resources / assets / fml / splash . properties <nl> deleted file mode 100644 <nl> index 4cfb4f5 . . 0000000 <nl> - - - a / fml / src / main / resources / assets / fml / splash . properties <nl> + + + / dev / null <nl> @ @ - 1 , 10 + 0 , 0 @ @ <nl> - enabled = true <nl> - rotate = true <nl> - <nl> - forgeTexture = fml : textures / gui / forge . png <nl> - logoOffset = 10 <nl> - background = 0xFFFFFF <nl> - font = 0x000000 <nl> - barBorder = 0xC0C0C0 <nl> - bar = 0xCB3D35 <nl> - barBackground = 0xFFFFFF
NEAREST DIFF (one line): diff - - git a / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java <nl> new file mode 100644 <nl> index 0000000 . . 760284e <nl> - - - / dev / null <nl> + + + b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java <nl> @ @ - 0 , 0 + 1 , 357 @ @ <nl> + package cpw . mods . fml . common . asm . transformers ; <nl> + <nl> + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; <nl> + <nl> + import java . io . BufferedInputStream ; <nl> + import java . io . BufferedOutputStream ; <nl> + import java . io . BufferedReader ; <nl> + import java . io . ByteArrayOutputStream ; <nl> + import java . io . File ; <nl> + import java . io . FileInputStream ; <nl> + import java . io . FileNotFoundException ; <nl> + import java . io . FileOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStream ; <nl> + import java . io . InputStreamReader ; <nl> + import java . net . URL ; <nl> + import java . text . SimpleDateFormat ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collection ; <nl> + import java . util . Date ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + import java . util . zip . ZipEntry ; <nl> + import java . util . zip . ZipInputStream ; <nl> + import java . util . zip . ZipOutputStream ; <nl> + <nl> + import org . objectweb . asm . ClassReader ; <nl> + import org . objectweb . asm . ClassWriter ; <nl> + import org . objectweb . asm . Type ; <nl> + import org . objectweb . asm . tree . ClassNode ; <nl> + import org . objectweb . asm . tree . FieldNode ; <nl> + import org . objectweb . asm . tree . MethodNode ; <nl> + <nl> + import com . google . common . base . CharMatcher ; <nl> + import com . google . common . base . Charsets ; <nl> + import com . google . common . base . Splitter ; <nl> + import com . google . common . base . Strings ; <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> + import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Multimap ; <nl> + import com . google . common . io . LineProcessor ; <nl> + import com . google . common . io . Resources ; <nl> + <nl> + import cpw . mods . fml . relauncher . IClassTransformer ; <nl> + <nl> + public class AccessTransformer implements IClassTransformer <nl> + { <nl> + private class Modifier <nl> + { <nl> + public String name = " " ; <nl> + public String desc = " " ; <nl> + public int oldAccess = 0 ; <nl> + public int newAccess = 0 ; <nl> + public int targetAccess = 0 ; <nl> + <nl> + private void setTargetAccess ( String name ) <nl> + { <nl> + if ( name . equalsIgnoreCase ( " public " ) ) targetAccess = ACC _ PUBLIC ; <nl> + else if ( name . equalsIgnoreCase ( " private " ) ) targetAccess = ACC _ PRIVATE ; <nl> + else if ( name . equalsIgnoreCase ( " protected " ) ) targetAccess = ACC _ PROTECTED ; <nl> + } <nl> + } <nl> + <nl> + private Multimap < String , Modifier > modifiers = ArrayListMultimap . create ( ) ; <nl> + <nl> + public AccessTransformer ( ) throws IOException <nl> + { <nl> + this ( " / rules . csv " ) ; <nl> + } <nl> + protected AccessTransformer ( String rulesFile ) throws IOException <nl> + { <nl> + readMapFile ( rulesFile ) ; <nl> + } <nl> + <nl> + private void readMapFile ( String rulesFile ) throws IOException <nl> + { <nl> + URL rulesResource = Resources . getResource ( rulesFile ) ; <nl> + Resources . readLines ( rulesResource , Charsets . UTF _ 8 , new LineProcessor < Void > ( ) <nl> + { <nl> + @ Override <nl> + public Void getResult ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean processLine ( String input ) throws IOException <nl> + { <nl> + String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; <nl> + if ( line . length ( ) = = 0 ) <nl> + { <nl> + return true ; <nl> + } <nl> + List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; <nl> + if ( parts . size ( ) > 2 | | parts . get ( 1 ) . indexOf ( ' . ' ) = = - 1 ) <nl> + { <nl> + throw new RuntimeException ( " Invalid config file line " + input ) ; <nl> + } <nl> + Modifier m = new Modifier ( ) ; <nl> + m . setTargetAccess ( parts . get ( 0 ) ) ; <nl> + List < String > descriptor = Lists . newArrayList ( Splitter . on ( " . " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; <nl> + List < String > method = Lists . newArrayList ( Splitter . on ( CharMatcher . anyOf ( " ( ) " ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( descriptor . get ( 1 ) ) ) ; <nl> + if ( method . size ( ) = = 2 ) <nl> + { <nl> + m . desc = method . get ( 1 ) ; <nl> + } <nl> + m . name = method . get ( 0 ) ; <nl> + modifiers . put ( descriptor . get ( 0 ) , m ) ; <nl> + return true ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + @ Override <nl> + public byte [ ] transform ( String name , byte [ ] bytes ) <nl> + { <nl> + if ( ! modifiers . containsKey ( name ) ) { return bytes ; } <nl> + <nl> + ClassNode classNode = new ClassNode ( ) ; <nl> + ClassReader classReader = new ClassReader ( bytes ) ; <nl> + classReader . accept ( classNode , 0 ) ; <nl> + <nl> + Collection < Modifier > mods = modifiers . get ( name ) ; <nl> + for ( Modifier m : mods ) <nl> + { <nl> + if ( m . desc . isEmpty ( ) ) <nl> + { <nl> + for ( FieldNode n : ( List < FieldNode > ) classNode . fields ) <nl> + { <nl> + if ( n . name . equals ( m . name ) ) <nl> + { <nl> + n . access = getFixedAccess ( n . access , m ) ; <nl> + System . out . println ( String . format ( " Field : % s . % s % s - > % s " , name , m . name , Integer . toBinaryString ( m . oldAccess ) , <nl> + Integer . toBinaryString ( m . newAccess ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + else <nl> + { <nl> + for ( MethodNode n : ( List < MethodNode > ) classNode . methods ) <nl> + { <nl> + if ( n . name . equals ( m . name ) & & n . desc . equals ( m . desc ) ) <nl> + { <nl> + n . access = getFixedAccess ( n . access , m ) ; <nl> + System . out . println ( String . format ( " Method : % s . % s % s % s - > % s " , name , m . name , m . desc , toBinary ( m . oldAccess ) , toBinary ( m . newAccess ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; <nl> + classNode . accept ( writer ) ; <nl> + return writer . toByteArray ( ) ; <nl> + } <nl> + <nl> + private String toBinary ( int num ) <nl> + { <nl> + return String . format ( " % 16s " , Integer . toBinaryString ( num ) ) . replace ( ' ' , ' 0 ' ) ; <nl> + } <nl> + <nl> + private int getFixedAccess ( int access , Modifier target ) <nl> + { <nl> + target . oldAccess = access ; <nl> + int t = target . targetAccess ; <nl> + int ret = ( access & ~ 7 ) ; <nl> + <nl> + switch ( access & 7 ) <nl> + { <nl> + case ACC _ PRIVATE : <nl> + ret | = t ; <nl> + break ; <nl> + case 0 : / / default <nl> + ret | = ( t ! = ACC _ PRIVATE ? t : 0 / * default * / ) ; <nl> + break ; <nl> + case ACC _ PROTECTED : <nl> + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / ? t : ACC _ PROTECTED ) ; <nl> + break ; <nl> + case ACC _ PUBLIC : <nl> + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / & & t ! = ACC _ PROTECTED ? t : ACC _ PUBLIC ) ; <nl> + break ; <nl> + default : <nl> + throw new RuntimeException ( " The fuck ? " ) ; <nl> + } <nl> + target . newAccess = ret ; <nl> + return ret ; <nl> + } <nl> + <nl> + public static void main ( String [ ] args ) <nl> + { <nl> + if ( args . length < 2 ) <nl> + { <nl> + System . out . println ( " Usage : AccessTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; <nl> + return ; <nl> + } <nl> + <nl> + boolean hasTransformer = false ; <nl> + AccessTransformer [ ] trans = new AccessTransformer [ args . length - 1 ] ; <nl> + for ( int x = 1 ; x < args . length ; x + + ) <nl> + { <nl> + try <nl> + { <nl> + trans [ x - 1 ] = new AccessTransformer ( args [ x ] ) ; <nl> + hasTransformer = true ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + if ( ! hasTransformer ) <nl> + { <nl> + System . out . println ( " Culd not find a valid transformer to perform " ) ; <nl> + return ; <nl> + } <nl> + <nl> + File orig = new File ( args [ 0 ] ) ; <nl> + File temp = new File ( args [ 0 ] + " . ATBack " ) ; <nl> + if ( ! orig . exists ( ) & & ! temp . exists ( ) ) <nl> + { <nl> + System . out . println ( " Could not find target jar : " + orig ) ; <nl> + return ; <nl> + } <nl> + <nl> + if ( temp . exists ( ) ) <nl> + { <nl> + if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) <nl> + { <nl> + System . out . println ( " Could not backup existing file : " + orig ) ; <nl> + return ; <nl> + } <nl> + if ( ! temp . renameTo ( orig ) ) <nl> + { <nl> + System . out . println ( " Could not restore backup from previous run : " + temp ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + if ( ! orig . renameTo ( temp ) ) <nl> + { <nl> + System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; <nl> + return ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + processJar ( temp , orig , trans ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + private static void processJar ( File inFile , File outFile , AccessTransformer [ ] transformers ) throws IOException <nl> + { <nl> + ZipInputStream inJar = null ; <nl> + ZipOutputStream outJar = null ; <nl> + <nl> + try <nl> + { <nl> + try <nl> + { <nl> + inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; <nl> + } <nl> + <nl> + ZipEntry entry ; <nl> + while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) <nl> + { <nl> + if ( entry . isDirectory ( ) ) <nl> + { <nl> + outJar . putNextEntry ( entry ) ; <nl> + continue ; <nl> + } <nl> + <nl> + byte [ ] data = new byte [ 4096 ] ; <nl> + ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; <nl> + <nl> + int len ; <nl> + do <nl> + { <nl> + len = inJar . read ( data ) ; <nl> + if ( len > 0 ) <nl> + { <nl> + entryBuffer . write ( data , 0 , len ) ; <nl> + } <nl> + } <nl> + while ( len ! = - 1 ) ; <nl> + <nl> + byte [ ] entryData = entryBuffer . toByteArray ( ) ; <nl> + <nl> + String entryName = entry . getName ( ) ; <nl> + <nl> + if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) <nl> + { <nl> + ClassNode cls = new ClassNode ( ) ; <nl> + ClassReader rdr = new ClassReader ( entryData ) ; <nl> + rdr . accept ( cls , 0 ) ; <nl> + String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; <nl> + <nl> + for ( AccessTransformer trans : transformers ) <nl> + { <nl> + entryData = trans . transform ( name , entryData ) ; <nl> + } <nl> + } <nl> + <nl> + ZipEntry newEntry = new ZipEntry ( entryName ) ; <nl> + outJar . putNextEntry ( newEntry ) ; <nl> + outJar . write ( entryData ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + if ( outJar ! = null ) <nl> + { <nl> + try <nl> + { <nl> + outJar . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + } <nl> + } <nl> + <nl> + if ( inJar ! = null ) <nl> + { <nl> + try <nl> + { <nl> + inJar . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> \ No newline at end of file

TEST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java b / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java 
 index defb8df . . 2e6dd0e 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java 
 + + + b / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java 
 @ @ - 4 , 6 + 4 , 9 @ @ import static org . lwjgl . opengl . GL11 . * ; 
 import static org . lwjgl . opengl . GL12 . * ; 
 
 import java . awt . image . BufferedImage ; 
 + import java . io . File ; 
 + import java . io . FileReader ; 
 + import java . io . FileWriter ; 
 import java . io . IOException ; 
 import java . io . InputStream ; 
 import java . lang . Thread . UncaughtExceptionHandler ; 
 @ @ - 39 , 6 + 42 , 7 @ @ import org . lwjgl . util . glu . GLU ; 
 import cpw . mods . fml . common . FMLCommonHandler ; 
 import cpw . mods . fml . common . FMLLog ; 
 import cpw . mods . fml . common . ICrashCallable ; 
 + import cpw . mods . fml . common . Loader ; 
 import cpw . mods . fml . common . ProgressManager ; 
 import cpw . mods . fml . common . ProgressManager . ProgressBar ; 
 import cpw . mods . fml . common . asm . FMLSanityChecker ; 
 @ @ - 59 , 26 + 63 , 97 @ @ public class SplashProgress 
 private static SplashFontRenderer fontRenderer ; 
 
 private static final IResourcePack mcPack = Minecraft . getMinecraft ( ) . mcDefaultResourcePack ; 
 - private static final IResourcePack fmlPack = createFmlResourcePack ( ) ; 
 + private static final IResourcePack fmlPack = createResourcePack ( FMLSanityChecker . fmlLocation ) ; 
 + private static IResourcePack miscPack ; 
 
 private static Texture fontTexture ; 
 private static Texture logoTexture ; 
 private static Texture forgeTexture ; 
 
 - private static ResourceLocation configLocation = new ResourceLocation ( " fml " , " splash . properties " ) ; 
 - private static final Properties config = loadConfig ( ) ; 
 + private static Properties config ; 
 
 - private static final boolean enabled = Boolean . parseBoolean ( config . getProperty ( " enabled " ) ) & & ! FMLClientHandler . instance ( ) . hasOptifine ( ) ; 
 - private static final boolean rotate = Boolean . parseBoolean ( config . getProperty ( " rotate " ) ) ; 
 - private static final int logoOffset = getInt ( " logoOffset " ) ; 
 - private static final int backgroundColor = getInt ( " background " ) ; 
 - private static final int fontColor = getInt ( " font " ) ; 
 - private static final int barBorderColor = getInt ( " barBorder " ) ; 
 - private static final int barColor = getInt ( " bar " ) ; 
 - private static final int barBackgroundColor = getInt ( " barBackground " ) ; 
 + private static boolean enabled ; 
 + private static boolean rotate ; 
 + private static int logoOffset ; 
 + private static int backgroundColor ; 
 + private static int fontColor ; 
 + private static int barBorderColor ; 
 + private static int barColor ; 
 + private static int barBackgroundColor ; 
 + 
 + private static String getString ( String name , String def ) 
 + { 
 + String value = config . getProperty ( name , def ) ; 
 + config . setProperty ( name , value ) ; 
 + return value ; 
 + } 
 + 
 + private static boolean getBool ( String name , boolean def ) 
 + { 
 + return Boolean . parseBoolean ( getString ( name , Boolean . toString ( def ) ) ) ; 
 + } 
 + 
 + private static int getInt ( String name , int def ) 
 + { 
 + return Integer . decode ( getString ( name , Integer . toString ( def ) ) ) ; 
 + } 
 + 
 + private static int getHex ( String name , int def ) 
 + { 
 + return Integer . decode ( getString ( name , " 0x " + Integer . toString ( def , 16 ) . toUpperCase ( ) ) ) ; 
 + } 
 
 public static void start ( ) 
 { 
 + File configFile = new File ( Minecraft . getMinecraft ( ) . mcDataDir , " config / splash . properties " ) ; 
 + FileReader r = null ; 
 + config = new Properties ( ) ; 
 + try 
 + { 
 + r = new FileReader ( configFile ) ; 
 + config . load ( r ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + FMLLog . info ( " Could not load splash . properties , will create a default one " ) ; 
 + } 
 + finally 
 + { 
 + IOUtils . closeQuietly ( r ) ; 
 + } 
 + 
 + enabled = getBool ( " enabled " , true ) & & ! FMLClientHandler . instance ( ) . hasOptifine ( ) ; 
 + rotate = getBool ( " rotate " , true ) ; 
 + logoOffset = getInt ( " logoOffset " , 10 ) ; 
 + backgroundColor = getHex ( " background " , 0xFFFFFF ) ; 
 + fontColor = getHex ( " font " , 0x000000 ) ; 
 + barBorderColor = getHex ( " barBorder " , 0xC0C0C0 ) ; 
 + barColor = getHex ( " bar " , 0xCB3D35 ) ; 
 + barBackgroundColor = getHex ( " barBackground " , 0xFFFFFF ) ; 
 + 
 + final ResourceLocation fontLoc = new ResourceLocation ( getString ( " fontTexture " , " textures / font / ascii . png " ) ) ; 
 + final ResourceLocation logoLoc = new ResourceLocation ( getString ( " logoTexture " , " textures / gui / title / mojang . png " ) ) ; 
 + final ResourceLocation forgeLoc = new ResourceLocation ( getString ( " forgeTexture " , " fml : textures / gui / forge . png " ) ) ; 
 + 
 + File miscPackFile = new File ( Minecraft . getMinecraft ( ) . mcDataDir , getString ( " resourcePackPath " , " resources " ) ) ; 
 + 
 + FileWriter w = null ; 
 + try 
 + { 
 + w = new FileWriter ( configFile ) ; 
 + config . store ( w , " Splash screen properties " ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + FMLLog . log ( Level . ERROR , e , " Could not save the splash . properties file " ) ; 
 + } 
 + finally 
 + { 
 + IOUtils . closeQuietly ( w ) ; 
 + } 
 + 
 + miscPack = createResourcePack ( miscPackFile ) ; 
 + 
 if ( ! enabled ) return ; 
 / / getting debug info out of the way , while we still can 
 FMLCommonHandler . instance ( ) . registerCrashCallable ( new ICrashCallable ( ) 
 @ @ - 121 , 9 + 196 , 9 @ @ public class SplashProgress 
 public void run ( ) 
 { 
 setGL ( ) ; 
 - fontTexture = new Texture ( mcPack , new ResourceLocation ( " textures / font / ascii . png " ) ) ; 
 - logoTexture = new Texture ( mcPack , new ResourceLocation ( " textures / gui / title / mojang . png " ) ) ; 
 - forgeTexture = new Texture ( fmlPack , new ResourceLocation ( config . getProperty ( " forgeTexture " ) ) ) ; 
 + fontTexture = new Texture ( fontLoc ) ; 
 + logoTexture = new Texture ( logoLoc ) ; 
 + forgeTexture = new Texture ( forgeLoc ) ; 
 glEnable ( GL _ TEXTURE _ 2D ) ; 
 fontRenderer = new SplashFontRenderer ( ) ; 
 glDisable ( GL _ TEXTURE _ 2D ) ; 
 @ @ - 409 , 44 + 484 , 18 @ @ public class SplashProgress 
 } 
 } 
 
 - private static IResourcePack createFmlResourcePack ( ) 
 + private static IResourcePack createResourcePack ( File file ) 
 { 
 - if ( FMLSanityChecker . fmlLocation . isDirectory ( ) ) 
 + if ( file . isDirectory ( ) ) 
 { 
 - return new FolderResourcePack ( FMLSanityChecker . fmlLocation ) ; 
 + return new FolderResourcePack ( file ) ; 
 } 
 else 
 { 
 - return new FileResourcePack ( FMLSanityChecker . fmlLocation ) ; 
 - } 
 - } 
 - 
 - private static Properties loadConfig ( ) 
 - { 
 - InputStream s = null ; 
 - try 
 - { 
 - s = fmlPack . getInputStream ( configLocation ) ; 
 - Properties config = new Properties ( ) ; 
 - config . load ( s ) ; 
 - return config ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - e . printStackTrace ( ) ; 
 - throw new RuntimeException ( e ) ; 
 - } 
 - finally 
 - { 
 - IOUtils . closeQuietly ( s ) ; 
 + return new FileResourcePack ( file ) ; 
 } 
 } 
 
 - private static int getInt ( String name ) 
 - { 
 - return Integer . decode ( config . getProperty ( name ) ) ; 
 - } 
 - 
 private static final IntBuffer buf = BufferUtils . createIntBuffer ( 4 * 1024 * 1024 ) ; 
 
 private static class Texture 
 @ @ - 458 , 13 + 507 , 13 @ @ public class SplashProgress 
 private final int frames ; 
 private final int size ; 
 
 - public Texture ( IResourcePack pack , ResourceLocation location ) 
 + public Texture ( ResourceLocation location ) 
 { 
 InputStream s = null ; 
 try 
 { 
 this . location = location ; 
 - s = pack . getInputStream ( location ) ; 
 + s = open ( location ) ; 
 ImageInputStream stream = ImageIO . createImageInputStream ( s ) ; 
 Iterator < ImageReader > readers = ImageIO . getImageReaders ( stream ) ; 
 if ( ! readers . hasNext ( ) ) throw new IOException ( " No suitable reader found for image " + location ) ; 
 @ @ - 493 , 7 + 542 , 6 @ @ public class SplashProgress 
 { 
 for ( int j = 0 ; i * ( size / width ) + j < frames & & j < size / width ; j + + ) 
 { 
 - FMLLog . info ( " loc : % s , i : % s , j : % s , size : % s , width : % s , height : % s " , location , i , j , size , width , height ) ; 
 buf . clear ( ) ; 
 BufferedImage image = images [ i * ( size / width ) + j ] ; 
 for ( int k = 0 ; k < height ; k + + ) 
 @ @ - 624 , 4 + 672 , 17 @ @ public class SplashProgress 
 throw new IllegalStateException ( where + " : " + GLU . gluErrorString ( err ) ) ; 
 } 
 } 
 + 
 + private static InputStream open ( ResourceLocation loc ) throws IOException 
 + { 
 + if ( miscPack . resourceExists ( loc ) ) 
 + { 
 + return miscPack . getInputStream ( loc ) ; 
 + } 
 + else if ( fmlPack . resourceExists ( loc ) ) 
 + { 
 + return fmlPack . getInputStream ( loc ) ; 
 + } 
 + return mcPack . getInputStream ( loc ) ; 
 + } 
 } 
 diff - - git a / fml / src / main / resources / assets / fml / splash . properties b / fml / src / main / resources / assets / fml / splash . properties 
 deleted file mode 100644 
 index 4cfb4f5 . . 0000000 
 - - - a / fml / src / main / resources / assets / fml / splash . properties 
 + + + / dev / null 
 @ @ - 1 , 10 + 0 , 0 @ @ 
 - enabled = true 
 - rotate = true 
 - 
 - forgeTexture = fml : textures / gui / forge . png 
 - logoOffset = 10 
 - background = 0xFFFFFF 
 - font = 0x000000 
 - barBorder = 0xC0C0C0 
 - bar = 0xCB3D35 
 - barBackground = 0xFFFFFF

NEAREST DIFF:
diff - - git a / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java 
 new file mode 100644 
 index 0000000 . . 760284e 
 - - - / dev / null 
 + + + b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java 
 @ @ - 0 , 0 + 1 , 357 @ @ 
 + package cpw . mods . fml . common . asm . transformers ; 
 + 
 + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; 
 + 
 + import java . io . BufferedInputStream ; 
 + import java . io . BufferedOutputStream ; 
 + import java . io . BufferedReader ; 
 + import java . io . ByteArrayOutputStream ; 
 + import java . io . File ; 
 + import java . io . FileInputStream ; 
 + import java . io . FileNotFoundException ; 
 + import java . io . FileOutputStream ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . io . InputStreamReader ; 
 + import java . net . URL ; 
 + import java . text . SimpleDateFormat ; 
 + import java . util . ArrayList ; 
 + import java . util . Collection ; 
 + import java . util . Date ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + import java . util . zip . ZipEntry ; 
 + import java . util . zip . ZipInputStream ; 
 + import java . util . zip . ZipOutputStream ; 
 + 
 + import org . objectweb . asm . ClassReader ; 
 + import org . objectweb . asm . ClassWriter ; 
 + import org . objectweb . asm . Type ; 
 + import org . objectweb . asm . tree . ClassNode ; 
 + import org . objectweb . asm . tree . FieldNode ; 
 + import org . objectweb . asm . tree . MethodNode ; 
 + 
 + import com . google . common . base . CharMatcher ; 
 + import com . google . common . base . Charsets ; 
 + import com . google . common . base . Splitter ; 
 + import com . google . common . base . Strings ; 
 + import com . google . common . collect . ArrayListMultimap ; 
 + import com . google . common . collect . Iterables ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Multimap ; 
 + import com . google . common . io . LineProcessor ; 
 + import com . google . common . io . Resources ; 
 + 
 + import cpw . mods . fml . relauncher . IClassTransformer ; 
 + 
 + public class AccessTransformer implements IClassTransformer 
 + { 
 + private class Modifier 
 + { 
 + public String name = " " ; 
 + public String desc = " " ; 
 + public int oldAccess = 0 ; 
 + public int newAccess = 0 ; 
 + public int targetAccess = 0 ; 
 + 
 + private void setTargetAccess ( String name ) 
 + { 
 + if ( name . equalsIgnoreCase ( " public " ) ) targetAccess = ACC _ PUBLIC ; 
 + else if ( name . equalsIgnoreCase ( " private " ) ) targetAccess = ACC _ PRIVATE ; 
 + else if ( name . equalsIgnoreCase ( " protected " ) ) targetAccess = ACC _ PROTECTED ; 
 + } 
 + } 
 + 
 + private Multimap < String , Modifier > modifiers = ArrayListMultimap . create ( ) ; 
 + 
 + public AccessTransformer ( ) throws IOException 
 + { 
 + this ( " / rules . csv " ) ; 
 + } 
 + protected AccessTransformer ( String rulesFile ) throws IOException 
 + { 
 + readMapFile ( rulesFile ) ; 
 + } 
 + 
 + private void readMapFile ( String rulesFile ) throws IOException 
 + { 
 + URL rulesResource = Resources . getResource ( rulesFile ) ; 
 + Resources . readLines ( rulesResource , Charsets . UTF _ 8 , new LineProcessor < Void > ( ) 
 + { 
 + @ Override 
 + public Void getResult ( ) 
 + { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public boolean processLine ( String input ) throws IOException 
 + { 
 + String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; 
 + if ( line . length ( ) = = 0 ) 
 + { 
 + return true ; 
 + } 
 + List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; 
 + if ( parts . size ( ) > 2 | | parts . get ( 1 ) . indexOf ( ' . ' ) = = - 1 ) 
 + { 
 + throw new RuntimeException ( " Invalid config file line " + input ) ; 
 + } 
 + Modifier m = new Modifier ( ) ; 
 + m . setTargetAccess ( parts . get ( 0 ) ) ; 
 + List < String > descriptor = Lists . newArrayList ( Splitter . on ( " . " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; 
 + List < String > method = Lists . newArrayList ( Splitter . on ( CharMatcher . anyOf ( " ( ) " ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( descriptor . get ( 1 ) ) ) ; 
 + if ( method . size ( ) = = 2 ) 
 + { 
 + m . desc = method . get ( 1 ) ; 
 + } 
 + m . name = method . get ( 0 ) ; 
 + modifiers . put ( descriptor . get ( 0 ) , m ) ; 
 + return true ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + @ Override 
 + public byte [ ] transform ( String name , byte [ ] bytes ) 
 + { 
 + if ( ! modifiers . containsKey ( name ) ) { return bytes ; } 
 + 
 + ClassNode classNode = new ClassNode ( ) ; 
 + ClassReader classReader = new ClassReader ( bytes ) ; 
 + classReader . accept ( classNode , 0 ) ; 
 + 
 + Collection < Modifier > mods = modifiers . get ( name ) ; 
 + for ( Modifier m : mods ) 
 + { 
 + if ( m . desc . isEmpty ( ) ) 
 + { 
 + for ( FieldNode n : ( List < FieldNode > ) classNode . fields ) 
 + { 
 + if ( n . name . equals ( m . name ) ) 
 + { 
 + n . access = getFixedAccess ( n . access , m ) ; 
 + System . out . println ( String . format ( " Field : % s . % s % s - > % s " , name , m . name , Integer . toBinaryString ( m . oldAccess ) , 
 + Integer . toBinaryString ( m . newAccess ) ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + else 
 + { 
 + for ( MethodNode n : ( List < MethodNode > ) classNode . methods ) 
 + { 
 + if ( n . name . equals ( m . name ) & & n . desc . equals ( m . desc ) ) 
 + { 
 + n . access = getFixedAccess ( n . access , m ) ; 
 + System . out . println ( String . format ( " Method : % s . % s % s % s - > % s " , name , m . name , m . desc , toBinary ( m . oldAccess ) , toBinary ( m . newAccess ) ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; 
 + classNode . accept ( writer ) ; 
 + return writer . toByteArray ( ) ; 
 + } 
 + 
 + private String toBinary ( int num ) 
 + { 
 + return String . format ( " % 16s " , Integer . toBinaryString ( num ) ) . replace ( ' ' , ' 0 ' ) ; 
 + } 
 + 
 + private int getFixedAccess ( int access , Modifier target ) 
 + { 
 + target . oldAccess = access ; 
 + int t = target . targetAccess ; 
 + int ret = ( access & ~ 7 ) ; 
 + 
 + switch ( access & 7 ) 
 + { 
 + case ACC _ PRIVATE : 
 + ret | = t ; 
 + break ; 
 + case 0 : / / default 
 + ret | = ( t ! = ACC _ PRIVATE ? t : 0 / * default * / ) ; 
 + break ; 
 + case ACC _ PROTECTED : 
 + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / ? t : ACC _ PROTECTED ) ; 
 + break ; 
 + case ACC _ PUBLIC : 
 + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / & & t ! = ACC _ PROTECTED ? t : ACC _ PUBLIC ) ; 
 + break ; 
 + default : 
 + throw new RuntimeException ( " The fuck ? " ) ; 
 + } 
 + target . newAccess = ret ; 
 + return ret ; 
 + } 
 + 
 + public static void main ( String [ ] args ) 
 + { 
 + if ( args . length < 2 ) 
 + { 
 + System . out . println ( " Usage : AccessTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; 
 + return ; 
 + } 
 + 
 + boolean hasTransformer = false ; 
 + AccessTransformer [ ] trans = new AccessTransformer [ args . length - 1 ] ; 
 + for ( int x = 1 ; x < args . length ; x + + ) 
 + { 
 + try 
 + { 
 + trans [ x - 1 ] = new AccessTransformer ( args [ x ] ) ; 
 + hasTransformer = true ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + if ( ! hasTransformer ) 
 + { 
 + System . out . println ( " Culd not find a valid transformer to perform " ) ; 
 + return ; 
 + } 
 + 
 + File orig = new File ( args [ 0 ] ) ; 
 + File temp = new File ( args [ 0 ] + " . ATBack " ) ; 
 + if ( ! orig . exists ( ) & & ! temp . exists ( ) ) 
 + { 
 + System . out . println ( " Could not find target jar : " + orig ) ; 
 + return ; 
 + } 
 + 
 + if ( temp . exists ( ) ) 
 + { 
 + if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) 
 + { 
 + System . out . println ( " Could not backup existing file : " + orig ) ; 
 + return ; 
 + } 
 + if ( ! temp . renameTo ( orig ) ) 
 + { 
 + System . out . println ( " Could not restore backup from previous run : " + temp ) ; 
 + return ; 
 + } 
 + } 
 + 
 + if ( ! orig . renameTo ( temp ) ) 
 + { 
 + System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; 
 + return ; 
 + } 
 + 
 + try 
 + { 
 + processJar ( temp , orig , trans ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + private static void processJar ( File inFile , File outFile , AccessTransformer [ ] transformers ) throws IOException 
 + { 
 + ZipInputStream inJar = null ; 
 + ZipOutputStream outJar = null ; 
 + 
 + try 
 + { 
 + try 
 + { 
 + inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; 
 + } 
 + 
 + try 
 + { 
 + outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; 
 + } 
 + 
 + ZipEntry entry ; 
 + while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) 
 + { 
 + if ( entry . isDirectory ( ) ) 
 + { 
 + outJar . putNextEntry ( entry ) ; 
 + continue ; 
 + } 
 + 
 + byte [ ] data = new byte [ 4096 ] ; 
 + ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; 
 + 
 + int len ; 
 + do 
 + { 
 + len = inJar . read ( data ) ; 
 + if ( len > 0 ) 
 + { 
 + entryBuffer . write ( data , 0 , len ) ; 
 + } 
 + } 
 + while ( len ! = - 1 ) ; 
 + 
 + byte [ ] entryData = entryBuffer . toByteArray ( ) ; 
 + 
 + String entryName = entry . getName ( ) ; 
 + 
 + if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) 
 + { 
 + ClassNode cls = new ClassNode ( ) ; 
 + ClassReader rdr = new ClassReader ( entryData ) ; 
 + rdr . accept ( cls , 0 ) ; 
 + String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; 
 + 
 + for ( AccessTransformer trans : transformers ) 
 + { 
 + entryData = trans . transform ( name , entryData ) ; 
 + } 
 + } 
 + 
 + ZipEntry newEntry = new ZipEntry ( entryName ) ; 
 + outJar . putNextEntry ( newEntry ) ; 
 + outJar . write ( entryData ) ; 
 + } 
 + } 
 + finally 
 + { 
 + if ( outJar ! = null ) 
 + { 
 + try 
 + { 
 + outJar . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + } 
 + } 
 + 
 + if ( inJar ! = null ) 
 + { 
 + try 
 + { 
 + inJar . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + } 
 + } 
 + } 
 + } 
 + } 
 \ No newline at end of file
