BLEU SCORE: 0.002124269490650393

TEST MSG: BiomeDictionary code cleanup
GENERATED MSG: Enhanced the Biome Dictionary with tags based on temperature , vegetation , moisture , trees and others

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / BiomeDictionary . java b / src / main / java / net / minecraftforge / common / BiomeDictionary . java <nl> index 84ae7a9 . . d23b244 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / BiomeDictionary . java <nl> + + + b / src / main / java / net / minecraftforge / common / BiomeDictionary . java <nl> @ @ - 21 , 133 + 21 , 140 @ @ package net . minecraftforge . common ; <nl> <nl> import java . util . * ; <nl> <nl> - import net . minecraftforge . fml . common . FMLLog ; <nl> + import javax . annotation . Nonnull ; <nl> <nl> import net . minecraft . init . Biomes ; <nl> import net . minecraft . init . Blocks ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraft . world . biome . * ; <nl> - import net . minecraftforge . common . util . EnumHelper ; <nl> - import net . minecraftforge . event . terraingen . DeferredBiomeDecorator ; <nl> import static net . minecraftforge . common . BiomeDictionary . Type . * ; <nl> + import net . minecraftforge . fml . common . FMLLog ; <nl> + import net . minecraftforge . fml . common . registry . ForgeRegistries ; <nl> + <nl> + import com . google . common . base . Preconditions ; <nl> + import com . google . common . collect . ImmutableList ; <nl> <nl> public class BiomeDictionary <nl> { <nl> - public enum Type <nl> + public static final class Type <nl> { <nl> + <nl> + private static final Map < String , Type > byName = new HashMap < String , Type > ( ) ; <nl> + <nl> / * Temperature - based tags . Specifying neither implies a biome is temperate * / <nl> - HOT , <nl> - COLD , <nl> + public static final Type HOT = new Type ( " HOT " ) ; <nl> + public static final Type COLD = new Type ( " COLD " ) ; <nl> + <nl> / * Tags specifying the amount of vegetation a biome has . Specifying neither implies a biome to have moderate amounts * / <nl> - SPARSE , <nl> - DENSE , <nl> + public static final Type SPARSE = new Type ( " SPARSE " ) ; <nl> + public static final Type DENSE = new Type ( " DENSE " ) ; <nl> + <nl> / * Tags specifying how moist a biome is . Specifying neither implies the biome as having moderate humidity * / <nl> - WET , <nl> - DRY , <nl> + public static final Type WET = new Type ( " WET " ) ; <nl> + public static final Type DRY = new Type ( " DRY " ) ; <nl> + <nl> / * Tree - based tags , SAVANNA refers to dry , desert - like trees ( Such as Acacia ) , CONIFEROUS refers to snowy trees ( Such as Spruce ) and JUNGLE refers to jungle trees . <nl> * Specifying no tag implies a biome has temperate trees ( Such as Oak ) * / <nl> - SAVANNA , <nl> - CONIFEROUS , <nl> - JUNGLE , <nl> + public static final Type SAVANNA = new Type ( " SAVANNA " ) ; <nl> + public static final Type CONIFEROUS = new Type ( " CONIFEROUS " ) ; <nl> + public static final Type JUNGLE = new Type ( " JUNGLE " ) ; <nl> <nl> / * Tags specifying the nature of a biome * / <nl> - SPOOKY , <nl> - DEAD , <nl> - LUSH , <nl> - NETHER , <nl> - END , <nl> - MUSHROOM , <nl> - MAGICAL , <nl> - <nl> - OCEAN , <nl> - RIVER , <nl> - / * * A general tag for all water - based biomes . Shown as present if OCEAN or RIVER are . * * / <nl> - WATER ( OCEAN , RIVER ) , <nl> + public static final Type SPOOKY = new Type ( " SPOOKY " ) ; <nl> + public static final Type DEAD = new Type ( " DEAD " ) ; <nl> + public static final Type LUSH = new Type ( " LUSH " ) ; <nl> + public static final Type NETHER = new Type ( " NETHER " ) ; <nl> + public static final Type END = new Type ( " END " ) ; <nl> + public static final Type MUSHROOM = new Type ( " MUSHROOM " ) ; <nl> + public static final Type MAGICAL = new Type ( " MAGICAL " ) ; <nl> + <nl> + public static final Type OCEAN = new Type ( " OCEAN " ) ; <nl> + public static final Type RIVER = new Type ( " RIVER " ) ; <nl> + / * * <nl> + * A general tag for all water - based biomes . Shown as present if OCEAN or RIVER are . <nl> + * * / <nl> + public static final Type WATER = new Type ( " WATER " , OCEAN , RIVER ) ; <nl> <nl> / * Generic types which a biome can be * / <nl> - MESA , <nl> - FOREST , <nl> - PLAINS , <nl> - MOUNTAIN , <nl> - HILLS , <nl> - SWAMP , <nl> - SANDY , <nl> - SNOWY , <nl> - WASTELAND , <nl> - BEACH ; <nl> - <nl> - private List < Type > subTags ; <nl> - <nl> - private Type ( Type . . . subTags ) <nl> + public static final Type MESA = new Type ( " MESA " ) ; <nl> + public static final Type FOREST = new Type ( " FOREST " ) ; <nl> + public static final Type PLAINS = new Type ( " PLAINS " ) ; <nl> + public static final Type MOUNTAIN = new Type ( " MOUNTAIN " ) ; <nl> + public static final Type HILLS = new Type ( " HILLS " ) ; <nl> + public static final Type SWAMP = new Type ( " SWAMP " ) ; <nl> + public static final Type SANDY = new Type ( " SANDY " ) ; <nl> + public static final Type SNOWY = new Type ( " SNOWY " ) ; <nl> + public static final Type WASTELAND = new Type ( " WASTELAND " ) ; <nl> + public static final Type BEACH = new Type ( " BEACH " ) ; <nl> + <nl> + private final String name ; <nl> + private final List < Type > subTypes ; <nl> + private final Set < Biome > biomes = new HashSet < Biome > ( ) ; <nl> + private final Set < Biome > biomesUn = Collections . unmodifiableSet ( biomes ) ; <nl> + <nl> + private Type ( String name , Type . . . subTypes ) <nl> + { <nl> + this . name = name ; <nl> + this . subTypes = ImmutableList . copyOf ( subTypes ) ; <nl> + <nl> + byName . put ( name , this ) ; <nl> + } <nl> + <nl> + private boolean hasSubTypes ( ) <nl> + { <nl> + return ! subTypes . isEmpty ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Gets the name for this type . <nl> + * / <nl> + public String getName ( ) <nl> { <nl> - this . subTags = Arrays . asList ( subTags ) ; <nl> + return name ; <nl> } <nl> <nl> - private boolean hasSubTags ( ) <nl> + public String toString ( ) <nl> { <nl> - return subTags ! = null & & ! subTags . isEmpty ( ) ; <nl> + return name ; <nl> } <nl> <nl> / * * <nl> - * Retrieves a Type value by name , <nl> + * Retrieves a Type instance by name , <nl> * if one does not exist already it creates one . <nl> * This can be used as intermediate measure for modders to <nl> - * add their own category of Biome . <nl> - * <nl> - * There are NO naming conventions besides : <nl> - * MUST be all upper case ( enforced by name . toUpper ( ) ) <nl> - * NO Special characters . { Unenforced , just don ' t be a pain , if it becomes a issue I WILL <nl> - * make this RTE with no worry about backwards compatibility } <nl> - * <nl> + * add their own Biome types . <nl> + * < p > <nl> + * There are < i > no < / i > naming conventions besides : <nl> + * < ul > < li > < b > Must < / b > be all upper case ( enforced by name . toUpper ( ) ) < / li > <nl> + * < li > < b > No < / b > Special characters . { Unenforced , just don ' t be a pain , if it becomes a issue I WILL <nl> + * make this RTE with no worry about backwards compatibility } < / li > < / ul > <nl> + * < p > <nl> * Note : For performance sake , the return value of this function SHOULD be cached . <nl> * Two calls with the same name SHOULD return the same value . <nl> * <nl> - * <nl> * @ param name The name of this Type <nl> * @ return An instance of Type for this name . <nl> * / <nl> public static Type getType ( String name , Type . . . subTypes ) <nl> { <nl> name = name . toUpperCase ( ) ; <nl> - for ( Type t : values ( ) ) <nl> - { <nl> - if ( t . name ( ) . equals ( name ) ) <nl> - return t ; <nl> - } <nl> - Type ret = EnumHelper . addEnum ( Type . class , name , new Class [ ] { Type [ ] . class } , new Object [ ] { subTypes } ) ; <nl> - if ( ret . ordinal ( ) > = typeInfoList . length ) <nl> - { <nl> - typeInfoList = Arrays . copyOf ( typeInfoList , ret . ordinal ( ) + 1 ) ; <nl> - } <nl> - for ( BiomeInfo bInfo : biomeInfoMap . values ( ) ) <nl> + Type t = byName . get ( name ) ; <nl> + if ( t = = null ) <nl> { <nl> - if ( bInfo ! = null ) <nl> - { <nl> - EnumSet < Type > oldSet = bInfo . typeList ; <nl> - bInfo . typeList = EnumSet . noneOf ( Type . class ) ; <nl> - bInfo . typeList . addAll ( oldSet ) ; <nl> - } <nl> + t = new Type ( name , subTypes ) ; <nl> } <nl> - return ret ; <nl> + return t ; <nl> } <nl> } <nl> <nl> - private static HashMap < ResourceLocation , BiomeInfo > biomeInfoMap = new HashMap < ResourceLocation , BiomeInfo > ( ) ; <nl> - @ SuppressWarnings ( " unchecked " ) <nl> - private static ArrayList < Biome > [ ] typeInfoList = new ArrayList [ Type . values ( ) . length ] ; <nl> + private static final Map < ResourceLocation , BiomeInfo > biomeInfoMap = new HashMap < ResourceLocation , BiomeInfo > ( ) ; <nl> <nl> private static class BiomeInfo <nl> { <nl> - public EnumSet < Type > typeList ; <nl> <nl> - public BiomeInfo ( Type [ ] types ) <nl> - { <nl> - typeList = EnumSet . noneOf ( Type . class ) ; <nl> - for ( Type t : types ) <nl> - { <nl> - typeList . add ( t ) ; <nl> - } <nl> - } <nl> + private final Set < Type > types = new HashSet < Type > ( ) ; <nl> + private final Set < Type > typesUn = Collections . unmodifiableSet ( this . types ) ; <nl> + <nl> } <nl> <nl> static <nl> @ @ - 156 , 90 + 163 , 54 @ @ public class BiomeDictionary <nl> } <nl> <nl> / * * <nl> - * Registers a biome with a specific biome type <nl> + * Adds the given types to the biome . <nl> * <nl> - * @ param biome the biome to be registered <nl> - * @ param types the types to register the biome as <nl> - * @ return returns true if the biome was registered successfully <nl> * / <nl> - public static boolean registerBiomeType ( Biome biome , Type . . . types ) <nl> + public static void addTypes ( Biome biome , Type . . . types ) <nl> { <nl> - types = listSubTags ( types ) ; <nl> - <nl> - if ( Biome . REGISTRY . getNameForObject ( biome ) ! = null ) <nl> - { <nl> - for ( Type type : types ) <nl> - { <nl> - if ( typeInfoList [ type . ordinal ( ) ] = = null ) <nl> - { <nl> - typeInfoList [ type . ordinal ( ) ] = new ArrayList < Biome > ( ) ; <nl> - } <nl> + Preconditions . checkArgument ( ForgeRegistries . BIOMES . containsValue ( biome ) , " Cannot add types to unregistered biome % s " , biome ) ; <nl> <nl> - typeInfoList [ type . ordinal ( ) ] . add ( biome ) ; <nl> - } <nl> - <nl> - if ( ! isBiomeRegistered ( biome ) ) <nl> - { <nl> - ResourceLocation location = Biome . REGISTRY . getNameForObject ( biome ) ; <nl> - biomeInfoMap . put ( location , new BiomeInfo ( types ) ) ; <nl> - } <nl> - else <nl> - { <nl> - for ( Type type : types ) <nl> - { <nl> - getBiomeInfo ( biome ) . typeList . add ( type ) ; <nl> - } <nl> - } <nl> + List < Type > subTypes = listSubTypes ( types ) ; <nl> <nl> - return true ; <nl> + for ( Type type : subTypes ) <nl> + { <nl> + type . biomes . add ( biome ) ; <nl> } <nl> <nl> - return false ; <nl> + getBiomeInfo ( biome ) . types . addAll ( subTypes ) ; <nl> } <nl> <nl> / * * <nl> - * Returns a list of biomes registered with a specific type <nl> + * Gets the set of biomes that have the given type . <nl> * <nl> - * @ param type the Type to look for <nl> - * @ return a list of biomes of the specified type , null if there are none <nl> * / <nl> - public static Biome [ ] getBiomesForType ( Type type ) <nl> + @ Nonnull <nl> + public static Set < Biome > getBiomes ( Type type ) <nl> { <nl> - if ( typeInfoList [ type . ordinal ( ) ] ! = null ) <nl> - { <nl> - return typeInfoList [ type . ordinal ( ) ] . toArray ( new Biome [ 0 ] ) ; <nl> - } <nl> - <nl> - return new Biome [ 0 ] ; <nl> + return type . biomesUn ; <nl> } <nl> <nl> / * * <nl> - * Gets a list of Types that a specific biome is registered with <nl> + * Gets the set of types that have been added to the given biome . <nl> * <nl> - * @ param biome the biome to check <nl> - * @ return the list of types , null if there are none <nl> * / <nl> - public static Type [ ] getTypesForBiome ( Biome biome ) <nl> + @ Nonnull <nl> + public static Set < Type > getTypes ( Biome biome ) <nl> { <nl> - checkRegistration ( biome ) ; <nl> - return getBiomeInfo ( biome ) . typeList . toArray ( new Type [ 0 ] ) ; <nl> + ensureHasTypes ( biome ) ; <nl> + return getBiomeInfo ( biome ) . typesUn ; <nl> } <nl> <nl> / * * <nl> - * Checks to see if two biomes are registered as having the same type <nl> + * Checks if the two given biomes have types in common . <nl> * <nl> - * @ param biomeA <nl> - * @ param biomeB <nl> * @ return returns true if a common type is found , false otherwise <nl> * / <nl> - public static boolean areBiomesEquivalent ( Biome biomeA , Biome biomeB ) <nl> + public static boolean areSimilar ( Biome biomeA , Biome biomeB ) <nl> { <nl> - checkRegistration ( biomeA ) ; <nl> - checkRegistration ( biomeB ) ; <nl> - <nl> - for ( Type type : getTypesForBiome ( biomeA ) ) <nl> + for ( Type type : getTypes ( biomeA ) ) <nl> { <nl> - if ( containsType ( getBiomeInfo ( biomeB ) , type ) ) <nl> + if ( containsType ( getTypes ( biomeB ) , type ) ) <nl> { <nl> return true ; <nl> } <nl> @ @ - 249 , 61 + 220 , 28 @ @ public class BiomeDictionary <nl> } <nl> <nl> / * * <nl> - * Checks to see if the given biome is registered as being a specific type <nl> + * Checks if the given type has been added to the given biome . <nl> * <nl> - * @ param biome the biome to be considered <nl> - * @ param type the type to check for <nl> - * @ return returns true if the biome is registered as being of type type , false otherwise <nl> - * / <nl> - public static boolean isBiomeOfType ( Biome biome , Type type ) <nl> - { <nl> - checkRegistration ( biome ) ; <nl> - return containsType ( getBiomeInfo ( biome ) , type ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Checks to see if the given biome has been registered as being of any type <nl> - * @ param biome the biome to consider <nl> - * @ return returns true if the biome has been registered , false otherwise <nl> * / <nl> - public static boolean isBiomeRegistered ( Biome biome ) <nl> + public static boolean hasType ( Biome biome , Type type ) <nl> { <nl> - return biomeInfoMap . containsKey ( Biome . REGISTRY . getNameForObject ( biome ) ) ; <nl> + return getTypes ( biome ) . contains ( type ) ; <nl> } <nl> <nl> - public static void registerAllBiomes ( ) <nl> - { <nl> - FMLLog . warning ( " Redundant call to BiomeDictionary . registerAllBiomes ignored " ) ; <nl> - } <nl> / * * <nl> - * Loops through the biome list and automatically adds tags to any biome that does not have any <nl> - * This is called by Forge at postinit time . It will additionally dispatch any deferred decorator <nl> - * creation events . <nl> + * Checks if any type has been added to the given biome . <nl> * <nl> - * DO NOT call this during world generation <nl> * / <nl> - public static void registerAllBiomesAndGenerateEvents ( ) <nl> + public static boolean hasAnyType ( Biome biome ) <nl> { <nl> - for ( ResourceLocation biomeResource : Biome . REGISTRY . getKeys ( ) ) <nl> - { <nl> - Biome biome = Biome . REGISTRY . getObject ( biomeResource ) ; <nl> - <nl> - if ( biome . theBiomeDecorator instanceof DeferredBiomeDecorator ) <nl> - { <nl> - DeferredBiomeDecorator decorator = ( DeferredBiomeDecorator ) biome . theBiomeDecorator ; <nl> - decorator . fireCreateEventAndReplace ( biome ) ; <nl> - } <nl> - <nl> - checkRegistration ( biome ) ; <nl> - } <nl> + return ! getBiomeInfo ( biome ) . types . isEmpty ( ) ; <nl> } <nl> <nl> / * * <nl> - * Automatically looks for and registers a given biome with appropriate tags <nl> - * This method is called automatically if a biome has not been registered with any tags , <nl> - * And another method requests information about it <nl> + * Automatically adds appropriate types to a given biome based on certain heuristics . <nl> + * If a biome ' s types are requested and no types have been added to the biome so far , the biome ' s types <nl> + * will be determined and added using this method . <nl> * <nl> - * @ param biome the biome to be considered <nl> * / <nl> public static void makeBestGuess ( Biome biome ) <nl> { <nl> @ @ - 311 , 189 + 249 , 202 @ @ public class BiomeDictionary <nl> { <nl> if ( biome . isHighHumidity ( ) & & biome . getTemperature ( ) > = 0 . 9F ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , JUNGLE ) ; <nl> + BiomeDictionary . addTypes ( biome , JUNGLE ) ; <nl> } <nl> else if ( ! biome . isHighHumidity ( ) ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , FOREST ) ; <nl> + BiomeDictionary . addTypes ( biome , FOREST ) ; <nl> <nl> if ( biome . getTemperature ( ) < = 0 . 2f ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , CONIFEROUS ) ; <nl> + BiomeDictionary . addTypes ( biome , CONIFEROUS ) ; <nl> } <nl> } <nl> } <nl> - else if ( biome . getHeightVariation ( ) < = 0 . 3F & & biome . getHeightVariation ( ) > = 0 . 0F ) <nl> + else if ( biome . getHeightVariation ( ) < = 0 . 3F & & biome . getHeightVariation ( ) > = 0 . 0F ) <nl> { <nl> - if ( ! biome . isHighHumidity ( ) | | biome . getBaseHeight ( ) > = 0 . 0F ) <nl> + if ( ! biome . isHighHumidity ( ) | | biome . getBaseHeight ( ) > = 0 . 0F ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , PLAINS ) ; <nl> + BiomeDictionary . addTypes ( biome , PLAINS ) ; <nl> } <nl> } <nl> <nl> if ( biome . getRainfall ( ) > 0 . 85f ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , WET ) ; <nl> + BiomeDictionary . addTypes ( biome , WET ) ; <nl> } <nl> <nl> if ( biome . getRainfall ( ) < 0 . 15f ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , DRY ) ; <nl> + BiomeDictionary . addTypes ( biome , DRY ) ; <nl> } <nl> <nl> if ( biome . getTemperature ( ) > 0 . 85f ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , HOT ) ; <nl> + BiomeDictionary . addTypes ( biome , HOT ) ; <nl> } <nl> <nl> if ( biome . getTemperature ( ) < 0 . 15f ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , COLD ) ; <nl> + BiomeDictionary . addTypes ( biome , COLD ) ; <nl> } <nl> <nl> if ( biome . theBiomeDecorator . treesPerChunk > 0 & & biome . theBiomeDecorator . treesPerChunk < 3 ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , SPARSE ) ; <nl> + BiomeDictionary . addTypes ( biome , SPARSE ) ; <nl> } <nl> else if ( biome . theBiomeDecorator . treesPerChunk > = 10 ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , DENSE ) ; <nl> + BiomeDictionary . addTypes ( biome , DENSE ) ; <nl> } <nl> <nl> if ( biome . isHighHumidity ( ) & & biome . getBaseHeight ( ) < 0 . 0F & & ( biome . getHeightVariation ( ) < = 0 . 3F & & biome . getHeightVariation ( ) > = 0 . 0F ) ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , SWAMP ) ; <nl> + BiomeDictionary . addTypes ( biome , SWAMP ) ; <nl> } <nl> <nl> if ( biome . getBaseHeight ( ) < = - 0 . 5F ) <nl> { <nl> if ( biome . getHeightVariation ( ) = = 0 . 0F ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , RIVER ) ; <nl> + BiomeDictionary . addTypes ( biome , RIVER ) ; <nl> } <nl> else <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , OCEAN ) ; <nl> + BiomeDictionary . addTypes ( biome , OCEAN ) ; <nl> } <nl> } <nl> <nl> if ( biome . getHeightVariation ( ) > = 0 . 4F & & biome . getHeightVariation ( ) < 1 . 5F ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , HILLS ) ; <nl> + BiomeDictionary . addTypes ( biome , HILLS ) ; <nl> } <nl> <nl> if ( biome . getHeightVariation ( ) > = 1 . 5F ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , MOUNTAIN ) ; <nl> + BiomeDictionary . addTypes ( biome , MOUNTAIN ) ; <nl> } <nl> <nl> if ( biome . getEnableSnow ( ) ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , SNOWY ) ; <nl> + BiomeDictionary . addTypes ( biome , SNOWY ) ; <nl> } <nl> <nl> if ( biome . topBlock ! = Blocks . SAND & & biome . getTemperature ( ) > = 1 . 0f & & biome . getRainfall ( ) < 0 . 2f ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , SAVANNA ) ; <nl> + BiomeDictionary . addTypes ( biome , SAVANNA ) ; <nl> } <nl> <nl> if ( biome . topBlock = = Blocks . SAND ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , SANDY ) ; <nl> + BiomeDictionary . addTypes ( biome , SANDY ) ; <nl> } <nl> else if ( biome . topBlock = = Blocks . MYCELIUM ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , MUSHROOM ) ; <nl> + BiomeDictionary . addTypes ( biome , MUSHROOM ) ; <nl> } <nl> if ( biome . fillerBlock = = Blocks . HARDENED _ CLAY ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , MESA ) ; <nl> + BiomeDictionary . addTypes ( biome , MESA ) ; <nl> } <nl> } <nl> <nl> / / Internal implementation <nl> private static BiomeInfo getBiomeInfo ( Biome biome ) <nl> { <nl> - return biomeInfoMap . get ( Biome . REGISTRY . getNameForObject ( biome ) ) ; <nl> + BiomeInfo info = biomeInfoMap . get ( biome . getRegistryName ( ) ) ; <nl> + if ( info = = null ) <nl> + { <nl> + info = new BiomeInfo ( ) ; <nl> + biomeInfoMap . put ( biome . getRegistryName ( ) , info ) ; <nl> + } <nl> + return info ; <nl> } <nl> <nl> - private static void checkRegistration ( Biome biome ) <nl> + / * * <nl> + * Ensure that at least one type has been added to the given biome . <nl> + * / <nl> + static void ensureHasTypes ( Biome biome ) <nl> { <nl> - if ( ! isBiomeRegistered ( biome ) ) <nl> + if ( ! hasAnyType ( biome ) ) <nl> { <nl> + FMLLog . warning ( " No types have been added to Biome % s , types will be assigned on a best - effort guess . " , biome . getRegistryName ( ) ) ; <nl> makeBestGuess ( biome ) ; <nl> } <nl> } <nl> <nl> - private static boolean containsType ( BiomeInfo info , Type type ) <nl> + private static boolean containsType ( Set < Type > types , Type type ) <nl> { <nl> - if ( type . hasSubTags ( ) ) <nl> + if ( type . hasSubTypes ( ) ) <nl> { <nl> - for ( Type remappedType : listSubTags ( type ) ) <nl> - { <nl> - if ( info . typeList . contains ( remappedType ) ) return true ; <nl> - } <nl> - <nl> - return false ; <nl> + return ! Collections . disjoint ( types , type . subTypes ) ; <nl> + } <nl> + else <nl> + { <nl> + return types . contains ( type ) ; <nl> } <nl> - <nl> - return info . typeList . contains ( type ) ; <nl> } <nl> <nl> - private static Type [ ] listSubTags ( Type . . . types ) <nl> + private static List < Type > listSubTypes ( Type . . . types ) <nl> { <nl> List < Type > subTags = new ArrayList < Type > ( ) ; <nl> <nl> for ( Type type : types ) <nl> { <nl> - if ( type . hasSubTags ( ) ) subTags . addAll ( type . subTags ) ; <nl> - else subTags . add ( type ) ; <nl> + if ( type . hasSubTypes ( ) ) <nl> + { <nl> + subTags . addAll ( type . subTypes ) ; <nl> + } <nl> + else <nl> + { <nl> + subTags . add ( type ) ; <nl> + } <nl> } <nl> <nl> - return subTags . toArray ( new Type [ subTags . size ( ) ] ) ; <nl> + return subTags ; <nl> } <nl> <nl> private static void registerVanillaBiomes ( ) <nl> { <nl> - registerBiomeType ( Biomes . OCEAN , OCEAN ) ; <nl> - registerBiomeType ( Biomes . PLAINS , PLAINS ) ; <nl> - registerBiomeType ( Biomes . DESERT , HOT , DRY , SANDY ) ; <nl> - registerBiomeType ( Biomes . EXTREME _ HILLS , MOUNTAIN , HILLS ) ; <nl> - registerBiomeType ( Biomes . FOREST , FOREST ) ; <nl> - registerBiomeType ( Biomes . TAIGA , COLD , CONIFEROUS , FOREST ) ; <nl> - registerBiomeType ( Biomes . TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , HILLS ) ; <nl> - registerBiomeType ( Biomes . SWAMPLAND , WET , SWAMP ) ; <nl> - registerBiomeType ( Biomes . RIVER , RIVER ) ; <nl> - registerBiomeType ( Biomes . FROZEN _ OCEAN , COLD , OCEAN , SNOWY ) ; <nl> - registerBiomeType ( Biomes . FROZEN _ RIVER , COLD , RIVER , SNOWY ) ; <nl> - registerBiomeType ( Biomes . ICE _ PLAINS , COLD , SNOWY , WASTELAND ) ; <nl> - registerBiomeType ( Biomes . ICE _ MOUNTAINS , COLD , SNOWY , MOUNTAIN ) ; <nl> - registerBiomeType ( Biomes . BEACH , BEACH ) ; <nl> - registerBiomeType ( Biomes . DESERT _ HILLS , HOT , DRY , SANDY , HILLS ) ; <nl> - registerBiomeType ( Biomes . JUNGLE , HOT , WET , DENSE , JUNGLE ) ; <nl> - registerBiomeType ( Biomes . JUNGLE _ HILLS , HOT , WET , DENSE , JUNGLE , HILLS ) ; <nl> - registerBiomeType ( Biomes . FOREST _ HILLS , FOREST , HILLS ) ; <nl> - registerBiomeType ( Biomes . SKY , COLD , DRY , END ) ; <nl> - registerBiomeType ( Biomes . HELL , HOT , DRY , NETHER ) ; <nl> - registerBiomeType ( Biomes . MUSHROOM _ ISLAND , MUSHROOM ) ; <nl> - registerBiomeType ( Biomes . EXTREME _ HILLS _ EDGE , MOUNTAIN ) ; <nl> - registerBiomeType ( Biomes . MUSHROOM _ ISLAND _ SHORE , MUSHROOM , BEACH ) ; <nl> - registerBiomeType ( Biomes . JUNGLE _ EDGE , HOT , WET , JUNGLE , FOREST ) ; <nl> - registerBiomeType ( Biomes . DEEP _ OCEAN , OCEAN ) ; <nl> - registerBiomeType ( Biomes . STONE _ BEACH , BEACH ) ; <nl> - registerBiomeType ( Biomes . COLD _ BEACH , COLD , BEACH , SNOWY ) ; <nl> - registerBiomeType ( Biomes . BIRCH _ FOREST , FOREST ) ; <nl> - registerBiomeType ( Biomes . BIRCH _ FOREST _ HILLS , FOREST , HILLS ) ; <nl> - registerBiomeType ( Biomes . ROOFED _ FOREST , SPOOKY , DENSE , FOREST ) ; <nl> - registerBiomeType ( Biomes . COLD _ TAIGA , COLD , CONIFEROUS , FOREST , SNOWY ) ; <nl> - registerBiomeType ( Biomes . COLD _ TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , SNOWY , HILLS ) ; <nl> - registerBiomeType ( Biomes . REDWOOD _ TAIGA , COLD , CONIFEROUS , FOREST ) ; <nl> - registerBiomeType ( Biomes . REDWOOD _ TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , HILLS ) ; <nl> - registerBiomeType ( Biomes . EXTREME _ HILLS _ WITH _ TREES , MOUNTAIN , FOREST , SPARSE ) ; <nl> - registerBiomeType ( Biomes . SAVANNA , HOT , SAVANNA , PLAINS , SPARSE ) ; <nl> - registerBiomeType ( Biomes . SAVANNA _ PLATEAU , HOT , SAVANNA , PLAINS , SPARSE ) ; <nl> - registerBiomeType ( Biomes . MESA , MESA , SANDY ) ; <nl> - registerBiomeType ( Biomes . MESA _ ROCK , MESA , SPARSE , SANDY ) ; <nl> - registerBiomeType ( Biomes . MESA _ CLEAR _ ROCK , MESA , SANDY ) ; <nl> + addTypes ( Biomes . OCEAN , OCEAN ) ; <nl> + addTypes ( Biomes . PLAINS , PLAINS ) ; <nl> + addTypes ( Biomes . DESERT , HOT , DRY , SANDY ) ; <nl> + addTypes ( Biomes . EXTREME _ HILLS , MOUNTAIN , HILLS ) ; <nl> + addTypes ( Biomes . FOREST , FOREST ) ; <nl> + addTypes ( Biomes . TAIGA , COLD , CONIFEROUS , FOREST ) ; <nl> + addTypes ( Biomes . TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , HILLS ) ; <nl> + addTypes ( Biomes . SWAMPLAND , WET , SWAMP ) ; <nl> + addTypes ( Biomes . RIVER , RIVER ) ; <nl> + addTypes ( Biomes . FROZEN _ OCEAN , COLD , OCEAN , SNOWY ) ; <nl> + addTypes ( Biomes . FROZEN _ RIVER , COLD , RIVER , SNOWY ) ; <nl> + addTypes ( Biomes . ICE _ PLAINS , COLD , SNOWY , WASTELAND ) ; <nl> + addTypes ( Biomes . ICE _ MOUNTAINS , COLD , SNOWY , MOUNTAIN ) ; <nl> + addTypes ( Biomes . BEACH , BEACH ) ; <nl> + addTypes ( Biomes . DESERT _ HILLS , HOT , DRY , SANDY , HILLS ) ; <nl> + addTypes ( Biomes . JUNGLE , HOT , WET , DENSE , JUNGLE ) ; <nl> + addTypes ( Biomes . JUNGLE _ HILLS , HOT , WET , DENSE , JUNGLE , HILLS ) ; <nl> + addTypes ( Biomes . FOREST _ HILLS , FOREST , HILLS ) ; <nl> + addTypes ( Biomes . SKY , COLD , DRY , END ) ; <nl> + addTypes ( Biomes . HELL , HOT , DRY , NETHER ) ; <nl> + addTypes ( Biomes . MUSHROOM _ ISLAND , MUSHROOM ) ; <nl> + addTypes ( Biomes . EXTREME _ HILLS _ EDGE , MOUNTAIN ) ; <nl> + addTypes ( Biomes . MUSHROOM _ ISLAND _ SHORE , MUSHROOM , BEACH ) ; <nl> + addTypes ( Biomes . JUNGLE _ EDGE , HOT , WET , JUNGLE , FOREST ) ; <nl> + addTypes ( Biomes . DEEP _ OCEAN , OCEAN ) ; <nl> + addTypes ( Biomes . STONE _ BEACH , BEACH ) ; <nl> + addTypes ( Biomes . COLD _ BEACH , COLD , BEACH , SNOWY ) ; <nl> + addTypes ( Biomes . BIRCH _ FOREST , FOREST ) ; <nl> + addTypes ( Biomes . BIRCH _ FOREST _ HILLS , FOREST , HILLS ) ; <nl> + addTypes ( Biomes . ROOFED _ FOREST , SPOOKY , DENSE , FOREST ) ; <nl> + addTypes ( Biomes . COLD _ TAIGA , COLD , CONIFEROUS , FOREST , SNOWY ) ; <nl> + addTypes ( Biomes . COLD _ TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , SNOWY , HILLS ) ; <nl> + addTypes ( Biomes . REDWOOD _ TAIGA , COLD , CONIFEROUS , FOREST ) ; <nl> + addTypes ( Biomes . REDWOOD _ TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , HILLS ) ; <nl> + addTypes ( Biomes . EXTREME _ HILLS _ WITH _ TREES , MOUNTAIN , FOREST , SPARSE ) ; <nl> + addTypes ( Biomes . SAVANNA , HOT , SAVANNA , PLAINS , SPARSE ) ; <nl> + addTypes ( Biomes . SAVANNA _ PLATEAU , HOT , SAVANNA , PLAINS , SPARSE ) ; <nl> + addTypes ( Biomes . MESA , MESA , SANDY ) ; <nl> + addTypes ( Biomes . MESA _ ROCK , MESA , SPARSE , SANDY ) ; <nl> + addTypes ( Biomes . MESA _ CLEAR _ ROCK , MESA , SANDY ) ; <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / common / ForgeModContainer . java b / src / main / java / net / minecraftforge / common / ForgeModContainer . java <nl> index ff70583 . . 149a5ad 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / ForgeModContainer . java <nl> + + + b / src / main / java / net / minecraftforge / common / ForgeModContainer . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ <nl> <nl> package net . minecraftforge . common ; <nl> <nl> + import net . minecraft . world . biome . Biome ; <nl> import static net . minecraftforge . common . config . Configuration . CATEGORY _ CLIENT ; <nl> import static net . minecraftforge . common . config . Configuration . CATEGORY _ GENERAL ; <nl> <nl> @ @ - 38 , 11 + 39 , 9 @ @ import java . util . Date ; <nl> import java . util . Iterator ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> - import java . util . Set ; <nl> <nl> import org . apache . logging . log4j . Level ; <nl> <nl> - import net . minecraft . crash . CrashReport ; <nl> import net . minecraft . crash . ICrashReportDetail ; <nl> import net . minecraft . nbt . NBTBase ; <nl> import net . minecraft . nbt . NBTTagCompound ; <nl> @ @ - 57 , 8 + 56 , 10 @ @ import net . minecraftforge . common . config . Property ; <nl> import net . minecraftforge . common . model . animation . CapabilityAnimation ; <nl> import net . minecraftforge . common . network . ForgeNetworkHandler ; <nl> import net . minecraftforge . energy . CapabilityEnergy ; <nl> + import net . minecraftforge . event . terraingen . DeferredBiomeDecorator ; <nl> import net . minecraftforge . fluids . FluidRegistry ; <nl> import net . minecraftforge . fluids . capability . CapabilityFluidHandler ; <nl> + import net . minecraftforge . fml . common . registry . ForgeRegistries ; <nl> import net . minecraftforge . items . CapabilityItemHandler ; <nl> import net . minecraftforge . fluids . UniversalBucket ; <nl> import net . minecraftforge . fml . common . registry . GameRegistry ; <nl> @ @ - 82 , 7 + 83 , 6 @ @ import net . minecraftforge . fml . common . LoadController ; <nl> import net . minecraftforge . fml . common . Loader ; <nl> import net . minecraftforge . fml . common . ModMetadata ; <nl> import net . minecraftforge . fml . common . WorldAccessContainer ; <nl> - import net . minecraftforge . fml . common . discovery . ASMDataTable ; <nl> import net . minecraftforge . fml . common . discovery . ASMDataTable . ASMData ; <nl> import net . minecraftforge . fml . common . event . FMLConstructionEvent ; <nl> import net . minecraftforge . fml . common . event . FMLLoadCompleteEvent ; <nl> @ @ - 428 , 10 + 428 , 24 @ @ public class ForgeModContainer extends DummyModContainer implements WorldAccessC <nl> @ Subscribe <nl> public void postInit ( FMLPostInitializationEvent evt ) <nl> { <nl> - BiomeDictionary . registerAllBiomesAndGenerateEvents ( ) ; <nl> + registerAllBiomesAndGenerateEvents ( ) ; <nl> ForgeChunkManager . loadConfiguration ( ) ; <nl> } <nl> <nl> + private static void registerAllBiomesAndGenerateEvents ( ) <nl> + { <nl> + for ( Biome biome : ForgeRegistries . BIOMES . getValues ( ) ) <nl> + { <nl> + if ( biome . theBiomeDecorator instanceof DeferredBiomeDecorator ) <nl> + { <nl> + DeferredBiomeDecorator decorator = ( DeferredBiomeDecorator ) biome . theBiomeDecorator ; <nl> + decorator . fireCreateEventAndReplace ( biome ) ; <nl> + } <nl> + <nl> + BiomeDictionary . ensureHasTypes ( biome ) ; <nl> + } <nl> + } <nl> + <nl> @ Subscribe <nl> public void onAvailable ( FMLLoadCompleteEvent evt ) <nl> {
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / BiomeDictionary . java b / src / main / java / net / minecraftforge / common / BiomeDictionary . java <nl> index cece2c8 . . a62ed47 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / BiomeDictionary . java <nl> + + + b / src / main / java / net / minecraftforge / common / BiomeDictionary . java <nl> @ @ - 3 , 6 + 3 , 7 @ @ package net . minecraftforge . common ; <nl> import java . util . * ; <nl> <nl> import cpw . mods . fml . common . FMLLog ; <nl> + import net . minecraft . init . Blocks ; <nl> import net . minecraft . world . biome . * ; <nl> import net . minecraftforge . event . terraingen . DeferredBiomeDecorator ; <nl> import static net . minecraft . world . biome . BiomeGenBase . * ; <nl> @ @ - 12 , 21 + 13 , 66 @ @ public class BiomeDictionary <nl> { <nl> public enum Type <nl> { <nl> + / * Temperature - based tags . Specifying neither implies a biome is temperate * / <nl> + HOT , <nl> + COLD , <nl> + / * Tags specifying the amount of vegetation a biome has . Specifying neither implies a biome to have moderate amounts * / <nl> + SPARSE , <nl> + DENSE , <nl> + / * Tags specifying how moist a biome is . Specifying neither implies the biome as having moderate humidity * / <nl> + WET , <nl> + DRY , <nl> + / * Tree - based tags , SAVANNA refers to dry , desert - like trees ( Such as Acacia ) , CONIFEROUS refers to snowy trees ( Such as Spruce ) and JUNGLE refers to jungle trees . <nl> + * Specifying no tag implies a biome has temperate trees ( Such as Oak ) * / <nl> + SAVANNA , <nl> + CONIFEROUS , <nl> + JUNGLE , <nl> + <nl> + / * Tags specifying the nature of a biome * / <nl> + SPOOKY , <nl> + DEAD , <nl> + LUSH , <nl> + NETHER , <nl> + END , <nl> + MUSHROOM , <nl> + MAGICAL , <nl> + <nl> + OCEAN , <nl> + RIVER , <nl> + / * * A general tag for all water - based biomes . Shown as present if OCEAN or RIVER are . * * / <nl> + WATER ( OCEAN , RIVER ) , <nl> + <nl> + / * Generic types which a biome can be * / <nl> + MESA , <nl> FOREST , <nl> PLAINS , <nl> MOUNTAIN , <nl> HILLS , <nl> SWAMP , <nl> - WATER , <nl> - DESERT , <nl> - FROZEN , <nl> - JUNGLE , <nl> + SANDY , <nl> + SNOWY , <nl> WASTELAND , <nl> BEACH , <nl> - NETHER , <nl> - END , <nl> - MUSHROOM , <nl> - MAGICAL ; <nl> + <nl> + / * Deprecated tags , kept for compatibility * / <nl> + @ Deprecated <nl> + / * * Replaced by SANDY * * / <nl> + DESERT ( SANDY ) , <nl> + @ Deprecated <nl> + / * * Replaced by SNOWY * * / <nl> + FROZEN ( SNOWY ) ; <nl> + <nl> + private List < Type > subTags ; <nl> + <nl> + private Type ( Type . . . subTags ) <nl> + { <nl> + this . subTags = Arrays . asList ( subTags ) ; <nl> + } <nl> + <nl> + private boolean hasSubTags ( ) <nl> + { <nl> + return subTags ! = null & & ! subTags . isEmpty ( ) ; <nl> + } <nl> } <nl> <nl> private static final int BIOME _ LIST _ SIZE = BiomeGenBase . getBiomeGenArray ( ) . length ; <nl> @ @ - 62 , 6 + 108 , 8 @ @ public class BiomeDictionary <nl> * / <nl> public static boolean registerBiomeType ( BiomeGenBase biome , Type . . . types ) <nl> { <nl> + types = listSubTags ( types ) ; <nl> + <nl> if ( BiomeGenBase . getBiomeGenArray ( ) [ biome . biomeID ] ! = null ) <nl> { <nl> for ( Type type : types ) <nl> @ @ - 232 , 15 + 280 , 20 @ @ public class BiomeDictionary <nl> * / <nl> public static void makeBestGuess ( BiomeGenBase biome ) <nl> { <nl> - if ( biome . theBiomeDecorator . treesPerChunk > = 3 ) <nl> + if ( biome . theBiomeDecorator . treesPerChunk > = 3 ) <nl> { <nl> - if ( biome . isHighHumidity ( ) & & biome . temperature > = 1 . 0F ) <nl> + if ( biome . isHighHumidity ( ) & & biome . temperature > = 0 . 9F ) <nl> { <nl> BiomeDictionary . registerBiomeType ( biome , JUNGLE ) ; <nl> } <nl> - else if ( ! biome . isHighHumidity ( ) ) <nl> + else if ( ! biome . isHighHumidity ( ) ) <nl> { <nl> BiomeDictionary . registerBiomeType ( biome , FOREST ) ; <nl> + <nl> + if ( biome . temperature < = 0 . 2f ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , CONIFEROUS ) ; <nl> + } <nl> } <nl> } <nl> else if ( biome . heightVariation < = 0 . 3F & & biome . heightVariation > = 0 . 0F ) <nl> @ @ - 251 , 29 + 304 , 83 @ @ public class BiomeDictionary <nl> } <nl> } <nl> <nl> - if ( biome . isHighHumidity ( ) & & biome . rootHeight < 0 . 0F & & ( biome . heightVariation < = 0 . 3F & & biome . heightVariation > = 0 . 0F ) ) <nl> + if ( biome . rainfall > 0 . 85f ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , WET ) ; <nl> + } <nl> + <nl> + if ( biome . rainfall < 0 . 15f ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , DRY ) ; <nl> + } <nl> + <nl> + if ( biome . temperature > 0 . 85f ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , HOT ) ; <nl> + } <nl> + <nl> + if ( biome . temperature < 0 . 15f ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , COLD ) ; <nl> + } <nl> + <nl> + if ( biome . theBiomeDecorator . treesPerChunk > 0 & & biome . theBiomeDecorator . treesPerChunk < 3 ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , SPARSE ) ; <nl> + } <nl> + else if ( biome . theBiomeDecorator . treesPerChunk > = 10 ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , DENSE ) ; <nl> + } <nl> + <nl> + if ( biome . isHighHumidity ( ) & & biome . rootHeight < 0 . 0F & & ( biome . heightVariation < = 0 . 3F & & biome . heightVariation > = 0 . 0F ) ) <nl> { <nl> BiomeDictionary . registerBiomeType ( biome , SWAMP ) ; <nl> } <nl> <nl> - if ( biome . rootHeight < = - 0 . 5F ) <nl> + if ( biome . rootHeight < = - 0 . 5F ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , WATER ) ; <nl> + if ( biome . heightVariation = = 0 . 0F ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , RIVER ) ; <nl> + } <nl> + else <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , OCEAN ) ; <nl> + } <nl> } <nl> <nl> - if ( biome . heightVariation > = 1 . 5F ) <nl> + if ( biome . heightVariation > = 0 . 4F & & biome . heightVariation < 1 . 5F ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , HILLS ) ; <nl> + } <nl> + <nl> + if ( biome . heightVariation > = 1 . 5F ) <nl> { <nl> BiomeDictionary . registerBiomeType ( biome , MOUNTAIN ) ; <nl> } <nl> - <nl> - if ( biome . getEnableSnow ( ) | | biome . temperature < 0 . 2F ) <nl> + <nl> + if ( biome . getEnableSnow ( ) ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , FROZEN ) ; <nl> + BiomeDictionary . registerBiomeType ( biome , SNOWY ) ; <nl> } <nl> - <nl> - if ( ! biome . isHighHumidity ( ) & & biome . temperature > = 1 . 0F ) <nl> + <nl> + if ( biome . topBlock ! = Blocks . sand & & biome . temperature > = 1 . 0f & & biome . rainfall < 0 . 2f ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , SAVANNA ) ; <nl> + } <nl> + <nl> + if ( biome . topBlock = = Blocks . sand ) <nl> { <nl> - BiomeDictionary . registerBiomeType ( biome , DESERT ) ; <nl> + BiomeDictionary . registerBiomeType ( biome , SANDY ) ; <nl> + } <nl> + else if ( biome . topBlock = = Blocks . hardened _ clay ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , MESA ) ; <nl> + } <nl> + else if ( biome . topBlock = = Blocks . mycelium ) <nl> + { <nl> + BiomeDictionary . registerBiomeType ( biome , MUSHROOM ) ; <nl> } <nl> } <nl> <nl> @ @ - 288 , 50 + 395 , 73 @ @ public class BiomeDictionary <nl> <nl> private static boolean containsType ( BiomeInfo info , Type type ) <nl> { <nl> + if ( type . hasSubTags ( ) ) <nl> + { <nl> + for ( Type remappedType : listSubTags ( type ) ) <nl> + { <nl> + if ( info . typeList . contains ( remappedType ) ) return true ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> return info . typeList . contains ( type ) ; <nl> } <nl> + <nl> + private static Type [ ] listSubTags ( Type . . . types ) <nl> + { <nl> + List < Type > subTags = new ArrayList < Type > ( ) ; <nl> + <nl> + for ( Type type : types ) <nl> + { <nl> + if ( type . hasSubTags ( ) ) subTags . addAll ( type . subTags ) ; <nl> + else subTags . add ( type ) ; <nl> + } <nl> + <nl> + return subTags . toArray ( new Type [ subTags . size ( ) ] ) ; <nl> + } <nl> <nl> private static void registerVanillaBiomes ( ) <nl> { <nl> - registerBiomeType ( ocean , WATER ) ; <nl> - registerBiomeType ( plains , PLAINS ) ; <nl> - registerBiomeType ( desert , DESERT ) ; <nl> - registerBiomeType ( extremeHills , MOUNTAIN ) ; <nl> - registerBiomeType ( forest , FOREST ) ; <nl> - registerBiomeType ( taiga , FOREST , FROZEN ) ; <nl> - registerBiomeType ( taigaHills , FOREST , FROZEN ) ; <nl> - registerBiomeType ( swampland , SWAMP ) ; <nl> - registerBiomeType ( river , WATER ) ; <nl> - registerBiomeType ( frozenOcean , WATER , FROZEN ) ; <nl> - registerBiomeType ( frozenRiver , WATER , FROZEN ) ; <nl> - registerBiomeType ( icePlains , FROZEN ) ; <nl> - registerBiomeType ( iceMountains , FROZEN ) ; <nl> - registerBiomeType ( beach , BEACH ) ; <nl> - registerBiomeType ( desertHills , DESERT ) ; <nl> - registerBiomeType ( jungle , JUNGLE ) ; <nl> - registerBiomeType ( jungleHills , JUNGLE ) ; <nl> - registerBiomeType ( forestHills , FOREST ) ; <nl> - registerBiomeType ( sky , END ) ; <nl> - registerBiomeType ( hell , NETHER ) ; <nl> - registerBiomeType ( mushroomIsland , MUSHROOM ) ; <nl> - registerBiomeType ( extremeHillsEdge , MOUNTAIN ) ; <nl> - registerBiomeType ( mushroomIslandShore , MUSHROOM , BEACH ) ; <nl> - registerBiomeType ( jungleEdge , JUNGLE ) ; <nl> - registerBiomeType ( deepOcean , WATER ) ; <nl> - registerBiomeType ( stoneBeach , BEACH ) ; <nl> - registerBiomeType ( coldBeach , BEACH , FROZEN ) ; <nl> - registerBiomeType ( birchForest , FOREST ) ; <nl> - registerBiomeType ( birchForestHills , FOREST ) ; <nl> - registerBiomeType ( roofedForest , FOREST ) ; <nl> - registerBiomeType ( coldTaiga , FOREST , FROZEN ) ; <nl> - registerBiomeType ( coldTaigaHills , FOREST , FROZEN ) ; <nl> - registerBiomeType ( megaTaiga , FOREST ) ; <nl> - registerBiomeType ( megaTaigaHills , FOREST ) ; <nl> - registerBiomeType ( extremeHillsPlus , FOREST ) ; <nl> - registerBiomeType ( savanna , PLAINS , DESERT ) ; <nl> - registerBiomeType ( savannaPlateau , PLAINS , DESERT ) ; <nl> - registerBiomeType ( mesa , DESERT ) ; <nl> - registerBiomeType ( mesaPlateau _ F , DESERT ) ; <nl> - registerBiomeType ( mesaPlateau , DESERT ) ; <nl> + registerBiomeType ( ocean , OCEAN ) ; <nl> + registerBiomeType ( plains , PLAINS ) ; <nl> + registerBiomeType ( desert , HOT , DRY , SANDY ) ; <nl> + registerBiomeType ( extremeHills , MOUNTAIN , HILLS ) ; <nl> + registerBiomeType ( forest , FOREST ) ; <nl> + registerBiomeType ( taiga , COLD , CONIFEROUS , FOREST ) ; <nl> + registerBiomeType ( taigaHills , COLD , CONIFEROUS , FOREST , HILLS ) ; <nl> + registerBiomeType ( swampland , WET , SWAMP ) ; <nl> + registerBiomeType ( river , RIVER ) ; <nl> + registerBiomeType ( frozenOcean , COLD , OCEAN , SNOWY ) ; <nl> + registerBiomeType ( frozenRiver , COLD , RIVER , SNOWY ) ; <nl> + registerBiomeType ( icePlains , COLD , SNOWY , WASTELAND ) ; <nl> + registerBiomeType ( iceMountains , COLD , SNOWY , MOUNTAIN ) ; <nl> + registerBiomeType ( beach , BEACH ) ; <nl> + registerBiomeType ( desertHills , HOT , DRY , SANDY , HILLS ) ; <nl> + registerBiomeType ( jungle , HOT , WET , DENSE , JUNGLE ) ; <nl> + registerBiomeType ( jungleHills , HOT , WET , DENSE , JUNGLE , HILLS ) ; <nl> + registerBiomeType ( forestHills , FOREST , HILLS ) ; <nl> + registerBiomeType ( sky , COLD , DRY , END ) ; <nl> + registerBiomeType ( hell , HOT , DRY , NETHER ) ; <nl> + registerBiomeType ( mushroomIsland , MUSHROOM ) ; <nl> + registerBiomeType ( extremeHillsEdge , MOUNTAIN ) ; <nl> + registerBiomeType ( mushroomIslandShore , MUSHROOM , BEACH ) ; <nl> + registerBiomeType ( jungleEdge , HOT , WET , JUNGLE , FOREST ) ; <nl> + registerBiomeType ( deepOcean , OCEAN ) ; <nl> + registerBiomeType ( stoneBeach , BEACH ) ; <nl> + registerBiomeType ( coldBeach , COLD , BEACH , SNOWY ) ; <nl> + registerBiomeType ( birchForest , FOREST ) ; <nl> + registerBiomeType ( birchForestHills , FOREST , HILLS ) ; <nl> + registerBiomeType ( roofedForest , SPOOKY , DENSE , FOREST ) ; <nl> + registerBiomeType ( coldTaiga , COLD , CONIFEROUS , FOREST , SNOWY ) ; <nl> + registerBiomeType ( coldTaigaHills , COLD , CONIFEROUS , FOREST , SNOWY , HILLS ) ; <nl> + registerBiomeType ( megaTaiga , COLD , CONIFEROUS , FOREST ) ; <nl> + registerBiomeType ( megaTaigaHills , COLD , CONIFEROUS , FOREST , HILLS ) ; <nl> + registerBiomeType ( extremeHillsPlus , MOUNTAIN , FOREST , SPARSE ) ; <nl> + registerBiomeType ( savanna , HOT , SAVANNA , PLAINS , SPARSE ) ; <nl> + registerBiomeType ( savannaPlateau , HOT , SAVANNA , PLAINS , SPARSE ) ; <nl> + registerBiomeType ( mesa , MESA , SANDY ) ; <nl> + registerBiomeType ( mesaPlateau _ F , MESA , SPARSE , SANDY ) ; <nl> + registerBiomeType ( mesaPlateau , MESA , SANDY ) ; <nl> } <nl> }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / BiomeDictionary . java b / src / main / java / net / minecraftforge / common / BiomeDictionary . java 
 index 84ae7a9 . . d23b244 100644 
 - - - a / src / main / java / net / minecraftforge / common / BiomeDictionary . java 
 + + + b / src / main / java / net / minecraftforge / common / BiomeDictionary . java 
 @ @ - 21 , 133 + 21 , 140 @ @ package net . minecraftforge . common ; 
 
 import java . util . * ; 
 
 - import net . minecraftforge . fml . common . FMLLog ; 
 + import javax . annotation . Nonnull ; 
 
 import net . minecraft . init . Biomes ; 
 import net . minecraft . init . Blocks ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraft . world . biome . * ; 
 - import net . minecraftforge . common . util . EnumHelper ; 
 - import net . minecraftforge . event . terraingen . DeferredBiomeDecorator ; 
 import static net . minecraftforge . common . BiomeDictionary . Type . * ; 
 + import net . minecraftforge . fml . common . FMLLog ; 
 + import net . minecraftforge . fml . common . registry . ForgeRegistries ; 
 + 
 + import com . google . common . base . Preconditions ; 
 + import com . google . common . collect . ImmutableList ; 
 
 public class BiomeDictionary 
 { 
 - public enum Type 
 + public static final class Type 
 { 
 + 
 + private static final Map < String , Type > byName = new HashMap < String , Type > ( ) ; 
 + 
 / * Temperature - based tags . Specifying neither implies a biome is temperate * / 
 - HOT , 
 - COLD , 
 + public static final Type HOT = new Type ( " HOT " ) ; 
 + public static final Type COLD = new Type ( " COLD " ) ; 
 + 
 / * Tags specifying the amount of vegetation a biome has . Specifying neither implies a biome to have moderate amounts * / 
 - SPARSE , 
 - DENSE , 
 + public static final Type SPARSE = new Type ( " SPARSE " ) ; 
 + public static final Type DENSE = new Type ( " DENSE " ) ; 
 + 
 / * Tags specifying how moist a biome is . Specifying neither implies the biome as having moderate humidity * / 
 - WET , 
 - DRY , 
 + public static final Type WET = new Type ( " WET " ) ; 
 + public static final Type DRY = new Type ( " DRY " ) ; 
 + 
 / * Tree - based tags , SAVANNA refers to dry , desert - like trees ( Such as Acacia ) , CONIFEROUS refers to snowy trees ( Such as Spruce ) and JUNGLE refers to jungle trees . 
 * Specifying no tag implies a biome has temperate trees ( Such as Oak ) * / 
 - SAVANNA , 
 - CONIFEROUS , 
 - JUNGLE , 
 + public static final Type SAVANNA = new Type ( " SAVANNA " ) ; 
 + public static final Type CONIFEROUS = new Type ( " CONIFEROUS " ) ; 
 + public static final Type JUNGLE = new Type ( " JUNGLE " ) ; 
 
 / * Tags specifying the nature of a biome * / 
 - SPOOKY , 
 - DEAD , 
 - LUSH , 
 - NETHER , 
 - END , 
 - MUSHROOM , 
 - MAGICAL , 
 - 
 - OCEAN , 
 - RIVER , 
 - / * * A general tag for all water - based biomes . Shown as present if OCEAN or RIVER are . * * / 
 - WATER ( OCEAN , RIVER ) , 
 + public static final Type SPOOKY = new Type ( " SPOOKY " ) ; 
 + public static final Type DEAD = new Type ( " DEAD " ) ; 
 + public static final Type LUSH = new Type ( " LUSH " ) ; 
 + public static final Type NETHER = new Type ( " NETHER " ) ; 
 + public static final Type END = new Type ( " END " ) ; 
 + public static final Type MUSHROOM = new Type ( " MUSHROOM " ) ; 
 + public static final Type MAGICAL = new Type ( " MAGICAL " ) ; 
 + 
 + public static final Type OCEAN = new Type ( " OCEAN " ) ; 
 + public static final Type RIVER = new Type ( " RIVER " ) ; 
 + / * * 
 + * A general tag for all water - based biomes . Shown as present if OCEAN or RIVER are . 
 + * * / 
 + public static final Type WATER = new Type ( " WATER " , OCEAN , RIVER ) ; 
 
 / * Generic types which a biome can be * / 
 - MESA , 
 - FOREST , 
 - PLAINS , 
 - MOUNTAIN , 
 - HILLS , 
 - SWAMP , 
 - SANDY , 
 - SNOWY , 
 - WASTELAND , 
 - BEACH ; 
 - 
 - private List < Type > subTags ; 
 - 
 - private Type ( Type . . . subTags ) 
 + public static final Type MESA = new Type ( " MESA " ) ; 
 + public static final Type FOREST = new Type ( " FOREST " ) ; 
 + public static final Type PLAINS = new Type ( " PLAINS " ) ; 
 + public static final Type MOUNTAIN = new Type ( " MOUNTAIN " ) ; 
 + public static final Type HILLS = new Type ( " HILLS " ) ; 
 + public static final Type SWAMP = new Type ( " SWAMP " ) ; 
 + public static final Type SANDY = new Type ( " SANDY " ) ; 
 + public static final Type SNOWY = new Type ( " SNOWY " ) ; 
 + public static final Type WASTELAND = new Type ( " WASTELAND " ) ; 
 + public static final Type BEACH = new Type ( " BEACH " ) ; 
 + 
 + private final String name ; 
 + private final List < Type > subTypes ; 
 + private final Set < Biome > biomes = new HashSet < Biome > ( ) ; 
 + private final Set < Biome > biomesUn = Collections . unmodifiableSet ( biomes ) ; 
 + 
 + private Type ( String name , Type . . . subTypes ) 
 + { 
 + this . name = name ; 
 + this . subTypes = ImmutableList . copyOf ( subTypes ) ; 
 + 
 + byName . put ( name , this ) ; 
 + } 
 + 
 + private boolean hasSubTypes ( ) 
 + { 
 + return ! subTypes . isEmpty ( ) ; 
 + } 
 + 
 + / * * 
 + * Gets the name for this type . 
 + * / 
 + public String getName ( ) 
 { 
 - this . subTags = Arrays . asList ( subTags ) ; 
 + return name ; 
 } 
 
 - private boolean hasSubTags ( ) 
 + public String toString ( ) 
 { 
 - return subTags ! = null & & ! subTags . isEmpty ( ) ; 
 + return name ; 
 } 
 
 / * * 
 - * Retrieves a Type value by name , 
 + * Retrieves a Type instance by name , 
 * if one does not exist already it creates one . 
 * This can be used as intermediate measure for modders to 
 - * add their own category of Biome . 
 - * 
 - * There are NO naming conventions besides : 
 - * MUST be all upper case ( enforced by name . toUpper ( ) ) 
 - * NO Special characters . { Unenforced , just don ' t be a pain , if it becomes a issue I WILL 
 - * make this RTE with no worry about backwards compatibility } 
 - * 
 + * add their own Biome types . 
 + * < p > 
 + * There are < i > no < / i > naming conventions besides : 
 + * < ul > < li > < b > Must < / b > be all upper case ( enforced by name . toUpper ( ) ) < / li > 
 + * < li > < b > No < / b > Special characters . { Unenforced , just don ' t be a pain , if it becomes a issue I WILL 
 + * make this RTE with no worry about backwards compatibility } < / li > < / ul > 
 + * < p > 
 * Note : For performance sake , the return value of this function SHOULD be cached . 
 * Two calls with the same name SHOULD return the same value . 
 * 
 - * 
 * @ param name The name of this Type 
 * @ return An instance of Type for this name . 
 * / 
 public static Type getType ( String name , Type . . . subTypes ) 
 { 
 name = name . toUpperCase ( ) ; 
 - for ( Type t : values ( ) ) 
 - { 
 - if ( t . name ( ) . equals ( name ) ) 
 - return t ; 
 - } 
 - Type ret = EnumHelper . addEnum ( Type . class , name , new Class [ ] { Type [ ] . class } , new Object [ ] { subTypes } ) ; 
 - if ( ret . ordinal ( ) > = typeInfoList . length ) 
 - { 
 - typeInfoList = Arrays . copyOf ( typeInfoList , ret . ordinal ( ) + 1 ) ; 
 - } 
 - for ( BiomeInfo bInfo : biomeInfoMap . values ( ) ) 
 + Type t = byName . get ( name ) ; 
 + if ( t = = null ) 
 { 
 - if ( bInfo ! = null ) 
 - { 
 - EnumSet < Type > oldSet = bInfo . typeList ; 
 - bInfo . typeList = EnumSet . noneOf ( Type . class ) ; 
 - bInfo . typeList . addAll ( oldSet ) ; 
 - } 
 + t = new Type ( name , subTypes ) ; 
 } 
 - return ret ; 
 + return t ; 
 } 
 } 
 
 - private static HashMap < ResourceLocation , BiomeInfo > biomeInfoMap = new HashMap < ResourceLocation , BiomeInfo > ( ) ; 
 - @ SuppressWarnings ( " unchecked " ) 
 - private static ArrayList < Biome > [ ] typeInfoList = new ArrayList [ Type . values ( ) . length ] ; 
 + private static final Map < ResourceLocation , BiomeInfo > biomeInfoMap = new HashMap < ResourceLocation , BiomeInfo > ( ) ; 
 
 private static class BiomeInfo 
 { 
 - public EnumSet < Type > typeList ; 
 
 - public BiomeInfo ( Type [ ] types ) 
 - { 
 - typeList = EnumSet . noneOf ( Type . class ) ; 
 - for ( Type t : types ) 
 - { 
 - typeList . add ( t ) ; 
 - } 
 - } 
 + private final Set < Type > types = new HashSet < Type > ( ) ; 
 + private final Set < Type > typesUn = Collections . unmodifiableSet ( this . types ) ; 
 + 
 } 
 
 static 
 @ @ - 156 , 90 + 163 , 54 @ @ public class BiomeDictionary 
 } 
 
 / * * 
 - * Registers a biome with a specific biome type 
 + * Adds the given types to the biome . 
 * 
 - * @ param biome the biome to be registered 
 - * @ param types the types to register the biome as 
 - * @ return returns true if the biome was registered successfully 
 * / 
 - public static boolean registerBiomeType ( Biome biome , Type . . . types ) 
 + public static void addTypes ( Biome biome , Type . . . types ) 
 { 
 - types = listSubTags ( types ) ; 
 - 
 - if ( Biome . REGISTRY . getNameForObject ( biome ) ! = null ) 
 - { 
 - for ( Type type : types ) 
 - { 
 - if ( typeInfoList [ type . ordinal ( ) ] = = null ) 
 - { 
 - typeInfoList [ type . ordinal ( ) ] = new ArrayList < Biome > ( ) ; 
 - } 
 + Preconditions . checkArgument ( ForgeRegistries . BIOMES . containsValue ( biome ) , " Cannot add types to unregistered biome % s " , biome ) ; 
 
 - typeInfoList [ type . ordinal ( ) ] . add ( biome ) ; 
 - } 
 - 
 - if ( ! isBiomeRegistered ( biome ) ) 
 - { 
 - ResourceLocation location = Biome . REGISTRY . getNameForObject ( biome ) ; 
 - biomeInfoMap . put ( location , new BiomeInfo ( types ) ) ; 
 - } 
 - else 
 - { 
 - for ( Type type : types ) 
 - { 
 - getBiomeInfo ( biome ) . typeList . add ( type ) ; 
 - } 
 - } 
 + List < Type > subTypes = listSubTypes ( types ) ; 
 
 - return true ; 
 + for ( Type type : subTypes ) 
 + { 
 + type . biomes . add ( biome ) ; 
 } 
 
 - return false ; 
 + getBiomeInfo ( biome ) . types . addAll ( subTypes ) ; 
 } 
 
 / * * 
 - * Returns a list of biomes registered with a specific type 
 + * Gets the set of biomes that have the given type . 
 * 
 - * @ param type the Type to look for 
 - * @ return a list of biomes of the specified type , null if there are none 
 * / 
 - public static Biome [ ] getBiomesForType ( Type type ) 
 + @ Nonnull 
 + public static Set < Biome > getBiomes ( Type type ) 
 { 
 - if ( typeInfoList [ type . ordinal ( ) ] ! = null ) 
 - { 
 - return typeInfoList [ type . ordinal ( ) ] . toArray ( new Biome [ 0 ] ) ; 
 - } 
 - 
 - return new Biome [ 0 ] ; 
 + return type . biomesUn ; 
 } 
 
 / * * 
 - * Gets a list of Types that a specific biome is registered with 
 + * Gets the set of types that have been added to the given biome . 
 * 
 - * @ param biome the biome to check 
 - * @ return the list of types , null if there are none 
 * / 
 - public static Type [ ] getTypesForBiome ( Biome biome ) 
 + @ Nonnull 
 + public static Set < Type > getTypes ( Biome biome ) 
 { 
 - checkRegistration ( biome ) ; 
 - return getBiomeInfo ( biome ) . typeList . toArray ( new Type [ 0 ] ) ; 
 + ensureHasTypes ( biome ) ; 
 + return getBiomeInfo ( biome ) . typesUn ; 
 } 
 
 / * * 
 - * Checks to see if two biomes are registered as having the same type 
 + * Checks if the two given biomes have types in common . 
 * 
 - * @ param biomeA 
 - * @ param biomeB 
 * @ return returns true if a common type is found , false otherwise 
 * / 
 - public static boolean areBiomesEquivalent ( Biome biomeA , Biome biomeB ) 
 + public static boolean areSimilar ( Biome biomeA , Biome biomeB ) 
 { 
 - checkRegistration ( biomeA ) ; 
 - checkRegistration ( biomeB ) ; 
 - 
 - for ( Type type : getTypesForBiome ( biomeA ) ) 
 + for ( Type type : getTypes ( biomeA ) ) 
 { 
 - if ( containsType ( getBiomeInfo ( biomeB ) , type ) ) 
 + if ( containsType ( getTypes ( biomeB ) , type ) ) 
 { 
 return true ; 
 } 
 @ @ - 249 , 61 + 220 , 28 @ @ public class BiomeDictionary 
 } 
 
 / * * 
 - * Checks to see if the given biome is registered as being a specific type 
 + * Checks if the given type has been added to the given biome . 
 * 
 - * @ param biome the biome to be considered 
 - * @ param type the type to check for 
 - * @ return returns true if the biome is registered as being of type type , false otherwise 
 - * / 
 - public static boolean isBiomeOfType ( Biome biome , Type type ) 
 - { 
 - checkRegistration ( biome ) ; 
 - return containsType ( getBiomeInfo ( biome ) , type ) ; 
 - } 
 - 
 - / * * 
 - * Checks to see if the given biome has been registered as being of any type 
 - * @ param biome the biome to consider 
 - * @ return returns true if the biome has been registered , false otherwise 
 * / 
 - public static boolean isBiomeRegistered ( Biome biome ) 
 + public static boolean hasType ( Biome biome , Type type ) 
 { 
 - return biomeInfoMap . containsKey ( Biome . REGISTRY . getNameForObject ( biome ) ) ; 
 + return getTypes ( biome ) . contains ( type ) ; 
 } 
 
 - public static void registerAllBiomes ( ) 
 - { 
 - FMLLog . warning ( " Redundant call to BiomeDictionary . registerAllBiomes ignored " ) ; 
 - } 
 / * * 
 - * Loops through the biome list and automatically adds tags to any biome that does not have any 
 - * This is called by Forge at postinit time . It will additionally dispatch any deferred decorator 
 - * creation events . 
 + * Checks if any type has been added to the given biome . 
 * 
 - * DO NOT call this during world generation 
 * / 
 - public static void registerAllBiomesAndGenerateEvents ( ) 
 + public static boolean hasAnyType ( Biome biome ) 
 { 
 - for ( ResourceLocation biomeResource : Biome . REGISTRY . getKeys ( ) ) 
 - { 
 - Biome biome = Biome . REGISTRY . getObject ( biomeResource ) ; 
 - 
 - if ( biome . theBiomeDecorator instanceof DeferredBiomeDecorator ) 
 - { 
 - DeferredBiomeDecorator decorator = ( DeferredBiomeDecorator ) biome . theBiomeDecorator ; 
 - decorator . fireCreateEventAndReplace ( biome ) ; 
 - } 
 - 
 - checkRegistration ( biome ) ; 
 - } 
 + return ! getBiomeInfo ( biome ) . types . isEmpty ( ) ; 
 } 
 
 / * * 
 - * Automatically looks for and registers a given biome with appropriate tags 
 - * This method is called automatically if a biome has not been registered with any tags , 
 - * And another method requests information about it 
 + * Automatically adds appropriate types to a given biome based on certain heuristics . 
 + * If a biome ' s types are requested and no types have been added to the biome so far , the biome ' s types 
 + * will be determined and added using this method . 
 * 
 - * @ param biome the biome to be considered 
 * / 
 public static void makeBestGuess ( Biome biome ) 
 { 
 @ @ - 311 , 189 + 249 , 202 @ @ public class BiomeDictionary 
 { 
 if ( biome . isHighHumidity ( ) & & biome . getTemperature ( ) > = 0 . 9F ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , JUNGLE ) ; 
 + BiomeDictionary . addTypes ( biome , JUNGLE ) ; 
 } 
 else if ( ! biome . isHighHumidity ( ) ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , FOREST ) ; 
 + BiomeDictionary . addTypes ( biome , FOREST ) ; 
 
 if ( biome . getTemperature ( ) < = 0 . 2f ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , CONIFEROUS ) ; 
 + BiomeDictionary . addTypes ( biome , CONIFEROUS ) ; 
 } 
 } 
 } 
 - else if ( biome . getHeightVariation ( ) < = 0 . 3F & & biome . getHeightVariation ( ) > = 0 . 0F ) 
 + else if ( biome . getHeightVariation ( ) < = 0 . 3F & & biome . getHeightVariation ( ) > = 0 . 0F ) 
 { 
 - if ( ! biome . isHighHumidity ( ) | | biome . getBaseHeight ( ) > = 0 . 0F ) 
 + if ( ! biome . isHighHumidity ( ) | | biome . getBaseHeight ( ) > = 0 . 0F ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , PLAINS ) ; 
 + BiomeDictionary . addTypes ( biome , PLAINS ) ; 
 } 
 } 
 
 if ( biome . getRainfall ( ) > 0 . 85f ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , WET ) ; 
 + BiomeDictionary . addTypes ( biome , WET ) ; 
 } 
 
 if ( biome . getRainfall ( ) < 0 . 15f ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , DRY ) ; 
 + BiomeDictionary . addTypes ( biome , DRY ) ; 
 } 
 
 if ( biome . getTemperature ( ) > 0 . 85f ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , HOT ) ; 
 + BiomeDictionary . addTypes ( biome , HOT ) ; 
 } 
 
 if ( biome . getTemperature ( ) < 0 . 15f ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , COLD ) ; 
 + BiomeDictionary . addTypes ( biome , COLD ) ; 
 } 
 
 if ( biome . theBiomeDecorator . treesPerChunk > 0 & & biome . theBiomeDecorator . treesPerChunk < 3 ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , SPARSE ) ; 
 + BiomeDictionary . addTypes ( biome , SPARSE ) ; 
 } 
 else if ( biome . theBiomeDecorator . treesPerChunk > = 10 ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , DENSE ) ; 
 + BiomeDictionary . addTypes ( biome , DENSE ) ; 
 } 
 
 if ( biome . isHighHumidity ( ) & & biome . getBaseHeight ( ) < 0 . 0F & & ( biome . getHeightVariation ( ) < = 0 . 3F & & biome . getHeightVariation ( ) > = 0 . 0F ) ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , SWAMP ) ; 
 + BiomeDictionary . addTypes ( biome , SWAMP ) ; 
 } 
 
 if ( biome . getBaseHeight ( ) < = - 0 . 5F ) 
 { 
 if ( biome . getHeightVariation ( ) = = 0 . 0F ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , RIVER ) ; 
 + BiomeDictionary . addTypes ( biome , RIVER ) ; 
 } 
 else 
 { 
 - BiomeDictionary . registerBiomeType ( biome , OCEAN ) ; 
 + BiomeDictionary . addTypes ( biome , OCEAN ) ; 
 } 
 } 
 
 if ( biome . getHeightVariation ( ) > = 0 . 4F & & biome . getHeightVariation ( ) < 1 . 5F ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , HILLS ) ; 
 + BiomeDictionary . addTypes ( biome , HILLS ) ; 
 } 
 
 if ( biome . getHeightVariation ( ) > = 1 . 5F ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , MOUNTAIN ) ; 
 + BiomeDictionary . addTypes ( biome , MOUNTAIN ) ; 
 } 
 
 if ( biome . getEnableSnow ( ) ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , SNOWY ) ; 
 + BiomeDictionary . addTypes ( biome , SNOWY ) ; 
 } 
 
 if ( biome . topBlock ! = Blocks . SAND & & biome . getTemperature ( ) > = 1 . 0f & & biome . getRainfall ( ) < 0 . 2f ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , SAVANNA ) ; 
 + BiomeDictionary . addTypes ( biome , SAVANNA ) ; 
 } 
 
 if ( biome . topBlock = = Blocks . SAND ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , SANDY ) ; 
 + BiomeDictionary . addTypes ( biome , SANDY ) ; 
 } 
 else if ( biome . topBlock = = Blocks . MYCELIUM ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , MUSHROOM ) ; 
 + BiomeDictionary . addTypes ( biome , MUSHROOM ) ; 
 } 
 if ( biome . fillerBlock = = Blocks . HARDENED _ CLAY ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , MESA ) ; 
 + BiomeDictionary . addTypes ( biome , MESA ) ; 
 } 
 } 
 
 / / Internal implementation 
 private static BiomeInfo getBiomeInfo ( Biome biome ) 
 { 
 - return biomeInfoMap . get ( Biome . REGISTRY . getNameForObject ( biome ) ) ; 
 + BiomeInfo info = biomeInfoMap . get ( biome . getRegistryName ( ) ) ; 
 + if ( info = = null ) 
 + { 
 + info = new BiomeInfo ( ) ; 
 + biomeInfoMap . put ( biome . getRegistryName ( ) , info ) ; 
 + } 
 + return info ; 
 } 
 
 - private static void checkRegistration ( Biome biome ) 
 + / * * 
 + * Ensure that at least one type has been added to the given biome . 
 + * / 
 + static void ensureHasTypes ( Biome biome ) 
 { 
 - if ( ! isBiomeRegistered ( biome ) ) 
 + if ( ! hasAnyType ( biome ) ) 
 { 
 + FMLLog . warning ( " No types have been added to Biome % s , types will be assigned on a best - effort guess . " , biome . getRegistryName ( ) ) ; 
 makeBestGuess ( biome ) ; 
 } 
 } 
 
 - private static boolean containsType ( BiomeInfo info , Type type ) 
 + private static boolean containsType ( Set < Type > types , Type type ) 
 { 
 - if ( type . hasSubTags ( ) ) 
 + if ( type . hasSubTypes ( ) ) 
 { 
 - for ( Type remappedType : listSubTags ( type ) ) 
 - { 
 - if ( info . typeList . contains ( remappedType ) ) return true ; 
 - } 
 - 
 - return false ; 
 + return ! Collections . disjoint ( types , type . subTypes ) ; 
 + } 
 + else 
 + { 
 + return types . contains ( type ) ; 
 } 
 - 
 - return info . typeList . contains ( type ) ; 
 } 
 
 - private static Type [ ] listSubTags ( Type . . . types ) 
 + private static List < Type > listSubTypes ( Type . . . types ) 
 { 
 List < Type > subTags = new ArrayList < Type > ( ) ; 
 
 for ( Type type : types ) 
 { 
 - if ( type . hasSubTags ( ) ) subTags . addAll ( type . subTags ) ; 
 - else subTags . add ( type ) ; 
 + if ( type . hasSubTypes ( ) ) 
 + { 
 + subTags . addAll ( type . subTypes ) ; 
 + } 
 + else 
 + { 
 + subTags . add ( type ) ; 
 + } 
 } 
 
 - return subTags . toArray ( new Type [ subTags . size ( ) ] ) ; 
 + return subTags ; 
 } 
 
 private static void registerVanillaBiomes ( ) 
 { 
 - registerBiomeType ( Biomes . OCEAN , OCEAN ) ; 
 - registerBiomeType ( Biomes . PLAINS , PLAINS ) ; 
 - registerBiomeType ( Biomes . DESERT , HOT , DRY , SANDY ) ; 
 - registerBiomeType ( Biomes . EXTREME _ HILLS , MOUNTAIN , HILLS ) ; 
 - registerBiomeType ( Biomes . FOREST , FOREST ) ; 
 - registerBiomeType ( Biomes . TAIGA , COLD , CONIFEROUS , FOREST ) ; 
 - registerBiomeType ( Biomes . TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , HILLS ) ; 
 - registerBiomeType ( Biomes . SWAMPLAND , WET , SWAMP ) ; 
 - registerBiomeType ( Biomes . RIVER , RIVER ) ; 
 - registerBiomeType ( Biomes . FROZEN _ OCEAN , COLD , OCEAN , SNOWY ) ; 
 - registerBiomeType ( Biomes . FROZEN _ RIVER , COLD , RIVER , SNOWY ) ; 
 - registerBiomeType ( Biomes . ICE _ PLAINS , COLD , SNOWY , WASTELAND ) ; 
 - registerBiomeType ( Biomes . ICE _ MOUNTAINS , COLD , SNOWY , MOUNTAIN ) ; 
 - registerBiomeType ( Biomes . BEACH , BEACH ) ; 
 - registerBiomeType ( Biomes . DESERT _ HILLS , HOT , DRY , SANDY , HILLS ) ; 
 - registerBiomeType ( Biomes . JUNGLE , HOT , WET , DENSE , JUNGLE ) ; 
 - registerBiomeType ( Biomes . JUNGLE _ HILLS , HOT , WET , DENSE , JUNGLE , HILLS ) ; 
 - registerBiomeType ( Biomes . FOREST _ HILLS , FOREST , HILLS ) ; 
 - registerBiomeType ( Biomes . SKY , COLD , DRY , END ) ; 
 - registerBiomeType ( Biomes . HELL , HOT , DRY , NETHER ) ; 
 - registerBiomeType ( Biomes . MUSHROOM _ ISLAND , MUSHROOM ) ; 
 - registerBiomeType ( Biomes . EXTREME _ HILLS _ EDGE , MOUNTAIN ) ; 
 - registerBiomeType ( Biomes . MUSHROOM _ ISLAND _ SHORE , MUSHROOM , BEACH ) ; 
 - registerBiomeType ( Biomes . JUNGLE _ EDGE , HOT , WET , JUNGLE , FOREST ) ; 
 - registerBiomeType ( Biomes . DEEP _ OCEAN , OCEAN ) ; 
 - registerBiomeType ( Biomes . STONE _ BEACH , BEACH ) ; 
 - registerBiomeType ( Biomes . COLD _ BEACH , COLD , BEACH , SNOWY ) ; 
 - registerBiomeType ( Biomes . BIRCH _ FOREST , FOREST ) ; 
 - registerBiomeType ( Biomes . BIRCH _ FOREST _ HILLS , FOREST , HILLS ) ; 
 - registerBiomeType ( Biomes . ROOFED _ FOREST , SPOOKY , DENSE , FOREST ) ; 
 - registerBiomeType ( Biomes . COLD _ TAIGA , COLD , CONIFEROUS , FOREST , SNOWY ) ; 
 - registerBiomeType ( Biomes . COLD _ TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , SNOWY , HILLS ) ; 
 - registerBiomeType ( Biomes . REDWOOD _ TAIGA , COLD , CONIFEROUS , FOREST ) ; 
 - registerBiomeType ( Biomes . REDWOOD _ TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , HILLS ) ; 
 - registerBiomeType ( Biomes . EXTREME _ HILLS _ WITH _ TREES , MOUNTAIN , FOREST , SPARSE ) ; 
 - registerBiomeType ( Biomes . SAVANNA , HOT , SAVANNA , PLAINS , SPARSE ) ; 
 - registerBiomeType ( Biomes . SAVANNA _ PLATEAU , HOT , SAVANNA , PLAINS , SPARSE ) ; 
 - registerBiomeType ( Biomes . MESA , MESA , SANDY ) ; 
 - registerBiomeType ( Biomes . MESA _ ROCK , MESA , SPARSE , SANDY ) ; 
 - registerBiomeType ( Biomes . MESA _ CLEAR _ ROCK , MESA , SANDY ) ; 
 + addTypes ( Biomes . OCEAN , OCEAN ) ; 
 + addTypes ( Biomes . PLAINS , PLAINS ) ; 
 + addTypes ( Biomes . DESERT , HOT , DRY , SANDY ) ; 
 + addTypes ( Biomes . EXTREME _ HILLS , MOUNTAIN , HILLS ) ; 
 + addTypes ( Biomes . FOREST , FOREST ) ; 
 + addTypes ( Biomes . TAIGA , COLD , CONIFEROUS , FOREST ) ; 
 + addTypes ( Biomes . TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , HILLS ) ; 
 + addTypes ( Biomes . SWAMPLAND , WET , SWAMP ) ; 
 + addTypes ( Biomes . RIVER , RIVER ) ; 
 + addTypes ( Biomes . FROZEN _ OCEAN , COLD , OCEAN , SNOWY ) ; 
 + addTypes ( Biomes . FROZEN _ RIVER , COLD , RIVER , SNOWY ) ; 
 + addTypes ( Biomes . ICE _ PLAINS , COLD , SNOWY , WASTELAND ) ; 
 + addTypes ( Biomes . ICE _ MOUNTAINS , COLD , SNOWY , MOUNTAIN ) ; 
 + addTypes ( Biomes . BEACH , BEACH ) ; 
 + addTypes ( Biomes . DESERT _ HILLS , HOT , DRY , SANDY , HILLS ) ; 
 + addTypes ( Biomes . JUNGLE , HOT , WET , DENSE , JUNGLE ) ; 
 + addTypes ( Biomes . JUNGLE _ HILLS , HOT , WET , DENSE , JUNGLE , HILLS ) ; 
 + addTypes ( Biomes . FOREST _ HILLS , FOREST , HILLS ) ; 
 + addTypes ( Biomes . SKY , COLD , DRY , END ) ; 
 + addTypes ( Biomes . HELL , HOT , DRY , NETHER ) ; 
 + addTypes ( Biomes . MUSHROOM _ ISLAND , MUSHROOM ) ; 
 + addTypes ( Biomes . EXTREME _ HILLS _ EDGE , MOUNTAIN ) ; 
 + addTypes ( Biomes . MUSHROOM _ ISLAND _ SHORE , MUSHROOM , BEACH ) ; 
 + addTypes ( Biomes . JUNGLE _ EDGE , HOT , WET , JUNGLE , FOREST ) ; 
 + addTypes ( Biomes . DEEP _ OCEAN , OCEAN ) ; 
 + addTypes ( Biomes . STONE _ BEACH , BEACH ) ; 
 + addTypes ( Biomes . COLD _ BEACH , COLD , BEACH , SNOWY ) ; 
 + addTypes ( Biomes . BIRCH _ FOREST , FOREST ) ; 
 + addTypes ( Biomes . BIRCH _ FOREST _ HILLS , FOREST , HILLS ) ; 
 + addTypes ( Biomes . ROOFED _ FOREST , SPOOKY , DENSE , FOREST ) ; 
 + addTypes ( Biomes . COLD _ TAIGA , COLD , CONIFEROUS , FOREST , SNOWY ) ; 
 + addTypes ( Biomes . COLD _ TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , SNOWY , HILLS ) ; 
 + addTypes ( Biomes . REDWOOD _ TAIGA , COLD , CONIFEROUS , FOREST ) ; 
 + addTypes ( Biomes . REDWOOD _ TAIGA _ HILLS , COLD , CONIFEROUS , FOREST , HILLS ) ; 
 + addTypes ( Biomes . EXTREME _ HILLS _ WITH _ TREES , MOUNTAIN , FOREST , SPARSE ) ; 
 + addTypes ( Biomes . SAVANNA , HOT , SAVANNA , PLAINS , SPARSE ) ; 
 + addTypes ( Biomes . SAVANNA _ PLATEAU , HOT , SAVANNA , PLAINS , SPARSE ) ; 
 + addTypes ( Biomes . MESA , MESA , SANDY ) ; 
 + addTypes ( Biomes . MESA _ ROCK , MESA , SPARSE , SANDY ) ; 
 + addTypes ( Biomes . MESA _ CLEAR _ ROCK , MESA , SANDY ) ; 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / common / ForgeModContainer . java b / src / main / java / net / minecraftforge / common / ForgeModContainer . java 
 index ff70583 . . 149a5ad 100644 
 - - - a / src / main / java / net / minecraftforge / common / ForgeModContainer . java 
 + + + b / src / main / java / net / minecraftforge / common / ForgeModContainer . java 
 @ @ - 24 , 6 + 24 , 7 @ @ 
 
 package net . minecraftforge . common ; 
 
 + import net . minecraft . world . biome . Biome ; 
 import static net . minecraftforge . common . config . Configuration . CATEGORY _ CLIENT ; 
 import static net . minecraftforge . common . config . Configuration . CATEGORY _ GENERAL ; 
 
 @ @ - 38 , 11 + 39 , 9 @ @ import java . util . Date ; 
 import java . util . Iterator ; 
 import java . util . List ; 
 import java . util . Map ; 
 - import java . util . Set ; 
 
 import org . apache . logging . log4j . Level ; 
 
 - import net . minecraft . crash . CrashReport ; 
 import net . minecraft . crash . ICrashReportDetail ; 
 import net . minecraft . nbt . NBTBase ; 
 import net . minecraft . nbt . NBTTagCompound ; 
 @ @ - 57 , 8 + 56 , 10 @ @ import net . minecraftforge . common . config . Property ; 
 import net . minecraftforge . common . model . animation . CapabilityAnimation ; 
 import net . minecraftforge . common . network . ForgeNetworkHandler ; 
 import net . minecraftforge . energy . CapabilityEnergy ; 
 + import net . minecraftforge . event . terraingen . DeferredBiomeDecorator ; 
 import net . minecraftforge . fluids . FluidRegistry ; 
 import net . minecraftforge . fluids . capability . CapabilityFluidHandler ; 
 + import net . minecraftforge . fml . common . registry . ForgeRegistries ; 
 import net . minecraftforge . items . CapabilityItemHandler ; 
 import net . minecraftforge . fluids . UniversalBucket ; 
 import net . minecraftforge . fml . common . registry . GameRegistry ; 
 @ @ - 82 , 7 + 83 , 6 @ @ import net . minecraftforge . fml . common . LoadController ; 
 import net . minecraftforge . fml . common . Loader ; 
 import net . minecraftforge . fml . common . ModMetadata ; 
 import net . minecraftforge . fml . common . WorldAccessContainer ; 
 - import net . minecraftforge . fml . common . discovery . ASMDataTable ; 
 import net . minecraftforge . fml . common . discovery . ASMDataTable . ASMData ; 
 import net . minecraftforge . fml . common . event . FMLConstructionEvent ; 
 import net . minecraftforge . fml . common . event . FMLLoadCompleteEvent ; 
 @ @ - 428 , 10 + 428 , 24 @ @ public class ForgeModContainer extends DummyModContainer implements WorldAccessC 
 @ Subscribe 
 public void postInit ( FMLPostInitializationEvent evt ) 
 { 
 - BiomeDictionary . registerAllBiomesAndGenerateEvents ( ) ; 
 + registerAllBiomesAndGenerateEvents ( ) ; 
 ForgeChunkManager . loadConfiguration ( ) ; 
 } 
 
 + private static void registerAllBiomesAndGenerateEvents ( ) 
 + { 
 + for ( Biome biome : ForgeRegistries . BIOMES . getValues ( ) ) 
 + { 
 + if ( biome . theBiomeDecorator instanceof DeferredBiomeDecorator ) 
 + { 
 + DeferredBiomeDecorator decorator = ( DeferredBiomeDecorator ) biome . theBiomeDecorator ; 
 + decorator . fireCreateEventAndReplace ( biome ) ; 
 + } 
 + 
 + BiomeDictionary . ensureHasTypes ( biome ) ; 
 + } 
 + } 
 + 
 @ Subscribe 
 public void onAvailable ( FMLLoadCompleteEvent evt ) 
 {

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / BiomeDictionary . java b / src / main / java / net / minecraftforge / common / BiomeDictionary . java 
 index cece2c8 . . a62ed47 100644 
 - - - a / src / main / java / net / minecraftforge / common / BiomeDictionary . java 
 + + + b / src / main / java / net / minecraftforge / common / BiomeDictionary . java 
 @ @ - 3 , 6 + 3 , 7 @ @ package net . minecraftforge . common ; 
 import java . util . * ; 
 
 import cpw . mods . fml . common . FMLLog ; 
 + import net . minecraft . init . Blocks ; 
 import net . minecraft . world . biome . * ; 
 import net . minecraftforge . event . terraingen . DeferredBiomeDecorator ; 
 import static net . minecraft . world . biome . BiomeGenBase . * ; 
 @ @ - 12 , 21 + 13 , 66 @ @ public class BiomeDictionary 
 { 
 public enum Type 
 { 
 + / * Temperature - based tags . Specifying neither implies a biome is temperate * / 
 + HOT , 
 + COLD , 
 + / * Tags specifying the amount of vegetation a biome has . Specifying neither implies a biome to have moderate amounts * / 
 + SPARSE , 
 + DENSE , 
 + / * Tags specifying how moist a biome is . Specifying neither implies the biome as having moderate humidity * / 
 + WET , 
 + DRY , 
 + / * Tree - based tags , SAVANNA refers to dry , desert - like trees ( Such as Acacia ) , CONIFEROUS refers to snowy trees ( Such as Spruce ) and JUNGLE refers to jungle trees . 
 + * Specifying no tag implies a biome has temperate trees ( Such as Oak ) * / 
 + SAVANNA , 
 + CONIFEROUS , 
 + JUNGLE , 
 + 
 + / * Tags specifying the nature of a biome * / 
 + SPOOKY , 
 + DEAD , 
 + LUSH , 
 + NETHER , 
 + END , 
 + MUSHROOM , 
 + MAGICAL , 
 + 
 + OCEAN , 
 + RIVER , 
 + / * * A general tag for all water - based biomes . Shown as present if OCEAN or RIVER are . * * / 
 + WATER ( OCEAN , RIVER ) , 
 + 
 + / * Generic types which a biome can be * / 
 + MESA , 
 FOREST , 
 PLAINS , 
 MOUNTAIN , 
 HILLS , 
 SWAMP , 
 - WATER , 
 - DESERT , 
 - FROZEN , 
 - JUNGLE , 
 + SANDY , 
 + SNOWY , 
 WASTELAND , 
 BEACH , 
 - NETHER , 
 - END , 
 - MUSHROOM , 
 - MAGICAL ; 
 + 
 + / * Deprecated tags , kept for compatibility * / 
 + @ Deprecated 
 + / * * Replaced by SANDY * * / 
 + DESERT ( SANDY ) , 
 + @ Deprecated 
 + / * * Replaced by SNOWY * * / 
 + FROZEN ( SNOWY ) ; 
 + 
 + private List < Type > subTags ; 
 + 
 + private Type ( Type . . . subTags ) 
 + { 
 + this . subTags = Arrays . asList ( subTags ) ; 
 + } 
 + 
 + private boolean hasSubTags ( ) 
 + { 
 + return subTags ! = null & & ! subTags . isEmpty ( ) ; 
 + } 
 } 
 
 private static final int BIOME _ LIST _ SIZE = BiomeGenBase . getBiomeGenArray ( ) . length ; 
 @ @ - 62 , 6 + 108 , 8 @ @ public class BiomeDictionary 
 * / 
 public static boolean registerBiomeType ( BiomeGenBase biome , Type . . . types ) 
 { 
 + types = listSubTags ( types ) ; 
 + 
 if ( BiomeGenBase . getBiomeGenArray ( ) [ biome . biomeID ] ! = null ) 
 { 
 for ( Type type : types ) 
 @ @ - 232 , 15 + 280 , 20 @ @ public class BiomeDictionary 
 * / 
 public static void makeBestGuess ( BiomeGenBase biome ) 
 { 
 - if ( biome . theBiomeDecorator . treesPerChunk > = 3 ) 
 + if ( biome . theBiomeDecorator . treesPerChunk > = 3 ) 
 { 
 - if ( biome . isHighHumidity ( ) & & biome . temperature > = 1 . 0F ) 
 + if ( biome . isHighHumidity ( ) & & biome . temperature > = 0 . 9F ) 
 { 
 BiomeDictionary . registerBiomeType ( biome , JUNGLE ) ; 
 } 
 - else if ( ! biome . isHighHumidity ( ) ) 
 + else if ( ! biome . isHighHumidity ( ) ) 
 { 
 BiomeDictionary . registerBiomeType ( biome , FOREST ) ; 
 + 
 + if ( biome . temperature < = 0 . 2f ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , CONIFEROUS ) ; 
 + } 
 } 
 } 
 else if ( biome . heightVariation < = 0 . 3F & & biome . heightVariation > = 0 . 0F ) 
 @ @ - 251 , 29 + 304 , 83 @ @ public class BiomeDictionary 
 } 
 } 
 
 - if ( biome . isHighHumidity ( ) & & biome . rootHeight < 0 . 0F & & ( biome . heightVariation < = 0 . 3F & & biome . heightVariation > = 0 . 0F ) ) 
 + if ( biome . rainfall > 0 . 85f ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , WET ) ; 
 + } 
 + 
 + if ( biome . rainfall < 0 . 15f ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , DRY ) ; 
 + } 
 + 
 + if ( biome . temperature > 0 . 85f ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , HOT ) ; 
 + } 
 + 
 + if ( biome . temperature < 0 . 15f ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , COLD ) ; 
 + } 
 + 
 + if ( biome . theBiomeDecorator . treesPerChunk > 0 & & biome . theBiomeDecorator . treesPerChunk < 3 ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , SPARSE ) ; 
 + } 
 + else if ( biome . theBiomeDecorator . treesPerChunk > = 10 ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , DENSE ) ; 
 + } 
 + 
 + if ( biome . isHighHumidity ( ) & & biome . rootHeight < 0 . 0F & & ( biome . heightVariation < = 0 . 3F & & biome . heightVariation > = 0 . 0F ) ) 
 { 
 BiomeDictionary . registerBiomeType ( biome , SWAMP ) ; 
 } 
 
 - if ( biome . rootHeight < = - 0 . 5F ) 
 + if ( biome . rootHeight < = - 0 . 5F ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , WATER ) ; 
 + if ( biome . heightVariation = = 0 . 0F ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , RIVER ) ; 
 + } 
 + else 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , OCEAN ) ; 
 + } 
 } 
 
 - if ( biome . heightVariation > = 1 . 5F ) 
 + if ( biome . heightVariation > = 0 . 4F & & biome . heightVariation < 1 . 5F ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , HILLS ) ; 
 + } 
 + 
 + if ( biome . heightVariation > = 1 . 5F ) 
 { 
 BiomeDictionary . registerBiomeType ( biome , MOUNTAIN ) ; 
 } 
 - 
 - if ( biome . getEnableSnow ( ) | | biome . temperature < 0 . 2F ) 
 + 
 + if ( biome . getEnableSnow ( ) ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , FROZEN ) ; 
 + BiomeDictionary . registerBiomeType ( biome , SNOWY ) ; 
 } 
 - 
 - if ( ! biome . isHighHumidity ( ) & & biome . temperature > = 1 . 0F ) 
 + 
 + if ( biome . topBlock ! = Blocks . sand & & biome . temperature > = 1 . 0f & & biome . rainfall < 0 . 2f ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , SAVANNA ) ; 
 + } 
 + 
 + if ( biome . topBlock = = Blocks . sand ) 
 { 
 - BiomeDictionary . registerBiomeType ( biome , DESERT ) ; 
 + BiomeDictionary . registerBiomeType ( biome , SANDY ) ; 
 + } 
 + else if ( biome . topBlock = = Blocks . hardened _ clay ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , MESA ) ; 
 + } 
 + else if ( biome . topBlock = = Blocks . mycelium ) 
 + { 
 + BiomeDictionary . registerBiomeType ( biome , MUSHROOM ) ; 
 } 
 } 
 
 @ @ - 288 , 50 + 395 , 73 @ @ public class BiomeDictionary 
 
 private static boolean containsType ( BiomeInfo info , Type type ) 
 { 
 + if ( type . hasSubTags ( ) ) 
 + { 
 + for ( Type remappedType : listSubTags ( type ) ) 
 + { 
 + if ( info . typeList . contains ( remappedType ) ) return true ; 
 + } 
 + 
 + return false ; 
 + } 
 + 
 return info . typeList . contains ( type ) ; 
 } 
 + 
 + private static Type [ ] listSubTags ( Type . . . types ) 
 + { 
 + List < Type > subTags = new ArrayList < Type > ( ) ; 
 + 
 + for ( Type type : types ) 
 + { 
 + if ( type . hasSubTags ( ) ) subTags . addAll ( type . subTags ) ; 
 + else subTags . add ( type ) ; 
 + } 
 + 
 + return subTags . toArray ( new Type [ subTags . size ( ) ] ) ; 
 + } 
 
 private static void registerVanillaBiomes ( ) 
 { 
 - registerBiomeType ( ocean , WATER ) ; 
 - registerBiomeType ( plains , PLAINS ) ; 
 - registerBiomeType ( desert , DESERT ) ; 
 - registerBiomeType ( extremeHills , MOUNTAIN ) ; 
 - registerBiomeType ( forest , FOREST ) ; 
 - registerBiomeType ( taiga , FOREST , FROZEN ) ; 
 - registerBiomeType ( taigaHills , FOREST , FROZEN ) ; 
 - registerBiomeType ( swampland , SWAMP ) ; 
 - registerBiomeType ( river , WATER ) ; 
 - registerBiomeType ( frozenOcean , WATER , FROZEN ) ; 
 - registerBiomeType ( frozenRiver , WATER , FROZEN ) ; 
 - registerBiomeType ( icePlains , FROZEN ) ; 
 - registerBiomeType ( iceMountains , FROZEN ) ; 
 - registerBiomeType ( beach , BEACH ) ; 
 - registerBiomeType ( desertHills , DESERT ) ; 
 - registerBiomeType ( jungle , JUNGLE ) ; 
 - registerBiomeType ( jungleHills , JUNGLE ) ; 
 - registerBiomeType ( forestHills , FOREST ) ; 
 - registerBiomeType ( sky , END ) ; 
 - registerBiomeType ( hell , NETHER ) ; 
 - registerBiomeType ( mushroomIsland , MUSHROOM ) ; 
 - registerBiomeType ( extremeHillsEdge , MOUNTAIN ) ; 
 - registerBiomeType ( mushroomIslandShore , MUSHROOM , BEACH ) ; 
 - registerBiomeType ( jungleEdge , JUNGLE ) ; 
 - registerBiomeType ( deepOcean , WATER ) ; 
 - registerBiomeType ( stoneBeach , BEACH ) ; 
 - registerBiomeType ( coldBeach , BEACH , FROZEN ) ; 
 - registerBiomeType ( birchForest , FOREST ) ; 
 - registerBiomeType ( birchForestHills , FOREST ) ; 
 - registerBiomeType ( roofedForest , FOREST ) ; 
 - registerBiomeType ( coldTaiga , FOREST , FROZEN ) ; 
 - registerBiomeType ( coldTaigaHills , FOREST , FROZEN ) ; 
 - registerBiomeType ( megaTaiga , FOREST ) ; 
 - registerBiomeType ( megaTaigaHills , FOREST ) ; 
 - registerBiomeType ( extremeHillsPlus , FOREST ) ; 
 - registerBiomeType ( savanna , PLAINS , DESERT ) ; 
 - registerBiomeType ( savannaPlateau , PLAINS , DESERT ) ; 
 - registerBiomeType ( mesa , DESERT ) ; 
 - registerBiomeType ( mesaPlateau _ F , DESERT ) ; 
 - registerBiomeType ( mesaPlateau , DESERT ) ; 
 + registerBiomeType ( ocean , OCEAN ) ; 
 + registerBiomeType ( plains , PLAINS ) ; 
 + registerBiomeType ( desert , HOT , DRY , SANDY ) ; 
 + registerBiomeType ( extremeHills , MOUNTAIN , HILLS ) ; 
 + registerBiomeType ( forest , FOREST ) ; 
 + registerBiomeType ( taiga , COLD , CONIFEROUS , FOREST ) ; 
 + registerBiomeType ( taigaHills , COLD , CONIFEROUS , FOREST , HILLS ) ; 
 + registerBiomeType ( swampland , WET , SWAMP ) ; 
 + registerBiomeType ( river , RIVER ) ; 
 + registerBiomeType ( frozenOcean , COLD , OCEAN , SNOWY ) ; 
 + registerBiomeType ( frozenRiver , COLD , RIVER , SNOWY ) ; 
 + registerBiomeType ( icePlains , COLD , SNOWY , WASTELAND ) ; 
 + registerBiomeType ( iceMountains , COLD , SNOWY , MOUNTAIN ) ; 
 + registerBiomeType ( beach , BEACH ) ; 
 + registerBiomeType ( desertHills , HOT , DRY , SANDY , HILLS ) ; 
 + registerBiomeType ( jungle , HOT , WET , DENSE , JUNGLE ) ; 
 + registerBiomeType ( jungleHills , HOT , WET , DENSE , JUNGLE , HILLS ) ; 
 + registerBiomeType ( forestHills , FOREST , HILLS ) ; 
 + registerBiomeType ( sky , COLD , DRY , END ) ; 
 + registerBiomeType ( hell , HOT , DRY , NETHER ) ; 
 + registerBiomeType ( mushroomIsland , MUSHROOM ) ; 
 + registerBiomeType ( extremeHillsEdge , MOUNTAIN ) ; 
 + registerBiomeType ( mushroomIslandShore , MUSHROOM , BEACH ) ; 
 + registerBiomeType ( jungleEdge , HOT , WET , JUNGLE , FOREST ) ; 
 + registerBiomeType ( deepOcean , OCEAN ) ; 
 + registerBiomeType ( stoneBeach , BEACH ) ; 
 + registerBiomeType ( coldBeach , COLD , BEACH , SNOWY ) ; 
 + registerBiomeType ( birchForest , FOREST ) ; 
 + registerBiomeType ( birchForestHills , FOREST , HILLS ) ; 
 + registerBiomeType ( roofedForest , SPOOKY , DENSE , FOREST ) ; 
 + registerBiomeType ( coldTaiga , COLD , CONIFEROUS , FOREST , SNOWY ) ; 
 + registerBiomeType ( coldTaigaHills , COLD , CONIFEROUS , FOREST , SNOWY , HILLS ) ; 
 + registerBiomeType ( megaTaiga , COLD , CONIFEROUS , FOREST ) ; 
 + registerBiomeType ( megaTaigaHills , COLD , CONIFEROUS , FOREST , HILLS ) ; 
 + registerBiomeType ( extremeHillsPlus , MOUNTAIN , FOREST , SPARSE ) ; 
 + registerBiomeType ( savanna , HOT , SAVANNA , PLAINS , SPARSE ) ; 
 + registerBiomeType ( savannaPlateau , HOT , SAVANNA , PLAINS , SPARSE ) ; 
 + registerBiomeType ( mesa , MESA , SANDY ) ; 
 + registerBiomeType ( mesaPlateau _ F , MESA , SPARSE , SANDY ) ; 
 + registerBiomeType ( mesaPlateau , MESA , SANDY ) ; 
 } 
 }
