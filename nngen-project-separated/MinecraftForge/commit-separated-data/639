BLEU SCORE: 0.02616269437927649

TEST MSG: Some test harness stuffs . Time to get the registry manager properly tested .
GENERATED MSG: Copy eventhandler from Forge into FML . It is going to replace a lot of the runtime event systems .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / Loader . java b / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> index b6cd20c . . 982c389 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> @ @ - 204 , 7 + 204 , 7 @ @ public class Loader <nl> } <nl> <nl> modClassLoader = new ModClassLoader ( getClass ( ) . getClassLoader ( ) ) ; <nl> - if ( ! mccversion . equals ( MC _ VERSION ) ) <nl> + if ( mccversion ! = null & & ! mccversion . equals ( MC _ VERSION ) ) <nl> { <nl> FMLLog . severe ( " This version of FML is built for Minecraft % s , we have detected Minecraft % s in your minecraft jar file " , mccversion , MC _ VERSION ) ; <nl> throw new LoaderException ( String . format ( " This version of FML is built for Minecraft % s , we have detected Minecraft % s in your minecraft jar file " , mccversion , MC _ VERSION ) ) ; <nl> @ @ - 1023 , 7 + 1023 , 10 @ @ public class Loader <nl> <nl> public void fireRemapEvent ( Map < ResourceLocation , Integer [ ] > remapBlocks , Map < ResourceLocation , Integer [ ] > remapItems , boolean isFreezing ) <nl> { <nl> - modController . propogateStateMessage ( new FMLModIdMappingEvent ( remapBlocks , remapItems , isFreezing ) ) ; <nl> + if ( modController ! = null ) <nl> + { <nl> + modController . propogateStateMessage ( new FMLModIdMappingEvent ( remapBlocks , remapItems , isFreezing ) ) ; <nl> + } <nl> } <nl> <nl> public void runtimeDisableMod ( String modId ) <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java b / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java <nl> index d11135b . . ea23483 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java <nl> @ @ - 55 , 7 + 55 , 10 @ @ public class ModClassLoader extends URLClassLoader <nl> <nl> public ModClassLoader ( ClassLoader parent ) { <nl> super ( new URL [ 0 ] , null ) ; <nl> - this . mainClassLoader = ( LaunchClassLoader ) parent ; <nl> + if ( parent instanceof LaunchClassLoader ) <nl> + { <nl> + this . mainClassLoader = ( LaunchClassLoader ) parent ; <nl> + } <nl> this . sources = Lists . newArrayList ( ) ; <nl> } <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> index da64ad9 . . 1f5670a 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> @ @ - 61 , 7 + 61 , 7 @ @ import com . google . common . collect . Sets . SetView ; <nl> @ SuppressWarnings ( " WeakerAccess " ) <nl> public class PersistentRegistryManager <nl> { <nl> - private enum PersistentRegistry <nl> + enum PersistentRegistry <nl> { <nl> ACTIVE , VANILLA , FROZEN , STAGING ; <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / fml / relauncher / FMLRelaunchLog . java b / src / main / java / net / minecraftforge / fml / relauncher / FMLRelaunchLog . java <nl> index 1c206f0 . . 41691d5 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / relauncher / FMLRelaunchLog . java <nl> + + + b / src / main / java / net / minecraftforge / fml / relauncher / FMLRelaunchLog . java <nl> @ @ - 54 , 6 + 54 , 8 @ @ public class FMLRelaunchLog { <nl> private static void configureLogging ( ) <nl> { <nl> log . myLog = LogManager . getLogger ( " FML " ) ; <nl> + / / Default side to client for test harness purposes <nl> + if ( side = = null ) side = Side . CLIENT ; <nl> ThreadContext . put ( " side " , side . name ( ) . toLowerCase ( Locale . ENGLISH ) ) ; <nl> configured = true ; <nl> <nl> diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java b / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java <nl> new file mode 100644 <nl> index 0000000 . . cc4fbb0 <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java <nl> @ @ - 0 , 0 + 1 , 146 @ @ <nl> + package net . minecraftforge . fml . common . registry ; <nl> + <nl> + import java . net . URLClassLoader ; <nl> + import java . util . Collections ; <nl> + import java . util . Set ; <nl> + <nl> + import com . google . common . collect . Sets ; <nl> + import org . junit . runner . Description ; <nl> + import org . junit . runner . Runner ; <nl> + import org . junit . runner . notification . Failure ; <nl> + import org . junit . runner . notification . RunNotifier ; <nl> + import org . junit . runners . JUnit4 ; <nl> + import org . junit . runners . model . InitializationError ; <nl> + <nl> + / * * <nl> + * Uses { @ code ResettingClassLoader } to load the test class , meaning the <nl> + * { @ code Quarantine } annotation can be used to ensure certain classes are <nl> + * loaded separately . <nl> + * <nl> + * Use of a separate class loader allows classes to be reloaded for each test <nl> + * class , which is handy when you ' re testing frameworks that make use of static <nl> + * members . <nl> + * <nl> + * The selective quarantining is required because if the test class and its <nl> + * ' children ' are all loaded by a different class loader , then the { @ code Test } <nl> + * annotations yield different { @ code Class } instances . JUnit then thinks there <nl> + * are no runnable methods , because it looks them up by Class . <nl> + * <nl> + * This is a simplified copy of https : / / github . com / BinaryTweed / quarantining - test - runner <nl> + * tailored for Minecraft use . <nl> + * <nl> + * / <nl> + public class ForgeTestRunner extends Runner <nl> + { <nl> + private final Object innerRunner ; <nl> + private final Class < ? > innerRunnerClass ; <nl> + <nl> + public ForgeTestRunner ( Class < ? > testFileClass ) throws InitializationError <nl> + { <nl> + Class < ? extends Runner > delegateRunningTo = JUnit4 . class ; <nl> + <nl> + String testFileClassName = testFileClass . getName ( ) ; <nl> + String delegateRunningToClassName = delegateRunningTo . getName ( ) ; <nl> + <nl> + String [ ] allPatterns = new String [ ] { testFileClassName , delegateRunningToClassName } ; <nl> + <nl> + ResettingClassLoader classLoader = new ResettingClassLoader ( allPatterns ) ; <nl> + <nl> + try <nl> + { <nl> + innerRunnerClass = classLoader . loadClass ( delegateRunningToClassName ) ; <nl> + Class < ? > testClass = classLoader . loadClass ( testFileClassName ) ; <nl> + innerRunner = innerRunnerClass . cast ( innerRunnerClass . getConstructor ( Class . class ) . newInstance ( testClass ) ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new InitializationError ( e ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + @ Override <nl> + public Description getDescription ( ) <nl> + { <nl> + try <nl> + { <nl> + return ( Description ) innerRunnerClass . getMethod ( " getDescription " ) . invoke ( innerRunner ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new RuntimeException ( " Could not get description " , e ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void run ( RunNotifier notifier ) <nl> + { <nl> + try <nl> + { <nl> + innerRunnerClass . getMethod ( " run " , RunNotifier . class ) . invoke ( innerRunner , notifier ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + notifier . fireTestFailure ( new Failure ( getDescription ( ) , e ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * If a class name starts with any of the supplied patterns , it is loaded by <nl> + * < em > this < / em > classloader ; otherwise it is loaded by the parent classloader . <nl> + * <nl> + * / <nl> + private class ResettingClassLoader extends URLClassLoader <nl> + { <nl> + private final Set < String > quarantinedClassNames ; <nl> + <nl> + / * * <nl> + * <nl> + * @ param quarantinedClassNames prefixes to match against when deciding how to load a class <nl> + * / <nl> + public ResettingClassLoader ( String . . . quarantinedClassNames ) <nl> + { <nl> + super ( ( ( URLClassLoader ) getSystemClassLoader ( ) ) . getURLs ( ) ) ; <nl> + <nl> + this . quarantinedClassNames = Sets . newHashSet ( ) ; <nl> + Collections . addAll ( this . quarantinedClassNames , quarantinedClassNames ) ; <nl> + Collections . addAll ( this . quarantinedClassNames , " net . minecraft " , " net . minecraftforge " ) ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * If a class name starts with any of the supplied patterns , it is loaded by <nl> + * < em > this < / em > classloader ; otherwise it is loaded by the parent classloader . <nl> + * <nl> + * @ param name class to load <nl> + * / <nl> + @ Override <nl> + public Class < ? > loadClass ( String name ) throws ClassNotFoundException <nl> + { <nl> + boolean quarantine = false ; <nl> + <nl> + for ( String quarantinedPattern : quarantinedClassNames ) <nl> + { <nl> + if ( name . startsWith ( quarantinedPattern ) ) <nl> + { <nl> + quarantine = true ; <nl> + break ; <nl> + } <nl> + } <nl> + <nl> + if ( quarantine ) <nl> + { <nl> + try <nl> + { <nl> + return findClass ( name ) ; <nl> + } <nl> + catch ( ClassNotFoundException e ) <nl> + { <nl> + throw e ; <nl> + } <nl> + } <nl> + <nl> + return super . loadClass ( name ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / FreezingTests . java b / src / test / java / net / minecraftforge / fml / common / registry / FreezingTests . java <nl> new file mode 100644 <nl> index 0000000 . . 6cdd810 <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / fml / common / registry / FreezingTests . java <nl> @ @ - 0 , 0 + 1 , 105 @ @ <nl> + package net . minecraftforge . fml . common . registry ; <nl> + <nl> + import net . minecraft . block . Block ; <nl> + import net . minecraft . item . Item ; <nl> + import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . fml . common . Loader ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import static org . junit . Assert . * ; <nl> + <nl> + / * * <nl> + * Created by cpw on 04 / 07 / 16 . <nl> + * / <nl> + @ RunWith ( ForgeTestRunner . class ) <nl> + public class FreezingTests <nl> + { <nl> + <nl> + private static RTest r1 ; <nl> + private static RTest r2 ; <nl> + private static RTest r3 ; <nl> + private static RTest r4 ; <nl> + private static RTest r5 ; <nl> + private static RTest r6 ; <nl> + private static PersistentRegistryManager . GameDataSnapshot ss ; <nl> + <nl> + static class RTest extends IForgeRegistryEntry . Impl < RTest > { <nl> + public RTest ( String name ) { <nl> + setRegistryName ( name ) ; <nl> + } <nl> + } <nl> + <nl> + public static IForgeRegistry < RTest > registry ; <nl> + public static ResourceLocation resloc = new ResourceLocation ( " fmltest : test " ) ; <nl> + <nl> + @ BeforeClass <nl> + public static void setup ( ) <nl> + { <nl> + Loader . instance ( ) ; <nl> + System . setProperty ( " fml . queryResult " , " confirm " ) ; <nl> + registry = PersistentRegistryManager . createRegistry ( resloc , RTest . class , null , 0 , 255 , false , null , null , null ) ; <nl> + PersistentRegistryManager . createRegistry ( PersistentRegistryManager . BLOCKS , Block . class , null , 0 , 255 , false , null , null , null ) ; <nl> + PersistentRegistryManager . createRegistry ( PersistentRegistryManager . ITEMS , Item . class , null , 0 , 255 , false , null , null , null ) ; <nl> + r1 = new RTest ( " test1 " ) ; <nl> + r2 = new RTest ( " test2 " ) ; <nl> + r3 = new RTest ( " test3 " ) ; <nl> + r4 = new RTest ( " test4 " ) ; <nl> + r5 = new RTest ( " test5 " ) ; <nl> + r6 = new RTest ( " test6 " ) ; <nl> + ss = new PersistentRegistryManager . GameDataSnapshot ( ) ; <nl> + ss . entries . put ( PersistentRegistryManager . BLOCKS , new PersistentRegistryManager . GameDataSnapshot . Entry ( ) ) ; <nl> + ss . entries . put ( PersistentRegistryManager . ITEMS , new PersistentRegistryManager . GameDataSnapshot . Entry ( ) ) ; <nl> + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r1 ) ; <nl> + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r2 ) ; <nl> + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r3 ) ; <nl> + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r4 ) ; <nl> + ss . entries . put ( resloc , new PersistentRegistryManager . GameDataSnapshot . Entry ( PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) ) ) ; <nl> + PersistentRegistryManager . PersistentRegistry . ACTIVE . clean ( ) ; <nl> + PersistentRegistryManager . PersistentRegistry . FROZEN . clean ( ) ; <nl> + registry = PersistentRegistryManager . createRegistry ( resloc , RTest . class , null , 0 , 255 , false , null , null , null ) ; <nl> + PersistentRegistryManager . createRegistry ( PersistentRegistryManager . BLOCKS , Block . class , null , 0 , 255 , false , null , null , null ) ; <nl> + PersistentRegistryManager . createRegistry ( PersistentRegistryManager . ITEMS , Item . class , null , 0 , 255 , false , null , null , null ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testFreezeCycle ( ) <nl> + { <nl> + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r6 ) ; <nl> + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r5 ) ; <nl> + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r4 ) ; <nl> + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r3 ) ; <nl> + FMLControlledNamespacedRegistry < RTest > r = ( FMLControlledNamespacedRegistry ) PersistentRegistryManager . findRegistry ( r3 ) ; <nl> + int r3id = r . getId ( r3 ) ; <nl> + PersistentRegistryManager . freezeData ( ) ; <nl> + RTest q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Active object is the same " , r3 , q1 ) ; <nl> + PersistentRegistryManager . injectSnapshot ( ss , false , false ) ; <nl> + assertNotEquals ( " IDs don ' t match " , r3id , r . getId ( r3 ) ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Active object is the same " , r3 , q1 ) ; <nl> + PersistentRegistryManager . revertToFrozen ( ) ; <nl> + assertEquals ( " IDs match " , r3id , r . getId ( r3 ) ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Active object is the same " , r3 , q1 ) ; <nl> + PersistentRegistryManager . injectSnapshot ( ss , true , true ) ; <nl> + assertNotEquals ( " IDs don ' t match " , r3id , r . getId ( r3 ) ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Active object is the same " , r3 , q1 ) ; <nl> + PersistentRegistryManager . revertToFrozen ( ) ; <nl> + assertEquals ( " IDs match " , r3id , r . getId ( r3 ) ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; <nl> + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; <nl> + assertEquals ( " Active object is the same " , r3 , q1 ) ; <nl> + } <nl> + } <nl> diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / VanillaRegistryTests . java b / src / test / java / net / minecraftforge / fml / common / registry / VanillaRegistryTests . java <nl> new file mode 100644 <nl> index 0000000 . . c2edccf <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / fml / common / registry / VanillaRegistryTests . java <nl> @ @ - 0 , 0 + 1 , 99 @ @ <nl> + package net . minecraftforge . fml . common . registry ; <nl> + <nl> + import net . minecraft . block . Block ; <nl> + import net . minecraft . block . material . Material ; <nl> + import net . minecraft . init . Blocks ; <nl> + import net . minecraft . init . Bootstrap ; <nl> + import net . minecraft . init . Items ; <nl> + import net . minecraft . item . Item ; <nl> + import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . fml . common . Loader ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import static org . junit . Assert . * ; <nl> + <nl> + / * * <nl> + * Vanilla registry tests <nl> + * / <nl> + @ RunWith ( ForgeTestRunner . class ) <nl> + public class VanillaRegistryTests <nl> + { <nl> + @ BeforeClass <nl> + public static void setupHarness ( ) <nl> + { <nl> + Loader . instance ( ) ; <nl> + Bootstrap . register ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSetup ( ) <nl> + { <nl> + / / All the blocks loaded <nl> + assertEquals ( " We have all the blocks via GameData " , 219 , Block . REGISTRY . getKeys ( ) . size ( ) ) ; <nl> + <nl> + / / All the items loaded <nl> + assertEquals ( " We have all the items via GameData " , 371 , Item . REGISTRY . getKeys ( ) . size ( ) ) ; <nl> + <nl> + / / Our lookups find the same stuff vanilla sees <nl> + final IForgeRegistry < Block > blocks = PersistentRegistryManager . findRegistry ( Blocks . AIR ) ; <nl> + assertEquals ( " We have the right blocks for a block " , blocks , Block . REGISTRY ) ; <nl> + <nl> + / / We can look up stuff through our APIs <nl> + Block bl = blocks . getValue ( new ResourceLocation ( " minecraft : air " ) ) ; <nl> + assertEquals ( " We got air when we asked for it " , Blocks . AIR , bl ) ; <nl> + <nl> + / / Default values work <nl> + Block blch = blocks . getValue ( new ResourceLocation ( " minecraft : cheese " ) ) ; <nl> + assertEquals ( " We got air when we asked for cheese " , Blocks . AIR , blch ) ; <nl> + <nl> + / / Our lookups find the same stuff vanilla sees <nl> + final IForgeRegistry < Item > items = PersistentRegistryManager . findRegistry ( Items . BED ) ; <nl> + assertEquals ( " We have the right items for an item " , items , Item . REGISTRY ) ; <nl> + <nl> + / / We can look up stuff through our APIs <nl> + Item it = items . getValue ( new ResourceLocation ( " minecraft : bed " ) ) ; <nl> + assertEquals ( " We got a bed item when we asked for it " , Items . BED , it ) ; <nl> + <nl> + / / We find nothing for a non - defaulted registry <nl> + Item none = items . getValue ( new ResourceLocation ( " minecraft : cheese " ) ) ; <nl> + assertEquals ( " We got nothing ( items ) when we asked for cheese " , null , none ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRegistration ( ) <nl> + { <nl> + Block myBlock = GameRegistry . register ( new Block ( Material . CAKE ) { } , new ResourceLocation ( " minecraft : testy " ) ) ; <nl> + assertNotNull ( " Registered my block " , myBlock ) ; <nl> + <nl> + / / Our lookups find the same stuff vanilla sees <nl> + final IForgeRegistry < Block > blocks = PersistentRegistryManager . findRegistry ( myBlock ) ; <nl> + assertEquals ( " We have the right blocks for a block " , blocks , Block . REGISTRY ) ; <nl> + <nl> + Block found = blocks . getValue ( new ResourceLocation ( " minecraft : testy " ) ) ; <nl> + assertEquals ( " Registry lookup works " , myBlock , found ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRegistryStates ( ) <nl> + { <nl> + final FMLControlledNamespacedRegistry < Block > blockVanilla = PersistentRegistryManager . PersistentRegistry . VANILLA . getRegistry ( Block . class ) ; <nl> + final FMLControlledNamespacedRegistry < Block > blockActive = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( Block . class ) ; <nl> + <nl> + assertNotEquals ( " Registry states are distinct " , blockActive , blockVanilla ) ; <nl> + <nl> + final Block stoneActive = blockActive . getValue ( new ResourceLocation ( " minecraft : stone " ) ) ; <nl> + final Block stoneVanilla = blockVanilla . getValue ( new ResourceLocation ( " minecraft : stone " ) ) ; <nl> + <nl> + assertEquals ( " Stone from active and vanilla are the same " , stoneActive , stoneVanilla ) ; <nl> + <nl> + int activeId = blockActive . getId ( stoneActive ) ; <nl> + int vanillaId = blockVanilla . getId ( stoneVanilla ) ; <nl> + <nl> + assertEquals ( " Stone has correct id " , 1 , activeId ) ; <nl> + assertEquals ( " Stone has correct id " , 1 , vanillaId ) ; <nl> + } <nl> + <nl> + <nl> + }
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java b / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java <nl> new file mode 100644 <nl> index 0000000 . . 6e0fdd0 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java <nl> @ @ - 0 , 0 + 1 , 192 @ @ <nl> + package cpw . mods . fml . common . asm . transformers ; <nl> + <nl> + import static org . objectweb . asm . ClassWriter . COMPUTE _ FRAMES ; <nl> + import static org . objectweb . asm . ClassWriter . COMPUTE _ MAXS ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ STATIC ; <nl> + import static org . objectweb . asm . Opcodes . ALOAD ; <nl> + import static org . objectweb . asm . Opcodes . ARETURN ; <nl> + import static org . objectweb . asm . Opcodes . ASM4 ; <nl> + import static org . objectweb . asm . Opcodes . DUP ; <nl> + import static org . objectweb . asm . Opcodes . F _ SAME ; <nl> + import static org . objectweb . asm . Opcodes . GETSTATIC ; <nl> + import static org . objectweb . asm . Opcodes . IFNULL ; <nl> + import static org . objectweb . asm . Opcodes . INVOKESPECIAL ; <nl> + import static org . objectweb . asm . Opcodes . NEW ; <nl> + import static org . objectweb . asm . Opcodes . PUTSTATIC ; <nl> + import static org . objectweb . asm . Opcodes . RETURN ; <nl> + import static org . objectweb . asm . Type . VOID _ TYPE ; <nl> + import static org . objectweb . asm . Type . getMethodDescriptor ; <nl> + <nl> + import java . util . List ; <nl> + <nl> + import net . minecraft . launchwrapper . IClassTransformer ; <nl> + <nl> + import org . objectweb . asm . ClassReader ; <nl> + import org . objectweb . asm . ClassWriter ; <nl> + import org . objectweb . asm . Type ; <nl> + import org . objectweb . asm . tree . ClassNode ; <nl> + import org . objectweb . asm . tree . FieldInsnNode ; <nl> + import org . objectweb . asm . tree . FieldNode ; <nl> + import org . objectweb . asm . tree . FrameNode ; <nl> + import org . objectweb . asm . tree . InsnNode ; <nl> + import org . objectweb . asm . tree . JumpInsnNode ; <nl> + import org . objectweb . asm . tree . LabelNode ; <nl> + import org . objectweb . asm . tree . MethodInsnNode ; <nl> + import org . objectweb . asm . tree . MethodNode ; <nl> + import org . objectweb . asm . tree . TypeInsnNode ; <nl> + import org . objectweb . asm . tree . VarInsnNode ; <nl> + <nl> + import cpw . mods . fml . common . eventhandler . Event ; <nl> + <nl> + public class EventSubscriptionTransformer implements IClassTransformer <nl> + { <nl> + public EventSubscriptionTransformer ( ) <nl> + { <nl> + } <nl> + <nl> + @ Override <nl> + public byte [ ] transform ( String name , String transformedName , byte [ ] bytes ) <nl> + { <nl> + if ( bytes = = null | | name . equals ( " cpw . mods . fml . common . eventhandler . Event " ) | | name . startsWith ( " net . minecraft . " ) | | name . indexOf ( ' . ' ) = = - 1 ) <nl> + { <nl> + return bytes ; <nl> + } <nl> + ClassReader cr = new ClassReader ( bytes ) ; <nl> + ClassNode classNode = new ClassNode ( ) ; <nl> + cr . accept ( classNode , 0 ) ; <nl> + <nl> + try <nl> + { <nl> + if ( buildEvents ( classNode ) ) <nl> + { <nl> + ClassWriter cw = new ClassWriter ( COMPUTE _ MAXS | COMPUTE _ FRAMES ) ; <nl> + classNode . accept ( cw ) ; <nl> + return cw . toByteArray ( ) ; <nl> + } <nl> + return bytes ; <nl> + } <nl> + catch ( ClassNotFoundException ex ) <nl> + { <nl> + / / Discard silently - it ' s just noise <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + <nl> + return bytes ; <nl> + } <nl> + <nl> + private boolean buildEvents ( ClassNode classNode ) throws Exception <nl> + { <nl> + Class < ? > parent = this . getClass ( ) . getClassLoader ( ) . loadClass ( classNode . superName . replace ( ' / ' , ' . ' ) ) ; <nl> + if ( ! Event . class . isAssignableFrom ( parent ) ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + boolean hasSetup = false ; <nl> + boolean hasGetListenerList = false ; <nl> + boolean hasDefaultCtr = false ; <nl> + <nl> + Class < ? > listenerListClazz = Class . forName ( " cpw . mods . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; <nl> + Type tList = Type . getType ( listenerListClazz ) ; <nl> + <nl> + for ( MethodNode method : ( List < MethodNode > ) classNode . methods ) <nl> + { <nl> + if ( method . name . equals ( " setup " ) & & <nl> + method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) & & <nl> + ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) <nl> + { <nl> + hasSetup = true ; <nl> + } <nl> + if ( method . name . equals ( " getListenerList " ) & & <nl> + method . desc . equals ( Type . getMethodDescriptor ( tList ) ) & & <nl> + ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) <nl> + { <nl> + hasGetListenerList = true ; <nl> + } <nl> + if ( method . name . equals ( " < init > " ) & & <nl> + method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) ) <nl> + { <nl> + hasDefaultCtr = true ; <nl> + } <nl> + } <nl> + <nl> + if ( hasSetup ) <nl> + { <nl> + if ( ! hasGetListenerList ) <nl> + { <nl> + throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; <nl> + } <nl> + else <nl> + { <nl> + return false ; <nl> + } <nl> + } <nl> + <nl> + Type tSuper = Type . getType ( classNode . superName ) ; <nl> + <nl> + / / Add private static ListenerList LISTENER _ LIST <nl> + classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , tList . getDescriptor ( ) , null , null ) ) ; <nl> + <nl> + / * Add : <nl> + * public < init > ( ) <nl> + * { <nl> + * super ( ) ; <nl> + * } <nl> + * / <nl> + MethodNode method = new MethodNode ( ASM4 , ACC _ PUBLIC , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; <nl> + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE ) ) ) ; <nl> + method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> + if ( ! hasDefaultCtr ) <nl> + { <nl> + classNode . methods . add ( method ) ; <nl> + } <nl> + <nl> + / * Add : <nl> + * protected void setup ( ) <nl> + * { <nl> + * super . setup ( ) ; <nl> + * if ( LISTENER _ LIST ! = NULL ) <nl> + * { <nl> + * return ; <nl> + * } <nl> + * LISTENER _ LIST = new ListenerList ( super . getListenerList ( ) ) ; <nl> + * } <nl> + * / <nl> + method = new MethodNode ( ASM4 , ACC _ PROTECTED , " setup " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; <nl> + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , getMethodDescriptor ( VOID _ TYPE ) ) ) ; <nl> + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + LabelNode initLisitener = new LabelNode ( ) ; <nl> + method . instructions . add ( new JumpInsnNode ( IFNULL , initLisitener ) ) ; <nl> + method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> + method . instructions . add ( initLisitener ) ; <nl> + method . instructions . add ( new FrameNode ( F _ SAME , 0 , null , 0 , null ) ) ; <nl> + method . instructions . add ( new TypeInsnNode ( NEW , tList . getInternalName ( ) ) ) ; <nl> + method . instructions . add ( new InsnNode ( DUP ) ) ; <nl> + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , getMethodDescriptor ( tList ) ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tList . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE , tList ) ) ) ; <nl> + method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> + classNode . methods . add ( method ) ; <nl> + <nl> + / * Add : <nl> + * public ListenerList getListenerList ( ) <nl> + * { <nl> + * return this . LISTENER _ LIST ; <nl> + * } <nl> + * / <nl> + method = new MethodNode ( ASM4 , ACC _ PUBLIC , " getListenerList " , getMethodDescriptor ( tList ) , null , null ) ; <nl> + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + method . instructions . add ( new InsnNode ( ARETURN ) ) ; <nl> + classNode . methods . add ( method ) ; <nl> + return true ; <nl> + } <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java <nl> new file mode 100644 <nl> index 0000000 . . 02bb037 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java <nl> @ @ - 0 , 0 + 1 , 130 @ @ <nl> + package cpw . mods . fml . common . eventhandler ; <nl> + <nl> + import static org . objectweb . asm . Opcodes . * ; <nl> + <nl> + import java . lang . reflect . Method ; <nl> + import java . util . HashMap ; <nl> + <nl> + <nl> + import org . objectweb . asm . ClassWriter ; <nl> + import org . objectweb . asm . MethodVisitor ; <nl> + import org . objectweb . asm . Type ; <nl> + <nl> + import com . google . common . collect . Maps ; <nl> + <nl> + <nl> + public class ASMEventHandler implements IEventListener <nl> + { <nl> + private static int IDs = 0 ; <nl> + private static final String HANDLER _ DESC = Type . getInternalName ( IEventListener . class ) ; <nl> + private static final String HANDLER _ FUNC _ DESC = Type . getMethodDescriptor ( IEventListener . class . getDeclaredMethods ( ) [ 0 ] ) ; <nl> + private static final ASMClassLoader LOADER = new ASMClassLoader ( ) ; <nl> + private static final HashMap < Method , Class < ? > > cache = Maps . newHashMap ( ) ; <nl> + <nl> + private final IEventListener handler ; <nl> + private final SubscribeEvent subInfo ; <nl> + public ASMEventHandler ( Object target , Method method ) throws Exception <nl> + { <nl> + handler = ( IEventListener ) createWrapper ( method ) . getConstructor ( Object . class ) . newInstance ( target ) ; <nl> + subInfo = method . getAnnotation ( SubscribeEvent . class ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void invoke ( Event event ) <nl> + { <nl> + if ( handler ! = null ) <nl> + { <nl> + if ( ! event . isCancelable ( ) | | ! event . isCanceled ( ) | | subInfo . receiveCanceled ( ) ) <nl> + { <nl> + handler . invoke ( event ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public EventPriority getPriority ( ) <nl> + { <nl> + return subInfo . priority ( ) ; <nl> + } <nl> + <nl> + public Class < ? > createWrapper ( Method callback ) <nl> + { <nl> + if ( cache . containsKey ( callback ) ) <nl> + { <nl> + return cache . get ( callback ) ; <nl> + } <nl> + <nl> + ClassWriter cw = new ClassWriter ( 0 ) ; <nl> + MethodVisitor mv ; <nl> + <nl> + String name = getUniqueName ( callback ) ; <nl> + String desc = name . replace ( ' . ' , ' / ' ) ; <nl> + String instType = Type . getInternalName ( callback . getDeclaringClass ( ) ) ; <nl> + String eventType = Type . getInternalName ( callback . getParameterTypes ( ) [ 0 ] ) ; <nl> + <nl> + / * <nl> + System . out . println ( " Name : " + name ) ; <nl> + System . out . println ( " Desc : " + desc ) ; <nl> + System . out . println ( " InstType : " + instType ) ; <nl> + System . out . println ( " Callback : " + callback . getName ( ) + Type . getMethodDescriptor ( callback ) ) ; <nl> + System . out . println ( " Event : " + eventType ) ; <nl> + * / <nl> + <nl> + cw . visit ( V1 _ 6 , ACC _ PUBLIC | ACC _ SUPER , desc , null , " java / lang / Object " , new String [ ] { HANDLER _ DESC } ) ; <nl> + <nl> + cw . visitSource ( " . dynamic " , null ) ; <nl> + { <nl> + cw . visitField ( ACC _ PUBLIC , " instance " , " Ljava / lang / Object ; " , null , null ) . visitEnd ( ) ; <nl> + } <nl> + { <nl> + mv = cw . visitMethod ( ACC _ PUBLIC , " < init > " , " ( Ljava / lang / Object ; ) V " , null , null ) ; <nl> + mv . visitCode ( ) ; <nl> + mv . visitVarInsn ( ALOAD , 0 ) ; <nl> + mv . visitMethodInsn ( INVOKESPECIAL , " java / lang / Object " , " < init > " , " ( ) V " ) ; <nl> + mv . visitVarInsn ( ALOAD , 0 ) ; <nl> + mv . visitVarInsn ( ALOAD , 1 ) ; <nl> + mv . visitFieldInsn ( PUTFIELD , desc , " instance " , " Ljava / lang / Object ; " ) ; <nl> + mv . visitInsn ( RETURN ) ; <nl> + mv . visitMaxs ( 2 , 2 ) ; <nl> + mv . visitEnd ( ) ; <nl> + } <nl> + { <nl> + mv = cw . visitMethod ( ACC _ PUBLIC , " invoke " , HANDLER _ FUNC _ DESC , null , null ) ; <nl> + mv . visitCode ( ) ; <nl> + mv . visitVarInsn ( ALOAD , 0 ) ; <nl> + mv . visitFieldInsn ( GETFIELD , desc , " instance " , " Ljava / lang / Object ; " ) ; <nl> + mv . visitTypeInsn ( CHECKCAST , instType ) ; <nl> + mv . visitVarInsn ( ALOAD , 1 ) ; <nl> + mv . visitTypeInsn ( CHECKCAST , eventType ) ; <nl> + mv . visitMethodInsn ( INVOKEVIRTUAL , instType , callback . getName ( ) , Type . getMethodDescriptor ( callback ) ) ; <nl> + mv . visitInsn ( RETURN ) ; <nl> + mv . visitMaxs ( 2 , 2 ) ; <nl> + mv . visitEnd ( ) ; <nl> + } <nl> + cw . visitEnd ( ) ; <nl> + Class < ? > ret = LOADER . define ( name , cw . toByteArray ( ) ) ; <nl> + cache . put ( callback , ret ) ; <nl> + return ret ; <nl> + } <nl> + <nl> + private String getUniqueName ( Method callback ) <nl> + { <nl> + return String . format ( " % s _ % d _ % s _ % s _ % s " , getClass ( ) . getName ( ) , IDs + + , <nl> + callback . getDeclaringClass ( ) . getSimpleName ( ) , <nl> + callback . getName ( ) , <nl> + callback . getParameterTypes ( ) [ 0 ] . getSimpleName ( ) ) ; <nl> + } <nl> + <nl> + private static class ASMClassLoader extends ClassLoader <nl> + { <nl> + private ASMClassLoader ( ) <nl> + { <nl> + super ( ASMClassLoader . class . getClassLoader ( ) ) ; <nl> + } <nl> + <nl> + public Class < ? > define ( String name , byte [ ] data ) <nl> + { <nl> + return defineClass ( name , data , 0 , data . length ) ; <nl> + } <nl> + } <nl> + <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / Cancelable . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Cancelable . java <nl> new file mode 100644 <nl> index 0000000 . . 4b73896 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Cancelable . java <nl> @ @ - 0 , 0 + 1 , 11 @ @ <nl> + package cpw . mods . fml . common . eventhandler ; <nl> + <nl> + import static java . lang . annotation . ElementType . TYPE ; <nl> + import static java . lang . annotation . RetentionPolicy . RUNTIME ; <nl> + <nl> + import java . lang . annotation . Retention ; <nl> + import java . lang . annotation . Target ; <nl> + <nl> + @ Retention ( value = RUNTIME ) <nl> + @ Target ( value = TYPE ) <nl> + public @ interface Cancelable { } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java <nl> new file mode 100644 <nl> index 0000000 . . d9c31ee <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java <nl> @ @ - 0 , 0 + 1 , 156 @ @ <nl> + package cpw . mods . fml . common . eventhandler ; <nl> + <nl> + import static java . lang . annotation . ElementType . TYPE ; <nl> + import static java . lang . annotation . RetentionPolicy . RUNTIME ; <nl> + <nl> + import java . lang . annotation . Annotation ; <nl> + import java . lang . annotation . Retention ; <nl> + import java . lang . annotation . Target ; <nl> + import java . util . Map ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> + <nl> + <nl> + / * * <nl> + * Base Event class that all other events are derived from <nl> + * / <nl> + public class Event <nl> + { <nl> + @ Retention ( value = RUNTIME ) <nl> + @ Target ( value = TYPE ) <nl> + public @ interface HasResult { } <nl> + <nl> + public enum Result <nl> + { <nl> + DENY , <nl> + DEFAULT , <nl> + ALLOW <nl> + } <nl> + <nl> + private boolean isCanceled = false ; <nl> + private final boolean isCancelable ; <nl> + private Result result = Result . DEFAULT ; <nl> + private final boolean hasResult ; <nl> + private static ListenerList listeners = new ListenerList ( ) ; <nl> + <nl> + private static final Map < Class < ? > , Map < Class < ? > , Boolean > > annotationMap = new ConcurrentHashMap < Class < ? > , Map < Class < ? > , Boolean > > ( ) ; <nl> + <nl> + public Event ( ) <nl> + { <nl> + setup ( ) ; <nl> + isCancelable = hasAnnotation ( Cancelable . class ) ; <nl> + hasResult = hasAnnotation ( HasResult . class ) ; <nl> + } <nl> + <nl> + private boolean hasAnnotation ( Class < ? extends Annotation > annotation ) <nl> + { <nl> + Class < ? > me = this . getClass ( ) ; <nl> + Map < Class < ? > , Boolean > list = annotationMap . get ( me ) ; <nl> + if ( list = = null ) <nl> + { <nl> + list = new ConcurrentHashMap < Class < ? > , Boolean > ( ) ; <nl> + annotationMap . put ( me , list ) ; <nl> + } <nl> + <nl> + Boolean cached = list . get ( annotation ) ; <nl> + if ( cached ! = null ) <nl> + { <nl> + return cached ; <nl> + } <nl> + <nl> + Class < ? > cls = me ; <nl> + while ( cls ! = Event . class ) <nl> + { <nl> + if ( cls . isAnnotationPresent ( annotation ) ) <nl> + { <nl> + list . put ( annotation , true ) ; <nl> + return true ; <nl> + } <nl> + cls = cls . getSuperclass ( ) ; <nl> + } <nl> + <nl> + list . put ( annotation , false ) ; <nl> + return false ; <nl> + } <nl> + <nl> + / * * <nl> + * Determine if this function is cancelable at all . <nl> + * @ return If access to setCanceled should be allowed <nl> + * / <nl> + public boolean isCancelable ( ) <nl> + { <nl> + return isCancelable ; <nl> + } <nl> + <nl> + / * * <nl> + * Determine if this event is canceled and should stop executing . <nl> + * @ return The current canceled state <nl> + * / <nl> + public boolean isCanceled ( ) <nl> + { <nl> + return isCanceled ; <nl> + } <nl> + <nl> + / * * <nl> + * Sets the state of this event , not all events are cancelable , and any attempt to <nl> + * cancel a event that can ' t be will result in a IllegalArgumentException . <nl> + * <nl> + * The functionality of setting the canceled state is defined on a per - event bases . <nl> + * <nl> + * @ param cancel The new canceled value <nl> + * / <nl> + public void setCanceled ( boolean cancel ) <nl> + { <nl> + if ( ! isCancelable ( ) ) <nl> + { <nl> + throw new IllegalArgumentException ( " Attempted to cancel a uncancelable event " ) ; <nl> + } <nl> + isCanceled = cancel ; <nl> + } <nl> + <nl> + / * * <nl> + * Determines if this event expects a significant result value . <nl> + * / <nl> + public boolean hasResult ( ) <nl> + { <nl> + return hasResult ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the value set as the result of this event <nl> + * / <nl> + public Result getResult ( ) <nl> + { <nl> + return result ; <nl> + } <nl> + <nl> + / * * <nl> + * Sets the result value for this event , not all events can have a result set , and any attempt to <nl> + * set a result for a event that isn ' t expecting it will result in a IllegalArgumentException . <nl> + * <nl> + * The functionality of setting the result is defined on a per - event bases . <nl> + * <nl> + * @ param value The new result <nl> + * / <nl> + public void setResult ( Result value ) <nl> + { <nl> + result = value ; <nl> + } <nl> + / * * <nl> + * Called by the base constructor , this is used by ASM generated <nl> + * event classes to setup various functionality such as the listenerlist . <nl> + * / <nl> + protected void setup ( ) <nl> + { <nl> + } <nl> + <nl> + / * * <nl> + * Returns a ListenerList object that contains all listeners <nl> + * that are registered to this event . <nl> + * <nl> + * @ return Listener List <nl> + * / <nl> + public ListenerList getListenerList ( ) <nl> + { <nl> + return listeners ; <nl> + } <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java <nl> new file mode 100644 <nl> index 0000000 . . aa6640d <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java <nl> @ @ - 0 , 0 + 1 , 112 @ @ <nl> + package cpw . mods . fml . common . eventhandler ; <nl> + <nl> + import java . lang . reflect . Constructor ; <nl> + import java . lang . reflect . Method ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Set ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> + <nl> + <nl> + <nl> + import com . google . common . reflect . TypeToken ; <nl> + <nl> + public class EventBus <nl> + { <nl> + private static int maxID = 0 ; <nl> + <nl> + private ConcurrentHashMap < Object , ArrayList < IEventListener > > listeners = new ConcurrentHashMap < Object , ArrayList < IEventListener > > ( ) ; <nl> + private final int busID = maxID + + ; <nl> + <nl> + public EventBus ( ) <nl> + { <nl> + ListenerList . resize ( busID + 1 ) ; <nl> + } <nl> + <nl> + public void register ( Object target ) <nl> + { <nl> + if ( listeners . containsKey ( target ) ) <nl> + { <nl> + return ; <nl> + } <nl> + <nl> + Set < ? extends Class < ? > > supers = TypeToken . of ( target . getClass ( ) ) . getTypes ( ) . rawTypes ( ) ; <nl> + for ( Method method : target . getClass ( ) . getMethods ( ) ) <nl> + { <nl> + for ( Class < ? > cls : supers ) <nl> + { <nl> + try <nl> + { <nl> + Method real = cls . getDeclaredMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; <nl> + if ( real . isAnnotationPresent ( SubscribeEvent . class ) ) <nl> + { <nl> + Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; <nl> + if ( parameterTypes . length ! = 1 ) <nl> + { <nl> + throw new IllegalArgumentException ( <nl> + " Method " + method + " has @ SubscribeEvent annotation , but requires " + parameterTypes . length + <nl> + " arguments . Event handler methods must require a single argument . " <nl> + ) ; <nl> + } <nl> + <nl> + Class < ? > eventType = parameterTypes [ 0 ] ; <nl> + <nl> + if ( ! Event . class . isAssignableFrom ( eventType ) ) <nl> + { <nl> + throw new IllegalArgumentException ( " Method " + method + " has @ SubscribeEvent annotation , but takes a argument that is not a Event " + eventType ) ; <nl> + } <nl> + <nl> + register ( eventType , target , method ) ; <nl> + break ; <nl> + } <nl> + } <nl> + catch ( NoSuchMethodException e ) <nl> + { <nl> + ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void register ( Class < ? > eventType , Object target , Method method ) <nl> + { <nl> + try <nl> + { <nl> + Constructor < ? > ctr = eventType . getConstructor ( ) ; <nl> + ctr . setAccessible ( true ) ; <nl> + Event event = ( Event ) ctr . newInstance ( ) ; <nl> + ASMEventHandler listener = new ASMEventHandler ( target , method ) ; <nl> + event . getListenerList ( ) . register ( busID , listener . getPriority ( ) , listener ) ; <nl> + <nl> + ArrayList < IEventListener > others = listeners . get ( target ) ; <nl> + if ( others = = null ) <nl> + { <nl> + others = new ArrayList < IEventListener > ( ) ; <nl> + listeners . put ( target , others ) ; <nl> + } <nl> + others . add ( listener ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + public void unregister ( Object object ) <nl> + { <nl> + ArrayList < IEventListener > list = listeners . remove ( object ) ; <nl> + for ( IEventListener listener : list ) <nl> + { <nl> + ListenerList . unregisterAll ( busID , listener ) ; <nl> + } <nl> + } <nl> + <nl> + public boolean post ( Event event ) <nl> + { <nl> + IEventListener [ ] listeners = event . getListenerList ( ) . getListeners ( busID ) ; <nl> + for ( IEventListener listener : listeners ) <nl> + { <nl> + listener . invoke ( event ) ; <nl> + } <nl> + return ( event . isCancelable ( ) ? event . isCanceled ( ) : false ) ; <nl> + } <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventPriority . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventPriority . java <nl> new file mode 100644 <nl> index 0000000 . . 6594db8 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventPriority . java <nl> @ @ - 0 , 0 + 1 , 16 @ @ <nl> + package cpw . mods . fml . common . eventhandler ; <nl> + <nl> + public enum EventPriority <nl> + { <nl> + / * Priority of event listeners , listeners will be sorted with respect to this priority level . <nl> + * <nl> + * Note : <nl> + * Due to using a ArrayList in the ListenerList , <nl> + * these need to stay in a contiguous index starting at 0 . { Default ordinal } <nl> + * / <nl> + HIGHEST , / / First to execute <nl> + HIGH , <nl> + NORMAL , <nl> + LOW , <nl> + LOWEST / / Last to execute <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / IEventListener . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / IEventListener . java <nl> new file mode 100644 <nl> index 0000000 . . f5eefd4 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / IEventListener . java <nl> @ @ - 0 , 0 + 1 , 8 @ @ <nl> + package cpw . mods . fml . common . eventhandler ; <nl> + <nl> + <nl> + <nl> + public interface IEventListener <nl> + { <nl> + public void invoke ( Event event ) ; <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / ListenerList . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ListenerList . java <nl> new file mode 100644 <nl> index 0000000 . . ca9f666 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ListenerList . java <nl> @ @ - 0 , 0 + 1 , 219 @ @ <nl> + package cpw . mods . fml . common . eventhandler ; <nl> + <nl> + import java . util . * ; <nl> + <nl> + <nl> + public class ListenerList <nl> + { <nl> + private static ArrayList < ListenerList > allLists = new ArrayList < ListenerList > ( ) ; <nl> + private static int maxSize = 0 ; <nl> + <nl> + private ListenerList parent ; <nl> + private ListenerListInst [ ] lists = new ListenerListInst [ 0 ] ; <nl> + <nl> + public ListenerList ( ) <nl> + { <nl> + allLists . add ( this ) ; <nl> + resizeLists ( maxSize ) ; <nl> + } <nl> + <nl> + public ListenerList ( ListenerList parent ) <nl> + { <nl> + allLists . add ( this ) ; <nl> + this . parent = parent ; <nl> + resizeLists ( maxSize ) ; <nl> + } <nl> + <nl> + public static void resize ( int max ) <nl> + { <nl> + if ( max < = maxSize ) <nl> + { <nl> + return ; <nl> + } <nl> + for ( ListenerList list : allLists ) <nl> + { <nl> + list . resizeLists ( max ) ; <nl> + } <nl> + maxSize = max ; <nl> + } <nl> + <nl> + public void resizeLists ( int max ) <nl> + { <nl> + if ( parent ! = null ) <nl> + { <nl> + parent . resizeLists ( max ) ; <nl> + } <nl> + <nl> + if ( lists . length > = max ) <nl> + { <nl> + return ; <nl> + } <nl> + <nl> + ListenerListInst [ ] newList = new ListenerListInst [ max ] ; <nl> + int x = 0 ; <nl> + for ( ; x < lists . length ; x + + ) <nl> + { <nl> + newList [ x ] = lists [ x ] ; <nl> + } <nl> + for ( ; x < max ; x + + ) <nl> + { <nl> + if ( parent ! = null ) <nl> + { <nl> + newList [ x ] = new ListenerListInst ( parent . getInstance ( x ) ) ; <nl> + } <nl> + else <nl> + { <nl> + newList [ x ] = new ListenerListInst ( ) ; <nl> + } <nl> + } <nl> + lists = newList ; <nl> + } <nl> + <nl> + public static void clearBusID ( int id ) <nl> + { <nl> + for ( ListenerList list : allLists ) <nl> + { <nl> + list . lists [ id ] . dispose ( ) ; <nl> + } <nl> + } <nl> + <nl> + protected ListenerListInst getInstance ( int id ) <nl> + { <nl> + return lists [ id ] ; <nl> + } <nl> + <nl> + public IEventListener [ ] getListeners ( int id ) <nl> + { <nl> + return lists [ id ] . getListeners ( ) ; <nl> + } <nl> + <nl> + public void register ( int id , EventPriority priority , IEventListener listener ) <nl> + { <nl> + lists [ id ] . register ( priority , listener ) ; <nl> + } <nl> + <nl> + public void unregister ( int id , IEventListener listener ) <nl> + { <nl> + lists [ id ] . unregister ( listener ) ; <nl> + } <nl> + <nl> + public static void unregisterAll ( int id , IEventListener listener ) <nl> + { <nl> + for ( ListenerList list : allLists ) <nl> + { <nl> + list . unregister ( id , listener ) ; <nl> + } <nl> + } <nl> + <nl> + private class ListenerListInst <nl> + { <nl> + private boolean rebuild = true ; <nl> + private IEventListener [ ] listeners ; <nl> + private ArrayList < ArrayList < IEventListener > > priorities ; <nl> + private ListenerListInst parent ; <nl> + <nl> + private ListenerListInst ( ) <nl> + { <nl> + int count = EventPriority . values ( ) . length ; <nl> + priorities = new ArrayList < ArrayList < IEventListener > > ( count ) ; <nl> + <nl> + for ( int x = 0 ; x < count ; x + + ) <nl> + { <nl> + priorities . add ( new ArrayList < IEventListener > ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + public void dispose ( ) <nl> + { <nl> + for ( ArrayList < IEventListener > listeners : priorities ) <nl> + { <nl> + listeners . clear ( ) ; <nl> + } <nl> + priorities . clear ( ) ; <nl> + parent = null ; <nl> + listeners = null ; <nl> + } <nl> + <nl> + private ListenerListInst ( ListenerListInst parent ) <nl> + { <nl> + this ( ) ; <nl> + this . parent = parent ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns a ArrayList containing all listeners for this event , <nl> + * and all parent events for the specified priority . <nl> + * <nl> + * The list is returned with the listeners for the children events first . <nl> + * <nl> + * @ param priority The Priority to get <nl> + * @ return ArrayList containing listeners <nl> + * / <nl> + public ArrayList < IEventListener > getListeners ( EventPriority priority ) <nl> + { <nl> + ArrayList < IEventListener > ret = new ArrayList < IEventListener > ( priorities . get ( priority . ordinal ( ) ) ) ; <nl> + if ( parent ! = null ) <nl> + { <nl> + ret . addAll ( parent . getListeners ( priority ) ) ; <nl> + } <nl> + return ret ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns a full list of all listeners for all priority levels . <nl> + * Including all parent listeners . <nl> + * <nl> + * List is returned in proper priority order . <nl> + * <nl> + * Automatically rebuilds the internal Array cache if its information is out of date . <nl> + * <nl> + * @ return Array containing listeners <nl> + * / <nl> + public IEventListener [ ] getListeners ( ) <nl> + { <nl> + if ( shouldRebuild ( ) ) buildCache ( ) ; <nl> + return listeners ; <nl> + } <nl> + <nl> + protected boolean shouldRebuild ( ) <nl> + { <nl> + return rebuild | | ( parent ! = null & & parent . shouldRebuild ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Rebuild the local Array of listeners , returns early if there is no work to do . <nl> + * / <nl> + private void buildCache ( ) <nl> + { <nl> + if ( parent ! = null & & parent . shouldRebuild ( ) ) <nl> + { <nl> + parent . buildCache ( ) ; <nl> + } <nl> + <nl> + ArrayList < IEventListener > ret = new ArrayList < IEventListener > ( ) ; <nl> + for ( EventPriority value : EventPriority . values ( ) ) <nl> + { <nl> + ret . addAll ( getListeners ( value ) ) ; <nl> + } <nl> + listeners = ret . toArray ( new IEventListener [ ret . size ( ) ] ) ; <nl> + rebuild = false ; <nl> + } <nl> + <nl> + public void register ( EventPriority priority , IEventListener listener ) <nl> + { <nl> + priorities . get ( priority . ordinal ( ) ) . add ( listener ) ; <nl> + rebuild = true ; <nl> + } <nl> + <nl> + public void unregister ( IEventListener listener ) <nl> + { <nl> + for ( ArrayList < IEventListener > list : priorities ) <nl> + { <nl> + if ( list . remove ( listener ) ) <nl> + { <nl> + rebuild = true ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / SubscribeEvent . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / SubscribeEvent . java <nl> new file mode 100644 <nl> index 0000000 . . 6effc42 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / SubscribeEvent . java <nl> @ @ - 0 , 0 + 1 , 15 @ @ <nl> + package cpw . mods . fml . common . eventhandler ; <nl> + <nl> + import java . lang . annotation . Retention ; <nl> + import java . lang . annotation . Target ; <nl> + <nl> + import static java . lang . annotation . RetentionPolicy . * ; <nl> + import static java . lang . annotation . ElementType . * ; <nl> + <nl> + @ Retention ( value = RUNTIME ) <nl> + @ Target ( value = METHOD ) <nl> + public @ interface SubscribeEvent <nl> + { <nl> + public EventPriority priority ( ) default EventPriority . NORMAL ; <nl> + public boolean receiveCanceled ( ) default false ; <nl> + }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / Loader . java b / src / main / java / net / minecraftforge / fml / common / Loader . java 
 index b6cd20c . . 982c389 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / Loader . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / Loader . java 
 @ @ - 204 , 7 + 204 , 7 @ @ public class Loader 
 } 
 
 modClassLoader = new ModClassLoader ( getClass ( ) . getClassLoader ( ) ) ; 
 - if ( ! mccversion . equals ( MC _ VERSION ) ) 
 + if ( mccversion ! = null & & ! mccversion . equals ( MC _ VERSION ) ) 
 { 
 FMLLog . severe ( " This version of FML is built for Minecraft % s , we have detected Minecraft % s in your minecraft jar file " , mccversion , MC _ VERSION ) ; 
 throw new LoaderException ( String . format ( " This version of FML is built for Minecraft % s , we have detected Minecraft % s in your minecraft jar file " , mccversion , MC _ VERSION ) ) ; 
 @ @ - 1023 , 7 + 1023 , 10 @ @ public class Loader 
 
 public void fireRemapEvent ( Map < ResourceLocation , Integer [ ] > remapBlocks , Map < ResourceLocation , Integer [ ] > remapItems , boolean isFreezing ) 
 { 
 - modController . propogateStateMessage ( new FMLModIdMappingEvent ( remapBlocks , remapItems , isFreezing ) ) ; 
 + if ( modController ! = null ) 
 + { 
 + modController . propogateStateMessage ( new FMLModIdMappingEvent ( remapBlocks , remapItems , isFreezing ) ) ; 
 + } 
 } 
 
 public void runtimeDisableMod ( String modId ) 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java b / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java 
 index d11135b . . ea23483 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java 
 @ @ - 55 , 7 + 55 , 10 @ @ public class ModClassLoader extends URLClassLoader 
 
 public ModClassLoader ( ClassLoader parent ) { 
 super ( new URL [ 0 ] , null ) ; 
 - this . mainClassLoader = ( LaunchClassLoader ) parent ; 
 + if ( parent instanceof LaunchClassLoader ) 
 + { 
 + this . mainClassLoader = ( LaunchClassLoader ) parent ; 
 + } 
 this . sources = Lists . newArrayList ( ) ; 
 } 
 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 index da64ad9 . . 1f5670a 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 @ @ - 61 , 7 + 61 , 7 @ @ import com . google . common . collect . Sets . SetView ; 
 @ SuppressWarnings ( " WeakerAccess " ) 
 public class PersistentRegistryManager 
 { 
 - private enum PersistentRegistry 
 + enum PersistentRegistry 
 { 
 ACTIVE , VANILLA , FROZEN , STAGING ; 
 
 diff - - git a / src / main / java / net / minecraftforge / fml / relauncher / FMLRelaunchLog . java b / src / main / java / net / minecraftforge / fml / relauncher / FMLRelaunchLog . java 
 index 1c206f0 . . 41691d5 100644 
 - - - a / src / main / java / net / minecraftforge / fml / relauncher / FMLRelaunchLog . java 
 + + + b / src / main / java / net / minecraftforge / fml / relauncher / FMLRelaunchLog . java 
 @ @ - 54 , 6 + 54 , 8 @ @ public class FMLRelaunchLog { 
 private static void configureLogging ( ) 
 { 
 log . myLog = LogManager . getLogger ( " FML " ) ; 
 + / / Default side to client for test harness purposes 
 + if ( side = = null ) side = Side . CLIENT ; 
 ThreadContext . put ( " side " , side . name ( ) . toLowerCase ( Locale . ENGLISH ) ) ; 
 configured = true ; 
 
 diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java b / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java 
 new file mode 100644 
 index 0000000 . . cc4fbb0 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java 
 @ @ - 0 , 0 + 1 , 146 @ @ 
 + package net . minecraftforge . fml . common . registry ; 
 + 
 + import java . net . URLClassLoader ; 
 + import java . util . Collections ; 
 + import java . util . Set ; 
 + 
 + import com . google . common . collect . Sets ; 
 + import org . junit . runner . Description ; 
 + import org . junit . runner . Runner ; 
 + import org . junit . runner . notification . Failure ; 
 + import org . junit . runner . notification . RunNotifier ; 
 + import org . junit . runners . JUnit4 ; 
 + import org . junit . runners . model . InitializationError ; 
 + 
 + / * * 
 + * Uses { @ code ResettingClassLoader } to load the test class , meaning the 
 + * { @ code Quarantine } annotation can be used to ensure certain classes are 
 + * loaded separately . 
 + * 
 + * Use of a separate class loader allows classes to be reloaded for each test 
 + * class , which is handy when you ' re testing frameworks that make use of static 
 + * members . 
 + * 
 + * The selective quarantining is required because if the test class and its 
 + * ' children ' are all loaded by a different class loader , then the { @ code Test } 
 + * annotations yield different { @ code Class } instances . JUnit then thinks there 
 + * are no runnable methods , because it looks them up by Class . 
 + * 
 + * This is a simplified copy of https : / / github . com / BinaryTweed / quarantining - test - runner 
 + * tailored for Minecraft use . 
 + * 
 + * / 
 + public class ForgeTestRunner extends Runner 
 + { 
 + private final Object innerRunner ; 
 + private final Class < ? > innerRunnerClass ; 
 + 
 + public ForgeTestRunner ( Class < ? > testFileClass ) throws InitializationError 
 + { 
 + Class < ? extends Runner > delegateRunningTo = JUnit4 . class ; 
 + 
 + String testFileClassName = testFileClass . getName ( ) ; 
 + String delegateRunningToClassName = delegateRunningTo . getName ( ) ; 
 + 
 + String [ ] allPatterns = new String [ ] { testFileClassName , delegateRunningToClassName } ; 
 + 
 + ResettingClassLoader classLoader = new ResettingClassLoader ( allPatterns ) ; 
 + 
 + try 
 + { 
 + innerRunnerClass = classLoader . loadClass ( delegateRunningToClassName ) ; 
 + Class < ? > testClass = classLoader . loadClass ( testFileClassName ) ; 
 + innerRunner = innerRunnerClass . cast ( innerRunnerClass . getConstructor ( Class . class ) . newInstance ( testClass ) ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new InitializationError ( e ) ; 
 + } 
 + } 
 + 
 + 
 + @ Override 
 + public Description getDescription ( ) 
 + { 
 + try 
 + { 
 + return ( Description ) innerRunnerClass . getMethod ( " getDescription " ) . invoke ( innerRunner ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new RuntimeException ( " Could not get description " , e ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void run ( RunNotifier notifier ) 
 + { 
 + try 
 + { 
 + innerRunnerClass . getMethod ( " run " , RunNotifier . class ) . invoke ( innerRunner , notifier ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + notifier . fireTestFailure ( new Failure ( getDescription ( ) , e ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * If a class name starts with any of the supplied patterns , it is loaded by 
 + * < em > this < / em > classloader ; otherwise it is loaded by the parent classloader . 
 + * 
 + * / 
 + private class ResettingClassLoader extends URLClassLoader 
 + { 
 + private final Set < String > quarantinedClassNames ; 
 + 
 + / * * 
 + * 
 + * @ param quarantinedClassNames prefixes to match against when deciding how to load a class 
 + * / 
 + public ResettingClassLoader ( String . . . quarantinedClassNames ) 
 + { 
 + super ( ( ( URLClassLoader ) getSystemClassLoader ( ) ) . getURLs ( ) ) ; 
 + 
 + this . quarantinedClassNames = Sets . newHashSet ( ) ; 
 + Collections . addAll ( this . quarantinedClassNames , quarantinedClassNames ) ; 
 + Collections . addAll ( this . quarantinedClassNames , " net . minecraft " , " net . minecraftforge " ) ; 
 + } 
 + 
 + 
 + / * * 
 + * If a class name starts with any of the supplied patterns , it is loaded by 
 + * < em > this < / em > classloader ; otherwise it is loaded by the parent classloader . 
 + * 
 + * @ param name class to load 
 + * / 
 + @ Override 
 + public Class < ? > loadClass ( String name ) throws ClassNotFoundException 
 + { 
 + boolean quarantine = false ; 
 + 
 + for ( String quarantinedPattern : quarantinedClassNames ) 
 + { 
 + if ( name . startsWith ( quarantinedPattern ) ) 
 + { 
 + quarantine = true ; 
 + break ; 
 + } 
 + } 
 + 
 + if ( quarantine ) 
 + { 
 + try 
 + { 
 + return findClass ( name ) ; 
 + } 
 + catch ( ClassNotFoundException e ) 
 + { 
 + throw e ; 
 + } 
 + } 
 + 
 + return super . loadClass ( name ) ; 
 + } 
 + } 
 + } 
 diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / FreezingTests . java b / src / test / java / net / minecraftforge / fml / common / registry / FreezingTests . java 
 new file mode 100644 
 index 0000000 . . 6cdd810 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / fml / common / registry / FreezingTests . java 
 @ @ - 0 , 0 + 1 , 105 @ @ 
 + package net . minecraftforge . fml . common . registry ; 
 + 
 + import net . minecraft . block . Block ; 
 + import net . minecraft . item . Item ; 
 + import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . fml . common . Loader ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import static org . junit . Assert . * ; 
 + 
 + / * * 
 + * Created by cpw on 04 / 07 / 16 . 
 + * / 
 + @ RunWith ( ForgeTestRunner . class ) 
 + public class FreezingTests 
 + { 
 + 
 + private static RTest r1 ; 
 + private static RTest r2 ; 
 + private static RTest r3 ; 
 + private static RTest r4 ; 
 + private static RTest r5 ; 
 + private static RTest r6 ; 
 + private static PersistentRegistryManager . GameDataSnapshot ss ; 
 + 
 + static class RTest extends IForgeRegistryEntry . Impl < RTest > { 
 + public RTest ( String name ) { 
 + setRegistryName ( name ) ; 
 + } 
 + } 
 + 
 + public static IForgeRegistry < RTest > registry ; 
 + public static ResourceLocation resloc = new ResourceLocation ( " fmltest : test " ) ; 
 + 
 + @ BeforeClass 
 + public static void setup ( ) 
 + { 
 + Loader . instance ( ) ; 
 + System . setProperty ( " fml . queryResult " , " confirm " ) ; 
 + registry = PersistentRegistryManager . createRegistry ( resloc , RTest . class , null , 0 , 255 , false , null , null , null ) ; 
 + PersistentRegistryManager . createRegistry ( PersistentRegistryManager . BLOCKS , Block . class , null , 0 , 255 , false , null , null , null ) ; 
 + PersistentRegistryManager . createRegistry ( PersistentRegistryManager . ITEMS , Item . class , null , 0 , 255 , false , null , null , null ) ; 
 + r1 = new RTest ( " test1 " ) ; 
 + r2 = new RTest ( " test2 " ) ; 
 + r3 = new RTest ( " test3 " ) ; 
 + r4 = new RTest ( " test4 " ) ; 
 + r5 = new RTest ( " test5 " ) ; 
 + r6 = new RTest ( " test6 " ) ; 
 + ss = new PersistentRegistryManager . GameDataSnapshot ( ) ; 
 + ss . entries . put ( PersistentRegistryManager . BLOCKS , new PersistentRegistryManager . GameDataSnapshot . Entry ( ) ) ; 
 + ss . entries . put ( PersistentRegistryManager . ITEMS , new PersistentRegistryManager . GameDataSnapshot . Entry ( ) ) ; 
 + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r1 ) ; 
 + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r2 ) ; 
 + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r3 ) ; 
 + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r4 ) ; 
 + ss . entries . put ( resloc , new PersistentRegistryManager . GameDataSnapshot . Entry ( PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) ) ) ; 
 + PersistentRegistryManager . PersistentRegistry . ACTIVE . clean ( ) ; 
 + PersistentRegistryManager . PersistentRegistry . FROZEN . clean ( ) ; 
 + registry = PersistentRegistryManager . createRegistry ( resloc , RTest . class , null , 0 , 255 , false , null , null , null ) ; 
 + PersistentRegistryManager . createRegistry ( PersistentRegistryManager . BLOCKS , Block . class , null , 0 , 255 , false , null , null , null ) ; 
 + PersistentRegistryManager . createRegistry ( PersistentRegistryManager . ITEMS , Item . class , null , 0 , 255 , false , null , null , null ) ; 
 + } 
 + 
 + @ Test 
 + public void testFreezeCycle ( ) 
 + { 
 + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r6 ) ; 
 + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r5 ) ; 
 + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r4 ) ; 
 + PersistentRegistryManager . findRegistryByType ( RTest . class ) . register ( r3 ) ; 
 + FMLControlledNamespacedRegistry < RTest > r = ( FMLControlledNamespacedRegistry ) PersistentRegistryManager . findRegistry ( r3 ) ; 
 + int r3id = r . getId ( r3 ) ; 
 + PersistentRegistryManager . freezeData ( ) ; 
 + RTest q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Active object is the same " , r3 , q1 ) ; 
 + PersistentRegistryManager . injectSnapshot ( ss , false , false ) ; 
 + assertNotEquals ( " IDs don ' t match " , r3id , r . getId ( r3 ) ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Active object is the same " , r3 , q1 ) ; 
 + PersistentRegistryManager . revertToFrozen ( ) ; 
 + assertEquals ( " IDs match " , r3id , r . getId ( r3 ) ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Active object is the same " , r3 , q1 ) ; 
 + PersistentRegistryManager . injectSnapshot ( ss , true , true ) ; 
 + assertNotEquals ( " IDs don ' t match " , r3id , r . getId ( r3 ) ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Active object is the same " , r3 , q1 ) ; 
 + PersistentRegistryManager . revertToFrozen ( ) ; 
 + assertEquals ( " IDs match " , r3id , r . getId ( r3 ) ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . FROZEN . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Frozen object is the same " , r3 , q1 ) ; 
 + q1 = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( RTest . class ) . getValue ( new ResourceLocation ( " test3 " ) ) ; 
 + assertEquals ( " Active object is the same " , r3 , q1 ) ; 
 + } 
 + } 
 diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / VanillaRegistryTests . java b / src / test / java / net / minecraftforge / fml / common / registry / VanillaRegistryTests . java 
 new file mode 100644 
 index 0000000 . . c2edccf 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / fml / common / registry / VanillaRegistryTests . java 
 @ @ - 0 , 0 + 1 , 99 @ @ 
 + package net . minecraftforge . fml . common . registry ; 
 + 
 + import net . minecraft . block . Block ; 
 + import net . minecraft . block . material . Material ; 
 + import net . minecraft . init . Blocks ; 
 + import net . minecraft . init . Bootstrap ; 
 + import net . minecraft . init . Items ; 
 + import net . minecraft . item . Item ; 
 + import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . fml . common . Loader ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import static org . junit . Assert . * ; 
 + 
 + / * * 
 + * Vanilla registry tests 
 + * / 
 + @ RunWith ( ForgeTestRunner . class ) 
 + public class VanillaRegistryTests 
 + { 
 + @ BeforeClass 
 + public static void setupHarness ( ) 
 + { 
 + Loader . instance ( ) ; 
 + Bootstrap . register ( ) ; 
 + } 
 + 
 + @ Test 
 + public void testSetup ( ) 
 + { 
 + / / All the blocks loaded 
 + assertEquals ( " We have all the blocks via GameData " , 219 , Block . REGISTRY . getKeys ( ) . size ( ) ) ; 
 + 
 + / / All the items loaded 
 + assertEquals ( " We have all the items via GameData " , 371 , Item . REGISTRY . getKeys ( ) . size ( ) ) ; 
 + 
 + / / Our lookups find the same stuff vanilla sees 
 + final IForgeRegistry < Block > blocks = PersistentRegistryManager . findRegistry ( Blocks . AIR ) ; 
 + assertEquals ( " We have the right blocks for a block " , blocks , Block . REGISTRY ) ; 
 + 
 + / / We can look up stuff through our APIs 
 + Block bl = blocks . getValue ( new ResourceLocation ( " minecraft : air " ) ) ; 
 + assertEquals ( " We got air when we asked for it " , Blocks . AIR , bl ) ; 
 + 
 + / / Default values work 
 + Block blch = blocks . getValue ( new ResourceLocation ( " minecraft : cheese " ) ) ; 
 + assertEquals ( " We got air when we asked for cheese " , Blocks . AIR , blch ) ; 
 + 
 + / / Our lookups find the same stuff vanilla sees 
 + final IForgeRegistry < Item > items = PersistentRegistryManager . findRegistry ( Items . BED ) ; 
 + assertEquals ( " We have the right items for an item " , items , Item . REGISTRY ) ; 
 + 
 + / / We can look up stuff through our APIs 
 + Item it = items . getValue ( new ResourceLocation ( " minecraft : bed " ) ) ; 
 + assertEquals ( " We got a bed item when we asked for it " , Items . BED , it ) ; 
 + 
 + / / We find nothing for a non - defaulted registry 
 + Item none = items . getValue ( new ResourceLocation ( " minecraft : cheese " ) ) ; 
 + assertEquals ( " We got nothing ( items ) when we asked for cheese " , null , none ) ; 
 + } 
 + 
 + @ Test 
 + public void testRegistration ( ) 
 + { 
 + Block myBlock = GameRegistry . register ( new Block ( Material . CAKE ) { } , new ResourceLocation ( " minecraft : testy " ) ) ; 
 + assertNotNull ( " Registered my block " , myBlock ) ; 
 + 
 + / / Our lookups find the same stuff vanilla sees 
 + final IForgeRegistry < Block > blocks = PersistentRegistryManager . findRegistry ( myBlock ) ; 
 + assertEquals ( " We have the right blocks for a block " , blocks , Block . REGISTRY ) ; 
 + 
 + Block found = blocks . getValue ( new ResourceLocation ( " minecraft : testy " ) ) ; 
 + assertEquals ( " Registry lookup works " , myBlock , found ) ; 
 + } 
 + 
 + @ Test 
 + public void testRegistryStates ( ) 
 + { 
 + final FMLControlledNamespacedRegistry < Block > blockVanilla = PersistentRegistryManager . PersistentRegistry . VANILLA . getRegistry ( Block . class ) ; 
 + final FMLControlledNamespacedRegistry < Block > blockActive = PersistentRegistryManager . PersistentRegistry . ACTIVE . getRegistry ( Block . class ) ; 
 + 
 + assertNotEquals ( " Registry states are distinct " , blockActive , blockVanilla ) ; 
 + 
 + final Block stoneActive = blockActive . getValue ( new ResourceLocation ( " minecraft : stone " ) ) ; 
 + final Block stoneVanilla = blockVanilla . getValue ( new ResourceLocation ( " minecraft : stone " ) ) ; 
 + 
 + assertEquals ( " Stone from active and vanilla are the same " , stoneActive , stoneVanilla ) ; 
 + 
 + int activeId = blockActive . getId ( stoneActive ) ; 
 + int vanillaId = blockVanilla . getId ( stoneVanilla ) ; 
 + 
 + assertEquals ( " Stone has correct id " , 1 , activeId ) ; 
 + assertEquals ( " Stone has correct id " , 1 , vanillaId ) ; 
 + } 
 + 
 + 
 + }

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java b / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java 
 new file mode 100644 
 index 0000000 . . 6e0fdd0 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java 
 @ @ - 0 , 0 + 1 , 192 @ @ 
 + package cpw . mods . fml . common . asm . transformers ; 
 + 
 + import static org . objectweb . asm . ClassWriter . COMPUTE _ FRAMES ; 
 + import static org . objectweb . asm . ClassWriter . COMPUTE _ MAXS ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; 
 + import static org . objectweb . asm . Opcodes . ACC _ STATIC ; 
 + import static org . objectweb . asm . Opcodes . ALOAD ; 
 + import static org . objectweb . asm . Opcodes . ARETURN ; 
 + import static org . objectweb . asm . Opcodes . ASM4 ; 
 + import static org . objectweb . asm . Opcodes . DUP ; 
 + import static org . objectweb . asm . Opcodes . F _ SAME ; 
 + import static org . objectweb . asm . Opcodes . GETSTATIC ; 
 + import static org . objectweb . asm . Opcodes . IFNULL ; 
 + import static org . objectweb . asm . Opcodes . INVOKESPECIAL ; 
 + import static org . objectweb . asm . Opcodes . NEW ; 
 + import static org . objectweb . asm . Opcodes . PUTSTATIC ; 
 + import static org . objectweb . asm . Opcodes . RETURN ; 
 + import static org . objectweb . asm . Type . VOID _ TYPE ; 
 + import static org . objectweb . asm . Type . getMethodDescriptor ; 
 + 
 + import java . util . List ; 
 + 
 + import net . minecraft . launchwrapper . IClassTransformer ; 
 + 
 + import org . objectweb . asm . ClassReader ; 
 + import org . objectweb . asm . ClassWriter ; 
 + import org . objectweb . asm . Type ; 
 + import org . objectweb . asm . tree . ClassNode ; 
 + import org . objectweb . asm . tree . FieldInsnNode ; 
 + import org . objectweb . asm . tree . FieldNode ; 
 + import org . objectweb . asm . tree . FrameNode ; 
 + import org . objectweb . asm . tree . InsnNode ; 
 + import org . objectweb . asm . tree . JumpInsnNode ; 
 + import org . objectweb . asm . tree . LabelNode ; 
 + import org . objectweb . asm . tree . MethodInsnNode ; 
 + import org . objectweb . asm . tree . MethodNode ; 
 + import org . objectweb . asm . tree . TypeInsnNode ; 
 + import org . objectweb . asm . tree . VarInsnNode ; 
 + 
 + import cpw . mods . fml . common . eventhandler . Event ; 
 + 
 + public class EventSubscriptionTransformer implements IClassTransformer 
 + { 
 + public EventSubscriptionTransformer ( ) 
 + { 
 + } 
 + 
 + @ Override 
 + public byte [ ] transform ( String name , String transformedName , byte [ ] bytes ) 
 + { 
 + if ( bytes = = null | | name . equals ( " cpw . mods . fml . common . eventhandler . Event " ) | | name . startsWith ( " net . minecraft . " ) | | name . indexOf ( ' . ' ) = = - 1 ) 
 + { 
 + return bytes ; 
 + } 
 + ClassReader cr = new ClassReader ( bytes ) ; 
 + ClassNode classNode = new ClassNode ( ) ; 
 + cr . accept ( classNode , 0 ) ; 
 + 
 + try 
 + { 
 + if ( buildEvents ( classNode ) ) 
 + { 
 + ClassWriter cw = new ClassWriter ( COMPUTE _ MAXS | COMPUTE _ FRAMES ) ; 
 + classNode . accept ( cw ) ; 
 + return cw . toByteArray ( ) ; 
 + } 
 + return bytes ; 
 + } 
 + catch ( ClassNotFoundException ex ) 
 + { 
 + / / Discard silently - it ' s just noise 
 + } 
 + catch ( Exception e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + 
 + return bytes ; 
 + } 
 + 
 + private boolean buildEvents ( ClassNode classNode ) throws Exception 
 + { 
 + Class < ? > parent = this . getClass ( ) . getClassLoader ( ) . loadClass ( classNode . superName . replace ( ' / ' , ' . ' ) ) ; 
 + if ( ! Event . class . isAssignableFrom ( parent ) ) 
 + { 
 + return false ; 
 + } 
 + 
 + boolean hasSetup = false ; 
 + boolean hasGetListenerList = false ; 
 + boolean hasDefaultCtr = false ; 
 + 
 + Class < ? > listenerListClazz = Class . forName ( " cpw . mods . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; 
 + Type tList = Type . getType ( listenerListClazz ) ; 
 + 
 + for ( MethodNode method : ( List < MethodNode > ) classNode . methods ) 
 + { 
 + if ( method . name . equals ( " setup " ) & & 
 + method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) & & 
 + ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) 
 + { 
 + hasSetup = true ; 
 + } 
 + if ( method . name . equals ( " getListenerList " ) & & 
 + method . desc . equals ( Type . getMethodDescriptor ( tList ) ) & & 
 + ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) 
 + { 
 + hasGetListenerList = true ; 
 + } 
 + if ( method . name . equals ( " < init > " ) & & 
 + method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) ) 
 + { 
 + hasDefaultCtr = true ; 
 + } 
 + } 
 + 
 + if ( hasSetup ) 
 + { 
 + if ( ! hasGetListenerList ) 
 + { 
 + throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; 
 + } 
 + else 
 + { 
 + return false ; 
 + } 
 + } 
 + 
 + Type tSuper = Type . getType ( classNode . superName ) ; 
 + 
 + / / Add private static ListenerList LISTENER _ LIST 
 + classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , tList . getDescriptor ( ) , null , null ) ) ; 
 + 
 + / * Add : 
 + * public < init > ( ) 
 + * { 
 + * super ( ) ; 
 + * } 
 + * / 
 + MethodNode method = new MethodNode ( ASM4 , ACC _ PUBLIC , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; 
 + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE ) ) ) ; 
 + method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 + if ( ! hasDefaultCtr ) 
 + { 
 + classNode . methods . add ( method ) ; 
 + } 
 + 
 + / * Add : 
 + * protected void setup ( ) 
 + * { 
 + * super . setup ( ) ; 
 + * if ( LISTENER _ LIST ! = NULL ) 
 + * { 
 + * return ; 
 + * } 
 + * LISTENER _ LIST = new ListenerList ( super . getListenerList ( ) ) ; 
 + * } 
 + * / 
 + method = new MethodNode ( ASM4 , ACC _ PROTECTED , " setup " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; 
 + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , getMethodDescriptor ( VOID _ TYPE ) ) ) ; 
 + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + LabelNode initLisitener = new LabelNode ( ) ; 
 + method . instructions . add ( new JumpInsnNode ( IFNULL , initLisitener ) ) ; 
 + method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 + method . instructions . add ( initLisitener ) ; 
 + method . instructions . add ( new FrameNode ( F _ SAME , 0 , null , 0 , null ) ) ; 
 + method . instructions . add ( new TypeInsnNode ( NEW , tList . getInternalName ( ) ) ) ; 
 + method . instructions . add ( new InsnNode ( DUP ) ) ; 
 + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , getMethodDescriptor ( tList ) ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tList . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE , tList ) ) ) ; 
 + method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 + classNode . methods . add ( method ) ; 
 + 
 + / * Add : 
 + * public ListenerList getListenerList ( ) 
 + * { 
 + * return this . LISTENER _ LIST ; 
 + * } 
 + * / 
 + method = new MethodNode ( ASM4 , ACC _ PUBLIC , " getListenerList " , getMethodDescriptor ( tList ) , null , null ) ; 
 + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + method . instructions . add ( new InsnNode ( ARETURN ) ) ; 
 + classNode . methods . add ( method ) ; 
 + return true ; 
 + } 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java 
 new file mode 100644 
 index 0000000 . . 02bb037 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java 
 @ @ - 0 , 0 + 1 , 130 @ @ 
 + package cpw . mods . fml . common . eventhandler ; 
 + 
 + import static org . objectweb . asm . Opcodes . * ; 
 + 
 + import java . lang . reflect . Method ; 
 + import java . util . HashMap ; 
 + 
 + 
 + import org . objectweb . asm . ClassWriter ; 
 + import org . objectweb . asm . MethodVisitor ; 
 + import org . objectweb . asm . Type ; 
 + 
 + import com . google . common . collect . Maps ; 
 + 
 + 
 + public class ASMEventHandler implements IEventListener 
 + { 
 + private static int IDs = 0 ; 
 + private static final String HANDLER _ DESC = Type . getInternalName ( IEventListener . class ) ; 
 + private static final String HANDLER _ FUNC _ DESC = Type . getMethodDescriptor ( IEventListener . class . getDeclaredMethods ( ) [ 0 ] ) ; 
 + private static final ASMClassLoader LOADER = new ASMClassLoader ( ) ; 
 + private static final HashMap < Method , Class < ? > > cache = Maps . newHashMap ( ) ; 
 + 
 + private final IEventListener handler ; 
 + private final SubscribeEvent subInfo ; 
 + public ASMEventHandler ( Object target , Method method ) throws Exception 
 + { 
 + handler = ( IEventListener ) createWrapper ( method ) . getConstructor ( Object . class ) . newInstance ( target ) ; 
 + subInfo = method . getAnnotation ( SubscribeEvent . class ) ; 
 + } 
 + 
 + @ Override 
 + public void invoke ( Event event ) 
 + { 
 + if ( handler ! = null ) 
 + { 
 + if ( ! event . isCancelable ( ) | | ! event . isCanceled ( ) | | subInfo . receiveCanceled ( ) ) 
 + { 
 + handler . invoke ( event ) ; 
 + } 
 + } 
 + } 
 + 
 + public EventPriority getPriority ( ) 
 + { 
 + return subInfo . priority ( ) ; 
 + } 
 + 
 + public Class < ? > createWrapper ( Method callback ) 
 + { 
 + if ( cache . containsKey ( callback ) ) 
 + { 
 + return cache . get ( callback ) ; 
 + } 
 + 
 + ClassWriter cw = new ClassWriter ( 0 ) ; 
 + MethodVisitor mv ; 
 + 
 + String name = getUniqueName ( callback ) ; 
 + String desc = name . replace ( ' . ' , ' / ' ) ; 
 + String instType = Type . getInternalName ( callback . getDeclaringClass ( ) ) ; 
 + String eventType = Type . getInternalName ( callback . getParameterTypes ( ) [ 0 ] ) ; 
 + 
 + / * 
 + System . out . println ( " Name : " + name ) ; 
 + System . out . println ( " Desc : " + desc ) ; 
 + System . out . println ( " InstType : " + instType ) ; 
 + System . out . println ( " Callback : " + callback . getName ( ) + Type . getMethodDescriptor ( callback ) ) ; 
 + System . out . println ( " Event : " + eventType ) ; 
 + * / 
 + 
 + cw . visit ( V1 _ 6 , ACC _ PUBLIC | ACC _ SUPER , desc , null , " java / lang / Object " , new String [ ] { HANDLER _ DESC } ) ; 
 + 
 + cw . visitSource ( " . dynamic " , null ) ; 
 + { 
 + cw . visitField ( ACC _ PUBLIC , " instance " , " Ljava / lang / Object ; " , null , null ) . visitEnd ( ) ; 
 + } 
 + { 
 + mv = cw . visitMethod ( ACC _ PUBLIC , " < init > " , " ( Ljava / lang / Object ; ) V " , null , null ) ; 
 + mv . visitCode ( ) ; 
 + mv . visitVarInsn ( ALOAD , 0 ) ; 
 + mv . visitMethodInsn ( INVOKESPECIAL , " java / lang / Object " , " < init > " , " ( ) V " ) ; 
 + mv . visitVarInsn ( ALOAD , 0 ) ; 
 + mv . visitVarInsn ( ALOAD , 1 ) ; 
 + mv . visitFieldInsn ( PUTFIELD , desc , " instance " , " Ljava / lang / Object ; " ) ; 
 + mv . visitInsn ( RETURN ) ; 
 + mv . visitMaxs ( 2 , 2 ) ; 
 + mv . visitEnd ( ) ; 
 + } 
 + { 
 + mv = cw . visitMethod ( ACC _ PUBLIC , " invoke " , HANDLER _ FUNC _ DESC , null , null ) ; 
 + mv . visitCode ( ) ; 
 + mv . visitVarInsn ( ALOAD , 0 ) ; 
 + mv . visitFieldInsn ( GETFIELD , desc , " instance " , " Ljava / lang / Object ; " ) ; 
 + mv . visitTypeInsn ( CHECKCAST , instType ) ; 
 + mv . visitVarInsn ( ALOAD , 1 ) ; 
 + mv . visitTypeInsn ( CHECKCAST , eventType ) ; 
 + mv . visitMethodInsn ( INVOKEVIRTUAL , instType , callback . getName ( ) , Type . getMethodDescriptor ( callback ) ) ; 
 + mv . visitInsn ( RETURN ) ; 
 + mv . visitMaxs ( 2 , 2 ) ; 
 + mv . visitEnd ( ) ; 
 + } 
 + cw . visitEnd ( ) ; 
 + Class < ? > ret = LOADER . define ( name , cw . toByteArray ( ) ) ; 
 + cache . put ( callback , ret ) ; 
 + return ret ; 
 + } 
 + 
 + private String getUniqueName ( Method callback ) 
 + { 
 + return String . format ( " % s _ % d _ % s _ % s _ % s " , getClass ( ) . getName ( ) , IDs + + , 
 + callback . getDeclaringClass ( ) . getSimpleName ( ) , 
 + callback . getName ( ) , 
 + callback . getParameterTypes ( ) [ 0 ] . getSimpleName ( ) ) ; 
 + } 
 + 
 + private static class ASMClassLoader extends ClassLoader 
 + { 
 + private ASMClassLoader ( ) 
 + { 
 + super ( ASMClassLoader . class . getClassLoader ( ) ) ; 
 + } 
 + 
 + public Class < ? > define ( String name , byte [ ] data ) 
 + { 
 + return defineClass ( name , data , 0 , data . length ) ; 
 + } 
 + } 
 + 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / Cancelable . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Cancelable . java 
 new file mode 100644 
 index 0000000 . . 4b73896 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Cancelable . java 
 @ @ - 0 , 0 + 1 , 11 @ @ 
 + package cpw . mods . fml . common . eventhandler ; 
 + 
 + import static java . lang . annotation . ElementType . TYPE ; 
 + import static java . lang . annotation . RetentionPolicy . RUNTIME ; 
 + 
 + import java . lang . annotation . Retention ; 
 + import java . lang . annotation . Target ; 
 + 
 + @ Retention ( value = RUNTIME ) 
 + @ Target ( value = TYPE ) 
 + public @ interface Cancelable { } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java 
 new file mode 100644 
 index 0000000 . . d9c31ee 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java 
 @ @ - 0 , 0 + 1 , 156 @ @ 
 + package cpw . mods . fml . common . eventhandler ; 
 + 
 + import static java . lang . annotation . ElementType . TYPE ; 
 + import static java . lang . annotation . RetentionPolicy . RUNTIME ; 
 + 
 + import java . lang . annotation . Annotation ; 
 + import java . lang . annotation . Retention ; 
 + import java . lang . annotation . Target ; 
 + import java . util . Map ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 + 
 + 
 + / * * 
 + * Base Event class that all other events are derived from 
 + * / 
 + public class Event 
 + { 
 + @ Retention ( value = RUNTIME ) 
 + @ Target ( value = TYPE ) 
 + public @ interface HasResult { } 
 + 
 + public enum Result 
 + { 
 + DENY , 
 + DEFAULT , 
 + ALLOW 
 + } 
 + 
 + private boolean isCanceled = false ; 
 + private final boolean isCancelable ; 
 + private Result result = Result . DEFAULT ; 
 + private final boolean hasResult ; 
 + private static ListenerList listeners = new ListenerList ( ) ; 
 + 
 + private static final Map < Class < ? > , Map < Class < ? > , Boolean > > annotationMap = new ConcurrentHashMap < Class < ? > , Map < Class < ? > , Boolean > > ( ) ; 
 + 
 + public Event ( ) 
 + { 
 + setup ( ) ; 
 + isCancelable = hasAnnotation ( Cancelable . class ) ; 
 + hasResult = hasAnnotation ( HasResult . class ) ; 
 + } 
 + 
 + private boolean hasAnnotation ( Class < ? extends Annotation > annotation ) 
 + { 
 + Class < ? > me = this . getClass ( ) ; 
 + Map < Class < ? > , Boolean > list = annotationMap . get ( me ) ; 
 + if ( list = = null ) 
 + { 
 + list = new ConcurrentHashMap < Class < ? > , Boolean > ( ) ; 
 + annotationMap . put ( me , list ) ; 
 + } 
 + 
 + Boolean cached = list . get ( annotation ) ; 
 + if ( cached ! = null ) 
 + { 
 + return cached ; 
 + } 
 + 
 + Class < ? > cls = me ; 
 + while ( cls ! = Event . class ) 
 + { 
 + if ( cls . isAnnotationPresent ( annotation ) ) 
 + { 
 + list . put ( annotation , true ) ; 
 + return true ; 
 + } 
 + cls = cls . getSuperclass ( ) ; 
 + } 
 + 
 + list . put ( annotation , false ) ; 
 + return false ; 
 + } 
 + 
 + / * * 
 + * Determine if this function is cancelable at all . 
 + * @ return If access to setCanceled should be allowed 
 + * / 
 + public boolean isCancelable ( ) 
 + { 
 + return isCancelable ; 
 + } 
 + 
 + / * * 
 + * Determine if this event is canceled and should stop executing . 
 + * @ return The current canceled state 
 + * / 
 + public boolean isCanceled ( ) 
 + { 
 + return isCanceled ; 
 + } 
 + 
 + / * * 
 + * Sets the state of this event , not all events are cancelable , and any attempt to 
 + * cancel a event that can ' t be will result in a IllegalArgumentException . 
 + * 
 + * The functionality of setting the canceled state is defined on a per - event bases . 
 + * 
 + * @ param cancel The new canceled value 
 + * / 
 + public void setCanceled ( boolean cancel ) 
 + { 
 + if ( ! isCancelable ( ) ) 
 + { 
 + throw new IllegalArgumentException ( " Attempted to cancel a uncancelable event " ) ; 
 + } 
 + isCanceled = cancel ; 
 + } 
 + 
 + / * * 
 + * Determines if this event expects a significant result value . 
 + * / 
 + public boolean hasResult ( ) 
 + { 
 + return hasResult ; 
 + } 
 + 
 + / * * 
 + * Returns the value set as the result of this event 
 + * / 
 + public Result getResult ( ) 
 + { 
 + return result ; 
 + } 
 + 
 + / * * 
 + * Sets the result value for this event , not all events can have a result set , and any attempt to 
 + * set a result for a event that isn ' t expecting it will result in a IllegalArgumentException . 
 + * 
 + * The functionality of setting the result is defined on a per - event bases . 
 + * 
 + * @ param value The new result 
 + * / 
 + public void setResult ( Result value ) 
 + { 
 + result = value ; 
 + } 
 + / * * 
 + * Called by the base constructor , this is used by ASM generated 
 + * event classes to setup various functionality such as the listenerlist . 
 + * / 
 + protected void setup ( ) 
 + { 
 + } 
 + 
 + / * * 
 + * Returns a ListenerList object that contains all listeners 
 + * that are registered to this event . 
 + * 
 + * @ return Listener List 
 + * / 
 + public ListenerList getListenerList ( ) 
 + { 
 + return listeners ; 
 + } 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java 
 new file mode 100644 
 index 0000000 . . aa6640d 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java 
 @ @ - 0 , 0 + 1 , 112 @ @ 
 + package cpw . mods . fml . common . eventhandler ; 
 + 
 + import java . lang . reflect . Constructor ; 
 + import java . lang . reflect . Method ; 
 + import java . util . ArrayList ; 
 + import java . util . Set ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 + 
 + 
 + 
 + import com . google . common . reflect . TypeToken ; 
 + 
 + public class EventBus 
 + { 
 + private static int maxID = 0 ; 
 + 
 + private ConcurrentHashMap < Object , ArrayList < IEventListener > > listeners = new ConcurrentHashMap < Object , ArrayList < IEventListener > > ( ) ; 
 + private final int busID = maxID + + ; 
 + 
 + public EventBus ( ) 
 + { 
 + ListenerList . resize ( busID + 1 ) ; 
 + } 
 + 
 + public void register ( Object target ) 
 + { 
 + if ( listeners . containsKey ( target ) ) 
 + { 
 + return ; 
 + } 
 + 
 + Set < ? extends Class < ? > > supers = TypeToken . of ( target . getClass ( ) ) . getTypes ( ) . rawTypes ( ) ; 
 + for ( Method method : target . getClass ( ) . getMethods ( ) ) 
 + { 
 + for ( Class < ? > cls : supers ) 
 + { 
 + try 
 + { 
 + Method real = cls . getDeclaredMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; 
 + if ( real . isAnnotationPresent ( SubscribeEvent . class ) ) 
 + { 
 + Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; 
 + if ( parameterTypes . length ! = 1 ) 
 + { 
 + throw new IllegalArgumentException ( 
 + " Method " + method + " has @ SubscribeEvent annotation , but requires " + parameterTypes . length + 
 + " arguments . Event handler methods must require a single argument . " 
 + ) ; 
 + } 
 + 
 + Class < ? > eventType = parameterTypes [ 0 ] ; 
 + 
 + if ( ! Event . class . isAssignableFrom ( eventType ) ) 
 + { 
 + throw new IllegalArgumentException ( " Method " + method + " has @ SubscribeEvent annotation , but takes a argument that is not a Event " + eventType ) ; 
 + } 
 + 
 + register ( eventType , target , method ) ; 
 + break ; 
 + } 
 + } 
 + catch ( NoSuchMethodException e ) 
 + { 
 + ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + private void register ( Class < ? > eventType , Object target , Method method ) 
 + { 
 + try 
 + { 
 + Constructor < ? > ctr = eventType . getConstructor ( ) ; 
 + ctr . setAccessible ( true ) ; 
 + Event event = ( Event ) ctr . newInstance ( ) ; 
 + ASMEventHandler listener = new ASMEventHandler ( target , method ) ; 
 + event . getListenerList ( ) . register ( busID , listener . getPriority ( ) , listener ) ; 
 + 
 + ArrayList < IEventListener > others = listeners . get ( target ) ; 
 + if ( others = = null ) 
 + { 
 + others = new ArrayList < IEventListener > ( ) ; 
 + listeners . put ( target , others ) ; 
 + } 
 + others . add ( listener ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + public void unregister ( Object object ) 
 + { 
 + ArrayList < IEventListener > list = listeners . remove ( object ) ; 
 + for ( IEventListener listener : list ) 
 + { 
 + ListenerList . unregisterAll ( busID , listener ) ; 
 + } 
 + } 
 + 
 + public boolean post ( Event event ) 
 + { 
 + IEventListener [ ] listeners = event . getListenerList ( ) . getListeners ( busID ) ; 
 + for ( IEventListener listener : listeners ) 
 + { 
 + listener . invoke ( event ) ; 
 + } 
 + return ( event . isCancelable ( ) ? event . isCanceled ( ) : false ) ; 
 + } 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventPriority . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventPriority . java 
 new file mode 100644 
 index 0000000 . . 6594db8 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventPriority . java 
 @ @ - 0 , 0 + 1 , 16 @ @ 
 + package cpw . mods . fml . common . eventhandler ; 
 + 
 + public enum EventPriority 
 + { 
 + / * Priority of event listeners , listeners will be sorted with respect to this priority level . 
 + * 
 + * Note : 
 + * Due to using a ArrayList in the ListenerList , 
 + * these need to stay in a contiguous index starting at 0 . { Default ordinal } 
 + * / 
 + HIGHEST , / / First to execute 
 + HIGH , 
 + NORMAL , 
 + LOW , 
 + LOWEST / / Last to execute 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / IEventListener . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / IEventListener . java 
 new file mode 100644 
 index 0000000 . . f5eefd4 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / IEventListener . java 
 @ @ - 0 , 0 + 1 , 8 @ @ 
 + package cpw . mods . fml . common . eventhandler ; 
 + 
 + 
 + 
 + public interface IEventListener 
 + { 
 + public void invoke ( Event event ) ; 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / ListenerList . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ListenerList . java 
 new file mode 100644 
 index 0000000 . . ca9f666 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ListenerList . java 
 @ @ - 0 , 0 + 1 , 219 @ @ 
 + package cpw . mods . fml . common . eventhandler ; 
 + 
 + import java . util . * ; 
 + 
 + 
 + public class ListenerList 
 + { 
 + private static ArrayList < ListenerList > allLists = new ArrayList < ListenerList > ( ) ; 
 + private static int maxSize = 0 ; 
 + 
 + private ListenerList parent ; 
 + private ListenerListInst [ ] lists = new ListenerListInst [ 0 ] ; 
 + 
 + public ListenerList ( ) 
 + { 
 + allLists . add ( this ) ; 
 + resizeLists ( maxSize ) ; 
 + } 
 + 
 + public ListenerList ( ListenerList parent ) 
 + { 
 + allLists . add ( this ) ; 
 + this . parent = parent ; 
 + resizeLists ( maxSize ) ; 
 + } 
 + 
 + public static void resize ( int max ) 
 + { 
 + if ( max < = maxSize ) 
 + { 
 + return ; 
 + } 
 + for ( ListenerList list : allLists ) 
 + { 
 + list . resizeLists ( max ) ; 
 + } 
 + maxSize = max ; 
 + } 
 + 
 + public void resizeLists ( int max ) 
 + { 
 + if ( parent ! = null ) 
 + { 
 + parent . resizeLists ( max ) ; 
 + } 
 + 
 + if ( lists . length > = max ) 
 + { 
 + return ; 
 + } 
 + 
 + ListenerListInst [ ] newList = new ListenerListInst [ max ] ; 
 + int x = 0 ; 
 + for ( ; x < lists . length ; x + + ) 
 + { 
 + newList [ x ] = lists [ x ] ; 
 + } 
 + for ( ; x < max ; x + + ) 
 + { 
 + if ( parent ! = null ) 
 + { 
 + newList [ x ] = new ListenerListInst ( parent . getInstance ( x ) ) ; 
 + } 
 + else 
 + { 
 + newList [ x ] = new ListenerListInst ( ) ; 
 + } 
 + } 
 + lists = newList ; 
 + } 
 + 
 + public static void clearBusID ( int id ) 
 + { 
 + for ( ListenerList list : allLists ) 
 + { 
 + list . lists [ id ] . dispose ( ) ; 
 + } 
 + } 
 + 
 + protected ListenerListInst getInstance ( int id ) 
 + { 
 + return lists [ id ] ; 
 + } 
 + 
 + public IEventListener [ ] getListeners ( int id ) 
 + { 
 + return lists [ id ] . getListeners ( ) ; 
 + } 
 + 
 + public void register ( int id , EventPriority priority , IEventListener listener ) 
 + { 
 + lists [ id ] . register ( priority , listener ) ; 
 + } 
 + 
 + public void unregister ( int id , IEventListener listener ) 
 + { 
 + lists [ id ] . unregister ( listener ) ; 
 + } 
 + 
 + public static void unregisterAll ( int id , IEventListener listener ) 
 + { 
 + for ( ListenerList list : allLists ) 
 + { 
 + list . unregister ( id , listener ) ; 
 + } 
 + } 
 + 
 + private class ListenerListInst 
 + { 
 + private boolean rebuild = true ; 
 + private IEventListener [ ] listeners ; 
 + private ArrayList < ArrayList < IEventListener > > priorities ; 
 + private ListenerListInst parent ; 
 + 
 + private ListenerListInst ( ) 
 + { 
 + int count = EventPriority . values ( ) . length ; 
 + priorities = new ArrayList < ArrayList < IEventListener > > ( count ) ; 
 + 
 + for ( int x = 0 ; x < count ; x + + ) 
 + { 
 + priorities . add ( new ArrayList < IEventListener > ( ) ) ; 
 + } 
 + } 
 + 
 + public void dispose ( ) 
 + { 
 + for ( ArrayList < IEventListener > listeners : priorities ) 
 + { 
 + listeners . clear ( ) ; 
 + } 
 + priorities . clear ( ) ; 
 + parent = null ; 
 + listeners = null ; 
 + } 
 + 
 + private ListenerListInst ( ListenerListInst parent ) 
 + { 
 + this ( ) ; 
 + this . parent = parent ; 
 + } 
 + 
 + / * * 
 + * Returns a ArrayList containing all listeners for this event , 
 + * and all parent events for the specified priority . 
 + * 
 + * The list is returned with the listeners for the children events first . 
 + * 
 + * @ param priority The Priority to get 
 + * @ return ArrayList containing listeners 
 + * / 
 + public ArrayList < IEventListener > getListeners ( EventPriority priority ) 
 + { 
 + ArrayList < IEventListener > ret = new ArrayList < IEventListener > ( priorities . get ( priority . ordinal ( ) ) ) ; 
 + if ( parent ! = null ) 
 + { 
 + ret . addAll ( parent . getListeners ( priority ) ) ; 
 + } 
 + return ret ; 
 + } 
 + 
 + / * * 
 + * Returns a full list of all listeners for all priority levels . 
 + * Including all parent listeners . 
 + * 
 + * List is returned in proper priority order . 
 + * 
 + * Automatically rebuilds the internal Array cache if its information is out of date . 
 + * 
 + * @ return Array containing listeners 
 + * / 
 + public IEventListener [ ] getListeners ( ) 
 + { 
 + if ( shouldRebuild ( ) ) buildCache ( ) ; 
 + return listeners ; 
 + } 
 + 
 + protected boolean shouldRebuild ( ) 
 + { 
 + return rebuild | | ( parent ! = null & & parent . shouldRebuild ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Rebuild the local Array of listeners , returns early if there is no work to do . 
 + * / 
 + private void buildCache ( ) 
 + { 
 + if ( parent ! = null & & parent . shouldRebuild ( ) ) 
 + { 
 + parent . buildCache ( ) ; 
 + } 
 + 
 + ArrayList < IEventListener > ret = new ArrayList < IEventListener > ( ) ; 
 + for ( EventPriority value : EventPriority . values ( ) ) 
 + { 
 + ret . addAll ( getListeners ( value ) ) ; 
 + } 
 + listeners = ret . toArray ( new IEventListener [ ret . size ( ) ] ) ; 
 + rebuild = false ; 
 + } 
 + 
 + public void register ( EventPriority priority , IEventListener listener ) 
 + { 
 + priorities . get ( priority . ordinal ( ) ) . add ( listener ) ; 
 + rebuild = true ; 
 + } 
 + 
 + public void unregister ( IEventListener listener ) 
 + { 
 + for ( ArrayList < IEventListener > list : priorities ) 
 + { 
 + if ( list . remove ( listener ) ) 
 + { 
 + rebuild = true ; 
 + } 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / SubscribeEvent . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / SubscribeEvent . java 
 new file mode 100644 
 index 0000000 . . 6effc42 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / SubscribeEvent . java 
 @ @ - 0 , 0 + 1 , 15 @ @ 
 + package cpw . mods . fml . common . eventhandler ; 
 + 
 + import java . lang . annotation . Retention ; 
 + import java . lang . annotation . Target ; 
 + 
 + import static java . lang . annotation . RetentionPolicy . * ; 
 + import static java . lang . annotation . ElementType . * ; 
 + 
 + @ Retention ( value = RUNTIME ) 
 + @ Target ( value = METHOD ) 
 + public @ interface SubscribeEvent 
 + { 
 + public EventPriority priority ( ) default EventPriority . NORMAL ; 
 + public boolean receiveCanceled ( ) default false ; 
 + }
