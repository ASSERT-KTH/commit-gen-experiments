BLEU SCORE: 0.0367352656298894

TEST MSG: Fixed registry issues that prevented connecting to 1 . 8 Forge servers .
GENERATED MSG: OK , this is finally actually working , I think . . .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> index 43a8474 . . 92c2258 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> @ @ - 267 , 7 + 267 , 7 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> ResourceLocation entryLoc ; <nl> if ( " fml : blocks " . equals ( key ) ) entryLoc = PersistentRegistryManager . BLOCKS ; <nl> else if ( " fml : items " . equals ( key ) ) entryLoc = PersistentRegistryManager . ITEMS ; <nl> - else if ( " fmlgr : villagerprofessions " . equals ( key ) ) entryLoc = new ResourceLocation ( " minecraft : villagerprofessions " ) ; <nl> + else if ( " fmlgr : villagerprofessions " . equals ( key ) ) entryLoc = VillagerRegistry . PROFESSIONS ; <nl> else entryLoc = new ResourceLocation ( key ) ; <nl> snapshot . entries . put ( entryLoc , entry ) ; <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> index e358478 . . 073f07a 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> @ @ - 713 , 4 + 713 , 15 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> { <nl> blockedIds . add ( id ) ; <nl> } <nl> + <nl> + public void noitifyCallbacks ( ) <nl> + { <nl> + if ( addCallback = = null ) <nl> + return ; <nl> + <nl> + for ( I i : this . underlyingIntegerMap ) <nl> + { <nl> + addCallback . onAdd ( i , this . underlyingIntegerMap . get ( i ) ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> index daf8b66 . . 955c6b4 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> @ @ - 23 , 11 + 23 , 13 @ @ import net . minecraft . block . Block ; <nl> import net . minecraft . item . Item ; <nl> import net . minecraft . potion . Potion ; <nl> import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . fml . common . EnhancedRuntimeException ; <nl> import net . minecraftforge . fml . common . FMLCommonHandler ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> import net . minecraftforge . fml . common . Loader ; <nl> import net . minecraftforge . fml . common . StartupQuery ; <nl> import net . minecraftforge . fml . common . ZipperUtil ; <nl> + import net . minecraftforge . fml . common . EnhancedRuntimeException . WrappedPrintStream ; <nl> import net . minecraftforge . fml . common . event . FMLMissingMappingsEvent ; <nl> <nl> / * * <nl> @ @ - 138 , 7 + 140 , 7 @ @ public class PersistentRegistryManager <nl> <nl> public static List < String > injectSnapshot ( GameDataSnapshot snapshot , boolean injectFrozenData , boolean isLocalWorld ) <nl> { <nl> - FMLLog . info ( " Injecting existing block and item data into this { } instance " , FMLCommonHandler . instance ( ) . getEffectiveSide ( ) . isServer ( ) ? " server " : " client " ) ; <nl> + FMLLog . info ( " Injecting existing block and item data into this % s instance " , FMLCommonHandler . instance ( ) . getEffectiveSide ( ) . isServer ( ) ? " server " : " client " ) ; <nl> final Map < ResourceLocation , Map < ResourceLocation , Integer [ ] > > remaps = Maps . newHashMap ( ) ; <nl> final LinkedHashMap < ResourceLocation , Map < ResourceLocation , Integer > > missing = Maps . newLinkedHashMap ( ) ; <nl> <nl> @ @ - 208 , 11 + 210 , 40 @ @ public class PersistentRegistryManager <nl> } <nl> } <nl> <nl> - private static < T > void loadRegistry ( ResourceLocation registryName , PersistentRegistry from , PersistentRegistry to , Class < T > regType ) <nl> + private static < T > void loadRegistry ( final ResourceLocation registryName , final PersistentRegistry from , final PersistentRegistry to , Class < T > regType ) <nl> { <nl> FMLControlledNamespacedRegistry < T > fromRegistry = from . getRegistry ( registryName , regType ) ; <nl> - FMLControlledNamespacedRegistry < T > toRegistry = to . getOrShallowCopyRegistry ( registryName , regType , fromRegistry ) ; <nl> - toRegistry . set ( fromRegistry ) ; <nl> + if ( fromRegistry = = null ) <nl> + { <nl> + FMLControlledNamespacedRegistry < T > toRegistry = to . getRegistry ( registryName , regType ) ; <nl> + if ( toRegistry = = null ) <nl> + { <nl> + throw new EnhancedRuntimeException ( " Could not find registry to load : " + registryName ) { <nl> + private static final long serialVersionUID = 1L ; <nl> + @ Override <nl> + protected void printStackTrace ( WrappedPrintStream stream ) <nl> + { <nl> + stream . println ( " Looking For : " + registryName ) ; <nl> + stream . println ( " Found From : " ) ; <nl> + for ( ResourceLocation name : from . registries . keySet ( ) ) <nl> + stream . println ( " " + name ) ; <nl> + stream . println ( " Found To : " ) ; <nl> + for ( ResourceLocation name : to . registries . keySet ( ) ) <nl> + stream . println ( " " + name ) ; <nl> + } <nl> + } ; <nl> + } <nl> + / / We found it in to , so lets trust to ' s state . . . <nl> + / / This happens when connecting to a server that doesn ' t have this registry . <nl> + / / Such as a 1 . 8 . 0 Forge server with 1 . 8 . 8 + Forge . <nl> + / / We must however , re - fire the callbacks as some internal data may be corrupted { potions } <nl> + toRegistry . noitifyCallbacks ( ) ; <nl> + } <nl> + else <nl> + { <nl> + FMLControlledNamespacedRegistry < T > toRegistry = to . getOrShallowCopyRegistry ( registryName , regType , fromRegistry ) ; <nl> + toRegistry . set ( fromRegistry ) ; <nl> + } <nl> } <nl> <nl> private static < T > void loadFrozenDataToStagingRegistry ( Map < ResourceLocation , Map < ResourceLocation , Integer [ ] > > remaps , ResourceLocation registryName , Class < T > regType ) <nl> @ @ - 225 , 10 + 256 , 16 @ @ public class PersistentRegistryManager <nl> private static < T > void loadPersistentDataToStagingRegistry ( boolean injectFrozenData , Map < ResourceLocation , Map < ResourceLocation , Integer [ ] > > remaps , LinkedHashMap < ResourceLocation , Map < ResourceLocation , Integer > > missing , Map . Entry < ResourceLocation , GameDataSnapshot . Entry > snapEntry , Class < T > regType ) <nl> { <nl> ResourceLocation registryName = snapEntry . getKey ( ) ; <nl> + <nl> + / / Translate old names <nl> + if ( " fml : blocks " . equals ( registryName . toString ( ) ) ) registryName = PersistentRegistryManager . BLOCKS ; <nl> + else if ( " fml : items " . equals ( registryName . toString ( ) ) ) registryName = PersistentRegistryManager . ITEMS ; <nl> + else if ( " fmlgr : villagerprofessions " . equals ( registryName . toString ( ) ) ) registryName = VillagerRegistry . PROFESSIONS ; <nl> + <nl> FMLControlledNamespacedRegistry < T > currentRegistry = PersistentRegistry . ACTIVE . getRegistry ( registryName , regType ) ; <nl> if ( currentRegistry = = null ) <nl> { <nl> - FMLLog . severe ( " An unknown persistent registry type { } has been encountered . This Forge instance cannot understand it . " , registryName ) ; <nl> + FMLLog . severe ( " An unknown persistent registry type \ " % s \ " has been encountered . This Forge instance cannot understand it . " , registryName ) ; <nl> StartupQuery . abort ( ) ; <nl> } <nl> FMLControlledNamespacedRegistry < T > newRegistry = PersistentRegistry . STAGING . getOrShallowCopyRegistry ( registryName , regType , currentRegistry ) ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java <nl> index 17c37c1 . . 7eef45e 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java <nl> @ @ - 53 , 6 + 53 , 7 @ @ import net . minecraftforge . fml . relauncher . SideOnly ; <nl> * / <nl> public class VillagerRegistry <nl> { <nl> + public static final ResourceLocation PROFESSIONS = new ResourceLocation ( " minecraft : villagerprofessions " ) ; <nl> private static final VillagerRegistry INSTANCE = new VillagerRegistry ( ) ; <nl> <nl> private Map < Class < ? > , IVillageCreationHandler > villageCreationHandlers = Maps . newHashMap ( ) ; <nl> @ @ - 206 , 7 + 207 , 7 @ @ public class VillagerRegistry <nl> } <nl> <nl> private boolean hasInit = false ; <nl> - private FMLControlledNamespacedRegistry < VillagerProfession > professions = PersistentRegistryManager . createRegistry ( new ResourceLocation ( " minecraft : villagerprofessions " ) , VillagerProfession . class , null , 1024 , 0 , true , null ) ; <nl> + private FMLControlledNamespacedRegistry < VillagerProfession > professions = PersistentRegistryManager . createRegistry ( PROFESSIONS , VillagerProfession . class , null , 1024 , 0 , true , null ) ; <nl> <nl> <nl> private void init ( )
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / fml / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> index 0236046 . . bf2fd34 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> @ @ - 32 , 10 + 32 , 12 @ @ import net . minecraftforge . fml . client . FMLFileResourcePack ; <nl> import net . minecraftforge . fml . client . FMLFolderResourcePack ; <nl> import net . minecraftforge . fml . common . asm . FMLSanityChecker ; <nl> import net . minecraftforge . fml . common . event . FMLConstructionEvent ; <nl> + import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> import net . minecraftforge . fml . common . network . NetworkCheckHandler ; <nl> import net . minecraftforge . fml . common . network . NetworkRegistry ; <nl> import net . minecraftforge . fml . common . network . internal . FMLNetworkHandler ; <nl> import net . minecraftforge . fml . common . registry . GameData ; <nl> + import net . minecraftforge . fml . common . registry . VillagerRegistry ; <nl> import net . minecraftforge . fml . relauncher . Side ; <nl> <nl> import org . apache . logging . log4j . Level ; <nl> @ @ - 84 , 6 + 86 , 13 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> FMLNetworkHandler . registerChannel ( this , evt . getSide ( ) ) ; <nl> } <nl> <nl> + @ Subscribe <nl> + public void modPreinitialization ( FMLPreInitializationEvent evt ) <nl> + { <nl> + / / Initialize the villager registry <nl> + VillagerRegistry . instance ( ) ; <nl> + } <nl> + <nl> @ NetworkCheckHandler <nl> public boolean checkModLists ( Map < String , String > modList , Side side ) <nl> { <nl> diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java b / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java <nl> index f1f0ee3 . . 7fd1bca 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java <nl> @ @ - 52 , 6 + 52 , 7 @ @ import com . google . common . base . Joiner . MapJoiner ; <nl> import com . google . common . collect . BiMap ; <nl> import com . google . common . collect . HashBasedTable ; <nl> import com . google . common . collect . HashBiMap ; <nl> + import com . google . common . collect . ImmutableBiMap ; <nl> import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . ImmutableListMultimap ; <nl> import com . google . common . collect . ImmutableMap ; <nl> @ @ - 709 , 15 + 710 , 18 @ @ public class GameData { <nl> <nl> int register ( Object obj , String name , int idHint ) / / from FMLControlledNamespacedRegistry . addObject <nl> { <nl> - / / tolerate extra name prefixes here since mc does it as well <nl> - name = addPrefix ( name ) ; <nl> - <nl> if ( obj instanceof Block ) <nl> { <nl> + / / tolerate extra name prefixes here since mc does it as well <nl> + name = addPrefix ( name ) ; <nl> + <nl> return registerBlock ( ( Block ) obj , name , idHint ) ; <nl> } <nl> else if ( obj instanceof Item ) <nl> { <nl> + / / tolerate extra name prefixes here since mc does it as well <nl> + name = addPrefix ( name ) ; <nl> + <nl> return registerItem ( ( Item ) obj , name , idHint ) ; <nl> } <nl> else <nl> @ @ - 963 , 7 + 967 , 7 @ @ public class GameData { <nl> } <nl> else <nl> { <nl> - throw new RuntimeException ( " WHAT ? " ) ; <nl> + return ImmutableBiMap . of ( ) ; <nl> } <nl> } <nl> <nl> @ @ - 1058 , 6 + 1062 , 12 @ @ public class GameData { <nl> String regName = e . getKey ( ) ; <nl> FMLControlledNamespacedRegistry < ? > registry = e . getValue ( ) ; <nl> FMLControlledNamespacedRegistry < ? > newRegistry = genericRegistries . get ( regName ) ; <nl> + if ( newRegistry = = null ) <nl> + { <nl> + newRegistry = registry . makeShallowCopy ( ) ; <nl> + genericRegistries . put ( regName , newRegistry ) ; <nl> + } <nl> + <nl> GameDataSnapshot . Entry regSnap = snapshot . entries . get ( " fmlgr : " + regName ) ; <nl> if ( regSnap = = null ) { <nl> FMLLog . info ( " Weird , there was no registry data for registry % s found in the snapshot " , regName ) ; <nl> @ @ - 1081 , 7 + 1091 , 8 @ @ public class GameData { <nl> FMLLog . fine ( " Fixed registry % s id mismatch % s : % d ( init ) - > % d ( map ) . " , regName , entryName , currId , entryId ) ; <nl> } <nl> <nl> - newRegistry . register ( entryId , entryName , registry . getRaw ( entryName ) ) ; <nl> + <nl> + newRegistry . add ( entryId , entryName , registry . getRaw ( entryName ) ) ; <nl> <nl> } <nl> }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 index 43a8474 . . 92c2258 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 @ @ - 267 , 7 + 267 , 7 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 ResourceLocation entryLoc ; 
 if ( " fml : blocks " . equals ( key ) ) entryLoc = PersistentRegistryManager . BLOCKS ; 
 else if ( " fml : items " . equals ( key ) ) entryLoc = PersistentRegistryManager . ITEMS ; 
 - else if ( " fmlgr : villagerprofessions " . equals ( key ) ) entryLoc = new ResourceLocation ( " minecraft : villagerprofessions " ) ; 
 + else if ( " fmlgr : villagerprofessions " . equals ( key ) ) entryLoc = VillagerRegistry . PROFESSIONS ; 
 else entryLoc = new ResourceLocation ( key ) ; 
 snapshot . entries . put ( entryLoc , entry ) ; 
 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 index e358478 . . 073f07a 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 @ @ - 713 , 4 + 713 , 15 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 { 
 blockedIds . add ( id ) ; 
 } 
 + 
 + public void noitifyCallbacks ( ) 
 + { 
 + if ( addCallback = = null ) 
 + return ; 
 + 
 + for ( I i : this . underlyingIntegerMap ) 
 + { 
 + addCallback . onAdd ( i , this . underlyingIntegerMap . get ( i ) ) ; 
 + } 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 index daf8b66 . . 955c6b4 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 @ @ - 23 , 11 + 23 , 13 @ @ import net . minecraft . block . Block ; 
 import net . minecraft . item . Item ; 
 import net . minecraft . potion . Potion ; 
 import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . fml . common . EnhancedRuntimeException ; 
 import net . minecraftforge . fml . common . FMLCommonHandler ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 import net . minecraftforge . fml . common . Loader ; 
 import net . minecraftforge . fml . common . StartupQuery ; 
 import net . minecraftforge . fml . common . ZipperUtil ; 
 + import net . minecraftforge . fml . common . EnhancedRuntimeException . WrappedPrintStream ; 
 import net . minecraftforge . fml . common . event . FMLMissingMappingsEvent ; 
 
 / * * 
 @ @ - 138 , 7 + 140 , 7 @ @ public class PersistentRegistryManager 
 
 public static List < String > injectSnapshot ( GameDataSnapshot snapshot , boolean injectFrozenData , boolean isLocalWorld ) 
 { 
 - FMLLog . info ( " Injecting existing block and item data into this { } instance " , FMLCommonHandler . instance ( ) . getEffectiveSide ( ) . isServer ( ) ? " server " : " client " ) ; 
 + FMLLog . info ( " Injecting existing block and item data into this % s instance " , FMLCommonHandler . instance ( ) . getEffectiveSide ( ) . isServer ( ) ? " server " : " client " ) ; 
 final Map < ResourceLocation , Map < ResourceLocation , Integer [ ] > > remaps = Maps . newHashMap ( ) ; 
 final LinkedHashMap < ResourceLocation , Map < ResourceLocation , Integer > > missing = Maps . newLinkedHashMap ( ) ; 
 
 @ @ - 208 , 11 + 210 , 40 @ @ public class PersistentRegistryManager 
 } 
 } 
 
 - private static < T > void loadRegistry ( ResourceLocation registryName , PersistentRegistry from , PersistentRegistry to , Class < T > regType ) 
 + private static < T > void loadRegistry ( final ResourceLocation registryName , final PersistentRegistry from , final PersistentRegistry to , Class < T > regType ) 
 { 
 FMLControlledNamespacedRegistry < T > fromRegistry = from . getRegistry ( registryName , regType ) ; 
 - FMLControlledNamespacedRegistry < T > toRegistry = to . getOrShallowCopyRegistry ( registryName , regType , fromRegistry ) ; 
 - toRegistry . set ( fromRegistry ) ; 
 + if ( fromRegistry = = null ) 
 + { 
 + FMLControlledNamespacedRegistry < T > toRegistry = to . getRegistry ( registryName , regType ) ; 
 + if ( toRegistry = = null ) 
 + { 
 + throw new EnhancedRuntimeException ( " Could not find registry to load : " + registryName ) { 
 + private static final long serialVersionUID = 1L ; 
 + @ Override 
 + protected void printStackTrace ( WrappedPrintStream stream ) 
 + { 
 + stream . println ( " Looking For : " + registryName ) ; 
 + stream . println ( " Found From : " ) ; 
 + for ( ResourceLocation name : from . registries . keySet ( ) ) 
 + stream . println ( " " + name ) ; 
 + stream . println ( " Found To : " ) ; 
 + for ( ResourceLocation name : to . registries . keySet ( ) ) 
 + stream . println ( " " + name ) ; 
 + } 
 + } ; 
 + } 
 + / / We found it in to , so lets trust to ' s state . . . 
 + / / This happens when connecting to a server that doesn ' t have this registry . 
 + / / Such as a 1 . 8 . 0 Forge server with 1 . 8 . 8 + Forge . 
 + / / We must however , re - fire the callbacks as some internal data may be corrupted { potions } 
 + toRegistry . noitifyCallbacks ( ) ; 
 + } 
 + else 
 + { 
 + FMLControlledNamespacedRegistry < T > toRegistry = to . getOrShallowCopyRegistry ( registryName , regType , fromRegistry ) ; 
 + toRegistry . set ( fromRegistry ) ; 
 + } 
 } 
 
 private static < T > void loadFrozenDataToStagingRegistry ( Map < ResourceLocation , Map < ResourceLocation , Integer [ ] > > remaps , ResourceLocation registryName , Class < T > regType ) 
 @ @ - 225 , 10 + 256 , 16 @ @ public class PersistentRegistryManager 
 private static < T > void loadPersistentDataToStagingRegistry ( boolean injectFrozenData , Map < ResourceLocation , Map < ResourceLocation , Integer [ ] > > remaps , LinkedHashMap < ResourceLocation , Map < ResourceLocation , Integer > > missing , Map . Entry < ResourceLocation , GameDataSnapshot . Entry > snapEntry , Class < T > regType ) 
 { 
 ResourceLocation registryName = snapEntry . getKey ( ) ; 
 + 
 + / / Translate old names 
 + if ( " fml : blocks " . equals ( registryName . toString ( ) ) ) registryName = PersistentRegistryManager . BLOCKS ; 
 + else if ( " fml : items " . equals ( registryName . toString ( ) ) ) registryName = PersistentRegistryManager . ITEMS ; 
 + else if ( " fmlgr : villagerprofessions " . equals ( registryName . toString ( ) ) ) registryName = VillagerRegistry . PROFESSIONS ; 
 + 
 FMLControlledNamespacedRegistry < T > currentRegistry = PersistentRegistry . ACTIVE . getRegistry ( registryName , regType ) ; 
 if ( currentRegistry = = null ) 
 { 
 - FMLLog . severe ( " An unknown persistent registry type { } has been encountered . This Forge instance cannot understand it . " , registryName ) ; 
 + FMLLog . severe ( " An unknown persistent registry type \ " % s \ " has been encountered . This Forge instance cannot understand it . " , registryName ) ; 
 StartupQuery . abort ( ) ; 
 } 
 FMLControlledNamespacedRegistry < T > newRegistry = PersistentRegistry . STAGING . getOrShallowCopyRegistry ( registryName , regType , currentRegistry ) ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java 
 index 17c37c1 . . 7eef45e 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java 
 @ @ - 53 , 6 + 53 , 7 @ @ import net . minecraftforge . fml . relauncher . SideOnly ; 
 * / 
 public class VillagerRegistry 
 { 
 + public static final ResourceLocation PROFESSIONS = new ResourceLocation ( " minecraft : villagerprofessions " ) ; 
 private static final VillagerRegistry INSTANCE = new VillagerRegistry ( ) ; 
 
 private Map < Class < ? > , IVillageCreationHandler > villageCreationHandlers = Maps . newHashMap ( ) ; 
 @ @ - 206 , 7 + 207 , 7 @ @ public class VillagerRegistry 
 } 
 
 private boolean hasInit = false ; 
 - private FMLControlledNamespacedRegistry < VillagerProfession > professions = PersistentRegistryManager . createRegistry ( new ResourceLocation ( " minecraft : villagerprofessions " ) , VillagerProfession . class , null , 1024 , 0 , true , null ) ; 
 + private FMLControlledNamespacedRegistry < VillagerProfession > professions = PersistentRegistryManager . createRegistry ( PROFESSIONS , VillagerProfession . class , null , 1024 , 0 , true , null ) ; 
 
 
 private void init ( )

NEAREST DIFF:
diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / fml / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 index 0236046 . . bf2fd34 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 @ @ - 32 , 10 + 32 , 12 @ @ import net . minecraftforge . fml . client . FMLFileResourcePack ; 
 import net . minecraftforge . fml . client . FMLFolderResourcePack ; 
 import net . minecraftforge . fml . common . asm . FMLSanityChecker ; 
 import net . minecraftforge . fml . common . event . FMLConstructionEvent ; 
 + import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 import net . minecraftforge . fml . common . network . NetworkCheckHandler ; 
 import net . minecraftforge . fml . common . network . NetworkRegistry ; 
 import net . minecraftforge . fml . common . network . internal . FMLNetworkHandler ; 
 import net . minecraftforge . fml . common . registry . GameData ; 
 + import net . minecraftforge . fml . common . registry . VillagerRegistry ; 
 import net . minecraftforge . fml . relauncher . Side ; 
 
 import org . apache . logging . log4j . Level ; 
 @ @ - 84 , 6 + 86 , 13 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 FMLNetworkHandler . registerChannel ( this , evt . getSide ( ) ) ; 
 } 
 
 + @ Subscribe 
 + public void modPreinitialization ( FMLPreInitializationEvent evt ) 
 + { 
 + / / Initialize the villager registry 
 + VillagerRegistry . instance ( ) ; 
 + } 
 + 
 @ NetworkCheckHandler 
 public boolean checkModLists ( Map < String , String > modList , Side side ) 
 { 
 diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java b / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java 
 index f1f0ee3 . . 7fd1bca 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java 
 @ @ - 52 , 6 + 52 , 7 @ @ import com . google . common . base . Joiner . MapJoiner ; 
 import com . google . common . collect . BiMap ; 
 import com . google . common . collect . HashBasedTable ; 
 import com . google . common . collect . HashBiMap ; 
 + import com . google . common . collect . ImmutableBiMap ; 
 import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . ImmutableListMultimap ; 
 import com . google . common . collect . ImmutableMap ; 
 @ @ - 709 , 15 + 710 , 18 @ @ public class GameData { 
 
 int register ( Object obj , String name , int idHint ) / / from FMLControlledNamespacedRegistry . addObject 
 { 
 - / / tolerate extra name prefixes here since mc does it as well 
 - name = addPrefix ( name ) ; 
 - 
 if ( obj instanceof Block ) 
 { 
 + / / tolerate extra name prefixes here since mc does it as well 
 + name = addPrefix ( name ) ; 
 + 
 return registerBlock ( ( Block ) obj , name , idHint ) ; 
 } 
 else if ( obj instanceof Item ) 
 { 
 + / / tolerate extra name prefixes here since mc does it as well 
 + name = addPrefix ( name ) ; 
 + 
 return registerItem ( ( Item ) obj , name , idHint ) ; 
 } 
 else 
 @ @ - 963 , 7 + 967 , 7 @ @ public class GameData { 
 } 
 else 
 { 
 - throw new RuntimeException ( " WHAT ? " ) ; 
 + return ImmutableBiMap . of ( ) ; 
 } 
 } 
 
 @ @ - 1058 , 6 + 1062 , 12 @ @ public class GameData { 
 String regName = e . getKey ( ) ; 
 FMLControlledNamespacedRegistry < ? > registry = e . getValue ( ) ; 
 FMLControlledNamespacedRegistry < ? > newRegistry = genericRegistries . get ( regName ) ; 
 + if ( newRegistry = = null ) 
 + { 
 + newRegistry = registry . makeShallowCopy ( ) ; 
 + genericRegistries . put ( regName , newRegistry ) ; 
 + } 
 + 
 GameDataSnapshot . Entry regSnap = snapshot . entries . get ( " fmlgr : " + regName ) ; 
 if ( regSnap = = null ) { 
 FMLLog . info ( " Weird , there was no registry data for registry % s found in the snapshot " , regName ) ; 
 @ @ - 1081 , 7 + 1091 , 8 @ @ public class GameData { 
 FMLLog . fine ( " Fixed registry % s id mismatch % s : % d ( init ) - > % d ( map ) . " , regName , entryName , currId , entryId ) ; 
 } 
 
 - newRegistry . register ( entryId , entryName , registry . getRaw ( entryName ) ) ; 
 + 
 + newRegistry . add ( entryId , entryName , registry . getRaw ( entryName ) ) ; 
 
 } 
 }
