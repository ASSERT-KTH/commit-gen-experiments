BLEU SCORE: 0.17542198478193427

TEST MSG: Only remove synthetic lambda methods referenced in body of SideOnly methods
GENERATED MSG: Remove dynamic lambda methods when inside of SideOnly methods

TEST DIFF (one line): diff - - git a / src / fmllauncher / java / net / minecraftforge / fml / loading / RuntimeDistCleaner . java b / src / fmllauncher / java / net / minecraftforge / fml / loading / RuntimeDistCleaner . java <nl> index 71fd2b7 . . f8cb738 100644 <nl> - - - a / src / fmllauncher / java / net / minecraftforge / fml / loading / RuntimeDistCleaner . java <nl> + + + b / src / fmllauncher / java / net / minecraftforge / fml / loading / RuntimeDistCleaner . java <nl> @ @ - 93 , 20 + 93 , 23 @ @ public class RuntimeDistCleaner implements ILaunchPluginService <nl> } <nl> } <nl> <nl> - / / remove dynamic lambda methods that are inside of removed methods <nl> - List < Handle > dynamicLambdaHandles = lambdaGatherer . getDynamicLambdaHandles ( ) ; <nl> - if ( ! dynamicLambdaHandles . isEmpty ( ) ) <nl> + / / remove dynamic synthetic lambda methods that are inside of removed methods <nl> + for ( List < Handle > dynamicLambdaHandles = lambdaGatherer . getDynamicLambdaHandles ( ) ; <nl> + ! dynamicLambdaHandles . isEmpty ( ) ; dynamicLambdaHandles = lambdaGatherer . getDynamicLambdaHandles ( ) ) <nl> { <nl> + lambdaGatherer = new LambdaGatherer ( ) ; <nl> methods = classNode . methods . iterator ( ) ; <nl> while ( methods . hasNext ( ) ) <nl> { <nl> MethodNode method = methods . next ( ) ; <nl> + if ( ( method . access & Opcodes . ACC _ SYNTHETIC ) = = 0 ) continue ; <nl> for ( Handle dynamicLambdaHandle : dynamicLambdaHandles ) <nl> { <nl> if ( method . name . equals ( dynamicLambdaHandle . getName ( ) ) & & method . desc . equals ( dynamicLambdaHandle . getDesc ( ) ) ) <nl> { <nl> LOGGER . debug ( DISTXFORM , " Removing lambda method : { } . { } { } " , classNode . name , method . name , method . desc ) ; <nl> methods . remove ( ) ; <nl> + lambdaGatherer . accept ( method ) ; <nl> changes . compareAndSet ( false , true ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / asm / transformers / SideTransformer . java b / src / main / java / net / minecraftforge / fml / common / asm / transformers / SideTransformer . java <nl> index 68e6c1f . . 4c1d0b5 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / asm / transformers / SideTransformer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / asm / transformers / SideTransformer . java <nl> @ @ - 19 , 8 + 19 , 10 @ @ <nl> <nl> package net . minecraftforge . fml . common . asm . transformers ; <nl> <nl> + import java . util . ArrayList ; <nl> import java . util . Iterator ; <nl> import java . util . List ; <nl> + import java . util . ListIterator ; <nl> <nl> import net . minecraft . launchwrapper . IClassTransformer ; <nl> import net . minecraftforge . fml . relauncher . FMLLaunchHandler ; <nl> @ @ - 28 , 7 + 30 , 11 @ @ import net . minecraftforge . fml . relauncher . SideOnly ; <nl> <nl> import org . objectweb . asm . ClassReader ; <nl> import org . objectweb . asm . ClassWriter ; <nl> + import org . objectweb . asm . Handle ; <nl> + import org . objectweb . asm . MethodVisitor ; <nl> + import org . objectweb . asm . Opcodes ; <nl> import org . objectweb . asm . Type ; <nl> + import org . objectweb . asm . tree . AbstractInsnNode ; <nl> import org . objectweb . asm . tree . AnnotationNode ; <nl> import org . objectweb . asm . tree . ClassNode ; <nl> import org . objectweb . asm . tree . FieldNode ; <nl> @ @ - 69 , 6 + 75 , 8 @ @ public class SideTransformer implements IClassTransformer <nl> fields . remove ( ) ; <nl> } <nl> } <nl> + <nl> + LambdaGatherer lambdaGatherer = new LambdaGatherer ( ) ; <nl> Iterator < MethodNode > methods = classNode . methods . iterator ( ) ; <nl> while ( methods . hasNext ( ) ) <nl> { <nl> @ @ - 80 , 6 + 88 , 29 @ @ public class SideTransformer implements IClassTransformer <nl> System . out . println ( String . format ( " Removing Method : % s . % s % s " , classNode . name , method . name , method . desc ) ) ; <nl> } <nl> methods . remove ( ) ; <nl> + lambdaGatherer . accept ( method ) ; <nl> + } <nl> + } <nl> + <nl> + / / remove dynamic lambda methods that are inside of removed methods <nl> + List < Handle > dynamicLambdaHandles = lambdaGatherer . getDynamicLambdaHandles ( ) ; <nl> + if ( ! dynamicLambdaHandles . isEmpty ( ) ) <nl> + { <nl> + methods = classNode . methods . iterator ( ) ; <nl> + while ( methods . hasNext ( ) ) <nl> + { <nl> + MethodNode method = methods . next ( ) ; <nl> + for ( Handle dynamicLambdaHandle : dynamicLambdaHandles ) <nl> + { <nl> + if ( method . name . equals ( dynamicLambdaHandle . getName ( ) ) & & method . desc . equals ( dynamicLambdaHandle . getDesc ( ) ) ) <nl> + { <nl> + if ( DEBUG ) <nl> + { <nl> + System . out . println ( String . format ( " Removing Method : % s . % s % s " , classNode . name , method . name , method . desc ) ) ; <nl> + } <nl> + methods . remove ( ) ; <nl> + } <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 120 , 4 + 151 , 41 @ @ public class SideTransformer implements IClassTransformer <nl> } <nl> return false ; <nl> } <nl> + <nl> + private static class LambdaGatherer extends MethodVisitor { <nl> + private static final Handle META _ FACTORY = new Handle ( Opcodes . H _ INVOKESTATIC , " java / lang / invoke / LambdaMetafactory " , " metafactory " , <nl> + " ( Ljava / lang / invoke / MethodHandles $ Lookup ; Ljava / lang / String ; Ljava / lang / invoke / MethodType ; Ljava / lang / invoke / MethodType ; Ljava / lang / invoke / MethodHandle ; Ljava / lang / invoke / MethodType ; ) Ljava / lang / invoke / CallSite ; " ) ; <nl> + private final List < Handle > dynamicLambdaHandles = new ArrayList < Handle > ( ) ; <nl> + <nl> + public LambdaGatherer ( ) { <nl> + super ( Opcodes . ASM5 ) ; <nl> + } <nl> + <nl> + public void accept ( MethodNode method ) { <nl> + ListIterator < AbstractInsnNode > insnNodeIterator = method . instructions . iterator ( ) ; <nl> + while ( insnNodeIterator . hasNext ( ) ) <nl> + { <nl> + AbstractInsnNode insnNode = insnNodeIterator . next ( ) ; <nl> + if ( insnNode . getType ( ) = = AbstractInsnNode . INVOKE _ DYNAMIC _ INSN ) <nl> + { <nl> + insnNode . accept ( this ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void visitInvokeDynamicInsn ( String name , String desc , Handle bsm , Object . . . bsmArgs ) <nl> + { <nl> + if ( META _ FACTORY . equals ( bsm ) ) <nl> + { <nl> + Handle dynamicLambdaHandle = ( Handle ) bsmArgs [ 1 ] ; <nl> + dynamicLambdaHandles . add ( dynamicLambdaHandle ) ; <nl> + } <nl> + } <nl> + <nl> + public List < Handle > getDynamicLambdaHandles ( ) <nl> + { <nl> + return dynamicLambdaHandles ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> index 6e8f0cd . . 200c2f6 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> @ @ - 121 , 7 + 121 , 7 @ @ public class FMLControlledNamespacedRegistry < I extends IForgeRegistryEntry < I > > e <nl> { <nl> try <nl> { <nl> - ReflectionHelper . findMethod ( BitSet . class , this . availabilityMap , new String [ ] { " trimToSize " } ) . invoke ( this . availabilityMap ) ; <nl> + ReflectionHelper . findMethod ( BitSet . class , " trimToSize " , null ) . invoke ( this . availabilityMap ) ; <nl> } <nl> catch ( Exception e ) <nl> { <nl> diff - - git a / src / main / java / net / minecraftforge / fml / relauncher / ReflectionHelper . java b / src / main / java / net / minecraftforge / fml / relauncher / ReflectionHelper . java <nl> index 4017160 . . 0085625 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / relauncher / ReflectionHelper . java <nl> + + + b / src / main / java / net / minecraftforge / fml / relauncher / ReflectionHelper . java <nl> @ @ - 18 , 6 + 18 , 11 @ @ <nl> * / <nl> package net . minecraftforge . fml . relauncher ; <nl> <nl> + import com . google . common . base . Preconditions ; <nl> + import net . minecraft . launchwrapper . Launch ; <nl> + import org . apache . commons . lang3 . StringUtils ; <nl> + <nl> + import javax . annotation . Nonnull ; <nl> import javax . annotation . Nullable ; <nl> import java . lang . reflect . Field ; <nl> import java . lang . reflect . Method ; <nl> @ @ - 40 , 6 + 45 , 11 @ @ public class ReflectionHelper <nl> / / this . methodNames = methodNames ; <nl> } <nl> <nl> + public UnableToFindMethodException ( Throwable failed ) <nl> + { <nl> + super ( failed ) ; <nl> + } <nl> + <nl> } <nl> <nl> public static class UnableToFindClassException extends RuntimeException <nl> @ @ - 170 , 10 + 180 , 13 @ @ public class ReflectionHelper <nl> throw new UnableToFindClassException ( classNames , err ) ; <nl> } <nl> <nl> - <nl> + / * * <nl> + * @ deprecated use { @ link # findMethod ( Class , String , String , Class [ ] ) } <nl> + * / <nl> + @ Deprecated <nl> public static < E > Method findMethod ( Class < ? super E > clazz , E instance , String [ ] methodNames , Class < ? > . . . methodTypes ) <nl> { <nl> - Exception failed = null ; <nl> + Throwable failed = null ; <nl> for ( String methodName : methodNames ) <nl> { <nl> try <nl> @ @ - 187 , 6 + 200 , 47 @ @ public class ReflectionHelper <nl> failed = e ; <nl> } <nl> } <nl> - throw new UnableToFindMethodException ( methodNames , failed ) ; <nl> + throw new UnableToFindMethodException ( failed ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Finds a method with the specified name and parameters in the given class and makes it accessible . <nl> + * Note : for performance , store the returned value and avoid calling this repeatedly . <nl> + * < p > <nl> + * Throws an exception if the method is not found . <nl> + * <nl> + * @ param clazz The class to find the method on . <nl> + * @ param methodName The name of the method to find ( used in developer environments , i . e . " getWorldTime " ) . <nl> + * @ param methodObfName The obfuscated name of the method to find ( used in obfuscated environments , i . e . " func _ 72820 _ D " ) . <nl> + * If the name you are looking for is on a class that is never obfuscated , this should be null . <nl> + * @ param parameterTypes The parameter types of the method to find . <nl> + * @ return The method with the specified name and parameters in the given class . <nl> + * / <nl> + @ Nonnull <nl> + public static Method findMethod ( @ Nonnull Class < ? > clazz , @ Nonnull String methodName , @ Nullable String methodObfName , Class < ? > . . . parameterTypes ) <nl> + { <nl> + Preconditions . checkNotNull ( clazz ) ; <nl> + Preconditions . checkArgument ( StringUtils . isNotEmpty ( methodName ) , " Method name cannot be empty " ) ; <nl> + <nl> + String nameToFind ; <nl> + if ( methodObfName = = null | | ( Boolean ) Launch . blackboard . get ( " fml . deobfuscatedEnvironment " ) ) <nl> + { <nl> + nameToFind = methodName ; <nl> + } <nl> + else <nl> + { <nl> + nameToFind = methodObfName ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + Method m = clazz . getDeclaredMethod ( nameToFind , parameterTypes ) ; <nl> + m . setAccessible ( true ) ; <nl> + return m ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new UnableToFindMethodException ( e ) ; <nl> + } <nl> } <nl> }

TEST DIFF:
diff - - git a / src / fmllauncher / java / net / minecraftforge / fml / loading / RuntimeDistCleaner . java b / src / fmllauncher / java / net / minecraftforge / fml / loading / RuntimeDistCleaner . java 
 index 71fd2b7 . . f8cb738 100644 
 - - - a / src / fmllauncher / java / net / minecraftforge / fml / loading / RuntimeDistCleaner . java 
 + + + b / src / fmllauncher / java / net / minecraftforge / fml / loading / RuntimeDistCleaner . java 
 @ @ - 93 , 20 + 93 , 23 @ @ public class RuntimeDistCleaner implements ILaunchPluginService 
 } 
 } 
 
 - / / remove dynamic lambda methods that are inside of removed methods 
 - List < Handle > dynamicLambdaHandles = lambdaGatherer . getDynamicLambdaHandles ( ) ; 
 - if ( ! dynamicLambdaHandles . isEmpty ( ) ) 
 + / / remove dynamic synthetic lambda methods that are inside of removed methods 
 + for ( List < Handle > dynamicLambdaHandles = lambdaGatherer . getDynamicLambdaHandles ( ) ; 
 + ! dynamicLambdaHandles . isEmpty ( ) ; dynamicLambdaHandles = lambdaGatherer . getDynamicLambdaHandles ( ) ) 
 { 
 + lambdaGatherer = new LambdaGatherer ( ) ; 
 methods = classNode . methods . iterator ( ) ; 
 while ( methods . hasNext ( ) ) 
 { 
 MethodNode method = methods . next ( ) ; 
 + if ( ( method . access & Opcodes . ACC _ SYNTHETIC ) = = 0 ) continue ; 
 for ( Handle dynamicLambdaHandle : dynamicLambdaHandles ) 
 { 
 if ( method . name . equals ( dynamicLambdaHandle . getName ( ) ) & & method . desc . equals ( dynamicLambdaHandle . getDesc ( ) ) ) 
 { 
 LOGGER . debug ( DISTXFORM , " Removing lambda method : { } . { } { } " , classNode . name , method . name , method . desc ) ; 
 methods . remove ( ) ; 
 + lambdaGatherer . accept ( method ) ; 
 changes . compareAndSet ( false , true ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / asm / transformers / SideTransformer . java b / src / main / java / net / minecraftforge / fml / common / asm / transformers / SideTransformer . java 
 index 68e6c1f . . 4c1d0b5 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / asm / transformers / SideTransformer . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / asm / transformers / SideTransformer . java 
 @ @ - 19 , 8 + 19 , 10 @ @ 
 
 package net . minecraftforge . fml . common . asm . transformers ; 
 
 + import java . util . ArrayList ; 
 import java . util . Iterator ; 
 import java . util . List ; 
 + import java . util . ListIterator ; 
 
 import net . minecraft . launchwrapper . IClassTransformer ; 
 import net . minecraftforge . fml . relauncher . FMLLaunchHandler ; 
 @ @ - 28 , 7 + 30 , 11 @ @ import net . minecraftforge . fml . relauncher . SideOnly ; 
 
 import org . objectweb . asm . ClassReader ; 
 import org . objectweb . asm . ClassWriter ; 
 + import org . objectweb . asm . Handle ; 
 + import org . objectweb . asm . MethodVisitor ; 
 + import org . objectweb . asm . Opcodes ; 
 import org . objectweb . asm . Type ; 
 + import org . objectweb . asm . tree . AbstractInsnNode ; 
 import org . objectweb . asm . tree . AnnotationNode ; 
 import org . objectweb . asm . tree . ClassNode ; 
 import org . objectweb . asm . tree . FieldNode ; 
 @ @ - 69 , 6 + 75 , 8 @ @ public class SideTransformer implements IClassTransformer 
 fields . remove ( ) ; 
 } 
 } 
 + 
 + LambdaGatherer lambdaGatherer = new LambdaGatherer ( ) ; 
 Iterator < MethodNode > methods = classNode . methods . iterator ( ) ; 
 while ( methods . hasNext ( ) ) 
 { 
 @ @ - 80 , 6 + 88 , 29 @ @ public class SideTransformer implements IClassTransformer 
 System . out . println ( String . format ( " Removing Method : % s . % s % s " , classNode . name , method . name , method . desc ) ) ; 
 } 
 methods . remove ( ) ; 
 + lambdaGatherer . accept ( method ) ; 
 + } 
 + } 
 + 
 + / / remove dynamic lambda methods that are inside of removed methods 
 + List < Handle > dynamicLambdaHandles = lambdaGatherer . getDynamicLambdaHandles ( ) ; 
 + if ( ! dynamicLambdaHandles . isEmpty ( ) ) 
 + { 
 + methods = classNode . methods . iterator ( ) ; 
 + while ( methods . hasNext ( ) ) 
 + { 
 + MethodNode method = methods . next ( ) ; 
 + for ( Handle dynamicLambdaHandle : dynamicLambdaHandles ) 
 + { 
 + if ( method . name . equals ( dynamicLambdaHandle . getName ( ) ) & & method . desc . equals ( dynamicLambdaHandle . getDesc ( ) ) ) 
 + { 
 + if ( DEBUG ) 
 + { 
 + System . out . println ( String . format ( " Removing Method : % s . % s % s " , classNode . name , method . name , method . desc ) ) ; 
 + } 
 + methods . remove ( ) ; 
 + } 
 + } 
 } 
 } 
 
 @ @ - 120 , 4 + 151 , 41 @ @ public class SideTransformer implements IClassTransformer 
 } 
 return false ; 
 } 
 + 
 + private static class LambdaGatherer extends MethodVisitor { 
 + private static final Handle META _ FACTORY = new Handle ( Opcodes . H _ INVOKESTATIC , " java / lang / invoke / LambdaMetafactory " , " metafactory " , 
 + " ( Ljava / lang / invoke / MethodHandles $ Lookup ; Ljava / lang / String ; Ljava / lang / invoke / MethodType ; Ljava / lang / invoke / MethodType ; Ljava / lang / invoke / MethodHandle ; Ljava / lang / invoke / MethodType ; ) Ljava / lang / invoke / CallSite ; " ) ; 
 + private final List < Handle > dynamicLambdaHandles = new ArrayList < Handle > ( ) ; 
 + 
 + public LambdaGatherer ( ) { 
 + super ( Opcodes . ASM5 ) ; 
 + } 
 + 
 + public void accept ( MethodNode method ) { 
 + ListIterator < AbstractInsnNode > insnNodeIterator = method . instructions . iterator ( ) ; 
 + while ( insnNodeIterator . hasNext ( ) ) 
 + { 
 + AbstractInsnNode insnNode = insnNodeIterator . next ( ) ; 
 + if ( insnNode . getType ( ) = = AbstractInsnNode . INVOKE _ DYNAMIC _ INSN ) 
 + { 
 + insnNode . accept ( this ) ; 
 + } 
 + } 
 + } 
 + 
 + @ Override 
 + public void visitInvokeDynamicInsn ( String name , String desc , Handle bsm , Object . . . bsmArgs ) 
 + { 
 + if ( META _ FACTORY . equals ( bsm ) ) 
 + { 
 + Handle dynamicLambdaHandle = ( Handle ) bsmArgs [ 1 ] ; 
 + dynamicLambdaHandles . add ( dynamicLambdaHandle ) ; 
 + } 
 + } 
 + 
 + public List < Handle > getDynamicLambdaHandles ( ) 
 + { 
 + return dynamicLambdaHandles ; 
 + } 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 index 6e8f0cd . . 200c2f6 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 @ @ - 121 , 7 + 121 , 7 @ @ public class FMLControlledNamespacedRegistry < I extends IForgeRegistryEntry < I > > e 
 { 
 try 
 { 
 - ReflectionHelper . findMethod ( BitSet . class , this . availabilityMap , new String [ ] { " trimToSize " } ) . invoke ( this . availabilityMap ) ; 
 + ReflectionHelper . findMethod ( BitSet . class , " trimToSize " , null ) . invoke ( this . availabilityMap ) ; 
 } 
 catch ( Exception e ) 
 { 
 diff - - git a / src / main / java / net / minecraftforge / fml / relauncher / ReflectionHelper . java b / src / main / java / net / minecraftforge / fml / relauncher / ReflectionHelper . java 
 index 4017160 . . 0085625 100644 
 - - - a / src / main / java / net / minecraftforge / fml / relauncher / ReflectionHelper . java 
 + + + b / src / main / java / net / minecraftforge / fml / relauncher / ReflectionHelper . java 
 @ @ - 18 , 6 + 18 , 11 @ @ 
 * / 
 package net . minecraftforge . fml . relauncher ; 
 
 + import com . google . common . base . Preconditions ; 
 + import net . minecraft . launchwrapper . Launch ; 
 + import org . apache . commons . lang3 . StringUtils ; 
 + 
 + import javax . annotation . Nonnull ; 
 import javax . annotation . Nullable ; 
 import java . lang . reflect . Field ; 
 import java . lang . reflect . Method ; 
 @ @ - 40 , 6 + 45 , 11 @ @ public class ReflectionHelper 
 / / this . methodNames = methodNames ; 
 } 
 
 + public UnableToFindMethodException ( Throwable failed ) 
 + { 
 + super ( failed ) ; 
 + } 
 + 
 } 
 
 public static class UnableToFindClassException extends RuntimeException 
 @ @ - 170 , 10 + 180 , 13 @ @ public class ReflectionHelper 
 throw new UnableToFindClassException ( classNames , err ) ; 
 } 
 
 - 
 + / * * 
 + * @ deprecated use { @ link # findMethod ( Class , String , String , Class [ ] ) } 
 + * / 
 + @ Deprecated 
 public static < E > Method findMethod ( Class < ? super E > clazz , E instance , String [ ] methodNames , Class < ? > . . . methodTypes ) 
 { 
 - Exception failed = null ; 
 + Throwable failed = null ; 
 for ( String methodName : methodNames ) 
 { 
 try 
 @ @ - 187 , 6 + 200 , 47 @ @ public class ReflectionHelper 
 failed = e ; 
 } 
 } 
 - throw new UnableToFindMethodException ( methodNames , failed ) ; 
 + throw new UnableToFindMethodException ( failed ) ; 
 + } 
 + 
 + / * * 
 + * Finds a method with the specified name and parameters in the given class and makes it accessible . 
 + * Note : for performance , store the returned value and avoid calling this repeatedly . 
 + * < p > 
 + * Throws an exception if the method is not found . 
 + * 
 + * @ param clazz The class to find the method on . 
 + * @ param methodName The name of the method to find ( used in developer environments , i . e . " getWorldTime " ) . 
 + * @ param methodObfName The obfuscated name of the method to find ( used in obfuscated environments , i . e . " func _ 72820 _ D " ) . 
 + * If the name you are looking for is on a class that is never obfuscated , this should be null . 
 + * @ param parameterTypes The parameter types of the method to find . 
 + * @ return The method with the specified name and parameters in the given class . 
 + * / 
 + @ Nonnull 
 + public static Method findMethod ( @ Nonnull Class < ? > clazz , @ Nonnull String methodName , @ Nullable String methodObfName , Class < ? > . . . parameterTypes ) 
 + { 
 + Preconditions . checkNotNull ( clazz ) ; 
 + Preconditions . checkArgument ( StringUtils . isNotEmpty ( methodName ) , " Method name cannot be empty " ) ; 
 + 
 + String nameToFind ; 
 + if ( methodObfName = = null | | ( Boolean ) Launch . blackboard . get ( " fml . deobfuscatedEnvironment " ) ) 
 + { 
 + nameToFind = methodName ; 
 + } 
 + else 
 + { 
 + nameToFind = methodObfName ; 
 + } 
 + 
 + try 
 + { 
 + Method m = clazz . getDeclaredMethod ( nameToFind , parameterTypes ) ; 
 + m . setAccessible ( true ) ; 
 + return m ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new UnableToFindMethodException ( e ) ; 
 + } 
 } 
 }
