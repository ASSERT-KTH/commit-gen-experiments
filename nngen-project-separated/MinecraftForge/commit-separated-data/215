BLEU SCORE: 0.041961149062965476

TEST MSG: Fix some ClassCastExceptions incorrectly being logged in FML handshake .
GENERATED MSG: Fixed remote and local connections work with mods now .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> index 3e697a3 . . 346c8ab 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> @ @ - 129 , 7 + 129 , 7 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> WAITINGSERVERCOMPLETE <nl> { <nl> @ Override <nl> - public void accept ( final ChannelHandlerContext ctx , final FMLHandshakeMessage msg , final Consumer < ? super FMLHandshakeClientState > cons ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> FMLHandshakeMessage . RegistryData pkt = ( FMLHandshakeMessage . RegistryData ) msg ; <nl> Map < ResourceLocation , ForgeRegistry . Snapshot > snap = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . get ( ) ; <nl> @ @ - 156 , 21 + 156 , 18 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> <nl> / / Do the remapping on the Client ' s thread in case things are reset while the client is running . We stall the network thread until this is finished which can cause the IO thread to time out . . . Not sure if we can do anything about that . <nl> final Map < ResourceLocation , ForgeRegistry . Snapshot > snap _ f = snap ; <nl> - Futures . getUnchecked ( Minecraft . getMinecraft ( ) . addScheduledTask ( ( ) - > <nl> + Multimap < ResourceLocation , ResourceLocation > locallyMissing = Futures . getUnchecked ( Minecraft . getMinecraft ( ) . addScheduledTask ( ( ) - > GameData . injectSnapshot ( snap _ f , false , false ) ) ) ; <nl> + if ( ! locallyMissing . isEmpty ( ) ) <nl> { <nl> - Multimap < ResourceLocation , ResourceLocation > locallyMissing = GameData . injectSnapshot ( snap _ f , false , false ) ; <nl> - if ( ! locallyMissing . isEmpty ( ) ) <nl> - { <nl> - cons . accept ( ERROR ) ; <nl> - NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> - dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; <nl> - FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; <nl> - locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; <nl> - return ; <nl> - } <nl> - cons . accept ( PENDINGCOMPLETE ) ; <nl> - ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> - } ) ) ; <nl> + cons . accept ( ERROR ) ; <nl> + NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> + dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; <nl> + FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; <nl> + locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; <nl> + return ; <nl> + } <nl> + cons . accept ( PENDINGCOMPLETE ) ; <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> } <nl> } , <nl> PENDINGCOMPLETE <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java <nl> index 5d547bd . . a7775b7 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java <nl> @ @ - 28 , 14 + 28 , 16 @ @ import io . netty . util . AttributeKey ; <nl> public class HandshakeMessageHandler < S extends Enum < S > & IHandshakeState < S > > extends SimpleChannelInboundHandler < FMLHandshakeMessage > { <nl> private static final AttributeKey < IHandshakeState < ? > > STATE = AttributeKey . valueOf ( " fml : handshake - state " ) ; <nl> private final AttributeKey < S > fmlHandshakeState ; <nl> - private S initialState ; <nl> - private Class < S > stateType ; <nl> + private final S initialState ; <nl> + private final S errorState ; <nl> + private final Class < S > stateType ; <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> public HandshakeMessageHandler ( Class < S > stateType ) <nl> { <nl> fmlHandshakeState = ( AttributeKey < S > ) ( ( Object ) STATE ) ; <nl> initialState = Enum . valueOf ( stateType , " START " ) ; <nl> + errorState = Enum . valueOf ( stateType , " ERROR " ) ; <nl> this . stateType = stateType ; <nl> } <nl> @ Override <nl> @ @ - 71 , 6 + 73 , 7 @ @ public class HandshakeMessageHandler < S extends Enum < S > & IHandshakeState < S > > ext <nl> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception <nl> { <nl> FMLLog . log . error ( " HandshakeMessageHandler exception " , cause ) ; <nl> + ctx . channel ( ) . attr ( fmlHandshakeState ) . set ( errorState ) ; <nl> super . exceptionCaught ( ctx , cause ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> index 76efce2 . . 529e01d 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> @ @ - 56 , 7 + 56 , 25 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> dispatcher . rejectHandshake ( result ) ; <nl> return ERROR ; <nl> } <nl> - ctx . writeAndFlush ( new FMLHandshakeMessage . ClientAck ( ) ) ; <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ) ) ; <nl> + if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) <nl> + { <nl> + return WAITINGSERVERCOMPLETE ; <nl> + } <nl> + else <nl> + { <nl> + return COMPLETE ; <nl> + } <nl> + } <nl> + } , <nl> + WAITINGSERVERCOMPLETE <nl> + { <nl> + @ Override <nl> + public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + { <nl> + FMLHandshakeMessage . ModIdData modIds = ( FMLHandshakeMessage . ModIdData ) msg ; <nl> + GameData . injectWorldIDMap ( modIds . dataList ( ) ) ; <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ) ) ; <nl> return COMPLETE ; <nl> } <nl> } , <nl> @ @ - 67 , 13 + 85 , 16 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> { <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . continueToClientPlayState ( ) ; <nl> - if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) <nl> - { <nl> - FMLHandshakeMessage . ModIdData modIds = ( FMLHandshakeMessage . ModIdData ) msg ; <nl> - GameData . injectWorldIDMap ( modIds . dataList ( ) ) ; <nl> - } <nl> FMLLog . info ( " Client side modded connection established " ) ; <nl> - ctx . writeAndFlush ( new FMLHandshakeMessage . ClientAck ( ) ) ; <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ) ) ; <nl> + return DONE ; <nl> + } <nl> + } , <nl> + DONE <nl> + { <nl> + @ Override <nl> + public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + { <nl> return this ; <nl> } <nl> } , <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java <nl> index 5019dff . . 8ccd3c9 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java <nl> @ @ - 11 , 7 + 11 , 7 @ @ public class FMLHandshakeCodec extends FMLIndexedMessageToMessageCodec < FMLHandsh <nl> addDiscriminator ( ( byte ) 1 , FMLHandshakeMessage . ClientHello . class ) ; <nl> addDiscriminator ( ( byte ) 2 , FMLHandshakeMessage . ModList . class ) ; <nl> addDiscriminator ( ( byte ) 3 , FMLHandshakeMessage . ModIdData . class ) ; <nl> - addDiscriminator ( ( byte ) - 1 , FMLHandshakeMessage . ClientAck . class ) ; <nl> + addDiscriminator ( ( byte ) - 1 , FMLHandshakeMessage . HandshakeAck . class ) ; <nl> } <nl> @ Override <nl> public void encodeInto ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , ByteBuf target ) throws Exception <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> index 8f8ac75 . . 6a85c59 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> @ @ - 151 , 7 + 151 , 7 @ @ public abstract class FMLHandshakeMessage { <nl> return modIds ; <nl> } <nl> } <nl> - public static class ClientAck extends FMLHandshakeMessage { <nl> + public static class HandshakeAck extends FMLHandshakeMessage { <nl> <nl> } <nl> public void fromBytes ( ByteBuf buffer ) <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java <nl> index 6adfa18 . . ac40a94 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java <nl> @ @ - 44 , 10 + 44 , 6 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> return ERROR ; <nl> } <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; <nl> - if ( ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) <nl> - { <nl> - return COMPLETE ; <nl> - } <nl> return WAITINGCACK ; <nl> } <nl> } , <nl> @ @ - 56 , 7 + 52 , 11 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> @ Override <nl> public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> { <nl> - ctx . writeAndFlush ( new FMLHandshakeMessage . ModIdData ( GameData . buildItemDataList ( ) ) ) ; <nl> + if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) <nl> + { <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . ModIdData ( GameData . buildItemDataList ( ) ) ) ; <nl> + } <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ) ) ; <nl> return COMPLETE ; <nl> } <nl> } , <nl> @ @ - 68 , 6 + 68 , 14 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> FMLLog . info ( " Server side modded connection established " ) ; <nl> dispatcher . continueToServerPlayState ( ) ; <nl> + return DONE ; <nl> + } <nl> + } , <nl> + DONE <nl> + { <nl> + @ Override <nl> + public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + { <nl> return this ; <nl> } <nl> } ,

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 index 3e697a3 . . 346c8ab 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 @ @ - 129 , 7 + 129 , 7 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 WAITINGSERVERCOMPLETE 
 { 
 @ Override 
 - public void accept ( final ChannelHandlerContext ctx , final FMLHandshakeMessage msg , final Consumer < ? super FMLHandshakeClientState > cons ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 FMLHandshakeMessage . RegistryData pkt = ( FMLHandshakeMessage . RegistryData ) msg ; 
 Map < ResourceLocation , ForgeRegistry . Snapshot > snap = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . get ( ) ; 
 @ @ - 156 , 21 + 156 , 18 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 
 / / Do the remapping on the Client ' s thread in case things are reset while the client is running . We stall the network thread until this is finished which can cause the IO thread to time out . . . Not sure if we can do anything about that . 
 final Map < ResourceLocation , ForgeRegistry . Snapshot > snap _ f = snap ; 
 - Futures . getUnchecked ( Minecraft . getMinecraft ( ) . addScheduledTask ( ( ) - > 
 + Multimap < ResourceLocation , ResourceLocation > locallyMissing = Futures . getUnchecked ( Minecraft . getMinecraft ( ) . addScheduledTask ( ( ) - > GameData . injectSnapshot ( snap _ f , false , false ) ) ) ; 
 + if ( ! locallyMissing . isEmpty ( ) ) 
 { 
 - Multimap < ResourceLocation , ResourceLocation > locallyMissing = GameData . injectSnapshot ( snap _ f , false , false ) ; 
 - if ( ! locallyMissing . isEmpty ( ) ) 
 - { 
 - cons . accept ( ERROR ) ; 
 - NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 - dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; 
 - FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; 
 - locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; 
 - return ; 
 - } 
 - cons . accept ( PENDINGCOMPLETE ) ; 
 - ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 - } ) ) ; 
 + cons . accept ( ERROR ) ; 
 + NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 + dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; 
 + FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; 
 + locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; 
 + return ; 
 + } 
 + cons . accept ( PENDINGCOMPLETE ) ; 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 } 
 } , 
 PENDINGCOMPLETE 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java 
 index 5d547bd . . a7775b7 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java 
 @ @ - 28 , 14 + 28 , 16 @ @ import io . netty . util . AttributeKey ; 
 public class HandshakeMessageHandler < S extends Enum < S > & IHandshakeState < S > > extends SimpleChannelInboundHandler < FMLHandshakeMessage > { 
 private static final AttributeKey < IHandshakeState < ? > > STATE = AttributeKey . valueOf ( " fml : handshake - state " ) ; 
 private final AttributeKey < S > fmlHandshakeState ; 
 - private S initialState ; 
 - private Class < S > stateType ; 
 + private final S initialState ; 
 + private final S errorState ; 
 + private final Class < S > stateType ; 
 
 @ SuppressWarnings ( " unchecked " ) 
 public HandshakeMessageHandler ( Class < S > stateType ) 
 { 
 fmlHandshakeState = ( AttributeKey < S > ) ( ( Object ) STATE ) ; 
 initialState = Enum . valueOf ( stateType , " START " ) ; 
 + errorState = Enum . valueOf ( stateType , " ERROR " ) ; 
 this . stateType = stateType ; 
 } 
 @ Override 
 @ @ - 71 , 6 + 73 , 7 @ @ public class HandshakeMessageHandler < S extends Enum < S > & IHandshakeState < S > > ext 
 public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception 
 { 
 FMLLog . log . error ( " HandshakeMessageHandler exception " , cause ) ; 
 + ctx . channel ( ) . attr ( fmlHandshakeState ) . set ( errorState ) ; 
 super . exceptionCaught ( ctx , cause ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 index 76efce2 . . 529e01d 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 @ @ - 56 , 7 + 56 , 25 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 dispatcher . rejectHandshake ( result ) ; 
 return ERROR ; 
 } 
 - ctx . writeAndFlush ( new FMLHandshakeMessage . ClientAck ( ) ) ; 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ) ) ; 
 + if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) 
 + { 
 + return WAITINGSERVERCOMPLETE ; 
 + } 
 + else 
 + { 
 + return COMPLETE ; 
 + } 
 + } 
 + } , 
 + WAITINGSERVERCOMPLETE 
 + { 
 + @ Override 
 + public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + { 
 + FMLHandshakeMessage . ModIdData modIds = ( FMLHandshakeMessage . ModIdData ) msg ; 
 + GameData . injectWorldIDMap ( modIds . dataList ( ) ) ; 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ) ) ; 
 return COMPLETE ; 
 } 
 } , 
 @ @ - 67 , 13 + 85 , 16 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 { 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . continueToClientPlayState ( ) ; 
 - if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) 
 - { 
 - FMLHandshakeMessage . ModIdData modIds = ( FMLHandshakeMessage . ModIdData ) msg ; 
 - GameData . injectWorldIDMap ( modIds . dataList ( ) ) ; 
 - } 
 FMLLog . info ( " Client side modded connection established " ) ; 
 - ctx . writeAndFlush ( new FMLHandshakeMessage . ClientAck ( ) ) ; 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ) ) ; 
 + return DONE ; 
 + } 
 + } , 
 + DONE 
 + { 
 + @ Override 
 + public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + { 
 return this ; 
 } 
 } , 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java 
 index 5019dff . . 8ccd3c9 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java 
 @ @ - 11 , 7 + 11 , 7 @ @ public class FMLHandshakeCodec extends FMLIndexedMessageToMessageCodec < FMLHandsh 
 addDiscriminator ( ( byte ) 1 , FMLHandshakeMessage . ClientHello . class ) ; 
 addDiscriminator ( ( byte ) 2 , FMLHandshakeMessage . ModList . class ) ; 
 addDiscriminator ( ( byte ) 3 , FMLHandshakeMessage . ModIdData . class ) ; 
 - addDiscriminator ( ( byte ) - 1 , FMLHandshakeMessage . ClientAck . class ) ; 
 + addDiscriminator ( ( byte ) - 1 , FMLHandshakeMessage . HandshakeAck . class ) ; 
 } 
 @ Override 
 public void encodeInto ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , ByteBuf target ) throws Exception 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 index 8f8ac75 . . 6a85c59 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 @ @ - 151 , 7 + 151 , 7 @ @ public abstract class FMLHandshakeMessage { 
 return modIds ; 
 } 
 } 
 - public static class ClientAck extends FMLHandshakeMessage { 
 + public static class HandshakeAck extends FMLHandshakeMessage { 
 
 } 
 public void fromBytes ( ByteBuf buffer ) 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java 
 index 6adfa18 . . ac40a94 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java 
 @ @ - 44 , 10 + 44 , 6 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 return ERROR ; 
 } 
 ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; 
 - if ( ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) 
 - { 
 - return COMPLETE ; 
 - } 
 return WAITINGCACK ; 
 } 
 } , 
 @ @ - 56 , 7 + 52 , 11 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 @ Override 
 public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 { 
 - ctx . writeAndFlush ( new FMLHandshakeMessage . ModIdData ( GameData . buildItemDataList ( ) ) ) ; 
 + if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) 
 + { 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . ModIdData ( GameData . buildItemDataList ( ) ) ) ; 
 + } 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ) ) ; 
 return COMPLETE ; 
 } 
 } , 
 @ @ - 68 , 6 + 68 , 14 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 FMLLog . info ( " Server side modded connection established " ) ; 
 dispatcher . continueToServerPlayState ( ) ; 
 + return DONE ; 
 + } 
 + } , 
 + DONE 
 + { 
 + @ Override 
 + public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + { 
 return this ; 
 } 
 } ,
