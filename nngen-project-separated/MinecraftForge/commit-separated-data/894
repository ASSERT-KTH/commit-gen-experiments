BLEU SCORE: 0.02564467478638021

TEST MSG: Fix the channel handler naming . It now uses the standard netty namer for it , by careful use of cunning reflection .
GENERATED MSG: Add overloaded version of SimpleNetworkWrapper # registerMessage that takes the MessageHandler instance directly , allowing to specify the same handler for multiple messages .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> index d67c148 . . 7f18106 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> @ @ - 2 , 14 + 2 , 20 @ @ package net . minecraftforge . fml . common . network . simpleimpl ; <nl> <nl> import io . netty . channel . ChannelFutureListener ; <nl> <nl> + import java . lang . reflect . Method ; <nl> import java . util . EnumMap ; <nl> <nl> import com . google . common . base . Throwables ; <nl> <nl> + import org . apache . logging . log4j . Level ; <nl> + <nl> + import io . netty . channel . ChannelHandler ; <nl> + import io . netty . channel . ChannelPipeline ; <nl> import net . minecraft . entity . player . EntityPlayerMP ; <nl> import net . minecraft . network . INetHandler ; <nl> import net . minecraft . network . Packet ; <nl> import net . minecraft . tileentity . TileEntity ; <nl> + import net . minecraftforge . fml . common . FMLLog ; <nl> import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> import net . minecraftforge . fml . common . network . FMLEmbeddedChannel ; <nl> import net . minecraftforge . fml . common . network . FMLOutboundHandler ; <nl> @ @ - 85 , 13 + 91 , 40 @ @ import net . minecraftforge . fml . relauncher . Side ; <nl> public class SimpleNetworkWrapper { <nl> private EnumMap < Side , FMLEmbeddedChannel > channels ; <nl> private SimpleIndexedCodec packetCodec ; <nl> - <nl> + private static Class < ? > defaultChannelPipeline ; <nl> + private static Method generateName ; <nl> + { <nl> + try <nl> + { <nl> + defaultChannelPipeline = Class . forName ( " io . netty . channel . DefaultChannelPipeline " ) ; <nl> + generateName = defaultChannelPipeline . getDeclaredMethod ( " generateName " , ChannelHandler . class ) ; <nl> + generateName . setAccessible ( true ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + / / How is this possible ? <nl> + FMLLog . log ( Level . FATAL , e , " What ? Netty isn ' t installed , what magic is this ? " ) ; <nl> + throw Throwables . propagate ( e ) ; <nl> + } <nl> + } <nl> public SimpleNetworkWrapper ( String channelName ) <nl> { <nl> packetCodec = new SimpleIndexedCodec ( ) ; <nl> channels = NetworkRegistry . INSTANCE . newChannel ( channelName , packetCodec ) ; <nl> } <nl> <nl> + private String generateName ( ChannelPipeline pipeline , ChannelHandler handler ) <nl> + { <nl> + try <nl> + { <nl> + return ( String ) generateName . invoke ( defaultChannelPipeline . cast ( pipeline ) , handler ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + FMLLog . log ( Level . FATAL , e , " It appears we somehow have a not - standard pipeline . Huh " ) ; <nl> + throw Throwables . propagate ( e ) ; <nl> + } <nl> + } <nl> / * * <nl> * Register a message and it ' s associated handler . The message will have the supplied discriminator byte . The message handler will <nl> * be registered on the supplied side ( this is the side where you want the message to be processed and acted upon ) . <nl> @ @ - 144 , 13 + 177 , 13 @ @ public class SimpleNetworkWrapper { <nl> private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addServerHandlerAfter ( FMLEmbeddedChannel channel , String type , IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestType ) <nl> { <nl> SimpleChannelHandlerWrapper < REQ , REPLY > handler = getHandlerWrapper ( messageHandler , Side . SERVER , requestType ) ; <nl> - channel . pipeline ( ) . addAfter ( type , messageHandler . getClass ( ) . getName ( ) , handler ) ; <nl> + channel . pipeline ( ) . addAfter ( type , generateName ( channel . pipeline ( ) , handler ) , handler ) ; <nl> } <nl> <nl> private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addClientHandlerAfter ( FMLEmbeddedChannel channel , String type , IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestType ) <nl> { <nl> SimpleChannelHandlerWrapper < REQ , REPLY > handler = getHandlerWrapper ( messageHandler , Side . CLIENT , requestType ) ; <nl> - channel . pipeline ( ) . addAfter ( type , messageHandler . getClass ( ) . getName ( ) , handler ) ; <nl> + channel . pipeline ( ) . addAfter ( type , generateName ( channel . pipeline ( ) , handler ) , handler ) ; <nl> } <nl> <nl> private < REPLY extends IMessage , REQ extends IMessage > SimpleChannelHandlerWrapper < REQ , REPLY > getHandlerWrapper ( IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Side side , Class < REQ > requestType )
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java b / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java <nl> index 06fd2f3 . . e7e2693 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java <nl> @ @ - 1 , 8 + 1 , 12 @ @ <nl> package cpw . mods . fml . common . network . simpleimpl ; <nl> <nl> import org . apache . logging . log4j . Level ; <nl> + <nl> import net . minecraft . network . INetHandler ; <nl> + <nl> + import com . google . common . base . Preconditions ; <nl> import com . google . common . base . Throwables ; <nl> + <nl> import cpw . mods . fml . common . FMLLog ; <nl> import cpw . mods . fml . common . network . FMLOutboundHandler ; <nl> import cpw . mods . fml . common . network . NetworkRegistry ; <nl> @ @ - 12 , 18 + 16 , 18 @ @ import io . netty . channel . ChannelHandlerContext ; <nl> import io . netty . channel . SimpleChannelInboundHandler ; <nl> <nl> public class SimpleChannelHandlerWrapper < REQ extends IMessage , REPLY extends IMessage > extends SimpleChannelInboundHandler < REQ > { <nl> - private IMessageHandler < REQ , REPLY > messageHandler ; <nl> - private Side side ; <nl> - public SimpleChannelHandlerWrapper ( Class < ? extends IMessageHandler < REQ , REPLY > > handler , Side side , Class < REQ > requestType ) <nl> + private final IMessageHandler < ? super REQ , ? extends REPLY > messageHandler ; <nl> + private final Side side ; <nl> + <nl> + public SimpleChannelHandlerWrapper ( Class < ? extends IMessageHandler < ? super REQ , ? extends REPLY > > handler , Side side , Class < REQ > requestType ) <nl> + { <nl> + this ( SimpleNetworkWrapper . instantiate ( handler ) , side , requestType ) ; <nl> + } <nl> + <nl> + public SimpleChannelHandlerWrapper ( IMessageHandler < ? super REQ , ? extends REPLY > handler , Side side , Class < REQ > requestType ) <nl> { <nl> super ( requestType ) ; <nl> - try <nl> - { <nl> - messageHandler = handler . newInstance ( ) ; <nl> - } catch ( Exception e ) <nl> - { <nl> - Throwables . propagate ( e ) ; <nl> - } <nl> + messageHandler = Preconditions . checkNotNull ( handler , " IMessageHandler must not be null " ) ; <nl> this . side = side ; <nl> } <nl> @ Override <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> index 91ddb3b . . edd5074 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> @ @ - 1 , 7 + 1 , 11 @ @ <nl> package cpw . mods . fml . common . network . simpleimpl ; <nl> <nl> import io . netty . channel . ChannelFutureListener ; <nl> + <nl> import java . util . EnumMap ; <nl> + <nl> + import com . google . common . base . Throwables ; <nl> + <nl> import net . minecraft . entity . player . EntityPlayerMP ; <nl> import net . minecraft . network . INetHandler ; <nl> import net . minecraft . network . Packet ; <nl> @ @ - 99 , 6 + 103 , 31 @ @ public class SimpleNetworkWrapper { <nl> * / <nl> public < REQ extends IMessage , REPLY extends IMessage > void registerMessage ( Class < ? extends IMessageHandler < REQ , REPLY > > messageHandler , Class < REQ > requestMessageType , int discriminator , Side side ) <nl> { <nl> + registerMessage ( instantiate ( messageHandler ) , requestMessageType , discriminator , side ) ; <nl> + } <nl> + <nl> + static < REQ extends IMessage , REPLY extends IMessage > IMessageHandler < ? super REQ , ? extends REPLY > instantiate ( Class < ? extends IMessageHandler < ? super REQ , ? extends REPLY > > handler ) <nl> + { <nl> + try <nl> + { <nl> + return handler . newInstance ( ) ; <nl> + } catch ( Exception e ) <nl> + { <nl> + throw Throwables . propagate ( e ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Register a message and it ' s associated handler . The message will have the supplied discriminator byte . The message handler will <nl> + * be registered on the supplied side ( this is the side where you want the message to be processed and acted upon ) . <nl> + * <nl> + * @ param messageHandler the message handler instance <nl> + * @ param requestMessageType the message type <nl> + * @ param discriminator a discriminator byte <nl> + * @ param side the side for the handler <nl> + * / <nl> + public < REQ extends IMessage , REPLY extends IMessage > void registerMessage ( IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestMessageType , int discriminator , Side side ) <nl> + { <nl> packetCodec . addDiscriminator ( discriminator , requestMessageType ) ; <nl> FMLEmbeddedChannel channel = channels . get ( side ) ; <nl> String type = channel . findChannelHandlerNameForType ( SimpleIndexedCodec . class ) ; <nl> @ @ - 112 , 19 + 141 , 19 @ @ public class SimpleNetworkWrapper { <nl> } <nl> } <nl> <nl> - private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addServerHandlerAfter ( FMLEmbeddedChannel channel , String type , Class < ? extends IMessageHandler < REQ , REPLY > > messageHandler , Class < REQ > requestType ) <nl> + private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addServerHandlerAfter ( FMLEmbeddedChannel channel , String type , IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestType ) <nl> { <nl> SimpleChannelHandlerWrapper < REQ , REPLY > handler = getHandlerWrapper ( messageHandler , Side . SERVER , requestType ) ; <nl> - channel . pipeline ( ) . addAfter ( type , messageHandler . getName ( ) , handler ) ; <nl> + channel . pipeline ( ) . addAfter ( type , messageHandler . getClass ( ) . getName ( ) , handler ) ; <nl> } <nl> <nl> - private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addClientHandlerAfter ( FMLEmbeddedChannel channel , String type , Class < ? extends IMessageHandler < REQ , REPLY > > messageHandler , Class < REQ > requestType ) <nl> + private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addClientHandlerAfter ( FMLEmbeddedChannel channel , String type , IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestType ) <nl> { <nl> SimpleChannelHandlerWrapper < REQ , REPLY > handler = getHandlerWrapper ( messageHandler , Side . CLIENT , requestType ) ; <nl> - channel . pipeline ( ) . addAfter ( type , messageHandler . getName ( ) , handler ) ; <nl> + channel . pipeline ( ) . addAfter ( type , messageHandler . getClass ( ) . getName ( ) , handler ) ; <nl> } <nl> <nl> - private < REPLY extends IMessage , REQ extends IMessage > SimpleChannelHandlerWrapper < REQ , REPLY > getHandlerWrapper ( Class < ? extends IMessageHandler < REQ , REPLY > > messageHandler , Side side , Class < REQ > requestType ) <nl> + private < REPLY extends IMessage , REQ extends IMessage > SimpleChannelHandlerWrapper < REQ , REPLY > getHandlerWrapper ( IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Side side , Class < REQ > requestType ) <nl> { <nl> return new SimpleChannelHandlerWrapper < REQ , REPLY > ( messageHandler , side , requestType ) ; <nl> }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 index d67c148 . . 7f18106 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 @ @ - 2 , 14 + 2 , 20 @ @ package net . minecraftforge . fml . common . network . simpleimpl ; 
 
 import io . netty . channel . ChannelFutureListener ; 
 
 + import java . lang . reflect . Method ; 
 import java . util . EnumMap ; 
 
 import com . google . common . base . Throwables ; 
 
 + import org . apache . logging . log4j . Level ; 
 + 
 + import io . netty . channel . ChannelHandler ; 
 + import io . netty . channel . ChannelPipeline ; 
 import net . minecraft . entity . player . EntityPlayerMP ; 
 import net . minecraft . network . INetHandler ; 
 import net . minecraft . network . Packet ; 
 import net . minecraft . tileentity . TileEntity ; 
 + import net . minecraftforge . fml . common . FMLLog ; 
 import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 import net . minecraftforge . fml . common . network . FMLEmbeddedChannel ; 
 import net . minecraftforge . fml . common . network . FMLOutboundHandler ; 
 @ @ - 85 , 13 + 91 , 40 @ @ import net . minecraftforge . fml . relauncher . Side ; 
 public class SimpleNetworkWrapper { 
 private EnumMap < Side , FMLEmbeddedChannel > channels ; 
 private SimpleIndexedCodec packetCodec ; 
 - 
 + private static Class < ? > defaultChannelPipeline ; 
 + private static Method generateName ; 
 + { 
 + try 
 + { 
 + defaultChannelPipeline = Class . forName ( " io . netty . channel . DefaultChannelPipeline " ) ; 
 + generateName = defaultChannelPipeline . getDeclaredMethod ( " generateName " , ChannelHandler . class ) ; 
 + generateName . setAccessible ( true ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + / / How is this possible ? 
 + FMLLog . log ( Level . FATAL , e , " What ? Netty isn ' t installed , what magic is this ? " ) ; 
 + throw Throwables . propagate ( e ) ; 
 + } 
 + } 
 public SimpleNetworkWrapper ( String channelName ) 
 { 
 packetCodec = new SimpleIndexedCodec ( ) ; 
 channels = NetworkRegistry . INSTANCE . newChannel ( channelName , packetCodec ) ; 
 } 
 
 + private String generateName ( ChannelPipeline pipeline , ChannelHandler handler ) 
 + { 
 + try 
 + { 
 + return ( String ) generateName . invoke ( defaultChannelPipeline . cast ( pipeline ) , handler ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + FMLLog . log ( Level . FATAL , e , " It appears we somehow have a not - standard pipeline . Huh " ) ; 
 + throw Throwables . propagate ( e ) ; 
 + } 
 + } 
 / * * 
 * Register a message and it ' s associated handler . The message will have the supplied discriminator byte . The message handler will 
 * be registered on the supplied side ( this is the side where you want the message to be processed and acted upon ) . 
 @ @ - 144 , 13 + 177 , 13 @ @ public class SimpleNetworkWrapper { 
 private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addServerHandlerAfter ( FMLEmbeddedChannel channel , String type , IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestType ) 
 { 
 SimpleChannelHandlerWrapper < REQ , REPLY > handler = getHandlerWrapper ( messageHandler , Side . SERVER , requestType ) ; 
 - channel . pipeline ( ) . addAfter ( type , messageHandler . getClass ( ) . getName ( ) , handler ) ; 
 + channel . pipeline ( ) . addAfter ( type , generateName ( channel . pipeline ( ) , handler ) , handler ) ; 
 } 
 
 private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addClientHandlerAfter ( FMLEmbeddedChannel channel , String type , IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestType ) 
 { 
 SimpleChannelHandlerWrapper < REQ , REPLY > handler = getHandlerWrapper ( messageHandler , Side . CLIENT , requestType ) ; 
 - channel . pipeline ( ) . addAfter ( type , messageHandler . getClass ( ) . getName ( ) , handler ) ; 
 + channel . pipeline ( ) . addAfter ( type , generateName ( channel . pipeline ( ) , handler ) , handler ) ; 
 } 
 
 private < REPLY extends IMessage , REQ extends IMessage > SimpleChannelHandlerWrapper < REQ , REPLY > getHandlerWrapper ( IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Side side , Class < REQ > requestType )

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java b / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java 
 index 06fd2f3 . . e7e2693 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java 
 @ @ - 1 , 8 + 1 , 12 @ @ 
 package cpw . mods . fml . common . network . simpleimpl ; 
 
 import org . apache . logging . log4j . Level ; 
 + 
 import net . minecraft . network . INetHandler ; 
 + 
 + import com . google . common . base . Preconditions ; 
 import com . google . common . base . Throwables ; 
 + 
 import cpw . mods . fml . common . FMLLog ; 
 import cpw . mods . fml . common . network . FMLOutboundHandler ; 
 import cpw . mods . fml . common . network . NetworkRegistry ; 
 @ @ - 12 , 18 + 16 , 18 @ @ import io . netty . channel . ChannelHandlerContext ; 
 import io . netty . channel . SimpleChannelInboundHandler ; 
 
 public class SimpleChannelHandlerWrapper < REQ extends IMessage , REPLY extends IMessage > extends SimpleChannelInboundHandler < REQ > { 
 - private IMessageHandler < REQ , REPLY > messageHandler ; 
 - private Side side ; 
 - public SimpleChannelHandlerWrapper ( Class < ? extends IMessageHandler < REQ , REPLY > > handler , Side side , Class < REQ > requestType ) 
 + private final IMessageHandler < ? super REQ , ? extends REPLY > messageHandler ; 
 + private final Side side ; 
 + 
 + public SimpleChannelHandlerWrapper ( Class < ? extends IMessageHandler < ? super REQ , ? extends REPLY > > handler , Side side , Class < REQ > requestType ) 
 + { 
 + this ( SimpleNetworkWrapper . instantiate ( handler ) , side , requestType ) ; 
 + } 
 + 
 + public SimpleChannelHandlerWrapper ( IMessageHandler < ? super REQ , ? extends REPLY > handler , Side side , Class < REQ > requestType ) 
 { 
 super ( requestType ) ; 
 - try 
 - { 
 - messageHandler = handler . newInstance ( ) ; 
 - } catch ( Exception e ) 
 - { 
 - Throwables . propagate ( e ) ; 
 - } 
 + messageHandler = Preconditions . checkNotNull ( handler , " IMessageHandler must not be null " ) ; 
 this . side = side ; 
 } 
 @ Override 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 index 91ddb3b . . edd5074 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 @ @ - 1 , 7 + 1 , 11 @ @ 
 package cpw . mods . fml . common . network . simpleimpl ; 
 
 import io . netty . channel . ChannelFutureListener ; 
 + 
 import java . util . EnumMap ; 
 + 
 + import com . google . common . base . Throwables ; 
 + 
 import net . minecraft . entity . player . EntityPlayerMP ; 
 import net . minecraft . network . INetHandler ; 
 import net . minecraft . network . Packet ; 
 @ @ - 99 , 6 + 103 , 31 @ @ public class SimpleNetworkWrapper { 
 * / 
 public < REQ extends IMessage , REPLY extends IMessage > void registerMessage ( Class < ? extends IMessageHandler < REQ , REPLY > > messageHandler , Class < REQ > requestMessageType , int discriminator , Side side ) 
 { 
 + registerMessage ( instantiate ( messageHandler ) , requestMessageType , discriminator , side ) ; 
 + } 
 + 
 + static < REQ extends IMessage , REPLY extends IMessage > IMessageHandler < ? super REQ , ? extends REPLY > instantiate ( Class < ? extends IMessageHandler < ? super REQ , ? extends REPLY > > handler ) 
 + { 
 + try 
 + { 
 + return handler . newInstance ( ) ; 
 + } catch ( Exception e ) 
 + { 
 + throw Throwables . propagate ( e ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Register a message and it ' s associated handler . The message will have the supplied discriminator byte . The message handler will 
 + * be registered on the supplied side ( this is the side where you want the message to be processed and acted upon ) . 
 + * 
 + * @ param messageHandler the message handler instance 
 + * @ param requestMessageType the message type 
 + * @ param discriminator a discriminator byte 
 + * @ param side the side for the handler 
 + * / 
 + public < REQ extends IMessage , REPLY extends IMessage > void registerMessage ( IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestMessageType , int discriminator , Side side ) 
 + { 
 packetCodec . addDiscriminator ( discriminator , requestMessageType ) ; 
 FMLEmbeddedChannel channel = channels . get ( side ) ; 
 String type = channel . findChannelHandlerNameForType ( SimpleIndexedCodec . class ) ; 
 @ @ - 112 , 19 + 141 , 19 @ @ public class SimpleNetworkWrapper { 
 } 
 } 
 
 - private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addServerHandlerAfter ( FMLEmbeddedChannel channel , String type , Class < ? extends IMessageHandler < REQ , REPLY > > messageHandler , Class < REQ > requestType ) 
 + private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addServerHandlerAfter ( FMLEmbeddedChannel channel , String type , IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestType ) 
 { 
 SimpleChannelHandlerWrapper < REQ , REPLY > handler = getHandlerWrapper ( messageHandler , Side . SERVER , requestType ) ; 
 - channel . pipeline ( ) . addAfter ( type , messageHandler . getName ( ) , handler ) ; 
 + channel . pipeline ( ) . addAfter ( type , messageHandler . getClass ( ) . getName ( ) , handler ) ; 
 } 
 
 - private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addClientHandlerAfter ( FMLEmbeddedChannel channel , String type , Class < ? extends IMessageHandler < REQ , REPLY > > messageHandler , Class < REQ > requestType ) 
 + private < REQ extends IMessage , REPLY extends IMessage , NH extends INetHandler > void addClientHandlerAfter ( FMLEmbeddedChannel channel , String type , IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Class < REQ > requestType ) 
 { 
 SimpleChannelHandlerWrapper < REQ , REPLY > handler = getHandlerWrapper ( messageHandler , Side . CLIENT , requestType ) ; 
 - channel . pipeline ( ) . addAfter ( type , messageHandler . getName ( ) , handler ) ; 
 + channel . pipeline ( ) . addAfter ( type , messageHandler . getClass ( ) . getName ( ) , handler ) ; 
 } 
 
 - private < REPLY extends IMessage , REQ extends IMessage > SimpleChannelHandlerWrapper < REQ , REPLY > getHandlerWrapper ( Class < ? extends IMessageHandler < REQ , REPLY > > messageHandler , Side side , Class < REQ > requestType ) 
 + private < REPLY extends IMessage , REQ extends IMessage > SimpleChannelHandlerWrapper < REQ , REPLY > getHandlerWrapper ( IMessageHandler < ? super REQ , ? extends REPLY > messageHandler , Side side , Class < REQ > requestType ) 
 { 
 return new SimpleChannelHandlerWrapper < REQ , REPLY > ( messageHandler , side , requestType ) ; 
 }
