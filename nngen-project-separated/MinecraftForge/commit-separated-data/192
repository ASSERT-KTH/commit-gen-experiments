BLEU SCORE: 0.013139808552042212

TEST MSG: Delete MarkerTransformer . I don ' t think this has been used in years .
GENERATED MSG: Commit the start of some pluggable transformers

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / asm / transformers / MarkerTransformer . java b / src / main / java / net / minecraftforge / fml / common / asm / transformers / MarkerTransformer . java <nl> deleted file mode 100644 <nl> index 8e5f621 . . 0000000 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / asm / transformers / MarkerTransformer . java <nl> + + + / dev / null <nl> @ @ - 1 , 277 + 0 , 0 @ @ <nl> - / * <nl> - * Minecraft Forge <nl> - * Copyright ( c ) 2016 - 2018 . <nl> - * <nl> - * This library is free software ; you can redistribute it and / or <nl> - * modify it under the terms of the GNU Lesser General Public <nl> - * License as published by the Free Software Foundation version 2 . 1 <nl> - * of the License . <nl> - * <nl> - * This library is distributed in the hope that it will be useful , <nl> - * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> - * <nl> - * You should have received a copy of the GNU Lesser General Public <nl> - * License along with this library ; if not , write to the Free Software <nl> - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> - * / <nl> - <nl> - package net . minecraftforge . fml . common . asm . transformers ; <nl> - <nl> - import java . io . BufferedInputStream ; <nl> - import java . io . BufferedOutputStream ; <nl> - import java . io . ByteArrayOutputStream ; <nl> - import java . io . File ; <nl> - import java . io . FileInputStream ; <nl> - import java . io . FileNotFoundException ; <nl> - import java . io . FileOutputStream ; <nl> - import java . io . IOException ; <nl> - import java . net . URL ; <nl> - import java . nio . charset . StandardCharsets ; <nl> - import java . util . List ; <nl> - import java . util . zip . ZipEntry ; <nl> - import java . util . zip . ZipInputStream ; <nl> - import java . util . zip . ZipOutputStream ; <nl> - <nl> - import net . minecraft . launchwrapper . IClassTransformer ; <nl> - <nl> - import org . apache . commons . io . IOUtils ; <nl> - import org . objectweb . asm . ClassReader ; <nl> - import org . objectweb . asm . ClassWriter ; <nl> - import org . objectweb . asm . tree . ClassNode ; <nl> - <nl> - import com . google . common . base . Splitter ; <nl> - import com . google . common . collect . ArrayListMultimap ; <nl> - import com . google . common . collect . Iterables ; <nl> - import com . google . common . collect . ListMultimap ; <nl> - import com . google . common . collect . Lists ; <nl> - import com . google . common . io . LineProcessor ; <nl> - import com . google . common . io . Resources ; <nl> - <nl> - public class MarkerTransformer implements IClassTransformer <nl> - { <nl> - private ListMultimap < String , String > markers = ArrayListMultimap . create ( ) ; <nl> - <nl> - public MarkerTransformer ( ) throws IOException <nl> - { <nl> - this ( " fml _ marker . cfg " ) ; <nl> - } <nl> - protected MarkerTransformer ( String rulesFile ) throws IOException <nl> - { <nl> - readMapFile ( rulesFile ) ; <nl> - } <nl> - <nl> - private void readMapFile ( String rulesFile ) throws IOException <nl> - { <nl> - File file = new File ( rulesFile ) ; <nl> - URL rulesResource ; <nl> - if ( file . exists ( ) ) <nl> - { <nl> - rulesResource = file . toURI ( ) . toURL ( ) ; <nl> - } <nl> - else <nl> - { <nl> - rulesResource = Resources . getResource ( rulesFile ) ; <nl> - } <nl> - Resources . readLines ( rulesResource , StandardCharsets . UTF _ 8 , new LineProcessor < Void > ( ) <nl> - { <nl> - @ Override <nl> - public Void getResult ( ) <nl> - { <nl> - return null ; <nl> - } <nl> - <nl> - @ Override <nl> - public boolean processLine ( String input ) throws IOException <nl> - { <nl> - String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; <nl> - if ( line . length ( ) = = 0 ) <nl> - { <nl> - return true ; <nl> - } <nl> - List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; <nl> - if ( parts . size ( ) ! = 2 ) <nl> - { <nl> - throw new RuntimeException ( " Invalid config file line " + input ) ; <nl> - } <nl> - List < String > markerInterfaces = Lists . newArrayList ( Splitter . on ( " , " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; <nl> - for ( String marker : markerInterfaces ) <nl> - { <nl> - markers . put ( parts . get ( 0 ) , marker ) ; <nl> - } <nl> - return true ; <nl> - } <nl> - } ) ; <nl> - } <nl> - <nl> - @ Override <nl> - public byte [ ] transform ( String name , String transformedName , byte [ ] bytes ) <nl> - { <nl> - if ( bytes = = null ) { return null ; } <nl> - if ( ! markers . containsKey ( name ) ) { return bytes ; } <nl> - <nl> - ClassNode classNode = new ClassNode ( ) ; <nl> - ClassReader classReader = new ClassReader ( bytes ) ; <nl> - classReader . accept ( classNode , 0 ) ; <nl> - <nl> - for ( String marker : markers . get ( name ) ) <nl> - { <nl> - classNode . interfaces . add ( marker ) ; <nl> - } <nl> - <nl> - ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; <nl> - classNode . accept ( writer ) ; <nl> - return writer . toByteArray ( ) ; <nl> - } <nl> - <nl> - public static void main ( String [ ] args ) <nl> - { <nl> - if ( args . length < 2 ) <nl> - { <nl> - System . out . println ( " Usage : MarkerTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; <nl> - return ; <nl> - } <nl> - <nl> - boolean hasTransformer = false ; <nl> - MarkerTransformer [ ] trans = new MarkerTransformer [ args . length - 1 ] ; <nl> - for ( int x = 1 ; x < args . length ; x + + ) <nl> - { <nl> - try <nl> - { <nl> - trans [ x - 1 ] = new MarkerTransformer ( args [ x ] ) ; <nl> - hasTransformer = true ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; <nl> - e . printStackTrace ( ) ; <nl> - } <nl> - } <nl> - <nl> - if ( ! hasTransformer ) <nl> - { <nl> - System . out . println ( " Could not find a valid transformer to perform " ) ; <nl> - return ; <nl> - } <nl> - <nl> - File orig = new File ( args [ 0 ] ) ; <nl> - File temp = new File ( args [ 0 ] + " . ATBack " ) ; <nl> - if ( ! orig . exists ( ) & & ! temp . exists ( ) ) <nl> - { <nl> - System . out . println ( " Could not find target jar : " + orig ) ; <nl> - return ; <nl> - } <nl> - / * <nl> - if ( temp . exists ( ) ) <nl> - { <nl> - if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) <nl> - { <nl> - System . out . println ( " Could not backup existing file : " + orig ) ; <nl> - return ; <nl> - } <nl> - if ( ! temp . renameTo ( orig ) ) <nl> - { <nl> - System . out . println ( " Could not restore backup from previous run : " + temp ) ; <nl> - return ; <nl> - } <nl> - } <nl> - * / <nl> - if ( ! orig . renameTo ( temp ) ) <nl> - { <nl> - System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; <nl> - return ; <nl> - } <nl> - <nl> - try <nl> - { <nl> - processJar ( temp , orig , trans ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - e . printStackTrace ( ) ; <nl> - } <nl> - <nl> - if ( ! temp . delete ( ) ) <nl> - { <nl> - System . out . println ( " Could not delete temp file : " + temp ) ; <nl> - } <nl> - } <nl> - <nl> - private static void processJar ( File inFile , File outFile , MarkerTransformer [ ] transformers ) throws IOException <nl> - { <nl> - ZipInputStream inJar = null ; <nl> - ZipOutputStream outJar = null ; <nl> - <nl> - try <nl> - { <nl> - try <nl> - { <nl> - inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; <nl> - } <nl> - catch ( FileNotFoundException e ) <nl> - { <nl> - throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; <nl> - } <nl> - <nl> - try <nl> - { <nl> - outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; <nl> - } <nl> - catch ( FileNotFoundException e ) <nl> - { <nl> - throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; <nl> - } <nl> - <nl> - ZipEntry entry ; <nl> - while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) <nl> - { <nl> - if ( entry . isDirectory ( ) ) <nl> - { <nl> - outJar . putNextEntry ( entry ) ; <nl> - continue ; <nl> - } <nl> - <nl> - byte [ ] data = new byte [ 4096 ] ; <nl> - ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; <nl> - <nl> - int len ; <nl> - do <nl> - { <nl> - len = inJar . read ( data ) ; <nl> - if ( len > 0 ) <nl> - { <nl> - entryBuffer . write ( data , 0 , len ) ; <nl> - } <nl> - } <nl> - while ( len ! = - 1 ) ; <nl> - <nl> - byte [ ] entryData = entryBuffer . toByteArray ( ) ; <nl> - <nl> - String entryName = entry . getName ( ) ; <nl> - <nl> - if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) <nl> - { <nl> - ClassNode cls = new ClassNode ( ) ; <nl> - ClassReader rdr = new ClassReader ( entryData ) ; <nl> - rdr . accept ( cls , 0 ) ; <nl> - String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; <nl> - <nl> - for ( MarkerTransformer trans : transformers ) <nl> - { <nl> - entryData = trans . transform ( name , name , entryData ) ; <nl> - } <nl> - } <nl> - <nl> - ZipEntry newEntry = new ZipEntry ( entryName ) ; <nl> - outJar . putNextEntry ( newEntry ) ; <nl> - outJar . write ( entryData ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - IOUtils . closeQuietly ( outJar ) ; <nl> - IOUtils . closeQuietly ( inJar ) ; <nl> - } <nl> - } <nl> - }
NEAREST DIFF (one line): diff - - git a / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java <nl> new file mode 100644 <nl> index 0000000 . . 760284e <nl> - - - / dev / null <nl> + + + b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java <nl> @ @ - 0 , 0 + 1 , 357 @ @ <nl> + package cpw . mods . fml . common . asm . transformers ; <nl> + <nl> + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; <nl> + <nl> + import java . io . BufferedInputStream ; <nl> + import java . io . BufferedOutputStream ; <nl> + import java . io . BufferedReader ; <nl> + import java . io . ByteArrayOutputStream ; <nl> + import java . io . File ; <nl> + import java . io . FileInputStream ; <nl> + import java . io . FileNotFoundException ; <nl> + import java . io . FileOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStream ; <nl> + import java . io . InputStreamReader ; <nl> + import java . net . URL ; <nl> + import java . text . SimpleDateFormat ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collection ; <nl> + import java . util . Date ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + import java . util . zip . ZipEntry ; <nl> + import java . util . zip . ZipInputStream ; <nl> + import java . util . zip . ZipOutputStream ; <nl> + <nl> + import org . objectweb . asm . ClassReader ; <nl> + import org . objectweb . asm . ClassWriter ; <nl> + import org . objectweb . asm . Type ; <nl> + import org . objectweb . asm . tree . ClassNode ; <nl> + import org . objectweb . asm . tree . FieldNode ; <nl> + import org . objectweb . asm . tree . MethodNode ; <nl> + <nl> + import com . google . common . base . CharMatcher ; <nl> + import com . google . common . base . Charsets ; <nl> + import com . google . common . base . Splitter ; <nl> + import com . google . common . base . Strings ; <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> + import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Multimap ; <nl> + import com . google . common . io . LineProcessor ; <nl> + import com . google . common . io . Resources ; <nl> + <nl> + import cpw . mods . fml . relauncher . IClassTransformer ; <nl> + <nl> + public class AccessTransformer implements IClassTransformer <nl> + { <nl> + private class Modifier <nl> + { <nl> + public String name = " " ; <nl> + public String desc = " " ; <nl> + public int oldAccess = 0 ; <nl> + public int newAccess = 0 ; <nl> + public int targetAccess = 0 ; <nl> + <nl> + private void setTargetAccess ( String name ) <nl> + { <nl> + if ( name . equalsIgnoreCase ( " public " ) ) targetAccess = ACC _ PUBLIC ; <nl> + else if ( name . equalsIgnoreCase ( " private " ) ) targetAccess = ACC _ PRIVATE ; <nl> + else if ( name . equalsIgnoreCase ( " protected " ) ) targetAccess = ACC _ PROTECTED ; <nl> + } <nl> + } <nl> + <nl> + private Multimap < String , Modifier > modifiers = ArrayListMultimap . create ( ) ; <nl> + <nl> + public AccessTransformer ( ) throws IOException <nl> + { <nl> + this ( " / rules . csv " ) ; <nl> + } <nl> + protected AccessTransformer ( String rulesFile ) throws IOException <nl> + { <nl> + readMapFile ( rulesFile ) ; <nl> + } <nl> + <nl> + private void readMapFile ( String rulesFile ) throws IOException <nl> + { <nl> + URL rulesResource = Resources . getResource ( rulesFile ) ; <nl> + Resources . readLines ( rulesResource , Charsets . UTF _ 8 , new LineProcessor < Void > ( ) <nl> + { <nl> + @ Override <nl> + public Void getResult ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean processLine ( String input ) throws IOException <nl> + { <nl> + String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; <nl> + if ( line . length ( ) = = 0 ) <nl> + { <nl> + return true ; <nl> + } <nl> + List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; <nl> + if ( parts . size ( ) > 2 | | parts . get ( 1 ) . indexOf ( ' . ' ) = = - 1 ) <nl> + { <nl> + throw new RuntimeException ( " Invalid config file line " + input ) ; <nl> + } <nl> + Modifier m = new Modifier ( ) ; <nl> + m . setTargetAccess ( parts . get ( 0 ) ) ; <nl> + List < String > descriptor = Lists . newArrayList ( Splitter . on ( " . " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; <nl> + List < String > method = Lists . newArrayList ( Splitter . on ( CharMatcher . anyOf ( " ( ) " ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( descriptor . get ( 1 ) ) ) ; <nl> + if ( method . size ( ) = = 2 ) <nl> + { <nl> + m . desc = method . get ( 1 ) ; <nl> + } <nl> + m . name = method . get ( 0 ) ; <nl> + modifiers . put ( descriptor . get ( 0 ) , m ) ; <nl> + return true ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + @ Override <nl> + public byte [ ] transform ( String name , byte [ ] bytes ) <nl> + { <nl> + if ( ! modifiers . containsKey ( name ) ) { return bytes ; } <nl> + <nl> + ClassNode classNode = new ClassNode ( ) ; <nl> + ClassReader classReader = new ClassReader ( bytes ) ; <nl> + classReader . accept ( classNode , 0 ) ; <nl> + <nl> + Collection < Modifier > mods = modifiers . get ( name ) ; <nl> + for ( Modifier m : mods ) <nl> + { <nl> + if ( m . desc . isEmpty ( ) ) <nl> + { <nl> + for ( FieldNode n : ( List < FieldNode > ) classNode . fields ) <nl> + { <nl> + if ( n . name . equals ( m . name ) ) <nl> + { <nl> + n . access = getFixedAccess ( n . access , m ) ; <nl> + System . out . println ( String . format ( " Field : % s . % s % s - > % s " , name , m . name , Integer . toBinaryString ( m . oldAccess ) , <nl> + Integer . toBinaryString ( m . newAccess ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + else <nl> + { <nl> + for ( MethodNode n : ( List < MethodNode > ) classNode . methods ) <nl> + { <nl> + if ( n . name . equals ( m . name ) & & n . desc . equals ( m . desc ) ) <nl> + { <nl> + n . access = getFixedAccess ( n . access , m ) ; <nl> + System . out . println ( String . format ( " Method : % s . % s % s % s - > % s " , name , m . name , m . desc , toBinary ( m . oldAccess ) , toBinary ( m . newAccess ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; <nl> + classNode . accept ( writer ) ; <nl> + return writer . toByteArray ( ) ; <nl> + } <nl> + <nl> + private String toBinary ( int num ) <nl> + { <nl> + return String . format ( " % 16s " , Integer . toBinaryString ( num ) ) . replace ( ' ' , ' 0 ' ) ; <nl> + } <nl> + <nl> + private int getFixedAccess ( int access , Modifier target ) <nl> + { <nl> + target . oldAccess = access ; <nl> + int t = target . targetAccess ; <nl> + int ret = ( access & ~ 7 ) ; <nl> + <nl> + switch ( access & 7 ) <nl> + { <nl> + case ACC _ PRIVATE : <nl> + ret | = t ; <nl> + break ; <nl> + case 0 : / / default <nl> + ret | = ( t ! = ACC _ PRIVATE ? t : 0 / * default * / ) ; <nl> + break ; <nl> + case ACC _ PROTECTED : <nl> + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / ? t : ACC _ PROTECTED ) ; <nl> + break ; <nl> + case ACC _ PUBLIC : <nl> + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / & & t ! = ACC _ PROTECTED ? t : ACC _ PUBLIC ) ; <nl> + break ; <nl> + default : <nl> + throw new RuntimeException ( " The fuck ? " ) ; <nl> + } <nl> + target . newAccess = ret ; <nl> + return ret ; <nl> + } <nl> + <nl> + public static void main ( String [ ] args ) <nl> + { <nl> + if ( args . length < 2 ) <nl> + { <nl> + System . out . println ( " Usage : AccessTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; <nl> + return ; <nl> + } <nl> + <nl> + boolean hasTransformer = false ; <nl> + AccessTransformer [ ] trans = new AccessTransformer [ args . length - 1 ] ; <nl> + for ( int x = 1 ; x < args . length ; x + + ) <nl> + { <nl> + try <nl> + { <nl> + trans [ x - 1 ] = new AccessTransformer ( args [ x ] ) ; <nl> + hasTransformer = true ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + if ( ! hasTransformer ) <nl> + { <nl> + System . out . println ( " Culd not find a valid transformer to perform " ) ; <nl> + return ; <nl> + } <nl> + <nl> + File orig = new File ( args [ 0 ] ) ; <nl> + File temp = new File ( args [ 0 ] + " . ATBack " ) ; <nl> + if ( ! orig . exists ( ) & & ! temp . exists ( ) ) <nl> + { <nl> + System . out . println ( " Could not find target jar : " + orig ) ; <nl> + return ; <nl> + } <nl> + <nl> + if ( temp . exists ( ) ) <nl> + { <nl> + if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) <nl> + { <nl> + System . out . println ( " Could not backup existing file : " + orig ) ; <nl> + return ; <nl> + } <nl> + if ( ! temp . renameTo ( orig ) ) <nl> + { <nl> + System . out . println ( " Could not restore backup from previous run : " + temp ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + if ( ! orig . renameTo ( temp ) ) <nl> + { <nl> + System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; <nl> + return ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + processJar ( temp , orig , trans ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + private static void processJar ( File inFile , File outFile , AccessTransformer [ ] transformers ) throws IOException <nl> + { <nl> + ZipInputStream inJar = null ; <nl> + ZipOutputStream outJar = null ; <nl> + <nl> + try <nl> + { <nl> + try <nl> + { <nl> + inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; <nl> + } <nl> + <nl> + ZipEntry entry ; <nl> + while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) <nl> + { <nl> + if ( entry . isDirectory ( ) ) <nl> + { <nl> + outJar . putNextEntry ( entry ) ; <nl> + continue ; <nl> + } <nl> + <nl> + byte [ ] data = new byte [ 4096 ] ; <nl> + ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; <nl> + <nl> + int len ; <nl> + do <nl> + { <nl> + len = inJar . read ( data ) ; <nl> + if ( len > 0 ) <nl> + { <nl> + entryBuffer . write ( data , 0 , len ) ; <nl> + } <nl> + } <nl> + while ( len ! = - 1 ) ; <nl> + <nl> + byte [ ] entryData = entryBuffer . toByteArray ( ) ; <nl> + <nl> + String entryName = entry . getName ( ) ; <nl> + <nl> + if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) <nl> + { <nl> + ClassNode cls = new ClassNode ( ) ; <nl> + ClassReader rdr = new ClassReader ( entryData ) ; <nl> + rdr . accept ( cls , 0 ) ; <nl> + String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; <nl> + <nl> + for ( AccessTransformer trans : transformers ) <nl> + { <nl> + entryData = trans . transform ( name , entryData ) ; <nl> + } <nl> + } <nl> + <nl> + ZipEntry newEntry = new ZipEntry ( entryName ) ; <nl> + outJar . putNextEntry ( newEntry ) ; <nl> + outJar . write ( entryData ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + if ( outJar ! = null ) <nl> + { <nl> + try <nl> + { <nl> + outJar . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + } <nl> + } <nl> + <nl> + if ( inJar ! = null ) <nl> + { <nl> + try <nl> + { <nl> + inJar . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> \ No newline at end of file

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / asm / transformers / MarkerTransformer . java b / src / main / java / net / minecraftforge / fml / common / asm / transformers / MarkerTransformer . java 
 deleted file mode 100644 
 index 8e5f621 . . 0000000 
 - - - a / src / main / java / net / minecraftforge / fml / common / asm / transformers / MarkerTransformer . java 
 + + + / dev / null 
 @ @ - 1 , 277 + 0 , 0 @ @ 
 - / * 
 - * Minecraft Forge 
 - * Copyright ( c ) 2016 - 2018 . 
 - * 
 - * This library is free software ; you can redistribute it and / or 
 - * modify it under the terms of the GNU Lesser General Public 
 - * License as published by the Free Software Foundation version 2 . 1 
 - * of the License . 
 - * 
 - * This library is distributed in the hope that it will be useful , 
 - * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 - * 
 - * You should have received a copy of the GNU Lesser General Public 
 - * License along with this library ; if not , write to the Free Software 
 - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 - * / 
 - 
 - package net . minecraftforge . fml . common . asm . transformers ; 
 - 
 - import java . io . BufferedInputStream ; 
 - import java . io . BufferedOutputStream ; 
 - import java . io . ByteArrayOutputStream ; 
 - import java . io . File ; 
 - import java . io . FileInputStream ; 
 - import java . io . FileNotFoundException ; 
 - import java . io . FileOutputStream ; 
 - import java . io . IOException ; 
 - import java . net . URL ; 
 - import java . nio . charset . StandardCharsets ; 
 - import java . util . List ; 
 - import java . util . zip . ZipEntry ; 
 - import java . util . zip . ZipInputStream ; 
 - import java . util . zip . ZipOutputStream ; 
 - 
 - import net . minecraft . launchwrapper . IClassTransformer ; 
 - 
 - import org . apache . commons . io . IOUtils ; 
 - import org . objectweb . asm . ClassReader ; 
 - import org . objectweb . asm . ClassWriter ; 
 - import org . objectweb . asm . tree . ClassNode ; 
 - 
 - import com . google . common . base . Splitter ; 
 - import com . google . common . collect . ArrayListMultimap ; 
 - import com . google . common . collect . Iterables ; 
 - import com . google . common . collect . ListMultimap ; 
 - import com . google . common . collect . Lists ; 
 - import com . google . common . io . LineProcessor ; 
 - import com . google . common . io . Resources ; 
 - 
 - public class MarkerTransformer implements IClassTransformer 
 - { 
 - private ListMultimap < String , String > markers = ArrayListMultimap . create ( ) ; 
 - 
 - public MarkerTransformer ( ) throws IOException 
 - { 
 - this ( " fml _ marker . cfg " ) ; 
 - } 
 - protected MarkerTransformer ( String rulesFile ) throws IOException 
 - { 
 - readMapFile ( rulesFile ) ; 
 - } 
 - 
 - private void readMapFile ( String rulesFile ) throws IOException 
 - { 
 - File file = new File ( rulesFile ) ; 
 - URL rulesResource ; 
 - if ( file . exists ( ) ) 
 - { 
 - rulesResource = file . toURI ( ) . toURL ( ) ; 
 - } 
 - else 
 - { 
 - rulesResource = Resources . getResource ( rulesFile ) ; 
 - } 
 - Resources . readLines ( rulesResource , StandardCharsets . UTF _ 8 , new LineProcessor < Void > ( ) 
 - { 
 - @ Override 
 - public Void getResult ( ) 
 - { 
 - return null ; 
 - } 
 - 
 - @ Override 
 - public boolean processLine ( String input ) throws IOException 
 - { 
 - String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; 
 - if ( line . length ( ) = = 0 ) 
 - { 
 - return true ; 
 - } 
 - List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; 
 - if ( parts . size ( ) ! = 2 ) 
 - { 
 - throw new RuntimeException ( " Invalid config file line " + input ) ; 
 - } 
 - List < String > markerInterfaces = Lists . newArrayList ( Splitter . on ( " , " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; 
 - for ( String marker : markerInterfaces ) 
 - { 
 - markers . put ( parts . get ( 0 ) , marker ) ; 
 - } 
 - return true ; 
 - } 
 - } ) ; 
 - } 
 - 
 - @ Override 
 - public byte [ ] transform ( String name , String transformedName , byte [ ] bytes ) 
 - { 
 - if ( bytes = = null ) { return null ; } 
 - if ( ! markers . containsKey ( name ) ) { return bytes ; } 
 - 
 - ClassNode classNode = new ClassNode ( ) ; 
 - ClassReader classReader = new ClassReader ( bytes ) ; 
 - classReader . accept ( classNode , 0 ) ; 
 - 
 - for ( String marker : markers . get ( name ) ) 
 - { 
 - classNode . interfaces . add ( marker ) ; 
 - } 
 - 
 - ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; 
 - classNode . accept ( writer ) ; 
 - return writer . toByteArray ( ) ; 
 - } 
 - 
 - public static void main ( String [ ] args ) 
 - { 
 - if ( args . length < 2 ) 
 - { 
 - System . out . println ( " Usage : MarkerTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; 
 - return ; 
 - } 
 - 
 - boolean hasTransformer = false ; 
 - MarkerTransformer [ ] trans = new MarkerTransformer [ args . length - 1 ] ; 
 - for ( int x = 1 ; x < args . length ; x + + ) 
 - { 
 - try 
 - { 
 - trans [ x - 1 ] = new MarkerTransformer ( args [ x ] ) ; 
 - hasTransformer = true ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; 
 - e . printStackTrace ( ) ; 
 - } 
 - } 
 - 
 - if ( ! hasTransformer ) 
 - { 
 - System . out . println ( " Could not find a valid transformer to perform " ) ; 
 - return ; 
 - } 
 - 
 - File orig = new File ( args [ 0 ] ) ; 
 - File temp = new File ( args [ 0 ] + " . ATBack " ) ; 
 - if ( ! orig . exists ( ) & & ! temp . exists ( ) ) 
 - { 
 - System . out . println ( " Could not find target jar : " + orig ) ; 
 - return ; 
 - } 
 - / * 
 - if ( temp . exists ( ) ) 
 - { 
 - if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) 
 - { 
 - System . out . println ( " Could not backup existing file : " + orig ) ; 
 - return ; 
 - } 
 - if ( ! temp . renameTo ( orig ) ) 
 - { 
 - System . out . println ( " Could not restore backup from previous run : " + temp ) ; 
 - return ; 
 - } 
 - } 
 - * / 
 - if ( ! orig . renameTo ( temp ) ) 
 - { 
 - System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; 
 - return ; 
 - } 
 - 
 - try 
 - { 
 - processJar ( temp , orig , trans ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - e . printStackTrace ( ) ; 
 - } 
 - 
 - if ( ! temp . delete ( ) ) 
 - { 
 - System . out . println ( " Could not delete temp file : " + temp ) ; 
 - } 
 - } 
 - 
 - private static void processJar ( File inFile , File outFile , MarkerTransformer [ ] transformers ) throws IOException 
 - { 
 - ZipInputStream inJar = null ; 
 - ZipOutputStream outJar = null ; 
 - 
 - try 
 - { 
 - try 
 - { 
 - inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; 
 - } 
 - catch ( FileNotFoundException e ) 
 - { 
 - throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; 
 - } 
 - 
 - try 
 - { 
 - outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; 
 - } 
 - catch ( FileNotFoundException e ) 
 - { 
 - throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; 
 - } 
 - 
 - ZipEntry entry ; 
 - while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) 
 - { 
 - if ( entry . isDirectory ( ) ) 
 - { 
 - outJar . putNextEntry ( entry ) ; 
 - continue ; 
 - } 
 - 
 - byte [ ] data = new byte [ 4096 ] ; 
 - ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; 
 - 
 - int len ; 
 - do 
 - { 
 - len = inJar . read ( data ) ; 
 - if ( len > 0 ) 
 - { 
 - entryBuffer . write ( data , 0 , len ) ; 
 - } 
 - } 
 - while ( len ! = - 1 ) ; 
 - 
 - byte [ ] entryData = entryBuffer . toByteArray ( ) ; 
 - 
 - String entryName = entry . getName ( ) ; 
 - 
 - if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) 
 - { 
 - ClassNode cls = new ClassNode ( ) ; 
 - ClassReader rdr = new ClassReader ( entryData ) ; 
 - rdr . accept ( cls , 0 ) ; 
 - String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; 
 - 
 - for ( MarkerTransformer trans : transformers ) 
 - { 
 - entryData = trans . transform ( name , name , entryData ) ; 
 - } 
 - } 
 - 
 - ZipEntry newEntry = new ZipEntry ( entryName ) ; 
 - outJar . putNextEntry ( newEntry ) ; 
 - outJar . write ( entryData ) ; 
 - } 
 - } 
 - finally 
 - { 
 - IOUtils . closeQuietly ( outJar ) ; 
 - IOUtils . closeQuietly ( inJar ) ; 
 - } 
 - } 
 - }

NEAREST DIFF:
diff - - git a / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java 
 new file mode 100644 
 index 0000000 . . 760284e 
 - - - / dev / null 
 + + + b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java 
 @ @ - 0 , 0 + 1 , 357 @ @ 
 + package cpw . mods . fml . common . asm . transformers ; 
 + 
 + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; 
 + 
 + import java . io . BufferedInputStream ; 
 + import java . io . BufferedOutputStream ; 
 + import java . io . BufferedReader ; 
 + import java . io . ByteArrayOutputStream ; 
 + import java . io . File ; 
 + import java . io . FileInputStream ; 
 + import java . io . FileNotFoundException ; 
 + import java . io . FileOutputStream ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . io . InputStreamReader ; 
 + import java . net . URL ; 
 + import java . text . SimpleDateFormat ; 
 + import java . util . ArrayList ; 
 + import java . util . Collection ; 
 + import java . util . Date ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + import java . util . zip . ZipEntry ; 
 + import java . util . zip . ZipInputStream ; 
 + import java . util . zip . ZipOutputStream ; 
 + 
 + import org . objectweb . asm . ClassReader ; 
 + import org . objectweb . asm . ClassWriter ; 
 + import org . objectweb . asm . Type ; 
 + import org . objectweb . asm . tree . ClassNode ; 
 + import org . objectweb . asm . tree . FieldNode ; 
 + import org . objectweb . asm . tree . MethodNode ; 
 + 
 + import com . google . common . base . CharMatcher ; 
 + import com . google . common . base . Charsets ; 
 + import com . google . common . base . Splitter ; 
 + import com . google . common . base . Strings ; 
 + import com . google . common . collect . ArrayListMultimap ; 
 + import com . google . common . collect . Iterables ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Multimap ; 
 + import com . google . common . io . LineProcessor ; 
 + import com . google . common . io . Resources ; 
 + 
 + import cpw . mods . fml . relauncher . IClassTransformer ; 
 + 
 + public class AccessTransformer implements IClassTransformer 
 + { 
 + private class Modifier 
 + { 
 + public String name = " " ; 
 + public String desc = " " ; 
 + public int oldAccess = 0 ; 
 + public int newAccess = 0 ; 
 + public int targetAccess = 0 ; 
 + 
 + private void setTargetAccess ( String name ) 
 + { 
 + if ( name . equalsIgnoreCase ( " public " ) ) targetAccess = ACC _ PUBLIC ; 
 + else if ( name . equalsIgnoreCase ( " private " ) ) targetAccess = ACC _ PRIVATE ; 
 + else if ( name . equalsIgnoreCase ( " protected " ) ) targetAccess = ACC _ PROTECTED ; 
 + } 
 + } 
 + 
 + private Multimap < String , Modifier > modifiers = ArrayListMultimap . create ( ) ; 
 + 
 + public AccessTransformer ( ) throws IOException 
 + { 
 + this ( " / rules . csv " ) ; 
 + } 
 + protected AccessTransformer ( String rulesFile ) throws IOException 
 + { 
 + readMapFile ( rulesFile ) ; 
 + } 
 + 
 + private void readMapFile ( String rulesFile ) throws IOException 
 + { 
 + URL rulesResource = Resources . getResource ( rulesFile ) ; 
 + Resources . readLines ( rulesResource , Charsets . UTF _ 8 , new LineProcessor < Void > ( ) 
 + { 
 + @ Override 
 + public Void getResult ( ) 
 + { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public boolean processLine ( String input ) throws IOException 
 + { 
 + String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; 
 + if ( line . length ( ) = = 0 ) 
 + { 
 + return true ; 
 + } 
 + List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; 
 + if ( parts . size ( ) > 2 | | parts . get ( 1 ) . indexOf ( ' . ' ) = = - 1 ) 
 + { 
 + throw new RuntimeException ( " Invalid config file line " + input ) ; 
 + } 
 + Modifier m = new Modifier ( ) ; 
 + m . setTargetAccess ( parts . get ( 0 ) ) ; 
 + List < String > descriptor = Lists . newArrayList ( Splitter . on ( " . " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; 
 + List < String > method = Lists . newArrayList ( Splitter . on ( CharMatcher . anyOf ( " ( ) " ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( descriptor . get ( 1 ) ) ) ; 
 + if ( method . size ( ) = = 2 ) 
 + { 
 + m . desc = method . get ( 1 ) ; 
 + } 
 + m . name = method . get ( 0 ) ; 
 + modifiers . put ( descriptor . get ( 0 ) , m ) ; 
 + return true ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + @ Override 
 + public byte [ ] transform ( String name , byte [ ] bytes ) 
 + { 
 + if ( ! modifiers . containsKey ( name ) ) { return bytes ; } 
 + 
 + ClassNode classNode = new ClassNode ( ) ; 
 + ClassReader classReader = new ClassReader ( bytes ) ; 
 + classReader . accept ( classNode , 0 ) ; 
 + 
 + Collection < Modifier > mods = modifiers . get ( name ) ; 
 + for ( Modifier m : mods ) 
 + { 
 + if ( m . desc . isEmpty ( ) ) 
 + { 
 + for ( FieldNode n : ( List < FieldNode > ) classNode . fields ) 
 + { 
 + if ( n . name . equals ( m . name ) ) 
 + { 
 + n . access = getFixedAccess ( n . access , m ) ; 
 + System . out . println ( String . format ( " Field : % s . % s % s - > % s " , name , m . name , Integer . toBinaryString ( m . oldAccess ) , 
 + Integer . toBinaryString ( m . newAccess ) ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + else 
 + { 
 + for ( MethodNode n : ( List < MethodNode > ) classNode . methods ) 
 + { 
 + if ( n . name . equals ( m . name ) & & n . desc . equals ( m . desc ) ) 
 + { 
 + n . access = getFixedAccess ( n . access , m ) ; 
 + System . out . println ( String . format ( " Method : % s . % s % s % s - > % s " , name , m . name , m . desc , toBinary ( m . oldAccess ) , toBinary ( m . newAccess ) ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; 
 + classNode . accept ( writer ) ; 
 + return writer . toByteArray ( ) ; 
 + } 
 + 
 + private String toBinary ( int num ) 
 + { 
 + return String . format ( " % 16s " , Integer . toBinaryString ( num ) ) . replace ( ' ' , ' 0 ' ) ; 
 + } 
 + 
 + private int getFixedAccess ( int access , Modifier target ) 
 + { 
 + target . oldAccess = access ; 
 + int t = target . targetAccess ; 
 + int ret = ( access & ~ 7 ) ; 
 + 
 + switch ( access & 7 ) 
 + { 
 + case ACC _ PRIVATE : 
 + ret | = t ; 
 + break ; 
 + case 0 : / / default 
 + ret | = ( t ! = ACC _ PRIVATE ? t : 0 / * default * / ) ; 
 + break ; 
 + case ACC _ PROTECTED : 
 + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / ? t : ACC _ PROTECTED ) ; 
 + break ; 
 + case ACC _ PUBLIC : 
 + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / & & t ! = ACC _ PROTECTED ? t : ACC _ PUBLIC ) ; 
 + break ; 
 + default : 
 + throw new RuntimeException ( " The fuck ? " ) ; 
 + } 
 + target . newAccess = ret ; 
 + return ret ; 
 + } 
 + 
 + public static void main ( String [ ] args ) 
 + { 
 + if ( args . length < 2 ) 
 + { 
 + System . out . println ( " Usage : AccessTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; 
 + return ; 
 + } 
 + 
 + boolean hasTransformer = false ; 
 + AccessTransformer [ ] trans = new AccessTransformer [ args . length - 1 ] ; 
 + for ( int x = 1 ; x < args . length ; x + + ) 
 + { 
 + try 
 + { 
 + trans [ x - 1 ] = new AccessTransformer ( args [ x ] ) ; 
 + hasTransformer = true ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + if ( ! hasTransformer ) 
 + { 
 + System . out . println ( " Culd not find a valid transformer to perform " ) ; 
 + return ; 
 + } 
 + 
 + File orig = new File ( args [ 0 ] ) ; 
 + File temp = new File ( args [ 0 ] + " . ATBack " ) ; 
 + if ( ! orig . exists ( ) & & ! temp . exists ( ) ) 
 + { 
 + System . out . println ( " Could not find target jar : " + orig ) ; 
 + return ; 
 + } 
 + 
 + if ( temp . exists ( ) ) 
 + { 
 + if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) 
 + { 
 + System . out . println ( " Could not backup existing file : " + orig ) ; 
 + return ; 
 + } 
 + if ( ! temp . renameTo ( orig ) ) 
 + { 
 + System . out . println ( " Could not restore backup from previous run : " + temp ) ; 
 + return ; 
 + } 
 + } 
 + 
 + if ( ! orig . renameTo ( temp ) ) 
 + { 
 + System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; 
 + return ; 
 + } 
 + 
 + try 
 + { 
 + processJar ( temp , orig , trans ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + private static void processJar ( File inFile , File outFile , AccessTransformer [ ] transformers ) throws IOException 
 + { 
 + ZipInputStream inJar = null ; 
 + ZipOutputStream outJar = null ; 
 + 
 + try 
 + { 
 + try 
 + { 
 + inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; 
 + } 
 + 
 + try 
 + { 
 + outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; 
 + } 
 + 
 + ZipEntry entry ; 
 + while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) 
 + { 
 + if ( entry . isDirectory ( ) ) 
 + { 
 + outJar . putNextEntry ( entry ) ; 
 + continue ; 
 + } 
 + 
 + byte [ ] data = new byte [ 4096 ] ; 
 + ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; 
 + 
 + int len ; 
 + do 
 + { 
 + len = inJar . read ( data ) ; 
 + if ( len > 0 ) 
 + { 
 + entryBuffer . write ( data , 0 , len ) ; 
 + } 
 + } 
 + while ( len ! = - 1 ) ; 
 + 
 + byte [ ] entryData = entryBuffer . toByteArray ( ) ; 
 + 
 + String entryName = entry . getName ( ) ; 
 + 
 + if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) 
 + { 
 + ClassNode cls = new ClassNode ( ) ; 
 + ClassReader rdr = new ClassReader ( entryData ) ; 
 + rdr . accept ( cls , 0 ) ; 
 + String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; 
 + 
 + for ( AccessTransformer trans : transformers ) 
 + { 
 + entryData = trans . transform ( name , entryData ) ; 
 + } 
 + } 
 + 
 + ZipEntry newEntry = new ZipEntry ( entryName ) ; 
 + outJar . putNextEntry ( newEntry ) ; 
 + outJar . write ( entryData ) ; 
 + } 
 + } 
 + finally 
 + { 
 + if ( outJar ! = null ) 
 + { 
 + try 
 + { 
 + outJar . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + } 
 + } 
 + 
 + if ( inJar ! = null ) 
 + { 
 + try 
 + { 
 + inJar . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + } 
 + } 
 + } 
 + } 
 + } 
 \ No newline at end of file
