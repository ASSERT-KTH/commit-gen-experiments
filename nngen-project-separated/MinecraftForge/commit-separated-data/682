BLEU SCORE: 0.018564670505078415

TEST MSG: Initial support for model visibility system . Implemented it for OBJ , B3D and normal vanilla models ; fixed NPE accessing parent state in B3DModel . Fixes # 2801 .
GENERATED MSG: Fixed B3D loader , fixed some obvious errors in ModelLoader .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> index 67044e5 . . 45f4809 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> @ @ - 63 , 6 + 63 , 7 @ @ import net . minecraftforge . client . model . animation . ModelBlockAnimation ; <nl> import net . minecraftforge . common . ForgeModContainer ; <nl> import net . minecraftforge . common . model . IModelPart ; <nl> import net . minecraftforge . common . model . IModelState ; <nl> + import net . minecraftforge . common . model . Models ; <nl> import net . minecraftforge . common . model . TRSRTransformation ; <nl> import net . minecraftforge . common . model . animation . IClip ; <nl> import net . minecraftforge . common . property . IExtendedBlockState ; <nl> @ @ - 526 , 6 + 527 , 10 @ @ public final class ModelLoader extends ModelBakery <nl> SimpleBakedModel . Builder builder = ( new SimpleBakedModel . Builder ( model , model . createOverrides ( ) ) ) . setTexture ( particle ) ; <nl> for ( int i = 0 ; i < model . getElements ( ) . size ( ) ; i + + ) <nl> { <nl> + if ( modelState . apply ( Optional . of ( Models . getHiddenModelPart ( ImmutableList . of ( Integer . toString ( i ) ) ) ) ) . isPresent ( ) ) <nl> + { <nl> + continue ; <nl> + } <nl> BlockPart part = model . getElements ( ) . get ( i ) ; <nl> TRSRTransformation transformation = baseState ; <nl> if ( newTransforms . get ( i ) ! = null ) <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> index 02f92be . . d0bcfeb 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> @ @ - 47 , 6 + 47 , 7 @ @ import net . minecraftforge . client . model . b3d . B3DModel . Vertex ; <nl> import net . minecraftforge . client . model . pipeline . UnpackedBakedQuad ; <nl> import net . minecraftforge . common . model . IModelPart ; <nl> import net . minecraftforge . common . model . IModelState ; <nl> + import net . minecraftforge . common . model . Models ; <nl> import net . minecraftforge . common . model . TRSRTransformation ; <nl> import net . minecraftforge . common . model . animation . IClip ; <nl> import net . minecraftforge . common . model . animation . IJoint ; <nl> @ @ - 209 , 7 + 210 , 14 @ @ public enum B3DLoader implements ICustomModelLoader <nl> public Optional < TRSRTransformation > apply ( Optional < ? extends IModelPart > part ) <nl> { <nl> / / TODO make more use of Optional <nl> - if ( ! part . isPresent ( ) ) return parent . apply ( part ) ; <nl> + if ( ! part . isPresent ( ) ) <nl> + { <nl> + if ( parent ! = null ) <nl> + { <nl> + return parent . apply ( part ) ; <nl> + } <nl> + return Optional . absent ( ) ; <nl> + } <nl> if ( ! ( part . get ( ) instanceof NodeJoint ) ) <nl> { <nl> return Optional . absent ( ) ; <nl> @ @ - 364 , 6 + 372 , 10 @ @ public enum B3DLoader implements ICustomModelLoader <nl> } <nl> } <nl> <nl> + / * * <nl> + * @ deprecated use AnimationProperty . <nl> + * / <nl> + @ Deprecated <nl> public static enum B3DFrameProperty implements IUnlistedProperty < B3DState > <nl> { <nl> INSTANCE ; <nl> @ @ - 679 , 26 + 691 , 30 @ @ public enum B3DLoader implements ICustomModelLoader <nl> if ( quads = = null ) <nl> { <nl> ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; <nl> - generateQuads ( builder , node , this . state ) ; <nl> + generateQuads ( builder , node , this . state , ImmutableList . < String > of ( ) ) ; <nl> quads = builder . build ( ) ; <nl> } <nl> / / TODO : caching ? <nl> if ( this . state ! = modelState ) <nl> { <nl> ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; <nl> - generateQuads ( builder , node , modelState ) ; <nl> + generateQuads ( builder , node , modelState , ImmutableList . < String > of ( ) ) ; <nl> return builder . build ( ) ; <nl> } <nl> return quads ; <nl> } <nl> <nl> - private void generateQuads ( ImmutableList . Builder < BakedQuad > builder , Node < ? > node , final IModelState state ) <nl> + private void generateQuads ( ImmutableList . Builder < BakedQuad > builder , Node < ? > node , final IModelState state , ImmutableList < String > path ) <nl> { <nl> + ImmutableList . Builder < String > pathBuilder = ImmutableList . builder ( ) ; <nl> + pathBuilder . addAll ( path ) ; <nl> + pathBuilder . add ( node . getName ( ) ) ; <nl> + ImmutableList < String > newPath = pathBuilder . build ( ) ; <nl> for ( Node < ? > child : node . getNodes ( ) . values ( ) ) <nl> { <nl> - generateQuads ( builder , child , state ) ; <nl> + generateQuads ( builder , child , state , newPath ) ; <nl> } <nl> - if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) ) <nl> + if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) & & ! state . apply ( Optional . of ( Models . getHiddenModelPart ( newPath ) ) ) . isPresent ( ) ) <nl> { <nl> Mesh mesh = ( Mesh ) node . getKind ( ) ; <nl> Collection < Face > faces = mesh . bake ( new Function < Node < ? > , Matrix4f > ( ) <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java b / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java <nl> index 88844c6 . . 661fcc3 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java <nl> @ @ - 32 , 16 + 32 , 15 @ @ import net . minecraft . client . resources . IResource ; <nl> import net . minecraft . client . resources . IResourceManager ; <nl> import net . minecraft . util . EnumFacing ; <nl> import net . minecraft . util . ResourceLocation ; <nl> - import net . minecraftforge . client . model . IModel ; <nl> - import net . minecraftforge . client . model . IModelCustomData ; <nl> - import net . minecraftforge . client . model . IPerspectiveAwareModel ; <nl> - import net . minecraftforge . client . model . IRetexturableModel ; <nl> - import net . minecraftforge . client . model . ModelLoader ; <nl> + import net . minecraftforge . client . model . * ; <nl> import net . minecraftforge . client . model . pipeline . UnpackedBakedQuad ; <nl> import net . minecraftforge . common . model . IModelPart ; <nl> import net . minecraftforge . common . model . IModelState ; <nl> + import net . minecraftforge . common . model . Models ; <nl> import net . minecraftforge . common . model . TRSRTransformation ; <nl> + import net . minecraftforge . common . property . IExtendedBlockState ; <nl> import net . minecraftforge . common . property . IUnlistedProperty ; <nl> + import net . minecraftforge . common . property . Properties ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> <nl> import org . apache . commons . lang3 . tuple . Pair ; <nl> @ @ - 1036 , 6 + 1035 , 7 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData <nl> } <nl> } <nl> <nl> + @ Deprecated <nl> public static class Group implements IModelPart <nl> { <nl> public static final String DEFAULT _ NAME = " OBJModel . Default . Element . Name " ; <nl> @ @ - 1092 , 6 + 1092 , 7 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData <nl> } <nl> } <nl> <nl> + @ Deprecated <nl> public static class OBJState implements IModelState <nl> { <nl> protected Map < String , Boolean > visibilityMap = Maps . newHashMap ( ) ; <nl> @ @ - 1230 , 6 + 1231 , 7 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData <nl> } <nl> } <nl> <nl> + @ Deprecated <nl> public enum OBJProperty implements IUnlistedProperty < OBJState > <nl> { <nl> INSTANCE ; <nl> @ @ - 1262 , 7 + 1264 , 7 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData <nl> private final OBJModel model ; <nl> private IModelState state ; <nl> private final VertexFormat format ; <nl> - private Set < BakedQuad > quads ; <nl> + private ImmutableList < BakedQuad > quads ; <nl> private ImmutableMap < String , TextureAtlasSprite > textures ; <nl> private TextureAtlasSprite sprite = ModelLoader . White . INSTANCE ; <nl> <nl> @ @ - 1277 , 98 + 1279 , 122 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData <nl> <nl> public void scheduleRebake ( ) <nl> { <nl> - this . quads = null ; <nl> } <nl> <nl> / / FIXME : merge with getQuads <nl> @ Override <nl> public List < BakedQuad > getQuads ( IBlockState blockState , EnumFacing side , long rand ) <nl> { <nl> - if ( side ! = null ) return ImmutableList . of ( ) ; <nl> + if ( side ! = null ) return ImmutableList . of ( ) ; <nl> if ( quads = = null ) <nl> { <nl> - quads = Collections . synchronizedSet ( new LinkedHashSet < BakedQuad > ( ) ) ; <nl> - Set < Face > faces = Collections . synchronizedSet ( new LinkedHashSet < Face > ( ) ) ; <nl> - Optional < TRSRTransformation > transform = Optional . absent ( ) ; <nl> - for ( Group g : this . model . getMatLib ( ) . getGroups ( ) . values ( ) ) <nl> + quads = buildQuads ( this . state ) ; <nl> + } <nl> + if ( blockState instanceof IExtendedBlockState ) <nl> + { <nl> + IExtendedBlockState exState = ( IExtendedBlockState ) blockState ; <nl> + if ( exState . getUnlistedNames ( ) . contains ( Properties . AnimationProperty ) ) <nl> { <nl> - / / g . minUVBounds = this . model . getMatLib ( ) . minUVBounds ; <nl> - / / g . maxUVBounds = this . model . getMatLib ( ) . maxUVBounds ; <nl> - / / FMLLog . info ( " Group : % s u : [ % f , % f ] v : [ % f , % f ] " , g . name , g . minUVBounds [ 0 ] , g . maxUVBounds [ 0 ] , g . minUVBounds [ 1 ] , g . maxUVBounds [ 1 ] ) ; <nl> <nl> - if ( this . state instanceof OBJState ) <nl> + IModelState newState = exState . getValue ( Properties . AnimationProperty ) ; <nl> + if ( newState ! = null ) <nl> + { <nl> + newState = new ModelStateComposition ( this . state , newState ) ; <nl> + return buildQuads ( newState ) ; <nl> + } <nl> + } <nl> + } <nl> + return quads ; <nl> + } <nl> + <nl> + private ImmutableList < BakedQuad > buildQuads ( IModelState modelState ) <nl> + { <nl> + List < BakedQuad > quads = Lists . newArrayList ( ) ; <nl> + Collections . synchronizedSet ( new LinkedHashSet < BakedQuad > ( ) ) ; <nl> + Set < Face > faces = Collections . synchronizedSet ( new LinkedHashSet < Face > ( ) ) ; <nl> + Optional < TRSRTransformation > transform = Optional . absent ( ) ; <nl> + for ( Group g : this . model . getMatLib ( ) . getGroups ( ) . values ( ) ) <nl> + { <nl> + / / g . minUVBounds = this . model . getMatLib ( ) . minUVBounds ; <nl> + / / g . maxUVBounds = this . model . getMatLib ( ) . maxUVBounds ; <nl> + / / FMLLog . info ( " Group : % s u : [ % f , % f ] v : [ % f , % f ] " , g . name , g . minUVBounds [ 0 ] , g . maxUVBounds [ 0 ] , g . minUVBounds [ 1 ] , g . maxUVBounds [ 1 ] ) ; <nl> + <nl> + if ( modelState . apply ( Optional . of ( Models . getHiddenModelPart ( ImmutableList . of ( g . getName ( ) ) ) ) ) . isPresent ( ) ) <nl> + { <nl> + continue ; <nl> + } <nl> + if ( modelState instanceof OBJState ) <nl> + { <nl> + OBJState state = ( OBJState ) modelState ; <nl> + if ( state . parent ! = null ) <nl> { <nl> - OBJState state = ( OBJState ) this . state ; <nl> - if ( state . parent ! = null ) <nl> + transform = state . parent . apply ( Optional . < IModelPart > absent ( ) ) ; <nl> + } <nl> + / / TODO : can this be replaced by updateStateVisibilityMap ( OBJState ) ? <nl> + if ( state . getGroupNamesFromMap ( ) . contains ( Group . ALL ) ) <nl> + { <nl> + state . visibilityMap . clear ( ) ; <nl> + for ( String s : this . model . getMatLib ( ) . getGroups ( ) . keySet ( ) ) <nl> { <nl> - transform = state . parent . apply ( Optional . < IModelPart > absent ( ) ) ; <nl> + state . visibilityMap . put ( s , state . operation . performOperation ( true ) ) ; <nl> } <nl> - / / TODO : can this be replaced by updateStateVisibilityMap ( OBJState ) ? <nl> - if ( state . getGroupNamesFromMap ( ) . contains ( Group . ALL ) ) <nl> + } <nl> + else if ( state . getGroupNamesFromMap ( ) . contains ( Group . ALL _ EXCEPT ) ) <nl> + { <nl> + List < String > exceptList = state . getGroupNamesFromMap ( ) . subList ( 1 , state . getGroupNamesFromMap ( ) . size ( ) ) ; <nl> + state . visibilityMap . clear ( ) ; <nl> + for ( String s : this . model . getMatLib ( ) . getGroups ( ) . keySet ( ) ) <nl> { <nl> - state . visibilityMap . clear ( ) ; <nl> - for ( String s : this . model . getMatLib ( ) . getGroups ( ) . keySet ( ) ) <nl> + if ( ! exceptList . contains ( s ) ) <nl> { <nl> state . visibilityMap . put ( s , state . operation . performOperation ( true ) ) ; <nl> } <nl> } <nl> - else if ( state . getGroupNamesFromMap ( ) . contains ( Group . ALL _ EXCEPT ) ) <nl> - { <nl> - List < String > exceptList = state . getGroupNamesFromMap ( ) . subList ( 1 , state . getGroupNamesFromMap ( ) . size ( ) ) ; <nl> - state . visibilityMap . clear ( ) ; <nl> - for ( String s : this . model . getMatLib ( ) . getGroups ( ) . keySet ( ) ) <nl> - { <nl> - if ( ! exceptList . contains ( s ) ) <nl> - { <nl> - state . visibilityMap . put ( s , state . operation . performOperation ( true ) ) ; <nl> - } <nl> - } <nl> - } <nl> - else <nl> - { <nl> - for ( String s : state . visibilityMap . keySet ( ) ) <nl> - { <nl> - state . visibilityMap . put ( s , state . operation . performOperation ( state . visibilityMap . get ( s ) ) ) ; <nl> - } <nl> - } <nl> - if ( state . getGroupsWithVisibility ( true ) . contains ( g . getName ( ) ) ) <nl> + } <nl> + else <nl> + { <nl> + for ( String s : state . visibilityMap . keySet ( ) ) <nl> { <nl> - faces . addAll ( g . applyTransform ( transform ) ) ; <nl> + state . visibilityMap . put ( s , state . operation . performOperation ( state . visibilityMap . get ( s ) ) ) ; <nl> } <nl> } <nl> - else <nl> + if ( state . getGroupsWithVisibility ( true ) . contains ( g . getName ( ) ) ) <nl> { <nl> - transform = state . apply ( Optional . < IModelPart > absent ( ) ) ; <nl> faces . addAll ( g . applyTransform ( transform ) ) ; <nl> } <nl> } <nl> - for ( Face f : faces ) <nl> + else <nl> { <nl> - if ( this . model . getMatLib ( ) . materials . get ( f . getMaterialName ( ) ) . isWhite ( ) ) <nl> - { <nl> - for ( Vertex v : f . getVertices ( ) ) <nl> - { / / update material in each vertex <nl> - if ( ! v . getMaterial ( ) . equals ( this . model . getMatLib ( ) . getMaterial ( v . getMaterial ( ) . getName ( ) ) ) ) <nl> - { <nl> - v . setMaterial ( this . model . getMatLib ( ) . getMaterial ( v . getMaterial ( ) . getName ( ) ) ) ; <nl> - } <nl> + transform = modelState . apply ( Optional . < IModelPart > absent ( ) ) ; <nl> + faces . addAll ( g . applyTransform ( transform ) ) ; <nl> + } <nl> + } <nl> + for ( Face f : faces ) <nl> + { <nl> + if ( this . model . getMatLib ( ) . materials . get ( f . getMaterialName ( ) ) . isWhite ( ) ) <nl> + { <nl> + for ( Vertex v : f . getVertices ( ) ) <nl> + { / / update material in each vertex <nl> + if ( ! v . getMaterial ( ) . equals ( this . model . getMatLib ( ) . getMaterial ( v . getMaterial ( ) . getName ( ) ) ) ) <nl> + { <nl> + v . setMaterial ( this . model . getMatLib ( ) . getMaterial ( v . getMaterial ( ) . getName ( ) ) ) ; <nl> } <nl> - sprite = ModelLoader . White . INSTANCE ; <nl> - } else sprite = this . textures . get ( f . getMaterialName ( ) ) ; <nl> - UnpackedBakedQuad . Builder builder = new UnpackedBakedQuad . Builder ( format ) ; <nl> - builder . setContractUVs ( true ) ; <nl> - builder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; <nl> - builder . setTexture ( sprite ) ; <nl> - Normal faceNormal = f . getNormal ( ) ; <nl> - putVertexData ( builder , f . verts [ 0 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 0 ] , sprite ) ; <nl> - putVertexData ( builder , f . verts [ 1 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 1 ] , sprite ) ; <nl> - putVertexData ( builder , f . verts [ 2 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 2 ] , sprite ) ; <nl> - putVertexData ( builder , f . verts [ 3 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 3 ] , sprite ) ; <nl> - quads . add ( builder . build ( ) ) ; <nl> + } <nl> + sprite = ModelLoader . White . INSTANCE ; <nl> } <nl> + else sprite = this . textures . get ( f . getMaterialName ( ) ) ; <nl> + UnpackedBakedQuad . Builder builder = new UnpackedBakedQuad . Builder ( format ) ; <nl> + builder . setContractUVs ( true ) ; <nl> + builder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; <nl> + builder . setTexture ( sprite ) ; <nl> + Normal faceNormal = f . getNormal ( ) ; <nl> + putVertexData ( builder , f . verts [ 0 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 0 ] , sprite ) ; <nl> + putVertexData ( builder , f . verts [ 1 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 1 ] , sprite ) ; <nl> + putVertexData ( builder , f . verts [ 2 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 2 ] , sprite ) ; <nl> + putVertexData ( builder , f . verts [ 3 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 3 ] , sprite ) ; <nl> + quads . add ( builder . build ( ) ) ; <nl> } <nl> - List < BakedQuad > quadList = Collections . synchronizedList ( Lists . newArrayList ( quads ) ) ; <nl> - return quadList ; <nl> + return ImmutableList . copyOf ( quads ) ; <nl> } <nl> <nl> private final void putVertexData ( UnpackedBakedQuad . Builder builder , Vertex v , Normal faceNormal , TextureCoordinate defUV , TextureAtlasSprite sprite ) <nl> diff - - git a / src / main / java / net / minecraftforge / common / model / HiddenModelPart . java b / src / main / java / net / minecraftforge / common / model / HiddenModelPart . java <nl> new file mode 100644 <nl> index 0000000 . . b51d552 <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / common / model / HiddenModelPart . java <nl> @ @ - 0 , 0 + 1 , 18 @ @ <nl> + package net . minecraftforge . common . model ; <nl> + <nl> + import com . google . common . collect . ImmutableList ; <nl> + <nl> + final class HiddenModelPart implements IModelPart <nl> + { <nl> + private final ImmutableList < String > path ; <nl> + <nl> + HiddenModelPart ( ImmutableList < String > path ) <nl> + { <nl> + this . path = path ; <nl> + } <nl> + <nl> + ImmutableList < String > getPath ( ) <nl> + { <nl> + return path ; <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / common / model / Models . java b / src / main / java / net / minecraftforge / common / model / Models . java <nl> new file mode 100644 <nl> index 0000000 . . 9e5daa2 <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / common / model / Models . java <nl> @ @ - 0 , 0 + 1 , 24 @ @ <nl> + package net . minecraftforge . common . model ; <nl> + <nl> + import com . google . common . collect . ImmutableList ; <nl> + import com . google . common . collect . Iterators ; <nl> + import com . google . common . collect . UnmodifiableIterator ; <nl> + <nl> + public enum Models <nl> + { <nl> + ; <nl> + <nl> + public static IModelPart getHiddenModelPart ( ImmutableList < String > path ) <nl> + { <nl> + return new HiddenModelPart ( path ) ; <nl> + } <nl> + <nl> + public static UnmodifiableIterator < String > getParts ( IModelPart part ) <nl> + { <nl> + if ( part instanceof HiddenModelPart ) <nl> + { <nl> + return ( ( HiddenModelPart ) part ) . getPath ( ) . iterator ( ) ; <nl> + } <nl> + return Iterators . emptyIterator ( ) ; <nl> + } <nl> + } <nl> diff - - git a / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java b / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java <nl> index bf25428 . . 78c6533 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java <nl> + + + b / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java <nl> @ @ - 1 , 7 + 1 , 6 @ @ <nl> package net . minecraftforge . debug ; <nl> <nl> import java . util . ArrayList ; <nl> - import java . util . Arrays ; <nl> import java . util . List ; <nl> <nl> import javax . vecmath . AxisAngle4d ; <nl> @ @ - 10 , 6 + 9 , 8 @ @ import javax . vecmath . Quat4f ; <nl> import javax . vecmath . Vector3d ; <nl> import javax . vecmath . Vector4f ; <nl> <nl> + import com . google . common . base . Optional ; <nl> + import com . google . common . collect . UnmodifiableIterator ; <nl> import net . minecraft . block . Block ; <nl> import net . minecraft . block . ITileEntityProvider ; <nl> import net . minecraft . block . material . Material ; <nl> @ @ - 36 , 16 + 37 , 17 @ @ import net . minecraft . util . math . MathHelper ; <nl> import net . minecraft . util . text . TextComponentString ; <nl> import net . minecraft . world . IBlockAccess ; <nl> import net . minecraft . world . World ; <nl> - import net . minecraftforge . client . model . IModel ; <nl> import net . minecraftforge . client . model . ModelLoader ; <nl> - import net . minecraftforge . client . model . ModelLoaderRegistry ; <nl> import net . minecraftforge . client . model . b3d . B3DLoader ; <nl> import net . minecraftforge . client . model . obj . OBJLoader ; <nl> - import net . minecraftforge . client . model . obj . OBJModel ; <nl> + import net . minecraftforge . common . model . IModelPart ; <nl> + import net . minecraftforge . common . model . IModelState ; <nl> + import net . minecraftforge . common . model . Models ; <nl> import net . minecraftforge . common . model . TRSRTransformation ; <nl> import net . minecraftforge . common . property . ExtendedBlockState ; <nl> import net . minecraftforge . common . property . IExtendedBlockState ; <nl> import net . minecraftforge . common . property . IUnlistedProperty ; <nl> + import net . minecraftforge . common . property . Properties ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> import net . minecraftforge . fml . common . Mod ; <nl> import net . minecraftforge . fml . common . Mod . EventHandler ; <nl> @ @ - 120 , 7 + 122 , 6 @ @ public class ModelLoaderRegistryDebug <nl> public static final CustomModelBlock instance = new CustomModelBlock ( ) ; <nl> public static final String name = " CustomModelBlock " ; <nl> private int counter = 1 ; <nl> - public ExtendedBlockState state = new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { B3DLoader . B3DFrameProperty . INSTANCE } ) ; <nl> <nl> private CustomModelBlock ( ) <nl> { <nl> @ @ - 163 , 7 + 164 , 7 @ @ public class ModelLoaderRegistryDebug <nl> { <nl> / / Only return an IExtendedBlockState from this method and createState ( ) , otherwise block placement might break ! <nl> B3DLoader . B3DState newState = new B3DLoader . B3DState ( null , counter ) ; <nl> - return ( ( IExtendedBlockState ) state ) . withProperty ( B3DLoader . B3DFrameProperty . INSTANCE , newState ) ; <nl> + return ( ( IExtendedBlockState ) state ) . withProperty ( Properties . AnimationProperty , newState ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 183 , 7 + 184 , 7 @ @ public class ModelLoaderRegistryDebug <nl> @ Override <nl> public BlockStateContainer createBlockState ( ) <nl> { <nl> - return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { B3DLoader . B3DFrameProperty . INSTANCE } ) ; <nl> + return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { Properties . AnimationProperty } ) ; <nl> } <nl> <nl> public static EnumFacing getFacingFromEntity ( World worldIn , BlockPos clickedBlock , EntityLivingBase entityIn ) <nl> @ @ - 221 , 7 + 222 , 6 @ @ public class ModelLoaderRegistryDebug <nl> { <nl> public static final OBJTesseractBlock instance = new OBJTesseractBlock ( ) ; <nl> public static final String name = " OBJTesseractBlock " ; <nl> - private ExtendedBlockState state = new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; <nl> <nl> private OBJTesseractBlock ( ) <nl> { <nl> @ @ - 247 , 19 + 247 , 10 @ @ public class ModelLoaderRegistryDebug <nl> public boolean isVisuallyOpaque ( ) { return false ; } <nl> <nl> @ Override <nl> - public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) <nl> - { <nl> - OBJTesseractTileEntity tileEntity = ( OBJTesseractTileEntity ) world . getTileEntity ( pos ) ; <nl> - OBJModel . OBJState retState = new OBJModel . OBJState ( tileEntity = = null ? Lists . newArrayList ( OBJModel . Group . ALL ) : tileEntity . visible , true ) ; <nl> - return ( ( IExtendedBlockState ) this . state . getBaseState ( ) ) . withProperty ( OBJModel . OBJProperty . INSTANCE , retState ) ; <nl> - } <nl> - <nl> - @ Override <nl> public boolean onBlockActivated ( World world , BlockPos pos , IBlockState state , EntityPlayer player , EnumHand hand , ItemStack heldItem , EnumFacing side , float hitX , float hitY , float hitZ ) <nl> { <nl> if ( world . getTileEntity ( pos ) = = null ) world . setTileEntity ( pos , new OBJTesseractTileEntity ( ) ) ; <nl> OBJTesseractTileEntity tileEntity = ( OBJTesseractTileEntity ) world . getTileEntity ( pos ) ; <nl> - IModel model = ModelLoaderRegistry . getModelOrMissing ( new ResourceLocation ( MODID . toLowerCase ( ) + " : " + " block / tesseract . obj " ) ) ; <nl> <nl> if ( player . isSneaking ( ) ) <nl> { <nl> @ @ - 267 , 19 + 258 , 9 @ @ public class ModelLoaderRegistryDebug <nl> } <nl> else <nl> { <nl> - if ( model ! = ModelLoaderRegistry . getMissingModel ( ) ) <nl> - { <nl> - tileEntity . setMax ( ( ( OBJModel ) model ) . getMatLib ( ) . getGroups ( ) . keySet ( ) . size ( ) - 1 ) ; <nl> - tileEntity . increment ( ) ; <nl> - } <nl> + tileEntity . increment ( ) ; <nl> } <nl> <nl> - if ( world . isRemote ) <nl> - { <nl> - / / wtf <nl> - / / OBJBakedModel objBaked = ( OBJBakedModel ) Minecraft . getMinecraft ( ) . getBlockRendererDispatcher ( ) . getModelFromBlockState ( state , world , pos ) ; <nl> - / / objBaked . scheduleRebake ( ) ; / / not necessarily needed for this specific case , but is available <nl> - } <nl> world . markBlockRangeForRenderUpdate ( pos , pos ) ; <nl> return false ; <nl> } <nl> @ @ - 289 , 69 + 270 , 85 @ @ public class ModelLoaderRegistryDebug <nl> { <nl> return true ; <nl> } <nl> + <nl> + @ Override <nl> + public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) <nl> + { <nl> + if ( world . getTileEntity ( pos ) ! = null & & world . getTileEntity ( pos ) instanceof OBJTesseractTileEntity ) <nl> + { <nl> + OBJTesseractTileEntity te = ( OBJTesseractTileEntity ) world . getTileEntity ( pos ) ; <nl> + return ( ( IExtendedBlockState ) state ) . withProperty ( Properties . AnimationProperty , te . state ) ; <nl> + } <nl> + return state ; <nl> + } <nl> + <nl> + @ Override <nl> + public BlockStateContainer createBlockState ( ) <nl> + { <nl> + return new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { Properties . AnimationProperty } ) ; <nl> + } <nl> } <nl> <nl> public static class OBJTesseractTileEntity extends TileEntity <nl> { <nl> private int counter = 1 ; <nl> - private int max = 2 ; <nl> - public List < String > visible = new ArrayList < String > ( ) ; <nl> - <nl> - public OBJTesseractTileEntity ( ) <nl> + private int max = 32 ; <nl> + private final List < String > hidden = new ArrayList < String > ( ) ; <nl> + private final IModelState state = new IModelState ( ) <nl> { <nl> - this . visible . add ( OBJModel . Group . ALL ) ; <nl> - } <nl> + private final Optional < TRSRTransformation > value = Optional . of ( TRSRTransformation . identity ( ) ) ; <nl> + <nl> + @ Override <nl> + public Optional < TRSRTransformation > apply ( Optional < ? extends IModelPart > part ) <nl> + { <nl> + if ( part . isPresent ( ) ) <nl> + { <nl> + / / This whole thing is subject to change , but should do for now . <nl> + UnmodifiableIterator < String > parts = Models . getParts ( part . get ( ) ) ; <nl> + if ( parts . hasNext ( ) ) <nl> + { <nl> + String name = parts . next ( ) ; <nl> + / / only interested in the root level <nl> + if ( ! parts . hasNext ( ) & & hidden . contains ( name ) ) <nl> + { <nl> + return value ; <nl> + } <nl> + } <nl> + } <nl> + return Optional . absent ( ) ; <nl> + } <nl> + } ; <nl> <nl> public void increment ( ) <nl> { <nl> - if ( this . visible . contains ( OBJModel . Group . ALL ) ) this . visible . remove ( OBJModel . Group . ALL ) ; <nl> if ( this . counter = = max ) <nl> { <nl> this . counter = 0 ; <nl> - this . visible . clear ( ) ; <nl> + this . hidden . clear ( ) ; <nl> } <nl> this . counter + + ; <nl> - this . visible . add ( Integer . toString ( this . counter ) ) ; <nl> + this . hidden . add ( Integer . toString ( this . counter ) ) ; <nl> TextComponentString text = new TextComponentString ( " " + this . counter ) ; <nl> if ( this . worldObj . isRemote ) Minecraft . getMinecraft ( ) . ingameGUI . getChatGUI ( ) . printChatMessage ( text ) ; <nl> } <nl> <nl> public void decrement ( ) <nl> { <nl> - if ( this . visible . contains ( OBJModel . Group . ALL ) ) this . visible . remove ( OBJModel . Group . ALL ) ; <nl> if ( this . counter = = 1 ) <nl> { <nl> this . counter = max + 1 ; <nl> - for ( int i = 1 ; i < max ; i + + ) this . visible . add ( Integer . toString ( i ) ) ; <nl> + for ( int i = 1 ; i < max ; i + + ) this . hidden . add ( Integer . toString ( i ) ) ; <nl> } <nl> - this . visible . remove ( Integer . toString ( this . counter ) ) ; <nl> + this . hidden . remove ( Integer . toString ( this . counter ) ) ; <nl> this . counter - - ; <nl> TextComponentString text = new TextComponentString ( " " + this . counter ) ; <nl> if ( this . worldObj . isRemote ) Minecraft . getMinecraft ( ) . ingameGUI . getChatGUI ( ) . printChatMessage ( text ) ; <nl> } <nl> <nl> - public void reset ( ) <nl> - { <nl> - this . counter = 1 ; <nl> - this . max = 2 ; <nl> - this . visible . clear ( ) ; <nl> - this . visible . add ( Integer . toString ( this . counter ) ) ; <nl> - } <nl> - <nl> - public int getMax ( ) <nl> - { <nl> - return this . max ; <nl> - } <nl> - <nl> public void setMax ( int max ) <nl> { <nl> this . max = max ; <nl> } <nl> - <nl> - public void setToMax ( ) <nl> - { <nl> - this . counter = this . max ; <nl> - } <nl> } <nl> <nl> / * * <nl> @ @ - 431 , 7 + 428 , 7 @ @ public class ModelLoaderRegistryDebug <nl> @ Override <nl> public BlockStateContainer createBlockState ( ) <nl> { <nl> - return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; <nl> + return new BlockStateContainer ( this , FACING ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 443 , 15 + 440 , 6 @ @ public class ModelLoaderRegistryDebug <nl> @ Override <nl> public boolean isVisuallyOpaque ( ) { return false ; } <nl> <nl> - @ Override <nl> - public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) <nl> - { <nl> - EnumFacing facing = ( EnumFacing ) state . getValue ( FACING ) ; <nl> - TRSRTransformation transform = new TRSRTransformation ( facing ) ; <nl> - OBJModel . OBJState retState = new OBJModel . OBJState ( Arrays . asList ( new String [ ] { OBJModel . Group . ALL } ) , true , transform ) ; <nl> - return ( ( IExtendedBlockState ) state ) . withProperty ( OBJModel . OBJProperty . INSTANCE , retState ) ; <nl> - } <nl> - <nl> public static EnumFacing getFacingFromEntity ( World worldIn , BlockPos clickedBlock , EntityLivingBase entityIn ) <nl> { <nl> if ( MathHelper . abs ( ( float ) entityIn . posX - ( float ) clickedBlock . getX ( ) ) < 2 . 0F & & MathHelper . abs ( ( float ) entityIn . posZ - ( float ) clickedBlock . getZ ( ) ) < 2 . 0F ) <nl> @ @ - 586 , 7 + 574 , 6 @ @ public class ModelLoaderRegistryDebug <nl> public static final PropertyDirection FACING = PropertyDirection . create ( " facing " ) ; <nl> public static final OBJDirectionBlock instance = new OBJDirectionBlock ( ) ; <nl> public static final String name = " OBJDirectionBlock " ; <nl> - public ExtendedBlockState state = new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; <nl> <nl> private OBJDirectionBlock ( ) <nl> { <nl> @ @ - 625 , 19 + 612 , 9 @ @ public class ModelLoaderRegistryDebug <nl> } <nl> <nl> @ Override <nl> - public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) <nl> - { <nl> - / / Only return an IExtendedBlockState from this method and createState ( ) , otherwise block placement will break ! <nl> - EnumFacing facing = ( EnumFacing ) state . getValue ( FACING ) ; <nl> - TRSRTransformation transform = new TRSRTransformation ( facing ) ; <nl> - OBJModel . OBJState newState = new OBJModel . OBJState ( Lists . newArrayList ( OBJModel . Group . ALL ) , true , transform ) ; <nl> - return ( ( IExtendedBlockState ) state ) . withProperty ( OBJModel . OBJProperty . INSTANCE , newState ) ; <nl> - } <nl> - <nl> - @ Override <nl> public BlockStateContainer createBlockState ( ) <nl> { <nl> - return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; <nl> + return new BlockStateContainer ( this , FACING ) ; <nl> } <nl> <nl> public static EnumFacing getFacingFromEntity ( World worldIn , BlockPos clickedBlock , EntityLivingBase entityIn ) <nl> @ @ - 732 , 7 + 709 , 6 @ @ public class ModelLoaderRegistryDebug <nl> { <nl> public static final OBJDynamicEye instance = new OBJDynamicEye ( ) ; <nl> public static final String name = " OBJDynamicEye " ; <nl> - public ExtendedBlockState state = new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; <nl> private OBJDynamicEye ( ) <nl> { <nl> super ( Material . IRON ) ; <nl> @ @ - 771 , 9 + 747 , 9 @ @ public class ModelLoaderRegistryDebug <nl> if ( world . getTileEntity ( pos ) ! = null & & world . getTileEntity ( pos ) instanceof OBJDynamicEyeTileEntity ) <nl> { <nl> OBJDynamicEyeTileEntity te = ( OBJDynamicEyeTileEntity ) world . getTileEntity ( pos ) ; <nl> - if ( te . state ! = null ) <nl> + if ( te . transform ! = TRSRTransformation . identity ( ) ) <nl> { <nl> - return ( ( IExtendedBlockState ) this . state . getBaseState ( ) ) . withProperty ( OBJModel . OBJProperty . INSTANCE , te . state ) ; <nl> + return ( ( IExtendedBlockState ) state ) . withProperty ( Properties . AnimationProperty , te . transform ) ; <nl> } <nl> } <nl> return state ; <nl> @ @ - 782 , 18 + 758 , 13 @ @ public class ModelLoaderRegistryDebug <nl> @ Override <nl> public BlockStateContainer createBlockState ( ) <nl> { <nl> - return new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; <nl> + return new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { Properties . AnimationProperty } ) ; <nl> } <nl> } <nl> <nl> public static class OBJDynamicEyeTileEntity extends TileEntity implements ITickable <nl> { <nl> - public OBJModel . OBJState state ; <nl> - <nl> - public OBJDynamicEyeTileEntity ( ) <nl> - { <nl> - this . state = new OBJModel . OBJState ( Lists . newArrayList ( OBJModel . Group . ALL ) , true ) ; <nl> - } <nl> + private TRSRTransformation transform = TRSRTransformation . identity ( ) ; <nl> <nl> @ Override <nl> public void update ( ) <nl> @ @ - 821 , 9 + 792 , 7 @ @ public class ModelLoaderRegistryDebug <nl> Matrix4f matrix = new Matrix4f ( ) ; <nl> matrix . setIdentity ( ) ; <nl> matrix . setRotation ( rot ) ; <nl> - TRSRTransformation transform = new TRSRTransformation ( matrix ) ; <nl> - transform = TRSRTransformation . blockCenterToCorner ( transform ) ; <nl> - this . state = new OBJModel . OBJState ( Lists . newArrayList ( OBJModel . Group . ALL ) , true , transform ) ; <nl> + transform = TRSRTransformation . blockCenterToCorner ( new TRSRTransformation ( matrix ) ) ; <nl> this . worldObj . markBlockRangeForRenderUpdate ( this . pos , this . pos ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> index 2b327cc . . eb77317 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> @ @ - 32 , 8 + 32 , 8 @ @ import net . minecraft . client . renderer . block . model . ItemModelGenerator ; <nl> import net . minecraft . client . renderer . block . model . ModelBlock ; <nl> import net . minecraft . client . renderer . block . model . ModelBlockDefinition ; <nl> import net . minecraft . client . renderer . block . model . ModelBlockDefinition . MissingVariantException ; <nl> - import net . minecraft . client . renderer . block . model . ModelBlockDefinition . Variant ; <nl> - import net . minecraft . client . renderer . block . model . ModelBlockDefinition . Variants ; <nl> + import net . minecraft . client . renderer . block . model . Variant ; <nl> + import net . minecraft . client . renderer . block . model . VariantList ; <nl> import net . minecraft . client . renderer . block . statemap . IStateMapper ; <nl> import net . minecraft . client . renderer . texture . IIconCreator ; <nl> import net . minecraft . client . renderer . texture . TextureAtlasSprite ; <nl> @ @ - 53 , 7 + 53 , 7 @ @ import net . minecraft . item . Item ; <nl> import net . minecraft . item . ItemStack ; <nl> import net . minecraft . launchwrapper . Launch ; <nl> import net . minecraft . util . EnumFacing ; <nl> - import net . minecraft . util . IRegistry ; <nl> + import net . minecraft . util . registry . IRegistry ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . client . model . animation . Animation ; <nl> import net . minecraftforge . client . model . animation . IAnimatedModel ; <nl> @ @ - 78 , 7 + 78 , 6 @ @ import com . google . common . base . Function ; <nl> import com . google . common . base . Optional ; <nl> import com . google . common . base . Throwables ; <nl> <nl> - @ SuppressWarnings ( " ALL " ) <nl> public class ModelLoader extends ModelBakery <nl> { <nl> private final Map < ModelResourceLocation , IModel > stateModels = Maps . newHashMap ( ) ; <nl> @ @ - 132 , 7 + 131 , 7 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> } <nl> } ) ; <nl> - IFlexibleBakedModel missingBaked = missingModel . bake ( missingModel . getDefaultState ( ) , DefaultVertexFormats . ITEM , DefaultTextureGetter . instance ) ; <nl> + IBakedModel missingBaked = missingModel . bake ( missingModel . getDefaultState ( ) , DefaultVertexFormats . ITEM , DefaultTextureGetter . instance ) ; <nl> for ( Entry < ModelResourceLocation , IModel > e : stateModels . entrySet ( ) ) <nl> { <nl> if ( e . getValue ( ) = = getMissingModel ( ) ) <nl> @ @ - 172 , 7 + 171 , 7 @ @ public class ModelLoader extends ModelBakery <nl> @ Override <nl> protected void registerVariant ( ModelBlockDefinition definition , ModelResourceLocation location ) <nl> { <nl> - Variants variants = null ; <nl> + VariantList variants = null ; <nl> try <nl> { <nl> variants = definition . getVariants ( location . getVariant ( ) ) ; <nl> @ @ - 480 , 7 + 479 , 7 @ @ public class ModelLoader extends ModelBakery <nl> { <nl> builder . add ( loc ) ; <nl> } <nl> - / / mojang hardcode <nl> + / * / / mojang hardcode <nl> if ( model . getRootModel ( ) = = MODEL _ COMPASS & & ! loc . equals ( TextureMap . LOCATION _ MISSING _ TEXTURE ) ) <nl> { <nl> TextureAtlasSprite . setLocationNameCompass ( loc . toString ( ) ) ; <nl> @ @ - 488 , 7 + 487 , 7 @ @ public class ModelLoader extends ModelBakery <nl> else if ( model . getRootModel ( ) = = MODEL _ CLOCK & & ! loc . equals ( TextureMap . LOCATION _ MISSING _ TEXTURE ) ) <nl> { <nl> TextureAtlasSprite . setLocationNameClock ( loc . toString ( ) ) ; <nl> - } <nl> + } * / <nl> } <nl> } <nl> for ( String s : model . textures . values ( ) ) <nl> @ @ - 501 , 7 + 500 , 7 @ @ public class ModelLoader extends ModelBakery <nl> return builder . build ( ) ; <nl> } <nl> <nl> - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> + public IBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> { <nl> if ( ! Attributes . moreSpecific ( format , Attributes . DEFAULT _ BAKED _ FORMAT ) ) <nl> { <nl> @ @ - 533 , 11 + 532 , 11 @ @ public class ModelLoader extends ModelBakery <nl> { <nl> return new ItemLayerModel ( model ) . bake ( perState , format , bakedTextureGetter ) ; <nl> } <nl> - if ( isCustomRenderer ( model ) ) return new IFlexibleBakedModel . Wrapper ( new BuiltInModel ( transforms ) , format ) ; <nl> + if ( isCustomRenderer ( model ) ) return new BuiltInModel ( transforms ) ; <nl> return bakeNormal ( model , perState , state . apply ( Optional . < IModelPart > absent ( ) ) . or ( TRSRTransformation . identity ( ) ) , newTransforms , format , bakedTextureGetter , uvlock ) ; <nl> } <nl> <nl> - private IFlexibleBakedModel bakeNormal ( ModelBlock model , IModelState perState , final TRSRTransformation modelState , List < TRSRTransformation > newTransforms , VertexFormat format , final Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter , boolean uvLocked ) <nl> + private IBakedModel bakeNormal ( ModelBlock model , IModelState perState , final TRSRTransformation modelState , List < TRSRTransformation > newTransforms , VertexFormat format , final Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter , boolean uvLocked ) <nl> { <nl> TextureAtlasSprite particle = bakedTextureGetter . apply ( new ResourceLocation ( model . resolveTextureName ( " particle " ) ) ) ; <nl> SimpleBakedModel . Builder builder = ( new SimpleBakedModel . Builder ( model ) ) . setTexture ( particle ) ; <nl> @ @ - 567 , 7 + 566 , 8 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> } <nl> <nl> - return new ISmartBlockModel . PerspectiveWrapper ( new IPerspectiveAwareModel . MapWrapper ( new IFlexibleBakedModel . Wrapper ( builder . makeBakedModel ( ) , format ) , perState ) ) <nl> + / / FIXME <nl> + return new ISmartBlockModel . PerspectiveWrapper ( new IPerspectiveAwareModel . MapWrapper ( builder . makeBakedModel ( ) , perState ) ) <nl> { <nl> public IBakedModel handleBlockState ( IBlockState state ) <nl> { <nl> @ @ - 576 , 7 + 576 , 7 @ @ public class ModelLoader extends ModelBakery <nl> } ; <nl> } <nl> <nl> - private IBakedModel handleBlockState ( IFlexibleBakedModel model , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter , TRSRTransformation modelState , IBlockState state ) <nl> + private IBakedModel handleBlockState ( IBakedModel model , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter , TRSRTransformation modelState , IBlockState state ) <nl> { <nl> if ( state instanceof IExtendedBlockState ) <nl> { <nl> @ @ - 594 , 7 + 594 , 7 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> <nl> @ Override <nl> - public IModel retexture ( ImmutableMap < String , String > textures ) <nl> + public VanillaModelWrapper retexture ( ImmutableMap < String , String > textures ) <nl> { <nl> if ( textures . isEmpty ( ) ) <nl> return this ; <nl> @ @ - 724 , 11 + 724 , 11 @ @ public class ModelLoader extends ModelBakery <nl> private final List < IModel > models = new ArrayList < IModel > ( ) ; <nl> private final IModelState defaultState ; <nl> <nl> - public WeightedRandomModel ( ModelResourceLocation parent , Variants variants ) <nl> + public WeightedRandomModel ( ModelResourceLocation parent , VariantList variants ) <nl> { <nl> - this . variants = variants . getVariants ( ) ; <nl> + this . variants = variants . func _ 188114 _ a ( ) ; <nl> ImmutableList . Builder < Pair < IModel , IModelState > > builder = ImmutableList . builder ( ) ; <nl> - for ( Variant v : variants . getVariants ( ) ) <nl> + for ( Variant v : this . variants ) <nl> { <nl> ResourceLocation loc = v . getModelLocation ( ) ; <nl> locations . add ( loc ) ; <nl> @ @ - 793 , 7 + 793 , 7 @ @ public class ModelLoader extends ModelBakery <nl> return state ; <nl> } <nl> <nl> - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> + public IBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> { <nl> if ( ! Attributes . moreSpecific ( format , Attributes . DEFAULT _ BAKED _ FORMAT ) ) <nl> { <nl> @ @ - 812 , 7 + 812 , 7 @ @ public class ModelLoader extends ModelBakery <nl> Variant v = variants . get ( i ) ; <nl> builder . add ( model . bake ( addUV ( v . isUvLocked ( ) , MultiModelState . getPartState ( state , model , i ) ) , format , bakedTextureGetter ) , variants . get ( i ) . getWeight ( ) ) ; <nl> } <nl> - return new FlexibleWeightedBakedModel ( builder . build ( ) , Attributes . DEFAULT _ BAKED _ FORMAT ) ; <nl> + return builder . build ( ) ; <nl> } <nl> <nl> public IModelState getDefaultState ( ) <nl> @ @ - 821 , 22 + 821 , 6 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> } <nl> <nl> - private static class FlexibleWeightedBakedModel extends WeightedBakedModel implements IFlexibleBakedModel <nl> - { <nl> - private final VertexFormat format ; <nl> - <nl> - public FlexibleWeightedBakedModel ( WeightedBakedModel parent , VertexFormat format ) <nl> - { <nl> - super ( parent . models ) ; <nl> - this . format = format ; <nl> - } <nl> - <nl> - public VertexFormat getFormat ( ) <nl> - { <nl> - return format ; <nl> - } <nl> - } <nl> - <nl> public IModel getMissingModel ( ) <nl> { <nl> if ( missingModel = = null ) <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> index eb60e17 . . 271ee94 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> @ @ - 19 , 11 + 19 , 11 @ @ import net . minecraft . client . renderer . block . model . BakedQuad ; <nl> import net . minecraft . client . renderer . block . model . IBakedModel ; <nl> import net . minecraft . client . renderer . block . model . ItemCameraTransforms ; <nl> import net . minecraft . client . renderer . block . model . ItemCameraTransforms . TransformType ; <nl> + import net . minecraft . client . renderer . block . model . ItemOverrideList ; <nl> import net . minecraft . client . renderer . texture . TextureAtlasSprite ; <nl> import net . minecraft . client . renderer . vertex . VertexFormat ; <nl> import net . minecraft . client . resources . IResource ; <nl> import net . minecraft . client . resources . IResourceManager ; <nl> - import net . minecraft . item . ItemStack ; <nl> import net . minecraft . util . EnumFacing ; <nl> import net . minecraft . util . math . MathHelper ; <nl> import net . minecraft . util . ResourceLocation ; <nl> @ @ - 68 , 7 + 68 , 6 @ @ import com . google . gson . JsonParser ; <nl> * To enable for your mod call instance . addDomain ( modid ) . <nl> * If you need more control over accepted resources - extend the class , and register a new instance with ModelLoaderRegistry . <nl> * / <nl> - @ SuppressWarnings ( " deprecation " ) <nl> public class B3DLoader implements ICustomModelLoader <nl> { <nl> public static final B3DLoader instance = new B3DLoader ( ) ; <nl> @ @ - 487 , 7 + 486 , 7 @ @ public class B3DLoader implements ICustomModelLoader <nl> } <nl> <nl> @ Override <nl> - public IModel retexture ( ImmutableMap < String , String > textures ) <nl> + public ModelWrapper retexture ( ImmutableMap < String , String > textures ) <nl> { <nl> ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; <nl> for ( Map . Entry < String , ResourceLocation > e : this . textures . entrySet ( ) ) <nl> @ @ - 509 , 7 + 508 , 7 @ @ public class B3DLoader implements ICustomModelLoader <nl> } <nl> <nl> @ Override <nl> - public IModel process ( ImmutableMap < String , String > data ) <nl> + public ModelWrapper process ( ImmutableMap < String , String > data ) <nl> { <nl> if ( data . containsKey ( " mesh " ) ) <nl> { <nl> @ @ - 601 , 7 + 600 , 7 @ @ public class B3DLoader implements ICustomModelLoader <nl> private final VertexFormat format ; <nl> private final ImmutableSet < String > meshes ; <nl> private final ImmutableMap < String , TextureAtlasSprite > textures ; <nl> - private final LoadingCache < Integer , BakedWrapper > cache ; <nl> + private final LoadingCache < Integer , B3DState > cache ; <nl> <nl> private ImmutableList < BakedQuad > quads ; <nl> <nl> @ @ - 610 , 9 + 609 , 9 @ @ public class B3DLoader implements ICustomModelLoader <nl> this ( node , state , smooth , gui3d , format , meshes , textures , CacheBuilder . newBuilder ( ) <nl> . maximumSize ( 128 ) <nl> . expireAfterAccess ( 2 , TimeUnit . MINUTES ) <nl> - . < Integer , BakedWrapper > build ( new CacheLoader < Integer , BakedWrapper > ( ) <nl> + . < Integer , B3DState > build ( new CacheLoader < Integer , B3DState > ( ) <nl> { <nl> - public BakedWrapper load ( Integer frame ) throws Exception <nl> + public B3DState load ( Integer frame ) throws Exception <nl> { <nl> IModelState parent = state ; <nl> Animation newAnimation = node . getAnimation ( ) ; <nl> @ @ - 621 , 12 + 620 , 12 @ @ public class B3DLoader implements ICustomModelLoader <nl> B3DState ps = ( B3DState ) parent ; <nl> parent = ps . getParent ( ) ; <nl> } <nl> - return new BakedWrapper ( node , new B3DState ( newAnimation , frame , frame , 0 , parent ) , smooth , gui3d , format , meshes , textures ) ; <nl> + return new B3DState ( newAnimation , frame , frame , 0 , parent ) ; <nl> } <nl> } ) ) ; <nl> } <nl> <nl> - public BakedWrapper ( Node < ? > node , IModelState state , boolean smooth , boolean gui3d , VertexFormat format , ImmutableSet < String > meshes , ImmutableMap < String , TextureAtlasSprite > textures , LoadingCache < Integer , BakedWrapper > cache ) <nl> + public BakedWrapper ( Node < ? > node , IModelState state , boolean smooth , boolean gui3d , VertexFormat format , ImmutableSet < String > meshes , ImmutableMap < String , TextureAtlasSprite > textures , LoadingCache < Integer , B3DState > cache ) <nl> { <nl> this . node = node ; <nl> this . state = state ; <nl> @ @ - 638 , 61 + 637 , 113 @ @ public class B3DLoader implements ICustomModelLoader <nl> this . cache = cache ; <nl> } <nl> <nl> - / / FIXME merge with handleBlockState <nl> @ Override <nl> - public List < BakedQuad > getGeneralQuads ( ) <nl> + public List < BakedQuad > func _ 188616 _ a ( IBlockState state , EnumFacing side , long rand ) <nl> { <nl> - if ( quads = = null ) <nl> + if ( side ! = null ) return ImmutableList . of ( ) ; <nl> + IModelState modelState = this . state ; <nl> + if ( state instanceof IExtendedBlockState ) <nl> { <nl> - ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; <nl> - for ( Node < ? > child : node . getNodes ( ) . values ( ) ) <nl> - { <nl> - builder . addAll ( new BakedWrapper ( child , state , smooth , gui3d , format , meshes , textures ) . getGeneralQuads ( ) ) ; <nl> - } <nl> - if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) ) <nl> + IExtendedBlockState exState = ( IExtendedBlockState ) state ; <nl> + if ( exState . getUnlistedNames ( ) . contains ( B3DFrameProperty . instance ) ) <nl> { <nl> - Mesh mesh = ( Mesh ) node . getKind ( ) ; <nl> - Collection < Face > faces = mesh . bake ( new Function < Node < ? > , Matrix4f > ( ) <nl> + B3DState s = exState . getValue ( B3DFrameProperty . instance ) ; <nl> + if ( s ! = null ) <nl> { <nl> - private final TRSRTransformation global = state . apply ( Optional . < IModelPart > absent ( ) ) . or ( TRSRTransformation . identity ( ) ) ; <nl> - private final LoadingCache < Node < ? > , TRSRTransformation > localCache = CacheBuilder . newBuilder ( ) <nl> - . maximumSize ( 32 ) <nl> - . build ( new CacheLoader < Node < ? > , TRSRTransformation > ( ) <nl> - { <nl> - public TRSRTransformation load ( Node < ? > node ) throws Exception <nl> - { <nl> - return state . apply ( Optional . of ( new NodeJoint ( node ) ) ) . or ( TRSRTransformation . identity ( ) ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - public Matrix4f apply ( Node < ? > node ) <nl> + / / return getCachedModel ( s . getFrame ( ) ) ; <nl> + IModelState parent = this . state ; <nl> + Animation newAnimation = s . getAnimation ( ) ; <nl> + if ( parent instanceof B3DState ) <nl> + { <nl> + B3DState ps = ( B3DState ) parent ; <nl> + parent = ps . getParent ( ) ; <nl> + } <nl> + if ( newAnimation = = null ) <nl> + { <nl> + newAnimation = node . getAnimation ( ) ; <nl> + } <nl> + if ( s . getFrame ( ) = = s . getNextFrame ( ) ) <nl> + { <nl> + modelState = cache . getUnchecked ( s . getFrame ( ) ) ; <nl> + } <nl> + else <nl> { <nl> - return global . compose ( localCache . getUnchecked ( node ) ) . getMatrix ( ) ; <nl> + modelState = new B3DState ( newAnimation , s . getFrame ( ) , s . getNextFrame ( ) , s . getProgress ( ) , parent ) ; <nl> } <nl> - } ) ; <nl> - for ( Face f : faces ) <nl> + } <nl> + } <nl> + else if ( exState . getUnlistedNames ( ) . contains ( Properties . AnimationProperty ) ) <nl> + { <nl> + / / FIXME : should animation state handle the parent state , or should it remain here ? <nl> + IModelState parent = this . state ; <nl> + if ( parent instanceof B3DState ) <nl> + { <nl> + B3DState ps = ( B3DState ) parent ; <nl> + parent = ps . getParent ( ) ; <nl> + } <nl> + IModelState newState = exState . getValue ( Properties . AnimationProperty ) ; <nl> + if ( newState ! = null ) <nl> { <nl> - UnpackedBakedQuad . Builder quadBuilder = new UnpackedBakedQuad . Builder ( format ) ; <nl> - quadBuilder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; <nl> - quadBuilder . setQuadColored ( ) ; <nl> - List < Texture > textures = null ; <nl> - if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; <nl> - TextureAtlasSprite sprite ; <nl> - if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; <nl> - else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; <nl> - else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; <nl> - putVertexData ( quadBuilder , f . getV1 ( ) , f . getNormal ( ) , sprite ) ; <nl> - putVertexData ( quadBuilder , f . getV2 ( ) , f . getNormal ( ) , sprite ) ; <nl> - putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; <nl> - putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; <nl> - builder . add ( quadBuilder . build ( ) ) ; <nl> + modelState = new ModelStateComposition ( parent , newState ) ; <nl> } <nl> } <nl> + } <nl> + if ( quads = = null ) <nl> + { <nl> + ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; <nl> + generateQuads ( builder , node , modelState ) ; <nl> quads = builder . build ( ) ; <nl> } <nl> return quads ; <nl> } <nl> <nl> + protected void generateQuads ( ImmutableList . Builder < BakedQuad > builder , Node < ? > node , final IModelState state ) <nl> + { <nl> + for ( Node < ? > child : node . getNodes ( ) . values ( ) ) <nl> + { <nl> + generateQuads ( builder , child , state ) ; <nl> + } <nl> + if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) ) <nl> + { <nl> + Mesh mesh = ( Mesh ) node . getKind ( ) ; <nl> + Collection < Face > faces = mesh . bake ( new Function < Node < ? > , Matrix4f > ( ) <nl> + { <nl> + private final TRSRTransformation global = state . apply ( Optional . < IModelPart > absent ( ) ) . or ( TRSRTransformation . identity ( ) ) ; <nl> + private final LoadingCache < Node < ? > , TRSRTransformation > localCache = CacheBuilder . newBuilder ( ) <nl> + . maximumSize ( 32 ) <nl> + . build ( new CacheLoader < Node < ? > , TRSRTransformation > ( ) <nl> + { <nl> + public TRSRTransformation load ( Node < ? > node ) throws Exception <nl> + { <nl> + return state . apply ( Optional . of ( new NodeJoint ( node ) ) ) . or ( TRSRTransformation . identity ( ) ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + public Matrix4f apply ( Node < ? > node ) <nl> + { <nl> + return global . compose ( localCache . getUnchecked ( node ) ) . getMatrix ( ) ; <nl> + } <nl> + } ) ; <nl> + for ( Face f : faces ) <nl> + { <nl> + UnpackedBakedQuad . Builder quadBuilder = new UnpackedBakedQuad . Builder ( format ) ; <nl> + quadBuilder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; <nl> + quadBuilder . setQuadColored ( ) ; <nl> + List < Texture > textures = null ; <nl> + if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; <nl> + TextureAtlasSprite sprite ; <nl> + if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; <nl> + else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; <nl> + else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; <nl> + putVertexData ( quadBuilder , f . getV1 ( ) , f . getNormal ( ) , sprite ) ; <nl> + putVertexData ( quadBuilder , f . getV2 ( ) , f . getNormal ( ) , sprite ) ; <nl> + putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; <nl> + putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; <nl> + builder . add ( quadBuilder . build ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> private final void putVertexData ( UnpackedBakedQuad . Builder builder , Vertex v , Vector3f faceNormal , TextureAtlasSprite sprite ) <nl> { <nl> / / TODO handle everything not handled ( texture transformations , bones , transformations , normals , e . t . c ) <nl> @ @ - 772 , 60 + 823 , 16 @ @ public class B3DLoader implements ICustomModelLoader <nl> return ItemCameraTransforms . DEFAULT ; <nl> } <nl> <nl> - / / FIXME merge with getQuads <nl> - @ Override <nl> - public BakedWrapper handleBlockState ( IBlockState state ) <nl> + public Pair < ? extends IBakedModel , Matrix4f > handlePerspective ( TransformType cameraTransformType ) <nl> { <nl> - if ( state instanceof IExtendedBlockState ) <nl> - { <nl> - IExtendedBlockState exState = ( IExtendedBlockState ) state ; <nl> - if ( exState . getUnlistedNames ( ) . contains ( B3DFrameProperty . instance ) ) <nl> - { <nl> - B3DState s = exState . getValue ( B3DFrameProperty . instance ) ; <nl> - if ( s ! = null ) <nl> - { <nl> - / / return getCachedModel ( s . getFrame ( ) ) ; <nl> - IModelState parent = this . state ; <nl> - Animation newAnimation = s . getAnimation ( ) ; <nl> - if ( parent instanceof B3DState ) <nl> - { <nl> - B3DState ps = ( B3DState ) parent ; <nl> - parent = ps . getParent ( ) ; <nl> - } <nl> - if ( newAnimation = = null ) <nl> - { <nl> - newAnimation = node . getAnimation ( ) ; <nl> - } <nl> - if ( s . getFrame ( ) = = s . getNextFrame ( ) ) <nl> - { <nl> - return cache . getUnchecked ( s . getFrame ( ) ) ; <nl> - } <nl> - B3DState newState = new B3DState ( newAnimation , s . getFrame ( ) , s . getNextFrame ( ) , s . getProgress ( ) , parent ) ; <nl> - return new BakedWrapper ( node , newState , smooth , gui3d , format , meshes , textures ) ; <nl> - } <nl> - } <nl> - else if ( exState . getUnlistedNames ( ) . contains ( Properties . AnimationProperty ) ) <nl> - { <nl> - / / FIXME : should animation state handle the parent state , or should it remain here ? <nl> - IModelState parent = this . state ; <nl> - if ( parent instanceof B3DState ) <nl> - { <nl> - B3DState ps = ( B3DState ) parent ; <nl> - parent = ps . getParent ( ) ; <nl> - } <nl> - IModelState newState = exState . getValue ( Properties . AnimationProperty ) ; <nl> - if ( newState ! = null ) <nl> - { <nl> - return new BakedWrapper ( node , new ModelStateComposition ( parent , newState ) , smooth , gui3d , format , meshes , textures ) ; <nl> - } <nl> - } <nl> - } <nl> - return this ; <nl> + return IPerspectiveAwareModel . MapWrapper . handlePerspective ( this , state , cameraTransformType ) ; <nl> } <nl> <nl> - public Pair < ? extends IBakedModel , Matrix4f > handlePerspective ( TransformType cameraTransformType ) <nl> + @ Override <nl> + public ItemOverrideList func _ 188617 _ f ( ) <nl> { <nl> - return IPerspectiveAwareModel . MapWrapper . handlePerspective ( this , state , cameraTransformType ) ; <nl> + / / TODO handle items <nl> + return ItemOverrideList . field _ 188022 _ a ; <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 index 67044e5 . . 45f4809 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 @ @ - 63 , 6 + 63 , 7 @ @ import net . minecraftforge . client . model . animation . ModelBlockAnimation ; 
 import net . minecraftforge . common . ForgeModContainer ; 
 import net . minecraftforge . common . model . IModelPart ; 
 import net . minecraftforge . common . model . IModelState ; 
 + import net . minecraftforge . common . model . Models ; 
 import net . minecraftforge . common . model . TRSRTransformation ; 
 import net . minecraftforge . common . model . animation . IClip ; 
 import net . minecraftforge . common . property . IExtendedBlockState ; 
 @ @ - 526 , 6 + 527 , 10 @ @ public final class ModelLoader extends ModelBakery 
 SimpleBakedModel . Builder builder = ( new SimpleBakedModel . Builder ( model , model . createOverrides ( ) ) ) . setTexture ( particle ) ; 
 for ( int i = 0 ; i < model . getElements ( ) . size ( ) ; i + + ) 
 { 
 + if ( modelState . apply ( Optional . of ( Models . getHiddenModelPart ( ImmutableList . of ( Integer . toString ( i ) ) ) ) ) . isPresent ( ) ) 
 + { 
 + continue ; 
 + } 
 BlockPart part = model . getElements ( ) . get ( i ) ; 
 TRSRTransformation transformation = baseState ; 
 if ( newTransforms . get ( i ) ! = null ) 
 diff - - git a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 index 02f92be . . d0bcfeb 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 @ @ - 47 , 6 + 47 , 7 @ @ import net . minecraftforge . client . model . b3d . B3DModel . Vertex ; 
 import net . minecraftforge . client . model . pipeline . UnpackedBakedQuad ; 
 import net . minecraftforge . common . model . IModelPart ; 
 import net . minecraftforge . common . model . IModelState ; 
 + import net . minecraftforge . common . model . Models ; 
 import net . minecraftforge . common . model . TRSRTransformation ; 
 import net . minecraftforge . common . model . animation . IClip ; 
 import net . minecraftforge . common . model . animation . IJoint ; 
 @ @ - 209 , 7 + 210 , 14 @ @ public enum B3DLoader implements ICustomModelLoader 
 public Optional < TRSRTransformation > apply ( Optional < ? extends IModelPart > part ) 
 { 
 / / TODO make more use of Optional 
 - if ( ! part . isPresent ( ) ) return parent . apply ( part ) ; 
 + if ( ! part . isPresent ( ) ) 
 + { 
 + if ( parent ! = null ) 
 + { 
 + return parent . apply ( part ) ; 
 + } 
 + return Optional . absent ( ) ; 
 + } 
 if ( ! ( part . get ( ) instanceof NodeJoint ) ) 
 { 
 return Optional . absent ( ) ; 
 @ @ - 364 , 6 + 372 , 10 @ @ public enum B3DLoader implements ICustomModelLoader 
 } 
 } 
 
 + / * * 
 + * @ deprecated use AnimationProperty . 
 + * / 
 + @ Deprecated 
 public static enum B3DFrameProperty implements IUnlistedProperty < B3DState > 
 { 
 INSTANCE ; 
 @ @ - 679 , 26 + 691 , 30 @ @ public enum B3DLoader implements ICustomModelLoader 
 if ( quads = = null ) 
 { 
 ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; 
 - generateQuads ( builder , node , this . state ) ; 
 + generateQuads ( builder , node , this . state , ImmutableList . < String > of ( ) ) ; 
 quads = builder . build ( ) ; 
 } 
 / / TODO : caching ? 
 if ( this . state ! = modelState ) 
 { 
 ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; 
 - generateQuads ( builder , node , modelState ) ; 
 + generateQuads ( builder , node , modelState , ImmutableList . < String > of ( ) ) ; 
 return builder . build ( ) ; 
 } 
 return quads ; 
 } 
 
 - private void generateQuads ( ImmutableList . Builder < BakedQuad > builder , Node < ? > node , final IModelState state ) 
 + private void generateQuads ( ImmutableList . Builder < BakedQuad > builder , Node < ? > node , final IModelState state , ImmutableList < String > path ) 
 { 
 + ImmutableList . Builder < String > pathBuilder = ImmutableList . builder ( ) ; 
 + pathBuilder . addAll ( path ) ; 
 + pathBuilder . add ( node . getName ( ) ) ; 
 + ImmutableList < String > newPath = pathBuilder . build ( ) ; 
 for ( Node < ? > child : node . getNodes ( ) . values ( ) ) 
 { 
 - generateQuads ( builder , child , state ) ; 
 + generateQuads ( builder , child , state , newPath ) ; 
 } 
 - if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) ) 
 + if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) & & ! state . apply ( Optional . of ( Models . getHiddenModelPart ( newPath ) ) ) . isPresent ( ) ) 
 { 
 Mesh mesh = ( Mesh ) node . getKind ( ) ; 
 Collection < Face > faces = mesh . bake ( new Function < Node < ? > , Matrix4f > ( ) 
 diff - - git a / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java b / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java 
 index 88844c6 . . 661fcc3 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java 
 + + + b / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java 
 @ @ - 32 , 16 + 32 , 15 @ @ import net . minecraft . client . resources . IResource ; 
 import net . minecraft . client . resources . IResourceManager ; 
 import net . minecraft . util . EnumFacing ; 
 import net . minecraft . util . ResourceLocation ; 
 - import net . minecraftforge . client . model . IModel ; 
 - import net . minecraftforge . client . model . IModelCustomData ; 
 - import net . minecraftforge . client . model . IPerspectiveAwareModel ; 
 - import net . minecraftforge . client . model . IRetexturableModel ; 
 - import net . minecraftforge . client . model . ModelLoader ; 
 + import net . minecraftforge . client . model . * ; 
 import net . minecraftforge . client . model . pipeline . UnpackedBakedQuad ; 
 import net . minecraftforge . common . model . IModelPart ; 
 import net . minecraftforge . common . model . IModelState ; 
 + import net . minecraftforge . common . model . Models ; 
 import net . minecraftforge . common . model . TRSRTransformation ; 
 + import net . minecraftforge . common . property . IExtendedBlockState ; 
 import net . minecraftforge . common . property . IUnlistedProperty ; 
 + import net . minecraftforge . common . property . Properties ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 
 import org . apache . commons . lang3 . tuple . Pair ; 
 @ @ - 1036 , 6 + 1035 , 7 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData 
 } 
 } 
 
 + @ Deprecated 
 public static class Group implements IModelPart 
 { 
 public static final String DEFAULT _ NAME = " OBJModel . Default . Element . Name " ; 
 @ @ - 1092 , 6 + 1092 , 7 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData 
 } 
 } 
 
 + @ Deprecated 
 public static class OBJState implements IModelState 
 { 
 protected Map < String , Boolean > visibilityMap = Maps . newHashMap ( ) ; 
 @ @ - 1230 , 6 + 1231 , 7 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData 
 } 
 } 
 
 + @ Deprecated 
 public enum OBJProperty implements IUnlistedProperty < OBJState > 
 { 
 INSTANCE ; 
 @ @ - 1262 , 7 + 1264 , 7 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData 
 private final OBJModel model ; 
 private IModelState state ; 
 private final VertexFormat format ; 
 - private Set < BakedQuad > quads ; 
 + private ImmutableList < BakedQuad > quads ; 
 private ImmutableMap < String , TextureAtlasSprite > textures ; 
 private TextureAtlasSprite sprite = ModelLoader . White . INSTANCE ; 
 
 @ @ - 1277 , 98 + 1279 , 122 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData 
 
 public void scheduleRebake ( ) 
 { 
 - this . quads = null ; 
 } 
 
 / / FIXME : merge with getQuads 
 @ Override 
 public List < BakedQuad > getQuads ( IBlockState blockState , EnumFacing side , long rand ) 
 { 
 - if ( side ! = null ) return ImmutableList . of ( ) ; 
 + if ( side ! = null ) return ImmutableList . of ( ) ; 
 if ( quads = = null ) 
 { 
 - quads = Collections . synchronizedSet ( new LinkedHashSet < BakedQuad > ( ) ) ; 
 - Set < Face > faces = Collections . synchronizedSet ( new LinkedHashSet < Face > ( ) ) ; 
 - Optional < TRSRTransformation > transform = Optional . absent ( ) ; 
 - for ( Group g : this . model . getMatLib ( ) . getGroups ( ) . values ( ) ) 
 + quads = buildQuads ( this . state ) ; 
 + } 
 + if ( blockState instanceof IExtendedBlockState ) 
 + { 
 + IExtendedBlockState exState = ( IExtendedBlockState ) blockState ; 
 + if ( exState . getUnlistedNames ( ) . contains ( Properties . AnimationProperty ) ) 
 { 
 - / / g . minUVBounds = this . model . getMatLib ( ) . minUVBounds ; 
 - / / g . maxUVBounds = this . model . getMatLib ( ) . maxUVBounds ; 
 - / / FMLLog . info ( " Group : % s u : [ % f , % f ] v : [ % f , % f ] " , g . name , g . minUVBounds [ 0 ] , g . maxUVBounds [ 0 ] , g . minUVBounds [ 1 ] , g . maxUVBounds [ 1 ] ) ; 
 
 - if ( this . state instanceof OBJState ) 
 + IModelState newState = exState . getValue ( Properties . AnimationProperty ) ; 
 + if ( newState ! = null ) 
 + { 
 + newState = new ModelStateComposition ( this . state , newState ) ; 
 + return buildQuads ( newState ) ; 
 + } 
 + } 
 + } 
 + return quads ; 
 + } 
 + 
 + private ImmutableList < BakedQuad > buildQuads ( IModelState modelState ) 
 + { 
 + List < BakedQuad > quads = Lists . newArrayList ( ) ; 
 + Collections . synchronizedSet ( new LinkedHashSet < BakedQuad > ( ) ) ; 
 + Set < Face > faces = Collections . synchronizedSet ( new LinkedHashSet < Face > ( ) ) ; 
 + Optional < TRSRTransformation > transform = Optional . absent ( ) ; 
 + for ( Group g : this . model . getMatLib ( ) . getGroups ( ) . values ( ) ) 
 + { 
 + / / g . minUVBounds = this . model . getMatLib ( ) . minUVBounds ; 
 + / / g . maxUVBounds = this . model . getMatLib ( ) . maxUVBounds ; 
 + / / FMLLog . info ( " Group : % s u : [ % f , % f ] v : [ % f , % f ] " , g . name , g . minUVBounds [ 0 ] , g . maxUVBounds [ 0 ] , g . minUVBounds [ 1 ] , g . maxUVBounds [ 1 ] ) ; 
 + 
 + if ( modelState . apply ( Optional . of ( Models . getHiddenModelPart ( ImmutableList . of ( g . getName ( ) ) ) ) ) . isPresent ( ) ) 
 + { 
 + continue ; 
 + } 
 + if ( modelState instanceof OBJState ) 
 + { 
 + OBJState state = ( OBJState ) modelState ; 
 + if ( state . parent ! = null ) 
 { 
 - OBJState state = ( OBJState ) this . state ; 
 - if ( state . parent ! = null ) 
 + transform = state . parent . apply ( Optional . < IModelPart > absent ( ) ) ; 
 + } 
 + / / TODO : can this be replaced by updateStateVisibilityMap ( OBJState ) ? 
 + if ( state . getGroupNamesFromMap ( ) . contains ( Group . ALL ) ) 
 + { 
 + state . visibilityMap . clear ( ) ; 
 + for ( String s : this . model . getMatLib ( ) . getGroups ( ) . keySet ( ) ) 
 { 
 - transform = state . parent . apply ( Optional . < IModelPart > absent ( ) ) ; 
 + state . visibilityMap . put ( s , state . operation . performOperation ( true ) ) ; 
 } 
 - / / TODO : can this be replaced by updateStateVisibilityMap ( OBJState ) ? 
 - if ( state . getGroupNamesFromMap ( ) . contains ( Group . ALL ) ) 
 + } 
 + else if ( state . getGroupNamesFromMap ( ) . contains ( Group . ALL _ EXCEPT ) ) 
 + { 
 + List < String > exceptList = state . getGroupNamesFromMap ( ) . subList ( 1 , state . getGroupNamesFromMap ( ) . size ( ) ) ; 
 + state . visibilityMap . clear ( ) ; 
 + for ( String s : this . model . getMatLib ( ) . getGroups ( ) . keySet ( ) ) 
 { 
 - state . visibilityMap . clear ( ) ; 
 - for ( String s : this . model . getMatLib ( ) . getGroups ( ) . keySet ( ) ) 
 + if ( ! exceptList . contains ( s ) ) 
 { 
 state . visibilityMap . put ( s , state . operation . performOperation ( true ) ) ; 
 } 
 } 
 - else if ( state . getGroupNamesFromMap ( ) . contains ( Group . ALL _ EXCEPT ) ) 
 - { 
 - List < String > exceptList = state . getGroupNamesFromMap ( ) . subList ( 1 , state . getGroupNamesFromMap ( ) . size ( ) ) ; 
 - state . visibilityMap . clear ( ) ; 
 - for ( String s : this . model . getMatLib ( ) . getGroups ( ) . keySet ( ) ) 
 - { 
 - if ( ! exceptList . contains ( s ) ) 
 - { 
 - state . visibilityMap . put ( s , state . operation . performOperation ( true ) ) ; 
 - } 
 - } 
 - } 
 - else 
 - { 
 - for ( String s : state . visibilityMap . keySet ( ) ) 
 - { 
 - state . visibilityMap . put ( s , state . operation . performOperation ( state . visibilityMap . get ( s ) ) ) ; 
 - } 
 - } 
 - if ( state . getGroupsWithVisibility ( true ) . contains ( g . getName ( ) ) ) 
 + } 
 + else 
 + { 
 + for ( String s : state . visibilityMap . keySet ( ) ) 
 { 
 - faces . addAll ( g . applyTransform ( transform ) ) ; 
 + state . visibilityMap . put ( s , state . operation . performOperation ( state . visibilityMap . get ( s ) ) ) ; 
 } 
 } 
 - else 
 + if ( state . getGroupsWithVisibility ( true ) . contains ( g . getName ( ) ) ) 
 { 
 - transform = state . apply ( Optional . < IModelPart > absent ( ) ) ; 
 faces . addAll ( g . applyTransform ( transform ) ) ; 
 } 
 } 
 - for ( Face f : faces ) 
 + else 
 { 
 - if ( this . model . getMatLib ( ) . materials . get ( f . getMaterialName ( ) ) . isWhite ( ) ) 
 - { 
 - for ( Vertex v : f . getVertices ( ) ) 
 - { / / update material in each vertex 
 - if ( ! v . getMaterial ( ) . equals ( this . model . getMatLib ( ) . getMaterial ( v . getMaterial ( ) . getName ( ) ) ) ) 
 - { 
 - v . setMaterial ( this . model . getMatLib ( ) . getMaterial ( v . getMaterial ( ) . getName ( ) ) ) ; 
 - } 
 + transform = modelState . apply ( Optional . < IModelPart > absent ( ) ) ; 
 + faces . addAll ( g . applyTransform ( transform ) ) ; 
 + } 
 + } 
 + for ( Face f : faces ) 
 + { 
 + if ( this . model . getMatLib ( ) . materials . get ( f . getMaterialName ( ) ) . isWhite ( ) ) 
 + { 
 + for ( Vertex v : f . getVertices ( ) ) 
 + { / / update material in each vertex 
 + if ( ! v . getMaterial ( ) . equals ( this . model . getMatLib ( ) . getMaterial ( v . getMaterial ( ) . getName ( ) ) ) ) 
 + { 
 + v . setMaterial ( this . model . getMatLib ( ) . getMaterial ( v . getMaterial ( ) . getName ( ) ) ) ; 
 } 
 - sprite = ModelLoader . White . INSTANCE ; 
 - } else sprite = this . textures . get ( f . getMaterialName ( ) ) ; 
 - UnpackedBakedQuad . Builder builder = new UnpackedBakedQuad . Builder ( format ) ; 
 - builder . setContractUVs ( true ) ; 
 - builder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; 
 - builder . setTexture ( sprite ) ; 
 - Normal faceNormal = f . getNormal ( ) ; 
 - putVertexData ( builder , f . verts [ 0 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 0 ] , sprite ) ; 
 - putVertexData ( builder , f . verts [ 1 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 1 ] , sprite ) ; 
 - putVertexData ( builder , f . verts [ 2 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 2 ] , sprite ) ; 
 - putVertexData ( builder , f . verts [ 3 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 3 ] , sprite ) ; 
 - quads . add ( builder . build ( ) ) ; 
 + } 
 + sprite = ModelLoader . White . INSTANCE ; 
 } 
 + else sprite = this . textures . get ( f . getMaterialName ( ) ) ; 
 + UnpackedBakedQuad . Builder builder = new UnpackedBakedQuad . Builder ( format ) ; 
 + builder . setContractUVs ( true ) ; 
 + builder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; 
 + builder . setTexture ( sprite ) ; 
 + Normal faceNormal = f . getNormal ( ) ; 
 + putVertexData ( builder , f . verts [ 0 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 0 ] , sprite ) ; 
 + putVertexData ( builder , f . verts [ 1 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 1 ] , sprite ) ; 
 + putVertexData ( builder , f . verts [ 2 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 2 ] , sprite ) ; 
 + putVertexData ( builder , f . verts [ 3 ] , faceNormal , TextureCoordinate . getDefaultUVs ( ) [ 3 ] , sprite ) ; 
 + quads . add ( builder . build ( ) ) ; 
 } 
 - List < BakedQuad > quadList = Collections . synchronizedList ( Lists . newArrayList ( quads ) ) ; 
 - return quadList ; 
 + return ImmutableList . copyOf ( quads ) ; 
 } 
 
 private final void putVertexData ( UnpackedBakedQuad . Builder builder , Vertex v , Normal faceNormal , TextureCoordinate defUV , TextureAtlasSprite sprite ) 
 diff - - git a / src / main / java / net / minecraftforge / common / model / HiddenModelPart . java b / src / main / java / net / minecraftforge / common / model / HiddenModelPart . java 
 new file mode 100644 
 index 0000000 . . b51d552 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / common / model / HiddenModelPart . java 
 @ @ - 0 , 0 + 1 , 18 @ @ 
 + package net . minecraftforge . common . model ; 
 + 
 + import com . google . common . collect . ImmutableList ; 
 + 
 + final class HiddenModelPart implements IModelPart 
 + { 
 + private final ImmutableList < String > path ; 
 + 
 + HiddenModelPart ( ImmutableList < String > path ) 
 + { 
 + this . path = path ; 
 + } 
 + 
 + ImmutableList < String > getPath ( ) 
 + { 
 + return path ; 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / common / model / Models . java b / src / main / java / net / minecraftforge / common / model / Models . java 
 new file mode 100644 
 index 0000000 . . 9e5daa2 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / common / model / Models . java 
 @ @ - 0 , 0 + 1 , 24 @ @ 
 + package net . minecraftforge . common . model ; 
 + 
 + import com . google . common . collect . ImmutableList ; 
 + import com . google . common . collect . Iterators ; 
 + import com . google . common . collect . UnmodifiableIterator ; 
 + 
 + public enum Models 
 + { 
 + ; 
 + 
 + public static IModelPart getHiddenModelPart ( ImmutableList < String > path ) 
 + { 
 + return new HiddenModelPart ( path ) ; 
 + } 
 + 
 + public static UnmodifiableIterator < String > getParts ( IModelPart part ) 
 + { 
 + if ( part instanceof HiddenModelPart ) 
 + { 
 + return ( ( HiddenModelPart ) part ) . getPath ( ) . iterator ( ) ; 
 + } 
 + return Iterators . emptyIterator ( ) ; 
 + } 
 + } 
 diff - - git a / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java b / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java 
 index bf25428 . . 78c6533 100644 
 - - - a / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java 
 + + + b / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java 
 @ @ - 1 , 7 + 1 , 6 @ @ 
 package net . minecraftforge . debug ; 
 
 import java . util . ArrayList ; 
 - import java . util . Arrays ; 
 import java . util . List ; 
 
 import javax . vecmath . AxisAngle4d ; 
 @ @ - 10 , 6 + 9 , 8 @ @ import javax . vecmath . Quat4f ; 
 import javax . vecmath . Vector3d ; 
 import javax . vecmath . Vector4f ; 
 
 + import com . google . common . base . Optional ; 
 + import com . google . common . collect . UnmodifiableIterator ; 
 import net . minecraft . block . Block ; 
 import net . minecraft . block . ITileEntityProvider ; 
 import net . minecraft . block . material . Material ; 
 @ @ - 36 , 16 + 37 , 17 @ @ import net . minecraft . util . math . MathHelper ; 
 import net . minecraft . util . text . TextComponentString ; 
 import net . minecraft . world . IBlockAccess ; 
 import net . minecraft . world . World ; 
 - import net . minecraftforge . client . model . IModel ; 
 import net . minecraftforge . client . model . ModelLoader ; 
 - import net . minecraftforge . client . model . ModelLoaderRegistry ; 
 import net . minecraftforge . client . model . b3d . B3DLoader ; 
 import net . minecraftforge . client . model . obj . OBJLoader ; 
 - import net . minecraftforge . client . model . obj . OBJModel ; 
 + import net . minecraftforge . common . model . IModelPart ; 
 + import net . minecraftforge . common . model . IModelState ; 
 + import net . minecraftforge . common . model . Models ; 
 import net . minecraftforge . common . model . TRSRTransformation ; 
 import net . minecraftforge . common . property . ExtendedBlockState ; 
 import net . minecraftforge . common . property . IExtendedBlockState ; 
 import net . minecraftforge . common . property . IUnlistedProperty ; 
 + import net . minecraftforge . common . property . Properties ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 import net . minecraftforge . fml . common . Mod ; 
 import net . minecraftforge . fml . common . Mod . EventHandler ; 
 @ @ - 120 , 7 + 122 , 6 @ @ public class ModelLoaderRegistryDebug 
 public static final CustomModelBlock instance = new CustomModelBlock ( ) ; 
 public static final String name = " CustomModelBlock " ; 
 private int counter = 1 ; 
 - public ExtendedBlockState state = new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { B3DLoader . B3DFrameProperty . INSTANCE } ) ; 
 
 private CustomModelBlock ( ) 
 { 
 @ @ - 163 , 7 + 164 , 7 @ @ public class ModelLoaderRegistryDebug 
 { 
 / / Only return an IExtendedBlockState from this method and createState ( ) , otherwise block placement might break ! 
 B3DLoader . B3DState newState = new B3DLoader . B3DState ( null , counter ) ; 
 - return ( ( IExtendedBlockState ) state ) . withProperty ( B3DLoader . B3DFrameProperty . INSTANCE , newState ) ; 
 + return ( ( IExtendedBlockState ) state ) . withProperty ( Properties . AnimationProperty , newState ) ; 
 } 
 
 @ Override 
 @ @ - 183 , 7 + 184 , 7 @ @ public class ModelLoaderRegistryDebug 
 @ Override 
 public BlockStateContainer createBlockState ( ) 
 { 
 - return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { B3DLoader . B3DFrameProperty . INSTANCE } ) ; 
 + return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { Properties . AnimationProperty } ) ; 
 } 
 
 public static EnumFacing getFacingFromEntity ( World worldIn , BlockPos clickedBlock , EntityLivingBase entityIn ) 
 @ @ - 221 , 7 + 222 , 6 @ @ public class ModelLoaderRegistryDebug 
 { 
 public static final OBJTesseractBlock instance = new OBJTesseractBlock ( ) ; 
 public static final String name = " OBJTesseractBlock " ; 
 - private ExtendedBlockState state = new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; 
 
 private OBJTesseractBlock ( ) 
 { 
 @ @ - 247 , 19 + 247 , 10 @ @ public class ModelLoaderRegistryDebug 
 public boolean isVisuallyOpaque ( ) { return false ; } 
 
 @ Override 
 - public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) 
 - { 
 - OBJTesseractTileEntity tileEntity = ( OBJTesseractTileEntity ) world . getTileEntity ( pos ) ; 
 - OBJModel . OBJState retState = new OBJModel . OBJState ( tileEntity = = null ? Lists . newArrayList ( OBJModel . Group . ALL ) : tileEntity . visible , true ) ; 
 - return ( ( IExtendedBlockState ) this . state . getBaseState ( ) ) . withProperty ( OBJModel . OBJProperty . INSTANCE , retState ) ; 
 - } 
 - 
 - @ Override 
 public boolean onBlockActivated ( World world , BlockPos pos , IBlockState state , EntityPlayer player , EnumHand hand , ItemStack heldItem , EnumFacing side , float hitX , float hitY , float hitZ ) 
 { 
 if ( world . getTileEntity ( pos ) = = null ) world . setTileEntity ( pos , new OBJTesseractTileEntity ( ) ) ; 
 OBJTesseractTileEntity tileEntity = ( OBJTesseractTileEntity ) world . getTileEntity ( pos ) ; 
 - IModel model = ModelLoaderRegistry . getModelOrMissing ( new ResourceLocation ( MODID . toLowerCase ( ) + " : " + " block / tesseract . obj " ) ) ; 
 
 if ( player . isSneaking ( ) ) 
 { 
 @ @ - 267 , 19 + 258 , 9 @ @ public class ModelLoaderRegistryDebug 
 } 
 else 
 { 
 - if ( model ! = ModelLoaderRegistry . getMissingModel ( ) ) 
 - { 
 - tileEntity . setMax ( ( ( OBJModel ) model ) . getMatLib ( ) . getGroups ( ) . keySet ( ) . size ( ) - 1 ) ; 
 - tileEntity . increment ( ) ; 
 - } 
 + tileEntity . increment ( ) ; 
 } 
 
 - if ( world . isRemote ) 
 - { 
 - / / wtf 
 - / / OBJBakedModel objBaked = ( OBJBakedModel ) Minecraft . getMinecraft ( ) . getBlockRendererDispatcher ( ) . getModelFromBlockState ( state , world , pos ) ; 
 - / / objBaked . scheduleRebake ( ) ; / / not necessarily needed for this specific case , but is available 
 - } 
 world . markBlockRangeForRenderUpdate ( pos , pos ) ; 
 return false ; 
 } 
 @ @ - 289 , 69 + 270 , 85 @ @ public class ModelLoaderRegistryDebug 
 { 
 return true ; 
 } 
 + 
 + @ Override 
 + public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) 
 + { 
 + if ( world . getTileEntity ( pos ) ! = null & & world . getTileEntity ( pos ) instanceof OBJTesseractTileEntity ) 
 + { 
 + OBJTesseractTileEntity te = ( OBJTesseractTileEntity ) world . getTileEntity ( pos ) ; 
 + return ( ( IExtendedBlockState ) state ) . withProperty ( Properties . AnimationProperty , te . state ) ; 
 + } 
 + return state ; 
 + } 
 + 
 + @ Override 
 + public BlockStateContainer createBlockState ( ) 
 + { 
 + return new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { Properties . AnimationProperty } ) ; 
 + } 
 } 
 
 public static class OBJTesseractTileEntity extends TileEntity 
 { 
 private int counter = 1 ; 
 - private int max = 2 ; 
 - public List < String > visible = new ArrayList < String > ( ) ; 
 - 
 - public OBJTesseractTileEntity ( ) 
 + private int max = 32 ; 
 + private final List < String > hidden = new ArrayList < String > ( ) ; 
 + private final IModelState state = new IModelState ( ) 
 { 
 - this . visible . add ( OBJModel . Group . ALL ) ; 
 - } 
 + private final Optional < TRSRTransformation > value = Optional . of ( TRSRTransformation . identity ( ) ) ; 
 + 
 + @ Override 
 + public Optional < TRSRTransformation > apply ( Optional < ? extends IModelPart > part ) 
 + { 
 + if ( part . isPresent ( ) ) 
 + { 
 + / / This whole thing is subject to change , but should do for now . 
 + UnmodifiableIterator < String > parts = Models . getParts ( part . get ( ) ) ; 
 + if ( parts . hasNext ( ) ) 
 + { 
 + String name = parts . next ( ) ; 
 + / / only interested in the root level 
 + if ( ! parts . hasNext ( ) & & hidden . contains ( name ) ) 
 + { 
 + return value ; 
 + } 
 + } 
 + } 
 + return Optional . absent ( ) ; 
 + } 
 + } ; 
 
 public void increment ( ) 
 { 
 - if ( this . visible . contains ( OBJModel . Group . ALL ) ) this . visible . remove ( OBJModel . Group . ALL ) ; 
 if ( this . counter = = max ) 
 { 
 this . counter = 0 ; 
 - this . visible . clear ( ) ; 
 + this . hidden . clear ( ) ; 
 } 
 this . counter + + ; 
 - this . visible . add ( Integer . toString ( this . counter ) ) ; 
 + this . hidden . add ( Integer . toString ( this . counter ) ) ; 
 TextComponentString text = new TextComponentString ( " " + this . counter ) ; 
 if ( this . worldObj . isRemote ) Minecraft . getMinecraft ( ) . ingameGUI . getChatGUI ( ) . printChatMessage ( text ) ; 
 } 
 
 public void decrement ( ) 
 { 
 - if ( this . visible . contains ( OBJModel . Group . ALL ) ) this . visible . remove ( OBJModel . Group . ALL ) ; 
 if ( this . counter = = 1 ) 
 { 
 this . counter = max + 1 ; 
 - for ( int i = 1 ; i < max ; i + + ) this . visible . add ( Integer . toString ( i ) ) ; 
 + for ( int i = 1 ; i < max ; i + + ) this . hidden . add ( Integer . toString ( i ) ) ; 
 } 
 - this . visible . remove ( Integer . toString ( this . counter ) ) ; 
 + this . hidden . remove ( Integer . toString ( this . counter ) ) ; 
 this . counter - - ; 
 TextComponentString text = new TextComponentString ( " " + this . counter ) ; 
 if ( this . worldObj . isRemote ) Minecraft . getMinecraft ( ) . ingameGUI . getChatGUI ( ) . printChatMessage ( text ) ; 
 } 
 
 - public void reset ( ) 
 - { 
 - this . counter = 1 ; 
 - this . max = 2 ; 
 - this . visible . clear ( ) ; 
 - this . visible . add ( Integer . toString ( this . counter ) ) ; 
 - } 
 - 
 - public int getMax ( ) 
 - { 
 - return this . max ; 
 - } 
 - 
 public void setMax ( int max ) 
 { 
 this . max = max ; 
 } 
 - 
 - public void setToMax ( ) 
 - { 
 - this . counter = this . max ; 
 - } 
 } 
 
 / * * 
 @ @ - 431 , 7 + 428 , 7 @ @ public class ModelLoaderRegistryDebug 
 @ Override 
 public BlockStateContainer createBlockState ( ) 
 { 
 - return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; 
 + return new BlockStateContainer ( this , FACING ) ; 
 } 
 
 @ Override 
 @ @ - 443 , 15 + 440 , 6 @ @ public class ModelLoaderRegistryDebug 
 @ Override 
 public boolean isVisuallyOpaque ( ) { return false ; } 
 
 - @ Override 
 - public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) 
 - { 
 - EnumFacing facing = ( EnumFacing ) state . getValue ( FACING ) ; 
 - TRSRTransformation transform = new TRSRTransformation ( facing ) ; 
 - OBJModel . OBJState retState = new OBJModel . OBJState ( Arrays . asList ( new String [ ] { OBJModel . Group . ALL } ) , true , transform ) ; 
 - return ( ( IExtendedBlockState ) state ) . withProperty ( OBJModel . OBJProperty . INSTANCE , retState ) ; 
 - } 
 - 
 public static EnumFacing getFacingFromEntity ( World worldIn , BlockPos clickedBlock , EntityLivingBase entityIn ) 
 { 
 if ( MathHelper . abs ( ( float ) entityIn . posX - ( float ) clickedBlock . getX ( ) ) < 2 . 0F & & MathHelper . abs ( ( float ) entityIn . posZ - ( float ) clickedBlock . getZ ( ) ) < 2 . 0F ) 
 @ @ - 586 , 7 + 574 , 6 @ @ public class ModelLoaderRegistryDebug 
 public static final PropertyDirection FACING = PropertyDirection . create ( " facing " ) ; 
 public static final OBJDirectionBlock instance = new OBJDirectionBlock ( ) ; 
 public static final String name = " OBJDirectionBlock " ; 
 - public ExtendedBlockState state = new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; 
 
 private OBJDirectionBlock ( ) 
 { 
 @ @ - 625 , 19 + 612 , 9 @ @ public class ModelLoaderRegistryDebug 
 } 
 
 @ Override 
 - public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) 
 - { 
 - / / Only return an IExtendedBlockState from this method and createState ( ) , otherwise block placement will break ! 
 - EnumFacing facing = ( EnumFacing ) state . getValue ( FACING ) ; 
 - TRSRTransformation transform = new TRSRTransformation ( facing ) ; 
 - OBJModel . OBJState newState = new OBJModel . OBJState ( Lists . newArrayList ( OBJModel . Group . ALL ) , true , transform ) ; 
 - return ( ( IExtendedBlockState ) state ) . withProperty ( OBJModel . OBJProperty . INSTANCE , newState ) ; 
 - } 
 - 
 - @ Override 
 public BlockStateContainer createBlockState ( ) 
 { 
 - return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; 
 + return new BlockStateContainer ( this , FACING ) ; 
 } 
 
 public static EnumFacing getFacingFromEntity ( World worldIn , BlockPos clickedBlock , EntityLivingBase entityIn ) 
 @ @ - 732 , 7 + 709 , 6 @ @ public class ModelLoaderRegistryDebug 
 { 
 public static final OBJDynamicEye instance = new OBJDynamicEye ( ) ; 
 public static final String name = " OBJDynamicEye " ; 
 - public ExtendedBlockState state = new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; 
 private OBJDynamicEye ( ) 
 { 
 super ( Material . IRON ) ; 
 @ @ - 771 , 9 + 747 , 9 @ @ public class ModelLoaderRegistryDebug 
 if ( world . getTileEntity ( pos ) ! = null & & world . getTileEntity ( pos ) instanceof OBJDynamicEyeTileEntity ) 
 { 
 OBJDynamicEyeTileEntity te = ( OBJDynamicEyeTileEntity ) world . getTileEntity ( pos ) ; 
 - if ( te . state ! = null ) 
 + if ( te . transform ! = TRSRTransformation . identity ( ) ) 
 { 
 - return ( ( IExtendedBlockState ) this . state . getBaseState ( ) ) . withProperty ( OBJModel . OBJProperty . INSTANCE , te . state ) ; 
 + return ( ( IExtendedBlockState ) state ) . withProperty ( Properties . AnimationProperty , te . transform ) ; 
 } 
 } 
 return state ; 
 @ @ - 782 , 18 + 758 , 13 @ @ public class ModelLoaderRegistryDebug 
 @ Override 
 public BlockStateContainer createBlockState ( ) 
 { 
 - return new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { OBJModel . OBJProperty . INSTANCE } ) ; 
 + return new ExtendedBlockState ( this , new IProperty [ 0 ] , new IUnlistedProperty [ ] { Properties . AnimationProperty } ) ; 
 } 
 } 
 
 public static class OBJDynamicEyeTileEntity extends TileEntity implements ITickable 
 { 
 - public OBJModel . OBJState state ; 
 - 
 - public OBJDynamicEyeTileEntity ( ) 
 - { 
 - this . state = new OBJModel . OBJState ( Lists . newArrayList ( OBJModel . Group . ALL ) , true ) ; 
 - } 
 + private TRSRTransformation transform = TRSRTransformation . identity ( ) ; 
 
 @ Override 
 public void update ( ) 
 @ @ - 821 , 9 + 792 , 7 @ @ public class ModelLoaderRegistryDebug 
 Matrix4f matrix = new Matrix4f ( ) ; 
 matrix . setIdentity ( ) ; 
 matrix . setRotation ( rot ) ; 
 - TRSRTransformation transform = new TRSRTransformation ( matrix ) ; 
 - transform = TRSRTransformation . blockCenterToCorner ( transform ) ; 
 - this . state = new OBJModel . OBJState ( Lists . newArrayList ( OBJModel . Group . ALL ) , true , transform ) ; 
 + transform = TRSRTransformation . blockCenterToCorner ( new TRSRTransformation ( matrix ) ) ; 
 this . worldObj . markBlockRangeForRenderUpdate ( this . pos , this . pos ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 index 2b327cc . . eb77317 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 @ @ - 32 , 8 + 32 , 8 @ @ import net . minecraft . client . renderer . block . model . ItemModelGenerator ; 
 import net . minecraft . client . renderer . block . model . ModelBlock ; 
 import net . minecraft . client . renderer . block . model . ModelBlockDefinition ; 
 import net . minecraft . client . renderer . block . model . ModelBlockDefinition . MissingVariantException ; 
 - import net . minecraft . client . renderer . block . model . ModelBlockDefinition . Variant ; 
 - import net . minecraft . client . renderer . block . model . ModelBlockDefinition . Variants ; 
 + import net . minecraft . client . renderer . block . model . Variant ; 
 + import net . minecraft . client . renderer . block . model . VariantList ; 
 import net . minecraft . client . renderer . block . statemap . IStateMapper ; 
 import net . minecraft . client . renderer . texture . IIconCreator ; 
 import net . minecraft . client . renderer . texture . TextureAtlasSprite ; 
 @ @ - 53 , 7 + 53 , 7 @ @ import net . minecraft . item . Item ; 
 import net . minecraft . item . ItemStack ; 
 import net . minecraft . launchwrapper . Launch ; 
 import net . minecraft . util . EnumFacing ; 
 - import net . minecraft . util . IRegistry ; 
 + import net . minecraft . util . registry . IRegistry ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . client . model . animation . Animation ; 
 import net . minecraftforge . client . model . animation . IAnimatedModel ; 
 @ @ - 78 , 7 + 78 , 6 @ @ import com . google . common . base . Function ; 
 import com . google . common . base . Optional ; 
 import com . google . common . base . Throwables ; 
 
 - @ SuppressWarnings ( " ALL " ) 
 public class ModelLoader extends ModelBakery 
 { 
 private final Map < ModelResourceLocation , IModel > stateModels = Maps . newHashMap ( ) ; 
 @ @ - 132 , 7 + 131 , 7 @ @ public class ModelLoader extends ModelBakery 
 } 
 } 
 } ) ; 
 - IFlexibleBakedModel missingBaked = missingModel . bake ( missingModel . getDefaultState ( ) , DefaultVertexFormats . ITEM , DefaultTextureGetter . instance ) ; 
 + IBakedModel missingBaked = missingModel . bake ( missingModel . getDefaultState ( ) , DefaultVertexFormats . ITEM , DefaultTextureGetter . instance ) ; 
 for ( Entry < ModelResourceLocation , IModel > e : stateModels . entrySet ( ) ) 
 { 
 if ( e . getValue ( ) = = getMissingModel ( ) ) 
 @ @ - 172 , 7 + 171 , 7 @ @ public class ModelLoader extends ModelBakery 
 @ Override 
 protected void registerVariant ( ModelBlockDefinition definition , ModelResourceLocation location ) 
 { 
 - Variants variants = null ; 
 + VariantList variants = null ; 
 try 
 { 
 variants = definition . getVariants ( location . getVariant ( ) ) ; 
 @ @ - 480 , 7 + 479 , 7 @ @ public class ModelLoader extends ModelBakery 
 { 
 builder . add ( loc ) ; 
 } 
 - / / mojang hardcode 
 + / * / / mojang hardcode 
 if ( model . getRootModel ( ) = = MODEL _ COMPASS & & ! loc . equals ( TextureMap . LOCATION _ MISSING _ TEXTURE ) ) 
 { 
 TextureAtlasSprite . setLocationNameCompass ( loc . toString ( ) ) ; 
 @ @ - 488 , 7 + 487 , 7 @ @ public class ModelLoader extends ModelBakery 
 else if ( model . getRootModel ( ) = = MODEL _ CLOCK & & ! loc . equals ( TextureMap . LOCATION _ MISSING _ TEXTURE ) ) 
 { 
 TextureAtlasSprite . setLocationNameClock ( loc . toString ( ) ) ; 
 - } 
 + } * / 
 } 
 } 
 for ( String s : model . textures . values ( ) ) 
 @ @ - 501 , 7 + 500 , 7 @ @ public class ModelLoader extends ModelBakery 
 return builder . build ( ) ; 
 } 
 
 - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 + public IBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 { 
 if ( ! Attributes . moreSpecific ( format , Attributes . DEFAULT _ BAKED _ FORMAT ) ) 
 { 
 @ @ - 533 , 11 + 532 , 11 @ @ public class ModelLoader extends ModelBakery 
 { 
 return new ItemLayerModel ( model ) . bake ( perState , format , bakedTextureGetter ) ; 
 } 
 - if ( isCustomRenderer ( model ) ) return new IFlexibleBakedModel . Wrapper ( new BuiltInModel ( transforms ) , format ) ; 
 + if ( isCustomRenderer ( model ) ) return new BuiltInModel ( transforms ) ; 
 return bakeNormal ( model , perState , state . apply ( Optional . < IModelPart > absent ( ) ) . or ( TRSRTransformation . identity ( ) ) , newTransforms , format , bakedTextureGetter , uvlock ) ; 
 } 
 
 - private IFlexibleBakedModel bakeNormal ( ModelBlock model , IModelState perState , final TRSRTransformation modelState , List < TRSRTransformation > newTransforms , VertexFormat format , final Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter , boolean uvLocked ) 
 + private IBakedModel bakeNormal ( ModelBlock model , IModelState perState , final TRSRTransformation modelState , List < TRSRTransformation > newTransforms , VertexFormat format , final Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter , boolean uvLocked ) 
 { 
 TextureAtlasSprite particle = bakedTextureGetter . apply ( new ResourceLocation ( model . resolveTextureName ( " particle " ) ) ) ; 
 SimpleBakedModel . Builder builder = ( new SimpleBakedModel . Builder ( model ) ) . setTexture ( particle ) ; 
 @ @ - 567 , 7 + 566 , 8 @ @ public class ModelLoader extends ModelBakery 
 } 
 } 
 
 - return new ISmartBlockModel . PerspectiveWrapper ( new IPerspectiveAwareModel . MapWrapper ( new IFlexibleBakedModel . Wrapper ( builder . makeBakedModel ( ) , format ) , perState ) ) 
 + / / FIXME 
 + return new ISmartBlockModel . PerspectiveWrapper ( new IPerspectiveAwareModel . MapWrapper ( builder . makeBakedModel ( ) , perState ) ) 
 { 
 public IBakedModel handleBlockState ( IBlockState state ) 
 { 
 @ @ - 576 , 7 + 576 , 7 @ @ public class ModelLoader extends ModelBakery 
 } ; 
 } 
 
 - private IBakedModel handleBlockState ( IFlexibleBakedModel model , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter , TRSRTransformation modelState , IBlockState state ) 
 + private IBakedModel handleBlockState ( IBakedModel model , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter , TRSRTransformation modelState , IBlockState state ) 
 { 
 if ( state instanceof IExtendedBlockState ) 
 { 
 @ @ - 594 , 7 + 594 , 7 @ @ public class ModelLoader extends ModelBakery 
 } 
 
 @ Override 
 - public IModel retexture ( ImmutableMap < String , String > textures ) 
 + public VanillaModelWrapper retexture ( ImmutableMap < String , String > textures ) 
 { 
 if ( textures . isEmpty ( ) ) 
 return this ; 
 @ @ - 724 , 11 + 724 , 11 @ @ public class ModelLoader extends ModelBakery 
 private final List < IModel > models = new ArrayList < IModel > ( ) ; 
 private final IModelState defaultState ; 
 
 - public WeightedRandomModel ( ModelResourceLocation parent , Variants variants ) 
 + public WeightedRandomModel ( ModelResourceLocation parent , VariantList variants ) 
 { 
 - this . variants = variants . getVariants ( ) ; 
 + this . variants = variants . func _ 188114 _ a ( ) ; 
 ImmutableList . Builder < Pair < IModel , IModelState > > builder = ImmutableList . builder ( ) ; 
 - for ( Variant v : variants . getVariants ( ) ) 
 + for ( Variant v : this . variants ) 
 { 
 ResourceLocation loc = v . getModelLocation ( ) ; 
 locations . add ( loc ) ; 
 @ @ - 793 , 7 + 793 , 7 @ @ public class ModelLoader extends ModelBakery 
 return state ; 
 } 
 
 - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 + public IBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 { 
 if ( ! Attributes . moreSpecific ( format , Attributes . DEFAULT _ BAKED _ FORMAT ) ) 
 { 
 @ @ - 812 , 7 + 812 , 7 @ @ public class ModelLoader extends ModelBakery 
 Variant v = variants . get ( i ) ; 
 builder . add ( model . bake ( addUV ( v . isUvLocked ( ) , MultiModelState . getPartState ( state , model , i ) ) , format , bakedTextureGetter ) , variants . get ( i ) . getWeight ( ) ) ; 
 } 
 - return new FlexibleWeightedBakedModel ( builder . build ( ) , Attributes . DEFAULT _ BAKED _ FORMAT ) ; 
 + return builder . build ( ) ; 
 } 
 
 public IModelState getDefaultState ( ) 
 @ @ - 821 , 22 + 821 , 6 @ @ public class ModelLoader extends ModelBakery 
 } 
 } 
 
 - private static class FlexibleWeightedBakedModel extends WeightedBakedModel implements IFlexibleBakedModel 
 - { 
 - private final VertexFormat format ; 
 - 
 - public FlexibleWeightedBakedModel ( WeightedBakedModel parent , VertexFormat format ) 
 - { 
 - super ( parent . models ) ; 
 - this . format = format ; 
 - } 
 - 
 - public VertexFormat getFormat ( ) 
 - { 
 - return format ; 
 - } 
 - } 
 - 
 public IModel getMissingModel ( ) 
 { 
 if ( missingModel = = null ) 
 diff - - git a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 index eb60e17 . . 271ee94 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 @ @ - 19 , 11 + 19 , 11 @ @ import net . minecraft . client . renderer . block . model . BakedQuad ; 
 import net . minecraft . client . renderer . block . model . IBakedModel ; 
 import net . minecraft . client . renderer . block . model . ItemCameraTransforms ; 
 import net . minecraft . client . renderer . block . model . ItemCameraTransforms . TransformType ; 
 + import net . minecraft . client . renderer . block . model . ItemOverrideList ; 
 import net . minecraft . client . renderer . texture . TextureAtlasSprite ; 
 import net . minecraft . client . renderer . vertex . VertexFormat ; 
 import net . minecraft . client . resources . IResource ; 
 import net . minecraft . client . resources . IResourceManager ; 
 - import net . minecraft . item . ItemStack ; 
 import net . minecraft . util . EnumFacing ; 
 import net . minecraft . util . math . MathHelper ; 
 import net . minecraft . util . ResourceLocation ; 
 @ @ - 68 , 7 + 68 , 6 @ @ import com . google . gson . JsonParser ; 
 * To enable for your mod call instance . addDomain ( modid ) . 
 * If you need more control over accepted resources - extend the class , and register a new instance with ModelLoaderRegistry . 
 * / 
 - @ SuppressWarnings ( " deprecation " ) 
 public class B3DLoader implements ICustomModelLoader 
 { 
 public static final B3DLoader instance = new B3DLoader ( ) ; 
 @ @ - 487 , 7 + 486 , 7 @ @ public class B3DLoader implements ICustomModelLoader 
 } 
 
 @ Override 
 - public IModel retexture ( ImmutableMap < String , String > textures ) 
 + public ModelWrapper retexture ( ImmutableMap < String , String > textures ) 
 { 
 ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; 
 for ( Map . Entry < String , ResourceLocation > e : this . textures . entrySet ( ) ) 
 @ @ - 509 , 7 + 508 , 7 @ @ public class B3DLoader implements ICustomModelLoader 
 } 
 
 @ Override 
 - public IModel process ( ImmutableMap < String , String > data ) 
 + public ModelWrapper process ( ImmutableMap < String , String > data ) 
 { 
 if ( data . containsKey ( " mesh " ) ) 
 { 
 @ @ - 601 , 7 + 600 , 7 @ @ public class B3DLoader implements ICustomModelLoader 
 private final VertexFormat format ; 
 private final ImmutableSet < String > meshes ; 
 private final ImmutableMap < String , TextureAtlasSprite > textures ; 
 - private final LoadingCache < Integer , BakedWrapper > cache ; 
 + private final LoadingCache < Integer , B3DState > cache ; 
 
 private ImmutableList < BakedQuad > quads ; 
 
 @ @ - 610 , 9 + 609 , 9 @ @ public class B3DLoader implements ICustomModelLoader 
 this ( node , state , smooth , gui3d , format , meshes , textures , CacheBuilder . newBuilder ( ) 
 . maximumSize ( 128 ) 
 . expireAfterAccess ( 2 , TimeUnit . MINUTES ) 
 - . < Integer , BakedWrapper > build ( new CacheLoader < Integer , BakedWrapper > ( ) 
 + . < Integer , B3DState > build ( new CacheLoader < Integer , B3DState > ( ) 
 { 
 - public BakedWrapper load ( Integer frame ) throws Exception 
 + public B3DState load ( Integer frame ) throws Exception 
 { 
 IModelState parent = state ; 
 Animation newAnimation = node . getAnimation ( ) ; 
 @ @ - 621 , 12 + 620 , 12 @ @ public class B3DLoader implements ICustomModelLoader 
 B3DState ps = ( B3DState ) parent ; 
 parent = ps . getParent ( ) ; 
 } 
 - return new BakedWrapper ( node , new B3DState ( newAnimation , frame , frame , 0 , parent ) , smooth , gui3d , format , meshes , textures ) ; 
 + return new B3DState ( newAnimation , frame , frame , 0 , parent ) ; 
 } 
 } ) ) ; 
 } 
 
 - public BakedWrapper ( Node < ? > node , IModelState state , boolean smooth , boolean gui3d , VertexFormat format , ImmutableSet < String > meshes , ImmutableMap < String , TextureAtlasSprite > textures , LoadingCache < Integer , BakedWrapper > cache ) 
 + public BakedWrapper ( Node < ? > node , IModelState state , boolean smooth , boolean gui3d , VertexFormat format , ImmutableSet < String > meshes , ImmutableMap < String , TextureAtlasSprite > textures , LoadingCache < Integer , B3DState > cache ) 
 { 
 this . node = node ; 
 this . state = state ; 
 @ @ - 638 , 61 + 637 , 113 @ @ public class B3DLoader implements ICustomModelLoader 
 this . cache = cache ; 
 } 
 
 - / / FIXME merge with handleBlockState 
 @ Override 
 - public List < BakedQuad > getGeneralQuads ( ) 
 + public List < BakedQuad > func _ 188616 _ a ( IBlockState state , EnumFacing side , long rand ) 
 { 
 - if ( quads = = null ) 
 + if ( side ! = null ) return ImmutableList . of ( ) ; 
 + IModelState modelState = this . state ; 
 + if ( state instanceof IExtendedBlockState ) 
 { 
 - ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; 
 - for ( Node < ? > child : node . getNodes ( ) . values ( ) ) 
 - { 
 - builder . addAll ( new BakedWrapper ( child , state , smooth , gui3d , format , meshes , textures ) . getGeneralQuads ( ) ) ; 
 - } 
 - if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) ) 
 + IExtendedBlockState exState = ( IExtendedBlockState ) state ; 
 + if ( exState . getUnlistedNames ( ) . contains ( B3DFrameProperty . instance ) ) 
 { 
 - Mesh mesh = ( Mesh ) node . getKind ( ) ; 
 - Collection < Face > faces = mesh . bake ( new Function < Node < ? > , Matrix4f > ( ) 
 + B3DState s = exState . getValue ( B3DFrameProperty . instance ) ; 
 + if ( s ! = null ) 
 { 
 - private final TRSRTransformation global = state . apply ( Optional . < IModelPart > absent ( ) ) . or ( TRSRTransformation . identity ( ) ) ; 
 - private final LoadingCache < Node < ? > , TRSRTransformation > localCache = CacheBuilder . newBuilder ( ) 
 - . maximumSize ( 32 ) 
 - . build ( new CacheLoader < Node < ? > , TRSRTransformation > ( ) 
 - { 
 - public TRSRTransformation load ( Node < ? > node ) throws Exception 
 - { 
 - return state . apply ( Optional . of ( new NodeJoint ( node ) ) ) . or ( TRSRTransformation . identity ( ) ) ; 
 - } 
 - } ) ; 
 - 
 - public Matrix4f apply ( Node < ? > node ) 
 + / / return getCachedModel ( s . getFrame ( ) ) ; 
 + IModelState parent = this . state ; 
 + Animation newAnimation = s . getAnimation ( ) ; 
 + if ( parent instanceof B3DState ) 
 + { 
 + B3DState ps = ( B3DState ) parent ; 
 + parent = ps . getParent ( ) ; 
 + } 
 + if ( newAnimation = = null ) 
 + { 
 + newAnimation = node . getAnimation ( ) ; 
 + } 
 + if ( s . getFrame ( ) = = s . getNextFrame ( ) ) 
 + { 
 + modelState = cache . getUnchecked ( s . getFrame ( ) ) ; 
 + } 
 + else 
 { 
 - return global . compose ( localCache . getUnchecked ( node ) ) . getMatrix ( ) ; 
 + modelState = new B3DState ( newAnimation , s . getFrame ( ) , s . getNextFrame ( ) , s . getProgress ( ) , parent ) ; 
 } 
 - } ) ; 
 - for ( Face f : faces ) 
 + } 
 + } 
 + else if ( exState . getUnlistedNames ( ) . contains ( Properties . AnimationProperty ) ) 
 + { 
 + / / FIXME : should animation state handle the parent state , or should it remain here ? 
 + IModelState parent = this . state ; 
 + if ( parent instanceof B3DState ) 
 + { 
 + B3DState ps = ( B3DState ) parent ; 
 + parent = ps . getParent ( ) ; 
 + } 
 + IModelState newState = exState . getValue ( Properties . AnimationProperty ) ; 
 + if ( newState ! = null ) 
 { 
 - UnpackedBakedQuad . Builder quadBuilder = new UnpackedBakedQuad . Builder ( format ) ; 
 - quadBuilder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; 
 - quadBuilder . setQuadColored ( ) ; 
 - List < Texture > textures = null ; 
 - if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; 
 - TextureAtlasSprite sprite ; 
 - if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; 
 - else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; 
 - else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; 
 - putVertexData ( quadBuilder , f . getV1 ( ) , f . getNormal ( ) , sprite ) ; 
 - putVertexData ( quadBuilder , f . getV2 ( ) , f . getNormal ( ) , sprite ) ; 
 - putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; 
 - putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; 
 - builder . add ( quadBuilder . build ( ) ) ; 
 + modelState = new ModelStateComposition ( parent , newState ) ; 
 } 
 } 
 + } 
 + if ( quads = = null ) 
 + { 
 + ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; 
 + generateQuads ( builder , node , modelState ) ; 
 quads = builder . build ( ) ; 
 } 
 return quads ; 
 } 
 
 + protected void generateQuads ( ImmutableList . Builder < BakedQuad > builder , Node < ? > node , final IModelState state ) 
 + { 
 + for ( Node < ? > child : node . getNodes ( ) . values ( ) ) 
 + { 
 + generateQuads ( builder , child , state ) ; 
 + } 
 + if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) ) 
 + { 
 + Mesh mesh = ( Mesh ) node . getKind ( ) ; 
 + Collection < Face > faces = mesh . bake ( new Function < Node < ? > , Matrix4f > ( ) 
 + { 
 + private final TRSRTransformation global = state . apply ( Optional . < IModelPart > absent ( ) ) . or ( TRSRTransformation . identity ( ) ) ; 
 + private final LoadingCache < Node < ? > , TRSRTransformation > localCache = CacheBuilder . newBuilder ( ) 
 + . maximumSize ( 32 ) 
 + . build ( new CacheLoader < Node < ? > , TRSRTransformation > ( ) 
 + { 
 + public TRSRTransformation load ( Node < ? > node ) throws Exception 
 + { 
 + return state . apply ( Optional . of ( new NodeJoint ( node ) ) ) . or ( TRSRTransformation . identity ( ) ) ; 
 + } 
 + } ) ; 
 + 
 + public Matrix4f apply ( Node < ? > node ) 
 + { 
 + return global . compose ( localCache . getUnchecked ( node ) ) . getMatrix ( ) ; 
 + } 
 + } ) ; 
 + for ( Face f : faces ) 
 + { 
 + UnpackedBakedQuad . Builder quadBuilder = new UnpackedBakedQuad . Builder ( format ) ; 
 + quadBuilder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; 
 + quadBuilder . setQuadColored ( ) ; 
 + List < Texture > textures = null ; 
 + if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; 
 + TextureAtlasSprite sprite ; 
 + if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; 
 + else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; 
 + else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; 
 + putVertexData ( quadBuilder , f . getV1 ( ) , f . getNormal ( ) , sprite ) ; 
 + putVertexData ( quadBuilder , f . getV2 ( ) , f . getNormal ( ) , sprite ) ; 
 + putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; 
 + putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; 
 + builder . add ( quadBuilder . build ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 private final void putVertexData ( UnpackedBakedQuad . Builder builder , Vertex v , Vector3f faceNormal , TextureAtlasSprite sprite ) 
 { 
 / / TODO handle everything not handled ( texture transformations , bones , transformations , normals , e . t . c ) 
 @ @ - 772 , 60 + 823 , 16 @ @ public class B3DLoader implements ICustomModelLoader 
 return ItemCameraTransforms . DEFAULT ; 
 } 
 
 - / / FIXME merge with getQuads 
 - @ Override 
 - public BakedWrapper handleBlockState ( IBlockState state ) 
 + public Pair < ? extends IBakedModel , Matrix4f > handlePerspective ( TransformType cameraTransformType ) 
 { 
 - if ( state instanceof IExtendedBlockState ) 
 - { 
 - IExtendedBlockState exState = ( IExtendedBlockState ) state ; 
 - if ( exState . getUnlistedNames ( ) . contains ( B3DFrameProperty . instance ) ) 
 - { 
 - B3DState s = exState . getValue ( B3DFrameProperty . instance ) ; 
 - if ( s ! = null ) 
 - { 
 - / / return getCachedModel ( s . getFrame ( ) ) ; 
 - IModelState parent = this . state ; 
 - Animation newAnimation = s . getAnimation ( ) ; 
 - if ( parent instanceof B3DState ) 
 - { 
 - B3DState ps = ( B3DState ) parent ; 
 - parent = ps . getParent ( ) ; 
 - } 
 - if ( newAnimation = = null ) 
 - { 
 - newAnimation = node . getAnimation ( ) ; 
 - } 
 - if ( s . getFrame ( ) = = s . getNextFrame ( ) ) 
 - { 
 - return cache . getUnchecked ( s . getFrame ( ) ) ; 
 - } 
 - B3DState newState = new B3DState ( newAnimation , s . getFrame ( ) , s . getNextFrame ( ) , s . getProgress ( ) , parent ) ; 
 - return new BakedWrapper ( node , newState , smooth , gui3d , format , meshes , textures ) ; 
 - } 
 - } 
 - else if ( exState . getUnlistedNames ( ) . contains ( Properties . AnimationProperty ) ) 
 - { 
 - / / FIXME : should animation state handle the parent state , or should it remain here ? 
 - IModelState parent = this . state ; 
 - if ( parent instanceof B3DState ) 
 - { 
 - B3DState ps = ( B3DState ) parent ; 
 - parent = ps . getParent ( ) ; 
 - } 
 - IModelState newState = exState . getValue ( Properties . AnimationProperty ) ; 
 - if ( newState ! = null ) 
 - { 
 - return new BakedWrapper ( node , new ModelStateComposition ( parent , newState ) , smooth , gui3d , format , meshes , textures ) ; 
 - } 
 - } 
 - } 
 - return this ; 
 + return IPerspectiveAwareModel . MapWrapper . handlePerspective ( this , state , cameraTransformType ) ; 
 } 
 
 - public Pair < ? extends IBakedModel , Matrix4f > handlePerspective ( TransformType cameraTransformType ) 
 + @ Override 
 + public ItemOverrideList func _ 188617 _ f ( ) 
 { 
 - return IPerspectiveAwareModel . MapWrapper . handlePerspective ( this , state , cameraTransformType ) ; 
 + / / TODO handle items 
 + return ItemOverrideList . field _ 188022 _ a ; 
 } 
 } 
 }
