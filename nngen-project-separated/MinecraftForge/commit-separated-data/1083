BLEU SCORE: 0.018709718017288025

TEST MSG: Rework EventSubscriptionTransformer to bake @ Cancelable and @ HasResult values , should increase EventBus performance even more by removing logic from Event constructors .
GENERATED MSG: Log4j2 logging context for things . This should help add context when things go wrong in mods .

TEST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java b / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java <nl> index 6d16b8c . . b60194c 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java <nl> @ @ - 17 , 7 + 17 , 10 @ @ import static org . objectweb . asm . Opcodes . INVOKESPECIAL ; <nl> import static org . objectweb . asm . Opcodes . NEW ; <nl> import static org . objectweb . asm . Opcodes . PUTSTATIC ; <nl> import static org . objectweb . asm . Opcodes . RETURN ; <nl> + import static org . objectweb . asm . Opcodes . IRETURN ; <nl> + import static org . objectweb . asm . Opcodes . ICONST _ 1 ; <nl> import static org . objectweb . asm . Type . VOID _ TYPE ; <nl> + import static org . objectweb . asm . Type . BOOLEAN _ TYPE ; <nl> import static org . objectweb . asm . Type . getMethodDescriptor ; <nl> <nl> import java . util . List ; <nl> @ @ - 27 , 6 + 30 , 7 @ @ import net . minecraft . launchwrapper . IClassTransformer ; <nl> import org . objectweb . asm . ClassReader ; <nl> import org . objectweb . asm . ClassWriter ; <nl> import org . objectweb . asm . Type ; <nl> + import org . objectweb . asm . tree . AnnotationNode ; <nl> import org . objectweb . asm . tree . ClassNode ; <nl> import org . objectweb . asm . tree . FieldInsnNode ; <nl> import org . objectweb . asm . tree . FieldNode ; <nl> @ @ - 82 , 56 + 86 , 87 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> <nl> private boolean buildEvents ( ClassNode classNode ) throws Exception <nl> { <nl> + / / Yes , this recursively loads classes until we get this base class . THIS IS NOT A ISSUE . Coremods should handle re - entry just fine . <nl> + / / If they do not this a COREMOD issue NOT a Forge / LaunchWrapper issue . <nl> Class < ? > parent = this . getClass ( ) . getClassLoader ( ) . loadClass ( classNode . superName . replace ( ' / ' , ' . ' ) ) ; <nl> if ( ! Event . class . isAssignableFrom ( parent ) ) <nl> { <nl> return false ; <nl> } <nl> <nl> - boolean hasSetup = false ; <nl> - boolean hasGetListenerList = false ; <nl> - boolean hasDefaultCtr = false ; <nl> + / / Class < ? > listenerListClazz = Class . forName ( " cpw . mods . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; <nl> + Type tList = Type . getType ( " Lcpw / mods / fml / common / eventhandler / ListenerList ; " ) ; <nl> <nl> - Class < ? > listenerListClazz = Class . forName ( " cpw . mods . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; <nl> - Type tList = Type . getType ( listenerListClazz ) ; <nl> + boolean edited = false ; <nl> + boolean hasSetup = false ; <nl> + boolean hasGetListenerList = false ; <nl> + boolean hasDefaultCtr = false ; <nl> + boolean hasCancelable = false ; <nl> + boolean hasResult = false ; <nl> + String voidDesc = Type . getMethodDescriptor ( VOID _ TYPE ) ; <nl> + String boolDesc = Type . getMethodDescriptor ( BOOLEAN _ TYPE ) ; <nl> + String listDesc = tList . getDescriptor ( ) ; <nl> + String listDescM = Type . getMethodDescriptor ( tList ) ; <nl> <nl> for ( MethodNode method : ( List < MethodNode > ) classNode . methods ) <nl> { <nl> - if ( method . name . equals ( " setup " ) & & <nl> - method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) & & <nl> - ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) <nl> - { <nl> - hasSetup = true ; <nl> - } <nl> - if ( method . name . equals ( " getListenerList " ) & & <nl> - method . desc . equals ( Type . getMethodDescriptor ( tList ) ) & & <nl> - ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) <nl> + if ( method . name . equals ( " setup " ) & & method . desc . equals ( voidDesc ) & & ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) hasSetup = true ; <nl> + if ( ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) <nl> + { <nl> + if ( method . name . equals ( " getListenerList " ) & & method . desc . equals ( listDescM ) ) hasGetListenerList = true ; <nl> + if ( method . name . equals ( " isCancelable " ) & & method . desc . equals ( boolDesc ) ) hasCancelable = true ; <nl> + if ( method . name . equals ( " hasResult " ) & & method . desc . equals ( boolDesc ) ) hasResult = true ; <nl> + } <nl> + if ( method . name . equals ( " < init > " ) & & method . desc . equals ( voidDesc ) ) hasDefaultCtr = true ; <nl> + } <nl> + <nl> + if ( classNode . visibleAnnotations ! = null ) <nl> + { <nl> + for ( AnnotationNode node : classNode . visibleAnnotations ) <nl> + { <nl> + if ( ! hasResult & & node . desc . equals ( " Lcpw / mods / fml / common / eventhandler / Event $ HasResult ; " ) ) <nl> { <nl> - hasGetListenerList = true ; <nl> + / * Add : <nl> + * public boolean hasResult ( ) <nl> + * { <nl> + * return true ; <nl> + * } <nl> + * / <nl> + MethodNode method = new MethodNode ( ACC _ PUBLIC , " hasResult " , boolDesc , null , null ) ; <nl> + method . instructions . add ( new InsnNode ( ICONST _ 1 ) ) ; <nl> + method . instructions . add ( new InsnNode ( IRETURN ) ) ; <nl> + classNode . methods . add ( method ) ; <nl> + edited = true ; <nl> } <nl> - if ( method . name . equals ( " < init > " ) & & <nl> - method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) ) <nl> + else if ( ! hasCancelable & & node . desc . equals ( " Lcpw / mods / fml / common / eventhandler / Cancelable ; " ) ) <nl> { <nl> - hasDefaultCtr = true ; <nl> + / * Add : <nl> + * public boolean isCancelable ( ) <nl> + * { <nl> + * return true ; <nl> + * } <nl> + * / <nl> + MethodNode method = new MethodNode ( ACC _ PUBLIC , " isCancelable " , boolDesc , null , null ) ; <nl> + method . instructions . add ( new InsnNode ( ICONST _ 1 ) ) ; <nl> + method . instructions . add ( new InsnNode ( IRETURN ) ) ; <nl> + classNode . methods . add ( method ) ; <nl> + edited = true ; <nl> } <nl> + } <nl> } <nl> <nl> if ( hasSetup ) <nl> { <nl> - if ( ! hasGetListenerList ) <nl> - { <nl> - throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; <nl> - } <nl> - else <nl> - { <nl> - return false ; <nl> - } <nl> + if ( ! hasGetListenerList ) <nl> + throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; <nl> + else <nl> + return edited ; <nl> } <nl> <nl> Type tSuper = Type . getType ( classNode . superName ) ; <nl> <nl> / / Add private static ListenerList LISTENER _ LIST <nl> - classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , tList . getDescriptor ( ) , null , null ) ) ; <nl> + classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , listDesc , null , null ) ) ; <nl> <nl> / * Add : <nl> * public < init > ( ) <nl> @ @ - 139 , 12 + 174 , 12 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> * super ( ) ; <nl> * } <nl> * / <nl> - MethodNode method = new MethodNode ( ASM5 , ACC _ PUBLIC , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; <nl> - method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , false ) ) ; <nl> - method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> if ( ! hasDefaultCtr ) <nl> { <nl> + MethodNode method = new MethodNode ( ACC _ PUBLIC , " < init > " , voidDesc , null , null ) ; <nl> + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , voidDesc , false ) ) ; <nl> + method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> classNode . methods . add ( method ) ; <nl> } <nl> <nl> @ @ - 159 , 10 + 194 , 10 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> * LISTENER _ LIST = new ListenerList ( super . getListenerList ( ) ) ; <nl> * } <nl> * / <nl> - method = new MethodNode ( ASM5 , ACC _ PROTECTED , " setup " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; <nl> + MethodNode method = new MethodNode ( ACC _ PROTECTED , " setup " , voidDesc , null , null ) ; <nl> method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , getMethodDescriptor ( VOID _ TYPE ) , false ) ) ; <nl> - method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , voidDesc , false ) ) ; <nl> + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; <nl> LabelNode initLisitener = new LabelNode ( ) ; <nl> method . instructions . add ( new JumpInsnNode ( IFNULL , initLisitener ) ) ; <nl> method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> @ @ - 171 , 9 + 206 , 9 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> method . instructions . add ( new TypeInsnNode ( NEW , tList . getInternalName ( ) ) ) ; <nl> method . instructions . add ( new InsnNode ( DUP ) ) ; <nl> method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , getMethodDescriptor ( tList ) , false ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , listDescM , false ) ) ; <nl> method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tList . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE , tList ) , false ) ) ; <nl> - method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; <nl> method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> classNode . methods . add ( method ) ; <nl> <nl> @ @ - 183 , 8 + 218 , 8 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> * return this . LISTENER _ LIST ; <nl> * } <nl> * / <nl> - method = new MethodNode ( ASM5 , ACC _ PUBLIC , " getListenerList " , getMethodDescriptor ( tList ) , null , null ) ; <nl> - method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + method = new MethodNode ( ACC _ PUBLIC , " getListenerList " , listDescM , null , null ) ; <nl> + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; <nl> method . instructions . add ( new InsnNode ( ARETURN ) ) ; <nl> classNode . methods . add ( method ) ; <nl> return true ; <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java <nl> index 80ac792 . . 814e742 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java <nl> @ @ - 32 , 9 + 32 , 7 @ @ public class Event <nl> } <nl> <nl> private boolean isCanceled = false ; <nl> - private final boolean isCancelable ; <nl> private Result result = Result . DEFAULT ; <nl> - private final boolean hasResult ; <nl> private static ListenerList listeners = new ListenerList ( ) ; <nl> private EventPriority phase = null ; <nl> <nl> @ @ - 43 , 48 + 41 , 18 @ @ public class Event <nl> public Event ( ) <nl> { <nl> setup ( ) ; <nl> - isCancelable = hasAnnotation ( Cancelable . class ) ; <nl> - hasResult = hasAnnotation ( HasResult . class ) ; <nl> - } <nl> - <nl> - private boolean hasAnnotation ( Class < ? extends Annotation > annotation ) <nl> - { <nl> - Class < ? > me = this . getClass ( ) ; <nl> - Map < Class < ? > , Boolean > list = annotationMap . get ( me ) ; <nl> - if ( list = = null ) <nl> - { <nl> - list = new ConcurrentHashMap < Class < ? > , Boolean > ( ) ; <nl> - annotationMap . put ( me , list ) ; <nl> - } <nl> - <nl> - Boolean cached = list . get ( annotation ) ; <nl> - if ( cached ! = null ) <nl> - { <nl> - return cached ; <nl> - } <nl> - <nl> - Class < ? > cls = me ; <nl> - while ( cls ! = Event . class ) <nl> - { <nl> - if ( cls . isAnnotationPresent ( annotation ) ) <nl> - { <nl> - list . put ( annotation , true ) ; <nl> - return true ; <nl> - } <nl> - cls = cls . getSuperclass ( ) ; <nl> - } <nl> - <nl> - list . put ( annotation , false ) ; <nl> - return false ; <nl> } <nl> <nl> / * * <nl> * Determine if this function is cancelable at all . <nl> * @ return If access to setCanceled should be allowed <nl> + * <nl> + * Note : <nl> + * Events with the Cancelable annotation will have this method automatically added to return true . <nl> * / <nl> public boolean isCancelable ( ) <nl> { <nl> - return isCancelable ; <nl> + return false ; <nl> } <nl> <nl> / * * <nl> @ @ - 115 , 10 + 83 , 13 @ @ public class Event <nl> <nl> / * * <nl> * Determines if this event expects a significant result value . <nl> + * <nl> + * Note : <nl> + * Events with the HasResult annotation will have this method automatically added to return true . <nl> * / <nl> public boolean hasResult ( ) <nl> { <nl> - return hasResult ; <nl> + return false ; <nl> } <nl> <nl> / * *
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / LoadController . java b / fml / src / main / java / cpw / mods / fml / common / LoadController . java <nl> index 3fdf5d9 . . e780752 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / LoadController . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / LoadController . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ import java . util . List ; <nl> import java . util . Map . Entry ; <nl> <nl> import org . apache . logging . log4j . Level ; <nl> + import org . apache . logging . log4j . ThreadContext ; <nl> <nl> import com . google . common . base . Joiner ; <nl> import com . google . common . collect . ArrayListMultimap ; <nl> @ @ - 201 , 9 + 202 , 11 @ @ public class LoadController <nl> } <nl> activeContainer = mc ; <nl> stateEvent . applyModContainer ( activeContainer ( ) ) ; <nl> + ThreadContext . put ( " mod " , modId ) ; <nl> FMLLog . log ( modId , Level . TRACE , " Sending event % s to mod % s " , stateEvent . getEventType ( ) , modId ) ; <nl> eventChannels . get ( modId ) . post ( stateEvent ) ; <nl> FMLLog . log ( modId , Level . TRACE , " Sent event % s to mod % s " , stateEvent . getEventType ( ) , modId ) ; <nl> + ThreadContext . put ( " mod " , " < NONE > " ) ; <nl> activeContainer = null ; <nl> if ( stateEvent instanceof FMLStateEvent ) <nl> { <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java <nl> index 02bb037 . . 4c59a05 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java <nl> @ @ - 6 , 25 + 6 , 29 @ @ import java . lang . reflect . Method ; <nl> import java . util . HashMap ; <nl> <nl> <nl> + import org . apache . logging . log4j . ThreadContext ; <nl> import org . objectweb . asm . ClassWriter ; <nl> import org . objectweb . asm . MethodVisitor ; <nl> import org . objectweb . asm . Type ; <nl> <nl> import com . google . common . collect . Maps ; <nl> + import cpw . mods . fml . common . ModContainer ; <nl> <nl> <nl> public class ASMEventHandler implements IEventListener <nl> { <nl> private static int IDs = 0 ; <nl> private static final String HANDLER _ DESC = Type . getInternalName ( IEventListener . class ) ; <nl> - private static final String HANDLER _ FUNC _ DESC = Type . getMethodDescriptor ( IEventListener . class . getDeclaredMethods ( ) [ 0 ] ) ; <nl> + private static final String HANDLER _ FUNC _ DESC = Type . getMethodDescriptor ( IEventListener . class . getDeclaredMethods ( ) [ 0 ] ) ; <nl> private static final ASMClassLoader LOADER = new ASMClassLoader ( ) ; <nl> private static final HashMap < Method , Class < ? > > cache = Maps . newHashMap ( ) ; <nl> - <nl> + <nl> private final IEventListener handler ; <nl> private final SubscribeEvent subInfo ; <nl> - public ASMEventHandler ( Object target , Method method ) throws Exception <nl> + private ModContainer owner ; <nl> + public ASMEventHandler ( Object target , Method method , ModContainer owner ) throws Exception <nl> { <nl> + this . owner = owner ; <nl> handler = ( IEventListener ) createWrapper ( method ) . getConstructor ( Object . class ) . newInstance ( target ) ; <nl> subInfo = method . getAnnotation ( SubscribeEvent . class ) ; <nl> } <nl> @ @ - 32 , 6 + 36 , 14 @ @ public class ASMEventHandler implements IEventListener <nl> @ Override <nl> public void invoke ( Event event ) <nl> { <nl> + if ( owner ! = null ) <nl> + { <nl> + ThreadContext . put ( " mod " , owner . getName ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + ThreadContext . put ( " mod " , " < NONE > " ) ; <nl> + } <nl> if ( handler ! = null ) <nl> { <nl> if ( ! event . isCancelable ( ) | | ! event . isCanceled ( ) | | subInfo . receiveCanceled ( ) ) <nl> @ @ - 39 , 13 + 51 , 14 @ @ public class ASMEventHandler implements IEventListener <nl> handler . invoke ( event ) ; <nl> } <nl> } <nl> + ThreadContext . remove ( " mod " ) ; <nl> } <nl> - <nl> + <nl> public EventPriority getPriority ( ) <nl> { <nl> return subInfo . priority ( ) ; <nl> } <nl> - <nl> + <nl> public Class < ? > createWrapper ( Method callback ) <nl> { <nl> if ( cache . containsKey ( callback ) ) <nl> @ @ - 55 , 12 + 68 , 12 @ @ public class ASMEventHandler implements IEventListener <nl> <nl> ClassWriter cw = new ClassWriter ( 0 ) ; <nl> MethodVisitor mv ; <nl> - <nl> + <nl> String name = getUniqueName ( callback ) ; <nl> String desc = name . replace ( ' . ' , ' / ' ) ; <nl> String instType = Type . getInternalName ( callback . getDeclaringClass ( ) ) ; <nl> String eventType = Type . getInternalName ( callback . getParameterTypes ( ) [ 0 ] ) ; <nl> - <nl> + <nl> / * <nl> System . out . println ( " Name : " + name ) ; <nl> System . out . println ( " Desc : " + desc ) ; <nl> @ @ - 68 , 7 + 81 , 7 @ @ public class ASMEventHandler implements IEventListener <nl> System . out . println ( " Callback : " + callback . getName ( ) + Type . getMethodDescriptor ( callback ) ) ; <nl> System . out . println ( " Event : " + eventType ) ; <nl> * / <nl> - <nl> + <nl> cw . visit ( V1 _ 6 , ACC _ PUBLIC | ACC _ SUPER , desc , null , " java / lang / Object " , new String [ ] { HANDLER _ DESC } ) ; <nl> <nl> cw . visitSource ( " . dynamic " , null ) ; <nl> @ @ - 105 , 22 + 118 , 22 @ @ public class ASMEventHandler implements IEventListener <nl> cache . put ( callback , ret ) ; <nl> return ret ; <nl> } <nl> - <nl> + <nl> private String getUniqueName ( Method callback ) <nl> { <nl> - return String . format ( " % s _ % d _ % s _ % s _ % s " , getClass ( ) . getName ( ) , IDs + + , <nl> - callback . getDeclaringClass ( ) . getSimpleName ( ) , <nl> - callback . getName ( ) , <nl> + return String . format ( " % s _ % d _ % s _ % s _ % s " , getClass ( ) . getName ( ) , IDs + + , <nl> + callback . getDeclaringClass ( ) . getSimpleName ( ) , <nl> + callback . getName ( ) , <nl> callback . getParameterTypes ( ) [ 0 ] . getSimpleName ( ) ) ; <nl> } <nl> - <nl> + <nl> private static class ASMClassLoader extends ClassLoader <nl> { <nl> private ASMClassLoader ( ) <nl> { <nl> super ( ASMClassLoader . class . getClassLoader ( ) ) ; <nl> } <nl> - <nl> + <nl> public Class < ? > define ( String name , byte [ ] data ) <nl> { <nl> return defineClass ( name , data , 0 , data . length ) ; <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java <nl> index aa6640d . . 3dfe411 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java <nl> @ @ - 3 , 18 + 3 , 23 @ @ package cpw . mods . fml . common . eventhandler ; <nl> import java . lang . reflect . Constructor ; <nl> import java . lang . reflect . Method ; <nl> import java . util . ArrayList ; <nl> + import java . util . Map ; <nl> import java . util . Set ; <nl> import java . util . concurrent . ConcurrentHashMap ; <nl> <nl> <nl> <nl> + import com . google . common . collect . MapMaker ; <nl> import com . google . common . reflect . TypeToken ; <nl> + import cpw . mods . fml . common . Loader ; <nl> + import cpw . mods . fml . common . ModContainer ; <nl> <nl> public class EventBus <nl> { <nl> private static int maxID = 0 ; <nl> <nl> private ConcurrentHashMap < Object , ArrayList < IEventListener > > listeners = new ConcurrentHashMap < Object , ArrayList < IEventListener > > ( ) ; <nl> + private Map < Object , ModContainer > listenerOwners = new MapMaker ( ) . weakKeys ( ) . weakValues ( ) . makeMap ( ) ; <nl> private final int busID = maxID + + ; <nl> <nl> public EventBus ( ) <nl> @ @ - 29 , 6 + 34 , 7 @ @ public class EventBus <nl> return ; <nl> } <nl> <nl> + listenerOwners . put ( target , Loader . instance ( ) . activeModContainer ( ) ) ; <nl> Set < ? extends Class < ? > > supers = TypeToken . of ( target . getClass ( ) ) . getTypes ( ) . rawTypes ( ) ; <nl> for ( Method method : target . getClass ( ) . getMethods ( ) ) <nl> { <nl> @ @ - 52 , 10 + 58 , 10 @ @ public class EventBus <nl> <nl> if ( ! Event . class . isAssignableFrom ( eventType ) ) <nl> { <nl> - throw new IllegalArgumentException ( " Method " + method + " has @ SubscribeEvent annotation , but takes a argument that is not a Event " + eventType ) ; <nl> + throw new IllegalArgumentException ( " Method " + method + " has @ SubscribeEvent annotation , but takes a argument that is not an Event " + eventType ) ; <nl> } <nl> <nl> - register ( eventType , target , method ) ; <nl> + register ( eventType , target , method , Loader . instance ( ) . activeModContainer ( ) ) ; <nl> break ; <nl> } <nl> } <nl> @ @ - 67 , 14 + 73 , 14 @ @ public class EventBus <nl> } <nl> } <nl> <nl> - private void register ( Class < ? > eventType , Object target , Method method ) <nl> + private void register ( Class < ? > eventType , Object target , Method method , ModContainer owner ) <nl> { <nl> try <nl> { <nl> Constructor < ? > ctr = eventType . getConstructor ( ) ; <nl> ctr . setAccessible ( true ) ; <nl> Event event = ( Event ) ctr . newInstance ( ) ; <nl> - ASMEventHandler listener = new ASMEventHandler ( target , method ) ; <nl> + ASMEventHandler listener = new ASMEventHandler ( target , method , owner ) ; <nl> event . getListenerList ( ) . register ( busID , listener . getPriority ( ) , listener ) ; <nl> <nl> ArrayList < IEventListener > others = listeners . get ( target ) ; <nl> diff - - git a / fml / src / main / resources / log4j2 . xml b / fml / src / main / resources / log4j2 . xml <nl> index 18eab39 . . 3f9cb3b 100644 <nl> - - - a / fml / src / main / resources / log4j2 . xml <nl> + + + b / fml / src / main / resources / log4j2 . xml <nl> @ @ - 21 , 7 + 21 , 7 @ @ <nl> < Routes pattern = " $ $ { ctx : side } " > <nl> < Route > <nl> < RollingRandomAccessFile name = " FmlFile " fileName = " logs / fml - $ { ctx : side } - latest . log " filePattern = " logs / fml - $ { ctx : side } - % i . log " > <nl> - < PatternLayout pattern = " [ % d { HH : mm : ss } ] [ % t / % level ] [ % logger ] : % msg % n " / > <nl> + < PatternLayout pattern = " [ % d { HH : mm : ss } ] [ % t / % level ] [ % logger / % X { mod } ] : % msg % n " / > <nl> < DefaultRolloverStrategy max = " 3 " fileIndex = " max " / > <nl> < Policies > <nl> < OnStartupTriggeringPolicy / >

TEST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java b / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java 
 index 6d16b8c . . b60194c 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / asm / transformers / EventSubscriptionTransformer . java 
 @ @ - 17 , 7 + 17 , 10 @ @ import static org . objectweb . asm . Opcodes . INVOKESPECIAL ; 
 import static org . objectweb . asm . Opcodes . NEW ; 
 import static org . objectweb . asm . Opcodes . PUTSTATIC ; 
 import static org . objectweb . asm . Opcodes . RETURN ; 
 + import static org . objectweb . asm . Opcodes . IRETURN ; 
 + import static org . objectweb . asm . Opcodes . ICONST _ 1 ; 
 import static org . objectweb . asm . Type . VOID _ TYPE ; 
 + import static org . objectweb . asm . Type . BOOLEAN _ TYPE ; 
 import static org . objectweb . asm . Type . getMethodDescriptor ; 
 
 import java . util . List ; 
 @ @ - 27 , 6 + 30 , 7 @ @ import net . minecraft . launchwrapper . IClassTransformer ; 
 import org . objectweb . asm . ClassReader ; 
 import org . objectweb . asm . ClassWriter ; 
 import org . objectweb . asm . Type ; 
 + import org . objectweb . asm . tree . AnnotationNode ; 
 import org . objectweb . asm . tree . ClassNode ; 
 import org . objectweb . asm . tree . FieldInsnNode ; 
 import org . objectweb . asm . tree . FieldNode ; 
 @ @ - 82 , 56 + 86 , 87 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 
 private boolean buildEvents ( ClassNode classNode ) throws Exception 
 { 
 + / / Yes , this recursively loads classes until we get this base class . THIS IS NOT A ISSUE . Coremods should handle re - entry just fine . 
 + / / If they do not this a COREMOD issue NOT a Forge / LaunchWrapper issue . 
 Class < ? > parent = this . getClass ( ) . getClassLoader ( ) . loadClass ( classNode . superName . replace ( ' / ' , ' . ' ) ) ; 
 if ( ! Event . class . isAssignableFrom ( parent ) ) 
 { 
 return false ; 
 } 
 
 - boolean hasSetup = false ; 
 - boolean hasGetListenerList = false ; 
 - boolean hasDefaultCtr = false ; 
 + / / Class < ? > listenerListClazz = Class . forName ( " cpw . mods . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; 
 + Type tList = Type . getType ( " Lcpw / mods / fml / common / eventhandler / ListenerList ; " ) ; 
 
 - Class < ? > listenerListClazz = Class . forName ( " cpw . mods . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; 
 - Type tList = Type . getType ( listenerListClazz ) ; 
 + boolean edited = false ; 
 + boolean hasSetup = false ; 
 + boolean hasGetListenerList = false ; 
 + boolean hasDefaultCtr = false ; 
 + boolean hasCancelable = false ; 
 + boolean hasResult = false ; 
 + String voidDesc = Type . getMethodDescriptor ( VOID _ TYPE ) ; 
 + String boolDesc = Type . getMethodDescriptor ( BOOLEAN _ TYPE ) ; 
 + String listDesc = tList . getDescriptor ( ) ; 
 + String listDescM = Type . getMethodDescriptor ( tList ) ; 
 
 for ( MethodNode method : ( List < MethodNode > ) classNode . methods ) 
 { 
 - if ( method . name . equals ( " setup " ) & & 
 - method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) & & 
 - ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) 
 - { 
 - hasSetup = true ; 
 - } 
 - if ( method . name . equals ( " getListenerList " ) & & 
 - method . desc . equals ( Type . getMethodDescriptor ( tList ) ) & & 
 - ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) 
 + if ( method . name . equals ( " setup " ) & & method . desc . equals ( voidDesc ) & & ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) hasSetup = true ; 
 + if ( ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) 
 + { 
 + if ( method . name . equals ( " getListenerList " ) & & method . desc . equals ( listDescM ) ) hasGetListenerList = true ; 
 + if ( method . name . equals ( " isCancelable " ) & & method . desc . equals ( boolDesc ) ) hasCancelable = true ; 
 + if ( method . name . equals ( " hasResult " ) & & method . desc . equals ( boolDesc ) ) hasResult = true ; 
 + } 
 + if ( method . name . equals ( " < init > " ) & & method . desc . equals ( voidDesc ) ) hasDefaultCtr = true ; 
 + } 
 + 
 + if ( classNode . visibleAnnotations ! = null ) 
 + { 
 + for ( AnnotationNode node : classNode . visibleAnnotations ) 
 + { 
 + if ( ! hasResult & & node . desc . equals ( " Lcpw / mods / fml / common / eventhandler / Event $ HasResult ; " ) ) 
 { 
 - hasGetListenerList = true ; 
 + / * Add : 
 + * public boolean hasResult ( ) 
 + * { 
 + * return true ; 
 + * } 
 + * / 
 + MethodNode method = new MethodNode ( ACC _ PUBLIC , " hasResult " , boolDesc , null , null ) ; 
 + method . instructions . add ( new InsnNode ( ICONST _ 1 ) ) ; 
 + method . instructions . add ( new InsnNode ( IRETURN ) ) ; 
 + classNode . methods . add ( method ) ; 
 + edited = true ; 
 } 
 - if ( method . name . equals ( " < init > " ) & & 
 - method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) ) 
 + else if ( ! hasCancelable & & node . desc . equals ( " Lcpw / mods / fml / common / eventhandler / Cancelable ; " ) ) 
 { 
 - hasDefaultCtr = true ; 
 + / * Add : 
 + * public boolean isCancelable ( ) 
 + * { 
 + * return true ; 
 + * } 
 + * / 
 + MethodNode method = new MethodNode ( ACC _ PUBLIC , " isCancelable " , boolDesc , null , null ) ; 
 + method . instructions . add ( new InsnNode ( ICONST _ 1 ) ) ; 
 + method . instructions . add ( new InsnNode ( IRETURN ) ) ; 
 + classNode . methods . add ( method ) ; 
 + edited = true ; 
 } 
 + } 
 } 
 
 if ( hasSetup ) 
 { 
 - if ( ! hasGetListenerList ) 
 - { 
 - throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; 
 - } 
 - else 
 - { 
 - return false ; 
 - } 
 + if ( ! hasGetListenerList ) 
 + throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; 
 + else 
 + return edited ; 
 } 
 
 Type tSuper = Type . getType ( classNode . superName ) ; 
 
 / / Add private static ListenerList LISTENER _ LIST 
 - classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , tList . getDescriptor ( ) , null , null ) ) ; 
 + classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , listDesc , null , null ) ) ; 
 
 / * Add : 
 * public < init > ( ) 
 @ @ - 139 , 12 + 174 , 12 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 * super ( ) ; 
 * } 
 * / 
 - MethodNode method = new MethodNode ( ASM5 , ACC _ PUBLIC , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; 
 - method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , false ) ) ; 
 - method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 if ( ! hasDefaultCtr ) 
 { 
 + MethodNode method = new MethodNode ( ACC _ PUBLIC , " < init > " , voidDesc , null , null ) ; 
 + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , voidDesc , false ) ) ; 
 + method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 classNode . methods . add ( method ) ; 
 } 
 
 @ @ - 159 , 10 + 194 , 10 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 * LISTENER _ LIST = new ListenerList ( super . getListenerList ( ) ) ; 
 * } 
 * / 
 - method = new MethodNode ( ASM5 , ACC _ PROTECTED , " setup " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; 
 + MethodNode method = new MethodNode ( ACC _ PROTECTED , " setup " , voidDesc , null , null ) ; 
 method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , getMethodDescriptor ( VOID _ TYPE ) , false ) ) ; 
 - method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , voidDesc , false ) ) ; 
 + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; 
 LabelNode initLisitener = new LabelNode ( ) ; 
 method . instructions . add ( new JumpInsnNode ( IFNULL , initLisitener ) ) ; 
 method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 @ @ - 171 , 9 + 206 , 9 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 method . instructions . add ( new TypeInsnNode ( NEW , tList . getInternalName ( ) ) ) ; 
 method . instructions . add ( new InsnNode ( DUP ) ) ; 
 method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , getMethodDescriptor ( tList ) , false ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , listDescM , false ) ) ; 
 method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tList . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE , tList ) , false ) ) ; 
 - method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; 
 method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 classNode . methods . add ( method ) ; 
 
 @ @ - 183 , 8 + 218 , 8 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 * return this . LISTENER _ LIST ; 
 * } 
 * / 
 - method = new MethodNode ( ASM5 , ACC _ PUBLIC , " getListenerList " , getMethodDescriptor ( tList ) , null , null ) ; 
 - method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + method = new MethodNode ( ACC _ PUBLIC , " getListenerList " , listDescM , null , null ) ; 
 + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; 
 method . instructions . add ( new InsnNode ( ARETURN ) ) ; 
 classNode . methods . add ( method ) ; 
 return true ; 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java 
 index 80ac792 . . 814e742 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / Event . java 
 @ @ - 32 , 9 + 32 , 7 @ @ public class Event 
 } 
 
 private boolean isCanceled = false ; 
 - private final boolean isCancelable ; 
 private Result result = Result . DEFAULT ; 
 - private final boolean hasResult ; 
 private static ListenerList listeners = new ListenerList ( ) ; 
 private EventPriority phase = null ; 
 
 @ @ - 43 , 48 + 41 , 18 @ @ public class Event 
 public Event ( ) 
 { 
 setup ( ) ; 
 - isCancelable = hasAnnotation ( Cancelable . class ) ; 
 - hasResult = hasAnnotation ( HasResult . class ) ; 
 - } 
 - 
 - private boolean hasAnnotation ( Class < ? extends Annotation > annotation ) 
 - { 
 - Class < ? > me = this . getClass ( ) ; 
 - Map < Class < ? > , Boolean > list = annotationMap . get ( me ) ; 
 - if ( list = = null ) 
 - { 
 - list = new ConcurrentHashMap < Class < ? > , Boolean > ( ) ; 
 - annotationMap . put ( me , list ) ; 
 - } 
 - 
 - Boolean cached = list . get ( annotation ) ; 
 - if ( cached ! = null ) 
 - { 
 - return cached ; 
 - } 
 - 
 - Class < ? > cls = me ; 
 - while ( cls ! = Event . class ) 
 - { 
 - if ( cls . isAnnotationPresent ( annotation ) ) 
 - { 
 - list . put ( annotation , true ) ; 
 - return true ; 
 - } 
 - cls = cls . getSuperclass ( ) ; 
 - } 
 - 
 - list . put ( annotation , false ) ; 
 - return false ; 
 } 
 
 / * * 
 * Determine if this function is cancelable at all . 
 * @ return If access to setCanceled should be allowed 
 + * 
 + * Note : 
 + * Events with the Cancelable annotation will have this method automatically added to return true . 
 * / 
 public boolean isCancelable ( ) 
 { 
 - return isCancelable ; 
 + return false ; 
 } 
 
 / * * 
 @ @ - 115 , 10 + 83 , 13 @ @ public class Event 
 
 / * * 
 * Determines if this event expects a significant result value . 
 + * 
 + * Note : 
 + * Events with the HasResult annotation will have this method automatically added to return true . 
 * / 
 public boolean hasResult ( ) 
 { 
 - return hasResult ; 
 + return false ; 
 } 
 
 / * *

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / LoadController . java b / fml / src / main / java / cpw / mods / fml / common / LoadController . java 
 index 3fdf5d9 . . e780752 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / LoadController . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / LoadController . java 
 @ @ - 19 , 6 + 19 , 7 @ @ import java . util . List ; 
 import java . util . Map . Entry ; 
 
 import org . apache . logging . log4j . Level ; 
 + import org . apache . logging . log4j . ThreadContext ; 
 
 import com . google . common . base . Joiner ; 
 import com . google . common . collect . ArrayListMultimap ; 
 @ @ - 201 , 9 + 202 , 11 @ @ public class LoadController 
 } 
 activeContainer = mc ; 
 stateEvent . applyModContainer ( activeContainer ( ) ) ; 
 + ThreadContext . put ( " mod " , modId ) ; 
 FMLLog . log ( modId , Level . TRACE , " Sending event % s to mod % s " , stateEvent . getEventType ( ) , modId ) ; 
 eventChannels . get ( modId ) . post ( stateEvent ) ; 
 FMLLog . log ( modId , Level . TRACE , " Sent event % s to mod % s " , stateEvent . getEventType ( ) , modId ) ; 
 + ThreadContext . put ( " mod " , " < NONE > " ) ; 
 activeContainer = null ; 
 if ( stateEvent instanceof FMLStateEvent ) 
 { 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java 
 index 02bb037 . . 4c59a05 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / ASMEventHandler . java 
 @ @ - 6 , 25 + 6 , 29 @ @ import java . lang . reflect . Method ; 
 import java . util . HashMap ; 
 
 
 + import org . apache . logging . log4j . ThreadContext ; 
 import org . objectweb . asm . ClassWriter ; 
 import org . objectweb . asm . MethodVisitor ; 
 import org . objectweb . asm . Type ; 
 
 import com . google . common . collect . Maps ; 
 + import cpw . mods . fml . common . ModContainer ; 
 
 
 public class ASMEventHandler implements IEventListener 
 { 
 private static int IDs = 0 ; 
 private static final String HANDLER _ DESC = Type . getInternalName ( IEventListener . class ) ; 
 - private static final String HANDLER _ FUNC _ DESC = Type . getMethodDescriptor ( IEventListener . class . getDeclaredMethods ( ) [ 0 ] ) ; 
 + private static final String HANDLER _ FUNC _ DESC = Type . getMethodDescriptor ( IEventListener . class . getDeclaredMethods ( ) [ 0 ] ) ; 
 private static final ASMClassLoader LOADER = new ASMClassLoader ( ) ; 
 private static final HashMap < Method , Class < ? > > cache = Maps . newHashMap ( ) ; 
 - 
 + 
 private final IEventListener handler ; 
 private final SubscribeEvent subInfo ; 
 - public ASMEventHandler ( Object target , Method method ) throws Exception 
 + private ModContainer owner ; 
 + public ASMEventHandler ( Object target , Method method , ModContainer owner ) throws Exception 
 { 
 + this . owner = owner ; 
 handler = ( IEventListener ) createWrapper ( method ) . getConstructor ( Object . class ) . newInstance ( target ) ; 
 subInfo = method . getAnnotation ( SubscribeEvent . class ) ; 
 } 
 @ @ - 32 , 6 + 36 , 14 @ @ public class ASMEventHandler implements IEventListener 
 @ Override 
 public void invoke ( Event event ) 
 { 
 + if ( owner ! = null ) 
 + { 
 + ThreadContext . put ( " mod " , owner . getName ( ) ) ; 
 + } 
 + else 
 + { 
 + ThreadContext . put ( " mod " , " < NONE > " ) ; 
 + } 
 if ( handler ! = null ) 
 { 
 if ( ! event . isCancelable ( ) | | ! event . isCanceled ( ) | | subInfo . receiveCanceled ( ) ) 
 @ @ - 39 , 13 + 51 , 14 @ @ public class ASMEventHandler implements IEventListener 
 handler . invoke ( event ) ; 
 } 
 } 
 + ThreadContext . remove ( " mod " ) ; 
 } 
 - 
 + 
 public EventPriority getPriority ( ) 
 { 
 return subInfo . priority ( ) ; 
 } 
 - 
 + 
 public Class < ? > createWrapper ( Method callback ) 
 { 
 if ( cache . containsKey ( callback ) ) 
 @ @ - 55 , 12 + 68 , 12 @ @ public class ASMEventHandler implements IEventListener 
 
 ClassWriter cw = new ClassWriter ( 0 ) ; 
 MethodVisitor mv ; 
 - 
 + 
 String name = getUniqueName ( callback ) ; 
 String desc = name . replace ( ' . ' , ' / ' ) ; 
 String instType = Type . getInternalName ( callback . getDeclaringClass ( ) ) ; 
 String eventType = Type . getInternalName ( callback . getParameterTypes ( ) [ 0 ] ) ; 
 - 
 + 
 / * 
 System . out . println ( " Name : " + name ) ; 
 System . out . println ( " Desc : " + desc ) ; 
 @ @ - 68 , 7 + 81 , 7 @ @ public class ASMEventHandler implements IEventListener 
 System . out . println ( " Callback : " + callback . getName ( ) + Type . getMethodDescriptor ( callback ) ) ; 
 System . out . println ( " Event : " + eventType ) ; 
 * / 
 - 
 + 
 cw . visit ( V1 _ 6 , ACC _ PUBLIC | ACC _ SUPER , desc , null , " java / lang / Object " , new String [ ] { HANDLER _ DESC } ) ; 
 
 cw . visitSource ( " . dynamic " , null ) ; 
 @ @ - 105 , 22 + 118 , 22 @ @ public class ASMEventHandler implements IEventListener 
 cache . put ( callback , ret ) ; 
 return ret ; 
 } 
 - 
 + 
 private String getUniqueName ( Method callback ) 
 { 
 - return String . format ( " % s _ % d _ % s _ % s _ % s " , getClass ( ) . getName ( ) , IDs + + , 
 - callback . getDeclaringClass ( ) . getSimpleName ( ) , 
 - callback . getName ( ) , 
 + return String . format ( " % s _ % d _ % s _ % s _ % s " , getClass ( ) . getName ( ) , IDs + + , 
 + callback . getDeclaringClass ( ) . getSimpleName ( ) , 
 + callback . getName ( ) , 
 callback . getParameterTypes ( ) [ 0 ] . getSimpleName ( ) ) ; 
 } 
 - 
 + 
 private static class ASMClassLoader extends ClassLoader 
 { 
 private ASMClassLoader ( ) 
 { 
 super ( ASMClassLoader . class . getClassLoader ( ) ) ; 
 } 
 - 
 + 
 public Class < ? > define ( String name , byte [ ] data ) 
 { 
 return defineClass ( name , data , 0 , data . length ) ; 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java 
 index aa6640d . . 3dfe411 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / eventhandler / EventBus . java 
 @ @ - 3 , 18 + 3 , 23 @ @ package cpw . mods . fml . common . eventhandler ; 
 import java . lang . reflect . Constructor ; 
 import java . lang . reflect . Method ; 
 import java . util . ArrayList ; 
 + import java . util . Map ; 
 import java . util . Set ; 
 import java . util . concurrent . ConcurrentHashMap ; 
 
 
 
 + import com . google . common . collect . MapMaker ; 
 import com . google . common . reflect . TypeToken ; 
 + import cpw . mods . fml . common . Loader ; 
 + import cpw . mods . fml . common . ModContainer ; 
 
 public class EventBus 
 { 
 private static int maxID = 0 ; 
 
 private ConcurrentHashMap < Object , ArrayList < IEventListener > > listeners = new ConcurrentHashMap < Object , ArrayList < IEventListener > > ( ) ; 
 + private Map < Object , ModContainer > listenerOwners = new MapMaker ( ) . weakKeys ( ) . weakValues ( ) . makeMap ( ) ; 
 private final int busID = maxID + + ; 
 
 public EventBus ( ) 
 @ @ - 29 , 6 + 34 , 7 @ @ public class EventBus 
 return ; 
 } 
 
 + listenerOwners . put ( target , Loader . instance ( ) . activeModContainer ( ) ) ; 
 Set < ? extends Class < ? > > supers = TypeToken . of ( target . getClass ( ) ) . getTypes ( ) . rawTypes ( ) ; 
 for ( Method method : target . getClass ( ) . getMethods ( ) ) 
 { 
 @ @ - 52 , 10 + 58 , 10 @ @ public class EventBus 
 
 if ( ! Event . class . isAssignableFrom ( eventType ) ) 
 { 
 - throw new IllegalArgumentException ( " Method " + method + " has @ SubscribeEvent annotation , but takes a argument that is not a Event " + eventType ) ; 
 + throw new IllegalArgumentException ( " Method " + method + " has @ SubscribeEvent annotation , but takes a argument that is not an Event " + eventType ) ; 
 } 
 
 - register ( eventType , target , method ) ; 
 + register ( eventType , target , method , Loader . instance ( ) . activeModContainer ( ) ) ; 
 break ; 
 } 
 } 
 @ @ - 67 , 14 + 73 , 14 @ @ public class EventBus 
 } 
 } 
 
 - private void register ( Class < ? > eventType , Object target , Method method ) 
 + private void register ( Class < ? > eventType , Object target , Method method , ModContainer owner ) 
 { 
 try 
 { 
 Constructor < ? > ctr = eventType . getConstructor ( ) ; 
 ctr . setAccessible ( true ) ; 
 Event event = ( Event ) ctr . newInstance ( ) ; 
 - ASMEventHandler listener = new ASMEventHandler ( target , method ) ; 
 + ASMEventHandler listener = new ASMEventHandler ( target , method , owner ) ; 
 event . getListenerList ( ) . register ( busID , listener . getPriority ( ) , listener ) ; 
 
 ArrayList < IEventListener > others = listeners . get ( target ) ; 
 diff - - git a / fml / src / main / resources / log4j2 . xml b / fml / src / main / resources / log4j2 . xml 
 index 18eab39 . . 3f9cb3b 100644 
 - - - a / fml / src / main / resources / log4j2 . xml 
 + + + b / fml / src / main / resources / log4j2 . xml 
 @ @ - 21 , 7 + 21 , 7 @ @ 
 < Routes pattern = " $ $ { ctx : side } " > 
 < Route > 
 < RollingRandomAccessFile name = " FmlFile " fileName = " logs / fml - $ { ctx : side } - latest . log " filePattern = " logs / fml - $ { ctx : side } - % i . log " > 
 - < PatternLayout pattern = " [ % d { HH : mm : ss } ] [ % t / % level ] [ % logger ] : % msg % n " / > 
 + < PatternLayout pattern = " [ % d { HH : mm : ss } ] [ % t / % level ] [ % logger / % X { mod } ] : % msg % n " / > 
 < DefaultRolloverStrategy max = " 3 " fileIndex = " max " / > 
 < Policies > 
 < OnStartupTriggeringPolicy / >
