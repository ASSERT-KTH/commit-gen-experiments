BLEU SCORE: 0.014199193612838947

TEST MSG: Move registry snapshot read / write code to Snapshot class . Cleaner code .
GENERATED MSG: Commit the start of some pluggable transformers

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> index 8f09c1c . . 2d7794b 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> @ @ - 23 , 7 + 23 , 6 @ @ import java . io . File ; <nl> import java . security . cert . Certificate ; <nl> import java . util . Arrays ; <nl> import java . util . Map ; <nl> - import java . util . Map . Entry ; <nl> import net . minecraft . nbt . NBTBase ; <nl> import net . minecraft . nbt . NBTTagCompound ; <nl> import net . minecraft . nbt . NBTTagList ; <nl> @ @ - 44 , 7 + 43 , 6 @ @ import net . minecraftforge . registries . ForgeRegistry ; <nl> import net . minecraftforge . registries . GameData ; <nl> import net . minecraftforge . registries . RegistryManager ; <nl> <nl> - import org . apache . logging . log4j . Level ; <nl> import org . apache . logging . log4j . LogManager ; <nl> <nl> import com . google . common . collect . Maps ; <nl> @ @ - 127 , 54 + 125 , 7 @ @ public final class FMLContainer extends DummyModContainer implements WorldAccess <nl> <nl> for ( Map . Entry < ResourceLocation , ForgeRegistry . Snapshot > e : RegistryManager . ACTIVE . takeSnapshot ( true ) . entrySet ( ) ) <nl> { <nl> - NBTTagCompound data = new NBTTagCompound ( ) ; <nl> - registries . setTag ( e . getKey ( ) . toString ( ) , data ) ; <nl> - <nl> - NBTTagList ids = new NBTTagList ( ) ; <nl> - for ( Entry < ResourceLocation , Integer > item : e . getValue ( ) . ids . entrySet ( ) ) <nl> - { <nl> - NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> - tag . setString ( " K " , item . getKey ( ) . toString ( ) ) ; <nl> - tag . setInteger ( " V " , item . getValue ( ) ) ; <nl> - ids . appendTag ( tag ) ; <nl> - } <nl> - data . setTag ( " ids " , ids ) ; <nl> - <nl> - NBTTagList aliases = new NBTTagList ( ) ; <nl> - for ( Entry < ResourceLocation , ResourceLocation > entry : e . getValue ( ) . aliases . entrySet ( ) ) <nl> - { <nl> - NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> - tag . setString ( " K " , entry . getKey ( ) . toString ( ) ) ; <nl> - tag . setString ( " V " , entry . getValue ( ) . toString ( ) ) ; <nl> - aliases . appendTag ( tag ) ; <nl> - } <nl> - data . setTag ( " aliases " , aliases ) ; <nl> - <nl> - NBTTagList overrides = new NBTTagList ( ) ; <nl> - for ( Entry < ResourceLocation , String > entry : e . getValue ( ) . overrides . entrySet ( ) ) <nl> - { <nl> - NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> - tag . setString ( " K " , entry . getKey ( ) . toString ( ) ) ; <nl> - tag . setString ( " V " , entry . getValue ( ) . toString ( ) ) ; <nl> - overrides . appendTag ( tag ) ; <nl> - } <nl> - data . setTag ( " overrides " , overrides ) ; <nl> - <nl> - int [ ] blocked = new int [ e . getValue ( ) . blocked . size ( ) ] ; <nl> - int idx = 0 ; <nl> - for ( Integer i : e . getValue ( ) . blocked ) <nl> - { <nl> - blocked [ idx + + ] = i ; <nl> - } <nl> - data . setIntArray ( " blocked " , blocked ) ; <nl> - NBTTagList dummied = new NBTTagList ( ) ; <nl> - for ( ResourceLocation entry : e . getValue ( ) . dummied ) <nl> - { <nl> - NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> - tag . setString ( " K " , entry . toString ( ) ) ; <nl> - dummied . appendTag ( tag ) ; <nl> - } <nl> - data . setTag ( " dummied " , dummied ) ; <nl> + registries . setTag ( e . getKey ( ) . toString ( ) , e . getValue ( ) . write ( ) ) ; <nl> } <nl> return fmlData ; <nl> } <nl> @ @ - 216 , 54 + 167 , 7 @ @ public final class FMLContainer extends DummyModContainer implements WorldAccess <nl> NBTTagCompound regs = tag . getCompoundTag ( " Registries " ) ; <nl> for ( String key : regs . getKeySet ( ) ) <nl> { <nl> - ForgeRegistry . Snapshot entry = new ForgeRegistry . Snapshot ( ) ; <nl> - NBTTagCompound ent = regs . getCompoundTag ( key ) ; <nl> - snapshot . put ( new ResourceLocation ( key ) , entry ) ; <nl> - <nl> - NBTTagList list = ent . getTagList ( " ids " , 10 ) ; <nl> - for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) <nl> - { <nl> - NBTTagCompound e = list . getCompoundTagAt ( x ) ; <nl> - entry . ids . put ( new ResourceLocation ( e . getString ( " K " ) ) , e . getInteger ( " V " ) ) ; <nl> - } <nl> - <nl> - list = ent . getTagList ( " aliases " , 10 ) ; <nl> - for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) <nl> - { <nl> - NBTTagCompound e = list . getCompoundTagAt ( x ) ; <nl> - String v = e . getString ( " V " ) ; <nl> - if ( v . indexOf ( ' : ' ) = = - 1 ) / / Forge Bug : https : / / github . com / MinecraftForge / MinecraftForge / issues / 4894 TODO : Remove in 1 . 13 <nl> - { <nl> - entry . overrides . put ( new ResourceLocation ( e . getString ( " K " ) ) , v ) ; <nl> - } <nl> - else <nl> - { <nl> - entry . aliases . put ( new ResourceLocation ( e . getString ( " K " ) ) , new ResourceLocation ( v ) ) ; <nl> - } <nl> - } <nl> - <nl> - list = ent . getTagList ( " overrides " , 10 ) ; <nl> - for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) <nl> - { <nl> - NBTTagCompound e = list . getCompoundTagAt ( x ) ; <nl> - entry . overrides . put ( new ResourceLocation ( e . getString ( " K " ) ) , e . getString ( " V " ) ) ; <nl> - } <nl> - <nl> - int [ ] blocked = regs . getCompoundTag ( key ) . getIntArray ( " blocked " ) ; <nl> - for ( int i : blocked ) <nl> - { <nl> - entry . blocked . add ( i ) ; <nl> - } <nl> - <nl> - if ( regs . getCompoundTag ( key ) . hasKey ( " dummied " ) ) / / Added in 1 . 8 . 9 dev , some worlds may not have it . <nl> - { <nl> - list = regs . getCompoundTag ( key ) . getTagList ( " dummied " , 10 ) ; <nl> - for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) <nl> - { <nl> - NBTTagCompound e = list . getCompoundTagAt ( x ) ; <nl> - entry . dummied . add ( new ResourceLocation ( e . getString ( " K " ) ) ) ; <nl> - } <nl> - } <nl> + snapshot . put ( new ResourceLocation ( key ) , ForgeRegistry . Snapshot . read ( regs . getCompoundTag ( key ) ) ) ; <nl> } <nl> failedElements = GameData . injectSnapshot ( snapshot , true , true ) ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> index bfb7dc3 . . 2cf7278 100644 <nl> - - - a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> @ @ - 43 , 6 + 43 , 10 @ @ import com . google . common . collect . Lists ; <nl> import com . google . common . collect . Maps ; <nl> import com . google . common . collect . Multimap ; <nl> import com . google . common . collect . Sets ; <nl> + <nl> + import net . minecraft . nbt . NBTTagCompound ; <nl> + import net . minecraft . nbt . NBTTagList ; <nl> + import net . minecraft . nbt . NBTTagString ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . event . RegistryEvent ; <nl> import net . minecraftforge . event . RegistryEvent . MissingMappings ; <nl> @ @ - 781 , 6 + 785 , 102 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> public final Set < Integer > blocked = Sets . newHashSet ( ) ; <nl> public final Set < ResourceLocation > dummied = Sets . newHashSet ( ) ; <nl> public final Map < ResourceLocation , String > overrides = Maps . newHashMap ( ) ; <nl> + <nl> + public NBTTagCompound write ( ) <nl> + { <nl> + NBTTagCompound data = new NBTTagCompound ( ) ; <nl> + <nl> + NBTTagList ids = new NBTTagList ( ) ; <nl> + this . ids . entrySet ( ) . stream ( ) . sorted ( ( o1 , o2 ) - > o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ) . forEach ( e - > <nl> + { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setString ( " K " , e . getKey ( ) . toString ( ) ) ; <nl> + tag . setInteger ( " V " , e . getValue ( ) ) ; <nl> + ids . appendTag ( tag ) ; <nl> + } ) ; <nl> + data . setTag ( " ids " , ids ) ; <nl> + <nl> + NBTTagList aliases = new NBTTagList ( ) ; <nl> + this . aliases . entrySet ( ) . stream ( ) . sorted ( ( o1 , o2 ) - > o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ) . forEach ( e - > <nl> + { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setString ( " K " , e . getKey ( ) . toString ( ) ) ; <nl> + tag . setString ( " V " , e . getKey ( ) . toString ( ) ) ; <nl> + aliases . appendTag ( tag ) ; <nl> + } ) ; <nl> + data . setTag ( " aliases " , aliases ) ; <nl> + <nl> + NBTTagList overrides = new NBTTagList ( ) ; <nl> + this . overrides . entrySet ( ) . stream ( ) . sorted ( ( o1 , o2 ) - > o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ) . forEach ( e - > <nl> + { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setString ( " K " , e . getKey ( ) . toString ( ) ) ; <nl> + tag . setString ( " V " , e . getValue ( ) ) ; <nl> + overrides . appendTag ( tag ) ; <nl> + } ) ; <nl> + data . setTag ( " overrides " , overrides ) ; <nl> + <nl> + int [ ] blocked = this . blocked . stream ( ) . mapToInt ( x - > x ) . sorted ( ) . toArray ( ) ; <nl> + data . setIntArray ( " blocked " , blocked ) ; <nl> + <nl> + NBTTagList dummied = new NBTTagList ( ) ; <nl> + this . dummied . stream ( ) . sorted ( ) . forEach ( e - > dummied . appendTag ( new NBTTagString ( e . toString ( ) ) ) ) ; <nl> + data . setTag ( " dummied " , dummied ) ; <nl> + <nl> + return data ; <nl> + } <nl> + <nl> + public static Snapshot read ( NBTTagCompound nbt ) <nl> + { <nl> + Snapshot ret = new Snapshot ( ) ; <nl> + if ( nbt = = null ) <nl> + { <nl> + return ret ; <nl> + } <nl> + <nl> + NBTTagList list = nbt . getTagList ( " ids " , 10 ) ; <nl> + list . forEach ( e - > <nl> + { <nl> + NBTTagCompound comp = ( NBTTagCompound ) e ; <nl> + ret . ids . put ( new ResourceLocation ( comp . getString ( " K " ) ) , comp . getInteger ( " V " ) ) ; <nl> + } ) ; <nl> + <nl> + list = nbt . getTagList ( " aliases " , 10 ) ; <nl> + list . forEach ( e - > <nl> + { <nl> + NBTTagCompound comp = ( NBTTagCompound ) e ; <nl> + String v = comp . getString ( " V " ) ; <nl> + if ( v . indexOf ( ' : ' ) = = - 1 ) / / Forge Bug : https : / / github . com / MinecraftForge / MinecraftForge / issues / 4894 TODO : Remove in 1 . 13 <nl> + { <nl> + ret . overrides . put ( new ResourceLocation ( comp . getString ( " K " ) ) , v ) ; <nl> + } <nl> + else <nl> + { <nl> + ret . aliases . put ( new ResourceLocation ( comp . getString ( " K " ) ) , new ResourceLocation ( v ) ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + list = nbt . getTagList ( " overrides " , 10 ) ; <nl> + list . forEach ( e - > <nl> + { <nl> + NBTTagCompound comp = ( NBTTagCompound ) e ; <nl> + ret . overrides . put ( new ResourceLocation ( comp . getString ( " K " ) ) , comp . getString ( " V " ) ) ; <nl> + } ) ; <nl> + <nl> + int [ ] blocked = nbt . getIntArray ( " blocked " ) ; <nl> + for ( int i : blocked ) <nl> + { <nl> + ret . blocked . add ( i ) ; <nl> + } <nl> + <nl> + list = nbt . getTagList ( " dummied " , 10 ) ; / / 10 - NBTTagCompound , Old format . New format is String list . For now we will just merge the old and new . TODO : Remove in 1 . 13 <nl> + list . forEach ( e - > ret . dummied . add ( new ResourceLocation ( ( ( NBTTagCompound ) e ) . getString ( " K " ) ) ) ) ; <nl> + <nl> + list = nbt . getTagList ( " dummied " , 8 ) ; / / 8 - NBTTagString , New format , less redundant / verbose <nl> + list . forEach ( e - > ret . dummied . add ( new ResourceLocation ( ( ( NBTTagString ) e ) . getString ( ) ) ) ) ; <nl> + <nl> + return ret ; <nl> + } <nl> } <nl> <nl> public MissingMappings < ? > getMissingEvent ( ResourceLocation name , Map < ResourceLocation , Integer > map )
NEAREST DIFF (one line): diff - - git a / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java <nl> new file mode 100644 <nl> index 0000000 . . 760284e <nl> - - - / dev / null <nl> + + + b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java <nl> @ @ - 0 , 0 + 1 , 357 @ @ <nl> + package cpw . mods . fml . common . asm . transformers ; <nl> + <nl> + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; <nl> + <nl> + import java . io . BufferedInputStream ; <nl> + import java . io . BufferedOutputStream ; <nl> + import java . io . BufferedReader ; <nl> + import java . io . ByteArrayOutputStream ; <nl> + import java . io . File ; <nl> + import java . io . FileInputStream ; <nl> + import java . io . FileNotFoundException ; <nl> + import java . io . FileOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStream ; <nl> + import java . io . InputStreamReader ; <nl> + import java . net . URL ; <nl> + import java . text . SimpleDateFormat ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collection ; <nl> + import java . util . Date ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + import java . util . zip . ZipEntry ; <nl> + import java . util . zip . ZipInputStream ; <nl> + import java . util . zip . ZipOutputStream ; <nl> + <nl> + import org . objectweb . asm . ClassReader ; <nl> + import org . objectweb . asm . ClassWriter ; <nl> + import org . objectweb . asm . Type ; <nl> + import org . objectweb . asm . tree . ClassNode ; <nl> + import org . objectweb . asm . tree . FieldNode ; <nl> + import org . objectweb . asm . tree . MethodNode ; <nl> + <nl> + import com . google . common . base . CharMatcher ; <nl> + import com . google . common . base . Charsets ; <nl> + import com . google . common . base . Splitter ; <nl> + import com . google . common . base . Strings ; <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> + import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Multimap ; <nl> + import com . google . common . io . LineProcessor ; <nl> + import com . google . common . io . Resources ; <nl> + <nl> + import cpw . mods . fml . relauncher . IClassTransformer ; <nl> + <nl> + public class AccessTransformer implements IClassTransformer <nl> + { <nl> + private class Modifier <nl> + { <nl> + public String name = " " ; <nl> + public String desc = " " ; <nl> + public int oldAccess = 0 ; <nl> + public int newAccess = 0 ; <nl> + public int targetAccess = 0 ; <nl> + <nl> + private void setTargetAccess ( String name ) <nl> + { <nl> + if ( name . equalsIgnoreCase ( " public " ) ) targetAccess = ACC _ PUBLIC ; <nl> + else if ( name . equalsIgnoreCase ( " private " ) ) targetAccess = ACC _ PRIVATE ; <nl> + else if ( name . equalsIgnoreCase ( " protected " ) ) targetAccess = ACC _ PROTECTED ; <nl> + } <nl> + } <nl> + <nl> + private Multimap < String , Modifier > modifiers = ArrayListMultimap . create ( ) ; <nl> + <nl> + public AccessTransformer ( ) throws IOException <nl> + { <nl> + this ( " / rules . csv " ) ; <nl> + } <nl> + protected AccessTransformer ( String rulesFile ) throws IOException <nl> + { <nl> + readMapFile ( rulesFile ) ; <nl> + } <nl> + <nl> + private void readMapFile ( String rulesFile ) throws IOException <nl> + { <nl> + URL rulesResource = Resources . getResource ( rulesFile ) ; <nl> + Resources . readLines ( rulesResource , Charsets . UTF _ 8 , new LineProcessor < Void > ( ) <nl> + { <nl> + @ Override <nl> + public Void getResult ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean processLine ( String input ) throws IOException <nl> + { <nl> + String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; <nl> + if ( line . length ( ) = = 0 ) <nl> + { <nl> + return true ; <nl> + } <nl> + List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; <nl> + if ( parts . size ( ) > 2 | | parts . get ( 1 ) . indexOf ( ' . ' ) = = - 1 ) <nl> + { <nl> + throw new RuntimeException ( " Invalid config file line " + input ) ; <nl> + } <nl> + Modifier m = new Modifier ( ) ; <nl> + m . setTargetAccess ( parts . get ( 0 ) ) ; <nl> + List < String > descriptor = Lists . newArrayList ( Splitter . on ( " . " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; <nl> + List < String > method = Lists . newArrayList ( Splitter . on ( CharMatcher . anyOf ( " ( ) " ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( descriptor . get ( 1 ) ) ) ; <nl> + if ( method . size ( ) = = 2 ) <nl> + { <nl> + m . desc = method . get ( 1 ) ; <nl> + } <nl> + m . name = method . get ( 0 ) ; <nl> + modifiers . put ( descriptor . get ( 0 ) , m ) ; <nl> + return true ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + @ Override <nl> + public byte [ ] transform ( String name , byte [ ] bytes ) <nl> + { <nl> + if ( ! modifiers . containsKey ( name ) ) { return bytes ; } <nl> + <nl> + ClassNode classNode = new ClassNode ( ) ; <nl> + ClassReader classReader = new ClassReader ( bytes ) ; <nl> + classReader . accept ( classNode , 0 ) ; <nl> + <nl> + Collection < Modifier > mods = modifiers . get ( name ) ; <nl> + for ( Modifier m : mods ) <nl> + { <nl> + if ( m . desc . isEmpty ( ) ) <nl> + { <nl> + for ( FieldNode n : ( List < FieldNode > ) classNode . fields ) <nl> + { <nl> + if ( n . name . equals ( m . name ) ) <nl> + { <nl> + n . access = getFixedAccess ( n . access , m ) ; <nl> + System . out . println ( String . format ( " Field : % s . % s % s - > % s " , name , m . name , Integer . toBinaryString ( m . oldAccess ) , <nl> + Integer . toBinaryString ( m . newAccess ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + else <nl> + { <nl> + for ( MethodNode n : ( List < MethodNode > ) classNode . methods ) <nl> + { <nl> + if ( n . name . equals ( m . name ) & & n . desc . equals ( m . desc ) ) <nl> + { <nl> + n . access = getFixedAccess ( n . access , m ) ; <nl> + System . out . println ( String . format ( " Method : % s . % s % s % s - > % s " , name , m . name , m . desc , toBinary ( m . oldAccess ) , toBinary ( m . newAccess ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; <nl> + classNode . accept ( writer ) ; <nl> + return writer . toByteArray ( ) ; <nl> + } <nl> + <nl> + private String toBinary ( int num ) <nl> + { <nl> + return String . format ( " % 16s " , Integer . toBinaryString ( num ) ) . replace ( ' ' , ' 0 ' ) ; <nl> + } <nl> + <nl> + private int getFixedAccess ( int access , Modifier target ) <nl> + { <nl> + target . oldAccess = access ; <nl> + int t = target . targetAccess ; <nl> + int ret = ( access & ~ 7 ) ; <nl> + <nl> + switch ( access & 7 ) <nl> + { <nl> + case ACC _ PRIVATE : <nl> + ret | = t ; <nl> + break ; <nl> + case 0 : / / default <nl> + ret | = ( t ! = ACC _ PRIVATE ? t : 0 / * default * / ) ; <nl> + break ; <nl> + case ACC _ PROTECTED : <nl> + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / ? t : ACC _ PROTECTED ) ; <nl> + break ; <nl> + case ACC _ PUBLIC : <nl> + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / & & t ! = ACC _ PROTECTED ? t : ACC _ PUBLIC ) ; <nl> + break ; <nl> + default : <nl> + throw new RuntimeException ( " The fuck ? " ) ; <nl> + } <nl> + target . newAccess = ret ; <nl> + return ret ; <nl> + } <nl> + <nl> + public static void main ( String [ ] args ) <nl> + { <nl> + if ( args . length < 2 ) <nl> + { <nl> + System . out . println ( " Usage : AccessTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; <nl> + return ; <nl> + } <nl> + <nl> + boolean hasTransformer = false ; <nl> + AccessTransformer [ ] trans = new AccessTransformer [ args . length - 1 ] ; <nl> + for ( int x = 1 ; x < args . length ; x + + ) <nl> + { <nl> + try <nl> + { <nl> + trans [ x - 1 ] = new AccessTransformer ( args [ x ] ) ; <nl> + hasTransformer = true ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + if ( ! hasTransformer ) <nl> + { <nl> + System . out . println ( " Culd not find a valid transformer to perform " ) ; <nl> + return ; <nl> + } <nl> + <nl> + File orig = new File ( args [ 0 ] ) ; <nl> + File temp = new File ( args [ 0 ] + " . ATBack " ) ; <nl> + if ( ! orig . exists ( ) & & ! temp . exists ( ) ) <nl> + { <nl> + System . out . println ( " Could not find target jar : " + orig ) ; <nl> + return ; <nl> + } <nl> + <nl> + if ( temp . exists ( ) ) <nl> + { <nl> + if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) <nl> + { <nl> + System . out . println ( " Could not backup existing file : " + orig ) ; <nl> + return ; <nl> + } <nl> + if ( ! temp . renameTo ( orig ) ) <nl> + { <nl> + System . out . println ( " Could not restore backup from previous run : " + temp ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + if ( ! orig . renameTo ( temp ) ) <nl> + { <nl> + System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; <nl> + return ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + processJar ( temp , orig , trans ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + private static void processJar ( File inFile , File outFile , AccessTransformer [ ] transformers ) throws IOException <nl> + { <nl> + ZipInputStream inJar = null ; <nl> + ZipOutputStream outJar = null ; <nl> + <nl> + try <nl> + { <nl> + try <nl> + { <nl> + inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; <nl> + } <nl> + <nl> + ZipEntry entry ; <nl> + while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) <nl> + { <nl> + if ( entry . isDirectory ( ) ) <nl> + { <nl> + outJar . putNextEntry ( entry ) ; <nl> + continue ; <nl> + } <nl> + <nl> + byte [ ] data = new byte [ 4096 ] ; <nl> + ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; <nl> + <nl> + int len ; <nl> + do <nl> + { <nl> + len = inJar . read ( data ) ; <nl> + if ( len > 0 ) <nl> + { <nl> + entryBuffer . write ( data , 0 , len ) ; <nl> + } <nl> + } <nl> + while ( len ! = - 1 ) ; <nl> + <nl> + byte [ ] entryData = entryBuffer . toByteArray ( ) ; <nl> + <nl> + String entryName = entry . getName ( ) ; <nl> + <nl> + if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) <nl> + { <nl> + ClassNode cls = new ClassNode ( ) ; <nl> + ClassReader rdr = new ClassReader ( entryData ) ; <nl> + rdr . accept ( cls , 0 ) ; <nl> + String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; <nl> + <nl> + for ( AccessTransformer trans : transformers ) <nl> + { <nl> + entryData = trans . transform ( name , entryData ) ; <nl> + } <nl> + } <nl> + <nl> + ZipEntry newEntry = new ZipEntry ( entryName ) ; <nl> + outJar . putNextEntry ( newEntry ) ; <nl> + outJar . write ( entryData ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + if ( outJar ! = null ) <nl> + { <nl> + try <nl> + { <nl> + outJar . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + } <nl> + } <nl> + <nl> + if ( inJar ! = null ) <nl> + { <nl> + try <nl> + { <nl> + inJar . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> \ No newline at end of file

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 index 8f09c1c . . 2d7794b 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 @ @ - 23 , 7 + 23 , 6 @ @ import java . io . File ; 
 import java . security . cert . Certificate ; 
 import java . util . Arrays ; 
 import java . util . Map ; 
 - import java . util . Map . Entry ; 
 import net . minecraft . nbt . NBTBase ; 
 import net . minecraft . nbt . NBTTagCompound ; 
 import net . minecraft . nbt . NBTTagList ; 
 @ @ - 44 , 7 + 43 , 6 @ @ import net . minecraftforge . registries . ForgeRegistry ; 
 import net . minecraftforge . registries . GameData ; 
 import net . minecraftforge . registries . RegistryManager ; 
 
 - import org . apache . logging . log4j . Level ; 
 import org . apache . logging . log4j . LogManager ; 
 
 import com . google . common . collect . Maps ; 
 @ @ - 127 , 54 + 125 , 7 @ @ public final class FMLContainer extends DummyModContainer implements WorldAccess 
 
 for ( Map . Entry < ResourceLocation , ForgeRegistry . Snapshot > e : RegistryManager . ACTIVE . takeSnapshot ( true ) . entrySet ( ) ) 
 { 
 - NBTTagCompound data = new NBTTagCompound ( ) ; 
 - registries . setTag ( e . getKey ( ) . toString ( ) , data ) ; 
 - 
 - NBTTagList ids = new NBTTagList ( ) ; 
 - for ( Entry < ResourceLocation , Integer > item : e . getValue ( ) . ids . entrySet ( ) ) 
 - { 
 - NBTTagCompound tag = new NBTTagCompound ( ) ; 
 - tag . setString ( " K " , item . getKey ( ) . toString ( ) ) ; 
 - tag . setInteger ( " V " , item . getValue ( ) ) ; 
 - ids . appendTag ( tag ) ; 
 - } 
 - data . setTag ( " ids " , ids ) ; 
 - 
 - NBTTagList aliases = new NBTTagList ( ) ; 
 - for ( Entry < ResourceLocation , ResourceLocation > entry : e . getValue ( ) . aliases . entrySet ( ) ) 
 - { 
 - NBTTagCompound tag = new NBTTagCompound ( ) ; 
 - tag . setString ( " K " , entry . getKey ( ) . toString ( ) ) ; 
 - tag . setString ( " V " , entry . getValue ( ) . toString ( ) ) ; 
 - aliases . appendTag ( tag ) ; 
 - } 
 - data . setTag ( " aliases " , aliases ) ; 
 - 
 - NBTTagList overrides = new NBTTagList ( ) ; 
 - for ( Entry < ResourceLocation , String > entry : e . getValue ( ) . overrides . entrySet ( ) ) 
 - { 
 - NBTTagCompound tag = new NBTTagCompound ( ) ; 
 - tag . setString ( " K " , entry . getKey ( ) . toString ( ) ) ; 
 - tag . setString ( " V " , entry . getValue ( ) . toString ( ) ) ; 
 - overrides . appendTag ( tag ) ; 
 - } 
 - data . setTag ( " overrides " , overrides ) ; 
 - 
 - int [ ] blocked = new int [ e . getValue ( ) . blocked . size ( ) ] ; 
 - int idx = 0 ; 
 - for ( Integer i : e . getValue ( ) . blocked ) 
 - { 
 - blocked [ idx + + ] = i ; 
 - } 
 - data . setIntArray ( " blocked " , blocked ) ; 
 - NBTTagList dummied = new NBTTagList ( ) ; 
 - for ( ResourceLocation entry : e . getValue ( ) . dummied ) 
 - { 
 - NBTTagCompound tag = new NBTTagCompound ( ) ; 
 - tag . setString ( " K " , entry . toString ( ) ) ; 
 - dummied . appendTag ( tag ) ; 
 - } 
 - data . setTag ( " dummied " , dummied ) ; 
 + registries . setTag ( e . getKey ( ) . toString ( ) , e . getValue ( ) . write ( ) ) ; 
 } 
 return fmlData ; 
 } 
 @ @ - 216 , 54 + 167 , 7 @ @ public final class FMLContainer extends DummyModContainer implements WorldAccess 
 NBTTagCompound regs = tag . getCompoundTag ( " Registries " ) ; 
 for ( String key : regs . getKeySet ( ) ) 
 { 
 - ForgeRegistry . Snapshot entry = new ForgeRegistry . Snapshot ( ) ; 
 - NBTTagCompound ent = regs . getCompoundTag ( key ) ; 
 - snapshot . put ( new ResourceLocation ( key ) , entry ) ; 
 - 
 - NBTTagList list = ent . getTagList ( " ids " , 10 ) ; 
 - for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) 
 - { 
 - NBTTagCompound e = list . getCompoundTagAt ( x ) ; 
 - entry . ids . put ( new ResourceLocation ( e . getString ( " K " ) ) , e . getInteger ( " V " ) ) ; 
 - } 
 - 
 - list = ent . getTagList ( " aliases " , 10 ) ; 
 - for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) 
 - { 
 - NBTTagCompound e = list . getCompoundTagAt ( x ) ; 
 - String v = e . getString ( " V " ) ; 
 - if ( v . indexOf ( ' : ' ) = = - 1 ) / / Forge Bug : https : / / github . com / MinecraftForge / MinecraftForge / issues / 4894 TODO : Remove in 1 . 13 
 - { 
 - entry . overrides . put ( new ResourceLocation ( e . getString ( " K " ) ) , v ) ; 
 - } 
 - else 
 - { 
 - entry . aliases . put ( new ResourceLocation ( e . getString ( " K " ) ) , new ResourceLocation ( v ) ) ; 
 - } 
 - } 
 - 
 - list = ent . getTagList ( " overrides " , 10 ) ; 
 - for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) 
 - { 
 - NBTTagCompound e = list . getCompoundTagAt ( x ) ; 
 - entry . overrides . put ( new ResourceLocation ( e . getString ( " K " ) ) , e . getString ( " V " ) ) ; 
 - } 
 - 
 - int [ ] blocked = regs . getCompoundTag ( key ) . getIntArray ( " blocked " ) ; 
 - for ( int i : blocked ) 
 - { 
 - entry . blocked . add ( i ) ; 
 - } 
 - 
 - if ( regs . getCompoundTag ( key ) . hasKey ( " dummied " ) ) / / Added in 1 . 8 . 9 dev , some worlds may not have it . 
 - { 
 - list = regs . getCompoundTag ( key ) . getTagList ( " dummied " , 10 ) ; 
 - for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) 
 - { 
 - NBTTagCompound e = list . getCompoundTagAt ( x ) ; 
 - entry . dummied . add ( new ResourceLocation ( e . getString ( " K " ) ) ) ; 
 - } 
 - } 
 + snapshot . put ( new ResourceLocation ( key ) , ForgeRegistry . Snapshot . read ( regs . getCompoundTag ( key ) ) ) ; 
 } 
 failedElements = GameData . injectSnapshot ( snapshot , true , true ) ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 index bfb7dc3 . . 2cf7278 100644 
 - - - a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 + + + b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 @ @ - 43 , 6 + 43 , 10 @ @ import com . google . common . collect . Lists ; 
 import com . google . common . collect . Maps ; 
 import com . google . common . collect . Multimap ; 
 import com . google . common . collect . Sets ; 
 + 
 + import net . minecraft . nbt . NBTTagCompound ; 
 + import net . minecraft . nbt . NBTTagList ; 
 + import net . minecraft . nbt . NBTTagString ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . event . RegistryEvent ; 
 import net . minecraftforge . event . RegistryEvent . MissingMappings ; 
 @ @ - 781 , 6 + 785 , 102 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 public final Set < Integer > blocked = Sets . newHashSet ( ) ; 
 public final Set < ResourceLocation > dummied = Sets . newHashSet ( ) ; 
 public final Map < ResourceLocation , String > overrides = Maps . newHashMap ( ) ; 
 + 
 + public NBTTagCompound write ( ) 
 + { 
 + NBTTagCompound data = new NBTTagCompound ( ) ; 
 + 
 + NBTTagList ids = new NBTTagList ( ) ; 
 + this . ids . entrySet ( ) . stream ( ) . sorted ( ( o1 , o2 ) - > o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ) . forEach ( e - > 
 + { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setString ( " K " , e . getKey ( ) . toString ( ) ) ; 
 + tag . setInteger ( " V " , e . getValue ( ) ) ; 
 + ids . appendTag ( tag ) ; 
 + } ) ; 
 + data . setTag ( " ids " , ids ) ; 
 + 
 + NBTTagList aliases = new NBTTagList ( ) ; 
 + this . aliases . entrySet ( ) . stream ( ) . sorted ( ( o1 , o2 ) - > o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ) . forEach ( e - > 
 + { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setString ( " K " , e . getKey ( ) . toString ( ) ) ; 
 + tag . setString ( " V " , e . getKey ( ) . toString ( ) ) ; 
 + aliases . appendTag ( tag ) ; 
 + } ) ; 
 + data . setTag ( " aliases " , aliases ) ; 
 + 
 + NBTTagList overrides = new NBTTagList ( ) ; 
 + this . overrides . entrySet ( ) . stream ( ) . sorted ( ( o1 , o2 ) - > o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ) . forEach ( e - > 
 + { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setString ( " K " , e . getKey ( ) . toString ( ) ) ; 
 + tag . setString ( " V " , e . getValue ( ) ) ; 
 + overrides . appendTag ( tag ) ; 
 + } ) ; 
 + data . setTag ( " overrides " , overrides ) ; 
 + 
 + int [ ] blocked = this . blocked . stream ( ) . mapToInt ( x - > x ) . sorted ( ) . toArray ( ) ; 
 + data . setIntArray ( " blocked " , blocked ) ; 
 + 
 + NBTTagList dummied = new NBTTagList ( ) ; 
 + this . dummied . stream ( ) . sorted ( ) . forEach ( e - > dummied . appendTag ( new NBTTagString ( e . toString ( ) ) ) ) ; 
 + data . setTag ( " dummied " , dummied ) ; 
 + 
 + return data ; 
 + } 
 + 
 + public static Snapshot read ( NBTTagCompound nbt ) 
 + { 
 + Snapshot ret = new Snapshot ( ) ; 
 + if ( nbt = = null ) 
 + { 
 + return ret ; 
 + } 
 + 
 + NBTTagList list = nbt . getTagList ( " ids " , 10 ) ; 
 + list . forEach ( e - > 
 + { 
 + NBTTagCompound comp = ( NBTTagCompound ) e ; 
 + ret . ids . put ( new ResourceLocation ( comp . getString ( " K " ) ) , comp . getInteger ( " V " ) ) ; 
 + } ) ; 
 + 
 + list = nbt . getTagList ( " aliases " , 10 ) ; 
 + list . forEach ( e - > 
 + { 
 + NBTTagCompound comp = ( NBTTagCompound ) e ; 
 + String v = comp . getString ( " V " ) ; 
 + if ( v . indexOf ( ' : ' ) = = - 1 ) / / Forge Bug : https : / / github . com / MinecraftForge / MinecraftForge / issues / 4894 TODO : Remove in 1 . 13 
 + { 
 + ret . overrides . put ( new ResourceLocation ( comp . getString ( " K " ) ) , v ) ; 
 + } 
 + else 
 + { 
 + ret . aliases . put ( new ResourceLocation ( comp . getString ( " K " ) ) , new ResourceLocation ( v ) ) ; 
 + } 
 + } ) ; 
 + 
 + list = nbt . getTagList ( " overrides " , 10 ) ; 
 + list . forEach ( e - > 
 + { 
 + NBTTagCompound comp = ( NBTTagCompound ) e ; 
 + ret . overrides . put ( new ResourceLocation ( comp . getString ( " K " ) ) , comp . getString ( " V " ) ) ; 
 + } ) ; 
 + 
 + int [ ] blocked = nbt . getIntArray ( " blocked " ) ; 
 + for ( int i : blocked ) 
 + { 
 + ret . blocked . add ( i ) ; 
 + } 
 + 
 + list = nbt . getTagList ( " dummied " , 10 ) ; / / 10 - NBTTagCompound , Old format . New format is String list . For now we will just merge the old and new . TODO : Remove in 1 . 13 
 + list . forEach ( e - > ret . dummied . add ( new ResourceLocation ( ( ( NBTTagCompound ) e ) . getString ( " K " ) ) ) ) ; 
 + 
 + list = nbt . getTagList ( " dummied " , 8 ) ; / / 8 - NBTTagString , New format , less redundant / verbose 
 + list . forEach ( e - > ret . dummied . add ( new ResourceLocation ( ( ( NBTTagString ) e ) . getString ( ) ) ) ) ; 
 + 
 + return ret ; 
 + } 
 } 
 
 public MissingMappings < ? > getMissingEvent ( ResourceLocation name , Map < ResourceLocation , Integer > map )

NEAREST DIFF:
diff - - git a / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java 
 new file mode 100644 
 index 0000000 . . 760284e 
 - - - / dev / null 
 + + + b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java 
 @ @ - 0 , 0 + 1 , 357 @ @ 
 + package cpw . mods . fml . common . asm . transformers ; 
 + 
 + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; 
 + 
 + import java . io . BufferedInputStream ; 
 + import java . io . BufferedOutputStream ; 
 + import java . io . BufferedReader ; 
 + import java . io . ByteArrayOutputStream ; 
 + import java . io . File ; 
 + import java . io . FileInputStream ; 
 + import java . io . FileNotFoundException ; 
 + import java . io . FileOutputStream ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . io . InputStreamReader ; 
 + import java . net . URL ; 
 + import java . text . SimpleDateFormat ; 
 + import java . util . ArrayList ; 
 + import java . util . Collection ; 
 + import java . util . Date ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + import java . util . zip . ZipEntry ; 
 + import java . util . zip . ZipInputStream ; 
 + import java . util . zip . ZipOutputStream ; 
 + 
 + import org . objectweb . asm . ClassReader ; 
 + import org . objectweb . asm . ClassWriter ; 
 + import org . objectweb . asm . Type ; 
 + import org . objectweb . asm . tree . ClassNode ; 
 + import org . objectweb . asm . tree . FieldNode ; 
 + import org . objectweb . asm . tree . MethodNode ; 
 + 
 + import com . google . common . base . CharMatcher ; 
 + import com . google . common . base . Charsets ; 
 + import com . google . common . base . Splitter ; 
 + import com . google . common . base . Strings ; 
 + import com . google . common . collect . ArrayListMultimap ; 
 + import com . google . common . collect . Iterables ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Multimap ; 
 + import com . google . common . io . LineProcessor ; 
 + import com . google . common . io . Resources ; 
 + 
 + import cpw . mods . fml . relauncher . IClassTransformer ; 
 + 
 + public class AccessTransformer implements IClassTransformer 
 + { 
 + private class Modifier 
 + { 
 + public String name = " " ; 
 + public String desc = " " ; 
 + public int oldAccess = 0 ; 
 + public int newAccess = 0 ; 
 + public int targetAccess = 0 ; 
 + 
 + private void setTargetAccess ( String name ) 
 + { 
 + if ( name . equalsIgnoreCase ( " public " ) ) targetAccess = ACC _ PUBLIC ; 
 + else if ( name . equalsIgnoreCase ( " private " ) ) targetAccess = ACC _ PRIVATE ; 
 + else if ( name . equalsIgnoreCase ( " protected " ) ) targetAccess = ACC _ PROTECTED ; 
 + } 
 + } 
 + 
 + private Multimap < String , Modifier > modifiers = ArrayListMultimap . create ( ) ; 
 + 
 + public AccessTransformer ( ) throws IOException 
 + { 
 + this ( " / rules . csv " ) ; 
 + } 
 + protected AccessTransformer ( String rulesFile ) throws IOException 
 + { 
 + readMapFile ( rulesFile ) ; 
 + } 
 + 
 + private void readMapFile ( String rulesFile ) throws IOException 
 + { 
 + URL rulesResource = Resources . getResource ( rulesFile ) ; 
 + Resources . readLines ( rulesResource , Charsets . UTF _ 8 , new LineProcessor < Void > ( ) 
 + { 
 + @ Override 
 + public Void getResult ( ) 
 + { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public boolean processLine ( String input ) throws IOException 
 + { 
 + String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; 
 + if ( line . length ( ) = = 0 ) 
 + { 
 + return true ; 
 + } 
 + List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; 
 + if ( parts . size ( ) > 2 | | parts . get ( 1 ) . indexOf ( ' . ' ) = = - 1 ) 
 + { 
 + throw new RuntimeException ( " Invalid config file line " + input ) ; 
 + } 
 + Modifier m = new Modifier ( ) ; 
 + m . setTargetAccess ( parts . get ( 0 ) ) ; 
 + List < String > descriptor = Lists . newArrayList ( Splitter . on ( " . " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; 
 + List < String > method = Lists . newArrayList ( Splitter . on ( CharMatcher . anyOf ( " ( ) " ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( descriptor . get ( 1 ) ) ) ; 
 + if ( method . size ( ) = = 2 ) 
 + { 
 + m . desc = method . get ( 1 ) ; 
 + } 
 + m . name = method . get ( 0 ) ; 
 + modifiers . put ( descriptor . get ( 0 ) , m ) ; 
 + return true ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + @ Override 
 + public byte [ ] transform ( String name , byte [ ] bytes ) 
 + { 
 + if ( ! modifiers . containsKey ( name ) ) { return bytes ; } 
 + 
 + ClassNode classNode = new ClassNode ( ) ; 
 + ClassReader classReader = new ClassReader ( bytes ) ; 
 + classReader . accept ( classNode , 0 ) ; 
 + 
 + Collection < Modifier > mods = modifiers . get ( name ) ; 
 + for ( Modifier m : mods ) 
 + { 
 + if ( m . desc . isEmpty ( ) ) 
 + { 
 + for ( FieldNode n : ( List < FieldNode > ) classNode . fields ) 
 + { 
 + if ( n . name . equals ( m . name ) ) 
 + { 
 + n . access = getFixedAccess ( n . access , m ) ; 
 + System . out . println ( String . format ( " Field : % s . % s % s - > % s " , name , m . name , Integer . toBinaryString ( m . oldAccess ) , 
 + Integer . toBinaryString ( m . newAccess ) ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + else 
 + { 
 + for ( MethodNode n : ( List < MethodNode > ) classNode . methods ) 
 + { 
 + if ( n . name . equals ( m . name ) & & n . desc . equals ( m . desc ) ) 
 + { 
 + n . access = getFixedAccess ( n . access , m ) ; 
 + System . out . println ( String . format ( " Method : % s . % s % s % s - > % s " , name , m . name , m . desc , toBinary ( m . oldAccess ) , toBinary ( m . newAccess ) ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; 
 + classNode . accept ( writer ) ; 
 + return writer . toByteArray ( ) ; 
 + } 
 + 
 + private String toBinary ( int num ) 
 + { 
 + return String . format ( " % 16s " , Integer . toBinaryString ( num ) ) . replace ( ' ' , ' 0 ' ) ; 
 + } 
 + 
 + private int getFixedAccess ( int access , Modifier target ) 
 + { 
 + target . oldAccess = access ; 
 + int t = target . targetAccess ; 
 + int ret = ( access & ~ 7 ) ; 
 + 
 + switch ( access & 7 ) 
 + { 
 + case ACC _ PRIVATE : 
 + ret | = t ; 
 + break ; 
 + case 0 : / / default 
 + ret | = ( t ! = ACC _ PRIVATE ? t : 0 / * default * / ) ; 
 + break ; 
 + case ACC _ PROTECTED : 
 + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / ? t : ACC _ PROTECTED ) ; 
 + break ; 
 + case ACC _ PUBLIC : 
 + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / & & t ! = ACC _ PROTECTED ? t : ACC _ PUBLIC ) ; 
 + break ; 
 + default : 
 + throw new RuntimeException ( " The fuck ? " ) ; 
 + } 
 + target . newAccess = ret ; 
 + return ret ; 
 + } 
 + 
 + public static void main ( String [ ] args ) 
 + { 
 + if ( args . length < 2 ) 
 + { 
 + System . out . println ( " Usage : AccessTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; 
 + return ; 
 + } 
 + 
 + boolean hasTransformer = false ; 
 + AccessTransformer [ ] trans = new AccessTransformer [ args . length - 1 ] ; 
 + for ( int x = 1 ; x < args . length ; x + + ) 
 + { 
 + try 
 + { 
 + trans [ x - 1 ] = new AccessTransformer ( args [ x ] ) ; 
 + hasTransformer = true ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + if ( ! hasTransformer ) 
 + { 
 + System . out . println ( " Culd not find a valid transformer to perform " ) ; 
 + return ; 
 + } 
 + 
 + File orig = new File ( args [ 0 ] ) ; 
 + File temp = new File ( args [ 0 ] + " . ATBack " ) ; 
 + if ( ! orig . exists ( ) & & ! temp . exists ( ) ) 
 + { 
 + System . out . println ( " Could not find target jar : " + orig ) ; 
 + return ; 
 + } 
 + 
 + if ( temp . exists ( ) ) 
 + { 
 + if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) 
 + { 
 + System . out . println ( " Could not backup existing file : " + orig ) ; 
 + return ; 
 + } 
 + if ( ! temp . renameTo ( orig ) ) 
 + { 
 + System . out . println ( " Could not restore backup from previous run : " + temp ) ; 
 + return ; 
 + } 
 + } 
 + 
 + if ( ! orig . renameTo ( temp ) ) 
 + { 
 + System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; 
 + return ; 
 + } 
 + 
 + try 
 + { 
 + processJar ( temp , orig , trans ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + private static void processJar ( File inFile , File outFile , AccessTransformer [ ] transformers ) throws IOException 
 + { 
 + ZipInputStream inJar = null ; 
 + ZipOutputStream outJar = null ; 
 + 
 + try 
 + { 
 + try 
 + { 
 + inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; 
 + } 
 + 
 + try 
 + { 
 + outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; 
 + } 
 + 
 + ZipEntry entry ; 
 + while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) 
 + { 
 + if ( entry . isDirectory ( ) ) 
 + { 
 + outJar . putNextEntry ( entry ) ; 
 + continue ; 
 + } 
 + 
 + byte [ ] data = new byte [ 4096 ] ; 
 + ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; 
 + 
 + int len ; 
 + do 
 + { 
 + len = inJar . read ( data ) ; 
 + if ( len > 0 ) 
 + { 
 + entryBuffer . write ( data , 0 , len ) ; 
 + } 
 + } 
 + while ( len ! = - 1 ) ; 
 + 
 + byte [ ] entryData = entryBuffer . toByteArray ( ) ; 
 + 
 + String entryName = entry . getName ( ) ; 
 + 
 + if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) 
 + { 
 + ClassNode cls = new ClassNode ( ) ; 
 + ClassReader rdr = new ClassReader ( entryData ) ; 
 + rdr . accept ( cls , 0 ) ; 
 + String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; 
 + 
 + for ( AccessTransformer trans : transformers ) 
 + { 
 + entryData = trans . transform ( name , entryData ) ; 
 + } 
 + } 
 + 
 + ZipEntry newEntry = new ZipEntry ( entryName ) ; 
 + outJar . putNextEntry ( newEntry ) ; 
 + outJar . write ( entryData ) ; 
 + } 
 + } 
 + finally 
 + { 
 + if ( outJar ! = null ) 
 + { 
 + try 
 + { 
 + outJar . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + } 
 + } 
 + 
 + if ( inJar ! = null ) 
 + { 
 + try 
 + { 
 + inJar . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + } 
 + } 
 + } 
 + } 
 + } 
 \ No newline at end of file
