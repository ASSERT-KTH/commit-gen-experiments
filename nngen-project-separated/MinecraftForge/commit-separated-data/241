BLEU SCORE: 0.023901021968803133

TEST MSG: Potentially fix issue with BungeeCord or other servers resetting the registry mappings on the client while the game is running .
GENERATED MSG: Add a FML outbound target for all players tracking a point or entity in the world . Closes # 3677

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> index e38f820 . . 3e697a3 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> @ @ - 22 , 13 + 22 , 14 @ @ package net . minecraftforge . fml . common . network . handshake ; <nl> import io . netty . channel . ChannelFutureListener ; <nl> import io . netty . channel . ChannelHandlerContext ; <nl> <nl> - import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . function . Consumer ; <nl> <nl> import com . google . common . collect . Maps ; <nl> import com . google . common . collect . Multimap ; <nl> + import com . google . common . util . concurrent . Futures ; <nl> <nl> + import net . minecraft . client . Minecraft ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> import net . minecraftforge . fml . common . Loader ; <nl> @ @ - 128 , 7 + 129 , 7 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> WAITINGSERVERCOMPLETE <nl> { <nl> @ Override <nl> - public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> + public void accept ( final ChannelHandlerContext ctx , final FMLHandshakeMessage msg , final Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> FMLHandshakeMessage . RegistryData pkt = ( FMLHandshakeMessage . RegistryData ) msg ; <nl> Map < ResourceLocation , ForgeRegistry . Snapshot > snap = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . get ( ) ; <nl> @ @ - 153 , 18 + 154 , 23 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> <nl> ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . set ( null ) ; <nl> <nl> - Multimap < ResourceLocation , ResourceLocation > locallyMissing = GameData . injectSnapshot ( snap , false , false ) ; <nl> - if ( ! locallyMissing . isEmpty ( ) ) <nl> + / / Do the remapping on the Client ' s thread in case things are reset while the client is running . We stall the network thread until this is finished which can cause the IO thread to time out . . . Not sure if we can do anything about that . <nl> + final Map < ResourceLocation , ForgeRegistry . Snapshot > snap _ f = snap ; <nl> + Futures . getUnchecked ( Minecraft . getMinecraft ( ) . addScheduledTask ( ( ) - > <nl> { <nl> - cons . accept ( ERROR ) ; <nl> - NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> - dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; <nl> - FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; <nl> - locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; <nl> - return ; <nl> - } <nl> - cons . accept ( PENDINGCOMPLETE ) ; <nl> - ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + Multimap < ResourceLocation , ResourceLocation > locallyMissing = GameData . injectSnapshot ( snap _ f , false , false ) ; <nl> + if ( ! locallyMissing . isEmpty ( ) ) <nl> + { <nl> + cons . accept ( ERROR ) ; <nl> + NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> + dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; <nl> + FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; <nl> + locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; <nl> + return ; <nl> + } <nl> + cons . accept ( PENDINGCOMPLETE ) ; <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } ) ) ; <nl> } <nl> } , <nl> PENDINGCOMPLETE <nl> @ @ - 197 , 7 + 203 , 8 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> if ( msg instanceof FMLHandshakeMessage . HandshakeReset ) <nl> { <nl> cons . accept ( HELLO ) ; <nl> - GameData . revertToFrozen ( ) ; <nl> + / / Run the revert on the client thread in case things are currently running to prevent race conditions while rebuilding the registries . <nl> + Minecraft . getMinecraft ( ) . addScheduledTask ( GameData : : revertToFrozen ) ; <nl> } <nl> } <nl> } ,
NEAREST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch b / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch <nl> index b4a9796 . . 7868457 100644 <nl> - - - a / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch <nl> + + + b / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch <nl> @ @ - 150 , 3 + 150 , 13 @ @ <nl> { <nl> this . func _ 187273 _ a ( this . field _ 187282 _ b . func _ 72688 _ a ( ) . func _ 175625 _ s ( blockpos1 ) ) ; <nl> } <nl> + @ @ - 311 , 4 + 348 , 9 @ @ <nl> + <nl> + return d0 ; <nl> + } <nl> + + <nl> + + public List < EntityPlayerMP > getWatchingPlayers ( ) <nl> + + { <nl> + + return func _ 187274 _ e ( ) ? java . util . Collections . unmodifiableList ( field _ 187283 _ c ) : java . util . Collections . emptyList ( ) ; <nl> + + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java b / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java <nl> index cf75d2f . . bb87206 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import io . netty . channel . ChannelHandlerContext ; <nl> import java . util . EnumMap ; <nl> <nl> import net . minecraft . client . network . NetHandlerPlayClient ; <nl> + import net . minecraft . entity . Entity ; <nl> import net . minecraft . entity . player . EntityPlayerMP ; <nl> import net . minecraft . network . NetHandlerPlayServer ; <nl> import net . minecraftforge . fml . common . FMLCommonHandler ; <nl> @ @ - 178 , 6 + 179 , 33 @ @ public class FMLEventChannel { <nl> } <nl> <nl> / * * <nl> + * Send to all tracking the point <nl> + * The { @ code range } field of the { @ link NetworkRegistry . TargetPoint } is ignored . <nl> + * @ param pkt <nl> + * @ param point <nl> + * / <nl> + public void sendToAllTracking ( FMLProxyPacket pkt , NetworkRegistry . TargetPoint point ) <nl> + { <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ POINT ) ; <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( point ) ; <nl> + channels . get ( Side . SERVER ) . writeAndFlush ( pkt ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Send to all tracking the entity <nl> + * This is not equivalent to { @ link # sendToAllTracking ( FMLProxyPacket , NetworkRegistry . TargetPoint ) } <nl> + * because entities have different tracking distances based on their type . <nl> + * @ param pkt <nl> + * @ param entity <nl> + * / <nl> + public void sendToAllTracking ( FMLProxyPacket pkt , Entity entity ) <nl> + { <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ ENTITY ) ; <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( entity ) ; <nl> + channels . get ( Side . SERVER ) . writeAndFlush ( pkt ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } <nl> + <nl> + / * * <nl> * Send to all in a dimension <nl> * @ param pkt <nl> * @ param dimensionId <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java b / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java <nl> index a84b9ef . . 9d1f144 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java <nl> @ @ - 26 , 9 + 26 , 17 @ @ import io . netty . channel . embedded . EmbeddedChannel ; <nl> import io . netty . util . AttributeKey ; <nl> <nl> import java . util . List ; <nl> + import java . util . Set ; <nl> <nl> + import net . minecraft . entity . Entity ; <nl> + import net . minecraft . entity . player . EntityPlayer ; <nl> import net . minecraft . entity . player . EntityPlayerMP ; <nl> import net . minecraft . network . NetworkManager ; <nl> + import net . minecraft . server . management . PlayerChunkMap ; <nl> + import net . minecraft . server . management . PlayerChunkMapEntry ; <nl> + import net . minecraft . util . math . MathHelper ; <nl> + import net . minecraft . world . WorldServer ; <nl> + import net . minecraftforge . common . DimensionManager ; <nl> import net . minecraftforge . common . util . FakePlayer ; <nl> import net . minecraftforge . fml . common . FMLCommonHandler ; <nl> import net . minecraftforge . fml . common . network . NetworkRegistry . TargetPoint ; <nl> @ @ - 232 , 6 + 240 , 79 @ @ public class FMLOutboundHandler extends ChannelOutboundHandlerAdapter { <nl> } <nl> } , <nl> / * * <nl> + * The packet is sent to all players that are watching the Chunk containing the supplied { @ link TargetPoint } . <nl> + * The { @ code range } field of the { @ link TargetPoint } is ignored . <nl> + * / <nl> + TRACKING _ POINT ( Sets . immutableEnumSet ( Side . SERVER ) ) <nl> + { <nl> + @ Override <nl> + public void validateArgs ( Object args ) <nl> + { <nl> + if ( ! ( args instanceof TargetPoint ) ) <nl> + { <nl> + throw new RuntimeException ( " TRACKING _ POINT expects a TargetPoint argument " ) ; <nl> + } <nl> + } <nl> + <nl> + @ Nullable <nl> + @ Override <nl> + public List < NetworkDispatcher > selectNetworks ( Object args , ChannelHandlerContext context , FMLProxyPacket packet ) <nl> + { <nl> + TargetPoint tp = ( TargetPoint ) args ; <nl> + WorldServer world = DimensionManager . getWorld ( tp . dimension ) ; <nl> + if ( world = = null ) <nl> + { <nl> + return ImmutableList . of ( ) ; <nl> + } <nl> + <nl> + PlayerChunkMapEntry entry = world . getPlayerChunkMap ( ) . getEntry ( MathHelper . floor ( tp . x ) > > 4 , MathHelper . floor ( tp . z ) > > 4 ) ; <nl> + if ( entry = = null ) <nl> + { <nl> + return ImmutableList . of ( ) ; <nl> + } <nl> + <nl> + ImmutableList . Builder < NetworkDispatcher > builder = ImmutableList . builder ( ) ; <nl> + for ( EntityPlayerMP player : entry . getWatchingPlayers ( ) ) <nl> + { <nl> + NetworkDispatcher dispatcher = player . connection . netManager . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> + if ( dispatcher ! = null ) builder . add ( dispatcher ) ; <nl> + } <nl> + return builder . build ( ) ; <nl> + } <nl> + } , <nl> + / * * <nl> + * The packet is sent to all players tracking the supplied { @ link Entity } . This is different from { @ link # TRACKING _ POINT } because Entities <nl> + * can have different tracking distances depending on their type . <nl> + * / <nl> + TRACKING _ ENTITY ( Sets . immutableEnumSet ( Side . SERVER ) ) <nl> + { <nl> + @ Override <nl> + public void validateArgs ( Object args ) <nl> + { <nl> + if ( ! ( args instanceof Entity ) ) <nl> + { <nl> + throw new RuntimeException ( " TRACKING _ ENTITY expects an Entity argument " ) ; <nl> + } <nl> + } <nl> + <nl> + @ Nullable <nl> + @ Override <nl> + public List < NetworkDispatcher > selectNetworks ( Object args , ChannelHandlerContext context , FMLProxyPacket packet ) <nl> + { <nl> + Entity e = ( Entity ) args ; <nl> + Set < ? extends EntityPlayer > players = FMLCommonHandler . instance ( ) . getMinecraftServerInstance ( ) <nl> + . getWorld ( e . dimension ) . getEntityTracker ( ) . getTrackingPlayers ( e ) ; <nl> + <nl> + ImmutableList . Builder < NetworkDispatcher > builder = ImmutableList . builder ( ) ; <nl> + for ( EntityPlayer player : players ) <nl> + { <nl> + NetworkDispatcher dispatcher = ( ( EntityPlayerMP ) player ) . connection . netManager . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> + if ( dispatcher ! = null ) builder . add ( dispatcher ) ; <nl> + } <nl> + return builder . build ( ) ; <nl> + } <nl> + } , <nl> + / * * <nl> * The packet is sent to the server this client is currently conversing with . <nl> * @ author cpw <nl> * <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> index b4cda09 . . 9f1a5d9 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import io . netty . channel . ChannelFutureListener ; <nl> import java . lang . reflect . Method ; <nl> import java . util . EnumMap ; <nl> <nl> + import net . minecraft . entity . Entity ; <nl> import net . minecraft . util . IThreadListener ; <nl> <nl> import io . netty . channel . ChannelHandler ; <nl> @ @ - 264 , 6 + 265 , 37 @ @ public class SimpleNetworkWrapper { <nl> } <nl> <nl> / * * <nl> + * Sends this message to everyone tracking a point . <nl> + * The { @ link IMessageHandler } for this message type should be on the CLIENT side . <nl> + * The { @ code range } field of the { @ link TargetPoint } is ignored . <nl> + * <nl> + * @ param message The message to send <nl> + * @ param point The tracked { @ link TargetPoint } around which to send <nl> + * / <nl> + public void sendToAllTracking ( IMessage message , NetworkRegistry . TargetPoint point ) <nl> + { <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ POINT ) ; <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( point ) ; <nl> + channels . get ( Side . SERVER ) . writeAndFlush ( message ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Sends this message to everyone tracking an entity . <nl> + * The { @ link IMessageHandler } for this message type should be on the CLIENT side . <nl> + * This is not equivalent to { @ link # sendToAllTracking ( IMessage , TargetPoint ) } <nl> + * because entities have different tracking distances based on their type . <nl> + * <nl> + * @ param message The message to send <nl> + * @ param entity The tracked entity around which to send <nl> + * / <nl> + public void sendToAllTracking ( IMessage message , Entity entity ) <nl> + { <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ ENTITY ) ; <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( entity ) ; <nl> + channels . get ( Side . SERVER ) . writeAndFlush ( message ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } <nl> + <nl> + / * * <nl> * Send this message to everyone within the supplied dimension . <nl> * The { @ link IMessageHandler } for this message type should be on the CLIENT side . <nl> * <nl> diff - - git a / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java b / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java <nl> new file mode 100644 <nl> index 0000000 . . f121ce5 <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java <nl> @ @ - 0 , 0 + 1 , 122 @ @ <nl> + package net . minecraftforge . debug ; <nl> + <nl> + import io . netty . buffer . ByteBuf ; <nl> + import net . minecraft . entity . item . EntityItemFrame ; <nl> + import net . minecraft . init . Items ; <nl> + import net . minecraftforge . event . entity . EntityJoinWorldEvent ; <nl> + import net . minecraftforge . fml . common . Mod ; <nl> + import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> + import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; <nl> + import net . minecraftforge . fml . common . gameevent . TickEvent ; <nl> + import net . minecraftforge . fml . common . network . NetworkRegistry ; <nl> + import net . minecraftforge . fml . common . network . simpleimpl . IMessage ; <nl> + import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; <nl> + import net . minecraftforge . fml . common . network . simpleimpl . MessageContext ; <nl> + import net . minecraftforge . fml . common . network . simpleimpl . SimpleNetworkWrapper ; <nl> + import net . minecraftforge . fml . relauncher . Side ; <nl> + import org . apache . logging . log4j . LogManager ; <nl> + import org . apache . logging . log4j . Logger ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . Set ; <nl> + import java . util . WeakHashMap ; <nl> + <nl> + @ Mod ( modid = TrackingTargetTest . ID , name = " Tracking Target Test " , acceptableRemoteVersions = " * " ) <nl> + @ Mod . EventBusSubscriber <nl> + public class TrackingTargetTest <nl> + { <nl> + public static final String ID = " trackingtargettest " ; <nl> + private static boolean ENABLED = false ; <nl> + private static final SimpleNetworkWrapper NET = new SimpleNetworkWrapper ( ID ) ; <nl> + private static final Logger LOGGER = LogManager . getLogger ( ID ) ; <nl> + <nl> + @ Mod . EventHandler <nl> + public static void preinit ( FMLPreInitializationEvent evt ) <nl> + { <nl> + NET . registerMessage ( TestMessageHandler . class , TestMessage . class , 0 , Side . CLIENT ) ; <nl> + NET . registerMessage ( TestEntityMessageHandler . class , TestEntityMessage . class , 1 , Side . CLIENT ) ; <nl> + } <nl> + <nl> + / / Every 3 seconds , send a message to all players tracking overworld ( 500 , 500 ) . <nl> + / / If you move sufficiently far away ( i . e greater than the server render distance ) from ( 500 , 500 ) , you should stop receiving the messages . <nl> + @ SubscribeEvent <nl> + public static void tick ( TickEvent . WorldTickEvent evt ) <nl> + { <nl> + if ( ENABLED & & evt . side = = Side . SERVER & & evt . phase = = TickEvent . Phase . END ) <nl> + { <nl> + if ( evt . world . getWorldTime ( ) % 60 = = 0 ) <nl> + { <nl> + NetworkRegistry . TargetPoint pt = new NetworkRegistry . TargetPoint ( 0 , 500 , 0 , 500 , - 1 ) ; <nl> + NET . sendToAllTracking ( new TestMessage ( ) , pt ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public static class TestMessage implements IMessage <nl> + { <nl> + @ Override <nl> + public void fromBytes ( ByteBuf buf ) { } <nl> + <nl> + @ Override <nl> + public void toBytes ( ByteBuf buf ) { } <nl> + } <nl> + <nl> + public static class TestMessageHandler implements IMessageHandler < TestMessage , IMessage > <nl> + { <nl> + @ Override <nl> + public IMessage onMessage ( TestMessage message , MessageContext ctx ) <nl> + { <nl> + LOGGER . info ( " Received tracking point test message " ) ; <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + / / Every 3 seconds , send a message to all players tracking any item frame with a stick in it <nl> + / / If you move sufficiently far away from the frame , you should stop receiving the messages . <nl> + private static final Set < EntityItemFrame > FRAMES = Collections . newSetFromMap ( new WeakHashMap < > ( ) ) ; <nl> + @ SubscribeEvent <nl> + public static void frameJoin ( EntityJoinWorldEvent evt ) <nl> + { <nl> + if ( ENABLED & & ! evt . getWorld ( ) . isRemote & & evt . getEntity ( ) instanceof EntityItemFrame ) <nl> + { <nl> + FRAMES . add ( ( EntityItemFrame ) evt . getEntity ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ SubscribeEvent <nl> + public static void tickEntity ( TickEvent . WorldTickEvent evt ) <nl> + { <nl> + if ( ENABLED & & evt . side = = Side . SERVER & & evt . phase = = TickEvent . Phase . END ) <nl> + { <nl> + if ( evt . world . getWorldTime ( ) % 60 = = 0 ) <nl> + { <nl> + for ( EntityItemFrame frame : FRAMES ) <nl> + { <nl> + if ( ! frame . isDead & & ! frame . getDisplayedItem ( ) . isEmpty ( ) & & frame . getDisplayedItem ( ) . getItem ( ) = = Items . STICK ) <nl> + { <nl> + NET . sendToAllTracking ( new TestEntityMessage ( ) , frame ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + public static class TestEntityMessage implements IMessage <nl> + { <nl> + @ Override <nl> + public void fromBytes ( ByteBuf buf ) { } <nl> + <nl> + @ Override <nl> + public void toBytes ( ByteBuf buf ) { } <nl> + } <nl> + <nl> + public static class TestEntityMessageHandler implements IMessageHandler < TestEntityMessage , IMessage > <nl> + { <nl> + @ Override <nl> + public IMessage onMessage ( TestEntityMessage message , MessageContext ctx ) <nl> + { <nl> + LOGGER . info ( " Received tracking point test entity message " ) ; <nl> + return null ; <nl> + } <nl> + } <nl> + }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 index e38f820 . . 3e697a3 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 @ @ - 22 , 13 + 22 , 14 @ @ package net . minecraftforge . fml . common . network . handshake ; 
 import io . netty . channel . ChannelFutureListener ; 
 import io . netty . channel . ChannelHandlerContext ; 
 
 - import java . util . List ; 
 import java . util . Map ; 
 import java . util . function . Consumer ; 
 
 import com . google . common . collect . Maps ; 
 import com . google . common . collect . Multimap ; 
 + import com . google . common . util . concurrent . Futures ; 
 
 + import net . minecraft . client . Minecraft ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 import net . minecraftforge . fml . common . Loader ; 
 @ @ - 128 , 7 + 129 , 7 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 WAITINGSERVERCOMPLETE 
 { 
 @ Override 
 - public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 + public void accept ( final ChannelHandlerContext ctx , final FMLHandshakeMessage msg , final Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 FMLHandshakeMessage . RegistryData pkt = ( FMLHandshakeMessage . RegistryData ) msg ; 
 Map < ResourceLocation , ForgeRegistry . Snapshot > snap = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . get ( ) ; 
 @ @ - 153 , 18 + 154 , 23 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 
 ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . set ( null ) ; 
 
 - Multimap < ResourceLocation , ResourceLocation > locallyMissing = GameData . injectSnapshot ( snap , false , false ) ; 
 - if ( ! locallyMissing . isEmpty ( ) ) 
 + / / Do the remapping on the Client ' s thread in case things are reset while the client is running . We stall the network thread until this is finished which can cause the IO thread to time out . . . Not sure if we can do anything about that . 
 + final Map < ResourceLocation , ForgeRegistry . Snapshot > snap _ f = snap ; 
 + Futures . getUnchecked ( Minecraft . getMinecraft ( ) . addScheduledTask ( ( ) - > 
 { 
 - cons . accept ( ERROR ) ; 
 - NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 - dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; 
 - FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; 
 - locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; 
 - return ; 
 - } 
 - cons . accept ( PENDINGCOMPLETE ) ; 
 - ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + Multimap < ResourceLocation , ResourceLocation > locallyMissing = GameData . injectSnapshot ( snap _ f , false , false ) ; 
 + if ( ! locallyMissing . isEmpty ( ) ) 
 + { 
 + cons . accept ( ERROR ) ; 
 + NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 + dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; 
 + FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; 
 + locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; 
 + return ; 
 + } 
 + cons . accept ( PENDINGCOMPLETE ) ; 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } ) ) ; 
 } 
 } , 
 PENDINGCOMPLETE 
 @ @ - 197 , 7 + 203 , 8 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 if ( msg instanceof FMLHandshakeMessage . HandshakeReset ) 
 { 
 cons . accept ( HELLO ) ; 
 - GameData . revertToFrozen ( ) ; 
 + / / Run the revert on the client thread in case things are currently running to prevent race conditions while rebuilding the registries . 
 + Minecraft . getMinecraft ( ) . addScheduledTask ( GameData : : revertToFrozen ) ; 
 } 
 } 
 } ,

NEAREST DIFF:
diff - - git a / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch b / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch 
 index b4a9796 . . 7868457 100644 
 - - - a / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch 
 + + + b / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch 
 @ @ - 150 , 3 + 150 , 13 @ @ 
 { 
 this . func _ 187273 _ a ( this . field _ 187282 _ b . func _ 72688 _ a ( ) . func _ 175625 _ s ( blockpos1 ) ) ; 
 } 
 + @ @ - 311 , 4 + 348 , 9 @ @ 
 + 
 + return d0 ; 
 + } 
 + + 
 + + public List < EntityPlayerMP > getWatchingPlayers ( ) 
 + + { 
 + + return func _ 187274 _ e ( ) ? java . util . Collections . unmodifiableList ( field _ 187283 _ c ) : java . util . Collections . emptyList ( ) ; 
 + + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java b / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java 
 index cf75d2f . . bb87206 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import io . netty . channel . ChannelHandlerContext ; 
 import java . util . EnumMap ; 
 
 import net . minecraft . client . network . NetHandlerPlayClient ; 
 + import net . minecraft . entity . Entity ; 
 import net . minecraft . entity . player . EntityPlayerMP ; 
 import net . minecraft . network . NetHandlerPlayServer ; 
 import net . minecraftforge . fml . common . FMLCommonHandler ; 
 @ @ - 178 , 6 + 179 , 33 @ @ public class FMLEventChannel { 
 } 
 
 / * * 
 + * Send to all tracking the point 
 + * The { @ code range } field of the { @ link NetworkRegistry . TargetPoint } is ignored . 
 + * @ param pkt 
 + * @ param point 
 + * / 
 + public void sendToAllTracking ( FMLProxyPacket pkt , NetworkRegistry . TargetPoint point ) 
 + { 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ POINT ) ; 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( point ) ; 
 + channels . get ( Side . SERVER ) . writeAndFlush ( pkt ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } 
 + 
 + / * * 
 + * Send to all tracking the entity 
 + * This is not equivalent to { @ link # sendToAllTracking ( FMLProxyPacket , NetworkRegistry . TargetPoint ) } 
 + * because entities have different tracking distances based on their type . 
 + * @ param pkt 
 + * @ param entity 
 + * / 
 + public void sendToAllTracking ( FMLProxyPacket pkt , Entity entity ) 
 + { 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ ENTITY ) ; 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( entity ) ; 
 + channels . get ( Side . SERVER ) . writeAndFlush ( pkt ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } 
 + 
 + / * * 
 * Send to all in a dimension 
 * @ param pkt 
 * @ param dimensionId 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java b / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java 
 index a84b9ef . . 9d1f144 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java 
 @ @ - 26 , 9 + 26 , 17 @ @ import io . netty . channel . embedded . EmbeddedChannel ; 
 import io . netty . util . AttributeKey ; 
 
 import java . util . List ; 
 + import java . util . Set ; 
 
 + import net . minecraft . entity . Entity ; 
 + import net . minecraft . entity . player . EntityPlayer ; 
 import net . minecraft . entity . player . EntityPlayerMP ; 
 import net . minecraft . network . NetworkManager ; 
 + import net . minecraft . server . management . PlayerChunkMap ; 
 + import net . minecraft . server . management . PlayerChunkMapEntry ; 
 + import net . minecraft . util . math . MathHelper ; 
 + import net . minecraft . world . WorldServer ; 
 + import net . minecraftforge . common . DimensionManager ; 
 import net . minecraftforge . common . util . FakePlayer ; 
 import net . minecraftforge . fml . common . FMLCommonHandler ; 
 import net . minecraftforge . fml . common . network . NetworkRegistry . TargetPoint ; 
 @ @ - 232 , 6 + 240 , 79 @ @ public class FMLOutboundHandler extends ChannelOutboundHandlerAdapter { 
 } 
 } , 
 / * * 
 + * The packet is sent to all players that are watching the Chunk containing the supplied { @ link TargetPoint } . 
 + * The { @ code range } field of the { @ link TargetPoint } is ignored . 
 + * / 
 + TRACKING _ POINT ( Sets . immutableEnumSet ( Side . SERVER ) ) 
 + { 
 + @ Override 
 + public void validateArgs ( Object args ) 
 + { 
 + if ( ! ( args instanceof TargetPoint ) ) 
 + { 
 + throw new RuntimeException ( " TRACKING _ POINT expects a TargetPoint argument " ) ; 
 + } 
 + } 
 + 
 + @ Nullable 
 + @ Override 
 + public List < NetworkDispatcher > selectNetworks ( Object args , ChannelHandlerContext context , FMLProxyPacket packet ) 
 + { 
 + TargetPoint tp = ( TargetPoint ) args ; 
 + WorldServer world = DimensionManager . getWorld ( tp . dimension ) ; 
 + if ( world = = null ) 
 + { 
 + return ImmutableList . of ( ) ; 
 + } 
 + 
 + PlayerChunkMapEntry entry = world . getPlayerChunkMap ( ) . getEntry ( MathHelper . floor ( tp . x ) > > 4 , MathHelper . floor ( tp . z ) > > 4 ) ; 
 + if ( entry = = null ) 
 + { 
 + return ImmutableList . of ( ) ; 
 + } 
 + 
 + ImmutableList . Builder < NetworkDispatcher > builder = ImmutableList . builder ( ) ; 
 + for ( EntityPlayerMP player : entry . getWatchingPlayers ( ) ) 
 + { 
 + NetworkDispatcher dispatcher = player . connection . netManager . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 + if ( dispatcher ! = null ) builder . add ( dispatcher ) ; 
 + } 
 + return builder . build ( ) ; 
 + } 
 + } , 
 + / * * 
 + * The packet is sent to all players tracking the supplied { @ link Entity } . This is different from { @ link # TRACKING _ POINT } because Entities 
 + * can have different tracking distances depending on their type . 
 + * / 
 + TRACKING _ ENTITY ( Sets . immutableEnumSet ( Side . SERVER ) ) 
 + { 
 + @ Override 
 + public void validateArgs ( Object args ) 
 + { 
 + if ( ! ( args instanceof Entity ) ) 
 + { 
 + throw new RuntimeException ( " TRACKING _ ENTITY expects an Entity argument " ) ; 
 + } 
 + } 
 + 
 + @ Nullable 
 + @ Override 
 + public List < NetworkDispatcher > selectNetworks ( Object args , ChannelHandlerContext context , FMLProxyPacket packet ) 
 + { 
 + Entity e = ( Entity ) args ; 
 + Set < ? extends EntityPlayer > players = FMLCommonHandler . instance ( ) . getMinecraftServerInstance ( ) 
 + . getWorld ( e . dimension ) . getEntityTracker ( ) . getTrackingPlayers ( e ) ; 
 + 
 + ImmutableList . Builder < NetworkDispatcher > builder = ImmutableList . builder ( ) ; 
 + for ( EntityPlayer player : players ) 
 + { 
 + NetworkDispatcher dispatcher = ( ( EntityPlayerMP ) player ) . connection . netManager . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 + if ( dispatcher ! = null ) builder . add ( dispatcher ) ; 
 + } 
 + return builder . build ( ) ; 
 + } 
 + } , 
 + / * * 
 * The packet is sent to the server this client is currently conversing with . 
 * @ author cpw 
 * 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 index b4cda09 . . 9f1a5d9 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import io . netty . channel . ChannelFutureListener ; 
 import java . lang . reflect . Method ; 
 import java . util . EnumMap ; 
 
 + import net . minecraft . entity . Entity ; 
 import net . minecraft . util . IThreadListener ; 
 
 import io . netty . channel . ChannelHandler ; 
 @ @ - 264 , 6 + 265 , 37 @ @ public class SimpleNetworkWrapper { 
 } 
 
 / * * 
 + * Sends this message to everyone tracking a point . 
 + * The { @ link IMessageHandler } for this message type should be on the CLIENT side . 
 + * The { @ code range } field of the { @ link TargetPoint } is ignored . 
 + * 
 + * @ param message The message to send 
 + * @ param point The tracked { @ link TargetPoint } around which to send 
 + * / 
 + public void sendToAllTracking ( IMessage message , NetworkRegistry . TargetPoint point ) 
 + { 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ POINT ) ; 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( point ) ; 
 + channels . get ( Side . SERVER ) . writeAndFlush ( message ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } 
 + 
 + / * * 
 + * Sends this message to everyone tracking an entity . 
 + * The { @ link IMessageHandler } for this message type should be on the CLIENT side . 
 + * This is not equivalent to { @ link # sendToAllTracking ( IMessage , TargetPoint ) } 
 + * because entities have different tracking distances based on their type . 
 + * 
 + * @ param message The message to send 
 + * @ param entity The tracked entity around which to send 
 + * / 
 + public void sendToAllTracking ( IMessage message , Entity entity ) 
 + { 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ ENTITY ) ; 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( entity ) ; 
 + channels . get ( Side . SERVER ) . writeAndFlush ( message ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } 
 + 
 + / * * 
 * Send this message to everyone within the supplied dimension . 
 * The { @ link IMessageHandler } for this message type should be on the CLIENT side . 
 * 
 diff - - git a / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java b / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java 
 new file mode 100644 
 index 0000000 . . f121ce5 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java 
 @ @ - 0 , 0 + 1 , 122 @ @ 
 + package net . minecraftforge . debug ; 
 + 
 + import io . netty . buffer . ByteBuf ; 
 + import net . minecraft . entity . item . EntityItemFrame ; 
 + import net . minecraft . init . Items ; 
 + import net . minecraftforge . event . entity . EntityJoinWorldEvent ; 
 + import net . minecraftforge . fml . common . Mod ; 
 + import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 + import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; 
 + import net . minecraftforge . fml . common . gameevent . TickEvent ; 
 + import net . minecraftforge . fml . common . network . NetworkRegistry ; 
 + import net . minecraftforge . fml . common . network . simpleimpl . IMessage ; 
 + import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; 
 + import net . minecraftforge . fml . common . network . simpleimpl . MessageContext ; 
 + import net . minecraftforge . fml . common . network . simpleimpl . SimpleNetworkWrapper ; 
 + import net . minecraftforge . fml . relauncher . Side ; 
 + import org . apache . logging . log4j . LogManager ; 
 + import org . apache . logging . log4j . Logger ; 
 + 
 + import java . util . Collections ; 
 + import java . util . Set ; 
 + import java . util . WeakHashMap ; 
 + 
 + @ Mod ( modid = TrackingTargetTest . ID , name = " Tracking Target Test " , acceptableRemoteVersions = " * " ) 
 + @ Mod . EventBusSubscriber 
 + public class TrackingTargetTest 
 + { 
 + public static final String ID = " trackingtargettest " ; 
 + private static boolean ENABLED = false ; 
 + private static final SimpleNetworkWrapper NET = new SimpleNetworkWrapper ( ID ) ; 
 + private static final Logger LOGGER = LogManager . getLogger ( ID ) ; 
 + 
 + @ Mod . EventHandler 
 + public static void preinit ( FMLPreInitializationEvent evt ) 
 + { 
 + NET . registerMessage ( TestMessageHandler . class , TestMessage . class , 0 , Side . CLIENT ) ; 
 + NET . registerMessage ( TestEntityMessageHandler . class , TestEntityMessage . class , 1 , Side . CLIENT ) ; 
 + } 
 + 
 + / / Every 3 seconds , send a message to all players tracking overworld ( 500 , 500 ) . 
 + / / If you move sufficiently far away ( i . e greater than the server render distance ) from ( 500 , 500 ) , you should stop receiving the messages . 
 + @ SubscribeEvent 
 + public static void tick ( TickEvent . WorldTickEvent evt ) 
 + { 
 + if ( ENABLED & & evt . side = = Side . SERVER & & evt . phase = = TickEvent . Phase . END ) 
 + { 
 + if ( evt . world . getWorldTime ( ) % 60 = = 0 ) 
 + { 
 + NetworkRegistry . TargetPoint pt = new NetworkRegistry . TargetPoint ( 0 , 500 , 0 , 500 , - 1 ) ; 
 + NET . sendToAllTracking ( new TestMessage ( ) , pt ) ; 
 + } 
 + } 
 + } 
 + 
 + public static class TestMessage implements IMessage 
 + { 
 + @ Override 
 + public void fromBytes ( ByteBuf buf ) { } 
 + 
 + @ Override 
 + public void toBytes ( ByteBuf buf ) { } 
 + } 
 + 
 + public static class TestMessageHandler implements IMessageHandler < TestMessage , IMessage > 
 + { 
 + @ Override 
 + public IMessage onMessage ( TestMessage message , MessageContext ctx ) 
 + { 
 + LOGGER . info ( " Received tracking point test message " ) ; 
 + return null ; 
 + } 
 + } 
 + 
 + / / Every 3 seconds , send a message to all players tracking any item frame with a stick in it 
 + / / If you move sufficiently far away from the frame , you should stop receiving the messages . 
 + private static final Set < EntityItemFrame > FRAMES = Collections . newSetFromMap ( new WeakHashMap < > ( ) ) ; 
 + @ SubscribeEvent 
 + public static void frameJoin ( EntityJoinWorldEvent evt ) 
 + { 
 + if ( ENABLED & & ! evt . getWorld ( ) . isRemote & & evt . getEntity ( ) instanceof EntityItemFrame ) 
 + { 
 + FRAMES . add ( ( EntityItemFrame ) evt . getEntity ( ) ) ; 
 + } 
 + } 
 + 
 + @ SubscribeEvent 
 + public static void tickEntity ( TickEvent . WorldTickEvent evt ) 
 + { 
 + if ( ENABLED & & evt . side = = Side . SERVER & & evt . phase = = TickEvent . Phase . END ) 
 + { 
 + if ( evt . world . getWorldTime ( ) % 60 = = 0 ) 
 + { 
 + for ( EntityItemFrame frame : FRAMES ) 
 + { 
 + if ( ! frame . isDead & & ! frame . getDisplayedItem ( ) . isEmpty ( ) & & frame . getDisplayedItem ( ) . getItem ( ) = = Items . STICK ) 
 + { 
 + NET . sendToAllTracking ( new TestEntityMessage ( ) , frame ) ; 
 + } 
 + } 
 + } 
 + } 
 + } 
 + 
 + public static class TestEntityMessage implements IMessage 
 + { 
 + @ Override 
 + public void fromBytes ( ByteBuf buf ) { } 
 + 
 + @ Override 
 + public void toBytes ( ByteBuf buf ) { } 
 + } 
 + 
 + public static class TestEntityMessageHandler implements IMessageHandler < TestEntityMessage , IMessage > 
 + { 
 + @ Override 
 + public IMessage onMessage ( TestEntityMessage message , MessageContext ctx ) 
 + { 
 + LOGGER . info ( " Received tracking point test entity message " ) ; 
 + return null ; 
 + } 
 + } 
 + }
