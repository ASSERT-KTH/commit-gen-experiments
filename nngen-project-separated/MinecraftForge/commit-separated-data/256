BLEU SCORE: 0.01543228837249852

TEST MSG: Improve performance of some ExtendedBlockState methods
GENERATED MSG: Optimize ExtendedBlockState . getClean , cache the return value instead of calculating it . Closes # 3936

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java b / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java <nl> index 63d5ee3 . . 09a56db 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java <nl> + + + b / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java <nl> @ @ - 22 , 15 + 22 , 12 @ @ package net . minecraftforge . common . property ; <nl> import javax . annotation . Nonnull ; <nl> import javax . annotation . Nullable ; <nl> import java . util . Collection ; <nl> - import java . util . Collections ; <nl> - import java . util . HashMap ; <nl> import java . util . Map ; <nl> + import java . util . Objects ; <nl> import java . util . Optional ; <nl> - import com . google . common . base . Predicates ; <nl> import com . google . common . collect . ImmutableMap ; <nl> import com . google . common . collect . ImmutableSet ; <nl> import com . google . common . collect . ImmutableTable ; <nl> - import com . google . common . collect . Iterables ; <nl> import net . minecraft . block . Block ; <nl> import net . minecraft . block . properties . IProperty ; <nl> import net . minecraft . block . state . BlockStateContainer ; <nl> @ @ - 95 , 7 + 92 , 7 @ @ public class ExtendedBlockState extends BlockStateContainer <nl> return this ; <nl> } <nl> <nl> - if ( unlistedProperties . values ( ) . stream ( ) . noneMatch ( Optional : : isPresent ) ) <nl> + if ( this = = this . cleanState ) <nl> { / / no dynamic properties present , looking up in the normal table <nl> return clean ; <nl> } <nl> @ @ - 104 , 39 + 101 , 53 @ @ public class ExtendedBlockState extends BlockStateContainer <nl> } <nl> <nl> @ Override <nl> - public < V > IExtendedBlockState withProperty ( IUnlistedProperty < V > property , V value ) <nl> + public < V > IExtendedBlockState withProperty ( IUnlistedProperty < V > property , @ Nullable V value ) <nl> { <nl> - if ( ! this . unlistedProperties . containsKey ( property ) ) <nl> + Optional < ? > oldValue = unlistedProperties . get ( property ) ; <nl> + if ( oldValue = = null ) <nl> { <nl> throw new IllegalArgumentException ( " Cannot set unlisted property " + property + " as it does not exist in " + getBlock ( ) . getBlockState ( ) ) ; <nl> } <nl> - if ( ! property . isValid ( value ) ) <nl> + if ( Objects . equals ( oldValue . orElse ( null ) , value ) ) <nl> + { <nl> + return this ; <nl> + } <nl> + if ( ! property . isValid ( value ) ) <nl> { <nl> throw new IllegalArgumentException ( " Cannot set unlisted property " + property + " to " + value + " on block " + Block . REGISTRY . getNameForObject ( getBlock ( ) ) + " , it is not an allowed value " ) ; <nl> } <nl> - Map < IUnlistedProperty < ? > , Optional < ? > > newMap = new HashMap < IUnlistedProperty < ? > , Optional < ? > > ( unlistedProperties ) ; <nl> - newMap . put ( property , Optional . ofNullable ( value ) ) ; <nl> - if ( Iterables . all ( newMap . values ( ) , Predicates . < Optional < ? > > equalTo ( Optional . empty ( ) ) ) ) <nl> + boolean clean = true ; <nl> + ImmutableMap . Builder < IUnlistedProperty < ? > , Optional < ? > > builder = ImmutableMap . builder ( ) ; <nl> + for ( Map . Entry < IUnlistedProperty < ? > , Optional < ? > > entry : unlistedProperties . entrySet ( ) ) <nl> + { <nl> + IUnlistedProperty < ? > key = entry . getKey ( ) ; <nl> + Optional < ? > newValue = key . equals ( property ) ? Optional . ofNullable ( value ) : entry . getValue ( ) ; <nl> + if ( newValue . isPresent ( ) ) clean = false ; <nl> + builder . put ( key , newValue ) ; <nl> + } <nl> + if ( clean ) <nl> { / / no dynamic properties , lookup normal state <nl> - return ( IExtendedBlockState ) cleanState ; <nl> + return ( IExtendedBlockState ) cleanState ; <nl> } <nl> - return new ExtendedStateImplementation ( getBlock ( ) , getProperties ( ) , ImmutableMap . copyOf ( newMap ) , propertyValueTable , this . cleanState ) ; <nl> + return new ExtendedStateImplementation ( getBlock ( ) , getProperties ( ) , builder . build ( ) , propertyValueTable , this . cleanState ) ; <nl> } <nl> <nl> @ Override <nl> public Collection < IUnlistedProperty < ? > > getUnlistedNames ( ) <nl> { <nl> - return Collections . unmodifiableCollection ( unlistedProperties . keySet ( ) ) ; <nl> + return unlistedProperties . keySet ( ) ; <nl> } <nl> <nl> @ Override <nl> - public < V > V getValue ( IUnlistedProperty < V > property ) <nl> + @ Nullable <nl> + public < V > V getValue ( IUnlistedProperty < V > property ) <nl> { <nl> - if ( ! this . unlistedProperties . containsKey ( property ) ) <nl> + Optional < ? > value = unlistedProperties . get ( property ) ; <nl> + if ( value = = null ) <nl> { <nl> throw new IllegalArgumentException ( " Cannot get unlisted property " + property + " as it does not exist in " + getBlock ( ) . getBlockState ( ) ) ; <nl> } <nl> - return property . getType ( ) . cast ( this . unlistedProperties . get ( property ) . orElse ( null ) ) ; <nl> + return property . getType ( ) . cast ( value . orElse ( null ) ) ; <nl> } <nl> <nl> public ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > getUnlistedProperties ( )
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java b / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java <nl> index 6f92b99 . . ddb6f70 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java <nl> + + + b / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java <nl> @ @ - 35 , 7 + 35 , 6 @ @ import com . google . common . collect . ImmutableMap ; <nl> import com . google . common . collect . ImmutableSet ; <nl> import com . google . common . collect . ImmutableTable ; <nl> import com . google . common . collect . Iterables ; <nl> - import com . google . common . collect . Maps ; <nl> <nl> import javax . annotation . Nonnull ; <nl> import javax . annotation . Nullable ; <nl> @ @ - 75 , 51 + 74 , 36 @ @ public class ExtendedBlockState extends BlockStateContainer <nl> protected StateImplementation createState ( @ Nonnull Block block , @ Nonnull ImmutableMap < IProperty < ? > , Comparable < ? > > properties , @ Nullable ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > unlistedProperties ) <nl> { <nl> if ( unlistedProperties = = null | | unlistedProperties . isEmpty ( ) ) return super . createState ( block , properties , unlistedProperties ) ; <nl> - return new ExtendedStateImplementation ( block , properties , unlistedProperties , null ) ; <nl> + return new ExtendedStateImplementation ( block , properties , unlistedProperties , null , null ) ; <nl> } <nl> <nl> protected static class ExtendedStateImplementation extends StateImplementation implements IExtendedBlockState <nl> { <nl> private final ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > unlistedProperties ; <nl> - private Map < Map < IProperty < ? > , Comparable < ? > > , BlockStateContainer . StateImplementation > normalMap ; <nl> + private IBlockState cleanState ; <nl> <nl> - protected ExtendedStateImplementation ( Block block , ImmutableMap < IProperty < ? > , Comparable < ? > > properties , ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > unlistedProperties , @ Nullable ImmutableTable < IProperty < ? > , Comparable < ? > , IBlockState > table ) <nl> + protected ExtendedStateImplementation ( Block block , ImmutableMap < IProperty < ? > , Comparable < ? > > properties , ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > unlistedProperties , @ Nullable ImmutableTable < IProperty < ? > , Comparable < ? > , IBlockState > table , IBlockState clean ) <nl> { <nl> - super ( block , properties ) ; <nl> + super ( block , properties , table ) ; <nl> this . unlistedProperties = unlistedProperties ; <nl> - this . propertyValueTable = table ; <nl> + this . cleanState = clean = = null ? this : clean ; <nl> } <nl> <nl> @ Override <nl> @ Nonnull <nl> public < T extends Comparable < T > , V extends T > IBlockState withProperty ( @ Nonnull IProperty < T > property , @ Nonnull V value ) <nl> { <nl> - if ( ! this . getProperties ( ) . containsKey ( property ) ) <nl> - { <nl> - throw new IllegalArgumentException ( " Cannot set property " + property + " as it does not exist in " + getBlock ( ) . getBlockState ( ) ) ; <nl> + IBlockState clean = super . withProperty ( property , value ) ; <nl> + if ( clean = = this . cleanState ) { <nl> + return this ; <nl> } <nl> - else <nl> - { <nl> - if ( ! property . getAllowedValues ( ) . contains ( value ) ) <nl> - { <nl> - throw new IllegalArgumentException ( " Cannot set property " + property + " to " + value + " on block " + Block . REGISTRY . getNameForObject ( getBlock ( ) ) + " , it is not an allowed value " ) ; <nl> - } else <nl> - { <nl> - if ( this . getProperties ( ) . get ( property ) = = value ) <nl> - { <nl> - return this ; <nl> - } <nl> - Map < IProperty < ? > , Comparable < ? > > map = Maps . newHashMap ( getProperties ( ) ) ; <nl> - map . put ( property , value ) ; <nl> - if ( Iterables . all ( unlistedProperties . values ( ) , Predicates . < Optional < ? > > equalTo ( Optional . empty ( ) ) ) ) <nl> - { / / no dynamic properties present , looking up in the normal table <nl> - return normalMap . get ( map ) ; <nl> - } <nl> - ImmutableTable < IProperty < ? > , Comparable < ? > , IBlockState > table = propertyValueTable ; <nl> - table = ( ( StateImplementation ) table . get ( property , value ) ) . getPropertyValueTable ( ) ; <nl> - return new ExtendedStateImplementation ( getBlock ( ) , ImmutableMap . copyOf ( map ) , unlistedProperties , table ) . setMap ( this . normalMap ) ; <nl> - } <nl> + <nl> + if ( Iterables . all ( unlistedProperties . values ( ) , Predicates . < Optional < ? > > equalTo ( Optional . empty ( ) ) ) ) <nl> + { / / no dynamic properties present , looking up in the normal table <nl> + return clean ; <nl> } <nl> + <nl> + return new ExtendedStateImplementation ( getBlock ( ) , clean . getProperties ( ) , unlistedProperties , ( ( StateImplementation ) clean ) . getPropertyValueTable ( ) , this . cleanState ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 137 , 9 + 121 , 9 @ @ public class ExtendedBlockState extends BlockStateContainer <nl> newMap . put ( property , Optional . ofNullable ( value ) ) ; <nl> if ( Iterables . all ( newMap . values ( ) , Predicates . < Optional < ? > > equalTo ( Optional . empty ( ) ) ) ) <nl> { / / no dynamic properties , lookup normal state <nl> - return ( IExtendedBlockState ) normalMap . get ( getProperties ( ) ) ; <nl> + return ( IExtendedBlockState ) cleanState ; <nl> } <nl> - return new ExtendedStateImplementation ( getBlock ( ) , getProperties ( ) , ImmutableMap . copyOf ( newMap ) , propertyValueTable ) . setMap ( this . normalMap ) ; <nl> + return new ExtendedStateImplementation ( getBlock ( ) , getProperties ( ) , ImmutableMap . copyOf ( newMap ) , propertyValueTable , this . cleanState ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 158 , 29 + 142 , 15 @ @ public class ExtendedBlockState extends BlockStateContainer <nl> return property . getType ( ) . cast ( this . unlistedProperties . get ( property ) . orElse ( null ) ) ; <nl> } <nl> <nl> - @ Override <nl> public ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > getUnlistedProperties ( ) <nl> { <nl> return unlistedProperties ; <nl> } <nl> <nl> @ Override <nl> - public void buildPropertyValueTable ( Map < Map < IProperty < ? > , Comparable < ? > > , BlockStateContainer . StateImplementation > map ) <nl> - { <nl> - this . normalMap = map ; <nl> - super . buildPropertyValueTable ( map ) ; <nl> - } <nl> - <nl> - private ExtendedStateImplementation setMap ( Map < Map < IProperty < ? > , Comparable < ? > > , BlockStateContainer . StateImplementation > map ) <nl> - { <nl> - this . normalMap = map ; <nl> - return this ; <nl> - } <nl> - <nl> - @ Override <nl> public IBlockState getClean ( ) <nl> { <nl> - return this . normalMap . get ( getProperties ( ) ) ; <nl> + return cleanState ; <nl> } <nl> } <nl> - } <nl> \ No newline at end of file <nl> + }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java b / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java 
 index 63d5ee3 . . 09a56db 100644 
 - - - a / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java 
 + + + b / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java 
 @ @ - 22 , 15 + 22 , 12 @ @ package net . minecraftforge . common . property ; 
 import javax . annotation . Nonnull ; 
 import javax . annotation . Nullable ; 
 import java . util . Collection ; 
 - import java . util . Collections ; 
 - import java . util . HashMap ; 
 import java . util . Map ; 
 + import java . util . Objects ; 
 import java . util . Optional ; 
 - import com . google . common . base . Predicates ; 
 import com . google . common . collect . ImmutableMap ; 
 import com . google . common . collect . ImmutableSet ; 
 import com . google . common . collect . ImmutableTable ; 
 - import com . google . common . collect . Iterables ; 
 import net . minecraft . block . Block ; 
 import net . minecraft . block . properties . IProperty ; 
 import net . minecraft . block . state . BlockStateContainer ; 
 @ @ - 95 , 7 + 92 , 7 @ @ public class ExtendedBlockState extends BlockStateContainer 
 return this ; 
 } 
 
 - if ( unlistedProperties . values ( ) . stream ( ) . noneMatch ( Optional : : isPresent ) ) 
 + if ( this = = this . cleanState ) 
 { / / no dynamic properties present , looking up in the normal table 
 return clean ; 
 } 
 @ @ - 104 , 39 + 101 , 53 @ @ public class ExtendedBlockState extends BlockStateContainer 
 } 
 
 @ Override 
 - public < V > IExtendedBlockState withProperty ( IUnlistedProperty < V > property , V value ) 
 + public < V > IExtendedBlockState withProperty ( IUnlistedProperty < V > property , @ Nullable V value ) 
 { 
 - if ( ! this . unlistedProperties . containsKey ( property ) ) 
 + Optional < ? > oldValue = unlistedProperties . get ( property ) ; 
 + if ( oldValue = = null ) 
 { 
 throw new IllegalArgumentException ( " Cannot set unlisted property " + property + " as it does not exist in " + getBlock ( ) . getBlockState ( ) ) ; 
 } 
 - if ( ! property . isValid ( value ) ) 
 + if ( Objects . equals ( oldValue . orElse ( null ) , value ) ) 
 + { 
 + return this ; 
 + } 
 + if ( ! property . isValid ( value ) ) 
 { 
 throw new IllegalArgumentException ( " Cannot set unlisted property " + property + " to " + value + " on block " + Block . REGISTRY . getNameForObject ( getBlock ( ) ) + " , it is not an allowed value " ) ; 
 } 
 - Map < IUnlistedProperty < ? > , Optional < ? > > newMap = new HashMap < IUnlistedProperty < ? > , Optional < ? > > ( unlistedProperties ) ; 
 - newMap . put ( property , Optional . ofNullable ( value ) ) ; 
 - if ( Iterables . all ( newMap . values ( ) , Predicates . < Optional < ? > > equalTo ( Optional . empty ( ) ) ) ) 
 + boolean clean = true ; 
 + ImmutableMap . Builder < IUnlistedProperty < ? > , Optional < ? > > builder = ImmutableMap . builder ( ) ; 
 + for ( Map . Entry < IUnlistedProperty < ? > , Optional < ? > > entry : unlistedProperties . entrySet ( ) ) 
 + { 
 + IUnlistedProperty < ? > key = entry . getKey ( ) ; 
 + Optional < ? > newValue = key . equals ( property ) ? Optional . ofNullable ( value ) : entry . getValue ( ) ; 
 + if ( newValue . isPresent ( ) ) clean = false ; 
 + builder . put ( key , newValue ) ; 
 + } 
 + if ( clean ) 
 { / / no dynamic properties , lookup normal state 
 - return ( IExtendedBlockState ) cleanState ; 
 + return ( IExtendedBlockState ) cleanState ; 
 } 
 - return new ExtendedStateImplementation ( getBlock ( ) , getProperties ( ) , ImmutableMap . copyOf ( newMap ) , propertyValueTable , this . cleanState ) ; 
 + return new ExtendedStateImplementation ( getBlock ( ) , getProperties ( ) , builder . build ( ) , propertyValueTable , this . cleanState ) ; 
 } 
 
 @ Override 
 public Collection < IUnlistedProperty < ? > > getUnlistedNames ( ) 
 { 
 - return Collections . unmodifiableCollection ( unlistedProperties . keySet ( ) ) ; 
 + return unlistedProperties . keySet ( ) ; 
 } 
 
 @ Override 
 - public < V > V getValue ( IUnlistedProperty < V > property ) 
 + @ Nullable 
 + public < V > V getValue ( IUnlistedProperty < V > property ) 
 { 
 - if ( ! this . unlistedProperties . containsKey ( property ) ) 
 + Optional < ? > value = unlistedProperties . get ( property ) ; 
 + if ( value = = null ) 
 { 
 throw new IllegalArgumentException ( " Cannot get unlisted property " + property + " as it does not exist in " + getBlock ( ) . getBlockState ( ) ) ; 
 } 
 - return property . getType ( ) . cast ( this . unlistedProperties . get ( property ) . orElse ( null ) ) ; 
 + return property . getType ( ) . cast ( value . orElse ( null ) ) ; 
 } 
 
 public ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > getUnlistedProperties ( )

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java b / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java 
 index 6f92b99 . . ddb6f70 100644 
 - - - a / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java 
 + + + b / src / main / java / net / minecraftforge / common / property / ExtendedBlockState . java 
 @ @ - 35 , 7 + 35 , 6 @ @ import com . google . common . collect . ImmutableMap ; 
 import com . google . common . collect . ImmutableSet ; 
 import com . google . common . collect . ImmutableTable ; 
 import com . google . common . collect . Iterables ; 
 - import com . google . common . collect . Maps ; 
 
 import javax . annotation . Nonnull ; 
 import javax . annotation . Nullable ; 
 @ @ - 75 , 51 + 74 , 36 @ @ public class ExtendedBlockState extends BlockStateContainer 
 protected StateImplementation createState ( @ Nonnull Block block , @ Nonnull ImmutableMap < IProperty < ? > , Comparable < ? > > properties , @ Nullable ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > unlistedProperties ) 
 { 
 if ( unlistedProperties = = null | | unlistedProperties . isEmpty ( ) ) return super . createState ( block , properties , unlistedProperties ) ; 
 - return new ExtendedStateImplementation ( block , properties , unlistedProperties , null ) ; 
 + return new ExtendedStateImplementation ( block , properties , unlistedProperties , null , null ) ; 
 } 
 
 protected static class ExtendedStateImplementation extends StateImplementation implements IExtendedBlockState 
 { 
 private final ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > unlistedProperties ; 
 - private Map < Map < IProperty < ? > , Comparable < ? > > , BlockStateContainer . StateImplementation > normalMap ; 
 + private IBlockState cleanState ; 
 
 - protected ExtendedStateImplementation ( Block block , ImmutableMap < IProperty < ? > , Comparable < ? > > properties , ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > unlistedProperties , @ Nullable ImmutableTable < IProperty < ? > , Comparable < ? > , IBlockState > table ) 
 + protected ExtendedStateImplementation ( Block block , ImmutableMap < IProperty < ? > , Comparable < ? > > properties , ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > unlistedProperties , @ Nullable ImmutableTable < IProperty < ? > , Comparable < ? > , IBlockState > table , IBlockState clean ) 
 { 
 - super ( block , properties ) ; 
 + super ( block , properties , table ) ; 
 this . unlistedProperties = unlistedProperties ; 
 - this . propertyValueTable = table ; 
 + this . cleanState = clean = = null ? this : clean ; 
 } 
 
 @ Override 
 @ Nonnull 
 public < T extends Comparable < T > , V extends T > IBlockState withProperty ( @ Nonnull IProperty < T > property , @ Nonnull V value ) 
 { 
 - if ( ! this . getProperties ( ) . containsKey ( property ) ) 
 - { 
 - throw new IllegalArgumentException ( " Cannot set property " + property + " as it does not exist in " + getBlock ( ) . getBlockState ( ) ) ; 
 + IBlockState clean = super . withProperty ( property , value ) ; 
 + if ( clean = = this . cleanState ) { 
 + return this ; 
 } 
 - else 
 - { 
 - if ( ! property . getAllowedValues ( ) . contains ( value ) ) 
 - { 
 - throw new IllegalArgumentException ( " Cannot set property " + property + " to " + value + " on block " + Block . REGISTRY . getNameForObject ( getBlock ( ) ) + " , it is not an allowed value " ) ; 
 - } else 
 - { 
 - if ( this . getProperties ( ) . get ( property ) = = value ) 
 - { 
 - return this ; 
 - } 
 - Map < IProperty < ? > , Comparable < ? > > map = Maps . newHashMap ( getProperties ( ) ) ; 
 - map . put ( property , value ) ; 
 - if ( Iterables . all ( unlistedProperties . values ( ) , Predicates . < Optional < ? > > equalTo ( Optional . empty ( ) ) ) ) 
 - { / / no dynamic properties present , looking up in the normal table 
 - return normalMap . get ( map ) ; 
 - } 
 - ImmutableTable < IProperty < ? > , Comparable < ? > , IBlockState > table = propertyValueTable ; 
 - table = ( ( StateImplementation ) table . get ( property , value ) ) . getPropertyValueTable ( ) ; 
 - return new ExtendedStateImplementation ( getBlock ( ) , ImmutableMap . copyOf ( map ) , unlistedProperties , table ) . setMap ( this . normalMap ) ; 
 - } 
 + 
 + if ( Iterables . all ( unlistedProperties . values ( ) , Predicates . < Optional < ? > > equalTo ( Optional . empty ( ) ) ) ) 
 + { / / no dynamic properties present , looking up in the normal table 
 + return clean ; 
 } 
 + 
 + return new ExtendedStateImplementation ( getBlock ( ) , clean . getProperties ( ) , unlistedProperties , ( ( StateImplementation ) clean ) . getPropertyValueTable ( ) , this . cleanState ) ; 
 } 
 
 @ Override 
 @ @ - 137 , 9 + 121 , 9 @ @ public class ExtendedBlockState extends BlockStateContainer 
 newMap . put ( property , Optional . ofNullable ( value ) ) ; 
 if ( Iterables . all ( newMap . values ( ) , Predicates . < Optional < ? > > equalTo ( Optional . empty ( ) ) ) ) 
 { / / no dynamic properties , lookup normal state 
 - return ( IExtendedBlockState ) normalMap . get ( getProperties ( ) ) ; 
 + return ( IExtendedBlockState ) cleanState ; 
 } 
 - return new ExtendedStateImplementation ( getBlock ( ) , getProperties ( ) , ImmutableMap . copyOf ( newMap ) , propertyValueTable ) . setMap ( this . normalMap ) ; 
 + return new ExtendedStateImplementation ( getBlock ( ) , getProperties ( ) , ImmutableMap . copyOf ( newMap ) , propertyValueTable , this . cleanState ) ; 
 } 
 
 @ Override 
 @ @ - 158 , 29 + 142 , 15 @ @ public class ExtendedBlockState extends BlockStateContainer 
 return property . getType ( ) . cast ( this . unlistedProperties . get ( property ) . orElse ( null ) ) ; 
 } 
 
 - @ Override 
 public ImmutableMap < IUnlistedProperty < ? > , Optional < ? > > getUnlistedProperties ( ) 
 { 
 return unlistedProperties ; 
 } 
 
 @ Override 
 - public void buildPropertyValueTable ( Map < Map < IProperty < ? > , Comparable < ? > > , BlockStateContainer . StateImplementation > map ) 
 - { 
 - this . normalMap = map ; 
 - super . buildPropertyValueTable ( map ) ; 
 - } 
 - 
 - private ExtendedStateImplementation setMap ( Map < Map < IProperty < ? > , Comparable < ? > > , BlockStateContainer . StateImplementation > map ) 
 - { 
 - this . normalMap = map ; 
 - return this ; 
 - } 
 - 
 - @ Override 
 public IBlockState getClean ( ) 
 { 
 - return this . normalMap . get ( getProperties ( ) ) ; 
 + return cleanState ; 
 } 
 } 
 - } 
 \ No newline at end of file 
 + }
