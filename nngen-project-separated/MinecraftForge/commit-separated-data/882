BLEU SCORE: 0.013353534059549447

TEST MSG: Fix that the dummy registry entries don ' t allow clients connecting to servers . Also fix that it repeatedly nags about missing stuff in the world .
GENERATED MSG: First attempt at making FMLControlledRegistry something a bit more generic than just blocks / items .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> index 92c2258 . . c1a77d1 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> @ @ - 154 , 6 + 154 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> blocked [ idx + + ] = i ; <nl> } <nl> data . setIntArray ( " blocked " , blocked ) ; <nl> + NBTTagList dummied = new NBTTagList ( ) ; <nl> + for ( ResourceLocation entry : e . getValue ( ) . dummied ) <nl> + { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setString ( " K " , entry . toString ( ) ) ; <nl> + dummied . appendTag ( tag ) ; <nl> + } <nl> + data . setTag ( " dummied " , dummied ) ; <nl> } <nl> return fmlData ; <nl> } <nl> @ @ - 297 , 6 + 305 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> { <nl> entry . blocked . add ( i ) ; <nl> } <nl> + / / save doesn ' t have dummied list <nl> + if ( ! regs . getCompoundTag ( key ) . hasKey ( " dummied " ) ) return ; <nl> + list = regs . getCompoundTag ( key ) . getTagList ( " dummied " , 10 ) ; <nl> + for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) <nl> + { <nl> + NBTTagCompound e = list . getCompoundTagAt ( x ) ; <nl> + entry . dummied . add ( new ResourceLocation ( e . getString ( " K " ) ) ) ; <nl> + } <nl> } <nl> failedElements = PersistentRegistryManager . injectSnapshot ( snapshot , true , true ) ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> index aa09692 . . d17393c 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> @ @ - 105 , 11 + 105 , 12 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> PersistentRegistryManager . GameDataSnapshot . Entry entry = new PersistentRegistryManager . GameDataSnapshot . Entry ( ) ; <nl> entry . ids . putAll ( pkt . getIdMap ( ) ) ; <nl> entry . substitutions . addAll ( pkt . getSubstitutions ( ) ) ; <nl> + entry . dummied . addAll ( pkt . getDummied ( ) ) ; <nl> snap . entries . put ( pkt . getName ( ) , entry ) ; <nl> <nl> if ( pkt . hasMore ( ) ) <nl> { <nl> - FMLLog . fine ( " Received Mod Registry mapping for % s : % d IDs % d subs " , pkt . getName ( ) , entry . ids . size ( ) , entry . substitutions . size ( ) ) ; <nl> + FMLLog . fine ( " Received Mod Registry mapping for % s : % d IDs % d subs % d dummied " , pkt . getName ( ) , entry . ids . size ( ) , entry . substitutions . size ( ) , entry . dummied . size ( ) ) ; <nl> return WAITINGSERVERCOMPLETE ; <nl> } <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java <nl> index b6f797a . . e24ed76 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java <nl> @ @ - 165 , 12 + 165 , 14 @ @ public abstract class FMLHandshakeMessage { <nl> this . name = name ; <nl> this . ids = entry . ids ; <nl> this . substitutions = entry . substitutions ; <nl> + this . dummied = entry . dummied ; <nl> } <nl> <nl> private boolean hasMore ; <nl> private ResourceLocation name ; <nl> private Map < ResourceLocation , Integer > ids ; <nl> private Set < ResourceLocation > substitutions ; <nl> + private Set < ResourceLocation > dummied ; <nl> <nl> @ Override <nl> public void fromBytes ( ByteBuf buffer ) <nl> @ @ - 193 , 6 + 195 , 15 @ @ public abstract class FMLHandshakeMessage { <nl> { <nl> substitutions . add ( new ResourceLocation ( ByteBufUtils . readUTF8String ( buffer ) ) ) ; <nl> } <nl> + dummied = Sets . newHashSet ( ) ; <nl> + / / if the dummied list isn ' t present - probably an older server <nl> + if ( ! buffer . isReadable ( ) ) return ; <nl> + length = ByteBufUtils . readVarInt ( buffer , 3 ) ; <nl> + <nl> + for ( int i = 0 ; i < length ; i + + ) <nl> + { <nl> + dummied . add ( new ResourceLocation ( ByteBufUtils . readUTF8String ( buffer ) ) ) ; <nl> + } <nl> / / if ( ! buffer . isReadable ( ) ) return ; / / In case we expand <nl> } <nl> <nl> @ @ - 214 , 6 + 225 , 11 @ @ public abstract class FMLHandshakeMessage { <nl> { <nl> ByteBufUtils . writeUTF8String ( buffer , entry . toString ( ) ) ; <nl> } <nl> + ByteBufUtils . writeVarInt ( buffer , dummied . size ( ) , 3 ) ; <nl> + for ( ResourceLocation entry : dummied ) <nl> + { <nl> + ByteBufUtils . writeUTF8String ( buffer , entry . toString ( ) ) ; <nl> + } <nl> } <nl> <nl> public Map < ResourceLocation , Integer > getIdMap ( ) <nl> @ @ - 224 , 6 + 240 , 7 @ @ public abstract class FMLHandshakeMessage { <nl> { <nl> return substitutions ; <nl> } <nl> + public Set < ResourceLocation > getDummied ( ) { return dummied ; } <nl> public ResourceLocation getName ( ) <nl> { <nl> return this . name ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> index b4a5670 . . 3e2a5c6 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> @ @ - 54 , 6 + 54 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> * / <nl> private final Set < Integer > blockedIds = Sets . newHashSet ( ) ; <nl> <nl> + private final Set < ResourceLocation > dummiedLocations = Sets . newHashSet ( ) ; <nl> + <nl> private final BitSet availabilityMap ; <nl> <nl> private final AddCallback < I > addCallback ; <nl> @ @ - 164 , 6 + 166 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> this . persistentSubstitutions . clear ( ) ; <nl> this . persistentSubstitutions . putAll ( otherRegistry . getPersistentSubstitutions ( ) ) ; <nl> this . activeSubstitutions . clear ( ) ; <nl> + this . dummiedLocations . clear ( ) ; <nl> + this . dummiedLocations . addAll ( otherRegistry . dummiedLocations ) ; <nl> <nl> underlyingIntegerMap = new ObjectIntIdentityMap < I > ( ) ; <nl> registryObjects . clear ( ) ; <nl> @ @ - 384 , 6 + 388 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> set . addAll ( activeSubstitutions . keySet ( ) ) ; <nl> } <nl> <nl> + public void serializeDummied ( Set < ResourceLocation > set ) { set . addAll ( this . dummiedLocations ) ; } <nl> + <nl> + <nl> / * * <nl> * Add the specified object to the registry . <nl> * <nl> @ @ - 456 , 6 + 463 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> { <nl> getExistingDelegate ( thing ) . setResourceName ( name ) ; <nl> } <nl> + this . dummiedLocations . remove ( name ) ; <nl> + <nl> if ( DEBUG ) <nl> { <nl> FMLLog . finer ( " Registry add : % s % d % s ( req . id % d ) " , name , idToUse , thing , id ) ; <nl> @ @ - 463 , 6 + 472 , 12 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> return idToUse ; <nl> } <nl> <nl> + void markDummy ( ResourceLocation rl , Integer id , I thing ) <nl> + { <nl> + this . dummiedLocations . add ( rl ) ; <nl> + this . addObjectRaw ( id , rl , thing ) ; <nl> + } <nl> + <nl> void addAlias ( ResourceLocation from , ResourceLocation to ) <nl> { <nl> aliases . put ( from , to ) ; <nl> @ @ - 688 , 6 + 703 , 11 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> } <nl> } <nl> <nl> + public void loadDummied ( Set < ResourceLocation > dummied ) <nl> + { <nl> + this . dummiedLocations . addAll ( dummied ) ; <nl> + } <nl> + <nl> public void loadIds ( Map < ResourceLocation , Integer > ids , Map < ResourceLocation , Integer > missingIds , Map < ResourceLocation , Integer [ ] > remappedIds , FMLControlledNamespacedRegistry < I > currentRegistry , ResourceLocation registryName ) <nl> { <nl> for ( Map . Entry < ResourceLocation , Integer > entry : ids . entrySet ( ) ) <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> index 6071989 . . 8bc999c 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> @ @ - 161 , 6 + 161 , 30 @ @ public class PersistentRegistryManager <nl> loadPersistentDataToStagingRegistry ( injectFrozenData , remaps , missing , snapshotEntry , PersistentRegistry . ACTIVE . registrySuperTypes . inverse ( ) . get ( snapshotEntry . getKey ( ) ) ) ; <nl> } <nl> <nl> + / / Handle dummied blocks <nl> + for ( ResourceLocation dummy : snapshot . entries . get ( BLOCKS ) . dummied ) <nl> + { <nl> + / / Currently missing locally , we just inject and carry on <nl> + if ( missing . get ( BLOCKS ) . containsKey ( dummy ) ) <nl> + { <nl> + Integer id = missing . get ( BLOCKS ) . remove ( dummy ) ; <nl> + / / Mark this entry as a dummy <nl> + PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . markDummy ( dummy , id , new BlockDummyAir ( ) ) ; <nl> + } <nl> + else if ( isLocalWorld ) <nl> + { <nl> + / / Carry on , we resuscitated the block <nl> + } <nl> + else <nl> + { <nl> + Integer id = PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . getId ( dummy ) ; <nl> + / / The server believes this is a dummy block identity , but we seem to have one locally . This is likely a conflict <nl> + / / in mod setup - Mark this entry as a dummy <nl> + FMLLog . log ( Level . WARN , " The ID % d is currently locally mapped - it will be replaced with air for this session " , id ) ; <nl> + PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . markDummy ( dummy , id , new BlockDummyAir ( ) ) ; <nl> + } <nl> + } <nl> + <nl> / / If we have missed data , fire the missing mapping event <nl> List < String > missedMappings = Loader . instance ( ) . fireMissingMappingEvent ( missing . get ( BLOCKS ) , missing . get ( ITEMS ) , isLocalWorld , remaps . get ( BLOCKS ) , remaps . get ( ITEMS ) ) ; <nl> / / If there ' s still missed mappings , we return , because that ' s an error <nl> @ @ - 178 , 7 + 202 , 8 @ @ public class PersistentRegistryManager <nl> ResourceLocation rl = missingBlock . getKey ( ) ; <nl> Integer id = missingBlock . getValue ( ) ; <nl> FMLLog . log ( Level . DEBUG , " Replacing id % s named as % s with air block . If the mod becomes available again later , it can reload here " , id , rl ) ; <nl> - PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . add ( id , rl , new BlockDummyAir ( ) ) ; <nl> + / / Mark this entry as a dummy <nl> + PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . markDummy ( rl , id , new BlockDummyAir ( ) ) ; <nl> } <nl> } <nl> / / If we ' re loading up the world from disk , we want to add in the new data that might have been provisioned by mods <nl> @ @ - 301 , 6 + 326 , 8 @ @ public class PersistentRegistryManager <nl> missing . put ( registryName , Maps . < ResourceLocation , Integer > newLinkedHashMap ( ) ) ; <nl> remaps . put ( registryName , Maps . < ResourceLocation , Integer [ ] > newHashMap ( ) ) ; <nl> newRegistry . loadIds ( snapshotEntry . ids , missing . get ( registryName ) , remaps . get ( registryName ) , currentRegistry , registryName ) ; <nl> + / / Load current dummies AFTER the snapshot is loaded <nl> + newRegistry . loadDummied ( snapshotEntry . dummied ) ; <nl> } <nl> <nl> public static boolean isFrozen ( FMLControlledNamespacedRegistry < ? > registry ) <nl> @ @ - 510 , 18 + 537 , 20 @ @ public class PersistentRegistryManager <nl> public final Set < ResourceLocation > substitutions ; <nl> public final Map < ResourceLocation , ResourceLocation > aliases ; <nl> public final Set < Integer > blocked ; <nl> + public final Set < ResourceLocation > dummied ; <nl> <nl> public Entry ( ) <nl> { <nl> - this ( new HashMap < ResourceLocation , Integer > ( ) , new HashSet < ResourceLocation > ( ) , new HashMap < ResourceLocation , ResourceLocation > ( ) , new HashSet < Integer > ( ) ) ; <nl> + this ( new HashMap < ResourceLocation , Integer > ( ) , new HashSet < ResourceLocation > ( ) , new HashMap < ResourceLocation , ResourceLocation > ( ) , new HashSet < Integer > ( ) , new HashSet < ResourceLocation > ( ) ) ; <nl> } <nl> <nl> - public Entry ( Map < ResourceLocation , Integer > ids , Set < ResourceLocation > substitutions , Map < ResourceLocation , ResourceLocation > aliases , Set < Integer > blocked ) <nl> + public Entry ( Map < ResourceLocation , Integer > ids , Set < ResourceLocation > substitutions , Map < ResourceLocation , ResourceLocation > aliases , Set < Integer > blocked , Set < ResourceLocation > dummies ) <nl> { <nl> this . ids = ids ; <nl> this . substitutions = substitutions ; <nl> this . aliases = aliases ; <nl> this . blocked = blocked ; <nl> + this . dummied = dummies ; <nl> } <nl> <nl> public Entry ( FMLControlledNamespacedRegistry < ? > registry ) <nl> @ @ - 530 , 11 + 559 , 13 @ @ public class PersistentRegistryManager <nl> this . substitutions = Sets . newHashSet ( ) ; <nl> this . aliases = Maps . newHashMap ( ) ; <nl> this . blocked = Sets . newHashSet ( ) ; <nl> + this . dummied = Sets . newHashSet ( ) ; <nl> <nl> registry . serializeIds ( this . ids ) ; <nl> registry . serializeSubstitutions ( this . substitutions ) ; <nl> registry . serializeAliases ( this . aliases ) ; <nl> registry . serializeBlockList ( this . blocked ) ; <nl> + registry . serializeDummied ( this . dummied ) ; <nl> } <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / fml / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> index 6161d98 . . 360284c 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> @ @ - 93 , 6 + 93 , 11 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> } <nl> <nl> } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + void setFrom ( FMLControlledNamespacedRegistry < ? > registry ) { <nl> + set ( ( FMLControlledNamespacedRegistry < I > ) registry ) ; <nl> + } <nl> void set ( FMLControlledNamespacedRegistry < I > registry ) <nl> { <nl> if ( this . superType ! = registry . superType ) throw new IllegalArgumentException ( " incompatible registry " ) ; <nl> @ @ - 520 , 4 + 525 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul <nl> if ( this . optionalDefaultKey ! = null ) <nl> Validate . notNull ( this . optionalDefaultObject ) ; <nl> } <nl> + <nl> + <nl> + FMLControlledNamespacedRegistry < I > makeShallowCopy ( ) { <nl> + return new FMLControlledNamespacedRegistry < I > ( optionalDefaultKey , maxId , minId , superType ) ; <nl> + } <nl> } <nl> diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java b / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java <nl> index c8a5e34 . . 9c2e573 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java <nl> @ @ - 142 , 6 + 142 , 9 @ @ public class GameData { <nl> GameDataSnapshot snap = new GameDataSnapshot ( ) ; <nl> snap . entries . put ( " fml : blocks " , new GameDataSnapshot . Entry ( getMain ( ) . getBlockRegistry ( ) ) ) ; <nl> snap . entries . put ( " fml : items " , new GameDataSnapshot . Entry ( getMain ( ) . getItemRegistry ( ) ) ) ; <nl> + for ( Map . Entry < String , FMLControlledNamespacedRegistry < ? > > e : getMain ( ) . genericRegistries . entrySet ( ) ) { <nl> + snap . entries . put ( " fmlgr : " + e . getKey ( ) , new GameDataSnapshot . Entry ( e . getValue ( ) ) ) ; <nl> + } <nl> return snap ; <nl> } <nl> <nl> @ @ - 445 , 6 + 448 , 11 @ @ public class GameData { <nl> List < String > missedMappings = Loader . instance ( ) . fireMissingMappingEvent ( missingBlocks , missingItems , isLocalWorld , newData , remapBlocks , remapItems ) ; <nl> if ( ! missedMappings . isEmpty ( ) ) return missedMappings ; <nl> <nl> + / / If we got here - the load was accepted . We ' ll load generic repositories here . <nl> + / / Generic registries can fail by returning a missing mapping . <nl> + missedMappings = newData . loadGenericRegistries ( snapshot , getMain ( ) ) ; <nl> + if ( ! missedMappings . isEmpty ( ) ) return missedMappings ; <nl> + <nl> if ( injectFrozenData ) / / add blocks + items missing from the map <nl> { <nl> Map < String , Integer > newBlocks = frozen . iBlockRegistry . getEntriesNotIn ( newData . iBlockRegistry ) ; <nl> @ @ - 665 , 6 + 673 , 7 @ @ public class GameData { <nl> iItemRegistry = new FMLControlledNamespacedRegistry < Item > ( null , MAX _ ITEM _ ID , MIN _ ITEM _ ID , Item . class ) ; <nl> availabilityMap = new BitSet ( MAX _ ITEM _ ID + 1 ) ; <nl> blockedIds = new HashSet < Integer > ( ) ; <nl> + genericRegistries = new HashMap < String , FMLControlledNamespacedRegistry < ? > > ( ) ; <nl> } <nl> <nl> private GameData ( GameData data ) <nl> @ @ - 681 , 6 + 690 , 17 @ @ public class GameData { <nl> availabilityMap . or ( data . availabilityMap ) ; <nl> blockedIds . clear ( ) ; <nl> blockedIds . addAll ( data . blockedIds ) ; <nl> + copyGenericRegistries ( data ) ; <nl> + } <nl> + <nl> + private void copyGenericRegistries ( GameData data ) { <nl> + for ( Map . Entry < String , FMLControlledNamespacedRegistry < ? > > e : data . genericRegistries . entrySet ( ) ) { <nl> + FMLControlledNamespacedRegistry < ? > orig = e . getValue ( ) ; <nl> + FMLControlledNamespacedRegistry < ? > copy = orig . makeShallowCopy ( ) ; <nl> + / / UGLY AS FUCK <nl> + copy . setFrom ( orig ) ; <nl> + genericRegistries . put ( e . getKey ( ) , copy ) ; <nl> + } <nl> } <nl> <nl> int register ( Object obj , String name , int idHint ) / / from FMLControlledNamespacedRegistry . addObject <nl> @ @ - 966 , 4 + 986 , 65 @ @ public class GameData { <nl> this . objectList . clear ( ) ; <nl> } <nl> } <nl> + <nl> + private Map < String , FMLControlledNamespacedRegistry < ? > > genericRegistries ; <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + private < T > FMLControlledNamespacedRegistry < T > getGenericRegistry ( String registryName , Class < T > type ) { <nl> + FMLControlledNamespacedRegistry < ? > fmlControlledNamespacedRegistry = genericRegistries . get ( registryName ) ; <nl> + return ( FMLControlledNamespacedRegistry < T > ) fmlControlledNamespacedRegistry ; <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + private < T > FMLControlledNamespacedRegistry < T > createGenericRegistry ( String registryName , Class < T > type , int minId , int maxId ) { <nl> + FMLControlledNamespacedRegistry < ? > fmlControlledNamespacedRegistry = new FMLControlledNamespacedRegistry < T > ( null , maxId , minId , type ) ; <nl> + return ( FMLControlledNamespacedRegistry < T > ) fmlControlledNamespacedRegistry ; <nl> + } <nl> + <nl> + public static < T > FMLControlledNamespacedRegistry < T > createRegistry ( String registryName , Class < T > type , int minId , int maxId ) { <nl> + return getMain ( ) . createGenericRegistry ( registryName , type , minId , maxId ) ; <nl> + } <nl> + private List < String > loadGenericRegistries ( GameDataSnapshot snapshot , GameData existing ) { <nl> + List < String > result = Lists . newArrayList ( ) ; <nl> + for ( Map . Entry < String , FMLControlledNamespacedRegistry < ? > > e : existing . genericRegistries . entrySet ( ) ) <nl> + { <nl> + String regName = e . getKey ( ) ; <nl> + FMLControlledNamespacedRegistry < ? > registry = e . getValue ( ) ; <nl> + FMLControlledNamespacedRegistry < ? > newRegistry = genericRegistries . get ( regName ) ; <nl> + GameDataSnapshot . Entry regSnap = snapshot . entries . get ( " fmlgr : " + regName ) ; <nl> + if ( regSnap = = null ) { <nl> + FMLLog . info ( " Weird , there was no registry data for registry % s found in the snapshot " , regName ) ; <nl> + continue ; <nl> + } <nl> + <nl> + for ( Entry < String , Integer > entry : regSnap . ids . entrySet ( ) ) <nl> + { <nl> + String entryName = entry . getKey ( ) ; <nl> + int entryId = entry . getValue ( ) ; <nl> + int currId = registry . getId ( entryName ) ; <nl> + <nl> + if ( currId = = - 1 ) <nl> + { <nl> + FMLLog . info ( " Found a missing id in registry % s from the world % s " , regName , entryName ) ; <nl> + result . add ( regName + " { " + entryName + " } = " + entryId ) ; <nl> + continue ; / / no block / item - > nothing to add <nl> + } <nl> + else if ( currId ! = entryId ) <nl> + { <nl> + FMLLog . fine ( " Fixed registry % s id mismatch % s : % d ( init ) - > % d ( map ) . " , regName , entryName , currId , entryId ) ; <nl> + } <nl> + <nl> + newRegistry . register ( entryId , entryName , registry . getRaw ( entryName ) ) ; <nl> + <nl> + } <nl> + } <nl> + return result ; <nl> + } <nl> + <nl> + public static < T > FMLControlledNamespacedRegistry < T > getRegistry ( String registryName , Class < T > type ) { <nl> + return getMain ( ) . getGenericRegistry ( registryName , type ) ; <nl> + } <nl> + <nl> + <nl> + <nl> } <nl> \ No newline at end of file <nl> diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java b / fml / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java <nl> index cf3999a . . b4af637 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java <nl> @ @ - 20 , 9 + 20 , 11 @ @ import java . util . Collections ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . Random ; <nl> + import java . util . Set ; <nl> <nl> import org . apache . commons . lang3 . Validate ; <nl> <nl> + import net . minecraft . block . Block ; <nl> import net . minecraft . entity . passive . EntityVillager ; <nl> import net . minecraft . entity . passive . EntityVillager . * ; <nl> import net . minecraft . init . Blocks ; <nl> @ @ - 31 , 6 + 33 , 8 @ @ import net . minecraft . item . EnumDyeColor ; <nl> import net . minecraft . item . Item ; <nl> import net . minecraft . item . ItemStack ; <nl> import net . minecraft . util . EnumFacing ; <nl> + import net . minecraft . util . ObjectIntIdentityMap ; <nl> + import net . minecraft . util . RegistryNamespacedDefaultedByKey ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraft . util . Tuple ; <nl> import net . minecraft . village . MerchantRecipeList ; <nl> @ @ - 112 , 6 + 116 , 7 @ @ public class VillagerRegistry <nl> * Register your villager id <nl> * @ param id <nl> * / <nl> + @ Deprecated / / Doesn ' t work at all . <nl> public void registerVillagerId ( int id ) <nl> { <nl> if ( newVillagerIds . contains ( id ) ) <nl> @ @ - 128 , 6 + 133 , 7 @ @ public class VillagerRegistry <nl> * @ param villagerSkin <nl> * / <nl> @ SideOnly ( Side . CLIENT ) <nl> + @ Deprecated / / Doesn ' t work at all . <nl> public void registerVillagerSkin ( int villagerId , ResourceLocation villagerSkin ) <nl> { <nl> if ( newVillagers = = null ) <nl> @ @ - 154 , 6 + 160 , 7 @ @ public class VillagerRegistry <nl> * @ param defaultSkin <nl> * / <nl> @ SideOnly ( Side . CLIENT ) <nl> + @ Deprecated / / Doesn ' t work at all . <nl> public static ResourceLocation getVillagerSkin ( int villagerType , ResourceLocation defaultSkin ) <nl> { <nl> if ( instance ( ) . newVillagers ! = null & & instance ( ) . newVillagers . containsKey ( villagerType ) ) <nl> @ @ - 168 , 6 + 175 , 7 @ @ public class VillagerRegistry <nl> * <nl> * @ return newVillagerIds <nl> * / <nl> + @ Deprecated / / Doesn ' t work at all . <nl> public static Collection < Integer > getRegisteredVillagers ( ) <nl> { <nl> return Collections . unmodifiableCollection ( instance ( ) . newVillagerIds ) ; <nl> @ @ - 191 , 12 + 199 , 15 @ @ public class VillagerRegistry <nl> <nl> public void register ( VillagerProfession prof ) <nl> { <nl> - / / blah <nl> + register ( prof , - 1 ) ; <nl> + } <nl> + private void register ( VillagerProfession prof , int id ) <nl> + { <nl> + professions . register ( id , prof . name , prof ) ; <nl> } <nl> <nl> private boolean hasInit = false ; <nl> - private List < VillagerProfession > professions = Lists . newArrayList ( ) ; <nl> - <nl> + private FMLControlledNamespacedRegistry < VillagerProfession > professions = GameData . createRegistry ( " villagerprofessions " , VillagerProfession . class , 0 , 1024 ) ; <nl> <nl> <nl> private void init ( ) <nl> @ @ - 206 , 7 + 217 , 7 @ @ public class VillagerRegistry <nl> <nl> VillagerProfession prof = new VillagerProfession ( " minecraft : farmer " , " minecraft : textures / entity / villager / farmer . png " ) ; <nl> { <nl> - register ( prof ) ; <nl> + register ( prof , 0 ) ; <nl> ( new VillagerCareer ( prof , " farmer " ) ) . init ( VanillaTrades . trades [ 0 ] [ 0 ] ) ; <nl> ( new VillagerCareer ( prof , " fisherman " ) ) . init ( VanillaTrades . trades [ 0 ] [ 1 ] ) ; <nl> ( new VillagerCareer ( prof , " shepherd " ) ) . init ( VanillaTrades . trades [ 0 ] [ 2 ] ) ; <nl> @ @ - 214 , 24 + 225 , 24 @ @ public class VillagerRegistry <nl> } <nl> prof = new VillagerProfession ( " minecraft : librarian " , " minecraft : textures / entity / villager / librarian . png " ) ; <nl> { <nl> - register ( prof ) ; <nl> + register ( prof , 1 ) ; <nl> ( new VillagerCareer ( prof , " librarian " ) ) . init ( VanillaTrades . trades [ 1 ] [ 0 ] ) ; <nl> } <nl> prof = new VillagerProfession ( " minecraft : priest " , " minecraft : textures / entity / villager / priest . png " ) ; <nl> { <nl> - register ( prof ) ; <nl> + register ( prof , 2 ) ; <nl> ( new VillagerCareer ( prof , " cleric " ) ) . init ( VanillaTrades . trades [ 2 ] [ 0 ] ) ; <nl> } <nl> prof = new VillagerProfession ( " minecraft : smith " , " minecraft : textures / entity / villager / smith . png " ) ; <nl> { <nl> - register ( prof ) ; <nl> + register ( prof , 3 ) ; <nl> ( new VillagerCareer ( prof , " armor " ) ) . init ( VanillaTrades . trades [ 3 ] [ 0 ] ) ; <nl> ( new VillagerCareer ( prof , " weapon " ) ) . init ( VanillaTrades . trades [ 3 ] [ 1 ] ) ; <nl> ( new VillagerCareer ( prof , " tool " ) ) . init ( VanillaTrades . trades [ 3 ] [ 2 ] ) ; <nl> } <nl> prof = new VillagerProfession ( " minecraft : butcher " , " minecraft : textures / entity / villager / butcher . png " ) ; <nl> { <nl> - register ( prof ) ; <nl> + register ( prof , 4 ) ; <nl> ( new VillagerCareer ( prof , " butcher " ) ) . init ( VanillaTrades . trades [ 4 ] [ 0 ] ) ; <nl> ( new VillagerCareer ( prof , " leather " ) ) . init ( VanillaTrades . trades [ 4 ] [ 1 ] ) ; <nl> } <nl> @ @ - 242 , 11 + 253 , 13 @ @ public class VillagerRegistry <nl> private ResourceLocation name ; <nl> private ResourceLocation texture ; <nl> private List < VillagerCareer > careers = Lists . newArrayList ( ) ; <nl> + private RegistryDelegate < VillagerProfession > delegate = GameData . getRegistry ( " villagerprofessions " , VillagerProfession . class ) . getDelegate ( this , VillagerProfession . class ) ; <nl> <nl> public VillagerProfession ( String name , String texture ) <nl> { <nl> this . name = new ResourceLocation ( name ) ; <nl> this . texture = new ResourceLocation ( texture ) ; <nl> + ( ( RegistryDelegate . Delegate < VillagerProfession > ) delegate ) . setName ( name ) ; <nl> } <nl> <nl> private void register ( VillagerCareer career ) <nl> @ @ - 293 , 6 + 306 , 8 @ @ public class VillagerRegistry <nl> * / <nl> public static void setRandomProfession ( EntityVillager entity , Random rand ) <nl> { <nl> + Set < String > entries = INSTANCE . professions . getKeys ( ) ; <nl> + int prof = rand . nextInt ( entries . size ( ) ) ; <nl> / / TODO : Grab id range from internal registry <nl> entity . setProfession ( rand . nextInt ( 5 ) ) ; <nl> }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 index 92c2258 . . c1a77d1 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 @ @ - 154 , 6 + 154 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 blocked [ idx + + ] = i ; 
 } 
 data . setIntArray ( " blocked " , blocked ) ; 
 + NBTTagList dummied = new NBTTagList ( ) ; 
 + for ( ResourceLocation entry : e . getValue ( ) . dummied ) 
 + { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setString ( " K " , entry . toString ( ) ) ; 
 + dummied . appendTag ( tag ) ; 
 + } 
 + data . setTag ( " dummied " , dummied ) ; 
 } 
 return fmlData ; 
 } 
 @ @ - 297 , 6 + 305 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 { 
 entry . blocked . add ( i ) ; 
 } 
 + / / save doesn ' t have dummied list 
 + if ( ! regs . getCompoundTag ( key ) . hasKey ( " dummied " ) ) return ; 
 + list = regs . getCompoundTag ( key ) . getTagList ( " dummied " , 10 ) ; 
 + for ( int x = 0 ; x < list . tagCount ( ) ; x + + ) 
 + { 
 + NBTTagCompound e = list . getCompoundTagAt ( x ) ; 
 + entry . dummied . add ( new ResourceLocation ( e . getString ( " K " ) ) ) ; 
 + } 
 } 
 failedElements = PersistentRegistryManager . injectSnapshot ( snapshot , true , true ) ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 index aa09692 . . d17393c 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 @ @ - 105 , 11 + 105 , 12 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 PersistentRegistryManager . GameDataSnapshot . Entry entry = new PersistentRegistryManager . GameDataSnapshot . Entry ( ) ; 
 entry . ids . putAll ( pkt . getIdMap ( ) ) ; 
 entry . substitutions . addAll ( pkt . getSubstitutions ( ) ) ; 
 + entry . dummied . addAll ( pkt . getDummied ( ) ) ; 
 snap . entries . put ( pkt . getName ( ) , entry ) ; 
 
 if ( pkt . hasMore ( ) ) 
 { 
 - FMLLog . fine ( " Received Mod Registry mapping for % s : % d IDs % d subs " , pkt . getName ( ) , entry . ids . size ( ) , entry . substitutions . size ( ) ) ; 
 + FMLLog . fine ( " Received Mod Registry mapping for % s : % d IDs % d subs % d dummied " , pkt . getName ( ) , entry . ids . size ( ) , entry . substitutions . size ( ) , entry . dummied . size ( ) ) ; 
 return WAITINGSERVERCOMPLETE ; 
 } 
 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java 
 index b6f797a . . e24ed76 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java 
 @ @ - 165 , 12 + 165 , 14 @ @ public abstract class FMLHandshakeMessage { 
 this . name = name ; 
 this . ids = entry . ids ; 
 this . substitutions = entry . substitutions ; 
 + this . dummied = entry . dummied ; 
 } 
 
 private boolean hasMore ; 
 private ResourceLocation name ; 
 private Map < ResourceLocation , Integer > ids ; 
 private Set < ResourceLocation > substitutions ; 
 + private Set < ResourceLocation > dummied ; 
 
 @ Override 
 public void fromBytes ( ByteBuf buffer ) 
 @ @ - 193 , 6 + 195 , 15 @ @ public abstract class FMLHandshakeMessage { 
 { 
 substitutions . add ( new ResourceLocation ( ByteBufUtils . readUTF8String ( buffer ) ) ) ; 
 } 
 + dummied = Sets . newHashSet ( ) ; 
 + / / if the dummied list isn ' t present - probably an older server 
 + if ( ! buffer . isReadable ( ) ) return ; 
 + length = ByteBufUtils . readVarInt ( buffer , 3 ) ; 
 + 
 + for ( int i = 0 ; i < length ; i + + ) 
 + { 
 + dummied . add ( new ResourceLocation ( ByteBufUtils . readUTF8String ( buffer ) ) ) ; 
 + } 
 / / if ( ! buffer . isReadable ( ) ) return ; / / In case we expand 
 } 
 
 @ @ - 214 , 6 + 225 , 11 @ @ public abstract class FMLHandshakeMessage { 
 { 
 ByteBufUtils . writeUTF8String ( buffer , entry . toString ( ) ) ; 
 } 
 + ByteBufUtils . writeVarInt ( buffer , dummied . size ( ) , 3 ) ; 
 + for ( ResourceLocation entry : dummied ) 
 + { 
 + ByteBufUtils . writeUTF8String ( buffer , entry . toString ( ) ) ; 
 + } 
 } 
 
 public Map < ResourceLocation , Integer > getIdMap ( ) 
 @ @ - 224 , 6 + 240 , 7 @ @ public abstract class FMLHandshakeMessage { 
 { 
 return substitutions ; 
 } 
 + public Set < ResourceLocation > getDummied ( ) { return dummied ; } 
 public ResourceLocation getName ( ) 
 { 
 return this . name ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 index b4a5670 . . 3e2a5c6 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 @ @ - 54 , 6 + 54 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 * / 
 private final Set < Integer > blockedIds = Sets . newHashSet ( ) ; 
 
 + private final Set < ResourceLocation > dummiedLocations = Sets . newHashSet ( ) ; 
 + 
 private final BitSet availabilityMap ; 
 
 private final AddCallback < I > addCallback ; 
 @ @ - 164 , 6 + 166 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 this . persistentSubstitutions . clear ( ) ; 
 this . persistentSubstitutions . putAll ( otherRegistry . getPersistentSubstitutions ( ) ) ; 
 this . activeSubstitutions . clear ( ) ; 
 + this . dummiedLocations . clear ( ) ; 
 + this . dummiedLocations . addAll ( otherRegistry . dummiedLocations ) ; 
 
 underlyingIntegerMap = new ObjectIntIdentityMap < I > ( ) ; 
 registryObjects . clear ( ) ; 
 @ @ - 384 , 6 + 388 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 set . addAll ( activeSubstitutions . keySet ( ) ) ; 
 } 
 
 + public void serializeDummied ( Set < ResourceLocation > set ) { set . addAll ( this . dummiedLocations ) ; } 
 + 
 + 
 / * * 
 * Add the specified object to the registry . 
 * 
 @ @ - 456 , 6 + 463 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 { 
 getExistingDelegate ( thing ) . setResourceName ( name ) ; 
 } 
 + this . dummiedLocations . remove ( name ) ; 
 + 
 if ( DEBUG ) 
 { 
 FMLLog . finer ( " Registry add : % s % d % s ( req . id % d ) " , name , idToUse , thing , id ) ; 
 @ @ - 463 , 6 + 472 , 12 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 return idToUse ; 
 } 
 
 + void markDummy ( ResourceLocation rl , Integer id , I thing ) 
 + { 
 + this . dummiedLocations . add ( rl ) ; 
 + this . addObjectRaw ( id , rl , thing ) ; 
 + } 
 + 
 void addAlias ( ResourceLocation from , ResourceLocation to ) 
 { 
 aliases . put ( from , to ) ; 
 @ @ - 688 , 6 + 703 , 11 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 } 
 } 
 
 + public void loadDummied ( Set < ResourceLocation > dummied ) 
 + { 
 + this . dummiedLocations . addAll ( dummied ) ; 
 + } 
 + 
 public void loadIds ( Map < ResourceLocation , Integer > ids , Map < ResourceLocation , Integer > missingIds , Map < ResourceLocation , Integer [ ] > remappedIds , FMLControlledNamespacedRegistry < I > currentRegistry , ResourceLocation registryName ) 
 { 
 for ( Map . Entry < ResourceLocation , Integer > entry : ids . entrySet ( ) ) 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 index 6071989 . . 8bc999c 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 @ @ - 161 , 6 + 161 , 30 @ @ public class PersistentRegistryManager 
 loadPersistentDataToStagingRegistry ( injectFrozenData , remaps , missing , snapshotEntry , PersistentRegistry . ACTIVE . registrySuperTypes . inverse ( ) . get ( snapshotEntry . getKey ( ) ) ) ; 
 } 
 
 + / / Handle dummied blocks 
 + for ( ResourceLocation dummy : snapshot . entries . get ( BLOCKS ) . dummied ) 
 + { 
 + / / Currently missing locally , we just inject and carry on 
 + if ( missing . get ( BLOCKS ) . containsKey ( dummy ) ) 
 + { 
 + Integer id = missing . get ( BLOCKS ) . remove ( dummy ) ; 
 + / / Mark this entry as a dummy 
 + PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . markDummy ( dummy , id , new BlockDummyAir ( ) ) ; 
 + } 
 + else if ( isLocalWorld ) 
 + { 
 + / / Carry on , we resuscitated the block 
 + } 
 + else 
 + { 
 + Integer id = PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . getId ( dummy ) ; 
 + / / The server believes this is a dummy block identity , but we seem to have one locally . This is likely a conflict 
 + / / in mod setup - Mark this entry as a dummy 
 + FMLLog . log ( Level . WARN , " The ID % d is currently locally mapped - it will be replaced with air for this session " , id ) ; 
 + PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . markDummy ( dummy , id , new BlockDummyAir ( ) ) ; 
 + } 
 + } 
 + 
 / / If we have missed data , fire the missing mapping event 
 List < String > missedMappings = Loader . instance ( ) . fireMissingMappingEvent ( missing . get ( BLOCKS ) , missing . get ( ITEMS ) , isLocalWorld , remaps . get ( BLOCKS ) , remaps . get ( ITEMS ) ) ; 
 / / If there ' s still missed mappings , we return , because that ' s an error 
 @ @ - 178 , 7 + 202 , 8 @ @ public class PersistentRegistryManager 
 ResourceLocation rl = missingBlock . getKey ( ) ; 
 Integer id = missingBlock . getValue ( ) ; 
 FMLLog . log ( Level . DEBUG , " Replacing id % s named as % s with air block . If the mod becomes available again later , it can reload here " , id , rl ) ; 
 - PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . add ( id , rl , new BlockDummyAir ( ) ) ; 
 + / / Mark this entry as a dummy 
 + PersistentRegistry . STAGING . getRegistry ( BLOCKS , Block . class ) . markDummy ( rl , id , new BlockDummyAir ( ) ) ; 
 } 
 } 
 / / If we ' re loading up the world from disk , we want to add in the new data that might have been provisioned by mods 
 @ @ - 301 , 6 + 326 , 8 @ @ public class PersistentRegistryManager 
 missing . put ( registryName , Maps . < ResourceLocation , Integer > newLinkedHashMap ( ) ) ; 
 remaps . put ( registryName , Maps . < ResourceLocation , Integer [ ] > newHashMap ( ) ) ; 
 newRegistry . loadIds ( snapshotEntry . ids , missing . get ( registryName ) , remaps . get ( registryName ) , currentRegistry , registryName ) ; 
 + / / Load current dummies AFTER the snapshot is loaded 
 + newRegistry . loadDummied ( snapshotEntry . dummied ) ; 
 } 
 
 public static boolean isFrozen ( FMLControlledNamespacedRegistry < ? > registry ) 
 @ @ - 510 , 18 + 537 , 20 @ @ public class PersistentRegistryManager 
 public final Set < ResourceLocation > substitutions ; 
 public final Map < ResourceLocation , ResourceLocation > aliases ; 
 public final Set < Integer > blocked ; 
 + public final Set < ResourceLocation > dummied ; 
 
 public Entry ( ) 
 { 
 - this ( new HashMap < ResourceLocation , Integer > ( ) , new HashSet < ResourceLocation > ( ) , new HashMap < ResourceLocation , ResourceLocation > ( ) , new HashSet < Integer > ( ) ) ; 
 + this ( new HashMap < ResourceLocation , Integer > ( ) , new HashSet < ResourceLocation > ( ) , new HashMap < ResourceLocation , ResourceLocation > ( ) , new HashSet < Integer > ( ) , new HashSet < ResourceLocation > ( ) ) ; 
 } 
 
 - public Entry ( Map < ResourceLocation , Integer > ids , Set < ResourceLocation > substitutions , Map < ResourceLocation , ResourceLocation > aliases , Set < Integer > blocked ) 
 + public Entry ( Map < ResourceLocation , Integer > ids , Set < ResourceLocation > substitutions , Map < ResourceLocation , ResourceLocation > aliases , Set < Integer > blocked , Set < ResourceLocation > dummies ) 
 { 
 this . ids = ids ; 
 this . substitutions = substitutions ; 
 this . aliases = aliases ; 
 this . blocked = blocked ; 
 + this . dummied = dummies ; 
 } 
 
 public Entry ( FMLControlledNamespacedRegistry < ? > registry ) 
 @ @ - 530 , 11 + 559 , 13 @ @ public class PersistentRegistryManager 
 this . substitutions = Sets . newHashSet ( ) ; 
 this . aliases = Maps . newHashMap ( ) ; 
 this . blocked = Sets . newHashSet ( ) ; 
 + this . dummied = Sets . newHashSet ( ) ; 
 
 registry . serializeIds ( this . ids ) ; 
 registry . serializeSubstitutions ( this . substitutions ) ; 
 registry . serializeAliases ( this . aliases ) ; 
 registry . serializeBlockList ( this . blocked ) ; 
 + registry . serializeDummied ( this . dummied ) ; 
 } 
 } 


NEAREST DIFF:
diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / fml / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 index 6161d98 . . 360284c 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 @ @ - 93 , 6 + 93 , 11 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 } 
 
 } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + void setFrom ( FMLControlledNamespacedRegistry < ? > registry ) { 
 + set ( ( FMLControlledNamespacedRegistry < I > ) registry ) ; 
 + } 
 void set ( FMLControlledNamespacedRegistry < I > registry ) 
 { 
 if ( this . superType ! = registry . superType ) throw new IllegalArgumentException ( " incompatible registry " ) ; 
 @ @ - 520 , 4 + 525 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespacedDefaul 
 if ( this . optionalDefaultKey ! = null ) 
 Validate . notNull ( this . optionalDefaultObject ) ; 
 } 
 + 
 + 
 + FMLControlledNamespacedRegistry < I > makeShallowCopy ( ) { 
 + return new FMLControlledNamespacedRegistry < I > ( optionalDefaultKey , maxId , minId , superType ) ; 
 + } 
 } 
 diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java b / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java 
 index c8a5e34 . . 9c2e573 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / registry / GameData . java 
 @ @ - 142 , 6 + 142 , 9 @ @ public class GameData { 
 GameDataSnapshot snap = new GameDataSnapshot ( ) ; 
 snap . entries . put ( " fml : blocks " , new GameDataSnapshot . Entry ( getMain ( ) . getBlockRegistry ( ) ) ) ; 
 snap . entries . put ( " fml : items " , new GameDataSnapshot . Entry ( getMain ( ) . getItemRegistry ( ) ) ) ; 
 + for ( Map . Entry < String , FMLControlledNamespacedRegistry < ? > > e : getMain ( ) . genericRegistries . entrySet ( ) ) { 
 + snap . entries . put ( " fmlgr : " + e . getKey ( ) , new GameDataSnapshot . Entry ( e . getValue ( ) ) ) ; 
 + } 
 return snap ; 
 } 
 
 @ @ - 445 , 6 + 448 , 11 @ @ public class GameData { 
 List < String > missedMappings = Loader . instance ( ) . fireMissingMappingEvent ( missingBlocks , missingItems , isLocalWorld , newData , remapBlocks , remapItems ) ; 
 if ( ! missedMappings . isEmpty ( ) ) return missedMappings ; 
 
 + / / If we got here - the load was accepted . We ' ll load generic repositories here . 
 + / / Generic registries can fail by returning a missing mapping . 
 + missedMappings = newData . loadGenericRegistries ( snapshot , getMain ( ) ) ; 
 + if ( ! missedMappings . isEmpty ( ) ) return missedMappings ; 
 + 
 if ( injectFrozenData ) / / add blocks + items missing from the map 
 { 
 Map < String , Integer > newBlocks = frozen . iBlockRegistry . getEntriesNotIn ( newData . iBlockRegistry ) ; 
 @ @ - 665 , 6 + 673 , 7 @ @ public class GameData { 
 iItemRegistry = new FMLControlledNamespacedRegistry < Item > ( null , MAX _ ITEM _ ID , MIN _ ITEM _ ID , Item . class ) ; 
 availabilityMap = new BitSet ( MAX _ ITEM _ ID + 1 ) ; 
 blockedIds = new HashSet < Integer > ( ) ; 
 + genericRegistries = new HashMap < String , FMLControlledNamespacedRegistry < ? > > ( ) ; 
 } 
 
 private GameData ( GameData data ) 
 @ @ - 681 , 6 + 690 , 17 @ @ public class GameData { 
 availabilityMap . or ( data . availabilityMap ) ; 
 blockedIds . clear ( ) ; 
 blockedIds . addAll ( data . blockedIds ) ; 
 + copyGenericRegistries ( data ) ; 
 + } 
 + 
 + private void copyGenericRegistries ( GameData data ) { 
 + for ( Map . Entry < String , FMLControlledNamespacedRegistry < ? > > e : data . genericRegistries . entrySet ( ) ) { 
 + FMLControlledNamespacedRegistry < ? > orig = e . getValue ( ) ; 
 + FMLControlledNamespacedRegistry < ? > copy = orig . makeShallowCopy ( ) ; 
 + / / UGLY AS FUCK 
 + copy . setFrom ( orig ) ; 
 + genericRegistries . put ( e . getKey ( ) , copy ) ; 
 + } 
 } 
 
 int register ( Object obj , String name , int idHint ) / / from FMLControlledNamespacedRegistry . addObject 
 @ @ - 966 , 4 + 986 , 65 @ @ public class GameData { 
 this . objectList . clear ( ) ; 
 } 
 } 
 + 
 + private Map < String , FMLControlledNamespacedRegistry < ? > > genericRegistries ; 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + private < T > FMLControlledNamespacedRegistry < T > getGenericRegistry ( String registryName , Class < T > type ) { 
 + FMLControlledNamespacedRegistry < ? > fmlControlledNamespacedRegistry = genericRegistries . get ( registryName ) ; 
 + return ( FMLControlledNamespacedRegistry < T > ) fmlControlledNamespacedRegistry ; 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + private < T > FMLControlledNamespacedRegistry < T > createGenericRegistry ( String registryName , Class < T > type , int minId , int maxId ) { 
 + FMLControlledNamespacedRegistry < ? > fmlControlledNamespacedRegistry = new FMLControlledNamespacedRegistry < T > ( null , maxId , minId , type ) ; 
 + return ( FMLControlledNamespacedRegistry < T > ) fmlControlledNamespacedRegistry ; 
 + } 
 + 
 + public static < T > FMLControlledNamespacedRegistry < T > createRegistry ( String registryName , Class < T > type , int minId , int maxId ) { 
 + return getMain ( ) . createGenericRegistry ( registryName , type , minId , maxId ) ; 
 + } 
 + private List < String > loadGenericRegistries ( GameDataSnapshot snapshot , GameData existing ) { 
 + List < String > result = Lists . newArrayList ( ) ; 
 + for ( Map . Entry < String , FMLControlledNamespacedRegistry < ? > > e : existing . genericRegistries . entrySet ( ) ) 
 + { 
 + String regName = e . getKey ( ) ; 
 + FMLControlledNamespacedRegistry < ? > registry = e . getValue ( ) ; 
 + FMLControlledNamespacedRegistry < ? > newRegistry = genericRegistries . get ( regName ) ; 
 + GameDataSnapshot . Entry regSnap = snapshot . entries . get ( " fmlgr : " + regName ) ; 
 + if ( regSnap = = null ) { 
 + FMLLog . info ( " Weird , there was no registry data for registry % s found in the snapshot " , regName ) ; 
 + continue ; 
 + } 
 + 
 + for ( Entry < String , Integer > entry : regSnap . ids . entrySet ( ) ) 
 + { 
 + String entryName = entry . getKey ( ) ; 
 + int entryId = entry . getValue ( ) ; 
 + int currId = registry . getId ( entryName ) ; 
 + 
 + if ( currId = = - 1 ) 
 + { 
 + FMLLog . info ( " Found a missing id in registry % s from the world % s " , regName , entryName ) ; 
 + result . add ( regName + " { " + entryName + " } = " + entryId ) ; 
 + continue ; / / no block / item - > nothing to add 
 + } 
 + else if ( currId ! = entryId ) 
 + { 
 + FMLLog . fine ( " Fixed registry % s id mismatch % s : % d ( init ) - > % d ( map ) . " , regName , entryName , currId , entryId ) ; 
 + } 
 + 
 + newRegistry . register ( entryId , entryName , registry . getRaw ( entryName ) ) ; 
 + 
 + } 
 + } 
 + return result ; 
 + } 
 + 
 + public static < T > FMLControlledNamespacedRegistry < T > getRegistry ( String registryName , Class < T > type ) { 
 + return getMain ( ) . getGenericRegistry ( registryName , type ) ; 
 + } 
 + 
 + 
 + 
 } 
 \ No newline at end of file 
 diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java b / fml / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java 
 index cf3999a . . b4af637 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / registry / VillagerRegistry . java 
 @ @ - 20 , 9 + 20 , 11 @ @ import java . util . Collections ; 
 import java . util . List ; 
 import java . util . Map ; 
 import java . util . Random ; 
 + import java . util . Set ; 
 
 import org . apache . commons . lang3 . Validate ; 
 
 + import net . minecraft . block . Block ; 
 import net . minecraft . entity . passive . EntityVillager ; 
 import net . minecraft . entity . passive . EntityVillager . * ; 
 import net . minecraft . init . Blocks ; 
 @ @ - 31 , 6 + 33 , 8 @ @ import net . minecraft . item . EnumDyeColor ; 
 import net . minecraft . item . Item ; 
 import net . minecraft . item . ItemStack ; 
 import net . minecraft . util . EnumFacing ; 
 + import net . minecraft . util . ObjectIntIdentityMap ; 
 + import net . minecraft . util . RegistryNamespacedDefaultedByKey ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraft . util . Tuple ; 
 import net . minecraft . village . MerchantRecipeList ; 
 @ @ - 112 , 6 + 116 , 7 @ @ public class VillagerRegistry 
 * Register your villager id 
 * @ param id 
 * / 
 + @ Deprecated / / Doesn ' t work at all . 
 public void registerVillagerId ( int id ) 
 { 
 if ( newVillagerIds . contains ( id ) ) 
 @ @ - 128 , 6 + 133 , 7 @ @ public class VillagerRegistry 
 * @ param villagerSkin 
 * / 
 @ SideOnly ( Side . CLIENT ) 
 + @ Deprecated / / Doesn ' t work at all . 
 public void registerVillagerSkin ( int villagerId , ResourceLocation villagerSkin ) 
 { 
 if ( newVillagers = = null ) 
 @ @ - 154 , 6 + 160 , 7 @ @ public class VillagerRegistry 
 * @ param defaultSkin 
 * / 
 @ SideOnly ( Side . CLIENT ) 
 + @ Deprecated / / Doesn ' t work at all . 
 public static ResourceLocation getVillagerSkin ( int villagerType , ResourceLocation defaultSkin ) 
 { 
 if ( instance ( ) . newVillagers ! = null & & instance ( ) . newVillagers . containsKey ( villagerType ) ) 
 @ @ - 168 , 6 + 175 , 7 @ @ public class VillagerRegistry 
 * 
 * @ return newVillagerIds 
 * / 
 + @ Deprecated / / Doesn ' t work at all . 
 public static Collection < Integer > getRegisteredVillagers ( ) 
 { 
 return Collections . unmodifiableCollection ( instance ( ) . newVillagerIds ) ; 
 @ @ - 191 , 12 + 199 , 15 @ @ public class VillagerRegistry 
 
 public void register ( VillagerProfession prof ) 
 { 
 - / / blah 
 + register ( prof , - 1 ) ; 
 + } 
 + private void register ( VillagerProfession prof , int id ) 
 + { 
 + professions . register ( id , prof . name , prof ) ; 
 } 
 
 private boolean hasInit = false ; 
 - private List < VillagerProfession > professions = Lists . newArrayList ( ) ; 
 - 
 + private FMLControlledNamespacedRegistry < VillagerProfession > professions = GameData . createRegistry ( " villagerprofessions " , VillagerProfession . class , 0 , 1024 ) ; 
 
 
 private void init ( ) 
 @ @ - 206 , 7 + 217 , 7 @ @ public class VillagerRegistry 
 
 VillagerProfession prof = new VillagerProfession ( " minecraft : farmer " , " minecraft : textures / entity / villager / farmer . png " ) ; 
 { 
 - register ( prof ) ; 
 + register ( prof , 0 ) ; 
 ( new VillagerCareer ( prof , " farmer " ) ) . init ( VanillaTrades . trades [ 0 ] [ 0 ] ) ; 
 ( new VillagerCareer ( prof , " fisherman " ) ) . init ( VanillaTrades . trades [ 0 ] [ 1 ] ) ; 
 ( new VillagerCareer ( prof , " shepherd " ) ) . init ( VanillaTrades . trades [ 0 ] [ 2 ] ) ; 
 @ @ - 214 , 24 + 225 , 24 @ @ public class VillagerRegistry 
 } 
 prof = new VillagerProfession ( " minecraft : librarian " , " minecraft : textures / entity / villager / librarian . png " ) ; 
 { 
 - register ( prof ) ; 
 + register ( prof , 1 ) ; 
 ( new VillagerCareer ( prof , " librarian " ) ) . init ( VanillaTrades . trades [ 1 ] [ 0 ] ) ; 
 } 
 prof = new VillagerProfession ( " minecraft : priest " , " minecraft : textures / entity / villager / priest . png " ) ; 
 { 
 - register ( prof ) ; 
 + register ( prof , 2 ) ; 
 ( new VillagerCareer ( prof , " cleric " ) ) . init ( VanillaTrades . trades [ 2 ] [ 0 ] ) ; 
 } 
 prof = new VillagerProfession ( " minecraft : smith " , " minecraft : textures / entity / villager / smith . png " ) ; 
 { 
 - register ( prof ) ; 
 + register ( prof , 3 ) ; 
 ( new VillagerCareer ( prof , " armor " ) ) . init ( VanillaTrades . trades [ 3 ] [ 0 ] ) ; 
 ( new VillagerCareer ( prof , " weapon " ) ) . init ( VanillaTrades . trades [ 3 ] [ 1 ] ) ; 
 ( new VillagerCareer ( prof , " tool " ) ) . init ( VanillaTrades . trades [ 3 ] [ 2 ] ) ; 
 } 
 prof = new VillagerProfession ( " minecraft : butcher " , " minecraft : textures / entity / villager / butcher . png " ) ; 
 { 
 - register ( prof ) ; 
 + register ( prof , 4 ) ; 
 ( new VillagerCareer ( prof , " butcher " ) ) . init ( VanillaTrades . trades [ 4 ] [ 0 ] ) ; 
 ( new VillagerCareer ( prof , " leather " ) ) . init ( VanillaTrades . trades [ 4 ] [ 1 ] ) ; 
 } 
 @ @ - 242 , 11 + 253 , 13 @ @ public class VillagerRegistry 
 private ResourceLocation name ; 
 private ResourceLocation texture ; 
 private List < VillagerCareer > careers = Lists . newArrayList ( ) ; 
 + private RegistryDelegate < VillagerProfession > delegate = GameData . getRegistry ( " villagerprofessions " , VillagerProfession . class ) . getDelegate ( this , VillagerProfession . class ) ; 
 
 public VillagerProfession ( String name , String texture ) 
 { 
 this . name = new ResourceLocation ( name ) ; 
 this . texture = new ResourceLocation ( texture ) ; 
 + ( ( RegistryDelegate . Delegate < VillagerProfession > ) delegate ) . setName ( name ) ; 
 } 
 
 private void register ( VillagerCareer career ) 
 @ @ - 293 , 6 + 306 , 8 @ @ public class VillagerRegistry 
 * / 
 public static void setRandomProfession ( EntityVillager entity , Random rand ) 
 { 
 + Set < String > entries = INSTANCE . professions . getKeys ( ) ; 
 + int prof = rand . nextInt ( entries . size ( ) ) ; 
 / / TODO : Grab id range from internal registry 
 entity . setProfession ( rand . nextInt ( 5 ) ) ; 
 }
