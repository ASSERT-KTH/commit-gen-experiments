BLEU SCORE: 0.018738883683389617

TEST MSG: Fix FML handshake crash , fixes # 4285 and # 3974
GENERATED MSG: ID syncing .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> index 0e0f400 . . 4fd0bb1 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import io . netty . channel . ChannelHandlerContext ; <nl> <nl> import java . util . List ; <nl> import java . util . Map ; <nl> + import java . util . function . Consumer ; <nl> <nl> import com . google . common . collect . Maps ; <nl> import com . google . common . collect . Multimap ; <nl> @ @ - 55 , 26 + 56 , 35 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> START <nl> { <nl> @ Override <nl> - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> + cons . accept ( HELLO ) ; <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . clientListenForServerHandshake ( ) ; <nl> - return HELLO ; <nl> } <nl> } , <nl> HELLO <nl> { <nl> @ Override <nl> - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> + boolean isVanilla = msg = = null ; <nl> + if ( isVanilla ) <nl> + { <nl> + cons . accept ( DONE ) ; <nl> + } <nl> + else <nl> + { <nl> + cons . accept ( WAITINGSERVERDATA ) ; <nl> + } <nl> / / write our custom packet registration , always <nl> ctx . writeAndFlush ( FMLHandshakeMessage . makeCustomChannelRegistration ( NetworkRegistry . INSTANCE . channelNamesFor ( Side . CLIENT ) ) ) ; <nl> - if ( msg = = null ) <nl> + if ( isVanilla ) <nl> { <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . abortClientHandshake ( " VANILLA " ) ; <nl> / / VANILLA login <nl> - return DONE ; <nl> + return ; <nl> } <nl> <nl> ServerHello serverHelloPacket = ( FMLHandshakeMessage . ServerHello ) msg ; <nl> @ @ - 87 , 37 + 97 , 38 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> } <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . ClientHello ( ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> - return WAITINGSERVERDATA ; <nl> } <nl> } , <nl> <nl> WAITINGSERVERDATA <nl> { <nl> @ Override <nl> - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> String result = FMLNetworkHandler . checkModList ( ( FMLHandshakeMessage . ModList ) msg , Side . SERVER ) ; <nl> if ( result ! = null ) <nl> { <nl> + cons . accept ( ERROR ) ; <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . rejectHandshake ( result ) ; <nl> - return ERROR ; <nl> + return ; <nl> } <nl> - ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) <nl> { <nl> - return WAITINGSERVERCOMPLETE ; <nl> + cons . accept ( WAITINGSERVERCOMPLETE ) ; <nl> } <nl> else <nl> { <nl> - return PENDINGCOMPLETE ; <nl> + cons . accept ( PENDINGCOMPLETE ) ; <nl> } <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + <nl> } <nl> } , <nl> WAITINGSERVERCOMPLETE <nl> { <nl> @ Override <nl> - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> FMLHandshakeMessage . RegistryData pkt = ( FMLHandshakeMessage . RegistryData ) msg ; <nl> Map < ResourceLocation , ForgeRegistry . Snapshot > snap = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . get ( ) ; <nl> @ @ - 135 , 8 + 146 , 9 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> <nl> if ( pkt . hasMore ( ) ) <nl> { <nl> + cons . accept ( WAITINGSERVERCOMPLETE ) ; <nl> FMLLog . log . debug ( " Received Mod Registry mapping for { } : { } IDs { } overrides { } dummied " , pkt . getName ( ) , entry . ids . size ( ) , entry . overrides . size ( ) , entry . dummied . size ( ) ) ; <nl> - return WAITINGSERVERCOMPLETE ; <nl> + return ; <nl> } <nl> <nl> ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . set ( null ) ; <nl> @ @ - 144 , 57 + 156 , 56 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> Multimap < ResourceLocation , ResourceLocation > locallyMissing = GameData . injectSnapshot ( snap , false , false ) ; <nl> if ( ! locallyMissing . isEmpty ( ) ) <nl> { <nl> + cons . accept ( ERROR ) ; <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; <nl> FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; <nl> locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; <nl> - return ERROR ; <nl> + return ; <nl> } <nl> + cons . accept ( PENDINGCOMPLETE ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> - return PENDINGCOMPLETE ; <nl> } <nl> } , <nl> PENDINGCOMPLETE <nl> { <nl> @ Override <nl> - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> + cons . accept ( COMPLETE ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> - return COMPLETE ; <nl> } <nl> } , <nl> COMPLETE <nl> { <nl> @ Override <nl> - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> + cons . accept ( DONE ) ; <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . completeClientHandshake ( ) ; <nl> FMLMessage . CompleteHandshake complete = new FMLMessage . CompleteHandshake ( Side . CLIENT ) ; <nl> ctx . fireChannelRead ( complete ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> - return DONE ; <nl> } <nl> } , <nl> DONE <nl> { <nl> @ Override <nl> - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> if ( msg instanceof FMLHandshakeMessage . HandshakeReset ) <nl> { <nl> + cons . accept ( HELLO ) ; <nl> GameData . revertToFrozen ( ) ; <nl> - return HELLO ; <nl> } <nl> - return this ; <nl> } <nl> } , <nl> ERROR <nl> { <nl> @ Override <nl> - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) <nl> { <nl> - return this ; <nl> } <nl> } ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeServerState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeServerState . java <nl> index d8706cc . . 500daff 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeServerState . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeServerState . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import io . netty . channel . ChannelHandlerContext ; <nl> import java . util . Iterator ; <nl> import java . util . Map ; <nl> import java . util . Map . Entry ; <nl> + import java . util . function . Consumer ; <nl> <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> @ @ - 41 , 25 + 42 , 25 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> START <nl> { <nl> @ Override <nl> - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) <nl> { <nl> + cons . accept ( HELLO ) ; <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> int overrideDim = dispatcher . serverInitiateHandshake ( ) ; <nl> ctx . writeAndFlush ( FMLHandshakeMessage . makeCustomChannelRegistration ( NetworkRegistry . INSTANCE . channelNamesFor ( Side . SERVER ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . ServerHello ( overrideDim ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> - return HELLO ; <nl> } <nl> } , <nl> HELLO <nl> { <nl> @ Override <nl> - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) <nl> { <nl> / / Hello packet first <nl> if ( msg instanceof FMLHandshakeMessage . ClientHello ) <nl> { <nl> FMLLog . log . info ( " Client protocol version { } " , Integer . toHexString ( ( ( FMLHandshakeMessage . ClientHello ) msg ) . protocolVersion ( ) ) ) ; <nl> - return this ; <nl> + return ; <nl> } <nl> <nl> FMLHandshakeMessage . ModList client = ( FMLHandshakeMessage . ModList ) msg ; <nl> @ @ - 69 , 18 + 70 , 20 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> String result = FMLNetworkHandler . checkModList ( client , Side . CLIENT ) ; <nl> if ( result ! = null ) <nl> { <nl> + cons . accept ( ERROR ) ; <nl> dispatcher . rejectHandshake ( result ) ; <nl> - return ERROR ; <nl> + return ; <nl> } <nl> + cons . accept ( WAITINGCACK ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; <nl> - return WAITINGCACK ; <nl> } <nl> } , <nl> WAITINGCACK <nl> { <nl> @ Override <nl> - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) <nl> { <nl> + cons . accept ( COMPLETE ) ; <nl> if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) <nl> { <nl> Map < ResourceLocation , ForgeRegistry . Snapshot > snapshot = RegistryManager . ACTIVE . takeSnapshot ( false ) ; <nl> @ @ - 93 , 35 + 96 , 32 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> } <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> NetworkRegistry . INSTANCE . fireNetworkHandshake ( ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) , Side . SERVER ) ; <nl> - return COMPLETE ; <nl> } <nl> } , <nl> COMPLETE <nl> { <nl> @ Override <nl> - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) <nl> { <nl> + cons . accept ( DONE ) ; <nl> / / Poke the client <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> FMLMessage . CompleteHandshake complete = new FMLMessage . CompleteHandshake ( Side . SERVER ) ; <nl> ctx . fireChannelRead ( complete ) ; <nl> - return DONE ; <nl> } <nl> } , <nl> DONE <nl> { <nl> @ Override <nl> - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) <nl> { <nl> - return this ; <nl> } <nl> } , <nl> ERROR <nl> { <nl> @ Override <nl> - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) <nl> { <nl> - return this ; <nl> } <nl> } ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java <nl> index c0fec98 . . 0cded94 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java <nl> @ @ - 43 , 26 + 43 , 30 @ @ public class HandshakeMessageHandler < S extends Enum < S > & IHandshakeState < S > > ext <nl> @ Override <nl> protected void channelRead0 ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) throws Exception <nl> { <nl> - S state = ctx . attr ( fmlHandshakeState ) . get ( ) ; <nl> + S state = ctx . channel ( ) . attr ( fmlHandshakeState ) . get ( ) ; <nl> FMLLog . log . debug ( " { } : { } - > { } : { } " , stateType . getSimpleName ( ) , msg . toString ( stateType ) , state . getClass ( ) . getName ( ) . substring ( state . getClass ( ) . getName ( ) . lastIndexOf ( ' . ' ) + 1 ) , state ) ; <nl> - S newState = state . accept ( ctx , msg ) ; <nl> - FMLLog . log . debug ( " Next : { } " , newState . name ( ) ) ; <nl> - ctx . attr ( fmlHandshakeState ) . set ( newState ) ; <nl> + state . accept ( ctx , msg , s - > <nl> + { <nl> + FMLLog . log . debug ( " Next : { } " , s . name ( ) ) ; <nl> + ctx . channel ( ) . attr ( fmlHandshakeState ) . set ( s ) ; <nl> + } ) ; <nl> } <nl> <nl> @ Override <nl> public void channelActive ( ChannelHandlerContext ctx ) throws Exception <nl> { <nl> - ctx . attr ( fmlHandshakeState ) . set ( initialState ) ; <nl> + ctx . channel ( ) . attr ( fmlHandshakeState ) . set ( initialState ) ; <nl> } <nl> @ Override <nl> public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception <nl> { <nl> S state = ctx . attr ( fmlHandshakeState ) . get ( ) ; <nl> FMLLog . log . debug ( " { } : null - > { } : { } " , stateType . getSimpleName ( ) , state . getClass ( ) . getName ( ) . substring ( state . getClass ( ) . getName ( ) . lastIndexOf ( ' . ' ) + 1 ) , state ) ; <nl> - S newState = state . accept ( ctx , null ) ; <nl> - FMLLog . log . debug ( " Next : { } " , newState . name ( ) ) ; <nl> - ctx . attr ( fmlHandshakeState ) . set ( newState ) ; <nl> + state . accept ( ctx , null , s - > <nl> + { <nl> + FMLLog . log . debug ( " Next : { } " , s . name ( ) ) ; <nl> + ctx . channel ( ) . attr ( fmlHandshakeState ) . set ( s ) ; <nl> + } ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / IHandshakeState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / IHandshakeState . java <nl> index 6210127 . . 67ec28f 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / IHandshakeState . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / IHandshakeState . java <nl> @ @ - 21 , 8 + 21 , 16 @ @ package net . minecraftforge . fml . common . network . handshake ; <nl> <nl> import io . netty . channel . ChannelHandlerContext ; <nl> <nl> + import java . util . function . Consumer ; <nl> + <nl> import javax . annotation . Nullable ; <nl> <nl> public interface IHandshakeState < S > { <nl> - S accept ( ChannelHandlerContext ctx , @ Nullable FMLHandshakeMessage msg ) ; <nl> + / * * <nl> + * Accepts FML handshake message for this state , and if needed - switches to another handshake state <nl> + * using the provided consumer . <nl> + * <nl> + * The consumer allows to set new state before sending any messages to avoid race conditions . <nl> + * / <nl> + void accept ( ChannelHandlerContext ctx , @ Nullable FMLHandshakeMessage msg , Consumer < ? super S > cons ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / FMLNetworkHandler . java b / fml / src / main / java / cpw / mods / fml / common / network / FMLNetworkHandler . java <nl> index 79a2382 . . 4fc93e1 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / FMLNetworkHandler . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / FMLNetworkHandler . java <nl> @ @ - 30 , 7 + 30 , 7 @ @ import com . google . common . collect . Lists ; <nl> <nl> import cpw . mods . fml . common . FMLLog ; <nl> import cpw . mods . fml . common . ModContainer ; <nl> - import cpw . mods . fml . common . network . handshake . FMLHandshakeMessage . ClientModList ; <nl> + import cpw . mods . fml . common . network . handshake . FMLHandshakeMessage ; <nl> import cpw . mods . fml . common . network . handshake . NetworkDispatcher ; <nl> import cpw . mods . fml . relauncher . Side ; <nl> <nl> @ @ - 451 , 13 + 451 , 13 @ @ public class FMLNetworkHandler <nl> return null ; <nl> } <nl> <nl> - public static String checkClientModList ( ClientModList clientModList ) <nl> + public static String checkModList ( FMLHandshakeMessage . ModList modListPacket , Side side ) <nl> { <nl> - Map < String , String > modList = clientModList . modList ( ) ; <nl> + Map < String , String > modList = modListPacket . modList ( ) ; <nl> List < ModContainer > rejects = Lists . newArrayList ( ) ; <nl> for ( Entry < ModContainer , NetworkModHolder > networkMod : NetworkRegistry . INSTANCE . registry ( ) . entrySet ( ) ) <nl> { <nl> - boolean result = networkMod . getValue ( ) . check ( modList , Side . CLIENT ) ; <nl> + boolean result = networkMod . getValue ( ) . check ( modList , side ) ; <nl> if ( ! result ) <nl> { <nl> rejects . add ( networkMod . getKey ( ) ) ; <nl> @ @ - 469 , 7 + 469 , 7 @ @ public class FMLNetworkHandler <nl> } <nl> else <nl> { <nl> - FMLLog . info ( " Rejecting client : % s " , rejects ) ; <nl> + FMLLog . info ( " Rejecting connection % s : % s " , side , rejects ) ; <nl> return String . format ( " Mod rejections % s " , rejects ) ; <nl> } <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / FMLProxyPacket . java b / fml / src / main / java / cpw / mods / fml / common / network / FMLProxyPacket . java <nl> index 3dd78e2 . . 623bdae 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / FMLProxyPacket . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / FMLProxyPacket . java <nl> @ @ - 6 , 13 + 6 , 12 @ @ import io . netty . channel . embedded . EmbeddedChannel ; <nl> <nl> import java . io . IOException ; <nl> <nl> - import cpw . mods . fml . relauncher . Side ; <nl> - <nl> import net . minecraft . network . INetHandler ; <nl> import net . minecraft . network . Packet ; <nl> import net . minecraft . network . PacketBuffer ; <nl> import net . minecraft . network . play . client . C17PacketCustomPayload ; <nl> import net . minecraft . network . play . server . S3FPacketCustomPayload ; <nl> + import cpw . mods . fml . relauncher . Side ; <nl> <nl> public class FMLProxyPacket extends Packet { <nl> final String channel ; <nl> @ @ - 65 , 11 + 64 , 18 @ @ public class FMLProxyPacket extends Packet { <nl> } <nl> } <nl> <nl> + public String channel ( ) <nl> + { <nl> + return channel ; <nl> + } <nl> public ByteBuf payload ( ) <nl> { <nl> return payload ; <nl> } <nl> - <nl> + public INetHandler handler ( ) <nl> + { <nl> + return netHandler ; <nl> + } <nl> public Packet toC17Packet ( ) <nl> { <nl> return new C17PacketCustomPayload ( channel , payload . array ( ) ) ; <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / NetworkRegistry . java b / fml / src / main / java / cpw / mods / fml / common / network / NetworkRegistry . java <nl> index c8f5a64 . . 5a1dcf0 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / NetworkRegistry . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / NetworkRegistry . java <nl> @ @ - 19 , 14 + 19 , 13 @ @ import io . netty . handler . codec . MessageToMessageCodec ; <nl> import io . netty . util . AttributeKey ; <nl> <nl> import java . util . EnumMap ; <nl> - import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> + import java . util . Set ; <nl> import java . util . logging . Level ; <nl> <nl> import net . minecraft . entity . player . EntityPlayer ; <nl> import net . minecraft . entity . player . EntityPlayerMP ; <nl> - import net . minecraft . network . EnumConnectionState ; <nl> import net . minecraft . network . NetworkManager ; <nl> import net . minecraft . world . World ; <nl> <nl> @ @ - 542 , 4 + 541 , 9 @ @ public enum NetworkRegistry <nl> { <nl> return registry ; <nl> } <nl> + <nl> + public Set < String > channelNamesFor ( Side side ) <nl> + { <nl> + return channels . get ( side ) . keySet ( ) ; <nl> + } <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / ChannelRegistrationHandler . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / ChannelRegistrationHandler . java <nl> new file mode 100644 <nl> index 0000000 . . e0e4cb0 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / ChannelRegistrationHandler . java <nl> @ @ - 0 , 0 + 1 , 33 @ @ <nl> + package cpw . mods . fml . common . network . handshake ; <nl> + <nl> + import com . google . common . base . Charsets ; <nl> + <nl> + import cpw . mods . fml . common . network . FMLProxyPacket ; <nl> + import cpw . mods . fml . common . network . NetworkRegistry ; <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import io . netty . channel . ChannelHandlerContext ; <nl> + import io . netty . channel . SimpleChannelInboundHandler ; <nl> + <nl> + public class ChannelRegistrationHandler extends SimpleChannelInboundHandler < FMLProxyPacket > { <nl> + @ Override <nl> + protected void channelRead0 ( ChannelHandlerContext ctx , FMLProxyPacket msg ) throws Exception <nl> + { <nl> + Side side = ctx . channel ( ) . attr ( NetworkRegistry . CHANNEL _ SOURCE ) . get ( ) ; <nl> + if ( msg . channel ( ) . equals ( " REGISTER " ) | | msg . channel ( ) . equals ( " UNREGISTER " ) ) <nl> + { <nl> + byte [ ] data = new byte [ msg . payload ( ) . readableBytes ( ) ] ; <nl> + msg . payload ( ) . readBytes ( data ) ; <nl> + String channels = new String ( data , Charsets . UTF _ 8 ) ; <nl> + String [ ] split = channels . split ( " \ 0 " ) ; <nl> + for ( String channel : split ) <nl> + { <nl> + System . out . printf ( " Register % s from % s \ n " , channel , side ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + ctx . fireChannelRead ( msg ) ; <nl> + } <nl> + } <nl> + <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> index 570f938 . . 76efce2 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> @ @ - 3 , 7 + 3 , 22 @ @ package cpw . mods . fml . common . network . handshake ; <nl> import io . netty . channel . ChannelHandlerContext ; <nl> import cpw . mods . fml . common . FMLLog ; <nl> import cpw . mods . fml . common . Loader ; <nl> + import cpw . mods . fml . common . network . FMLNetworkHandler ; <nl> + import cpw . mods . fml . common . network . NetworkRegistry ; <nl> + import cpw . mods . fml . common . registry . GameData ; <nl> + import cpw . mods . fml . relauncher . Side ; <nl> <nl> + / * * <nl> + * Packet handshake sequence manager - client side ( responding to remote server ) <nl> + * <nl> + * Flow : <nl> + * 1 . Wait for server hello . ( START ) . Move to HELLO state . <nl> + * 2 . Receive Server Hello . Send customchannel registration . Send Client Hello . Send our modlist . Move to WAITINGFORSERVERDATA state . <nl> + * 3 . Receive server modlist . Send ack if acceptable , else send nack and exit error . Receive server IDs . Move to COMPLETE state . Send ack . <nl> + * <nl> + * @ author cpw <nl> + * <nl> + * / <nl> enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> { <nl> START <nl> @ @ - 22 , 8 + 37 , 26 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> { <nl> FMLLog . info ( " Server protocol version % x " , ( ( FMLHandshakeMessage . ServerHello ) msg ) . protocolVersion ( ) ) ; <nl> + ctx . writeAndFlush ( FMLHandshakeMessage . makeCustomChannelRegistration ( NetworkRegistry . INSTANCE . channelNamesFor ( Side . CLIENT ) ) ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . ClientHello ( ) ) ; <nl> - ctx . writeAndFlush ( new FMLHandshakeMessage . ClientModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; <nl> + return WAITINGSERVERDATA ; <nl> + } <nl> + } , <nl> + <nl> + WAITINGSERVERDATA <nl> + { <nl> + @ Override <nl> + public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + { <nl> + String result = FMLNetworkHandler . checkModList ( ( FMLHandshakeMessage . ModList ) msg , Side . SERVER ) ; <nl> + if ( result ! = null ) <nl> + { <nl> + NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> + dispatcher . rejectHandshake ( result ) ; <nl> + return ERROR ; <nl> + } <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . ClientAck ( ) ) ; <nl> return COMPLETE ; <nl> } <nl> } , <nl> @ @ - 34 , 9 + 67 , 22 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> { <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . continueToClientPlayState ( ) ; <nl> + if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) <nl> + { <nl> + FMLHandshakeMessage . ModIdData modIds = ( FMLHandshakeMessage . ModIdData ) msg ; <nl> + GameData . injectWorldIDMap ( modIds . dataList ( ) ) ; <nl> + } <nl> FMLLog . info ( " Client side modded connection established " ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . ClientAck ( ) ) ; <nl> return this ; <nl> } <nl> + } , <nl> + ERROR <nl> + { <nl> + @ Override <nl> + public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + { <nl> + return this ; <nl> + } <nl> } ; <nl> } <nl> \ No newline at end of file <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java <nl> index 226c451 . . 5019dff 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java <nl> @ @ - 9 , 8 + 9 , 8 @ @ public class FMLHandshakeCodec extends FMLIndexedMessageToMessageCodec < FMLHandsh <nl> { <nl> addDiscriminator ( ( byte ) 0 , FMLHandshakeMessage . ServerHello . class ) ; <nl> addDiscriminator ( ( byte ) 1 , FMLHandshakeMessage . ClientHello . class ) ; <nl> - addDiscriminator ( ( byte ) 2 , FMLHandshakeMessage . ClientModList . class ) ; <nl> - addDiscriminator ( ( byte ) 3 , FMLHandshakeMessage . ServerModList . class ) ; <nl> + addDiscriminator ( ( byte ) 2 , FMLHandshakeMessage . ModList . class ) ; <nl> + addDiscriminator ( ( byte ) 3 , FMLHandshakeMessage . ModIdData . class ) ; <nl> addDiscriminator ( ( byte ) - 1 , FMLHandshakeMessage . ClientAck . class ) ; <nl> } <nl> @ Override <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> index 2ba5440 . . 8f8ac75 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> @ @ - 1 , 19 + 1 , 31 @ @ <nl> package cpw . mods . fml . common . network . handshake ; <nl> <nl> import io . netty . buffer . ByteBuf ; <nl> + import io . netty . buffer . Unpooled ; <nl> <nl> + import java . util . Arrays ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> + import java . util . Map . Entry ; <nl> + import java . util . Set ; <nl> <nl> + import com . google . common . base . Charsets ; <nl> import com . google . common . base . Joiner ; <nl> - import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Maps ; <nl> <nl> import cpw . mods . fml . common . ModContainer ; <nl> import cpw . mods . fml . common . network . ByteBufUtils ; <nl> + import cpw . mods . fml . common . network . FMLProxyPacket ; <nl> import cpw . mods . fml . common . network . NetworkRegistry ; <nl> <nl> public abstract class FMLHandshakeMessage { <nl> + public static FMLProxyPacket makeCustomChannelRegistration ( Set < String > channels ) <nl> + { <nl> + String salutation = Joiner . on ( ' \ 0 ' ) . join ( Iterables . concat ( Arrays . asList ( " FML | HS " , " FML " ) , channels ) ) ; <nl> + FMLProxyPacket proxy = new FMLProxyPacket ( Unpooled . wrappedBuffer ( salutation . getBytes ( Charsets . UTF _ 8 ) ) , " REGISTER " ) ; <nl> + return proxy ; <nl> + } <nl> public static class ServerHello extends FMLHandshakeMessage { <nl> private byte serverProtocolVersion ; <nl> public void toBytes ( ByteBuf buffer ) <nl> @ @ - 48 , 38 + 60 , 12 @ @ public abstract class FMLHandshakeMessage { <nl> return serverProtocolVersion ; <nl> } <nl> } <nl> - public static class ServerModList extends FMLHandshakeMessage { <nl> - private List < String > modTags = Lists . newArrayList ( ) ; <nl> - <nl> - @ Override <nl> - public void toBytes ( ByteBuf buffer ) <nl> - { <nl> - super . toBytes ( buffer ) ; <nl> - ByteBufUtils . writeVarInt ( buffer , modTags . size ( ) , 2 ) ; <nl> - for ( String modTag : modTags ) <nl> - { <nl> - ByteBufUtils . writeUTF8String ( buffer , modTag ) ; <nl> - } <nl> - } <nl> - <nl> - @ Override <nl> - public void fromBytes ( ByteBuf buffer ) <nl> - { <nl> - super . fromBytes ( buffer ) ; <nl> - int modCount = ByteBufUtils . readVarInt ( buffer , 2 ) ; <nl> - for ( int i = 0 ; i < modCount ; i + + ) <nl> - { <nl> - modTags . add ( ByteBufUtils . readUTF8String ( buffer ) ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - public static class ClientModList extends FMLHandshakeMessage { <nl> - public ClientModList ( ) <nl> + public static class ModList extends FMLHandshakeMessage { <nl> + public ModList ( ) <nl> { <nl> <nl> } <nl> - public ClientModList ( List < ModContainer > modList ) <nl> + public ModList ( List < ModContainer > modList ) <nl> { <nl> for ( ModContainer mod : modList ) <nl> { <nl> @ @ - 126 , 6 + 112 , 45 @ @ public abstract class FMLHandshakeMessage { <nl> } <nl> } <nl> <nl> + public static class ModIdData extends FMLHandshakeMessage { <nl> + public ModIdData ( ) <nl> + { <nl> + <nl> + } <nl> + <nl> + public ModIdData ( Map < String , Integer > modIds ) <nl> + { <nl> + this . modIds = modIds ; <nl> + } <nl> + <nl> + private Map < String , Integer > modIds ; <nl> + public void fromBytes ( ByteBuf buffer ) <nl> + { <nl> + int length = ByteBufUtils . readVarInt ( buffer , 3 ) ; <nl> + modIds = Maps . newHashMap ( ) ; <nl> + <nl> + for ( int i = 0 ; i < length ; i + + ) <nl> + { <nl> + modIds . put ( ByteBufUtils . readUTF8String ( buffer ) , ByteBufUtils . readVarInt ( buffer , 3 ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void toBytes ( ByteBuf buffer ) <nl> + { <nl> + ByteBufUtils . writeVarInt ( buffer , modIds . size ( ) , 3 ) ; <nl> + for ( Entry < String , Integer > entry : modIds . entrySet ( ) ) <nl> + { <nl> + ByteBufUtils . writeUTF8String ( buffer , entry . getKey ( ) ) ; <nl> + ByteBufUtils . writeVarInt ( buffer , entry . getValue ( ) , 3 ) ; <nl> + } <nl> + } <nl> + <nl> + public Map < String , Integer > dataList ( ) <nl> + { <nl> + return modIds ; <nl> + } <nl> + } <nl> public static class ClientAck extends FMLHandshakeMessage { <nl> <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java <nl> index b79bac8 . . 6adfa18 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java <nl> @ @ - 2 , 7 + 2 , 11 @ @ package cpw . mods . fml . common . network . handshake ; <nl> <nl> import io . netty . channel . ChannelHandlerContext ; <nl> import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . common . Loader ; <nl> import cpw . mods . fml . common . network . FMLNetworkHandler ; <nl> + import cpw . mods . fml . common . network . NetworkRegistry ; <nl> + import cpw . mods . fml . common . registry . GameData ; <nl> + import cpw . mods . fml . relauncher . Side ; <nl> <nl> enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> { <nl> @ @ - 13 , 6 + 17 , 7 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> { <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . serverInitiateHandshake ( ) ; <nl> + ctx . writeAndFlush ( FMLHandshakeMessage . makeCustomChannelRegistration ( NetworkRegistry . INSTANCE . channelNamesFor ( Side . SERVER ) ) ) ; <nl> ctx . writeAndFlush ( new FMLHandshakeMessage . ServerHello ( ) ) ; <nl> return HELLO ; <nl> } <nl> @ @ - 29 , 16 + 34 , 29 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > <nl> return this ; <nl> } <nl> <nl> - FMLHandshakeMessage . ClientModList client = ( FMLHandshakeMessage . ClientModList ) msg ; <nl> + FMLHandshakeMessage . ModList client = ( FMLHandshakeMessage . ModList ) msg ; <nl> FMLLog . info ( " Client attempting to join with % d mods : % s " , client . modListSize ( ) , client . modListAsString ( ) ) ; <nl> - String result = FMLNetworkHandler . checkClientModList ( client ) ; <nl> + String result = FMLNetworkHandler . checkModList ( client , Side . CLIENT ) ; <nl> if ( result ! = null ) <nl> { <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> dispatcher . rejectHandshake ( result ) ; <nl> return ERROR ; <nl> } <nl> - ctx . writeAndFlush ( new FMLHandshakeMessage . ServerModList ( ) ) ; <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; <nl> + if ( ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) <nl> + { <nl> + return COMPLETE ; <nl> + } <nl> + return WAITINGCACK ; <nl> + } <nl> + } , <nl> + WAITINGCACK <nl> + { <nl> + @ Override <nl> + public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> + { <nl> + ctx . writeAndFlush ( new FMLHandshakeMessage . ModIdData ( GameData . buildItemDataList ( ) ) ) ; <nl> return COMPLETE ; <nl> } <nl> } , <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / NetworkDispatcher . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / NetworkDispatcher . java <nl> index cafc7e3 . . 2987e4d 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / NetworkDispatcher . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / NetworkDispatcher . java <nl> @ @ - 56 , 6 + 56 , 7 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { <nl> } <nl> <nl> public static final AttributeKey < NetworkDispatcher > FML _ DISPATCHER = new AttributeKey < NetworkDispatcher > ( " fml : dispatcher " ) ; <nl> + public static final AttributeKey < Boolean > IS _ LOCAL = new AttributeKey < Boolean > ( " fml : isLocal " ) ; <nl> private final NetworkManager manager ; <nl> private final ServerConfigurationManager scm ; <nl> private EntityPlayerMP player ; <nl> @ @ - 70 , 9 + 71 , 11 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { <nl> this . manager = manager ; <nl> this . scm = null ; <nl> this . side = Side . CLIENT ; <nl> - this . handshakeChannel = new EmbeddedChannel ( new HandshakeInjector ( this ) , new FMLHandshakeCodec ( ) , new HandshakeMessageHandler < FMLHandshakeClientState > ( FMLHandshakeClientState . class ) ) ; <nl> + this . handshakeChannel = new EmbeddedChannel ( new HandshakeInjector ( this ) , new ChannelRegistrationHandler ( ) , new FMLHandshakeCodec ( ) , new HandshakeMessageHandler < FMLHandshakeClientState > ( FMLHandshakeClientState . class ) ) ; <nl> this . handshakeChannel . attr ( FML _ DISPATCHER ) . set ( this ) ; <nl> + this . handshakeChannel . attr ( NetworkRegistry . CHANNEL _ SOURCE ) . set ( Side . SERVER ) ; <nl> this . handshakeChannel . attr ( NetworkRegistry . FML _ CHANNEL ) . set ( " FML | HS " ) ; <nl> + this . handshakeChannel . attr ( IS _ LOCAL ) . set ( manager . func _ 150731 _ c ( ) ) ; <nl> } <nl> <nl> public NetworkDispatcher ( NetworkManager manager , ServerConfigurationManager scm ) <nl> @ @ - 81 , 9 + 84 , 11 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { <nl> this . manager = manager ; <nl> this . scm = scm ; <nl> this . side = Side . SERVER ; <nl> - this . handshakeChannel = new EmbeddedChannel ( new HandshakeInjector ( this ) , new FMLHandshakeCodec ( ) , new HandshakeMessageHandler < FMLHandshakeServerState > ( FMLHandshakeServerState . class ) ) ; <nl> + this . handshakeChannel = new EmbeddedChannel ( new HandshakeInjector ( this ) , new ChannelRegistrationHandler ( ) , new FMLHandshakeCodec ( ) , new HandshakeMessageHandler < FMLHandshakeServerState > ( FMLHandshakeServerState . class ) ) ; <nl> this . handshakeChannel . attr ( FML _ DISPATCHER ) . set ( this ) ; <nl> + this . handshakeChannel . attr ( NetworkRegistry . CHANNEL _ SOURCE ) . set ( Side . CLIENT ) ; <nl> this . handshakeChannel . attr ( NetworkRegistry . FML _ CHANNEL ) . set ( " FML | HS " ) ; <nl> + this . handshakeChannel . attr ( IS _ LOCAL ) . set ( manager . func _ 150731 _ c ( ) ) ; <nl> } <nl> <nl> public void serverToClientHandshake ( EntityPlayerMP player ) <nl> @ @ - 210 , 7 + 215 , 7 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { <nl> private boolean handleClientSideCustomPacket ( S3FPacketCustomPayload msg , ChannelHandlerContext context ) <nl> { <nl> String channelName = msg . func _ 149169 _ c ( ) ; <nl> - if ( " FML | HS " . equals ( channelName ) ) <nl> + if ( " FML | HS " . equals ( channelName ) | | " REGISTER " . equals ( channelName ) | | " UNREGISTER " . equals ( channelName ) ) <nl> { <nl> FMLProxyPacket proxy = new FMLProxyPacket ( msg ) ; <nl> handshakeChannel . writeInbound ( proxy ) ; <nl> @ @ - 233 , 7 + 238 , 7 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { <nl> state = ConnectionState . HANDSHAKING ; <nl> } <nl> String channelName = msg . func _ 149559 _ c ( ) ; <nl> - if ( " FML | HS " . equals ( channelName ) ) <nl> + if ( " FML | HS " . equals ( channelName ) | | " REGISTER " . equals ( channelName ) | | " UNREGISTER " . equals ( channelName ) ) <nl> { <nl> FMLProxyPacket proxy = new FMLProxyPacket ( msg ) ; <nl> handshakeChannel . writeInbound ( proxy ) ; <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / server / FMLServerHandler . java b / fml / src / main / java / cpw / mods / fml / server / FMLServerHandler . java <nl> index e0622d2 . . 9da326f 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / server / FMLServerHandler . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / server / FMLServerHandler . java <nl> @ @ - 38 , 7 + 38 , 6 @ @ import cpw . mods . fml . common . network . packet . EntitySpawnAdjustmentPacket ; <nl> import cpw . mods . fml . common . network . packet . EntitySpawnPacket ; <nl> import cpw . mods . fml . common . network . packet . ModMissingPacket ; <nl> import cpw . mods . fml . common . registry . EntityRegistry . EntityRegistration ; <nl> - import cpw . mods . fml . common . registry . GameData ; <nl> import cpw . mods . fml . common . registry . LanguageRegistry ; <nl> import cpw . mods . fml . relauncher . Side ; <nl> <nl> @ @ - 96 , 7 + 95 , 6 @ @ public class FMLServerHandler implements IFMLSidedHandler <nl> { <nl> Loader . instance ( ) . initializeMods ( ) ; <nl> LanguageRegistry . reloadLanguageTable ( ) ; <nl> - GameData . initializeServerGate ( 1 ) ; <nl> } <nl> <nl> @ Override

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 index 0e0f400 . . 4fd0bb1 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeClientState . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import io . netty . channel . ChannelHandlerContext ; 
 
 import java . util . List ; 
 import java . util . Map ; 
 + import java . util . function . Consumer ; 
 
 import com . google . common . collect . Maps ; 
 import com . google . common . collect . Multimap ; 
 @ @ - 55 , 26 + 56 , 35 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 START 
 { 
 @ Override 
 - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 + cons . accept ( HELLO ) ; 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . clientListenForServerHandshake ( ) ; 
 - return HELLO ; 
 } 
 } , 
 HELLO 
 { 
 @ Override 
 - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 + boolean isVanilla = msg = = null ; 
 + if ( isVanilla ) 
 + { 
 + cons . accept ( DONE ) ; 
 + } 
 + else 
 + { 
 + cons . accept ( WAITINGSERVERDATA ) ; 
 + } 
 / / write our custom packet registration , always 
 ctx . writeAndFlush ( FMLHandshakeMessage . makeCustomChannelRegistration ( NetworkRegistry . INSTANCE . channelNamesFor ( Side . CLIENT ) ) ) ; 
 - if ( msg = = null ) 
 + if ( isVanilla ) 
 { 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . abortClientHandshake ( " VANILLA " ) ; 
 / / VANILLA login 
 - return DONE ; 
 + return ; 
 } 
 
 ServerHello serverHelloPacket = ( FMLHandshakeMessage . ServerHello ) msg ; 
 @ @ - 87 , 37 + 97 , 38 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 } 
 ctx . writeAndFlush ( new FMLHandshakeMessage . ClientHello ( ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 - return WAITINGSERVERDATA ; 
 } 
 } , 
 
 WAITINGSERVERDATA 
 { 
 @ Override 
 - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 String result = FMLNetworkHandler . checkModList ( ( FMLHandshakeMessage . ModList ) msg , Side . SERVER ) ; 
 if ( result ! = null ) 
 { 
 + cons . accept ( ERROR ) ; 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . rejectHandshake ( result ) ; 
 - return ERROR ; 
 + return ; 
 } 
 - ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) 
 { 
 - return WAITINGSERVERCOMPLETE ; 
 + cons . accept ( WAITINGSERVERCOMPLETE ) ; 
 } 
 else 
 { 
 - return PENDINGCOMPLETE ; 
 + cons . accept ( PENDINGCOMPLETE ) ; 
 } 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + 
 } 
 } , 
 WAITINGSERVERCOMPLETE 
 { 
 @ Override 
 - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 FMLHandshakeMessage . RegistryData pkt = ( FMLHandshakeMessage . RegistryData ) msg ; 
 Map < ResourceLocation , ForgeRegistry . Snapshot > snap = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . get ( ) ; 
 @ @ - 135 , 8 + 146 , 9 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 
 if ( pkt . hasMore ( ) ) 
 { 
 + cons . accept ( WAITINGSERVERCOMPLETE ) ; 
 FMLLog . log . debug ( " Received Mod Registry mapping for { } : { } IDs { } overrides { } dummied " , pkt . getName ( ) , entry . ids . size ( ) , entry . overrides . size ( ) , entry . dummied . size ( ) ) ; 
 - return WAITINGSERVERCOMPLETE ; 
 + return ; 
 } 
 
 ctx . channel ( ) . attr ( NetworkDispatcher . FML _ GAMEDATA _ SNAPSHOT ) . set ( null ) ; 
 @ @ - 144 , 57 + 156 , 56 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 Multimap < ResourceLocation , ResourceLocation > locallyMissing = GameData . injectSnapshot ( snap , false , false ) ; 
 if ( ! locallyMissing . isEmpty ( ) ) 
 { 
 + cons . accept ( ERROR ) ; 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . rejectHandshake ( " Fatally missing registry entries " ) ; 
 FMLLog . log . fatal ( " Failed to connect to server : there are { } missing registry items " , locallyMissing . size ( ) ) ; 
 locallyMissing . asMap ( ) . forEach ( ( key , value ) - > FMLLog . log . debug ( " Missing { } Entries : { } " , key , value ) ) ; 
 - return ERROR ; 
 + return ; 
 } 
 + cons . accept ( PENDINGCOMPLETE ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 - return PENDINGCOMPLETE ; 
 } 
 } , 
 PENDINGCOMPLETE 
 { 
 @ Override 
 - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 + cons . accept ( COMPLETE ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 - return COMPLETE ; 
 } 
 } , 
 COMPLETE 
 { 
 @ Override 
 - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 + cons . accept ( DONE ) ; 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . completeClientHandshake ( ) ; 
 FMLMessage . CompleteHandshake complete = new FMLMessage . CompleteHandshake ( Side . CLIENT ) ; 
 ctx . fireChannelRead ( complete ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 - return DONE ; 
 } 
 } , 
 DONE 
 { 
 @ Override 
 - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 if ( msg instanceof FMLHandshakeMessage . HandshakeReset ) 
 { 
 + cons . accept ( HELLO ) ; 
 GameData . revertToFrozen ( ) ; 
 - return HELLO ; 
 } 
 - return this ; 
 } 
 } , 
 ERROR 
 { 
 @ Override 
 - public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeClientState > cons ) 
 { 
 - return this ; 
 } 
 } ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeServerState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeServerState . java 
 index d8706cc . . 500daff 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeServerState . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeServerState . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import io . netty . channel . ChannelHandlerContext ; 
 import java . util . Iterator ; 
 import java . util . Map ; 
 import java . util . Map . Entry ; 
 + import java . util . function . Consumer ; 
 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 @ @ - 41 , 25 + 42 , 25 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 START 
 { 
 @ Override 
 - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) 
 { 
 + cons . accept ( HELLO ) ; 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 int overrideDim = dispatcher . serverInitiateHandshake ( ) ; 
 ctx . writeAndFlush ( FMLHandshakeMessage . makeCustomChannelRegistration ( NetworkRegistry . INSTANCE . channelNamesFor ( Side . SERVER ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . ServerHello ( overrideDim ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 - return HELLO ; 
 } 
 } , 
 HELLO 
 { 
 @ Override 
 - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) 
 { 
 / / Hello packet first 
 if ( msg instanceof FMLHandshakeMessage . ClientHello ) 
 { 
 FMLLog . log . info ( " Client protocol version { } " , Integer . toHexString ( ( ( FMLHandshakeMessage . ClientHello ) msg ) . protocolVersion ( ) ) ) ; 
 - return this ; 
 + return ; 
 } 
 
 FMLHandshakeMessage . ModList client = ( FMLHandshakeMessage . ModList ) msg ; 
 @ @ - 69 , 18 + 70 , 20 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 String result = FMLNetworkHandler . checkModList ( client , Side . CLIENT ) ; 
 if ( result ! = null ) 
 { 
 + cons . accept ( ERROR ) ; 
 dispatcher . rejectHandshake ( result ) ; 
 - return ERROR ; 
 + return ; 
 } 
 + cons . accept ( WAITINGCACK ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; 
 - return WAITINGCACK ; 
 } 
 } , 
 WAITINGCACK 
 { 
 @ Override 
 - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) 
 { 
 + cons . accept ( COMPLETE ) ; 
 if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) 
 { 
 Map < ResourceLocation , ForgeRegistry . Snapshot > snapshot = RegistryManager . ACTIVE . takeSnapshot ( false ) ; 
 @ @ - 93 , 35 + 96 , 32 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 } 
 ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 NetworkRegistry . INSTANCE . fireNetworkHandshake ( ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) , Side . SERVER ) ; 
 - return COMPLETE ; 
 } 
 } , 
 COMPLETE 
 { 
 @ Override 
 - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) 
 { 
 + cons . accept ( DONE ) ; 
 / / Poke the client 
 ctx . writeAndFlush ( new FMLHandshakeMessage . HandshakeAck ( ordinal ( ) ) ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 FMLMessage . CompleteHandshake complete = new FMLMessage . CompleteHandshake ( Side . SERVER ) ; 
 ctx . fireChannelRead ( complete ) ; 
 - return DONE ; 
 } 
 } , 
 DONE 
 { 
 @ Override 
 - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) 
 { 
 - return this ; 
 } 
 } , 
 ERROR 
 { 
 @ Override 
 - public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + public void accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg , Consumer < ? super FMLHandshakeServerState > cons ) 
 { 
 - return this ; 
 } 
 } ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java 
 index c0fec98 . . 0cded94 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / HandshakeMessageHandler . java 
 @ @ - 43 , 26 + 43 , 30 @ @ public class HandshakeMessageHandler < S extends Enum < S > & IHandshakeState < S > > ext 
 @ Override 
 protected void channelRead0 ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) throws Exception 
 { 
 - S state = ctx . attr ( fmlHandshakeState ) . get ( ) ; 
 + S state = ctx . channel ( ) . attr ( fmlHandshakeState ) . get ( ) ; 
 FMLLog . log . debug ( " { } : { } - > { } : { } " , stateType . getSimpleName ( ) , msg . toString ( stateType ) , state . getClass ( ) . getName ( ) . substring ( state . getClass ( ) . getName ( ) . lastIndexOf ( ' . ' ) + 1 ) , state ) ; 
 - S newState = state . accept ( ctx , msg ) ; 
 - FMLLog . log . debug ( " Next : { } " , newState . name ( ) ) ; 
 - ctx . attr ( fmlHandshakeState ) . set ( newState ) ; 
 + state . accept ( ctx , msg , s - > 
 + { 
 + FMLLog . log . debug ( " Next : { } " , s . name ( ) ) ; 
 + ctx . channel ( ) . attr ( fmlHandshakeState ) . set ( s ) ; 
 + } ) ; 
 } 
 
 @ Override 
 public void channelActive ( ChannelHandlerContext ctx ) throws Exception 
 { 
 - ctx . attr ( fmlHandshakeState ) . set ( initialState ) ; 
 + ctx . channel ( ) . attr ( fmlHandshakeState ) . set ( initialState ) ; 
 } 
 @ Override 
 public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception 
 { 
 S state = ctx . attr ( fmlHandshakeState ) . get ( ) ; 
 FMLLog . log . debug ( " { } : null - > { } : { } " , stateType . getSimpleName ( ) , state . getClass ( ) . getName ( ) . substring ( state . getClass ( ) . getName ( ) . lastIndexOf ( ' . ' ) + 1 ) , state ) ; 
 - S newState = state . accept ( ctx , null ) ; 
 - FMLLog . log . debug ( " Next : { } " , newState . name ( ) ) ; 
 - ctx . attr ( fmlHandshakeState ) . set ( newState ) ; 
 + state . accept ( ctx , null , s - > 
 + { 
 + FMLLog . log . debug ( " Next : { } " , s . name ( ) ) ; 
 + ctx . channel ( ) . attr ( fmlHandshakeState ) . set ( s ) ; 
 + } ) ; 
 } 
 
 @ Override 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / IHandshakeState . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / IHandshakeState . java 
 index 6210127 . . 67ec28f 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / IHandshakeState . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / IHandshakeState . java 
 @ @ - 21 , 8 + 21 , 16 @ @ package net . minecraftforge . fml . common . network . handshake ; 
 
 import io . netty . channel . ChannelHandlerContext ; 
 
 + import java . util . function . Consumer ; 
 + 
 import javax . annotation . Nullable ; 
 
 public interface IHandshakeState < S > { 
 - S accept ( ChannelHandlerContext ctx , @ Nullable FMLHandshakeMessage msg ) ; 
 + / * * 
 + * Accepts FML handshake message for this state , and if needed - switches to another handshake state 
 + * using the provided consumer . 
 + * 
 + * The consumer allows to set new state before sending any messages to avoid race conditions . 
 + * / 
 + void accept ( ChannelHandlerContext ctx , @ Nullable FMLHandshakeMessage msg , Consumer < ? super S > cons ) ; 
 }

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / FMLNetworkHandler . java b / fml / src / main / java / cpw / mods / fml / common / network / FMLNetworkHandler . java 
 index 79a2382 . . 4fc93e1 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / FMLNetworkHandler . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / FMLNetworkHandler . java 
 @ @ - 30 , 7 + 30 , 7 @ @ import com . google . common . collect . Lists ; 
 
 import cpw . mods . fml . common . FMLLog ; 
 import cpw . mods . fml . common . ModContainer ; 
 - import cpw . mods . fml . common . network . handshake . FMLHandshakeMessage . ClientModList ; 
 + import cpw . mods . fml . common . network . handshake . FMLHandshakeMessage ; 
 import cpw . mods . fml . common . network . handshake . NetworkDispatcher ; 
 import cpw . mods . fml . relauncher . Side ; 
 
 @ @ - 451 , 13 + 451 , 13 @ @ public class FMLNetworkHandler 
 return null ; 
 } 
 
 - public static String checkClientModList ( ClientModList clientModList ) 
 + public static String checkModList ( FMLHandshakeMessage . ModList modListPacket , Side side ) 
 { 
 - Map < String , String > modList = clientModList . modList ( ) ; 
 + Map < String , String > modList = modListPacket . modList ( ) ; 
 List < ModContainer > rejects = Lists . newArrayList ( ) ; 
 for ( Entry < ModContainer , NetworkModHolder > networkMod : NetworkRegistry . INSTANCE . registry ( ) . entrySet ( ) ) 
 { 
 - boolean result = networkMod . getValue ( ) . check ( modList , Side . CLIENT ) ; 
 + boolean result = networkMod . getValue ( ) . check ( modList , side ) ; 
 if ( ! result ) 
 { 
 rejects . add ( networkMod . getKey ( ) ) ; 
 @ @ - 469 , 7 + 469 , 7 @ @ public class FMLNetworkHandler 
 } 
 else 
 { 
 - FMLLog . info ( " Rejecting client : % s " , rejects ) ; 
 + FMLLog . info ( " Rejecting connection % s : % s " , side , rejects ) ; 
 return String . format ( " Mod rejections % s " , rejects ) ; 
 } 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / FMLProxyPacket . java b / fml / src / main / java / cpw / mods / fml / common / network / FMLProxyPacket . java 
 index 3dd78e2 . . 623bdae 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / FMLProxyPacket . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / FMLProxyPacket . java 
 @ @ - 6 , 13 + 6 , 12 @ @ import io . netty . channel . embedded . EmbeddedChannel ; 
 
 import java . io . IOException ; 
 
 - import cpw . mods . fml . relauncher . Side ; 
 - 
 import net . minecraft . network . INetHandler ; 
 import net . minecraft . network . Packet ; 
 import net . minecraft . network . PacketBuffer ; 
 import net . minecraft . network . play . client . C17PacketCustomPayload ; 
 import net . minecraft . network . play . server . S3FPacketCustomPayload ; 
 + import cpw . mods . fml . relauncher . Side ; 
 
 public class FMLProxyPacket extends Packet { 
 final String channel ; 
 @ @ - 65 , 11 + 64 , 18 @ @ public class FMLProxyPacket extends Packet { 
 } 
 } 
 
 + public String channel ( ) 
 + { 
 + return channel ; 
 + } 
 public ByteBuf payload ( ) 
 { 
 return payload ; 
 } 
 - 
 + public INetHandler handler ( ) 
 + { 
 + return netHandler ; 
 + } 
 public Packet toC17Packet ( ) 
 { 
 return new C17PacketCustomPayload ( channel , payload . array ( ) ) ; 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / NetworkRegistry . java b / fml / src / main / java / cpw / mods / fml / common / network / NetworkRegistry . java 
 index c8f5a64 . . 5a1dcf0 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / NetworkRegistry . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / NetworkRegistry . java 
 @ @ - 19 , 14 + 19 , 13 @ @ import io . netty . handler . codec . MessageToMessageCodec ; 
 import io . netty . util . AttributeKey ; 
 
 import java . util . EnumMap ; 
 - import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 + import java . util . Set ; 
 import java . util . logging . Level ; 
 
 import net . minecraft . entity . player . EntityPlayer ; 
 import net . minecraft . entity . player . EntityPlayerMP ; 
 - import net . minecraft . network . EnumConnectionState ; 
 import net . minecraft . network . NetworkManager ; 
 import net . minecraft . world . World ; 
 
 @ @ - 542 , 4 + 541 , 9 @ @ public enum NetworkRegistry 
 { 
 return registry ; 
 } 
 + 
 + public Set < String > channelNamesFor ( Side side ) 
 + { 
 + return channels . get ( side ) . keySet ( ) ; 
 + } 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / ChannelRegistrationHandler . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / ChannelRegistrationHandler . java 
 new file mode 100644 
 index 0000000 . . e0e4cb0 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / ChannelRegistrationHandler . java 
 @ @ - 0 , 0 + 1 , 33 @ @ 
 + package cpw . mods . fml . common . network . handshake ; 
 + 
 + import com . google . common . base . Charsets ; 
 + 
 + import cpw . mods . fml . common . network . FMLProxyPacket ; 
 + import cpw . mods . fml . common . network . NetworkRegistry ; 
 + import cpw . mods . fml . relauncher . Side ; 
 + import io . netty . channel . ChannelHandlerContext ; 
 + import io . netty . channel . SimpleChannelInboundHandler ; 
 + 
 + public class ChannelRegistrationHandler extends SimpleChannelInboundHandler < FMLProxyPacket > { 
 + @ Override 
 + protected void channelRead0 ( ChannelHandlerContext ctx , FMLProxyPacket msg ) throws Exception 
 + { 
 + Side side = ctx . channel ( ) . attr ( NetworkRegistry . CHANNEL _ SOURCE ) . get ( ) ; 
 + if ( msg . channel ( ) . equals ( " REGISTER " ) | | msg . channel ( ) . equals ( " UNREGISTER " ) ) 
 + { 
 + byte [ ] data = new byte [ msg . payload ( ) . readableBytes ( ) ] ; 
 + msg . payload ( ) . readBytes ( data ) ; 
 + String channels = new String ( data , Charsets . UTF _ 8 ) ; 
 + String [ ] split = channels . split ( " \ 0 " ) ; 
 + for ( String channel : split ) 
 + { 
 + System . out . printf ( " Register % s from % s \ n " , channel , side ) ; 
 + } 
 + } 
 + else 
 + { 
 + ctx . fireChannelRead ( msg ) ; 
 + } 
 + } 
 + 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 index 570f938 . . 76efce2 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 @ @ - 3 , 7 + 3 , 22 @ @ package cpw . mods . fml . common . network . handshake ; 
 import io . netty . channel . ChannelHandlerContext ; 
 import cpw . mods . fml . common . FMLLog ; 
 import cpw . mods . fml . common . Loader ; 
 + import cpw . mods . fml . common . network . FMLNetworkHandler ; 
 + import cpw . mods . fml . common . network . NetworkRegistry ; 
 + import cpw . mods . fml . common . registry . GameData ; 
 + import cpw . mods . fml . relauncher . Side ; 
 
 + / * * 
 + * Packet handshake sequence manager - client side ( responding to remote server ) 
 + * 
 + * Flow : 
 + * 1 . Wait for server hello . ( START ) . Move to HELLO state . 
 + * 2 . Receive Server Hello . Send customchannel registration . Send Client Hello . Send our modlist . Move to WAITINGFORSERVERDATA state . 
 + * 3 . Receive server modlist . Send ack if acceptable , else send nack and exit error . Receive server IDs . Move to COMPLETE state . Send ack . 
 + * 
 + * @ author cpw 
 + * 
 + * / 
 enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 { 
 START 
 @ @ - 22 , 8 + 37 , 26 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 { 
 FMLLog . info ( " Server protocol version % x " , ( ( FMLHandshakeMessage . ServerHello ) msg ) . protocolVersion ( ) ) ; 
 + ctx . writeAndFlush ( FMLHandshakeMessage . makeCustomChannelRegistration ( NetworkRegistry . INSTANCE . channelNamesFor ( Side . CLIENT ) ) ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . ClientHello ( ) ) ; 
 - ctx . writeAndFlush ( new FMLHandshakeMessage . ClientModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; 
 + return WAITINGSERVERDATA ; 
 + } 
 + } , 
 + 
 + WAITINGSERVERDATA 
 + { 
 + @ Override 
 + public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + { 
 + String result = FMLNetworkHandler . checkModList ( ( FMLHandshakeMessage . ModList ) msg , Side . SERVER ) ; 
 + if ( result ! = null ) 
 + { 
 + NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 + dispatcher . rejectHandshake ( result ) ; 
 + return ERROR ; 
 + } 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . ClientAck ( ) ) ; 
 return COMPLETE ; 
 } 
 } , 
 @ @ - 34 , 9 + 67 , 22 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 { 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . continueToClientPlayState ( ) ; 
 + if ( ! ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) 
 + { 
 + FMLHandshakeMessage . ModIdData modIds = ( FMLHandshakeMessage . ModIdData ) msg ; 
 + GameData . injectWorldIDMap ( modIds . dataList ( ) ) ; 
 + } 
 FMLLog . info ( " Client side modded connection established " ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . ClientAck ( ) ) ; 
 return this ; 
 } 
 + } , 
 + ERROR 
 + { 
 + @ Override 
 + public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + { 
 + return this ; 
 + } 
 } ; 
 } 
 \ No newline at end of file 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java 
 index 226c451 . . 5019dff 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeCodec . java 
 @ @ - 9 , 8 + 9 , 8 @ @ public class FMLHandshakeCodec extends FMLIndexedMessageToMessageCodec < FMLHandsh 
 { 
 addDiscriminator ( ( byte ) 0 , FMLHandshakeMessage . ServerHello . class ) ; 
 addDiscriminator ( ( byte ) 1 , FMLHandshakeMessage . ClientHello . class ) ; 
 - addDiscriminator ( ( byte ) 2 , FMLHandshakeMessage . ClientModList . class ) ; 
 - addDiscriminator ( ( byte ) 3 , FMLHandshakeMessage . ServerModList . class ) ; 
 + addDiscriminator ( ( byte ) 2 , FMLHandshakeMessage . ModList . class ) ; 
 + addDiscriminator ( ( byte ) 3 , FMLHandshakeMessage . ModIdData . class ) ; 
 addDiscriminator ( ( byte ) - 1 , FMLHandshakeMessage . ClientAck . class ) ; 
 } 
 @ Override 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 index 2ba5440 . . 8f8ac75 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 @ @ - 1 , 19 + 1 , 31 @ @ 
 package cpw . mods . fml . common . network . handshake ; 
 
 import io . netty . buffer . ByteBuf ; 
 + import io . netty . buffer . Unpooled ; 
 
 + import java . util . Arrays ; 
 import java . util . List ; 
 import java . util . Map ; 
 + import java . util . Map . Entry ; 
 + import java . util . Set ; 
 
 + import com . google . common . base . Charsets ; 
 import com . google . common . base . Joiner ; 
 - import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Maps ; 
 
 import cpw . mods . fml . common . ModContainer ; 
 import cpw . mods . fml . common . network . ByteBufUtils ; 
 + import cpw . mods . fml . common . network . FMLProxyPacket ; 
 import cpw . mods . fml . common . network . NetworkRegistry ; 
 
 public abstract class FMLHandshakeMessage { 
 + public static FMLProxyPacket makeCustomChannelRegistration ( Set < String > channels ) 
 + { 
 + String salutation = Joiner . on ( ' \ 0 ' ) . join ( Iterables . concat ( Arrays . asList ( " FML | HS " , " FML " ) , channels ) ) ; 
 + FMLProxyPacket proxy = new FMLProxyPacket ( Unpooled . wrappedBuffer ( salutation . getBytes ( Charsets . UTF _ 8 ) ) , " REGISTER " ) ; 
 + return proxy ; 
 + } 
 public static class ServerHello extends FMLHandshakeMessage { 
 private byte serverProtocolVersion ; 
 public void toBytes ( ByteBuf buffer ) 
 @ @ - 48 , 38 + 60 , 12 @ @ public abstract class FMLHandshakeMessage { 
 return serverProtocolVersion ; 
 } 
 } 
 - public static class ServerModList extends FMLHandshakeMessage { 
 - private List < String > modTags = Lists . newArrayList ( ) ; 
 - 
 - @ Override 
 - public void toBytes ( ByteBuf buffer ) 
 - { 
 - super . toBytes ( buffer ) ; 
 - ByteBufUtils . writeVarInt ( buffer , modTags . size ( ) , 2 ) ; 
 - for ( String modTag : modTags ) 
 - { 
 - ByteBufUtils . writeUTF8String ( buffer , modTag ) ; 
 - } 
 - } 
 - 
 - @ Override 
 - public void fromBytes ( ByteBuf buffer ) 
 - { 
 - super . fromBytes ( buffer ) ; 
 - int modCount = ByteBufUtils . readVarInt ( buffer , 2 ) ; 
 - for ( int i = 0 ; i < modCount ; i + + ) 
 - { 
 - modTags . add ( ByteBufUtils . readUTF8String ( buffer ) ) ; 
 - } 
 - } 
 - } 
 - 
 - public static class ClientModList extends FMLHandshakeMessage { 
 - public ClientModList ( ) 
 + public static class ModList extends FMLHandshakeMessage { 
 + public ModList ( ) 
 { 
 
 } 
 - public ClientModList ( List < ModContainer > modList ) 
 + public ModList ( List < ModContainer > modList ) 
 { 
 for ( ModContainer mod : modList ) 
 { 
 @ @ - 126 , 6 + 112 , 45 @ @ public abstract class FMLHandshakeMessage { 
 } 
 } 
 
 + public static class ModIdData extends FMLHandshakeMessage { 
 + public ModIdData ( ) 
 + { 
 + 
 + } 
 + 
 + public ModIdData ( Map < String , Integer > modIds ) 
 + { 
 + this . modIds = modIds ; 
 + } 
 + 
 + private Map < String , Integer > modIds ; 
 + public void fromBytes ( ByteBuf buffer ) 
 + { 
 + int length = ByteBufUtils . readVarInt ( buffer , 3 ) ; 
 + modIds = Maps . newHashMap ( ) ; 
 + 
 + for ( int i = 0 ; i < length ; i + + ) 
 + { 
 + modIds . put ( ByteBufUtils . readUTF8String ( buffer ) , ByteBufUtils . readVarInt ( buffer , 3 ) ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void toBytes ( ByteBuf buffer ) 
 + { 
 + ByteBufUtils . writeVarInt ( buffer , modIds . size ( ) , 3 ) ; 
 + for ( Entry < String , Integer > entry : modIds . entrySet ( ) ) 
 + { 
 + ByteBufUtils . writeUTF8String ( buffer , entry . getKey ( ) ) ; 
 + ByteBufUtils . writeVarInt ( buffer , entry . getValue ( ) , 3 ) ; 
 + } 
 + } 
 + 
 + public Map < String , Integer > dataList ( ) 
 + { 
 + return modIds ; 
 + } 
 + } 
 public static class ClientAck extends FMLHandshakeMessage { 
 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java 
 index b79bac8 . . 6adfa18 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeServerState . java 
 @ @ - 2 , 7 + 2 , 11 @ @ package cpw . mods . fml . common . network . handshake ; 
 
 import io . netty . channel . ChannelHandlerContext ; 
 import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . common . Loader ; 
 import cpw . mods . fml . common . network . FMLNetworkHandler ; 
 + import cpw . mods . fml . common . network . NetworkRegistry ; 
 + import cpw . mods . fml . common . registry . GameData ; 
 + import cpw . mods . fml . relauncher . Side ; 
 
 enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 { 
 @ @ - 13 , 6 + 17 , 7 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 { 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . serverInitiateHandshake ( ) ; 
 + ctx . writeAndFlush ( FMLHandshakeMessage . makeCustomChannelRegistration ( NetworkRegistry . INSTANCE . channelNamesFor ( Side . SERVER ) ) ) ; 
 ctx . writeAndFlush ( new FMLHandshakeMessage . ServerHello ( ) ) ; 
 return HELLO ; 
 } 
 @ @ - 29 , 16 + 34 , 29 @ @ enum FMLHandshakeServerState implements IHandshakeState < FMLHandshakeServerState > 
 return this ; 
 } 
 
 - FMLHandshakeMessage . ClientModList client = ( FMLHandshakeMessage . ClientModList ) msg ; 
 + FMLHandshakeMessage . ModList client = ( FMLHandshakeMessage . ModList ) msg ; 
 FMLLog . info ( " Client attempting to join with % d mods : % s " , client . modListSize ( ) , client . modListAsString ( ) ) ; 
 - String result = FMLNetworkHandler . checkClientModList ( client ) ; 
 + String result = FMLNetworkHandler . checkModList ( client , Side . CLIENT ) ; 
 if ( result ! = null ) 
 { 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 dispatcher . rejectHandshake ( result ) ; 
 return ERROR ; 
 } 
 - ctx . writeAndFlush ( new FMLHandshakeMessage . ServerModList ( ) ) ; 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . ModList ( Loader . instance ( ) . getActiveModList ( ) ) ) ; 
 + if ( ctx . channel ( ) . attr ( NetworkDispatcher . IS _ LOCAL ) . get ( ) ) 
 + { 
 + return COMPLETE ; 
 + } 
 + return WAITINGCACK ; 
 + } 
 + } , 
 + WAITINGCACK 
 + { 
 + @ Override 
 + public FMLHandshakeServerState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 + { 
 + ctx . writeAndFlush ( new FMLHandshakeMessage . ModIdData ( GameData . buildItemDataList ( ) ) ) ; 
 return COMPLETE ; 
 } 
 } , 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / NetworkDispatcher . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / NetworkDispatcher . java 
 index cafc7e3 . . 2987e4d 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / NetworkDispatcher . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / NetworkDispatcher . java 
 @ @ - 56 , 6 + 56 , 7 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { 
 } 
 
 public static final AttributeKey < NetworkDispatcher > FML _ DISPATCHER = new AttributeKey < NetworkDispatcher > ( " fml : dispatcher " ) ; 
 + public static final AttributeKey < Boolean > IS _ LOCAL = new AttributeKey < Boolean > ( " fml : isLocal " ) ; 
 private final NetworkManager manager ; 
 private final ServerConfigurationManager scm ; 
 private EntityPlayerMP player ; 
 @ @ - 70 , 9 + 71 , 11 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { 
 this . manager = manager ; 
 this . scm = null ; 
 this . side = Side . CLIENT ; 
 - this . handshakeChannel = new EmbeddedChannel ( new HandshakeInjector ( this ) , new FMLHandshakeCodec ( ) , new HandshakeMessageHandler < FMLHandshakeClientState > ( FMLHandshakeClientState . class ) ) ; 
 + this . handshakeChannel = new EmbeddedChannel ( new HandshakeInjector ( this ) , new ChannelRegistrationHandler ( ) , new FMLHandshakeCodec ( ) , new HandshakeMessageHandler < FMLHandshakeClientState > ( FMLHandshakeClientState . class ) ) ; 
 this . handshakeChannel . attr ( FML _ DISPATCHER ) . set ( this ) ; 
 + this . handshakeChannel . attr ( NetworkRegistry . CHANNEL _ SOURCE ) . set ( Side . SERVER ) ; 
 this . handshakeChannel . attr ( NetworkRegistry . FML _ CHANNEL ) . set ( " FML | HS " ) ; 
 + this . handshakeChannel . attr ( IS _ LOCAL ) . set ( manager . func _ 150731 _ c ( ) ) ; 
 } 
 
 public NetworkDispatcher ( NetworkManager manager , ServerConfigurationManager scm ) 
 @ @ - 81 , 9 + 84 , 11 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { 
 this . manager = manager ; 
 this . scm = scm ; 
 this . side = Side . SERVER ; 
 - this . handshakeChannel = new EmbeddedChannel ( new HandshakeInjector ( this ) , new FMLHandshakeCodec ( ) , new HandshakeMessageHandler < FMLHandshakeServerState > ( FMLHandshakeServerState . class ) ) ; 
 + this . handshakeChannel = new EmbeddedChannel ( new HandshakeInjector ( this ) , new ChannelRegistrationHandler ( ) , new FMLHandshakeCodec ( ) , new HandshakeMessageHandler < FMLHandshakeServerState > ( FMLHandshakeServerState . class ) ) ; 
 this . handshakeChannel . attr ( FML _ DISPATCHER ) . set ( this ) ; 
 + this . handshakeChannel . attr ( NetworkRegistry . CHANNEL _ SOURCE ) . set ( Side . CLIENT ) ; 
 this . handshakeChannel . attr ( NetworkRegistry . FML _ CHANNEL ) . set ( " FML | HS " ) ; 
 + this . handshakeChannel . attr ( IS _ LOCAL ) . set ( manager . func _ 150731 _ c ( ) ) ; 
 } 
 
 public void serverToClientHandshake ( EntityPlayerMP player ) 
 @ @ - 210 , 7 + 215 , 7 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { 
 private boolean handleClientSideCustomPacket ( S3FPacketCustomPayload msg , ChannelHandlerContext context ) 
 { 
 String channelName = msg . func _ 149169 _ c ( ) ; 
 - if ( " FML | HS " . equals ( channelName ) ) 
 + if ( " FML | HS " . equals ( channelName ) | | " REGISTER " . equals ( channelName ) | | " UNREGISTER " . equals ( channelName ) ) 
 { 
 FMLProxyPacket proxy = new FMLProxyPacket ( msg ) ; 
 handshakeChannel . writeInbound ( proxy ) ; 
 @ @ - 233 , 7 + 238 , 7 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet > { 
 state = ConnectionState . HANDSHAKING ; 
 } 
 String channelName = msg . func _ 149559 _ c ( ) ; 
 - if ( " FML | HS " . equals ( channelName ) ) 
 + if ( " FML | HS " . equals ( channelName ) | | " REGISTER " . equals ( channelName ) | | " UNREGISTER " . equals ( channelName ) ) 
 { 
 FMLProxyPacket proxy = new FMLProxyPacket ( msg ) ; 
 handshakeChannel . writeInbound ( proxy ) ; 
 diff - - git a / fml / src / main / java / cpw / mods / fml / server / FMLServerHandler . java b / fml / src / main / java / cpw / mods / fml / server / FMLServerHandler . java 
 index e0622d2 . . 9da326f 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / server / FMLServerHandler . java 
 + + + b / fml / src / main / java / cpw / mods / fml / server / FMLServerHandler . java 
 @ @ - 38 , 7 + 38 , 6 @ @ import cpw . mods . fml . common . network . packet . EntitySpawnAdjustmentPacket ; 
 import cpw . mods . fml . common . network . packet . EntitySpawnPacket ; 
 import cpw . mods . fml . common . network . packet . ModMissingPacket ; 
 import cpw . mods . fml . common . registry . EntityRegistry . EntityRegistration ; 
 - import cpw . mods . fml . common . registry . GameData ; 
 import cpw . mods . fml . common . registry . LanguageRegistry ; 
 import cpw . mods . fml . relauncher . Side ; 
 
 @ @ - 96 , 7 + 95 , 6 @ @ public class FMLServerHandler implements IFMLSidedHandler 
 { 
 Loader . instance ( ) . initializeMods ( ) ; 
 LanguageRegistry . reloadLanguageTable ( ) ; 
 - GameData . initializeServerGate ( 1 ) ; 
 } 
 
 @ Override
