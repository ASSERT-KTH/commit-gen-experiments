BLEU SCORE: 0.02383853510228548

TEST MSG: Tabulate crash report mod list and add signature information
GENERATED MSG: Mod sorting

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / ForgeModContainer . java b / src / main / java / net / minecraftforge / common / ForgeModContainer . java <nl> index de8b492 . . edf614d 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / ForgeModContainer . java <nl> + + + b / src / main / java / net / minecraftforge / common / ForgeModContainer . java <nl> @ @ - 414 , 6 + 414 , 11 @ @ public class ForgeModContainer extends DummyModContainer implements WorldAccessC <nl> all . add ( asm . getClassName ( ) ) ; <nl> for ( ASMData asm : evt . getASMHarvestedData ( ) . getAll ( ICrashCallable . class . getName ( ) . replace ( ' . ' , ' / ' ) ) ) <nl> all . add ( asm . getClassName ( ) ) ; <nl> + / / Add table classes for mod list tabulation <nl> + all . add ( " net / minecraftforge / common / util / TextTable " ) ; <nl> + all . add ( " net / minecraftforge / common / util / TextTable $ Column " ) ; <nl> + all . add ( " net / minecraftforge / common / util / TextTable $ Row " ) ; <nl> + all . add ( " net / minecraftforge / common / util / TextTable $ Alignment " ) ; <nl> <nl> all . removeIf ( cls - > ! cls . startsWith ( " net / minecraft / " ) & & ! cls . startsWith ( " net / minecraftforge / " ) ) ; <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / common / util / TextTable . java b / src / main / java / net / minecraftforge / common / util / TextTable . java <nl> new file mode 100644 <nl> index 0000000 . . b14c973 <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / common / util / TextTable . java <nl> @ @ - 0 , 0 + 1 , 220 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package net . minecraftforge . common . util ; <nl> + <nl> + import com . google . common . collect . Streams ; <nl> + import org . apache . commons . lang3 . StringUtils ; <nl> + <nl> + import javax . annotation . Nonnull ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> + import java . util . Objects ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + / * * <nl> + * Utility to format data into a textual ( markdown - compliant ) table . <nl> + * / <nl> + public class TextTable <nl> + { <nl> + public static Column column ( String header ) <nl> + { <nl> + return new Column ( header ) ; <nl> + } <nl> + <nl> + public static Column column ( String header , Alignment alignment ) <nl> + { <nl> + return new Column ( header , alignment ) ; <nl> + } <nl> + <nl> + private final List < Column > columns ; <nl> + private final List < Row > rows = new ArrayList < > ( ) ; <nl> + <nl> + public TextTable ( List < Column > columns ) <nl> + { <nl> + this . columns = columns ; <nl> + } <nl> + <nl> + public String build ( String lineEnding ) <nl> + { <nl> + StringBuilder destination = new StringBuilder ( ) ; <nl> + append ( destination , lineEnding ) ; <nl> + return destination . toString ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Appends the data formatted as a table to the given string builder . <nl> + * The padding character used for the column alignments is a single space ( ' ' ) , <nl> + * the separate between column headers and values is a dash ( ' - ' ) . <nl> + * Note that you * have * to specify a line ending , ' \ n ' isn ' t used by default . <nl> + * < p > <nl> + * The generated table is compliant with the markdown file format . <nl> + * <nl> + * @ param destination a string builder to append the table to <nl> + * @ param lineEnding the line ending to use for each row of the table <nl> + * / <nl> + public void append ( StringBuilder destination , String lineEnding ) <nl> + { <nl> + List < String > headers = columns . stream ( ) . map ( c - > c . formatHeader ( " " ) ) . collect ( Collectors . toList ( ) ) ; <nl> + printRow ( destination , headers ) ; <nl> + destination . append ( lineEnding ) ; <nl> + printSeparators ( destination ) ; <nl> + for ( Row row : rows ) <nl> + { <nl> + destination . append ( lineEnding ) ; <nl> + printRow ( destination , row . format ( columns , " " ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void printSeparators ( StringBuilder destination ) <nl> + { <nl> + destination . append ( ' | ' ) ; <nl> + for ( Column column : columns ) <nl> + { <nl> + destination . append ( column . alignment ! = Alignment . RIGHT ? ' : ' : ' ' ) ; <nl> + destination . append ( column . getSeparator ( ' - ' ) ) ; <nl> + destination . append ( column . alignment ! = Alignment . LEFT ? ' : ' : ' ' ) ; <nl> + destination . append ( ' | ' ) ; <nl> + } <nl> + } <nl> + <nl> + private void printRow ( StringBuilder destination , List < String > values ) <nl> + { <nl> + destination . append ( ' | ' ) ; <nl> + for ( String value : values ) <nl> + { <nl> + destination . append ( ' ' ) ; <nl> + destination . append ( value ) ; <nl> + destination . append ( ' ' ) ; <nl> + destination . append ( ' | ' ) ; <nl> + } <nl> + } <nl> + <nl> + public void add ( @ Nonnull Object . . . values ) <nl> + { <nl> + if ( values . length ! = columns . size ( ) ) <nl> + { <nl> + throw new IllegalArgumentException ( " Received wrong amount of values for table row , expected " + columns . size ( ) + " , received " + columns . size ( ) + " . " ) ; <nl> + } <nl> + Row row = new Row ( ) ; <nl> + for ( int i = 0 ; i < values . length ; i + + ) <nl> + { <nl> + String value = Objects . toString ( values [ i ] ) ; <nl> + row . values . add ( value ) ; <nl> + columns . get ( i ) . fit ( value ) ; <nl> + } <nl> + rows . add ( row ) ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + for ( Column column : columns ) <nl> + { <nl> + column . resetWidth ( ) ; <nl> + } <nl> + rows . clear ( ) ; <nl> + } <nl> + <nl> + public List < Column > getColumns ( ) <nl> + { <nl> + return Collections . unmodifiableList ( columns ) ; <nl> + } <nl> + <nl> + public static class Column <nl> + { <nl> + private String header ; <nl> + private int width ; <nl> + private Alignment alignment ; <nl> + <nl> + public Column ( String header ) <nl> + { <nl> + this ( header , Alignment . LEFT ) ; <nl> + } <nl> + <nl> + public Column ( String header , Alignment alignment ) <nl> + { <nl> + this . header = header ; <nl> + this . width = header . length ( ) ; <nl> + this . alignment = alignment ; <nl> + } <nl> + <nl> + public String formatHeader ( String padding ) <nl> + { <nl> + return format ( header , padding ) ; <nl> + } <nl> + <nl> + public String format ( String value , String padding ) <nl> + { <nl> + switch ( alignment ) <nl> + { <nl> + case LEFT : <nl> + return StringUtils . rightPad ( value , width , padding ) ; <nl> + case RIGHT : <nl> + return StringUtils . leftPad ( value , width , padding ) ; <nl> + default : <nl> + int length = value . length ( ) ; <nl> + int left = ( width - length ) / 2 ; <nl> + int leftWidth = left + length ; <nl> + return StringUtils . rightPad ( StringUtils . leftPad ( value , leftWidth , padding ) , width , padding ) ; <nl> + } <nl> + } <nl> + <nl> + public String getSeparator ( char character ) <nl> + { <nl> + return StringUtils . leftPad ( " " , width , character ) ; <nl> + } <nl> + <nl> + public void fit ( String value ) <nl> + { <nl> + if ( value . length ( ) > width ) <nl> + { <nl> + width = value . length ( ) ; <nl> + } <nl> + } <nl> + <nl> + public void resetWidth ( ) <nl> + { <nl> + this . width = header . length ( ) ; <nl> + } <nl> + <nl> + public int getWidth ( ) <nl> + { <nl> + return width ; <nl> + } <nl> + } <nl> + <nl> + public static class Row <nl> + { <nl> + private final ArrayList < String > values = new ArrayList < > ( ) ; <nl> + <nl> + public List < String > format ( List < Column > columns , String padding ) <nl> + { <nl> + if ( columns . size ( ) ! = values . size ( ) ) <nl> + { <nl> + throw new IllegalArgumentException ( " Received wrong amount of columns for table row , expected " + columns . size ( ) + " , received " + columns . size ( ) + " . " ) ; <nl> + } <nl> + return Streams . zip ( values . stream ( ) , columns . stream ( ) , ( v , c ) - > c . format ( v , padding ) ) . collect ( Collectors . toList ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + public enum Alignment <nl> + { <nl> + LEFT , CENTER , RIGHT <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / LoadController . java b / src / main / java / net / minecraftforge / fml / common / LoadController . java <nl> index e612ceb . . 0876732 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / LoadController . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / LoadController . java <nl> @ @ - 28 , 6 + 28 , 7 @ @ import java . util . Map ; <nl> import java . util . Map . Entry ; <nl> import java . util . stream . Collectors ; <nl> <nl> + import net . minecraftforge . common . util . TextTable ; <nl> import net . minecraftforge . fml . common . LoaderState . ModState ; <nl> import net . minecraftforge . fml . common . ProgressManager . ProgressBar ; <nl> import net . minecraftforge . fml . common . event . FMLEvent ; <nl> @ @ - 310 , 14 + 311 , 28 @ @ public class LoadController <nl> for ( ModState state : ModState . values ( ) ) <nl> ret . append ( " ' " ) . append ( state . getMarker ( ) ) . append ( " ' = " ) . append ( state . toString ( ) ) ; <nl> <nl> + TextTable table = new TextTable ( Lists . newArrayList ( <nl> + TextTable . column ( " State " ) , <nl> + TextTable . column ( " ID " ) , <nl> + TextTable . column ( " Version " ) , <nl> + TextTable . column ( " Source " ) , <nl> + TextTable . column ( " Signature " ) ) <nl> + ) ; <nl> for ( ModContainer mc : loader . getModList ( ) ) <nl> { <nl> - ret . append ( " \ n \ t " ) ; <nl> - for ( ModState state : modStates . get ( mc . getModId ( ) ) ) <nl> - ret . append ( state . getMarker ( ) ) ; <nl> - <nl> - ret . append ( " \ t " ) . append ( mc . getModId ( ) ) . append ( " { " ) . append ( mc . getVersion ( ) ) . append ( " } [ " ) . append ( mc . getName ( ) ) . append ( " ] ( " ) . append ( mc . getSource ( ) . getName ( ) ) . append ( " ) " ) ; <nl> + table . add ( <nl> + modStates . get ( mc . getModId ( ) ) . stream ( ) . map ( ModState : : getMarker ) . reduce ( " " , ( a , b ) - > a + b ) , <nl> + mc . getModId ( ) , <nl> + mc . getVersion ( ) , <nl> + mc . getSource ( ) . getName ( ) , <nl> + mc . getSigningCertificate ( ) ! = null ? CertificateHelper . getFingerprint ( mc . getSigningCertificate ( ) ) : " None " <nl> + ) ; <nl> } <nl> + <nl> + ret . append ( " \ n " ) ; <nl> + ret . append ( " \ n \ t " ) ; <nl> + table . append ( ret , " \ n \ t " ) ; <nl> + ret . append ( " \ n " ) ; <nl> } <nl> <nl> public List < ModContainer > getActiveModList ( ) <nl> diff - - git a / src / test / java / net / minecraftforge / test / TextTableTest . java b / src / test / java / net / minecraftforge / test / TextTableTest . java <nl> new file mode 100644 <nl> index 0000000 . . 0203eaa <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / test / TextTableTest . java <nl> @ @ - 0 , 0 + 1 , 119 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . test ; <nl> + <nl> + import com . google . common . collect . Lists ; <nl> + import net . minecraftforge . common . util . TextTable ; <nl> + import net . minecraftforge . common . util . TextTable . Column ; <nl> + import org . junit . Assert ; <nl> + import org . junit . Test ; <nl> + <nl> + import static net . minecraftforge . common . util . TextTable . column ; <nl> + <nl> + public class TextTableTest <nl> + { <nl> + private static final String WIDTH _ REFERENCE = " StringOfWidth15 " ; <nl> + private static final int WIDTH _ REFERENCE _ LENGTH = WIDTH _ REFERENCE . length ( ) ; <nl> + <nl> + @ Test <nl> + public void testColumnWidthAdjustment ( ) <nl> + { <nl> + Column column = column ( " Column " , TextTable . Alignment . LEFT ) ; <nl> + column . fit ( WIDTH _ REFERENCE ) ; <nl> + String paddedHeader = column . formatHeader ( " - " ) ; <nl> + Assert . assertEquals ( " Formatted column header didn ' t have correct length " , WIDTH _ REFERENCE _ LENGTH , paddedHeader . length ( ) ) ; <nl> + Assert . assertEquals ( " Formatted column header wasn ' t padded properly " , " Column - - - - - - - - - " , paddedHeader ) ; <nl> + <nl> + String paddedReference = column . format ( WIDTH _ REFERENCE , " - " ) ; <nl> + Assert . assertEquals ( " Formatted width reference didn ' t have correct length " , WIDTH _ REFERENCE _ LENGTH , paddedReference . length ( ) ) ; <nl> + Assert . assertEquals ( " Formatted width reference was changed despite defining width " , WIDTH _ REFERENCE , paddedReference ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testLeftAlignment ( ) <nl> + { <nl> + Column column = column ( " Left " , TextTable . Alignment . LEFT ) ; <nl> + column . fit ( WIDTH _ REFERENCE ) ; <nl> + <nl> + String paddedHeader = column . formatHeader ( " - " ) ; <nl> + Assert . assertEquals ( " Left - aligned header should be padded on the right " , " Left - - - - - - - - - - - " , paddedHeader ) ; <nl> + String paddedReference = column . format ( WIDTH _ REFERENCE , " - " ) ; <nl> + Assert . assertEquals ( " Left - aligned reference should ' nt be padded " , WIDTH _ REFERENCE , paddedReference ) ; <nl> + String paddedValue = column . format ( " Value " , " - " ) ; <nl> + Assert . assertEquals ( " Left - aligned value should be padded on the right " , " Value - - - - - - - - - - " , paddedValue ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCenterAlignment ( ) <nl> + { <nl> + Column column = column ( " Centered " , TextTable . Alignment . CENTER ) ; <nl> + column . fit ( WIDTH _ REFERENCE ) ; <nl> + <nl> + String paddedHeader = column . formatHeader ( " - " ) ; <nl> + Assert . assertEquals ( " Centered header should be padded equally on both sides " , " - - - Centered - - - - " , paddedHeader ) ; <nl> + String paddedReference = column . format ( WIDTH _ REFERENCE , " - " ) ; <nl> + Assert . assertEquals ( " Centered reference should ' nt be padded " , WIDTH _ REFERENCE , paddedReference ) ; <nl> + String paddedValue = column . format ( " Value " , " - " ) ; <nl> + Assert . assertEquals ( " Centered value should be padded equally on both sides " , " - - - - - Value - - - - - " , paddedValue ) ; <nl> + String paddedOffCenter = column . format ( " Value1 " , " - " ) ; <nl> + Assert . assertNotEquals ( " Center padding should be left - biased " , " - - - - - Value1 - - - - " , paddedOffCenter ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRightAlignment ( ) <nl> + { <nl> + Column column = column ( " Right " , TextTable . Alignment . RIGHT ) ; <nl> + column . fit ( WIDTH _ REFERENCE ) ; <nl> + <nl> + String paddedHeader = column . formatHeader ( " - " ) ; <nl> + Assert . assertEquals ( " Right - aligned header should be padded on the left " , " - - - - - - - - - - Right " , paddedHeader ) ; <nl> + String paddedReference = column . format ( WIDTH _ REFERENCE , " - " ) ; <nl> + Assert . assertEquals ( " Right - aligned reference should ' nt be padded " , WIDTH _ REFERENCE , paddedReference ) ; <nl> + String paddedValue = column . format ( " Value " , " - " ) ; <nl> + Assert . assertEquals ( " Right - aligned value should be padded on the left " , " - - - - - - - - - - Value " , paddedValue ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testMarkdownCompliance ( ) <nl> + { <nl> + TextTable table = new TextTable ( Lists . newArrayList ( <nl> + column ( " Left " , TextTable . Alignment . LEFT ) , <nl> + column ( " Center " , TextTable . Alignment . CENTER ) , <nl> + column ( " Right " , TextTable . Alignment . RIGHT ) <nl> + ) ) ; <nl> + table . add ( " Long Value 1 " , " Value 2 " , " Value 3 " ) ; <nl> + table . add ( " Value 1 " , " Long Value 2 " , " Value 3 " ) ; <nl> + table . add ( " Value 1 " , " Value 2 " , " Long Value 3 " ) ; <nl> + int [ ] columnWidths = table . getColumns ( ) . stream ( ) . mapToInt ( Column : : getWidth ) . toArray ( ) ; <nl> + Assert . assertArrayEquals ( " Column widths should adjust for long values " , new int [ ] { 12 , 12 , 12 } , columnWidths ) ; <nl> + <nl> + String [ ] result = table . build ( " \ n " ) . split ( " \ n " ) ; <nl> + Assert . assertEquals ( " Header row + separator row + value rows should result in 5 lines " , 5 , result . length ) ; <nl> + Assert . assertEquals ( <nl> + " Column headers should be properly formatted " , <nl> + " | Left | Center | Right | " , <nl> + result [ 0 ] ) ; <nl> + Assert . assertEquals ( <nl> + " Header - body separators should contain markdown alignment information " , <nl> + " | : - - - - - - - - - - - - | : - - - - - - - - - - - - : | - - - - - - - - - - - - : | " , <nl> + result [ 1 ] <nl> + ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / fml / . settings / org . eclipse . ltk . core . refactoring . prefs b / fml / . settings / org . eclipse . ltk . core . refactoring . prefs <nl> new file mode 100644 <nl> index 0000000 . . b196c64 <nl> - - - / dev / null <nl> + + + b / fml / . settings / org . eclipse . ltk . core . refactoring . prefs <nl> @ @ - 0 , 0 + 1 , 2 @ @ <nl> + eclipse . preferences . version = 1 <nl> + org . eclipse . ltk . core . refactoring . enable . project . refactoring . history = false <nl> diff - - git a / fml / . settings / org . eclipse . m2e . core . prefs b / fml / . settings / org . eclipse . m2e . core . prefs <nl> new file mode 100644 <nl> index 0000000 . . f897a7f <nl> - - - / dev / null <nl> + + + b / fml / . settings / org . eclipse . m2e . core . prefs <nl> @ @ - 0 , 0 + 1 , 4 @ @ <nl> + activeProfiles = <nl> + eclipse . preferences . version = 1 <nl> + resolveWorkspaceProjects = true <nl> + version = 1 <nl> diff - - git a / fml / common / cpw / mods / fml / common / FMLModContainer . java b / fml / common / cpw / mods / fml / common / FMLModContainer . java <nl> index 77184e7 . . c33b911 100644 <nl> - - - a / fml / common / cpw / mods / fml / common / FMLModContainer . java <nl> + + + b / fml / common / cpw / mods / fml / common / FMLModContainer . java <nl> @ @ - 18 , 8 + 18 , 16 @ @ import java . util . List ; <nl> public class FMLModContainer implements ModContainer { <nl> private Mod modDescriptor ; <nl> private Object modInstance ; <nl> + private String source ; <nl> <nl> + public FMLModContainer ( String source ) { <nl> + this . source = source ; <nl> + } <nl> + <nl> public FMLModContainer ( Class < ? > clazz ) { <nl> + if ( clazz = = null ) { <nl> + return ; <nl> + } <nl> modDescriptor = clazz . getAnnotation ( Mod . class ) ; <nl> <nl> try { <nl> @ @ - 86 , 8 + 94 , 7 @ @ public class FMLModContainer implements ModContainer { <nl> <nl> @ Override <nl> public String getSource ( ) { <nl> - / / TODO Auto - generated method stub <nl> - return null ; <nl> + return source ; <nl> } <nl> <nl> @ Override <nl> @ @ - 189 , 4 + 196 , 11 @ @ public class FMLModContainer implements ModContainer { <nl> return new ArrayList < String > ( 0 ) ; <nl> } <nl> <nl> + / * ( non - Javadoc ) <nl> + * @ see java . lang . Object # toString ( ) <nl> + * / <nl> + @ Override <nl> + public String toString ( ) { <nl> + return getSource ( ) ; <nl> + } <nl> } <nl> diff - - git a / fml / common / cpw / mods / fml / common / Loader . java b / fml / common / cpw / mods / fml / common / Loader . java <nl> index 8ca6b7c . . 9cbad60 100644 <nl> - - - a / fml / common / cpw / mods / fml / common / Loader . java <nl> + + + b / fml / common / cpw / mods / fml / common / Loader . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import java . util . regex . Pattern ; <nl> import java . util . zip . ZipEntry ; <nl> import java . util . zip . ZipFile ; <nl> <nl> + import cpw . mods . fml . common . toposort . ModSorter ; <nl> import cpw . mods . fml . server . FMLHandler ; <nl> <nl> public class Loader { <nl> @ @ - 78 , 6 + 79 , 7 @ @ public class Loader { <nl> } <nl> <nl> private void sortModList ( ) { <nl> + log . fine ( " Verifying mod dependencies are satisfied " ) ; <nl> for ( ModContainer mod : mods ) { <nl> if ( ! namedMods . keySet ( ) . containsAll ( mod . getDependencies ( ) ) ) { <nl> log . severe ( String . format ( " The mod % s requires mods % s to be available , one or more are not " , mod . getName ( ) , mod . getDependencies ( ) ) ) ; <nl> @ @ - 86 , 6 + 88 , 17 @ @ public class Loader { <nl> throw new LoaderException ( ) ; <nl> } <nl> } <nl> + log . fine ( " All dependencies are satisfied " ) ; <nl> + ModSorter sorter = new ModSorter ( mods , namedMods ) ; <nl> + try { <nl> + log . fine ( " Sorting mods into an ordered list " ) ; <nl> + mods = sorter . sort ( ) ; <nl> + log . fine ( String . format ( " Mod list sorted % s " , mods ) ) ; <nl> + } catch ( IllegalArgumentException iae ) { <nl> + log . severe ( " A dependency cycle was detected in the input mod set so they cannot load them in order " ) ; <nl> + log . throwing ( " Loader " , " sortModList " , iae ) ; <nl> + throw new LoaderException ( iae ) ; <nl> + } <nl> } <nl> <nl> private void preModInit ( ) { <nl> diff - - git a / fml / common / cpw / mods / fml / common / toposort / ModSorter . java b / fml / common / cpw / mods / fml / common / toposort / ModSorter . java <nl> new file mode 100644 <nl> index 0000000 . . 5115fb4 <nl> - - - / dev / null <nl> + + + b / fml / common / cpw / mods / fml / common / toposort / ModSorter . java <nl> @ @ - 0 , 0 + 1 , 93 @ @ <nl> + / * <nl> + * The FML Forge Mod Loader suite . Copyright ( C ) 2012 cpw <nl> + * <nl> + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> + * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package cpw . mods . fml . common . toposort ; <nl> + <nl> + import java . util . Arrays ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + <nl> + import cpw . mods . fml . common . FMLModContainer ; <nl> + import cpw . mods . fml . common . ModContainer ; <nl> + import cpw . mods . fml . common . toposort . TopologicalSort . DirectedGraph ; <nl> + <nl> + / * * <nl> + * @ author cpw <nl> + * <nl> + * / <nl> + public class ModSorter { <nl> + private DirectedGraph < ModContainer > modGraph ; <nl> + <nl> + private ModContainer beforeAll = new FMLModContainer ( " DummyBeforeAll " ) ; <nl> + private ModContainer afterAll = new FMLModContainer ( " DummyAfterAll " ) ; <nl> + private ModContainer before = new FMLModContainer ( " DummyBefore " ) ; <nl> + private ModContainer after = new FMLModContainer ( " DummyAfter " ) ; <nl> + <nl> + public ModSorter ( List < ModContainer > modList , Map < String , ModContainer > nameLookup ) { <nl> + buildGraph ( modList , nameLookup ) ; <nl> + } <nl> + <nl> + private void buildGraph ( List < ModContainer > modList , Map < String , ModContainer > nameLookup ) { <nl> + modGraph = new DirectedGraph < ModContainer > ( ) ; <nl> + modGraph . addNode ( beforeAll ) ; <nl> + modGraph . addNode ( before ) ; <nl> + modGraph . addNode ( afterAll ) ; <nl> + modGraph . addNode ( after ) ; <nl> + <nl> + modGraph . addEdge ( before , after ) ; <nl> + modGraph . addEdge ( beforeAll , before ) ; <nl> + modGraph . addEdge ( after , afterAll ) ; <nl> + for ( ModContainer mod : modList ) { <nl> + modGraph . addNode ( mod ) ; <nl> + } <nl> + for ( ModContainer mod : modList ) { <nl> + boolean preDepAdded = false ; <nl> + boolean postDepAdded = false ; <nl> + for ( String dep : mod . getPreDepends ( ) ) { <nl> + preDepAdded = true ; <nl> + if ( dep . equals ( " * " ) ) { <nl> + / / We are " after " everything <nl> + modGraph . addEdge ( mod , afterAll ) ; <nl> + modGraph . addEdge ( after , mod ) ; <nl> + postDepAdded = true ; <nl> + } else { <nl> + modGraph . addEdge ( before , mod ) ; <nl> + modGraph . addEdge ( nameLookup . get ( dep ) , mod ) ; <nl> + } <nl> + } <nl> + for ( String dep : mod . getPostDepends ( ) ) { <nl> + postDepAdded = true ; <nl> + if ( dep . equals ( " * " ) ) { <nl> + / / We are " before " everything <nl> + modGraph . addEdge ( beforeAll , mod ) ; <nl> + modGraph . addEdge ( mod , before ) ; <nl> + preDepAdded = true ; <nl> + } else { <nl> + modGraph . addEdge ( mod , after ) ; <nl> + modGraph . addEdge ( mod , nameLookup . get ( dep ) ) ; <nl> + } <nl> + } <nl> + if ( ! preDepAdded ) { <nl> + modGraph . addEdge ( before , mod ) ; <nl> + } <nl> + if ( ! postDepAdded ) { <nl> + modGraph . addEdge ( mod , after ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public List < ModContainer > sort ( ) { <nl> + List < ModContainer > sortedList = TopologicalSort . topologicalSort ( modGraph ) ; <nl> + sortedList . removeAll ( Arrays . asList ( new ModContainer [ ] { beforeAll , before , after , afterAll } ) ) ; <nl> + return sortedList ; <nl> + } <nl> + } <nl> diff - - git a / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java b / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java <nl> new file mode 100644 <nl> index 0000000 . . 37b5bf2 <nl> - - - / dev / null <nl> + + + b / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java <nl> @ @ - 0 , 0 + 1 , 155 @ @ <nl> + / * <nl> + * The FML Forge Mod Loader suite . <nl> + * Copyright ( C ) 2012 cpw <nl> + * <nl> + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> + * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package cpw . mods . fml . common . toposort ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . HashSet ; <nl> + import java . util . Iterator ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . NoSuchElementException ; <nl> + import java . util . Set ; <nl> + <nl> + / * * <nl> + * Topological sort for mod loading <nl> + * <nl> + * Based on a variety of sources , including http : / / keithschwarz . com / interesting / code / ? dir = topological - sort <nl> + * @ author cpw <nl> + * <nl> + * / <nl> + public class TopologicalSort { <nl> + public static class DirectedGraph < T > implements Iterable < T > { <nl> + private final Map < T , Set < T > > graph = new HashMap < T , Set < T > > ( ) ; <nl> + <nl> + public boolean addNode ( T node ) { <nl> + / / Ignore nodes already added <nl> + if ( graph . containsKey ( node ) ) { <nl> + return false ; <nl> + } <nl> + graph . put ( node , new HashSet < T > ( ) ) ; <nl> + return true ; <nl> + } <nl> + <nl> + public void addEdge ( T from , T to ) { <nl> + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { <nl> + throw new NoSuchElementException ( " Missing nodes from graph " ) ; <nl> + } <nl> + graph . get ( from ) . add ( to ) ; <nl> + } <nl> + <nl> + public void removeEdge ( T from , T to ) { <nl> + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { <nl> + throw new NoSuchElementException ( " Missing nodes from graph " ) ; <nl> + } <nl> + graph . get ( from ) . remove ( to ) ; <nl> + } <nl> + <nl> + public boolean edgeExists ( T from , T to ) { <nl> + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { <nl> + throw new NoSuchElementException ( " Missing nodes from graph " ) ; <nl> + } <nl> + return graph . get ( from ) . contains ( to ) ; <nl> + } <nl> + <nl> + public Set < T > edgesFrom ( T from ) { <nl> + if ( ! graph . containsKey ( from ) ) { <nl> + throw new NoSuchElementException ( " Missing node from graph " ) ; <nl> + } <nl> + return Collections . unmodifiableSet ( graph . get ( from ) ) ; <nl> + } <nl> + @ Override <nl> + public Iterator < T > iterator ( ) { <nl> + return graph . keySet ( ) . iterator ( ) ; <nl> + } <nl> + <nl> + public int size ( ) { <nl> + return graph . size ( ) ; <nl> + } <nl> + <nl> + public boolean isEmpty ( ) { <nl> + return graph . isEmpty ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) { <nl> + return graph . toString ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Sort the input graph into a topologically sorted list <nl> + * <nl> + * Uses the reverse depth first search as outlined in . . . <nl> + * @ param graph <nl> + * @ return <nl> + * / <nl> + public static < T > List < T > topologicalSort ( DirectedGraph < T > graph ) { <nl> + DirectedGraph < T > rGraph = reverse ( graph ) ; <nl> + <nl> + List < T > sortedResult = new ArrayList < T > ( ) ; <nl> + Set < T > visitedNodes = new HashSet < T > ( ) ; <nl> + <nl> + / / A list of " fully explored " nodes . Leftovers in here indicate cycles in the graph <nl> + Set < T > expandedNodes = new HashSet < T > ( ) ; <nl> + <nl> + for ( T node : rGraph ) { <nl> + explore ( node , rGraph , sortedResult , visitedNodes , expandedNodes ) ; <nl> + } <nl> + <nl> + return sortedResult ; <nl> + } <nl> + <nl> + public static < T > DirectedGraph < T > reverse ( DirectedGraph < T > graph ) { <nl> + DirectedGraph < T > result = new DirectedGraph < T > ( ) ; <nl> + for ( T node : graph ) { <nl> + result . addNode ( node ) ; <nl> + } <nl> + for ( T from : graph ) { <nl> + for ( T to : graph . edgesFrom ( from ) ) { <nl> + result . addEdge ( to , from ) ; <nl> + } <nl> + } <nl> + <nl> + return result ; <nl> + } <nl> + <nl> + public static < T > void explore ( T node , DirectedGraph < T > graph , List < T > sortedResult , Set < T > visitedNodes , Set < T > expandedNodes ) { <nl> + / / Have we been here before ? <nl> + if ( visitedNodes . contains ( node ) ) { <nl> + / / And have completed this node before <nl> + if ( expandedNodes . contains ( node ) ) { <nl> + / / Then we ' re fine <nl> + return ; <nl> + } <nl> + System . out . printf ( " % s : % s \ n % s \ n % s \ n " , node , sortedResult , visitedNodes , expandedNodes ) ; <nl> + throw new IllegalArgumentException ( " There was a cycle detected in the input graph , sorting is not possible " ) ; <nl> + } <nl> + <nl> + / / Visit this node <nl> + visitedNodes . add ( node ) ; <nl> + <nl> + / / Recursively explore inbound edges <nl> + for ( T inbound : graph . edgesFrom ( node ) ) { <nl> + explore ( inbound , graph , sortedResult , visitedNodes , expandedNodes ) ; <nl> + } <nl> + <nl> + / / Add ourselves now <nl> + sortedResult . add ( node ) ; <nl> + <nl> + / / And mark ourselves as explored <nl> + expandedNodes . add ( node ) ; <nl> + } <nl> + } <nl> diff - - git a / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java b / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java <nl> index 8c57058 . . 922e4f8 100644 <nl> - - - a / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java <nl> + + + b / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java <nl> @ @ - 14 , 7 + 14 , 6 @ @ <nl> package cpw . mods . fml . server ; <nl> <nl> import java . util . ArrayList ; <nl> - import java . util . Collections ; <nl> import java . util . List ; <nl> import java . util . StringTokenizer ; <nl> <nl> @ @ - 32 , 6 + 31 , 9 @ @ public class ModLoaderModContainer implements ModContainer { <nl> private BaseMod mod ; <nl> private boolean isTicking ; <nl> private String modSource ; <nl> + private ArrayList < String > dependencies ; <nl> + private ArrayList < String > preDependencies ; <nl> + private ArrayList < String > postDependencies ; <nl> public ModLoaderModContainer ( Class < ? extends BaseMod > modClazz , String modSource ) { <nl> this . modClazz = modClazz ; <nl> this . modSource = modSource ; <nl> @ @ - 174 , 15 + 176 , 13 @ @ public class ModLoaderModContainer implements ModContainer { <nl> public ICraftingHandler getCraftingHandler ( ) { <nl> return mod ; <nl> } <nl> - <nl> - / * ( non - Javadoc ) <nl> - * @ see cpw . mods . fml . common . ModContainer # getDependencies ( ) <nl> - * / <nl> - @ Override <nl> - public List < String > getDependencies ( ) { <nl> - ArrayList < String > dependencies = new ArrayList < String > ( 10 ) ; <nl> + <nl> + private void computeDependencies ( ) { <nl> + dependencies = new ArrayList < String > ( ) ; <nl> + preDependencies = new ArrayList < String > ( ) ; <nl> + postDependencies = new ArrayList < String > ( ) ; <nl> if ( mod . getPriorities ( ) = = null | | mod . getPriorities ( ) . length ( ) = = 0 ) { <nl> - return dependencies ; <nl> + return ; <nl> } <nl> StringTokenizer st = new StringTokenizer ( mod . getPriorities ( ) , " ; " ) ; <nl> for ( ; st . hasMoreTokens ( ) ; ) { <nl> @ @ - 194 , 19 + 194 , 44 @ @ public class ModLoaderModContainer implements ModContainer { <nl> if ( " required - before " . equals ( depparts [ 0 ] ) | | " required - after " . equals ( depparts [ 0 ] ) ) { <nl> dependencies . add ( depparts [ 1 ] ) ; <nl> } <nl> + <nl> + if ( " required - before " . equals ( depparts [ 0 ] ) | | " before " . equals ( depparts [ 0 ] ) ) { <nl> + preDependencies . add ( depparts [ 1 ] ) ; <nl> + } <nl> + <nl> + if ( " required - after " . equals ( depparts [ 0 ] ) | | " after " . equals ( depparts [ 0 ] ) ) { <nl> + postDependencies . add ( depparts [ 1 ] ) ; <nl> + } <nl> + } <nl> + } <nl> + / * ( non - Javadoc ) <nl> + * @ see cpw . mods . fml . common . ModContainer # getDependencies ( ) <nl> + * / <nl> + @ Override <nl> + public List < String > getDependencies ( ) { <nl> + if ( dependencies = = null ) { <nl> + computeDependencies ( ) ; <nl> } <nl> return dependencies ; <nl> } <nl> <nl> @ Override <nl> public List < String > getPreDepends ( ) { <nl> - / / TODO Auto - generated method stub <nl> - return null ; <nl> + if ( dependencies = = null ) { <nl> + computeDependencies ( ) ; <nl> + } <nl> + return preDependencies ; <nl> } <nl> <nl> @ Override <nl> public List < String > getPostDepends ( ) { <nl> - / / TODO Auto - generated method stub <nl> - return null ; <nl> + if ( dependencies = = null ) { <nl> + computeDependencies ( ) ; <nl> + } <nl> + return postDependencies ; <nl> + } <nl> + <nl> + public String toString ( ) { <nl> + return modSource ; <nl> } <nl> } <nl> diff - - git a / fml / test / cpw / mods / fml / test / LoaderTests . java b / fml / test / cpw / mods / fml / test / LoaderTests . java <nl> new file mode 100644 <nl> index 0000000 . . 28e1b41 <nl> - - - / dev / null <nl> + + + b / fml / test / cpw / mods / fml / test / LoaderTests . java <nl> @ @ - 0 , 0 + 1 , 214 @ @ <nl> + / * <nl> + * The FML Forge Mod Loader suite . <nl> + * Copyright ( C ) 2012 cpw <nl> + * <nl> + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> + * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package cpw . mods . fml . test ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + <nl> + import net . minecraft . src . BaseMod ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . Before ; <nl> + import org . junit . Test ; <nl> + import static org . junit . Assert . * ; <nl> + <nl> + import cpw . mods . fml . common . ModContainer ; <nl> + import cpw . mods . fml . common . toposort . ModSorter ; <nl> + import cpw . mods . fml . server . ModLoaderModContainer ; <nl> + <nl> + <nl> + public class LoaderTests { <nl> + <nl> + private ModContainer mc1 ; <nl> + private ModContainer mc2 ; <nl> + private ModContainer mc3 ; <nl> + private ModContainer mc4 ; <nl> + private ModContainer mc5 ; <nl> + private ModContainer mc6 ; <nl> + private ModContainer mc7 ; <nl> + private ModContainer mc8 ; <nl> + <nl> + @ Before <nl> + public void setUp ( ) throws Exception { <nl> + mc1 = new ModLoaderModContainer ( Mod1 . class , " Test1 " ) ; <nl> + mc1 . preInit ( ) ; <nl> + mc2 = new ModLoaderModContainer ( Mod2 . class , " Test2 " ) ; <nl> + mc2 . preInit ( ) ; <nl> + mc3 = new ModLoaderModContainer ( Mod3 . class , " Test3 " ) ; <nl> + mc3 . preInit ( ) ; <nl> + mc4 = new ModLoaderModContainer ( Mod4 . class , " Test4 " ) ; <nl> + mc4 . preInit ( ) ; <nl> + mc5 = new ModLoaderModContainer ( Mod5 . class , " Test5 " ) ; <nl> + mc5 . preInit ( ) ; <nl> + mc6 = new ModLoaderModContainer ( Mod5 . class , " Test6 " ) ; <nl> + mc6 . preInit ( ) ; <nl> + mc7 = new ModLoaderModContainer ( Mod5 . class , " Test7 " ) ; <nl> + mc7 . preInit ( ) ; <nl> + mc8 = new ModLoaderModContainer ( Mod5 . class , " Test8 " ) ; <nl> + mc8 . preInit ( ) ; <nl> + } <nl> + <nl> + @ After <nl> + public void tearDown ( ) throws Exception { <nl> + } <nl> + <nl> + @ Test <nl> + public void testModSorting ( ) { <nl> + HashMap < String , ModContainer > modList = new HashMap < String , ModContainer > ( ) ; <nl> + modList . put ( " Mod1 " , mc1 ) ; <nl> + modList . put ( " Mod2 " , mc2 ) ; <nl> + modList . put ( " Mod3 " , mc3 ) ; <nl> + modList . put ( " Mod4 " , mc4 ) ; <nl> + modList . put ( " Mod5 " , mc5 ) ; <nl> + modList . put ( " Mod6 " , mc6 ) ; <nl> + modList . put ( " Mod7 " , mc7 ) ; <nl> + modList . put ( " Mod8 " , mc8 ) ; <nl> + ModSorter ms = new ModSorter ( Collections . list ( Collections . enumeration ( modList . values ( ) ) ) , modList ) ; <nl> + List < ModContainer > mods = ms . sort ( ) ; <nl> + assertEquals ( " Eight mods " , 8 , mods . size ( ) ) ; <nl> + System . out . printf ( " % s \ n " , mods ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testModPrioritiesParsing ( ) { <nl> + / / Mod 1 <nl> + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; <nl> + <nl> + / / Mod 2 <nl> + assertTrue ( " Empty hard dependencies for Mod2 " , mc2 . getDependencies ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( " Mod2 postdepends on * " , mc1 . getPostDepends ( ) . contains ( " * " ) ) ; <nl> + <nl> + / / Mod 3 <nl> + assertEquals ( " Two hard dependencies for Mod3 " , 2 , mc1 . getDependencies ( ) . size ( ) ) ; <nl> + assertTrue ( " Hard dependencies for Mod3 contains Mod4 " , mc1 . getDependencies ( ) . contains ( " Mod4 " ) ) ; <nl> + assertTrue ( " Hard dependencies for Mod3 contains Mod2 " , mc1 . getDependencies ( ) . contains ( " Mod2 " ) ) ; <nl> + assertEquals ( " One pre depends for Mod3 " , 1 , mc1 . getPreDepends ( ) . size ( ) ) ; <nl> + assertEquals ( " One post depends for Mod3 " , 1 , mc1 . getPostDepends ( ) . size ( ) ) ; <nl> + <nl> + / / Mod 4 <nl> + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; <nl> + <nl> + / / Mod 5 <nl> + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; <nl> + } <nl> + <nl> + public static class Mod1 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " before : * " ; <nl> + } <nl> + } <nl> + public static class Mod2 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " after : * " ; <nl> + } <nl> + } <nl> + public static class Mod3 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " required - before : Mod4 ; required - after : Mod5 " ; <nl> + } <nl> + } <nl> + public static class Mod4 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " required - before : Mod2 ; after : Mod3 ; required - after : Mod1 " ; <nl> + } <nl> + } <nl> + public static class Mod5 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " " ; <nl> + } <nl> + } <nl> + public static class Mod6 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " " ; <nl> + } <nl> + } <nl> + public static class Mod7 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " " ; <nl> + } <nl> + } <nl> + public static class Mod8 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " before : Mod7 " ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / fml / test / fml / test / LoaderTests . java b / fml / test / fml / test / LoaderTests . java <nl> deleted file mode 100644 <nl> index 8330e88 . . 0000000 <nl> - - - a / fml / test / fml / test / LoaderTests . java <nl> + + + / dev / null <nl> @ @ - 1 , 37 + 0 , 0 @ @ <nl> - / * <nl> - * The FML Forge Mod Loader suite . <nl> - * Copyright ( C ) 2012 cpw <nl> - * <nl> - * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> - * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> - * <nl> - * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> - * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> - * <nl> - * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> - * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> - * / <nl> - package fml . test ; <nl> - <nl> - import org . junit . After ; <nl> - import org . junit . Before ; <nl> - import org . junit . Test ; <nl> - <nl> - import cpw . mods . fml . common . Loader ; <nl> - <nl> - <nl> - public class LoaderTests { <nl> - <nl> - @ Before <nl> - public void setUp ( ) throws Exception { <nl> - } <nl> - <nl> - @ After <nl> - public void tearDown ( ) throws Exception { <nl> - } <nl> - <nl> - @ Test <nl> - public void testModLoading ( ) { <nl> - Loader . instance ( ) . loadMods ( ) ; <nl> - } <nl> - }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / ForgeModContainer . java b / src / main / java / net / minecraftforge / common / ForgeModContainer . java 
 index de8b492 . . edf614d 100644 
 - - - a / src / main / java / net / minecraftforge / common / ForgeModContainer . java 
 + + + b / src / main / java / net / minecraftforge / common / ForgeModContainer . java 
 @ @ - 414 , 6 + 414 , 11 @ @ public class ForgeModContainer extends DummyModContainer implements WorldAccessC 
 all . add ( asm . getClassName ( ) ) ; 
 for ( ASMData asm : evt . getASMHarvestedData ( ) . getAll ( ICrashCallable . class . getName ( ) . replace ( ' . ' , ' / ' ) ) ) 
 all . add ( asm . getClassName ( ) ) ; 
 + / / Add table classes for mod list tabulation 
 + all . add ( " net / minecraftforge / common / util / TextTable " ) ; 
 + all . add ( " net / minecraftforge / common / util / TextTable $ Column " ) ; 
 + all . add ( " net / minecraftforge / common / util / TextTable $ Row " ) ; 
 + all . add ( " net / minecraftforge / common / util / TextTable $ Alignment " ) ; 
 
 all . removeIf ( cls - > ! cls . startsWith ( " net / minecraft / " ) & & ! cls . startsWith ( " net / minecraftforge / " ) ) ; 
 
 diff - - git a / src / main / java / net / minecraftforge / common / util / TextTable . java b / src / main / java / net / minecraftforge / common / util / TextTable . java 
 new file mode 100644 
 index 0000000 . . b14c973 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / common / util / TextTable . java 
 @ @ - 0 , 0 + 1 , 220 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package net . minecraftforge . common . util ; 
 + 
 + import com . google . common . collect . Streams ; 
 + import org . apache . commons . lang3 . StringUtils ; 
 + 
 + import javax . annotation . Nonnull ; 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 + import java . util . Objects ; 
 + import java . util . stream . Collectors ; 
 + 
 + / * * 
 + * Utility to format data into a textual ( markdown - compliant ) table . 
 + * / 
 + public class TextTable 
 + { 
 + public static Column column ( String header ) 
 + { 
 + return new Column ( header ) ; 
 + } 
 + 
 + public static Column column ( String header , Alignment alignment ) 
 + { 
 + return new Column ( header , alignment ) ; 
 + } 
 + 
 + private final List < Column > columns ; 
 + private final List < Row > rows = new ArrayList < > ( ) ; 
 + 
 + public TextTable ( List < Column > columns ) 
 + { 
 + this . columns = columns ; 
 + } 
 + 
 + public String build ( String lineEnding ) 
 + { 
 + StringBuilder destination = new StringBuilder ( ) ; 
 + append ( destination , lineEnding ) ; 
 + return destination . toString ( ) ; 
 + } 
 + 
 + / * * 
 + * Appends the data formatted as a table to the given string builder . 
 + * The padding character used for the column alignments is a single space ( ' ' ) , 
 + * the separate between column headers and values is a dash ( ' - ' ) . 
 + * Note that you * have * to specify a line ending , ' \ n ' isn ' t used by default . 
 + * < p > 
 + * The generated table is compliant with the markdown file format . 
 + * 
 + * @ param destination a string builder to append the table to 
 + * @ param lineEnding the line ending to use for each row of the table 
 + * / 
 + public void append ( StringBuilder destination , String lineEnding ) 
 + { 
 + List < String > headers = columns . stream ( ) . map ( c - > c . formatHeader ( " " ) ) . collect ( Collectors . toList ( ) ) ; 
 + printRow ( destination , headers ) ; 
 + destination . append ( lineEnding ) ; 
 + printSeparators ( destination ) ; 
 + for ( Row row : rows ) 
 + { 
 + destination . append ( lineEnding ) ; 
 + printRow ( destination , row . format ( columns , " " ) ) ; 
 + } 
 + } 
 + 
 + private void printSeparators ( StringBuilder destination ) 
 + { 
 + destination . append ( ' | ' ) ; 
 + for ( Column column : columns ) 
 + { 
 + destination . append ( column . alignment ! = Alignment . RIGHT ? ' : ' : ' ' ) ; 
 + destination . append ( column . getSeparator ( ' - ' ) ) ; 
 + destination . append ( column . alignment ! = Alignment . LEFT ? ' : ' : ' ' ) ; 
 + destination . append ( ' | ' ) ; 
 + } 
 + } 
 + 
 + private void printRow ( StringBuilder destination , List < String > values ) 
 + { 
 + destination . append ( ' | ' ) ; 
 + for ( String value : values ) 
 + { 
 + destination . append ( ' ' ) ; 
 + destination . append ( value ) ; 
 + destination . append ( ' ' ) ; 
 + destination . append ( ' | ' ) ; 
 + } 
 + } 
 + 
 + public void add ( @ Nonnull Object . . . values ) 
 + { 
 + if ( values . length ! = columns . size ( ) ) 
 + { 
 + throw new IllegalArgumentException ( " Received wrong amount of values for table row , expected " + columns . size ( ) + " , received " + columns . size ( ) + " . " ) ; 
 + } 
 + Row row = new Row ( ) ; 
 + for ( int i = 0 ; i < values . length ; i + + ) 
 + { 
 + String value = Objects . toString ( values [ i ] ) ; 
 + row . values . add ( value ) ; 
 + columns . get ( i ) . fit ( value ) ; 
 + } 
 + rows . add ( row ) ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + for ( Column column : columns ) 
 + { 
 + column . resetWidth ( ) ; 
 + } 
 + rows . clear ( ) ; 
 + } 
 + 
 + public List < Column > getColumns ( ) 
 + { 
 + return Collections . unmodifiableList ( columns ) ; 
 + } 
 + 
 + public static class Column 
 + { 
 + private String header ; 
 + private int width ; 
 + private Alignment alignment ; 
 + 
 + public Column ( String header ) 
 + { 
 + this ( header , Alignment . LEFT ) ; 
 + } 
 + 
 + public Column ( String header , Alignment alignment ) 
 + { 
 + this . header = header ; 
 + this . width = header . length ( ) ; 
 + this . alignment = alignment ; 
 + } 
 + 
 + public String formatHeader ( String padding ) 
 + { 
 + return format ( header , padding ) ; 
 + } 
 + 
 + public String format ( String value , String padding ) 
 + { 
 + switch ( alignment ) 
 + { 
 + case LEFT : 
 + return StringUtils . rightPad ( value , width , padding ) ; 
 + case RIGHT : 
 + return StringUtils . leftPad ( value , width , padding ) ; 
 + default : 
 + int length = value . length ( ) ; 
 + int left = ( width - length ) / 2 ; 
 + int leftWidth = left + length ; 
 + return StringUtils . rightPad ( StringUtils . leftPad ( value , leftWidth , padding ) , width , padding ) ; 
 + } 
 + } 
 + 
 + public String getSeparator ( char character ) 
 + { 
 + return StringUtils . leftPad ( " " , width , character ) ; 
 + } 
 + 
 + public void fit ( String value ) 
 + { 
 + if ( value . length ( ) > width ) 
 + { 
 + width = value . length ( ) ; 
 + } 
 + } 
 + 
 + public void resetWidth ( ) 
 + { 
 + this . width = header . length ( ) ; 
 + } 
 + 
 + public int getWidth ( ) 
 + { 
 + return width ; 
 + } 
 + } 
 + 
 + public static class Row 
 + { 
 + private final ArrayList < String > values = new ArrayList < > ( ) ; 
 + 
 + public List < String > format ( List < Column > columns , String padding ) 
 + { 
 + if ( columns . size ( ) ! = values . size ( ) ) 
 + { 
 + throw new IllegalArgumentException ( " Received wrong amount of columns for table row , expected " + columns . size ( ) + " , received " + columns . size ( ) + " . " ) ; 
 + } 
 + return Streams . zip ( values . stream ( ) , columns . stream ( ) , ( v , c ) - > c . format ( v , padding ) ) . collect ( Collectors . toList ( ) ) ; 
 + } 
 + } 
 + 
 + public enum Alignment 
 + { 
 + LEFT , CENTER , RIGHT 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / LoadController . java b / src / main / java / net / minecraftforge / fml / common / LoadController . java 
 index e612ceb . . 0876732 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / LoadController . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / LoadController . java 
 @ @ - 28 , 6 + 28 , 7 @ @ import java . util . Map ; 
 import java . util . Map . Entry ; 
 import java . util . stream . Collectors ; 
 
 + import net . minecraftforge . common . util . TextTable ; 
 import net . minecraftforge . fml . common . LoaderState . ModState ; 
 import net . minecraftforge . fml . common . ProgressManager . ProgressBar ; 
 import net . minecraftforge . fml . common . event . FMLEvent ; 
 @ @ - 310 , 14 + 311 , 28 @ @ public class LoadController 
 for ( ModState state : ModState . values ( ) ) 
 ret . append ( " ' " ) . append ( state . getMarker ( ) ) . append ( " ' = " ) . append ( state . toString ( ) ) ; 
 
 + TextTable table = new TextTable ( Lists . newArrayList ( 
 + TextTable . column ( " State " ) , 
 + TextTable . column ( " ID " ) , 
 + TextTable . column ( " Version " ) , 
 + TextTable . column ( " Source " ) , 
 + TextTable . column ( " Signature " ) ) 
 + ) ; 
 for ( ModContainer mc : loader . getModList ( ) ) 
 { 
 - ret . append ( " \ n \ t " ) ; 
 - for ( ModState state : modStates . get ( mc . getModId ( ) ) ) 
 - ret . append ( state . getMarker ( ) ) ; 
 - 
 - ret . append ( " \ t " ) . append ( mc . getModId ( ) ) . append ( " { " ) . append ( mc . getVersion ( ) ) . append ( " } [ " ) . append ( mc . getName ( ) ) . append ( " ] ( " ) . append ( mc . getSource ( ) . getName ( ) ) . append ( " ) " ) ; 
 + table . add ( 
 + modStates . get ( mc . getModId ( ) ) . stream ( ) . map ( ModState : : getMarker ) . reduce ( " " , ( a , b ) - > a + b ) , 
 + mc . getModId ( ) , 
 + mc . getVersion ( ) , 
 + mc . getSource ( ) . getName ( ) , 
 + mc . getSigningCertificate ( ) ! = null ? CertificateHelper . getFingerprint ( mc . getSigningCertificate ( ) ) : " None " 
 + ) ; 
 } 
 + 
 + ret . append ( " \ n " ) ; 
 + ret . append ( " \ n \ t " ) ; 
 + table . append ( ret , " \ n \ t " ) ; 
 + ret . append ( " \ n " ) ; 
 } 
 
 public List < ModContainer > getActiveModList ( ) 
 diff - - git a / src / test / java / net / minecraftforge / test / TextTableTest . java b / src / test / java / net / minecraftforge / test / TextTableTest . java 
 new file mode 100644 
 index 0000000 . . 0203eaa 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / test / TextTableTest . java 
 @ @ - 0 , 0 + 1 , 119 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . test ; 
 + 
 + import com . google . common . collect . Lists ; 
 + import net . minecraftforge . common . util . TextTable ; 
 + import net . minecraftforge . common . util . TextTable . Column ; 
 + import org . junit . Assert ; 
 + import org . junit . Test ; 
 + 
 + import static net . minecraftforge . common . util . TextTable . column ; 
 + 
 + public class TextTableTest 
 + { 
 + private static final String WIDTH _ REFERENCE = " StringOfWidth15 " ; 
 + private static final int WIDTH _ REFERENCE _ LENGTH = WIDTH _ REFERENCE . length ( ) ; 
 + 
 + @ Test 
 + public void testColumnWidthAdjustment ( ) 
 + { 
 + Column column = column ( " Column " , TextTable . Alignment . LEFT ) ; 
 + column . fit ( WIDTH _ REFERENCE ) ; 
 + String paddedHeader = column . formatHeader ( " - " ) ; 
 + Assert . assertEquals ( " Formatted column header didn ' t have correct length " , WIDTH _ REFERENCE _ LENGTH , paddedHeader . length ( ) ) ; 
 + Assert . assertEquals ( " Formatted column header wasn ' t padded properly " , " Column - - - - - - - - - " , paddedHeader ) ; 
 + 
 + String paddedReference = column . format ( WIDTH _ REFERENCE , " - " ) ; 
 + Assert . assertEquals ( " Formatted width reference didn ' t have correct length " , WIDTH _ REFERENCE _ LENGTH , paddedReference . length ( ) ) ; 
 + Assert . assertEquals ( " Formatted width reference was changed despite defining width " , WIDTH _ REFERENCE , paddedReference ) ; 
 + } 
 + 
 + @ Test 
 + public void testLeftAlignment ( ) 
 + { 
 + Column column = column ( " Left " , TextTable . Alignment . LEFT ) ; 
 + column . fit ( WIDTH _ REFERENCE ) ; 
 + 
 + String paddedHeader = column . formatHeader ( " - " ) ; 
 + Assert . assertEquals ( " Left - aligned header should be padded on the right " , " Left - - - - - - - - - - - " , paddedHeader ) ; 
 + String paddedReference = column . format ( WIDTH _ REFERENCE , " - " ) ; 
 + Assert . assertEquals ( " Left - aligned reference should ' nt be padded " , WIDTH _ REFERENCE , paddedReference ) ; 
 + String paddedValue = column . format ( " Value " , " - " ) ; 
 + Assert . assertEquals ( " Left - aligned value should be padded on the right " , " Value - - - - - - - - - - " , paddedValue ) ; 
 + } 
 + 
 + @ Test 
 + public void testCenterAlignment ( ) 
 + { 
 + Column column = column ( " Centered " , TextTable . Alignment . CENTER ) ; 
 + column . fit ( WIDTH _ REFERENCE ) ; 
 + 
 + String paddedHeader = column . formatHeader ( " - " ) ; 
 + Assert . assertEquals ( " Centered header should be padded equally on both sides " , " - - - Centered - - - - " , paddedHeader ) ; 
 + String paddedReference = column . format ( WIDTH _ REFERENCE , " - " ) ; 
 + Assert . assertEquals ( " Centered reference should ' nt be padded " , WIDTH _ REFERENCE , paddedReference ) ; 
 + String paddedValue = column . format ( " Value " , " - " ) ; 
 + Assert . assertEquals ( " Centered value should be padded equally on both sides " , " - - - - - Value - - - - - " , paddedValue ) ; 
 + String paddedOffCenter = column . format ( " Value1 " , " - " ) ; 
 + Assert . assertNotEquals ( " Center padding should be left - biased " , " - - - - - Value1 - - - - " , paddedOffCenter ) ; 
 + } 
 + 
 + @ Test 
 + public void testRightAlignment ( ) 
 + { 
 + Column column = column ( " Right " , TextTable . Alignment . RIGHT ) ; 
 + column . fit ( WIDTH _ REFERENCE ) ; 
 + 
 + String paddedHeader = column . formatHeader ( " - " ) ; 
 + Assert . assertEquals ( " Right - aligned header should be padded on the left " , " - - - - - - - - - - Right " , paddedHeader ) ; 
 + String paddedReference = column . format ( WIDTH _ REFERENCE , " - " ) ; 
 + Assert . assertEquals ( " Right - aligned reference should ' nt be padded " , WIDTH _ REFERENCE , paddedReference ) ; 
 + String paddedValue = column . format ( " Value " , " - " ) ; 
 + Assert . assertEquals ( " Right - aligned value should be padded on the left " , " - - - - - - - - - - Value " , paddedValue ) ; 
 + } 
 + 
 + @ Test 
 + public void testMarkdownCompliance ( ) 
 + { 
 + TextTable table = new TextTable ( Lists . newArrayList ( 
 + column ( " Left " , TextTable . Alignment . LEFT ) , 
 + column ( " Center " , TextTable . Alignment . CENTER ) , 
 + column ( " Right " , TextTable . Alignment . RIGHT ) 
 + ) ) ; 
 + table . add ( " Long Value 1 " , " Value 2 " , " Value 3 " ) ; 
 + table . add ( " Value 1 " , " Long Value 2 " , " Value 3 " ) ; 
 + table . add ( " Value 1 " , " Value 2 " , " Long Value 3 " ) ; 
 + int [ ] columnWidths = table . getColumns ( ) . stream ( ) . mapToInt ( Column : : getWidth ) . toArray ( ) ; 
 + Assert . assertArrayEquals ( " Column widths should adjust for long values " , new int [ ] { 12 , 12 , 12 } , columnWidths ) ; 
 + 
 + String [ ] result = table . build ( " \ n " ) . split ( " \ n " ) ; 
 + Assert . assertEquals ( " Header row + separator row + value rows should result in 5 lines " , 5 , result . length ) ; 
 + Assert . assertEquals ( 
 + " Column headers should be properly formatted " , 
 + " | Left | Center | Right | " , 
 + result [ 0 ] ) ; 
 + Assert . assertEquals ( 
 + " Header - body separators should contain markdown alignment information " , 
 + " | : - - - - - - - - - - - - | : - - - - - - - - - - - - : | - - - - - - - - - - - - : | " , 
 + result [ 1 ] 
 + ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / fml / . settings / org . eclipse . ltk . core . refactoring . prefs b / fml / . settings / org . eclipse . ltk . core . refactoring . prefs 
 new file mode 100644 
 index 0000000 . . b196c64 
 - - - / dev / null 
 + + + b / fml / . settings / org . eclipse . ltk . core . refactoring . prefs 
 @ @ - 0 , 0 + 1 , 2 @ @ 
 + eclipse . preferences . version = 1 
 + org . eclipse . ltk . core . refactoring . enable . project . refactoring . history = false 
 diff - - git a / fml / . settings / org . eclipse . m2e . core . prefs b / fml / . settings / org . eclipse . m2e . core . prefs 
 new file mode 100644 
 index 0000000 . . f897a7f 
 - - - / dev / null 
 + + + b / fml / . settings / org . eclipse . m2e . core . prefs 
 @ @ - 0 , 0 + 1 , 4 @ @ 
 + activeProfiles = 
 + eclipse . preferences . version = 1 
 + resolveWorkspaceProjects = true 
 + version = 1 
 diff - - git a / fml / common / cpw / mods / fml / common / FMLModContainer . java b / fml / common / cpw / mods / fml / common / FMLModContainer . java 
 index 77184e7 . . c33b911 100644 
 - - - a / fml / common / cpw / mods / fml / common / FMLModContainer . java 
 + + + b / fml / common / cpw / mods / fml / common / FMLModContainer . java 
 @ @ - 18 , 8 + 18 , 16 @ @ import java . util . List ; 
 public class FMLModContainer implements ModContainer { 
 private Mod modDescriptor ; 
 private Object modInstance ; 
 + private String source ; 
 
 + public FMLModContainer ( String source ) { 
 + this . source = source ; 
 + } 
 + 
 public FMLModContainer ( Class < ? > clazz ) { 
 + if ( clazz = = null ) { 
 + return ; 
 + } 
 modDescriptor = clazz . getAnnotation ( Mod . class ) ; 
 
 try { 
 @ @ - 86 , 8 + 94 , 7 @ @ public class FMLModContainer implements ModContainer { 
 
 @ Override 
 public String getSource ( ) { 
 - / / TODO Auto - generated method stub 
 - return null ; 
 + return source ; 
 } 
 
 @ Override 
 @ @ - 189 , 4 + 196 , 11 @ @ public class FMLModContainer implements ModContainer { 
 return new ArrayList < String > ( 0 ) ; 
 } 
 
 + / * ( non - Javadoc ) 
 + * @ see java . lang . Object # toString ( ) 
 + * / 
 + @ Override 
 + public String toString ( ) { 
 + return getSource ( ) ; 
 + } 
 } 
 diff - - git a / fml / common / cpw / mods / fml / common / Loader . java b / fml / common / cpw / mods / fml / common / Loader . java 
 index 8ca6b7c . . 9cbad60 100644 
 - - - a / fml / common / cpw / mods / fml / common / Loader . java 
 + + + b / fml / common / cpw / mods / fml / common / Loader . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import java . util . regex . Pattern ; 
 import java . util . zip . ZipEntry ; 
 import java . util . zip . ZipFile ; 
 
 + import cpw . mods . fml . common . toposort . ModSorter ; 
 import cpw . mods . fml . server . FMLHandler ; 
 
 public class Loader { 
 @ @ - 78 , 6 + 79 , 7 @ @ public class Loader { 
 } 
 
 private void sortModList ( ) { 
 + log . fine ( " Verifying mod dependencies are satisfied " ) ; 
 for ( ModContainer mod : mods ) { 
 if ( ! namedMods . keySet ( ) . containsAll ( mod . getDependencies ( ) ) ) { 
 log . severe ( String . format ( " The mod % s requires mods % s to be available , one or more are not " , mod . getName ( ) , mod . getDependencies ( ) ) ) ; 
 @ @ - 86 , 6 + 88 , 17 @ @ public class Loader { 
 throw new LoaderException ( ) ; 
 } 
 } 
 + log . fine ( " All dependencies are satisfied " ) ; 
 + ModSorter sorter = new ModSorter ( mods , namedMods ) ; 
 + try { 
 + log . fine ( " Sorting mods into an ordered list " ) ; 
 + mods = sorter . sort ( ) ; 
 + log . fine ( String . format ( " Mod list sorted % s " , mods ) ) ; 
 + } catch ( IllegalArgumentException iae ) { 
 + log . severe ( " A dependency cycle was detected in the input mod set so they cannot load them in order " ) ; 
 + log . throwing ( " Loader " , " sortModList " , iae ) ; 
 + throw new LoaderException ( iae ) ; 
 + } 
 } 
 
 private void preModInit ( ) { 
 diff - - git a / fml / common / cpw / mods / fml / common / toposort / ModSorter . java b / fml / common / cpw / mods / fml / common / toposort / ModSorter . java 
 new file mode 100644 
 index 0000000 . . 5115fb4 
 - - - / dev / null 
 + + + b / fml / common / cpw / mods / fml / common / toposort / ModSorter . java 
 @ @ - 0 , 0 + 1 , 93 @ @ 
 + / * 
 + * The FML Forge Mod Loader suite . Copyright ( C ) 2012 cpw 
 + * 
 + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 + * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package cpw . mods . fml . common . toposort ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + 
 + import cpw . mods . fml . common . FMLModContainer ; 
 + import cpw . mods . fml . common . ModContainer ; 
 + import cpw . mods . fml . common . toposort . TopologicalSort . DirectedGraph ; 
 + 
 + / * * 
 + * @ author cpw 
 + * 
 + * / 
 + public class ModSorter { 
 + private DirectedGraph < ModContainer > modGraph ; 
 + 
 + private ModContainer beforeAll = new FMLModContainer ( " DummyBeforeAll " ) ; 
 + private ModContainer afterAll = new FMLModContainer ( " DummyAfterAll " ) ; 
 + private ModContainer before = new FMLModContainer ( " DummyBefore " ) ; 
 + private ModContainer after = new FMLModContainer ( " DummyAfter " ) ; 
 + 
 + public ModSorter ( List < ModContainer > modList , Map < String , ModContainer > nameLookup ) { 
 + buildGraph ( modList , nameLookup ) ; 
 + } 
 + 
 + private void buildGraph ( List < ModContainer > modList , Map < String , ModContainer > nameLookup ) { 
 + modGraph = new DirectedGraph < ModContainer > ( ) ; 
 + modGraph . addNode ( beforeAll ) ; 
 + modGraph . addNode ( before ) ; 
 + modGraph . addNode ( afterAll ) ; 
 + modGraph . addNode ( after ) ; 
 + 
 + modGraph . addEdge ( before , after ) ; 
 + modGraph . addEdge ( beforeAll , before ) ; 
 + modGraph . addEdge ( after , afterAll ) ; 
 + for ( ModContainer mod : modList ) { 
 + modGraph . addNode ( mod ) ; 
 + } 
 + for ( ModContainer mod : modList ) { 
 + boolean preDepAdded = false ; 
 + boolean postDepAdded = false ; 
 + for ( String dep : mod . getPreDepends ( ) ) { 
 + preDepAdded = true ; 
 + if ( dep . equals ( " * " ) ) { 
 + / / We are " after " everything 
 + modGraph . addEdge ( mod , afterAll ) ; 
 + modGraph . addEdge ( after , mod ) ; 
 + postDepAdded = true ; 
 + } else { 
 + modGraph . addEdge ( before , mod ) ; 
 + modGraph . addEdge ( nameLookup . get ( dep ) , mod ) ; 
 + } 
 + } 
 + for ( String dep : mod . getPostDepends ( ) ) { 
 + postDepAdded = true ; 
 + if ( dep . equals ( " * " ) ) { 
 + / / We are " before " everything 
 + modGraph . addEdge ( beforeAll , mod ) ; 
 + modGraph . addEdge ( mod , before ) ; 
 + preDepAdded = true ; 
 + } else { 
 + modGraph . addEdge ( mod , after ) ; 
 + modGraph . addEdge ( mod , nameLookup . get ( dep ) ) ; 
 + } 
 + } 
 + if ( ! preDepAdded ) { 
 + modGraph . addEdge ( before , mod ) ; 
 + } 
 + if ( ! postDepAdded ) { 
 + modGraph . addEdge ( mod , after ) ; 
 + } 
 + } 
 + } 
 + 
 + public List < ModContainer > sort ( ) { 
 + List < ModContainer > sortedList = TopologicalSort . topologicalSort ( modGraph ) ; 
 + sortedList . removeAll ( Arrays . asList ( new ModContainer [ ] { beforeAll , before , after , afterAll } ) ) ; 
 + return sortedList ; 
 + } 
 + } 
 diff - - git a / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java b / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java 
 new file mode 100644 
 index 0000000 . . 37b5bf2 
 - - - / dev / null 
 + + + b / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java 
 @ @ - 0 , 0 + 1 , 155 @ @ 
 + / * 
 + * The FML Forge Mod Loader suite . 
 + * Copyright ( C ) 2012 cpw 
 + * 
 + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 + * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package cpw . mods . fml . common . toposort ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . HashSet ; 
 + import java . util . Iterator ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . NoSuchElementException ; 
 + import java . util . Set ; 
 + 
 + / * * 
 + * Topological sort for mod loading 
 + * 
 + * Based on a variety of sources , including http : / / keithschwarz . com / interesting / code / ? dir = topological - sort 
 + * @ author cpw 
 + * 
 + * / 
 + public class TopologicalSort { 
 + public static class DirectedGraph < T > implements Iterable < T > { 
 + private final Map < T , Set < T > > graph = new HashMap < T , Set < T > > ( ) ; 
 + 
 + public boolean addNode ( T node ) { 
 + / / Ignore nodes already added 
 + if ( graph . containsKey ( node ) ) { 
 + return false ; 
 + } 
 + graph . put ( node , new HashSet < T > ( ) ) ; 
 + return true ; 
 + } 
 + 
 + public void addEdge ( T from , T to ) { 
 + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { 
 + throw new NoSuchElementException ( " Missing nodes from graph " ) ; 
 + } 
 + graph . get ( from ) . add ( to ) ; 
 + } 
 + 
 + public void removeEdge ( T from , T to ) { 
 + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { 
 + throw new NoSuchElementException ( " Missing nodes from graph " ) ; 
 + } 
 + graph . get ( from ) . remove ( to ) ; 
 + } 
 + 
 + public boolean edgeExists ( T from , T to ) { 
 + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { 
 + throw new NoSuchElementException ( " Missing nodes from graph " ) ; 
 + } 
 + return graph . get ( from ) . contains ( to ) ; 
 + } 
 + 
 + public Set < T > edgesFrom ( T from ) { 
 + if ( ! graph . containsKey ( from ) ) { 
 + throw new NoSuchElementException ( " Missing node from graph " ) ; 
 + } 
 + return Collections . unmodifiableSet ( graph . get ( from ) ) ; 
 + } 
 + @ Override 
 + public Iterator < T > iterator ( ) { 
 + return graph . keySet ( ) . iterator ( ) ; 
 + } 
 + 
 + public int size ( ) { 
 + return graph . size ( ) ; 
 + } 
 + 
 + public boolean isEmpty ( ) { 
 + return graph . isEmpty ( ) ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) { 
 + return graph . toString ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Sort the input graph into a topologically sorted list 
 + * 
 + * Uses the reverse depth first search as outlined in . . . 
 + * @ param graph 
 + * @ return 
 + * / 
 + public static < T > List < T > topologicalSort ( DirectedGraph < T > graph ) { 
 + DirectedGraph < T > rGraph = reverse ( graph ) ; 
 + 
 + List < T > sortedResult = new ArrayList < T > ( ) ; 
 + Set < T > visitedNodes = new HashSet < T > ( ) ; 
 + 
 + / / A list of " fully explored " nodes . Leftovers in here indicate cycles in the graph 
 + Set < T > expandedNodes = new HashSet < T > ( ) ; 
 + 
 + for ( T node : rGraph ) { 
 + explore ( node , rGraph , sortedResult , visitedNodes , expandedNodes ) ; 
 + } 
 + 
 + return sortedResult ; 
 + } 
 + 
 + public static < T > DirectedGraph < T > reverse ( DirectedGraph < T > graph ) { 
 + DirectedGraph < T > result = new DirectedGraph < T > ( ) ; 
 + for ( T node : graph ) { 
 + result . addNode ( node ) ; 
 + } 
 + for ( T from : graph ) { 
 + for ( T to : graph . edgesFrom ( from ) ) { 
 + result . addEdge ( to , from ) ; 
 + } 
 + } 
 + 
 + return result ; 
 + } 
 + 
 + public static < T > void explore ( T node , DirectedGraph < T > graph , List < T > sortedResult , Set < T > visitedNodes , Set < T > expandedNodes ) { 
 + / / Have we been here before ? 
 + if ( visitedNodes . contains ( node ) ) { 
 + / / And have completed this node before 
 + if ( expandedNodes . contains ( node ) ) { 
 + / / Then we ' re fine 
 + return ; 
 + } 
 + System . out . printf ( " % s : % s \ n % s \ n % s \ n " , node , sortedResult , visitedNodes , expandedNodes ) ; 
 + throw new IllegalArgumentException ( " There was a cycle detected in the input graph , sorting is not possible " ) ; 
 + } 
 + 
 + / / Visit this node 
 + visitedNodes . add ( node ) ; 
 + 
 + / / Recursively explore inbound edges 
 + for ( T inbound : graph . edgesFrom ( node ) ) { 
 + explore ( inbound , graph , sortedResult , visitedNodes , expandedNodes ) ; 
 + } 
 + 
 + / / Add ourselves now 
 + sortedResult . add ( node ) ; 
 + 
 + / / And mark ourselves as explored 
 + expandedNodes . add ( node ) ; 
 + } 
 + } 
 diff - - git a / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java b / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java 
 index 8c57058 . . 922e4f8 100644 
 - - - a / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java 
 + + + b / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java 
 @ @ - 14 , 7 + 14 , 6 @ @ 
 package cpw . mods . fml . server ; 
 
 import java . util . ArrayList ; 
 - import java . util . Collections ; 
 import java . util . List ; 
 import java . util . StringTokenizer ; 
 
 @ @ - 32 , 6 + 31 , 9 @ @ public class ModLoaderModContainer implements ModContainer { 
 private BaseMod mod ; 
 private boolean isTicking ; 
 private String modSource ; 
 + private ArrayList < String > dependencies ; 
 + private ArrayList < String > preDependencies ; 
 + private ArrayList < String > postDependencies ; 
 public ModLoaderModContainer ( Class < ? extends BaseMod > modClazz , String modSource ) { 
 this . modClazz = modClazz ; 
 this . modSource = modSource ; 
 @ @ - 174 , 15 + 176 , 13 @ @ public class ModLoaderModContainer implements ModContainer { 
 public ICraftingHandler getCraftingHandler ( ) { 
 return mod ; 
 } 
 - 
 - / * ( non - Javadoc ) 
 - * @ see cpw . mods . fml . common . ModContainer # getDependencies ( ) 
 - * / 
 - @ Override 
 - public List < String > getDependencies ( ) { 
 - ArrayList < String > dependencies = new ArrayList < String > ( 10 ) ; 
 + 
 + private void computeDependencies ( ) { 
 + dependencies = new ArrayList < String > ( ) ; 
 + preDependencies = new ArrayList < String > ( ) ; 
 + postDependencies = new ArrayList < String > ( ) ; 
 if ( mod . getPriorities ( ) = = null | | mod . getPriorities ( ) . length ( ) = = 0 ) { 
 - return dependencies ; 
 + return ; 
 } 
 StringTokenizer st = new StringTokenizer ( mod . getPriorities ( ) , " ; " ) ; 
 for ( ; st . hasMoreTokens ( ) ; ) { 
 @ @ - 194 , 19 + 194 , 44 @ @ public class ModLoaderModContainer implements ModContainer { 
 if ( " required - before " . equals ( depparts [ 0 ] ) | | " required - after " . equals ( depparts [ 0 ] ) ) { 
 dependencies . add ( depparts [ 1 ] ) ; 
 } 
 + 
 + if ( " required - before " . equals ( depparts [ 0 ] ) | | " before " . equals ( depparts [ 0 ] ) ) { 
 + preDependencies . add ( depparts [ 1 ] ) ; 
 + } 
 + 
 + if ( " required - after " . equals ( depparts [ 0 ] ) | | " after " . equals ( depparts [ 0 ] ) ) { 
 + postDependencies . add ( depparts [ 1 ] ) ; 
 + } 
 + } 
 + } 
 + / * ( non - Javadoc ) 
 + * @ see cpw . mods . fml . common . ModContainer # getDependencies ( ) 
 + * / 
 + @ Override 
 + public List < String > getDependencies ( ) { 
 + if ( dependencies = = null ) { 
 + computeDependencies ( ) ; 
 } 
 return dependencies ; 
 } 
 
 @ Override 
 public List < String > getPreDepends ( ) { 
 - / / TODO Auto - generated method stub 
 - return null ; 
 + if ( dependencies = = null ) { 
 + computeDependencies ( ) ; 
 + } 
 + return preDependencies ; 
 } 
 
 @ Override 
 public List < String > getPostDepends ( ) { 
 - / / TODO Auto - generated method stub 
 - return null ; 
 + if ( dependencies = = null ) { 
 + computeDependencies ( ) ; 
 + } 
 + return postDependencies ; 
 + } 
 + 
 + public String toString ( ) { 
 + return modSource ; 
 } 
 } 
 diff - - git a / fml / test / cpw / mods / fml / test / LoaderTests . java b / fml / test / cpw / mods / fml / test / LoaderTests . java 
 new file mode 100644 
 index 0000000 . . 28e1b41 
 - - - / dev / null 
 + + + b / fml / test / cpw / mods / fml / test / LoaderTests . java 
 @ @ - 0 , 0 + 1 , 214 @ @ 
 + / * 
 + * The FML Forge Mod Loader suite . 
 + * Copyright ( C ) 2012 cpw 
 + * 
 + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 + * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package cpw . mods . fml . test ; 
 + 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + 
 + import net . minecraft . src . BaseMod ; 
 + 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Test ; 
 + import static org . junit . Assert . * ; 
 + 
 + import cpw . mods . fml . common . ModContainer ; 
 + import cpw . mods . fml . common . toposort . ModSorter ; 
 + import cpw . mods . fml . server . ModLoaderModContainer ; 
 + 
 + 
 + public class LoaderTests { 
 + 
 + private ModContainer mc1 ; 
 + private ModContainer mc2 ; 
 + private ModContainer mc3 ; 
 + private ModContainer mc4 ; 
 + private ModContainer mc5 ; 
 + private ModContainer mc6 ; 
 + private ModContainer mc7 ; 
 + private ModContainer mc8 ; 
 + 
 + @ Before 
 + public void setUp ( ) throws Exception { 
 + mc1 = new ModLoaderModContainer ( Mod1 . class , " Test1 " ) ; 
 + mc1 . preInit ( ) ; 
 + mc2 = new ModLoaderModContainer ( Mod2 . class , " Test2 " ) ; 
 + mc2 . preInit ( ) ; 
 + mc3 = new ModLoaderModContainer ( Mod3 . class , " Test3 " ) ; 
 + mc3 . preInit ( ) ; 
 + mc4 = new ModLoaderModContainer ( Mod4 . class , " Test4 " ) ; 
 + mc4 . preInit ( ) ; 
 + mc5 = new ModLoaderModContainer ( Mod5 . class , " Test5 " ) ; 
 + mc5 . preInit ( ) ; 
 + mc6 = new ModLoaderModContainer ( Mod5 . class , " Test6 " ) ; 
 + mc6 . preInit ( ) ; 
 + mc7 = new ModLoaderModContainer ( Mod5 . class , " Test7 " ) ; 
 + mc7 . preInit ( ) ; 
 + mc8 = new ModLoaderModContainer ( Mod5 . class , " Test8 " ) ; 
 + mc8 . preInit ( ) ; 
 + } 
 + 
 + @ After 
 + public void tearDown ( ) throws Exception { 
 + } 
 + 
 + @ Test 
 + public void testModSorting ( ) { 
 + HashMap < String , ModContainer > modList = new HashMap < String , ModContainer > ( ) ; 
 + modList . put ( " Mod1 " , mc1 ) ; 
 + modList . put ( " Mod2 " , mc2 ) ; 
 + modList . put ( " Mod3 " , mc3 ) ; 
 + modList . put ( " Mod4 " , mc4 ) ; 
 + modList . put ( " Mod5 " , mc5 ) ; 
 + modList . put ( " Mod6 " , mc6 ) ; 
 + modList . put ( " Mod7 " , mc7 ) ; 
 + modList . put ( " Mod8 " , mc8 ) ; 
 + ModSorter ms = new ModSorter ( Collections . list ( Collections . enumeration ( modList . values ( ) ) ) , modList ) ; 
 + List < ModContainer > mods = ms . sort ( ) ; 
 + assertEquals ( " Eight mods " , 8 , mods . size ( ) ) ; 
 + System . out . printf ( " % s \ n " , mods ) ; 
 + } 
 + 
 + @ Test 
 + public void testModPrioritiesParsing ( ) { 
 + / / Mod 1 
 + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; 
 + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; 
 + 
 + / / Mod 2 
 + assertTrue ( " Empty hard dependencies for Mod2 " , mc2 . getDependencies ( ) . isEmpty ( ) ) ; 
 + assertTrue ( " Mod2 postdepends on * " , mc1 . getPostDepends ( ) . contains ( " * " ) ) ; 
 + 
 + / / Mod 3 
 + assertEquals ( " Two hard dependencies for Mod3 " , 2 , mc1 . getDependencies ( ) . size ( ) ) ; 
 + assertTrue ( " Hard dependencies for Mod3 contains Mod4 " , mc1 . getDependencies ( ) . contains ( " Mod4 " ) ) ; 
 + assertTrue ( " Hard dependencies for Mod3 contains Mod2 " , mc1 . getDependencies ( ) . contains ( " Mod2 " ) ) ; 
 + assertEquals ( " One pre depends for Mod3 " , 1 , mc1 . getPreDepends ( ) . size ( ) ) ; 
 + assertEquals ( " One post depends for Mod3 " , 1 , mc1 . getPostDepends ( ) . size ( ) ) ; 
 + 
 + / / Mod 4 
 + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; 
 + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; 
 + 
 + / / Mod 5 
 + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; 
 + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; 
 + } 
 + 
 + public static class Mod1 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " before : * " ; 
 + } 
 + } 
 + public static class Mod2 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " after : * " ; 
 + } 
 + } 
 + public static class Mod3 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " required - before : Mod4 ; required - after : Mod5 " ; 
 + } 
 + } 
 + public static class Mod4 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " required - before : Mod2 ; after : Mod3 ; required - after : Mod1 " ; 
 + } 
 + } 
 + public static class Mod5 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " " ; 
 + } 
 + } 
 + public static class Mod6 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " " ; 
 + } 
 + } 
 + public static class Mod7 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " " ; 
 + } 
 + } 
 + public static class Mod8 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " before : Mod7 " ; 
 + } 
 + } 
 + } 
 diff - - git a / fml / test / fml / test / LoaderTests . java b / fml / test / fml / test / LoaderTests . java 
 deleted file mode 100644 
 index 8330e88 . . 0000000 
 - - - a / fml / test / fml / test / LoaderTests . java 
 + + + / dev / null 
 @ @ - 1 , 37 + 0 , 0 @ @ 
 - / * 
 - * The FML Forge Mod Loader suite . 
 - * Copyright ( C ) 2012 cpw 
 - * 
 - * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 - * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 - * 
 - * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 - * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 - * 
 - * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 - * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 - * / 
 - package fml . test ; 
 - 
 - import org . junit . After ; 
 - import org . junit . Before ; 
 - import org . junit . Test ; 
 - 
 - import cpw . mods . fml . common . Loader ; 
 - 
 - 
 - public class LoaderTests { 
 - 
 - @ Before 
 - public void setUp ( ) throws Exception { 
 - } 
 - 
 - @ After 
 - public void tearDown ( ) throws Exception { 
 - } 
 - 
 - @ Test 
 - public void testModLoading ( ) { 
 - Loader . instance ( ) . loadMods ( ) ; 
 - } 
 - }
