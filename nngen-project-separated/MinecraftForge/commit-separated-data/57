BLEU SCORE: 0.014333045747359384

TEST MSG: Try writing a temporary file to disk when a paulscode thread requests
GENERATED MSG: Fix 5408 by making Paths from the default provider ( not inside jars )

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java b / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java <nl> index 4a307d0 . . 695c3f2 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java <nl> + + + b / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java <nl> @ @ - 19 , 7 + 19 , 6 @ @ <nl> <nl> package net . minecraftforge . fml . packs ; <nl> <nl> - import it . unimi . dsi . fastutil . io . FastByteArrayInputStream ; <nl> import net . minecraft . resources . AbstractResourcePack ; <nl> import net . minecraft . resources . ResourcePackInfo ; <nl> import net . minecraft . resources . ResourcePackType ; <nl> @ @ - 28 , 23 + 27 , 26 @ @ import net . minecraftforge . fml . loading . moddiscovery . ModFile ; <nl> <nl> import java . io . File ; <nl> import java . io . FileInputStream ; <nl> + import java . io . FileNotFoundException ; <nl> import java . io . IOException ; <nl> import java . io . InputStream ; <nl> - import java . nio . channels . ByteChannel ; <nl> - import java . nio . channels . Channels ; <nl> - import java . nio . channels . SeekableByteChannel ; <nl> import java . nio . file . * ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> + import java . util . Objects ; <nl> import java . util . Set ; <nl> import java . util . function . Predicate ; <nl> import java . util . stream . Collectors ; <nl> - import java . util . stream . StreamSupport ; <nl> <nl> import com . google . common . base . Joiner ; <nl> + import org . apache . logging . log4j . LogManager ; <nl> + import org . apache . logging . log4j . Logger ; <nl> + <nl> + import static net . minecraftforge . fml . Logging . CORE ; <nl> <nl> public class ModFileResourcePack extends AbstractResourcePack <nl> { <nl> + private static final Logger LOGGER = LogManager . getLogger ( ) ; <nl> private final ModFile modFile ; <nl> private ResourcePackInfo packInfo ; <nl> <nl> @ @ - 73 , 12 + 75 , 33 @ @ public class ModFileResourcePack extends AbstractResourcePack <nl> / / If the Path comes from the default filesystem provider , we will rather use the path to generate an old FileInputStream <nl> final Path path = modFile . getLocator ( ) . findPath ( modFile , name ) ; <nl> if ( path . getFileSystem ( ) = = FileSystems . getDefault ( ) ) { <nl> + LOGGER . trace ( CORE , " Request for resource { } returning FileInputStream for regular file { } " , name , path ) ; <nl> return new FileInputStream ( path . toFile ( ) ) ; <nl> + } else if ( Objects . equals ( Thread . currentThread ( ) . getStackTrace ( ) [ 0 ] . getClassName ( ) , " paulscode . sound . CommandThread " ) ) { <nl> + final Path tempFile = Files . createTempFile ( " modpack " , " soundresource " ) ; <nl> + Files . copy ( Files . newInputStream ( path , StandardOpenOption . READ ) , tempFile ) ; <nl> + LOGGER . trace ( CORE , " Request for resource { } returning DeletingTemporaryFileInputStream for packed file { } on paulscode thread " , name , path ) ; <nl> + return new DeletingTemporaryFileInputStream ( tempFile ) ; <nl> } else { <nl> return Files . newInputStream ( path , StandardOpenOption . READ ) ; <nl> } <nl> } <nl> <nl> + private final class DeletingTemporaryFileInputStream extends FileInputStream { <nl> + private final Path tempfile ; <nl> + <nl> + DeletingTemporaryFileInputStream ( final Path tempfile ) throws FileNotFoundException { <nl> + super ( tempfile . toFile ( ) ) ; <nl> + this . tempfile = tempfile ; <nl> + } <nl> + <nl> + @ Override <nl> + public void close ( ) throws IOException { <nl> + super . close ( ) ; <nl> + Files . deleteIfExists ( tempfile ) ; <nl> + } <nl> + } <nl> + <nl> @ Override <nl> protected boolean resourceExists ( String name ) <nl> {
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java b / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java <nl> index 5a83d7f . . 362a141 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java <nl> + + + b / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ <nl> <nl> package net . minecraftforge . fml . packs ; <nl> <nl> + import it . unimi . dsi . fastutil . io . FastByteArrayInputStream ; <nl> import net . minecraft . resources . AbstractResourcePack ; <nl> import net . minecraft . resources . ResourcePackInfo ; <nl> import net . minecraft . resources . ResourcePackType ; <nl> @ @ - 26 , 11 + 27 , 13 @ @ import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . fml . loading . moddiscovery . ModFile ; <nl> <nl> import java . io . File ; <nl> + import java . io . FileInputStream ; <nl> import java . io . IOException ; <nl> import java . io . InputStream ; <nl> - import java . nio . file . Files ; <nl> - import java . nio . file . Path ; <nl> - import java . nio . file . Paths ; <nl> + import java . nio . channels . ByteChannel ; <nl> + import java . nio . channels . Channels ; <nl> + import java . nio . channels . SeekableByteChannel ; <nl> + import java . nio . file . * ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> import java . util . Set ; <nl> @ @ - 64 , 7 + 67 , 16 @ @ public class ModFileResourcePack extends AbstractResourcePack <nl> @ Override <nl> protected InputStream getInputStream ( String name ) throws IOException <nl> { <nl> - return Files . newInputStream ( modFile . getLocator ( ) . findPath ( modFile , name ) ) ; <nl> + / / because paulscode is ancient , we can ' t return FileChannel based InputStreams here - it will cause a deadlock or crash <nl> + / / Paulscode sends interrupt ( ) to trigger thread processing behaviour , and FileChannels will interpret that interrupt ( ) as <nl> + / / a sign to close the FileChannel and throw an interrupt error . Tis brilliant ! <nl> + / / If the Path comes from the default filesystem provider , we will rather use the path to generate an old FileInputStream <nl> + final Path path = modFile . getLocator ( ) . findPath ( modFile , name ) ; <nl> + if ( path . getFileSystem ( ) = = FileSystems . getDefault ( ) ) { <nl> + return new FileInputStream ( path . toFile ( ) ) ; <nl> + } else { <nl> + return Files . newInputStream ( path , StandardOpenOption . READ ) ; <nl> + } <nl> } <nl> <nl> @ Override

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java b / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java 
 index 4a307d0 . . 695c3f2 100644 
 - - - a / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java 
 + + + b / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java 
 @ @ - 19 , 7 + 19 , 6 @ @ 
 
 package net . minecraftforge . fml . packs ; 
 
 - import it . unimi . dsi . fastutil . io . FastByteArrayInputStream ; 
 import net . minecraft . resources . AbstractResourcePack ; 
 import net . minecraft . resources . ResourcePackInfo ; 
 import net . minecraft . resources . ResourcePackType ; 
 @ @ - 28 , 23 + 27 , 26 @ @ import net . minecraftforge . fml . loading . moddiscovery . ModFile ; 
 
 import java . io . File ; 
 import java . io . FileInputStream ; 
 + import java . io . FileNotFoundException ; 
 import java . io . IOException ; 
 import java . io . InputStream ; 
 - import java . nio . channels . ByteChannel ; 
 - import java . nio . channels . Channels ; 
 - import java . nio . channels . SeekableByteChannel ; 
 import java . nio . file . * ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 + import java . util . Objects ; 
 import java . util . Set ; 
 import java . util . function . Predicate ; 
 import java . util . stream . Collectors ; 
 - import java . util . stream . StreamSupport ; 
 
 import com . google . common . base . Joiner ; 
 + import org . apache . logging . log4j . LogManager ; 
 + import org . apache . logging . log4j . Logger ; 
 + 
 + import static net . minecraftforge . fml . Logging . CORE ; 
 
 public class ModFileResourcePack extends AbstractResourcePack 
 { 
 + private static final Logger LOGGER = LogManager . getLogger ( ) ; 
 private final ModFile modFile ; 
 private ResourcePackInfo packInfo ; 
 
 @ @ - 73 , 12 + 75 , 33 @ @ public class ModFileResourcePack extends AbstractResourcePack 
 / / If the Path comes from the default filesystem provider , we will rather use the path to generate an old FileInputStream 
 final Path path = modFile . getLocator ( ) . findPath ( modFile , name ) ; 
 if ( path . getFileSystem ( ) = = FileSystems . getDefault ( ) ) { 
 + LOGGER . trace ( CORE , " Request for resource { } returning FileInputStream for regular file { } " , name , path ) ; 
 return new FileInputStream ( path . toFile ( ) ) ; 
 + } else if ( Objects . equals ( Thread . currentThread ( ) . getStackTrace ( ) [ 0 ] . getClassName ( ) , " paulscode . sound . CommandThread " ) ) { 
 + final Path tempFile = Files . createTempFile ( " modpack " , " soundresource " ) ; 
 + Files . copy ( Files . newInputStream ( path , StandardOpenOption . READ ) , tempFile ) ; 
 + LOGGER . trace ( CORE , " Request for resource { } returning DeletingTemporaryFileInputStream for packed file { } on paulscode thread " , name , path ) ; 
 + return new DeletingTemporaryFileInputStream ( tempFile ) ; 
 } else { 
 return Files . newInputStream ( path , StandardOpenOption . READ ) ; 
 } 
 } 
 
 + private final class DeletingTemporaryFileInputStream extends FileInputStream { 
 + private final Path tempfile ; 
 + 
 + DeletingTemporaryFileInputStream ( final Path tempfile ) throws FileNotFoundException { 
 + super ( tempfile . toFile ( ) ) ; 
 + this . tempfile = tempfile ; 
 + } 
 + 
 + @ Override 
 + public void close ( ) throws IOException { 
 + super . close ( ) ; 
 + Files . deleteIfExists ( tempfile ) ; 
 + } 
 + } 
 + 
 @ Override 
 protected boolean resourceExists ( String name ) 
 {

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java b / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java 
 index 5a83d7f . . 362a141 100644 
 - - - a / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java 
 + + + b / src / main / java / net / minecraftforge / fml / packs / ModFileResourcePack . java 
 @ @ - 19 , 6 + 19 , 7 @ @ 
 
 package net . minecraftforge . fml . packs ; 
 
 + import it . unimi . dsi . fastutil . io . FastByteArrayInputStream ; 
 import net . minecraft . resources . AbstractResourcePack ; 
 import net . minecraft . resources . ResourcePackInfo ; 
 import net . minecraft . resources . ResourcePackType ; 
 @ @ - 26 , 11 + 27 , 13 @ @ import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . fml . loading . moddiscovery . ModFile ; 
 
 import java . io . File ; 
 + import java . io . FileInputStream ; 
 import java . io . IOException ; 
 import java . io . InputStream ; 
 - import java . nio . file . Files ; 
 - import java . nio . file . Path ; 
 - import java . nio . file . Paths ; 
 + import java . nio . channels . ByteChannel ; 
 + import java . nio . channels . Channels ; 
 + import java . nio . channels . SeekableByteChannel ; 
 + import java . nio . file . * ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 import java . util . Set ; 
 @ @ - 64 , 7 + 67 , 16 @ @ public class ModFileResourcePack extends AbstractResourcePack 
 @ Override 
 protected InputStream getInputStream ( String name ) throws IOException 
 { 
 - return Files . newInputStream ( modFile . getLocator ( ) . findPath ( modFile , name ) ) ; 
 + / / because paulscode is ancient , we can ' t return FileChannel based InputStreams here - it will cause a deadlock or crash 
 + / / Paulscode sends interrupt ( ) to trigger thread processing behaviour , and FileChannels will interpret that interrupt ( ) as 
 + / / a sign to close the FileChannel and throw an interrupt error . Tis brilliant ! 
 + / / If the Path comes from the default filesystem provider , we will rather use the path to generate an old FileInputStream 
 + final Path path = modFile . getLocator ( ) . findPath ( modFile , name ) ; 
 + if ( path . getFileSystem ( ) = = FileSystems . getDefault ( ) ) { 
 + return new FileInputStream ( path . toFile ( ) ) ; 
 + } else { 
 + return Files . newInputStream ( path , StandardOpenOption . READ ) ; 
 + } 
 } 
 
 @ Override
