BLEU SCORE: 0.008954307276600085

TEST MSG: Implemented interpolation of TRSR transformations ; B3D : added interpolation capabilities to B3DState , animated TESR example in ModelAnimationTest ( pure TESR right now , no separation inside the example model between the static and dynamic parts right now ) .
GENERATED MSG: B3D Improvements

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java b / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java <nl> index 189069c . . 3aed561 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java <nl> @ @ - 3 , 6 + 3 , 8 @ @ package net . minecraftforge . client . model ; <nl> import javax . vecmath . Matrix3f ; <nl> import javax . vecmath . Matrix4f ; <nl> import javax . vecmath . Quat4f ; <nl> + import javax . vecmath . Tuple3f ; <nl> + import javax . vecmath . Tuple4f ; <nl> import javax . vecmath . Vector3f ; <nl> import javax . vecmath . Vector4f ; <nl> <nl> @ @ - 181 , 7 + 183 , 6 @ @ public class TRSRTransformation implements IModelState , ITransformation <nl> { <nl> Matrix4f res = new Matrix4f ( ) , t = new Matrix4f ( ) ; <nl> res . setIdentity ( ) ; <nl> - if ( translation ! = null ) res . setTranslation ( translation ) ; <nl> if ( leftRot ! = null ) <nl> { <nl> t . set ( leftRot ) ; <nl> @ @ - 200 , 6 + 201 , 7 @ @ public class TRSRTransformation implements IModelState , ITransformation <nl> t . set ( rightRot ) ; <nl> res . mul ( t ) ; <nl> } <nl> + if ( translation ! = null ) res . setTranslation ( translation ) ; <nl> return res ; <nl> } <nl> <nl> @ @ - 221 , 7 + 223 , 8 @ @ public class TRSRTransformation implements IModelState , ITransformation <nl> b . set ( m ) ; <nl> b . mul ( t ) ; <nl> <nl> - sortSingularValues ( b , v ) ; <nl> + / / FIXME : this doesn ' t work correctly for some reason ; not crucial , so disabling for now ; investigate in the future . <nl> + / / sortSingularValues ( b , v ) ; <nl> <nl> Pair < Float , Float > p ; <nl> <nl> @ @ - 281 , 7 + 284 , 7 @ @ public class TRSRTransformation implements IModelState , ITransformation <nl> return f ; <nl> } <nl> <nl> - private static final float eps = 1e - 7f ; <nl> + private static final float eps = 1e - 6f ; <nl> private static final float g = 3f + 2f * ( float ) Math . sqrt ( 2 ) ; <nl> private static final float cs = ( float ) Math . cos ( Math . PI / 8 ) ; <nl> private static final float ss = ( float ) Math . sin ( Math . PI / 8 ) ; <nl> @ @ - 365 , 50 + 368 , 59 @ @ public class TRSRTransformation implements IModelState , ITransformation <nl> Quat4f qt = new Quat4f ( ) , ret = new Quat4f ( 0 , 0 , 0 , 1 ) ; <nl> Pair < Float , Float > p ; <nl> / / 01 <nl> - p = approxGivensQuat ( m . m00 , . 5f * ( m . m01 + m . m10 ) , m . m11 ) ; <nl> - qt . set ( 0 , 0 , p . getLeft ( ) , p . getRight ( ) ) ; <nl> - / / qt . normalize ( ) ; <nl> - ret . mul ( qt ) ; <nl> - / / t . set ( qt ) ; <nl> - t . setIdentity ( ) ; <nl> - t . m00 = qt . w * qt . w - qt . z * qt . z ; <nl> - t . m11 = t . m00 ; <nl> - t . m10 = 2 * qt . z * qt . w ; <nl> - t . m01 = - t . m10 ; <nl> - t . m22 = qt . w * qt . w + qt . z * qt . z ; <nl> - m . mul ( m , t ) ; <nl> - t . transpose ( ) ; <nl> - m . mul ( t , m ) ; <nl> + if ( m . m01 * m . m01 + m . m10 * m . m10 > eps ) <nl> + { <nl> + p = approxGivensQuat ( m . m00 , . 5f * ( m . m01 + m . m10 ) , m . m11 ) ; <nl> + qt . set ( 0 , 0 , p . getLeft ( ) , p . getRight ( ) ) ; <nl> + / / qt . normalize ( ) ; <nl> + ret . mul ( qt ) ; <nl> + / / t . set ( qt ) ; <nl> + t . setIdentity ( ) ; <nl> + t . m00 = qt . w * qt . w - qt . z * qt . z ; <nl> + t . m11 = t . m00 ; <nl> + t . m10 = 2 * qt . z * qt . w ; <nl> + t . m01 = - t . m10 ; <nl> + t . m22 = qt . w * qt . w + qt . z * qt . z ; <nl> + m . mul ( m , t ) ; <nl> + t . transpose ( ) ; <nl> + m . mul ( t , m ) ; <nl> + } <nl> / / 02 <nl> - p = approxGivensQuat ( m . m00 , . 5f * ( m . m02 + m . m20 ) , m . m22 ) ; <nl> - qt . set ( 0 , - p . getLeft ( ) , 0 , p . getRight ( ) ) ; <nl> - / / qt . normalize ( ) ; <nl> - ret . mul ( qt ) ; <nl> - / / t . set ( qt ) ; <nl> - t . setIdentity ( ) ; <nl> - t . m00 = qt . w * qt . w - qt . y * qt . y ; <nl> - t . m22 = t . m00 ; <nl> - t . m20 = - 2 * qt . y * qt . w ; <nl> - t . m02 = - t . m20 ; <nl> - t . m11 = qt . w * qt . w + qt . y * qt . y ; <nl> - m . mul ( m , t ) ; <nl> - t . transpose ( ) ; <nl> - m . mul ( t , m ) ; <nl> + if ( m . m02 * m . m02 + m . m20 * m . m20 > eps ) <nl> + { <nl> + p = approxGivensQuat ( m . m00 , . 5f * ( m . m02 + m . m20 ) , m . m22 ) ; <nl> + qt . set ( 0 , - p . getLeft ( ) , 0 , p . getRight ( ) ) ; <nl> + / / qt . normalize ( ) ; <nl> + ret . mul ( qt ) ; <nl> + / / t . set ( qt ) ; <nl> + t . setIdentity ( ) ; <nl> + t . m00 = qt . w * qt . w - qt . y * qt . y ; <nl> + t . m22 = t . m00 ; <nl> + t . m20 = - 2 * qt . y * qt . w ; <nl> + t . m02 = - t . m20 ; <nl> + t . m11 = qt . w * qt . w + qt . y * qt . y ; <nl> + m . mul ( m , t ) ; <nl> + t . transpose ( ) ; <nl> + m . mul ( t , m ) ; <nl> + } <nl> / / 12 <nl> - p = approxGivensQuat ( m . m11 , . 5f * ( m . m12 + m . m21 ) , m . m22 ) ; <nl> - qt . set ( p . getLeft ( ) , 0 , 0 , p . getRight ( ) ) ; <nl> - / / qt . normalize ( ) ; <nl> - ret . mul ( qt ) ; <nl> - / / t . set ( qt ) ; <nl> - t . setIdentity ( ) ; <nl> - t . m11 = qt . w * qt . w - qt . x * qt . x ; <nl> - t . m22 = t . m11 ; <nl> - t . m21 = 2 * qt . x * qt . w ; <nl> - t . m12 = - t . m21 ; <nl> - t . m00 = qt . w * qt . w + qt . x * qt . x ; <nl> - m . mul ( m , t ) ; <nl> - t . transpose ( ) ; <nl> - m . mul ( t , m ) ; <nl> + if ( m . m12 * m . m12 + m . m21 * m . m21 > eps ) <nl> + { <nl> + p = approxGivensQuat ( m . m11 , . 5f * ( m . m12 + m . m21 ) , m . m22 ) ; <nl> + qt . set ( p . getLeft ( ) , 0 , 0 , p . getRight ( ) ) ; <nl> + / / qt . normalize ( ) ; <nl> + ret . mul ( qt ) ; <nl> + / / t . set ( qt ) ; <nl> + t . setIdentity ( ) ; <nl> + t . m11 = qt . w * qt . w - qt . x * qt . x ; <nl> + t . m22 = t . m11 ; <nl> + t . m21 = 2 * qt . x * qt . w ; <nl> + t . m12 = - t . m21 ; <nl> + t . m00 = qt . w * qt . w + qt . x * qt . x ; <nl> + m . mul ( m , t ) ; <nl> + t . transpose ( ) ; <nl> + m . mul ( t , m ) ; <nl> + } <nl> return ret ; <nl> } <nl> <nl> @ @ - 617 , 4 + 629 , 35 @ @ public class TRSRTransformation implements IModelState , ITransformation <nl> r . m33 = m . m33 ; <nl> return r ; <nl> } <nl> + <nl> + public static Vector3f lerp ( Tuple3f from , Tuple3f to , float progress ) <nl> + { <nl> + Vector3f res = new Vector3f ( from ) ; <nl> + res . interpolate ( from , to , progress ) ; <nl> + return res ; <nl> + } <nl> + <nl> + public static Vector4f lerp ( Tuple4f from , Tuple4f to , float progress ) <nl> + { <nl> + Vector4f res = new Vector4f ( from ) ; <nl> + res . interpolate ( from , to , progress ) ; <nl> + return res ; <nl> + } <nl> + <nl> + public static Quat4f slerp ( Quat4f from , Quat4f to , float progress ) <nl> + { <nl> + Quat4f res = new Quat4f ( ) ; <nl> + res . interpolate ( from , to , progress ) ; <nl> + return res ; <nl> + } <nl> + <nl> + public TRSRTransformation slerp ( TRSRTransformation that , float progress ) <nl> + { <nl> + return new TRSRTransformation ( <nl> + lerp ( this . getTranslation ( ) , that . getTranslation ( ) , progress ) , <nl> + slerp ( this . getLeftRot ( ) , that . getLeftRot ( ) , progress ) , <nl> + lerp ( this . getScale ( ) , that . getScale ( ) , progress ) , <nl> + slerp ( this . getRightRot ( ) , that . getRightRot ( ) , progress ) <nl> + ) ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> index d75ab37 . . 5cfad73 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import net . minecraft . client . resources . IResourceManager ; <nl> import net . minecraft . client . resources . model . IBakedModel ; <nl> import net . minecraft . item . ItemStack ; <nl> import net . minecraft . util . EnumFacing ; <nl> + import net . minecraft . util . MathHelper ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . client . model . ICustomModelLoader ; <nl> import net . minecraftforge . client . model . IFlexibleBakedModel ; <nl> @ @ - 65 , 6 + 66 , 9 @ @ import com . google . common . cache . LoadingCache ; <nl> import com . google . common . collect . Collections2 ; <nl> import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . ImmutableMap ; <nl> + import com . google . common . collect . ImmutableSet ; <nl> + import com . google . gson . JsonElement ; <nl> + import com . google . gson . JsonParser ; <nl> <nl> / * <nl> * Loader for Blitz3D models . <nl> @ @ - 138 , 16 + 142 , 19 @ @ public class B3DLoader implements ICustomModelLoader <nl> FMLLog . severe ( " No mesh named % s in model % s , skipping " , mesh , modelLocation ) ; <nl> return ModelLoaderRegistry . getMissingModel ( ) ; <nl> } <nl> - return new Wrapper ( modelLocation , model . getTextures ( ) , model . getMeshes ( ) . get ( mesh ) ) ; <nl> + return new ModelWrapper ( modelLocation , model , ImmutableSet . of ( mesh ) , 1 ) ; <nl> } <nl> if ( ! ( model . getRoot ( ) . getKind ( ) instanceof Mesh ) ) <nl> { <nl> - FMLLog . severe ( " No root mesh in model % s and no mesh name in location , skipping " , modelLocation ) ; <nl> - return ModelLoaderRegistry . getMissingModel ( ) ; <nl> + return new ModelWrapper ( modelLocation , model , ImmutableSet . < String > of ( ) , 1 ) ; <nl> } <nl> - return new Wrapper ( modelLocation , model . getTextures ( ) , ( Node < Mesh > ) model . getRoot ( ) ) ; <nl> + return new ModelWrapper ( modelLocation , model , ImmutableSet . of ( ( ( Node < Mesh > ) model . getRoot ( ) ) . getName ( ) ) , 1 ) ; <nl> } <nl> <nl> + / * * <nl> + * @ deprecated Use json or IModelCustomData . process <nl> + * / <nl> + @ Deprecated <nl> public static class B3DMeshLocation extends ResourceLocation <nl> { <nl> public final String mesh ; <nl> @ @ - 192 , 17 + 199 , 31 @ @ public class B3DLoader implements ICustomModelLoader <nl> { <nl> private final Animation animation ; <nl> private final int frame ; <nl> + private final int nextFrame ; <nl> + private final float progress ; <nl> private final IModelState parent ; <nl> <nl> public B3DState ( Animation animation , int frame ) <nl> { <nl> - this ( animation , frame , null ) ; <nl> + this ( animation , frame , frame , 0 ) ; <nl> } <nl> <nl> public B3DState ( Animation animation , int frame , IModelState parent ) <nl> { <nl> + this ( animation , frame , frame , 0 , parent ) ; <nl> + } <nl> + <nl> + public B3DState ( Animation animation , int frame , int nextFrame , float progress ) <nl> + { <nl> + this ( animation , frame , nextFrame , progress , null ) ; <nl> + } <nl> + <nl> + public B3DState ( Animation animation , int frame , int nextFrame , float progress , IModelState parent ) <nl> + { <nl> this . animation = animation ; <nl> this . frame = frame ; <nl> + this . nextFrame = nextFrame ; <nl> + this . progress = MathHelper . clamp _ float ( progress , 0 , 1 ) ; <nl> this . parent = getParent ( parent ) ; <nl> } <nl> <nl> @ @ - 223 , 17 + 244 , 47 @ @ public class B3DLoader implements ICustomModelLoader <nl> return frame ; <nl> } <nl> <nl> + public int getNextFrame ( ) <nl> + { <nl> + return nextFrame ; <nl> + } <nl> + <nl> + public float getProgress ( ) <nl> + { <nl> + return progress ; <nl> + } <nl> + <nl> + public IModelState getParent ( ) <nl> + { <nl> + return parent ; <nl> + } <nl> + <nl> public TRSRTransformation apply ( IModelPart part ) <nl> { <nl> if ( ! ( part instanceof PartWrapper < ? > ) ) <nl> { <nl> throw new IllegalArgumentException ( " B3DState can only be applied to b3d models " ) ; <nl> } <nl> + Node < ? > node = ( ( PartWrapper < ? > ) part ) . getNode ( ) ; <nl> + TRSRTransformation nodeTransform ; <nl> + if ( progress < 1e - 5 | | frame = = nextFrame ) <nl> + { <nl> + nodeTransform = getNodeMatrix ( node , frame ) ; <nl> + } <nl> + else if ( progress > 1 - 1e - 5 ) <nl> + { <nl> + nodeTransform = getNodeMatrix ( node , nextFrame ) ; <nl> + } <nl> + else <nl> + { <nl> + nodeTransform = getNodeMatrix ( node , frame ) ; <nl> + nodeTransform = nodeTransform . slerp ( getNodeMatrix ( node , nextFrame ) , progress ) ; <nl> + } <nl> if ( parent ! = null ) <nl> { <nl> - return parent . apply ( part ) . compose ( getNodeMatrix ( ( ( PartWrapper < ? > ) part ) . getNode ( ) ) ) ; <nl> + return parent . apply ( part ) . compose ( nodeTransform ) ; <nl> } <nl> - return getNodeMatrix ( ( ( PartWrapper < ? > ) part ) . getNode ( ) ) ; <nl> + return nodeTransform ; <nl> } <nl> <nl> private static LoadingCache < Triple < Animation , Node < ? > , Integer > , TRSRTransformation > cache = CacheBuilder . newBuilder ( ) <nl> @ @ - 252 , 6 + 303 , 11 @ @ public class B3DLoader implements ICustomModelLoader <nl> return cache . getUnchecked ( Triple . < Animation , Node < ? > , Integer > of ( animation , node , frame ) ) ; <nl> } <nl> <nl> + public TRSRTransformation getNodeMatrix ( Node < ? > node , int frame ) <nl> + { <nl> + return cache . getUnchecked ( Triple . < Animation , Node < ? > , Integer > of ( animation , node , frame ) ) ; <nl> + } <nl> + <nl> public static TRSRTransformation getNodeMatrix ( Animation animation , Node < ? > node , int frame ) <nl> { <nl> TRSRTransformation ret = TRSRTransformation . identity ( ) ; <nl> @ @ - 326 , 20 + 382 , 36 @ @ public class B3DLoader implements ICustomModelLoader <nl> } <nl> } <nl> <nl> + / * * <nl> + * @ deprecated Use ModelWrapper , this will be removed in 1 . 9 <nl> + * / <nl> + @ Deprecated <nl> public static class Wrapper extends PartWrapper < Mesh > implements IRetexturableModel , IModelCustomData <nl> { <nl> private final ResourceLocation location ; <nl> + private final ImmutableSet < String > meshes ; <nl> private final ImmutableMap < String , ResourceLocation > textures ; <nl> <nl> public Wrapper ( ResourceLocation location , List < Texture > textures , B3DModel . Node < Mesh > mesh ) <nl> { <nl> - this ( location , buildTextures ( textures ) , mesh ) ; <nl> + this ( location , ImmutableSet . < String > of ( ) , buildTextures ( textures ) , mesh ) ; <nl> } <nl> <nl> public Wrapper ( ResourceLocation location , ImmutableMap < String , ResourceLocation > textures , B3DModel . Node < Mesh > mesh ) <nl> { <nl> + this ( location , ImmutableSet . < String > of ( ) , textures , mesh ) ; <nl> + } <nl> + <nl> + public Wrapper ( ResourceLocation location , ImmutableSet < String > meshes , List < Texture > textures , B3DModel . Node < Mesh > mesh ) <nl> + { <nl> + this ( location , meshes , buildTextures ( textures ) , mesh ) ; <nl> + } <nl> + <nl> + public Wrapper ( ResourceLocation location , ImmutableSet < String > meshes , ImmutableMap < String , ResourceLocation > textures , B3DModel . Node < Mesh > mesh ) <nl> + { <nl> super ( mesh ) ; <nl> this . location = location ; <nl> + this . meshes = meshes ; <nl> this . textures = textures ; <nl> } <nl> <nl> @ @ - 398 , 7 + 470 , 7 @ @ public class B3DLoader implements ICustomModelLoader <nl> } <nl> } <nl> builder . put ( " missingno " , missing ) ; <nl> - return new BakedWrapper ( this , state , format , builder . build ( ) ) ; <nl> + return new BakedWrapper ( getNode ( ) , state , format , meshes , builder . build ( ) ) ; <nl> } <nl> <nl> public B3DState getDefaultState ( ) <nl> @ @ - 465 , 29 + 537 , 211 @ @ public class B3DLoader implements ICustomModelLoader <nl> @ Override <nl> public IModel process ( ImmutableMap < String , String > customData ) <nl> { <nl> - / / TODO keyframe <nl> - return null ; <nl> + return this ; <nl> + } <nl> + } <nl> + public static class ModelWrapper implements IRetexturableModel , IModelCustomData <nl> + { <nl> + private final ResourceLocation modelLocation ; <nl> + private final B3DModel model ; <nl> + private final ImmutableSet < String > meshes ; <nl> + private final ImmutableMap < String , ResourceLocation > textures ; <nl> + private final int defaultKey ; <nl> + <nl> + public ModelWrapper ( ResourceLocation modelLocation , B3DModel model , ImmutableSet < String > meshes , int defaultKey ) <nl> + { <nl> + this ( modelLocation , model , meshes , defaultKey , buildTextures ( model . getTextures ( ) ) ) ; <nl> + } <nl> + <nl> + public ModelWrapper ( ResourceLocation modelLocation , B3DModel model , ImmutableSet < String > meshes , int defaultKey , ImmutableMap < String , ResourceLocation > textures ) <nl> + { <nl> + this . modelLocation = modelLocation ; <nl> + this . model = model ; <nl> + this . meshes = meshes ; <nl> + this . textures = textures ; <nl> + this . defaultKey = defaultKey ; <nl> + } <nl> + <nl> + private static ImmutableMap < String , ResourceLocation > buildTextures ( List < Texture > textures ) <nl> + { <nl> + ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; <nl> + <nl> + for ( Texture t : textures ) <nl> + { <nl> + String path = t . getPath ( ) ; <nl> + String location = getLocation ( path ) ; <nl> + if ( ! location . startsWith ( " # " ) ) location = " # " + location ; <nl> + builder . put ( path , new ResourceLocation ( location ) ) ; <nl> + } <nl> + return builder . build ( ) ; <nl> + } <nl> + <nl> + private static String getLocation ( String path ) <nl> + { <nl> + if ( path . endsWith ( " . png " ) ) path = path . substring ( 0 , path . length ( ) - " . png " . length ( ) ) ; <nl> + return path ; <nl> + } <nl> + <nl> + @ Override <nl> + public Collection < ResourceLocation > getDependencies ( ) <nl> + { <nl> + return Collections . emptyList ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Collection < ResourceLocation > getTextures ( ) <nl> + { <nl> + return Collections2 . filter ( textures . values ( ) , new Predicate < ResourceLocation > ( ) <nl> + { <nl> + public boolean apply ( ResourceLocation loc ) <nl> + { <nl> + return ! loc . getResourcePath ( ) . startsWith ( " # " ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> + { <nl> + ImmutableMap . Builder < String , TextureAtlasSprite > builder = ImmutableMap . builder ( ) ; <nl> + TextureAtlasSprite missing = bakedTextureGetter . apply ( new ResourceLocation ( " missingno " ) ) ; <nl> + for ( Map . Entry < String , ResourceLocation > e : textures . entrySet ( ) ) <nl> + { <nl> + if ( e . getValue ( ) . getResourcePath ( ) . startsWith ( " # " ) ) <nl> + { <nl> + FMLLog . severe ( " unresolved texture ' % s ' for b3d model ' % s ' " , e . getValue ( ) . getResourcePath ( ) , modelLocation ) ; <nl> + builder . put ( e . getKey ( ) , missing ) ; <nl> + } <nl> + else <nl> + { <nl> + builder . put ( e . getKey ( ) , bakedTextureGetter . apply ( e . getValue ( ) ) ) ; <nl> + } <nl> + } <nl> + builder . put ( " missingno " , missing ) ; <nl> + return new BakedWrapper ( model . getRoot ( ) , state , format , meshes , builder . build ( ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public IModelState getDefaultState ( ) <nl> + { <nl> + return new B3DState ( model . getRoot ( ) . getAnimation ( ) , defaultKey , defaultKey , 0 ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public IModel retexture ( ImmutableMap < String , String > textures ) <nl> + { <nl> + ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; <nl> + for ( Map . Entry < String , ResourceLocation > e : this . textures . entrySet ( ) ) <nl> + { <nl> + String path = e . getKey ( ) ; <nl> + String loc = getLocation ( path ) ; <nl> + if ( textures . containsKey ( loc ) ) <nl> + { <nl> + String newLoc = textures . get ( loc ) ; <nl> + if ( newLoc = = null ) newLoc = getLocation ( path ) ; <nl> + builder . put ( e . getKey ( ) , new ResourceLocation ( newLoc ) ) ; <nl> + } <nl> + else <nl> + { <nl> + builder . put ( e ) ; <nl> + } <nl> + } <nl> + return new ModelWrapper ( modelLocation , model , meshes , defaultKey , builder . build ( ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public IModel process ( ImmutableMap < String , String > data ) <nl> + { <nl> + if ( data . containsKey ( " mesh " ) ) <nl> + { <nl> + JsonElement e = new JsonParser ( ) . parse ( data . get ( " mesh " ) ) ; <nl> + if ( e . isJsonPrimitive ( ) & & e . getAsJsonPrimitive ( ) . isString ( ) ) <nl> + { <nl> + return new ModelWrapper ( modelLocation , model , ImmutableSet . of ( e . getAsString ( ) ) , defaultKey , textures ) ; <nl> + } <nl> + else if ( e . isJsonArray ( ) ) <nl> + { <nl> + ImmutableSet . Builder < String > builder = ImmutableSet . builder ( ) ; <nl> + for ( JsonElement s : e . getAsJsonArray ( ) ) <nl> + { <nl> + if ( s . isJsonPrimitive ( ) & & s . getAsJsonPrimitive ( ) . isString ( ) ) <nl> + { <nl> + builder . add ( s . getAsString ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + FMLLog . severe ( " unknown mesh definition ' % s ' in array for b3d model ' % s ' " , s . toString ( ) , modelLocation ) ; <nl> + return this ; <nl> + } <nl> + } <nl> + return new ModelWrapper ( modelLocation , model , builder . build ( ) , defaultKey , textures ) ; <nl> + } <nl> + else <nl> + { <nl> + FMLLog . severe ( " unknown mesh definition ' % s ' for b3d model ' % s ' " , e . toString ( ) , modelLocation ) ; <nl> + return this ; <nl> + } <nl> + } <nl> + if ( data . containsKey ( " key " ) ) <nl> + { <nl> + JsonElement e = new JsonParser ( ) . parse ( data . get ( " key " ) ) ; <nl> + if ( e . isJsonPrimitive ( ) & & e . getAsJsonPrimitive ( ) . isNumber ( ) ) <nl> + { <nl> + return new ModelWrapper ( modelLocation , model , meshes , e . getAsNumber ( ) . intValue ( ) , textures ) ; <nl> + } <nl> + else <nl> + { <nl> + FMLLog . severe ( " unknown keyframe definition ' % s ' for b3d model ' % s ' " , e . toString ( ) , modelLocation ) ; <nl> + return this ; <nl> + } <nl> + } <nl> + return this ; <nl> } <nl> } <nl> <nl> private static class BakedWrapper implements IFlexibleBakedModel , ISmartBlockModel , ISmartItemModel , IPerspectiveAwareModel <nl> { <nl> - private final B3DLoader . Wrapper model ; <nl> + private final Node < ? > node ; <nl> private final IModelState state ; <nl> private final VertexFormat format ; <nl> + private final ImmutableSet < String > meshes ; <nl> private final ImmutableMap < String , TextureAtlasSprite > textures ; <nl> + private final LoadingCache < Integer , BakedWrapper > cache ; <nl> <nl> private ImmutableList < BakedQuad > quads ; <nl> <nl> - private static final int BYTES _ IN _ INT = Integer . SIZE / Byte . SIZE ; <nl> - private static final int VERTICES _ IN _ QUAD = 4 ; <nl> - <nl> - public BakedWrapper ( B3DLoader . Wrapper model , IModelState state , VertexFormat format , ImmutableMap < String , TextureAtlasSprite > textures ) <nl> + public BakedWrapper ( Node < ? > node , IModelState state , VertexFormat format , ImmutableSet < String > meshes , ImmutableMap < String , TextureAtlasSprite > textures ) <nl> { <nl> - this . model = model ; <nl> + this ( node , state , format , meshes , textures , CacheBuilder . newBuilder ( ) <nl> + . maximumSize ( 128 ) <nl> + . expireAfterAccess ( 2 , TimeUnit . MINUTES ) <nl> + . build ( new CacheLoader < Integer , BakedWrapper > ( ) <nl> + { <nl> + public BakedWrapper load ( Integer frame ) throws Exception <nl> + { <nl> + IModelState parent = state ; <nl> + Animation newAnimation = null ; <nl> + if ( parent instanceof B3DState ) <nl> + { <nl> + B3DState ps = ( B3DState ) parent ; <nl> + parent = ps . getParent ( ) ; <nl> + } <nl> + if ( newAnimation = = null ) <nl> + { <nl> + newAnimation = node . getAnimation ( ) ; <nl> + } <nl> + return new BakedWrapper ( node , new B3DState ( newAnimation , frame , frame , 0 , parent ) , format , meshes , textures ) ; <nl> + } <nl> + } ) ) ; <nl> + } <nl> + public BakedWrapper ( Node < ? > node , IModelState state , VertexFormat format , ImmutableSet < String > meshes , ImmutableMap < String , TextureAtlasSprite > textures , LoadingCache < Integer , BakedWrapper > cache ) <nl> + { <nl> + this . node = node ; <nl> this . state = state ; <nl> this . format = format ; <nl> + this . meshes = meshes ; <nl> this . textures = textures ; <nl> + this . cache = cache ; <nl> } <nl> <nl> public List < BakedQuad > getFaceQuads ( EnumFacing side ) <nl> @ @ - 495 , 47 + 749 , 43 @ @ public class B3DLoader implements ICustomModelLoader <nl> return Collections . emptyList ( ) ; <nl> } <nl> <nl> - @ SuppressWarnings ( " unchecked " ) <nl> public List < BakedQuad > getGeneralQuads ( ) <nl> { <nl> if ( quads = = null ) <nl> { <nl> - Node < Mesh > mesh = model . getNode ( ) ; <nl> ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; <nl> - for ( Node < ? > child : mesh . getNodes ( ) . values ( ) ) <nl> + for ( Node < ? > child : node . getNodes ( ) . values ( ) ) <nl> { <nl> - if ( child . getKind ( ) instanceof Mesh ) <nl> - { <nl> - Node < Mesh > childMesh = ( Node < Mesh > ) child ; <nl> - builder . addAll ( new BakedWrapper ( new B3DLoader . Wrapper ( model . getLocation ( ) , model . getTextureMap ( ) , childMesh ) , state , format , textures ) . getGeneralQuads ( ) ) ; <nl> - } <nl> + builder . addAll ( new BakedWrapper ( child , state , format , meshes , textures ) . getGeneralQuads ( ) ) ; <nl> } <nl> - mesh . getKind ( ) . getWeightMap ( ) ; <nl> - Collection < Face > faces = mesh . getKind ( ) . getFaces ( ) ; <nl> - faces = mesh . getKind ( ) . bake ( new Function < Node < ? > , Matrix4f > ( ) <nl> + if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) ) <nl> { <nl> - / / gets transformation in global space <nl> - public Matrix4f apply ( Node < ? > node ) <nl> + Mesh mesh = ( Mesh ) node . getKind ( ) ; <nl> + Collection < Face > faces = mesh . bake ( new Function < Node < ? > , Matrix4f > ( ) <nl> + { <nl> + / / gets transformation in global space <nl> + public Matrix4f apply ( Node < ? > node ) <nl> + { <nl> + return state . apply ( PartWrapper . create ( node ) ) . getMatrix ( ) ; <nl> + } <nl> + } ) ; <nl> + for ( Face f : faces ) <nl> { <nl> - return state . apply ( PartWrapper . create ( node ) ) . getMatrix ( ) ; <nl> + UnpackedBakedQuad . Builder quadBuilder = new UnpackedBakedQuad . Builder ( format ) ; <nl> + quadBuilder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; <nl> + quadBuilder . setQuadColored ( ) ; <nl> + List < Texture > textures = null ; <nl> + if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; <nl> + TextureAtlasSprite sprite ; <nl> + if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; <nl> + else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; <nl> + else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; <nl> + putVertexData ( quadBuilder , f . getV1 ( ) , f . getNormal ( ) , sprite ) ; <nl> + putVertexData ( quadBuilder , f . getV2 ( ) , f . getNormal ( ) , sprite ) ; <nl> + putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; <nl> + putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; <nl> + builder . add ( quadBuilder . build ( ) ) ; <nl> } <nl> - } ) ; <nl> - for ( Face f : faces ) <nl> - { <nl> - UnpackedBakedQuad . Builder quadBuilder = new UnpackedBakedQuad . Builder ( format ) ; <nl> - quadBuilder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; <nl> - quadBuilder . setQuadColored ( ) ; <nl> - List < Texture > textures = null ; <nl> - if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; <nl> - TextureAtlasSprite sprite ; <nl> - if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; <nl> - else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; <nl> - else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; <nl> - putVertexData ( quadBuilder , f . getV1 ( ) , f . getNormal ( ) , sprite ) ; <nl> - putVertexData ( quadBuilder , f . getV2 ( ) , f . getNormal ( ) , sprite ) ; <nl> - putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; <nl> - putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; <nl> - builder . add ( quadBuilder . build ( ) ) ; <nl> } <nl> quads = builder . build ( ) ; <nl> } <nl> @ @ - 632 , 24 + 882 , 30 @ @ public class B3DLoader implements ICustomModelLoader <nl> B3DState s = exState . getValue ( B3DFrameProperty . instance ) ; <nl> if ( s ! = null ) <nl> { <nl> - return getCachedModel ( s . getFrame ( ) ) ; <nl> + / / return getCachedModel ( s . getFrame ( ) ) ; <nl> + IModelState parent = this . state ; <nl> + Animation newAnimation = s . getAnimation ( ) ; <nl> + if ( parent instanceof B3DState ) <nl> + { <nl> + B3DState ps = ( B3DState ) parent ; <nl> + parent = ps . getParent ( ) ; <nl> + } <nl> + if ( newAnimation = = null ) <nl> + { <nl> + newAnimation = node . getAnimation ( ) ; <nl> + } <nl> + if ( s . getFrame ( ) = = s . getNextFrame ( ) ) <nl> + { <nl> + return cache . getUnchecked ( s . getFrame ( ) ) ; <nl> + } <nl> + B3DState newState = new B3DState ( newAnimation , s . getFrame ( ) , s . getNextFrame ( ) , s . getProgress ( ) , parent ) ; <nl> + return new BakedWrapper ( node , newState , format , meshes , textures ) ; <nl> } <nl> } <nl> } <nl> return this ; <nl> } <nl> <nl> - private final Map < Integer , BakedWrapper > cache = new HashMap < Integer , BakedWrapper > ( ) ; <nl> - <nl> - public BakedWrapper getCachedModel ( int frame ) <nl> - { <nl> - if ( ! cache . containsKey ( frame ) ) <nl> - { <nl> - cache . put ( frame , new BakedWrapper ( model , new B3DState ( model . getNode ( ) . getAnimation ( ) , frame , state ) , format , textures ) ) ; <nl> - } <nl> - return cache . get ( frame ) ; <nl> - } <nl> - <nl> public VertexFormat getFormat ( ) <nl> { <nl> return format ; <nl> @ @ - 665 , 7 + 921 , 7 @ @ public class B3DLoader implements ICustomModelLoader <nl> { <nl> if ( state instanceof IPerspectiveState ) <nl> { <nl> - return Pair . of ( ( IBakedModel ) this , TRSRTransformation . blockCornerToCenter ( ( ( IPerspectiveState ) state ) . forPerspective ( cameraTransformType ) . apply ( model ) ) . getMatrix ( ) ) ; <nl> + return Pair . of ( ( IBakedModel ) this , TRSRTransformation . blockCornerToCenter ( ( ( IPerspectiveState ) state ) . forPerspective ( cameraTransformType ) . apply ( PartWrapper . create ( node ) ) ) . getMatrix ( ) ) ; <nl> } <nl> return Pair . of ( ( IBakedModel ) this , null ) ; <nl> } <nl> diff - - git a / src / test / java / net / minecraftforge / debug / ModelAnimationDebug . java b / src / test / java / net / minecraftforge / debug / ModelAnimationDebug . java <nl> new file mode 100644 <nl> index 0000000 . . 48b8ec2 <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / debug / ModelAnimationDebug . java <nl> @ @ - 0 , 0 + 1 , 285 @ @ <nl> + package net . minecraftforge . debug ; <nl> + <nl> + import net . minecraft . block . Block ; <nl> + import net . minecraft . block . BlockPistonBase ; <nl> + import net . minecraft . block . material . Material ; <nl> + import net . minecraft . block . properties . IProperty ; <nl> + import net . minecraft . block . properties . PropertyDirection ; <nl> + import net . minecraft . block . state . IBlockState ; <nl> + import net . minecraft . client . Minecraft ; <nl> + import net . minecraft . client . renderer . BlockRendererDispatcher ; <nl> + import net . minecraft . client . renderer . GlStateManager ; <nl> + import net . minecraft . client . renderer . RenderHelper ; <nl> + import net . minecraft . client . renderer . Tessellator ; <nl> + import net . minecraft . client . renderer . WorldRenderer ; <nl> + import net . minecraft . client . renderer . texture . TextureMap ; <nl> + import net . minecraft . client . renderer . tileentity . TileEntitySpecialRenderer ; <nl> + import net . minecraft . client . renderer . vertex . DefaultVertexFormats ; <nl> + import net . minecraft . client . resources . model . IBakedModel ; <nl> + import net . minecraft . client . resources . model . ModelResourceLocation ; <nl> + import net . minecraft . creativetab . CreativeTabs ; <nl> + import net . minecraft . entity . EntityLivingBase ; <nl> + import net . minecraft . entity . player . EntityPlayer ; <nl> + import net . minecraft . item . Item ; <nl> + import net . minecraft . tileentity . TileEntity ; <nl> + import net . minecraft . util . BlockPos ; <nl> + import net . minecraft . util . EnumFacing ; <nl> + import net . minecraft . util . ITickable ; <nl> + import net . minecraft . world . World ; <nl> + import net . minecraftforge . client . model . ISmartBlockModel ; <nl> + import net . minecraftforge . client . model . ModelLoader ; <nl> + import net . minecraftforge . client . model . b3d . B3DLoader ; <nl> + import net . minecraftforge . client . model . b3d . B3DLoader . B3DFrameProperty ; <nl> + import net . minecraftforge . client . model . b3d . B3DLoader . B3DState ; <nl> + import net . minecraftforge . common . property . ExtendedBlockState ; <nl> + import net . minecraftforge . common . property . IExtendedBlockState ; <nl> + import net . minecraftforge . common . property . IUnlistedProperty ; <nl> + import net . minecraftforge . fml . client . registry . ClientRegistry ; <nl> + import net . minecraftforge . fml . common . Mod ; <nl> + import net . minecraftforge . fml . common . Mod . EventHandler ; <nl> + import net . minecraftforge . fml . common . SidedProxy ; <nl> + import net . minecraftforge . fml . common . event . FMLInitializationEvent ; <nl> + import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> + import net . minecraftforge . fml . common . registry . GameRegistry ; <nl> + <nl> + import org . lwjgl . opengl . GL11 ; <nl> + <nl> + @ Mod ( modid = ModelAnimationDebug . MODID , version = ModelAnimationDebug . VERSION ) <nl> + public class ModelAnimationDebug <nl> + { <nl> + public static final String MODID = " forgedebugmodelanimation " ; <nl> + public static final String VERSION = " 0 . 0 " ; <nl> + <nl> + public static String blockName = " test _ animation _ block " ; <nl> + public static final PropertyDirection FACING = PropertyDirection . create ( " facing " ) ; <nl> + <nl> + @ SidedProxy ( serverSide = " net . minecraftforge . debug . ModelAnimationDebug $ CommonProxy " , clientSide = " net . minecraftforge . debug . ModelAnimationDebug $ ClientProxy " ) <nl> + public static CommonProxy proxy ; <nl> + <nl> + public static class CommonProxy <nl> + { <nl> + public void preInit ( FMLPreInitializationEvent event ) <nl> + { <nl> + B3DLoader . instance . addDomain ( MODID ) ; <nl> + GameRegistry . registerBlock ( new Block ( Material . wood ) <nl> + { <nl> + { <nl> + setCreativeTab ( CreativeTabs . tabBlock ) ; <nl> + setUnlocalizedName ( MODID + " . " + blockName ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public ExtendedBlockState createBlockState ( ) <nl> + { <nl> + return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { B3DFrameProperty . instance } ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int getRenderType ( ) { return - 1 ; } <nl> + <nl> + @ Override <nl> + public boolean isOpaqueCube ( ) { return false ; } <nl> + <nl> + @ Override <nl> + public boolean isFullCube ( ) { return false ; } <nl> + <nl> + @ Override <nl> + public IBlockState onBlockPlaced ( World world , BlockPos pos , EnumFacing facing , float hitX , float hitY , float hitZ , int meta , EntityLivingBase placer ) <nl> + { <nl> + return this . getDefaultState ( ) . withProperty ( FACING , BlockPistonBase . getFacingFromEntity ( world , pos , placer ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public IBlockState getStateFromMeta ( int meta ) { <nl> + return getDefaultState ( ) . withProperty ( FACING , EnumFacing . getFront ( meta ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int getMetaFromState ( IBlockState state ) { <nl> + return ( ( EnumFacing ) state . getValue ( FACING ) ) . getIndex ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasTileEntity ( IBlockState state ) { <nl> + return true ; <nl> + } <nl> + <nl> + @ Override <nl> + public TileEntity createTileEntity ( World world , IBlockState state ) { <nl> + return new Chest ( state ) ; <nl> + } <nl> + <nl> + / * @ Override <nl> + public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) { <nl> + TileEntity te = world . getTileEntity ( pos ) ; <nl> + if ( te instanceof Chest & & state instanceof IExtendedBlockState ) <nl> + { <nl> + return ( ( Chest ) te ) . getState ( ( IExtendedBlockState ) state ) ; <nl> + } <nl> + return super . getExtendedState ( state , world , pos ) ; <nl> + } * / <nl> + <nl> + @ Override <nl> + public boolean onBlockActivated ( World world , BlockPos pos , IBlockState state , EntityPlayer player , EnumFacing side , float hitX , float hitY , float hitZ ) <nl> + { <nl> + if ( world . isRemote ) <nl> + { <nl> + TileEntity te = world . getTileEntity ( pos ) ; <nl> + if ( te instanceof Chest ) <nl> + { <nl> + ( ( Chest ) te ) . click ( ) ; <nl> + } <nl> + } <nl> + return false ; <nl> + } <nl> + } , blockName ) ; <nl> + } <nl> + <nl> + public void init ( FMLInitializationEvent event ) { } <nl> + } <nl> + <nl> + public static class ClientProxy extends CommonProxy <nl> + { <nl> + @ Override <nl> + public void preInit ( FMLPreInitializationEvent event ) <nl> + { <nl> + super . preInit ( event ) ; <nl> + ModelLoader . setCustomModelResourceLocation ( Item . getItemFromBlock ( GameRegistry . findBlock ( MODID , blockName ) ) , 0 , new ModelResourceLocation ( MODID . toLowerCase ( ) + " : " + blockName , " inventory " ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void init ( FMLInitializationEvent event ) <nl> + { <nl> + super . init ( event ) ; <nl> + ClientRegistry . bindTileEntitySpecialRenderer ( Chest . class , ChestRenderer . instance ) ; <nl> + } <nl> + } <nl> + <nl> + @ EventHandler <nl> + public void preInit ( FMLPreInitializationEvent event ) { proxy . preInit ( event ) ; } <nl> + <nl> + @ EventHandler <nl> + public void init ( FMLInitializationEvent event ) { proxy . init ( event ) ; } <nl> + <nl> + private static class Chest extends TileEntity implements ITickable <nl> + { <nl> + private final int minFrame = 1 ; <nl> + private final int maxFrame = 10 ; <nl> + private int tick = minFrame ; <nl> + private boolean opening = false ; <nl> + private boolean closing = false ; <nl> + <nl> + public Chest ( IBlockState state ) { <nl> + } <nl> + <nl> + / * public IExtendedBlockState getState ( IExtendedBlockState state ) { <nl> + return state . withProperty ( B3DFrameProperty . instance , curState ) ; <nl> + } * / <nl> + <nl> + public void click ( ) <nl> + { <nl> + if ( opening | | tick = = maxFrame ) <nl> + { <nl> + opening = false ; <nl> + closing = true ; <nl> + return ; <nl> + } <nl> + if ( closing | | tick = = minFrame ) <nl> + { <nl> + closing = false ; <nl> + opening = true ; <nl> + return ; <nl> + } <nl> + opening = true ; <nl> + } <nl> + <nl> + @ Override <nl> + public void update ( ) <nl> + { <nl> + if ( opening ) <nl> + { <nl> + tick + + ; <nl> + if ( tick > = maxFrame ) <nl> + { <nl> + tick = maxFrame ; <nl> + opening = false ; <nl> + } <nl> + } <nl> + if ( closing ) <nl> + { <nl> + tick - - ; <nl> + if ( tick < = minFrame ) <nl> + { <nl> + tick = minFrame ; <nl> + closing = false ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public int getCurFrame ( ) <nl> + { <nl> + return tick ; <nl> + } <nl> + <nl> + public int getNextFrame ( ) <nl> + { <nl> + if ( opening ) return Math . min ( tick + 1 , maxFrame ) ; <nl> + if ( closing ) return Math . max ( tick - 1 , minFrame ) ; <nl> + return tick ; <nl> + } <nl> + } <nl> + <nl> + private static class ChestRenderer extends TileEntitySpecialRenderer < Chest > <nl> + { <nl> + public static ChestRenderer instance = new ChestRenderer ( ) ; <nl> + private ChestRenderer ( ) { } <nl> + <nl> + private final BlockRendererDispatcher blockRenderer = Minecraft . getMinecraft ( ) . getBlockRendererDispatcher ( ) ; <nl> + <nl> + public void renderTileEntityAt ( Chest te , double x , double y , double z , float partialTick , int breakStage ) <nl> + { <nl> + IBlockState state = te . getWorld ( ) . getBlockState ( te . getPos ( ) ) ; <nl> + IBakedModel model = this . blockRenderer . getModelFromBlockState ( state , te . getWorld ( ) , te . getPos ( ) ) ; <nl> + if ( state instanceof IExtendedBlockState ) <nl> + { <nl> + IExtendedBlockState exState = ( IExtendedBlockState ) state ; <nl> + if ( exState . getUnlistedNames ( ) . contains ( B3DFrameProperty . instance ) ) <nl> + { <nl> + exState = exState . withProperty ( B3DFrameProperty . instance , new B3DState ( null , te . getCurFrame ( ) , te . getNextFrame ( ) , partialTick ) ) ; <nl> + if ( model instanceof ISmartBlockModel ) <nl> + { <nl> + model = ( ( ISmartBlockModel ) model ) . handleBlockState ( exState ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + Tessellator tessellator = Tessellator . getInstance ( ) ; <nl> + WorldRenderer worldrenderer = tessellator . getWorldRenderer ( ) ; <nl> + this . bindTexture ( TextureMap . locationBlocksTexture ) ; <nl> + RenderHelper . disableStandardItemLighting ( ) ; <nl> + GlStateManager . blendFunc ( GL11 . GL _ SRC _ ALPHA , GL11 . GL _ ONE _ MINUS _ SRC _ ALPHA ) ; <nl> + GlStateManager . enableBlend ( ) ; <nl> + GlStateManager . disableCull ( ) ; <nl> + <nl> + if ( Minecraft . isAmbientOcclusionEnabled ( ) ) <nl> + { <nl> + GlStateManager . shadeModel ( GL11 . GL _ SMOOTH ) ; <nl> + } <nl> + else <nl> + { <nl> + GlStateManager . shadeModel ( GL11 . GL _ FLAT ) ; <nl> + } <nl> + <nl> + worldrenderer . func _ 181668 _ a ( 7 , DefaultVertexFormats . BLOCK ) ; <nl> + worldrenderer . setTranslation ( x - te . getPos ( ) . getX ( ) , y - te . getPos ( ) . getY ( ) , z - te . getPos ( ) . getZ ( ) ) ; <nl> + <nl> + this . blockRenderer . getBlockModelRenderer ( ) . renderModel ( te . getWorld ( ) , model , state , te . getPos ( ) , worldrenderer , false ) ; <nl> + <nl> + worldrenderer . setTranslation ( 0 , 0 , 0 ) ; <nl> + tessellator . draw ( ) ; <nl> + <nl> + RenderHelper . enableStandardItemLighting ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> diff - - git a / src / test / resources / assets / forgedebugmodelanimation / blockstates / test _ animation _ block . json b / src / test / resources / assets / forgedebugmodelanimation / blockstates / test _ animation _ block . json <nl> new file mode 100644 <nl> index 0000000 . . b12b091 <nl> - - - / dev / null <nl> + + + b / src / test / resources / assets / forgedebugmodelanimation / blockstates / test _ animation _ block . json <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + { <nl> + " forge _ marker " : 1 , <nl> + " defaults " : { <nl> + " textures " : { <nl> + " # chest " : " entity / chest / normal " <nl> + } , <nl> + " model " : " forgedebugmodelloaderregistry : chest . b3d " , <nl> + " custom " : { <nl> + " mesh " : [ " Cube . 001 " ] <nl> + } <nl> + } , <nl> + " variants " : { <nl> + " normal " : [ { } ] , <nl> + " inventory " : [ { <nl> + " transform " : " forge : default - block " <nl> + } ] , <nl> + " facing " : { <nl> + " down " : { " transform " : { " rotation " : { " x " : 90 } } } , <nl> + " up " : { " transform " : { " rotation " : { " x " : 270 } } } , <nl> + " north " : { " transform " : { " rotation " : { " y " : 180 } } } , <nl> + " south " : { " transform " : " identity " } , <nl> + " west " : { " transform " : { " rotation " : { " y " : 90 } } } , <nl> + " east " : { " transform " : { " rotation " : { " y " : 270 } } } <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> index ca6ab30 . . 46f1c46 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java <nl> @ @ - 30 , 8 + 30 , 10 @ @ import net . minecraftforge . client . model . IColoredBakedQuad . ColoredBakedQuad ; <nl> import net . minecraftforge . client . model . ICustomModelLoader ; <nl> import net . minecraftforge . client . model . IFlexibleBakedModel ; <nl> import net . minecraftforge . client . model . IModel ; <nl> + import net . minecraftforge . client . model . IModelCustomData ; <nl> import net . minecraftforge . client . model . IModelPart ; <nl> import net . minecraftforge . client . model . IModelState ; <nl> + import net . minecraftforge . client . model . IRetexturableModel ; <nl> import net . minecraftforge . client . model . ISmartBlockModel ; <nl> import net . minecraftforge . client . model . ISmartItemModel ; <nl> import net . minecraftforge . client . model . ModelLoader ; <nl> @ @ - 56 , 11 + 58 , 14 @ @ import org . apache . logging . log4j . Level ; <nl> import org . lwjgl . BufferUtils ; <nl> <nl> import com . google . common . base . Function ; <nl> + import com . google . common . base . Predicate ; <nl> import com . google . common . cache . CacheBuilder ; <nl> import com . google . common . cache . CacheLoader ; <nl> import com . google . common . cache . LoadingCache ; <nl> + import com . google . common . collect . Collections2 ; <nl> import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . ImmutableMap ; <nl> + import com . google . common . collect . Maps ; <nl> import com . google . common . collect . Multimap ; <nl> <nl> / * <nl> @ @ - 238 , 24 + 243 , 28 @ @ public class B3DLoader implements ICustomModelLoader <nl> public static TRSRTransformation getNodeMatrix ( Animation animation , Node < ? > node , int frame ) <nl> { <nl> TRSRTransformation ret = TRSRTransformation . identity ( ) ; <nl> - if ( node . getParent ( ) ! = null ) <nl> - { <nl> - TRSRTransformation pm = cache . getUnchecked ( Triple . < Animation , Node < ? > , Integer > of ( animation , node . getParent ( ) , frame ) ) ; <nl> - ret = ret . compose ( pm ) ; <nl> - } <nl> Key key = null ; <nl> if ( animation ! = null ) key = animation . getKeys ( ) . get ( frame , node ) ; <nl> else if ( key = = null & & node . getAnimation ( ) ! = null & & node . getAnimation ( ) ! = animation ) key = node . getAnimation ( ) . getKeys ( ) . get ( frame , node ) ; <nl> - if ( key = = null ) <nl> - { <nl> - FMLLog . severe ( " invalid key index : " + frame ) ; <nl> - } <nl> - else <nl> + if ( key ! = null ) <nl> { <nl> + Node < ? > parent = node . getParent ( ) ; <nl> + if ( parent ! = null ) <nl> + { <nl> + TRSRTransformation pm = cache . getUnchecked ( Triple . < Animation , Node < ? > , Integer > of ( animation , node . getParent ( ) , frame ) ) ; <nl> + ret = ret . compose ( pm ) ; <nl> + ret = ret . compose ( new TRSRTransformation ( parent . getPos ( ) , parent . getRot ( ) , parent . getScale ( ) , null ) ) ; <nl> + } <nl> ret = ret . compose ( new TRSRTransformation ( key . getPos ( ) , key . getRot ( ) , key . getScale ( ) , null ) ) ; <nl> Matrix4f rm = new TRSRTransformation ( node . getPos ( ) , node . getRot ( ) , node . getScale ( ) , null ) . getMatrix ( ) ; <nl> rm . invert ( ) ; <nl> ret = ret . compose ( new TRSRTransformation ( rm ) ) ; <nl> + if ( parent ! = null ) <nl> + { <nl> + rm = new TRSRTransformation ( parent . getPos ( ) , parent . getRot ( ) , parent . getScale ( ) , null ) . getMatrix ( ) ; <nl> + rm . invert ( ) ; <nl> + ret = ret . compose ( new TRSRTransformation ( rm ) ) ; <nl> + } <nl> } <nl> return ret ; <nl> } <nl> @ @ - 305 , 14 + 314 , 14 @ @ public class B3DLoader implements ICustomModelLoader <nl> } <nl> } <nl> <nl> - public static class Wrapper extends PartWrapper < Mesh > implements IModel <nl> + public static class Wrapper extends PartWrapper < Mesh > implements IRetexturableModel , IModelCustomData <nl> { <nl> private final ResourceLocation location ; <nl> private final ImmutableMap < String , ResourceLocation > textures ; <nl> <nl> public Wrapper ( ResourceLocation location , List < Texture > textures , B3DModel . Node < Mesh > mesh ) <nl> { <nl> - this ( location , buildTextures ( location , textures ) , mesh ) ; <nl> + this ( location , buildTextures ( textures ) , mesh ) ; <nl> } <nl> <nl> public Wrapper ( ResourceLocation location , ImmutableMap < String , ResourceLocation > textures , B3DModel . Node < Mesh > mesh ) <nl> @ @ - 322 , 19 + 331 , 24 @ @ public class B3DLoader implements ICustomModelLoader <nl> this . textures = textures ; <nl> } <nl> <nl> - private static ImmutableMap < String , ResourceLocation > buildTextures ( ResourceLocation location , List < Texture > textures ) <nl> + private static ImmutableMap < String , ResourceLocation > buildTextures ( List < Texture > textures ) <nl> { <nl> ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; <nl> <nl> for ( Texture t : textures ) <nl> { <nl> String path = t . getPath ( ) ; <nl> - if ( path . endsWith ( " . png " ) ) path = path . substring ( 0 , path . length ( ) - " . png " . length ( ) ) ; <nl> - builder . put ( t . getPath ( ) , new ResourceLocation ( location . getResourceDomain ( ) , path ) ) ; <nl> + builder . put ( path , new ResourceLocation ( getLocation ( path ) ) ) ; <nl> } <nl> return builder . build ( ) ; <nl> } <nl> <nl> + private static String getLocation ( String path ) <nl> + { <nl> + if ( path . endsWith ( " . png " ) ) path = path . substring ( 0 , path . length ( ) - " . png " . length ( ) ) ; <nl> + return path ; <nl> + } <nl> + <nl> public Collection < ResourceLocation > getDependencies ( ) <nl> { <nl> / / no dependencies for in - file models <nl> @ @ - 344 , 17 + 358 , 32 @ @ public class B3DLoader implements ICustomModelLoader <nl> <nl> public Collection < ResourceLocation > getTextures ( ) <nl> { <nl> - return textures . values ( ) ; <nl> + return Collections2 . filter ( textures . values ( ) , new Predicate < ResourceLocation > ( ) <nl> + { <nl> + public boolean apply ( ResourceLocation loc ) <nl> + { <nl> + return ! loc . getResourcePath ( ) . startsWith ( " # " ) ; <nl> + } <nl> + } ) ; <nl> } <nl> <nl> public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> { <nl> ImmutableMap . Builder < String , TextureAtlasSprite > builder = ImmutableMap . builder ( ) ; <nl> - for ( String path : textures . keySet ( ) ) <nl> + TextureAtlasSprite missing = bakedTextureGetter . apply ( new ResourceLocation ( " missingno " ) ) ; <nl> + for ( Map . Entry < String , ResourceLocation > e : textures . entrySet ( ) ) <nl> { <nl> - builder . put ( path , bakedTextureGetter . apply ( textures . get ( path ) ) ) ; <nl> + if ( e . getValue ( ) . getResourcePath ( ) . startsWith ( " # " ) ) <nl> + { <nl> + FMLLog . severe ( " unresolved texture ' % s ' for b3d model ' % s ' " , e . getValue ( ) . getResourcePath ( ) , location ) ; <nl> + builder . put ( e . getKey ( ) , missing ) ; <nl> + } <nl> + else <nl> + { <nl> + builder . put ( e . getKey ( ) , bakedTextureGetter . apply ( e . getValue ( ) ) ) ; <nl> + } <nl> } <nl> - builder . put ( " missingno " , bakedTextureGetter . apply ( new ResourceLocation ( " missingno " ) ) ) ; <nl> + builder . put ( " missingno " , missing ) ; <nl> return new BakedWrapper ( this , state , format , builder . build ( ) ) ; <nl> } <nl> <nl> @ @ - 396 , 6 + 425 , 35 @ @ public class B3DLoader implements ICustomModelLoader <nl> else if ( ! location . equals ( other . location ) ) return false ; <nl> return true ; <nl> } <nl> + <nl> + @ Override <nl> + public IModel retexture ( ImmutableMap < String , String > textures ) <nl> + { <nl> + ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; <nl> + for ( Map . Entry < String , ResourceLocation > e : this . textures . entrySet ( ) ) <nl> + { <nl> + String path = e . getKey ( ) ; <nl> + String loc = getLocation ( path ) ; <nl> + if ( textures . containsKey ( loc ) ) <nl> + { <nl> + String newLoc = textures . get ( loc ) ; <nl> + if ( newLoc = = null ) newLoc = getLocation ( path ) ; <nl> + builder . put ( e . getKey ( ) , new ResourceLocation ( newLoc ) ) ; <nl> + } <nl> + else <nl> + { <nl> + builder . put ( e ) ; <nl> + } <nl> + } <nl> + return new Wrapper ( location , builder . build ( ) , getNode ( ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public IModel process ( ImmutableMap < String , String > customData ) <nl> + { <nl> + / / TODO keyframe <nl> + return null ; <nl> + } <nl> } <nl> <nl> private static class BakedWrapper implements IFlexibleBakedModel , ISmartBlockModel , ISmartItemModel <nl> @ @ - 454 , 9 + 512 , 10 @ @ public class B3DLoader implements ICustomModelLoader <nl> for ( Face f : faces ) <nl> { <nl> buf . clear ( ) ; <nl> - List < Texture > textures = f . getBrush ( ) . getTextures ( ) ; <nl> + List < Texture > textures = null ; <nl> + if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; <nl> TextureAtlasSprite sprite ; <nl> - if ( textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; <nl> + if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; <nl> else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; <nl> else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; <nl> putVertexData ( f . getV1 ( ) , sprite ) ; <nl> diff - - git a / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java b / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java <nl> index 3fe304b . . 2358b93 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java <nl> + + + b / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java <nl> @ @ - 64 , 14 + 64 , 9 @ @ public class ModelLoaderRegistryDebug <nl> <nl> private void clientPreInit ( ) <nl> { <nl> - / / ModelLoaderRegistry . registerLoader ( DummyModelLoader . instance ) ; <nl> B3DLoader . instance . addDomain ( MODID . toLowerCase ( ) ) ; <nl> - / / ModelBakery . addVariantName ( Item . getItemFromBlock ( CustomModelBlock . instance ) , " forgedebug : dummymodel " ) ; <nl> - String modelLocation = MODID . toLowerCase ( ) + " : untitled2 . b3d " ; <nl> - ModelBakery . addVariantName ( Item . getItemFromBlock ( CustomModelBlock . instance ) , modelLocation ) ; <nl> Item item = Item . getItemFromBlock ( CustomModelBlock . instance ) ; <nl> - ModelLoader . setCustomModelResourceLocation ( item , 0 , new ModelResourceLocation ( modelLocation , " inventory " ) ) ; <nl> - / / ModelLoader . setCustomModelResourceLocation ( item , 0 , new ModelResourceLocation ( " forgedebug : dummymodel " , " inventory " ) ) ; <nl> + ModelLoader . setCustomModelResourceLocation ( item , 0 , new ModelResourceLocation ( MODID . toLowerCase ( ) + " : " + CustomModelBlock . name , " inventory " ) ) ; <nl> } <nl> <nl> public static class CustomModelBlock extends Block <nl> @ @ - 100 , 9 + 95 , 7 @ @ public class ModelLoaderRegistryDebug <nl> @ Override <nl> public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) <nl> { <nl> - IModel model = ModelLoaderRegistry . getModel ( new ResourceLocation ( MODID . toLowerCase ( ) , " block / untitled2 . b3d " ) ) ; <nl> - B3DLoader . B3DState defaultState = ( ( B3DLoader . Wrapper ) model ) . getDefaultState ( ) ; <nl> - B3DLoader . B3DState newState = new B3DLoader . B3DState ( defaultState . getAnimation ( ) , counter ) ; <nl> + B3DLoader . B3DState newState = new B3DLoader . B3DState ( null , counter ) ; <nl> return ( ( IExtendedBlockState ) this . state . getBaseState ( ) ) . withProperty ( B3DLoader . B3DFrameProperty . instance , newState ) ; <nl> } <nl> <nl> @ @ - 120 , 106 + 113 , 4 @ @ public class ModelLoaderRegistryDebug <nl> return false ; <nl> } <nl> } <nl> - <nl> - public static class DummyModelLoader implements ICustomModelLoader <nl> - { <nl> - public static final DummyModelLoader instance = new DummyModelLoader ( ) ; <nl> - public static final ResourceLocation dummyTexture = new ResourceLocation ( " minecraft : blocks / dirt " ) ; <nl> - <nl> - public boolean accepts ( ResourceLocation modelLocation ) <nl> - { <nl> - return modelLocation . getResourceDomain ( ) . equals ( " forgedebug " ) & & modelLocation . getResourcePath ( ) . contains ( " dummymodel " ) ; <nl> - } <nl> - <nl> - public IModel loadModel ( ResourceLocation model ) <nl> - { <nl> - return DummyModel . instance ; <nl> - } <nl> - <nl> - public static enum DummyModel implements IModel <nl> - { <nl> - instance ; <nl> - <nl> - public Collection < ResourceLocation > getDependencies ( ) <nl> - { <nl> - return Collections . emptyList ( ) ; <nl> - } <nl> - <nl> - public Collection < ResourceLocation > getTextures ( ) <nl> - { <nl> - return Collections . singletonList ( dummyTexture ) ; <nl> - } <nl> - <nl> - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > textures ) <nl> - { <nl> - return new DummyBakedModel ( textures . apply ( dummyTexture ) ) ; <nl> - } <nl> - <nl> - public IModelState getDefaultState ( ) <nl> - { <nl> - return ModelRotation . X0 _ Y0 ; <nl> - } <nl> - } <nl> - <nl> - public static class DummyBakedModel implements IFlexibleBakedModel <nl> - { <nl> - private final TextureAtlasSprite texture ; <nl> - <nl> - public DummyBakedModel ( TextureAtlasSprite texture ) <nl> - { <nl> - this . texture = texture ; <nl> - } <nl> - <nl> - public List < BakedQuad > getFaceQuads ( EnumFacing side ) <nl> - { <nl> - return Collections . emptyList ( ) ; <nl> - } <nl> - <nl> - private int [ ] vertexToInts ( float x , float y , float z , int color , float u , float v ) <nl> - { <nl> - return new int [ ] { <nl> - Float . floatToRawIntBits ( x ) , <nl> - Float . floatToRawIntBits ( y ) , <nl> - Float . floatToRawIntBits ( z ) , <nl> - color , <nl> - Float . floatToRawIntBits ( texture . getInterpolatedU ( u ) ) , <nl> - Float . floatToRawIntBits ( texture . getInterpolatedV ( v ) ) , <nl> - 0 <nl> - } ; <nl> - } <nl> - <nl> - public List < BakedQuad > getGeneralQuads ( ) <nl> - { <nl> - List < BakedQuad > ret = new ArrayList < BakedQuad > ( ) ; <nl> - / / 1 half - way rotated quad looking UP <nl> - ret . add ( new BakedQuad ( Ints . concat ( <nl> - vertexToInts ( 0 , . 5f , . 5f , - 1 , 0 , 0 ) , <nl> - vertexToInts ( . 5f , . 5f , 1 , - 1 , 0 , 16 ) , <nl> - vertexToInts ( 1 , . 5f , . 5f , - 1 , 16 , 16 ) , <nl> - vertexToInts ( . 5f , . 5f , 0 , - 1 , 16 , 0 ) <nl> - ) , - 1 , EnumFacing . UP ) ) ; <nl> - return ret ; <nl> - } <nl> - <nl> - public boolean isGui3d ( ) { return true ; } <nl> - <nl> - public boolean isAmbientOcclusion ( ) { return true ; } <nl> - <nl> - public boolean isBuiltInRenderer ( ) { return false ; } <nl> - <nl> - public TextureAtlasSprite getTexture ( ) { return this . texture ; } <nl> - <nl> - public ItemCameraTransforms getItemCameraTransforms ( ) <nl> - { <nl> - return ItemCameraTransforms . DEFAULT ; <nl> - } <nl> - <nl> - public VertexFormat getFormat ( ) <nl> - { <nl> - return Attributes . DEFAULT _ BAKED _ FORMAT ; <nl> - } <nl> - } <nl> - <nl> - public void onResourceManagerReload ( IResourceManager resourceManager ) { } <nl> - } <nl> } <nl> diff - - git a / src / test / resources / assets / forgedebugmodelloaderregistry / blockstates / CustomModelBlock . json b / src / test / resources / assets / forgedebugmodelloaderregistry / blockstates / CustomModelBlock . json <nl> index 1ebdfc8 . . c6db8d8 100644 <nl> - - - a / src / test / resources / assets / forgedebugmodelloaderregistry / blockstates / CustomModelBlock . json <nl> + + + b / src / test / resources / assets / forgedebugmodelloaderregistry / blockstates / CustomModelBlock . json <nl> @ @ - 1 , 5 + 1 , 18 @ @ <nl> { <nl> + " forge _ marker " : 1 , <nl> + " defaults " : { <nl> + " textures " : { <nl> + " # texture " : " forgedebugmodelloaderregistry : texture " , <nl> + " # chest " : " entity / chest / normal " <nl> + } , <nl> + " model " : " forgedebugmodelloaderregistry : chest . b3d " <nl> + } , <nl> " variants " : { <nl> - " normal " : { " model " : " forgedebugmodelloaderregistry : untitled2 . b3d " } <nl> + " normal " : { <nl> + " dummy " : " " <nl> + } , <nl> + " inventory " : { <nl> + " dummy " : " " <nl> + } <nl> } <nl> } <nl> diff - - git a / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / chest . b3d b / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / chest . b3d <nl> new file mode 100644 <nl> index 0000000 . . b070d7a <nl> Binary files / dev / null and b / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / chest . b3d differ <nl> diff - - git a / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / untitled2 . b3d b / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / untitled2 . b3d <nl> index 14e9c4d . . 8f4bd09 100644 <nl> Binary files a / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / untitled2 . b3d and b / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / untitled2 . b3d differ

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java b / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java 
 index 189069c . . 3aed561 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java 
 + + + b / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java 
 @ @ - 3 , 6 + 3 , 8 @ @ package net . minecraftforge . client . model ; 
 import javax . vecmath . Matrix3f ; 
 import javax . vecmath . Matrix4f ; 
 import javax . vecmath . Quat4f ; 
 + import javax . vecmath . Tuple3f ; 
 + import javax . vecmath . Tuple4f ; 
 import javax . vecmath . Vector3f ; 
 import javax . vecmath . Vector4f ; 
 
 @ @ - 181 , 7 + 183 , 6 @ @ public class TRSRTransformation implements IModelState , ITransformation 
 { 
 Matrix4f res = new Matrix4f ( ) , t = new Matrix4f ( ) ; 
 res . setIdentity ( ) ; 
 - if ( translation ! = null ) res . setTranslation ( translation ) ; 
 if ( leftRot ! = null ) 
 { 
 t . set ( leftRot ) ; 
 @ @ - 200 , 6 + 201 , 7 @ @ public class TRSRTransformation implements IModelState , ITransformation 
 t . set ( rightRot ) ; 
 res . mul ( t ) ; 
 } 
 + if ( translation ! = null ) res . setTranslation ( translation ) ; 
 return res ; 
 } 
 
 @ @ - 221 , 7 + 223 , 8 @ @ public class TRSRTransformation implements IModelState , ITransformation 
 b . set ( m ) ; 
 b . mul ( t ) ; 
 
 - sortSingularValues ( b , v ) ; 
 + / / FIXME : this doesn ' t work correctly for some reason ; not crucial , so disabling for now ; investigate in the future . 
 + / / sortSingularValues ( b , v ) ; 
 
 Pair < Float , Float > p ; 
 
 @ @ - 281 , 7 + 284 , 7 @ @ public class TRSRTransformation implements IModelState , ITransformation 
 return f ; 
 } 
 
 - private static final float eps = 1e - 7f ; 
 + private static final float eps = 1e - 6f ; 
 private static final float g = 3f + 2f * ( float ) Math . sqrt ( 2 ) ; 
 private static final float cs = ( float ) Math . cos ( Math . PI / 8 ) ; 
 private static final float ss = ( float ) Math . sin ( Math . PI / 8 ) ; 
 @ @ - 365 , 50 + 368 , 59 @ @ public class TRSRTransformation implements IModelState , ITransformation 
 Quat4f qt = new Quat4f ( ) , ret = new Quat4f ( 0 , 0 , 0 , 1 ) ; 
 Pair < Float , Float > p ; 
 / / 01 
 - p = approxGivensQuat ( m . m00 , . 5f * ( m . m01 + m . m10 ) , m . m11 ) ; 
 - qt . set ( 0 , 0 , p . getLeft ( ) , p . getRight ( ) ) ; 
 - / / qt . normalize ( ) ; 
 - ret . mul ( qt ) ; 
 - / / t . set ( qt ) ; 
 - t . setIdentity ( ) ; 
 - t . m00 = qt . w * qt . w - qt . z * qt . z ; 
 - t . m11 = t . m00 ; 
 - t . m10 = 2 * qt . z * qt . w ; 
 - t . m01 = - t . m10 ; 
 - t . m22 = qt . w * qt . w + qt . z * qt . z ; 
 - m . mul ( m , t ) ; 
 - t . transpose ( ) ; 
 - m . mul ( t , m ) ; 
 + if ( m . m01 * m . m01 + m . m10 * m . m10 > eps ) 
 + { 
 + p = approxGivensQuat ( m . m00 , . 5f * ( m . m01 + m . m10 ) , m . m11 ) ; 
 + qt . set ( 0 , 0 , p . getLeft ( ) , p . getRight ( ) ) ; 
 + / / qt . normalize ( ) ; 
 + ret . mul ( qt ) ; 
 + / / t . set ( qt ) ; 
 + t . setIdentity ( ) ; 
 + t . m00 = qt . w * qt . w - qt . z * qt . z ; 
 + t . m11 = t . m00 ; 
 + t . m10 = 2 * qt . z * qt . w ; 
 + t . m01 = - t . m10 ; 
 + t . m22 = qt . w * qt . w + qt . z * qt . z ; 
 + m . mul ( m , t ) ; 
 + t . transpose ( ) ; 
 + m . mul ( t , m ) ; 
 + } 
 / / 02 
 - p = approxGivensQuat ( m . m00 , . 5f * ( m . m02 + m . m20 ) , m . m22 ) ; 
 - qt . set ( 0 , - p . getLeft ( ) , 0 , p . getRight ( ) ) ; 
 - / / qt . normalize ( ) ; 
 - ret . mul ( qt ) ; 
 - / / t . set ( qt ) ; 
 - t . setIdentity ( ) ; 
 - t . m00 = qt . w * qt . w - qt . y * qt . y ; 
 - t . m22 = t . m00 ; 
 - t . m20 = - 2 * qt . y * qt . w ; 
 - t . m02 = - t . m20 ; 
 - t . m11 = qt . w * qt . w + qt . y * qt . y ; 
 - m . mul ( m , t ) ; 
 - t . transpose ( ) ; 
 - m . mul ( t , m ) ; 
 + if ( m . m02 * m . m02 + m . m20 * m . m20 > eps ) 
 + { 
 + p = approxGivensQuat ( m . m00 , . 5f * ( m . m02 + m . m20 ) , m . m22 ) ; 
 + qt . set ( 0 , - p . getLeft ( ) , 0 , p . getRight ( ) ) ; 
 + / / qt . normalize ( ) ; 
 + ret . mul ( qt ) ; 
 + / / t . set ( qt ) ; 
 + t . setIdentity ( ) ; 
 + t . m00 = qt . w * qt . w - qt . y * qt . y ; 
 + t . m22 = t . m00 ; 
 + t . m20 = - 2 * qt . y * qt . w ; 
 + t . m02 = - t . m20 ; 
 + t . m11 = qt . w * qt . w + qt . y * qt . y ; 
 + m . mul ( m , t ) ; 
 + t . transpose ( ) ; 
 + m . mul ( t , m ) ; 
 + } 
 / / 12 
 - p = approxGivensQuat ( m . m11 , . 5f * ( m . m12 + m . m21 ) , m . m22 ) ; 
 - qt . set ( p . getLeft ( ) , 0 , 0 , p . getRight ( ) ) ; 
 - / / qt . normalize ( ) ; 
 - ret . mul ( qt ) ; 
 - / / t . set ( qt ) ; 
 - t . setIdentity ( ) ; 
 - t . m11 = qt . w * qt . w - qt . x * qt . x ; 
 - t . m22 = t . m11 ; 
 - t . m21 = 2 * qt . x * qt . w ; 
 - t . m12 = - t . m21 ; 
 - t . m00 = qt . w * qt . w + qt . x * qt . x ; 
 - m . mul ( m , t ) ; 
 - t . transpose ( ) ; 
 - m . mul ( t , m ) ; 
 + if ( m . m12 * m . m12 + m . m21 * m . m21 > eps ) 
 + { 
 + p = approxGivensQuat ( m . m11 , . 5f * ( m . m12 + m . m21 ) , m . m22 ) ; 
 + qt . set ( p . getLeft ( ) , 0 , 0 , p . getRight ( ) ) ; 
 + / / qt . normalize ( ) ; 
 + ret . mul ( qt ) ; 
 + / / t . set ( qt ) ; 
 + t . setIdentity ( ) ; 
 + t . m11 = qt . w * qt . w - qt . x * qt . x ; 
 + t . m22 = t . m11 ; 
 + t . m21 = 2 * qt . x * qt . w ; 
 + t . m12 = - t . m21 ; 
 + t . m00 = qt . w * qt . w + qt . x * qt . x ; 
 + m . mul ( m , t ) ; 
 + t . transpose ( ) ; 
 + m . mul ( t , m ) ; 
 + } 
 return ret ; 
 } 
 
 @ @ - 617 , 4 + 629 , 35 @ @ public class TRSRTransformation implements IModelState , ITransformation 
 r . m33 = m . m33 ; 
 return r ; 
 } 
 + 
 + public static Vector3f lerp ( Tuple3f from , Tuple3f to , float progress ) 
 + { 
 + Vector3f res = new Vector3f ( from ) ; 
 + res . interpolate ( from , to , progress ) ; 
 + return res ; 
 + } 
 + 
 + public static Vector4f lerp ( Tuple4f from , Tuple4f to , float progress ) 
 + { 
 + Vector4f res = new Vector4f ( from ) ; 
 + res . interpolate ( from , to , progress ) ; 
 + return res ; 
 + } 
 + 
 + public static Quat4f slerp ( Quat4f from , Quat4f to , float progress ) 
 + { 
 + Quat4f res = new Quat4f ( ) ; 
 + res . interpolate ( from , to , progress ) ; 
 + return res ; 
 + } 
 + 
 + public TRSRTransformation slerp ( TRSRTransformation that , float progress ) 
 + { 
 + return new TRSRTransformation ( 
 + lerp ( this . getTranslation ( ) , that . getTranslation ( ) , progress ) , 
 + slerp ( this . getLeftRot ( ) , that . getLeftRot ( ) , progress ) , 
 + lerp ( this . getScale ( ) , that . getScale ( ) , progress ) , 
 + slerp ( this . getRightRot ( ) , that . getRightRot ( ) , progress ) 
 + ) ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 index d75ab37 . . 5cfad73 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import net . minecraft . client . resources . IResourceManager ; 
 import net . minecraft . client . resources . model . IBakedModel ; 
 import net . minecraft . item . ItemStack ; 
 import net . minecraft . util . EnumFacing ; 
 + import net . minecraft . util . MathHelper ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . client . model . ICustomModelLoader ; 
 import net . minecraftforge . client . model . IFlexibleBakedModel ; 
 @ @ - 65 , 6 + 66 , 9 @ @ import com . google . common . cache . LoadingCache ; 
 import com . google . common . collect . Collections2 ; 
 import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . ImmutableMap ; 
 + import com . google . common . collect . ImmutableSet ; 
 + import com . google . gson . JsonElement ; 
 + import com . google . gson . JsonParser ; 
 
 / * 
 * Loader for Blitz3D models . 
 @ @ - 138 , 16 + 142 , 19 @ @ public class B3DLoader implements ICustomModelLoader 
 FMLLog . severe ( " No mesh named % s in model % s , skipping " , mesh , modelLocation ) ; 
 return ModelLoaderRegistry . getMissingModel ( ) ; 
 } 
 - return new Wrapper ( modelLocation , model . getTextures ( ) , model . getMeshes ( ) . get ( mesh ) ) ; 
 + return new ModelWrapper ( modelLocation , model , ImmutableSet . of ( mesh ) , 1 ) ; 
 } 
 if ( ! ( model . getRoot ( ) . getKind ( ) instanceof Mesh ) ) 
 { 
 - FMLLog . severe ( " No root mesh in model % s and no mesh name in location , skipping " , modelLocation ) ; 
 - return ModelLoaderRegistry . getMissingModel ( ) ; 
 + return new ModelWrapper ( modelLocation , model , ImmutableSet . < String > of ( ) , 1 ) ; 
 } 
 - return new Wrapper ( modelLocation , model . getTextures ( ) , ( Node < Mesh > ) model . getRoot ( ) ) ; 
 + return new ModelWrapper ( modelLocation , model , ImmutableSet . of ( ( ( Node < Mesh > ) model . getRoot ( ) ) . getName ( ) ) , 1 ) ; 
 } 
 
 + / * * 
 + * @ deprecated Use json or IModelCustomData . process 
 + * / 
 + @ Deprecated 
 public static class B3DMeshLocation extends ResourceLocation 
 { 
 public final String mesh ; 
 @ @ - 192 , 17 + 199 , 31 @ @ public class B3DLoader implements ICustomModelLoader 
 { 
 private final Animation animation ; 
 private final int frame ; 
 + private final int nextFrame ; 
 + private final float progress ; 
 private final IModelState parent ; 
 
 public B3DState ( Animation animation , int frame ) 
 { 
 - this ( animation , frame , null ) ; 
 + this ( animation , frame , frame , 0 ) ; 
 } 
 
 public B3DState ( Animation animation , int frame , IModelState parent ) 
 { 
 + this ( animation , frame , frame , 0 , parent ) ; 
 + } 
 + 
 + public B3DState ( Animation animation , int frame , int nextFrame , float progress ) 
 + { 
 + this ( animation , frame , nextFrame , progress , null ) ; 
 + } 
 + 
 + public B3DState ( Animation animation , int frame , int nextFrame , float progress , IModelState parent ) 
 + { 
 this . animation = animation ; 
 this . frame = frame ; 
 + this . nextFrame = nextFrame ; 
 + this . progress = MathHelper . clamp _ float ( progress , 0 , 1 ) ; 
 this . parent = getParent ( parent ) ; 
 } 
 
 @ @ - 223 , 17 + 244 , 47 @ @ public class B3DLoader implements ICustomModelLoader 
 return frame ; 
 } 
 
 + public int getNextFrame ( ) 
 + { 
 + return nextFrame ; 
 + } 
 + 
 + public float getProgress ( ) 
 + { 
 + return progress ; 
 + } 
 + 
 + public IModelState getParent ( ) 
 + { 
 + return parent ; 
 + } 
 + 
 public TRSRTransformation apply ( IModelPart part ) 
 { 
 if ( ! ( part instanceof PartWrapper < ? > ) ) 
 { 
 throw new IllegalArgumentException ( " B3DState can only be applied to b3d models " ) ; 
 } 
 + Node < ? > node = ( ( PartWrapper < ? > ) part ) . getNode ( ) ; 
 + TRSRTransformation nodeTransform ; 
 + if ( progress < 1e - 5 | | frame = = nextFrame ) 
 + { 
 + nodeTransform = getNodeMatrix ( node , frame ) ; 
 + } 
 + else if ( progress > 1 - 1e - 5 ) 
 + { 
 + nodeTransform = getNodeMatrix ( node , nextFrame ) ; 
 + } 
 + else 
 + { 
 + nodeTransform = getNodeMatrix ( node , frame ) ; 
 + nodeTransform = nodeTransform . slerp ( getNodeMatrix ( node , nextFrame ) , progress ) ; 
 + } 
 if ( parent ! = null ) 
 { 
 - return parent . apply ( part ) . compose ( getNodeMatrix ( ( ( PartWrapper < ? > ) part ) . getNode ( ) ) ) ; 
 + return parent . apply ( part ) . compose ( nodeTransform ) ; 
 } 
 - return getNodeMatrix ( ( ( PartWrapper < ? > ) part ) . getNode ( ) ) ; 
 + return nodeTransform ; 
 } 
 
 private static LoadingCache < Triple < Animation , Node < ? > , Integer > , TRSRTransformation > cache = CacheBuilder . newBuilder ( ) 
 @ @ - 252 , 6 + 303 , 11 @ @ public class B3DLoader implements ICustomModelLoader 
 return cache . getUnchecked ( Triple . < Animation , Node < ? > , Integer > of ( animation , node , frame ) ) ; 
 } 
 
 + public TRSRTransformation getNodeMatrix ( Node < ? > node , int frame ) 
 + { 
 + return cache . getUnchecked ( Triple . < Animation , Node < ? > , Integer > of ( animation , node , frame ) ) ; 
 + } 
 + 
 public static TRSRTransformation getNodeMatrix ( Animation animation , Node < ? > node , int frame ) 
 { 
 TRSRTransformation ret = TRSRTransformation . identity ( ) ; 
 @ @ - 326 , 20 + 382 , 36 @ @ public class B3DLoader implements ICustomModelLoader 
 } 
 } 
 
 + / * * 
 + * @ deprecated Use ModelWrapper , this will be removed in 1 . 9 
 + * / 
 + @ Deprecated 
 public static class Wrapper extends PartWrapper < Mesh > implements IRetexturableModel , IModelCustomData 
 { 
 private final ResourceLocation location ; 
 + private final ImmutableSet < String > meshes ; 
 private final ImmutableMap < String , ResourceLocation > textures ; 
 
 public Wrapper ( ResourceLocation location , List < Texture > textures , B3DModel . Node < Mesh > mesh ) 
 { 
 - this ( location , buildTextures ( textures ) , mesh ) ; 
 + this ( location , ImmutableSet . < String > of ( ) , buildTextures ( textures ) , mesh ) ; 
 } 
 
 public Wrapper ( ResourceLocation location , ImmutableMap < String , ResourceLocation > textures , B3DModel . Node < Mesh > mesh ) 
 { 
 + this ( location , ImmutableSet . < String > of ( ) , textures , mesh ) ; 
 + } 
 + 
 + public Wrapper ( ResourceLocation location , ImmutableSet < String > meshes , List < Texture > textures , B3DModel . Node < Mesh > mesh ) 
 + { 
 + this ( location , meshes , buildTextures ( textures ) , mesh ) ; 
 + } 
 + 
 + public Wrapper ( ResourceLocation location , ImmutableSet < String > meshes , ImmutableMap < String , ResourceLocation > textures , B3DModel . Node < Mesh > mesh ) 
 + { 
 super ( mesh ) ; 
 this . location = location ; 
 + this . meshes = meshes ; 
 this . textures = textures ; 
 } 
 
 @ @ - 398 , 7 + 470 , 7 @ @ public class B3DLoader implements ICustomModelLoader 
 } 
 } 
 builder . put ( " missingno " , missing ) ; 
 - return new BakedWrapper ( this , state , format , builder . build ( ) ) ; 
 + return new BakedWrapper ( getNode ( ) , state , format , meshes , builder . build ( ) ) ; 
 } 
 
 public B3DState getDefaultState ( ) 
 @ @ - 465 , 29 + 537 , 211 @ @ public class B3DLoader implements ICustomModelLoader 
 @ Override 
 public IModel process ( ImmutableMap < String , String > customData ) 
 { 
 - / / TODO keyframe 
 - return null ; 
 + return this ; 
 + } 
 + } 
 + public static class ModelWrapper implements IRetexturableModel , IModelCustomData 
 + { 
 + private final ResourceLocation modelLocation ; 
 + private final B3DModel model ; 
 + private final ImmutableSet < String > meshes ; 
 + private final ImmutableMap < String , ResourceLocation > textures ; 
 + private final int defaultKey ; 
 + 
 + public ModelWrapper ( ResourceLocation modelLocation , B3DModel model , ImmutableSet < String > meshes , int defaultKey ) 
 + { 
 + this ( modelLocation , model , meshes , defaultKey , buildTextures ( model . getTextures ( ) ) ) ; 
 + } 
 + 
 + public ModelWrapper ( ResourceLocation modelLocation , B3DModel model , ImmutableSet < String > meshes , int defaultKey , ImmutableMap < String , ResourceLocation > textures ) 
 + { 
 + this . modelLocation = modelLocation ; 
 + this . model = model ; 
 + this . meshes = meshes ; 
 + this . textures = textures ; 
 + this . defaultKey = defaultKey ; 
 + } 
 + 
 + private static ImmutableMap < String , ResourceLocation > buildTextures ( List < Texture > textures ) 
 + { 
 + ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; 
 + 
 + for ( Texture t : textures ) 
 + { 
 + String path = t . getPath ( ) ; 
 + String location = getLocation ( path ) ; 
 + if ( ! location . startsWith ( " # " ) ) location = " # " + location ; 
 + builder . put ( path , new ResourceLocation ( location ) ) ; 
 + } 
 + return builder . build ( ) ; 
 + } 
 + 
 + private static String getLocation ( String path ) 
 + { 
 + if ( path . endsWith ( " . png " ) ) path = path . substring ( 0 , path . length ( ) - " . png " . length ( ) ) ; 
 + return path ; 
 + } 
 + 
 + @ Override 
 + public Collection < ResourceLocation > getDependencies ( ) 
 + { 
 + return Collections . emptyList ( ) ; 
 + } 
 + 
 + @ Override 
 + public Collection < ResourceLocation > getTextures ( ) 
 + { 
 + return Collections2 . filter ( textures . values ( ) , new Predicate < ResourceLocation > ( ) 
 + { 
 + public boolean apply ( ResourceLocation loc ) 
 + { 
 + return ! loc . getResourcePath ( ) . startsWith ( " # " ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ Override 
 + public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 + { 
 + ImmutableMap . Builder < String , TextureAtlasSprite > builder = ImmutableMap . builder ( ) ; 
 + TextureAtlasSprite missing = bakedTextureGetter . apply ( new ResourceLocation ( " missingno " ) ) ; 
 + for ( Map . Entry < String , ResourceLocation > e : textures . entrySet ( ) ) 
 + { 
 + if ( e . getValue ( ) . getResourcePath ( ) . startsWith ( " # " ) ) 
 + { 
 + FMLLog . severe ( " unresolved texture ' % s ' for b3d model ' % s ' " , e . getValue ( ) . getResourcePath ( ) , modelLocation ) ; 
 + builder . put ( e . getKey ( ) , missing ) ; 
 + } 
 + else 
 + { 
 + builder . put ( e . getKey ( ) , bakedTextureGetter . apply ( e . getValue ( ) ) ) ; 
 + } 
 + } 
 + builder . put ( " missingno " , missing ) ; 
 + return new BakedWrapper ( model . getRoot ( ) , state , format , meshes , builder . build ( ) ) ; 
 + } 
 + 
 + @ Override 
 + public IModelState getDefaultState ( ) 
 + { 
 + return new B3DState ( model . getRoot ( ) . getAnimation ( ) , defaultKey , defaultKey , 0 ) ; 
 + } 
 + 
 + @ Override 
 + public IModel retexture ( ImmutableMap < String , String > textures ) 
 + { 
 + ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; 
 + for ( Map . Entry < String , ResourceLocation > e : this . textures . entrySet ( ) ) 
 + { 
 + String path = e . getKey ( ) ; 
 + String loc = getLocation ( path ) ; 
 + if ( textures . containsKey ( loc ) ) 
 + { 
 + String newLoc = textures . get ( loc ) ; 
 + if ( newLoc = = null ) newLoc = getLocation ( path ) ; 
 + builder . put ( e . getKey ( ) , new ResourceLocation ( newLoc ) ) ; 
 + } 
 + else 
 + { 
 + builder . put ( e ) ; 
 + } 
 + } 
 + return new ModelWrapper ( modelLocation , model , meshes , defaultKey , builder . build ( ) ) ; 
 + } 
 + 
 + @ Override 
 + public IModel process ( ImmutableMap < String , String > data ) 
 + { 
 + if ( data . containsKey ( " mesh " ) ) 
 + { 
 + JsonElement e = new JsonParser ( ) . parse ( data . get ( " mesh " ) ) ; 
 + if ( e . isJsonPrimitive ( ) & & e . getAsJsonPrimitive ( ) . isString ( ) ) 
 + { 
 + return new ModelWrapper ( modelLocation , model , ImmutableSet . of ( e . getAsString ( ) ) , defaultKey , textures ) ; 
 + } 
 + else if ( e . isJsonArray ( ) ) 
 + { 
 + ImmutableSet . Builder < String > builder = ImmutableSet . builder ( ) ; 
 + for ( JsonElement s : e . getAsJsonArray ( ) ) 
 + { 
 + if ( s . isJsonPrimitive ( ) & & s . getAsJsonPrimitive ( ) . isString ( ) ) 
 + { 
 + builder . add ( s . getAsString ( ) ) ; 
 + } 
 + else 
 + { 
 + FMLLog . severe ( " unknown mesh definition ' % s ' in array for b3d model ' % s ' " , s . toString ( ) , modelLocation ) ; 
 + return this ; 
 + } 
 + } 
 + return new ModelWrapper ( modelLocation , model , builder . build ( ) , defaultKey , textures ) ; 
 + } 
 + else 
 + { 
 + FMLLog . severe ( " unknown mesh definition ' % s ' for b3d model ' % s ' " , e . toString ( ) , modelLocation ) ; 
 + return this ; 
 + } 
 + } 
 + if ( data . containsKey ( " key " ) ) 
 + { 
 + JsonElement e = new JsonParser ( ) . parse ( data . get ( " key " ) ) ; 
 + if ( e . isJsonPrimitive ( ) & & e . getAsJsonPrimitive ( ) . isNumber ( ) ) 
 + { 
 + return new ModelWrapper ( modelLocation , model , meshes , e . getAsNumber ( ) . intValue ( ) , textures ) ; 
 + } 
 + else 
 + { 
 + FMLLog . severe ( " unknown keyframe definition ' % s ' for b3d model ' % s ' " , e . toString ( ) , modelLocation ) ; 
 + return this ; 
 + } 
 + } 
 + return this ; 
 } 
 } 
 
 private static class BakedWrapper implements IFlexibleBakedModel , ISmartBlockModel , ISmartItemModel , IPerspectiveAwareModel 
 { 
 - private final B3DLoader . Wrapper model ; 
 + private final Node < ? > node ; 
 private final IModelState state ; 
 private final VertexFormat format ; 
 + private final ImmutableSet < String > meshes ; 
 private final ImmutableMap < String , TextureAtlasSprite > textures ; 
 + private final LoadingCache < Integer , BakedWrapper > cache ; 
 
 private ImmutableList < BakedQuad > quads ; 
 
 - private static final int BYTES _ IN _ INT = Integer . SIZE / Byte . SIZE ; 
 - private static final int VERTICES _ IN _ QUAD = 4 ; 
 - 
 - public BakedWrapper ( B3DLoader . Wrapper model , IModelState state , VertexFormat format , ImmutableMap < String , TextureAtlasSprite > textures ) 
 + public BakedWrapper ( Node < ? > node , IModelState state , VertexFormat format , ImmutableSet < String > meshes , ImmutableMap < String , TextureAtlasSprite > textures ) 
 { 
 - this . model = model ; 
 + this ( node , state , format , meshes , textures , CacheBuilder . newBuilder ( ) 
 + . maximumSize ( 128 ) 
 + . expireAfterAccess ( 2 , TimeUnit . MINUTES ) 
 + . build ( new CacheLoader < Integer , BakedWrapper > ( ) 
 + { 
 + public BakedWrapper load ( Integer frame ) throws Exception 
 + { 
 + IModelState parent = state ; 
 + Animation newAnimation = null ; 
 + if ( parent instanceof B3DState ) 
 + { 
 + B3DState ps = ( B3DState ) parent ; 
 + parent = ps . getParent ( ) ; 
 + } 
 + if ( newAnimation = = null ) 
 + { 
 + newAnimation = node . getAnimation ( ) ; 
 + } 
 + return new BakedWrapper ( node , new B3DState ( newAnimation , frame , frame , 0 , parent ) , format , meshes , textures ) ; 
 + } 
 + } ) ) ; 
 + } 
 + public BakedWrapper ( Node < ? > node , IModelState state , VertexFormat format , ImmutableSet < String > meshes , ImmutableMap < String , TextureAtlasSprite > textures , LoadingCache < Integer , BakedWrapper > cache ) 
 + { 
 + this . node = node ; 
 this . state = state ; 
 this . format = format ; 
 + this . meshes = meshes ; 
 this . textures = textures ; 
 + this . cache = cache ; 
 } 
 
 public List < BakedQuad > getFaceQuads ( EnumFacing side ) 
 @ @ - 495 , 47 + 749 , 43 @ @ public class B3DLoader implements ICustomModelLoader 
 return Collections . emptyList ( ) ; 
 } 
 
 - @ SuppressWarnings ( " unchecked " ) 
 public List < BakedQuad > getGeneralQuads ( ) 
 { 
 if ( quads = = null ) 
 { 
 - Node < Mesh > mesh = model . getNode ( ) ; 
 ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; 
 - for ( Node < ? > child : mesh . getNodes ( ) . values ( ) ) 
 + for ( Node < ? > child : node . getNodes ( ) . values ( ) ) 
 { 
 - if ( child . getKind ( ) instanceof Mesh ) 
 - { 
 - Node < Mesh > childMesh = ( Node < Mesh > ) child ; 
 - builder . addAll ( new BakedWrapper ( new B3DLoader . Wrapper ( model . getLocation ( ) , model . getTextureMap ( ) , childMesh ) , state , format , textures ) . getGeneralQuads ( ) ) ; 
 - } 
 + builder . addAll ( new BakedWrapper ( child , state , format , meshes , textures ) . getGeneralQuads ( ) ) ; 
 } 
 - mesh . getKind ( ) . getWeightMap ( ) ; 
 - Collection < Face > faces = mesh . getKind ( ) . getFaces ( ) ; 
 - faces = mesh . getKind ( ) . bake ( new Function < Node < ? > , Matrix4f > ( ) 
 + if ( node . getKind ( ) instanceof Mesh & & meshes . contains ( node . getName ( ) ) ) 
 { 
 - / / gets transformation in global space 
 - public Matrix4f apply ( Node < ? > node ) 
 + Mesh mesh = ( Mesh ) node . getKind ( ) ; 
 + Collection < Face > faces = mesh . bake ( new Function < Node < ? > , Matrix4f > ( ) 
 + { 
 + / / gets transformation in global space 
 + public Matrix4f apply ( Node < ? > node ) 
 + { 
 + return state . apply ( PartWrapper . create ( node ) ) . getMatrix ( ) ; 
 + } 
 + } ) ; 
 + for ( Face f : faces ) 
 { 
 - return state . apply ( PartWrapper . create ( node ) ) . getMatrix ( ) ; 
 + UnpackedBakedQuad . Builder quadBuilder = new UnpackedBakedQuad . Builder ( format ) ; 
 + quadBuilder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; 
 + quadBuilder . setQuadColored ( ) ; 
 + List < Texture > textures = null ; 
 + if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; 
 + TextureAtlasSprite sprite ; 
 + if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; 
 + else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; 
 + else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; 
 + putVertexData ( quadBuilder , f . getV1 ( ) , f . getNormal ( ) , sprite ) ; 
 + putVertexData ( quadBuilder , f . getV2 ( ) , f . getNormal ( ) , sprite ) ; 
 + putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; 
 + putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; 
 + builder . add ( quadBuilder . build ( ) ) ; 
 } 
 - } ) ; 
 - for ( Face f : faces ) 
 - { 
 - UnpackedBakedQuad . Builder quadBuilder = new UnpackedBakedQuad . Builder ( format ) ; 
 - quadBuilder . setQuadOrientation ( EnumFacing . getFacingFromVector ( f . getNormal ( ) . x , f . getNormal ( ) . y , f . getNormal ( ) . z ) ) ; 
 - quadBuilder . setQuadColored ( ) ; 
 - List < Texture > textures = null ; 
 - if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; 
 - TextureAtlasSprite sprite ; 
 - if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; 
 - else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; 
 - else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; 
 - putVertexData ( quadBuilder , f . getV1 ( ) , f . getNormal ( ) , sprite ) ; 
 - putVertexData ( quadBuilder , f . getV2 ( ) , f . getNormal ( ) , sprite ) ; 
 - putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; 
 - putVertexData ( quadBuilder , f . getV3 ( ) , f . getNormal ( ) , sprite ) ; 
 - builder . add ( quadBuilder . build ( ) ) ; 
 } 
 quads = builder . build ( ) ; 
 } 
 @ @ - 632 , 24 + 882 , 30 @ @ public class B3DLoader implements ICustomModelLoader 
 B3DState s = exState . getValue ( B3DFrameProperty . instance ) ; 
 if ( s ! = null ) 
 { 
 - return getCachedModel ( s . getFrame ( ) ) ; 
 + / / return getCachedModel ( s . getFrame ( ) ) ; 
 + IModelState parent = this . state ; 
 + Animation newAnimation = s . getAnimation ( ) ; 
 + if ( parent instanceof B3DState ) 
 + { 
 + B3DState ps = ( B3DState ) parent ; 
 + parent = ps . getParent ( ) ; 
 + } 
 + if ( newAnimation = = null ) 
 + { 
 + newAnimation = node . getAnimation ( ) ; 
 + } 
 + if ( s . getFrame ( ) = = s . getNextFrame ( ) ) 
 + { 
 + return cache . getUnchecked ( s . getFrame ( ) ) ; 
 + } 
 + B3DState newState = new B3DState ( newAnimation , s . getFrame ( ) , s . getNextFrame ( ) , s . getProgress ( ) , parent ) ; 
 + return new BakedWrapper ( node , newState , format , meshes , textures ) ; 
 } 
 } 
 } 
 return this ; 
 } 
 
 - private final Map < Integer , BakedWrapper > cache = new HashMap < Integer , BakedWrapper > ( ) ; 
 - 
 - public BakedWrapper getCachedModel ( int frame ) 
 - { 
 - if ( ! cache . containsKey ( frame ) ) 
 - { 
 - cache . put ( frame , new BakedWrapper ( model , new B3DState ( model . getNode ( ) . getAnimation ( ) , frame , state ) , format , textures ) ) ; 
 - } 
 - return cache . get ( frame ) ; 
 - } 
 - 
 public VertexFormat getFormat ( ) 
 { 
 return format ; 
 @ @ - 665 , 7 + 921 , 7 @ @ public class B3DLoader implements ICustomModelLoader 
 { 
 if ( state instanceof IPerspectiveState ) 
 { 
 - return Pair . of ( ( IBakedModel ) this , TRSRTransformation . blockCornerToCenter ( ( ( IPerspectiveState ) state ) . forPerspective ( cameraTransformType ) . apply ( model ) ) . getMatrix ( ) ) ; 
 + return Pair . of ( ( IBakedModel ) this , TRSRTransformation . blockCornerToCenter ( ( ( IPerspectiveState ) state ) . forPerspective ( cameraTransformType ) . apply ( PartWrapper . create ( node ) ) ) . getMatrix ( ) ) ; 
 } 
 return Pair . of ( ( IBakedModel ) this , null ) ; 
 } 
 diff - - git a / src / test / java / net / minecraftforge / debug / ModelAnimationDebug . java b / src / test / java / net / minecraftforge / debug / ModelAnimationDebug . java 
 new file mode 100644 
 index 0000000 . . 48b8ec2 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / debug / ModelAnimationDebug . java 
 @ @ - 0 , 0 + 1 , 285 @ @ 
 + package net . minecraftforge . debug ; 
 + 
 + import net . minecraft . block . Block ; 
 + import net . minecraft . block . BlockPistonBase ; 
 + import net . minecraft . block . material . Material ; 
 + import net . minecraft . block . properties . IProperty ; 
 + import net . minecraft . block . properties . PropertyDirection ; 
 + import net . minecraft . block . state . IBlockState ; 
 + import net . minecraft . client . Minecraft ; 
 + import net . minecraft . client . renderer . BlockRendererDispatcher ; 
 + import net . minecraft . client . renderer . GlStateManager ; 
 + import net . minecraft . client . renderer . RenderHelper ; 
 + import net . minecraft . client . renderer . Tessellator ; 
 + import net . minecraft . client . renderer . WorldRenderer ; 
 + import net . minecraft . client . renderer . texture . TextureMap ; 
 + import net . minecraft . client . renderer . tileentity . TileEntitySpecialRenderer ; 
 + import net . minecraft . client . renderer . vertex . DefaultVertexFormats ; 
 + import net . minecraft . client . resources . model . IBakedModel ; 
 + import net . minecraft . client . resources . model . ModelResourceLocation ; 
 + import net . minecraft . creativetab . CreativeTabs ; 
 + import net . minecraft . entity . EntityLivingBase ; 
 + import net . minecraft . entity . player . EntityPlayer ; 
 + import net . minecraft . item . Item ; 
 + import net . minecraft . tileentity . TileEntity ; 
 + import net . minecraft . util . BlockPos ; 
 + import net . minecraft . util . EnumFacing ; 
 + import net . minecraft . util . ITickable ; 
 + import net . minecraft . world . World ; 
 + import net . minecraftforge . client . model . ISmartBlockModel ; 
 + import net . minecraftforge . client . model . ModelLoader ; 
 + import net . minecraftforge . client . model . b3d . B3DLoader ; 
 + import net . minecraftforge . client . model . b3d . B3DLoader . B3DFrameProperty ; 
 + import net . minecraftforge . client . model . b3d . B3DLoader . B3DState ; 
 + import net . minecraftforge . common . property . ExtendedBlockState ; 
 + import net . minecraftforge . common . property . IExtendedBlockState ; 
 + import net . minecraftforge . common . property . IUnlistedProperty ; 
 + import net . minecraftforge . fml . client . registry . ClientRegistry ; 
 + import net . minecraftforge . fml . common . Mod ; 
 + import net . minecraftforge . fml . common . Mod . EventHandler ; 
 + import net . minecraftforge . fml . common . SidedProxy ; 
 + import net . minecraftforge . fml . common . event . FMLInitializationEvent ; 
 + import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 + import net . minecraftforge . fml . common . registry . GameRegistry ; 
 + 
 + import org . lwjgl . opengl . GL11 ; 
 + 
 + @ Mod ( modid = ModelAnimationDebug . MODID , version = ModelAnimationDebug . VERSION ) 
 + public class ModelAnimationDebug 
 + { 
 + public static final String MODID = " forgedebugmodelanimation " ; 
 + public static final String VERSION = " 0 . 0 " ; 
 + 
 + public static String blockName = " test _ animation _ block " ; 
 + public static final PropertyDirection FACING = PropertyDirection . create ( " facing " ) ; 
 + 
 + @ SidedProxy ( serverSide = " net . minecraftforge . debug . ModelAnimationDebug $ CommonProxy " , clientSide = " net . minecraftforge . debug . ModelAnimationDebug $ ClientProxy " ) 
 + public static CommonProxy proxy ; 
 + 
 + public static class CommonProxy 
 + { 
 + public void preInit ( FMLPreInitializationEvent event ) 
 + { 
 + B3DLoader . instance . addDomain ( MODID ) ; 
 + GameRegistry . registerBlock ( new Block ( Material . wood ) 
 + { 
 + { 
 + setCreativeTab ( CreativeTabs . tabBlock ) ; 
 + setUnlocalizedName ( MODID + " . " + blockName ) ; 
 + } 
 + 
 + @ Override 
 + public ExtendedBlockState createBlockState ( ) 
 + { 
 + return new ExtendedBlockState ( this , new IProperty [ ] { FACING } , new IUnlistedProperty [ ] { B3DFrameProperty . instance } ) ; 
 + } 
 + 
 + @ Override 
 + public int getRenderType ( ) { return - 1 ; } 
 + 
 + @ Override 
 + public boolean isOpaqueCube ( ) { return false ; } 
 + 
 + @ Override 
 + public boolean isFullCube ( ) { return false ; } 
 + 
 + @ Override 
 + public IBlockState onBlockPlaced ( World world , BlockPos pos , EnumFacing facing , float hitX , float hitY , float hitZ , int meta , EntityLivingBase placer ) 
 + { 
 + return this . getDefaultState ( ) . withProperty ( FACING , BlockPistonBase . getFacingFromEntity ( world , pos , placer ) ) ; 
 + } 
 + 
 + @ Override 
 + public IBlockState getStateFromMeta ( int meta ) { 
 + return getDefaultState ( ) . withProperty ( FACING , EnumFacing . getFront ( meta ) ) ; 
 + } 
 + 
 + @ Override 
 + public int getMetaFromState ( IBlockState state ) { 
 + return ( ( EnumFacing ) state . getValue ( FACING ) ) . getIndex ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean hasTileEntity ( IBlockState state ) { 
 + return true ; 
 + } 
 + 
 + @ Override 
 + public TileEntity createTileEntity ( World world , IBlockState state ) { 
 + return new Chest ( state ) ; 
 + } 
 + 
 + / * @ Override 
 + public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) { 
 + TileEntity te = world . getTileEntity ( pos ) ; 
 + if ( te instanceof Chest & & state instanceof IExtendedBlockState ) 
 + { 
 + return ( ( Chest ) te ) . getState ( ( IExtendedBlockState ) state ) ; 
 + } 
 + return super . getExtendedState ( state , world , pos ) ; 
 + } * / 
 + 
 + @ Override 
 + public boolean onBlockActivated ( World world , BlockPos pos , IBlockState state , EntityPlayer player , EnumFacing side , float hitX , float hitY , float hitZ ) 
 + { 
 + if ( world . isRemote ) 
 + { 
 + TileEntity te = world . getTileEntity ( pos ) ; 
 + if ( te instanceof Chest ) 
 + { 
 + ( ( Chest ) te ) . click ( ) ; 
 + } 
 + } 
 + return false ; 
 + } 
 + } , blockName ) ; 
 + } 
 + 
 + public void init ( FMLInitializationEvent event ) { } 
 + } 
 + 
 + public static class ClientProxy extends CommonProxy 
 + { 
 + @ Override 
 + public void preInit ( FMLPreInitializationEvent event ) 
 + { 
 + super . preInit ( event ) ; 
 + ModelLoader . setCustomModelResourceLocation ( Item . getItemFromBlock ( GameRegistry . findBlock ( MODID , blockName ) ) , 0 , new ModelResourceLocation ( MODID . toLowerCase ( ) + " : " + blockName , " inventory " ) ) ; 
 + } 
 + 
 + @ Override 
 + public void init ( FMLInitializationEvent event ) 
 + { 
 + super . init ( event ) ; 
 + ClientRegistry . bindTileEntitySpecialRenderer ( Chest . class , ChestRenderer . instance ) ; 
 + } 
 + } 
 + 
 + @ EventHandler 
 + public void preInit ( FMLPreInitializationEvent event ) { proxy . preInit ( event ) ; } 
 + 
 + @ EventHandler 
 + public void init ( FMLInitializationEvent event ) { proxy . init ( event ) ; } 
 + 
 + private static class Chest extends TileEntity implements ITickable 
 + { 
 + private final int minFrame = 1 ; 
 + private final int maxFrame = 10 ; 
 + private int tick = minFrame ; 
 + private boolean opening = false ; 
 + private boolean closing = false ; 
 + 
 + public Chest ( IBlockState state ) { 
 + } 
 + 
 + / * public IExtendedBlockState getState ( IExtendedBlockState state ) { 
 + return state . withProperty ( B3DFrameProperty . instance , curState ) ; 
 + } * / 
 + 
 + public void click ( ) 
 + { 
 + if ( opening | | tick = = maxFrame ) 
 + { 
 + opening = false ; 
 + closing = true ; 
 + return ; 
 + } 
 + if ( closing | | tick = = minFrame ) 
 + { 
 + closing = false ; 
 + opening = true ; 
 + return ; 
 + } 
 + opening = true ; 
 + } 
 + 
 + @ Override 
 + public void update ( ) 
 + { 
 + if ( opening ) 
 + { 
 + tick + + ; 
 + if ( tick > = maxFrame ) 
 + { 
 + tick = maxFrame ; 
 + opening = false ; 
 + } 
 + } 
 + if ( closing ) 
 + { 
 + tick - - ; 
 + if ( tick < = minFrame ) 
 + { 
 + tick = minFrame ; 
 + closing = false ; 
 + } 
 + } 
 + } 
 + 
 + public int getCurFrame ( ) 
 + { 
 + return tick ; 
 + } 
 + 
 + public int getNextFrame ( ) 
 + { 
 + if ( opening ) return Math . min ( tick + 1 , maxFrame ) ; 
 + if ( closing ) return Math . max ( tick - 1 , minFrame ) ; 
 + return tick ; 
 + } 
 + } 
 + 
 + private static class ChestRenderer extends TileEntitySpecialRenderer < Chest > 
 + { 
 + public static ChestRenderer instance = new ChestRenderer ( ) ; 
 + private ChestRenderer ( ) { } 
 + 
 + private final BlockRendererDispatcher blockRenderer = Minecraft . getMinecraft ( ) . getBlockRendererDispatcher ( ) ; 
 + 
 + public void renderTileEntityAt ( Chest te , double x , double y , double z , float partialTick , int breakStage ) 
 + { 
 + IBlockState state = te . getWorld ( ) . getBlockState ( te . getPos ( ) ) ; 
 + IBakedModel model = this . blockRenderer . getModelFromBlockState ( state , te . getWorld ( ) , te . getPos ( ) ) ; 
 + if ( state instanceof IExtendedBlockState ) 
 + { 
 + IExtendedBlockState exState = ( IExtendedBlockState ) state ; 
 + if ( exState . getUnlistedNames ( ) . contains ( B3DFrameProperty . instance ) ) 
 + { 
 + exState = exState . withProperty ( B3DFrameProperty . instance , new B3DState ( null , te . getCurFrame ( ) , te . getNextFrame ( ) , partialTick ) ) ; 
 + if ( model instanceof ISmartBlockModel ) 
 + { 
 + model = ( ( ISmartBlockModel ) model ) . handleBlockState ( exState ) ; 
 + } 
 + } 
 + } 
 + 
 + Tessellator tessellator = Tessellator . getInstance ( ) ; 
 + WorldRenderer worldrenderer = tessellator . getWorldRenderer ( ) ; 
 + this . bindTexture ( TextureMap . locationBlocksTexture ) ; 
 + RenderHelper . disableStandardItemLighting ( ) ; 
 + GlStateManager . blendFunc ( GL11 . GL _ SRC _ ALPHA , GL11 . GL _ ONE _ MINUS _ SRC _ ALPHA ) ; 
 + GlStateManager . enableBlend ( ) ; 
 + GlStateManager . disableCull ( ) ; 
 + 
 + if ( Minecraft . isAmbientOcclusionEnabled ( ) ) 
 + { 
 + GlStateManager . shadeModel ( GL11 . GL _ SMOOTH ) ; 
 + } 
 + else 
 + { 
 + GlStateManager . shadeModel ( GL11 . GL _ FLAT ) ; 
 + } 
 + 
 + worldrenderer . func _ 181668 _ a ( 7 , DefaultVertexFormats . BLOCK ) ; 
 + worldrenderer . setTranslation ( x - te . getPos ( ) . getX ( ) , y - te . getPos ( ) . getY ( ) , z - te . getPos ( ) . getZ ( ) ) ; 
 + 
 + this . blockRenderer . getBlockModelRenderer ( ) . renderModel ( te . getWorld ( ) , model , state , te . getPos ( ) , worldrenderer , false ) ; 
 + 
 + worldrenderer . setTranslation ( 0 , 0 , 0 ) ; 
 + tessellator . draw ( ) ; 
 + 
 + RenderHelper . enableStandardItemLighting ( ) ; 
 + } 
 + } 
 + } 
 + 
 diff - - git a / src / test / resources / assets / forgedebugmodelanimation / blockstates / test _ animation _ block . json b / src / test / resources / assets / forgedebugmodelanimation / blockstates / test _ animation _ block . json 
 new file mode 100644 
 index 0000000 . . b12b091 
 - - - / dev / null 
 + + + b / src / test / resources / assets / forgedebugmodelanimation / blockstates / test _ animation _ block . json 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + { 
 + " forge _ marker " : 1 , 
 + " defaults " : { 
 + " textures " : { 
 + " # chest " : " entity / chest / normal " 
 + } , 
 + " model " : " forgedebugmodelloaderregistry : chest . b3d " , 
 + " custom " : { 
 + " mesh " : [ " Cube . 001 " ] 
 + } 
 + } , 
 + " variants " : { 
 + " normal " : [ { } ] , 
 + " inventory " : [ { 
 + " transform " : " forge : default - block " 
 + } ] , 
 + " facing " : { 
 + " down " : { " transform " : { " rotation " : { " x " : 90 } } } , 
 + " up " : { " transform " : { " rotation " : { " x " : 270 } } } , 
 + " north " : { " transform " : { " rotation " : { " y " : 180 } } } , 
 + " south " : { " transform " : " identity " } , 
 + " west " : { " transform " : { " rotation " : { " y " : 90 } } } , 
 + " east " : { " transform " : { " rotation " : { " y " : 270 } } } 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 index ca6ab30 . . 46f1c46 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / b3d / B3DLoader . java 
 @ @ - 30 , 8 + 30 , 10 @ @ import net . minecraftforge . client . model . IColoredBakedQuad . ColoredBakedQuad ; 
 import net . minecraftforge . client . model . ICustomModelLoader ; 
 import net . minecraftforge . client . model . IFlexibleBakedModel ; 
 import net . minecraftforge . client . model . IModel ; 
 + import net . minecraftforge . client . model . IModelCustomData ; 
 import net . minecraftforge . client . model . IModelPart ; 
 import net . minecraftforge . client . model . IModelState ; 
 + import net . minecraftforge . client . model . IRetexturableModel ; 
 import net . minecraftforge . client . model . ISmartBlockModel ; 
 import net . minecraftforge . client . model . ISmartItemModel ; 
 import net . minecraftforge . client . model . ModelLoader ; 
 @ @ - 56 , 11 + 58 , 14 @ @ import org . apache . logging . log4j . Level ; 
 import org . lwjgl . BufferUtils ; 
 
 import com . google . common . base . Function ; 
 + import com . google . common . base . Predicate ; 
 import com . google . common . cache . CacheBuilder ; 
 import com . google . common . cache . CacheLoader ; 
 import com . google . common . cache . LoadingCache ; 
 + import com . google . common . collect . Collections2 ; 
 import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . ImmutableMap ; 
 + import com . google . common . collect . Maps ; 
 import com . google . common . collect . Multimap ; 
 
 / * 
 @ @ - 238 , 24 + 243 , 28 @ @ public class B3DLoader implements ICustomModelLoader 
 public static TRSRTransformation getNodeMatrix ( Animation animation , Node < ? > node , int frame ) 
 { 
 TRSRTransformation ret = TRSRTransformation . identity ( ) ; 
 - if ( node . getParent ( ) ! = null ) 
 - { 
 - TRSRTransformation pm = cache . getUnchecked ( Triple . < Animation , Node < ? > , Integer > of ( animation , node . getParent ( ) , frame ) ) ; 
 - ret = ret . compose ( pm ) ; 
 - } 
 Key key = null ; 
 if ( animation ! = null ) key = animation . getKeys ( ) . get ( frame , node ) ; 
 else if ( key = = null & & node . getAnimation ( ) ! = null & & node . getAnimation ( ) ! = animation ) key = node . getAnimation ( ) . getKeys ( ) . get ( frame , node ) ; 
 - if ( key = = null ) 
 - { 
 - FMLLog . severe ( " invalid key index : " + frame ) ; 
 - } 
 - else 
 + if ( key ! = null ) 
 { 
 + Node < ? > parent = node . getParent ( ) ; 
 + if ( parent ! = null ) 
 + { 
 + TRSRTransformation pm = cache . getUnchecked ( Triple . < Animation , Node < ? > , Integer > of ( animation , node . getParent ( ) , frame ) ) ; 
 + ret = ret . compose ( pm ) ; 
 + ret = ret . compose ( new TRSRTransformation ( parent . getPos ( ) , parent . getRot ( ) , parent . getScale ( ) , null ) ) ; 
 + } 
 ret = ret . compose ( new TRSRTransformation ( key . getPos ( ) , key . getRot ( ) , key . getScale ( ) , null ) ) ; 
 Matrix4f rm = new TRSRTransformation ( node . getPos ( ) , node . getRot ( ) , node . getScale ( ) , null ) . getMatrix ( ) ; 
 rm . invert ( ) ; 
 ret = ret . compose ( new TRSRTransformation ( rm ) ) ; 
 + if ( parent ! = null ) 
 + { 
 + rm = new TRSRTransformation ( parent . getPos ( ) , parent . getRot ( ) , parent . getScale ( ) , null ) . getMatrix ( ) ; 
 + rm . invert ( ) ; 
 + ret = ret . compose ( new TRSRTransformation ( rm ) ) ; 
 + } 
 } 
 return ret ; 
 } 
 @ @ - 305 , 14 + 314 , 14 @ @ public class B3DLoader implements ICustomModelLoader 
 } 
 } 
 
 - public static class Wrapper extends PartWrapper < Mesh > implements IModel 
 + public static class Wrapper extends PartWrapper < Mesh > implements IRetexturableModel , IModelCustomData 
 { 
 private final ResourceLocation location ; 
 private final ImmutableMap < String , ResourceLocation > textures ; 
 
 public Wrapper ( ResourceLocation location , List < Texture > textures , B3DModel . Node < Mesh > mesh ) 
 { 
 - this ( location , buildTextures ( location , textures ) , mesh ) ; 
 + this ( location , buildTextures ( textures ) , mesh ) ; 
 } 
 
 public Wrapper ( ResourceLocation location , ImmutableMap < String , ResourceLocation > textures , B3DModel . Node < Mesh > mesh ) 
 @ @ - 322 , 19 + 331 , 24 @ @ public class B3DLoader implements ICustomModelLoader 
 this . textures = textures ; 
 } 
 
 - private static ImmutableMap < String , ResourceLocation > buildTextures ( ResourceLocation location , List < Texture > textures ) 
 + private static ImmutableMap < String , ResourceLocation > buildTextures ( List < Texture > textures ) 
 { 
 ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; 
 
 for ( Texture t : textures ) 
 { 
 String path = t . getPath ( ) ; 
 - if ( path . endsWith ( " . png " ) ) path = path . substring ( 0 , path . length ( ) - " . png " . length ( ) ) ; 
 - builder . put ( t . getPath ( ) , new ResourceLocation ( location . getResourceDomain ( ) , path ) ) ; 
 + builder . put ( path , new ResourceLocation ( getLocation ( path ) ) ) ; 
 } 
 return builder . build ( ) ; 
 } 
 
 + private static String getLocation ( String path ) 
 + { 
 + if ( path . endsWith ( " . png " ) ) path = path . substring ( 0 , path . length ( ) - " . png " . length ( ) ) ; 
 + return path ; 
 + } 
 + 
 public Collection < ResourceLocation > getDependencies ( ) 
 { 
 / / no dependencies for in - file models 
 @ @ - 344 , 17 + 358 , 32 @ @ public class B3DLoader implements ICustomModelLoader 
 
 public Collection < ResourceLocation > getTextures ( ) 
 { 
 - return textures . values ( ) ; 
 + return Collections2 . filter ( textures . values ( ) , new Predicate < ResourceLocation > ( ) 
 + { 
 + public boolean apply ( ResourceLocation loc ) 
 + { 
 + return ! loc . getResourcePath ( ) . startsWith ( " # " ) ; 
 + } 
 + } ) ; 
 } 
 
 public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 { 
 ImmutableMap . Builder < String , TextureAtlasSprite > builder = ImmutableMap . builder ( ) ; 
 - for ( String path : textures . keySet ( ) ) 
 + TextureAtlasSprite missing = bakedTextureGetter . apply ( new ResourceLocation ( " missingno " ) ) ; 
 + for ( Map . Entry < String , ResourceLocation > e : textures . entrySet ( ) ) 
 { 
 - builder . put ( path , bakedTextureGetter . apply ( textures . get ( path ) ) ) ; 
 + if ( e . getValue ( ) . getResourcePath ( ) . startsWith ( " # " ) ) 
 + { 
 + FMLLog . severe ( " unresolved texture ' % s ' for b3d model ' % s ' " , e . getValue ( ) . getResourcePath ( ) , location ) ; 
 + builder . put ( e . getKey ( ) , missing ) ; 
 + } 
 + else 
 + { 
 + builder . put ( e . getKey ( ) , bakedTextureGetter . apply ( e . getValue ( ) ) ) ; 
 + } 
 } 
 - builder . put ( " missingno " , bakedTextureGetter . apply ( new ResourceLocation ( " missingno " ) ) ) ; 
 + builder . put ( " missingno " , missing ) ; 
 return new BakedWrapper ( this , state , format , builder . build ( ) ) ; 
 } 
 
 @ @ - 396 , 6 + 425 , 35 @ @ public class B3DLoader implements ICustomModelLoader 
 else if ( ! location . equals ( other . location ) ) return false ; 
 return true ; 
 } 
 + 
 + @ Override 
 + public IModel retexture ( ImmutableMap < String , String > textures ) 
 + { 
 + ImmutableMap . Builder < String , ResourceLocation > builder = ImmutableMap . builder ( ) ; 
 + for ( Map . Entry < String , ResourceLocation > e : this . textures . entrySet ( ) ) 
 + { 
 + String path = e . getKey ( ) ; 
 + String loc = getLocation ( path ) ; 
 + if ( textures . containsKey ( loc ) ) 
 + { 
 + String newLoc = textures . get ( loc ) ; 
 + if ( newLoc = = null ) newLoc = getLocation ( path ) ; 
 + builder . put ( e . getKey ( ) , new ResourceLocation ( newLoc ) ) ; 
 + } 
 + else 
 + { 
 + builder . put ( e ) ; 
 + } 
 + } 
 + return new Wrapper ( location , builder . build ( ) , getNode ( ) ) ; 
 + } 
 + 
 + @ Override 
 + public IModel process ( ImmutableMap < String , String > customData ) 
 + { 
 + / / TODO keyframe 
 + return null ; 
 + } 
 } 
 
 private static class BakedWrapper implements IFlexibleBakedModel , ISmartBlockModel , ISmartItemModel 
 @ @ - 454 , 9 + 512 , 10 @ @ public class B3DLoader implements ICustomModelLoader 
 for ( Face f : faces ) 
 { 
 buf . clear ( ) ; 
 - List < Texture > textures = f . getBrush ( ) . getTextures ( ) ; 
 + List < Texture > textures = null ; 
 + if ( f . getBrush ( ) ! = null ) textures = f . getBrush ( ) . getTextures ( ) ; 
 TextureAtlasSprite sprite ; 
 - if ( textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; 
 + if ( textures = = null | | textures . isEmpty ( ) ) sprite = this . textures . get ( " missingno " ) ; 
 else if ( textures . get ( 0 ) = = B3DModel . Texture . White ) sprite = ModelLoader . White . instance ; 
 else sprite = this . textures . get ( textures . get ( 0 ) . getPath ( ) ) ; 
 putVertexData ( f . getV1 ( ) , sprite ) ; 
 diff - - git a / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java b / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java 
 index 3fe304b . . 2358b93 100644 
 - - - a / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java 
 + + + b / src / test / java / net / minecraftforge / debug / ModelLoaderRegistryDebug . java 
 @ @ - 64 , 14 + 64 , 9 @ @ public class ModelLoaderRegistryDebug 
 
 private void clientPreInit ( ) 
 { 
 - / / ModelLoaderRegistry . registerLoader ( DummyModelLoader . instance ) ; 
 B3DLoader . instance . addDomain ( MODID . toLowerCase ( ) ) ; 
 - / / ModelBakery . addVariantName ( Item . getItemFromBlock ( CustomModelBlock . instance ) , " forgedebug : dummymodel " ) ; 
 - String modelLocation = MODID . toLowerCase ( ) + " : untitled2 . b3d " ; 
 - ModelBakery . addVariantName ( Item . getItemFromBlock ( CustomModelBlock . instance ) , modelLocation ) ; 
 Item item = Item . getItemFromBlock ( CustomModelBlock . instance ) ; 
 - ModelLoader . setCustomModelResourceLocation ( item , 0 , new ModelResourceLocation ( modelLocation , " inventory " ) ) ; 
 - / / ModelLoader . setCustomModelResourceLocation ( item , 0 , new ModelResourceLocation ( " forgedebug : dummymodel " , " inventory " ) ) ; 
 + ModelLoader . setCustomModelResourceLocation ( item , 0 , new ModelResourceLocation ( MODID . toLowerCase ( ) + " : " + CustomModelBlock . name , " inventory " ) ) ; 
 } 
 
 public static class CustomModelBlock extends Block 
 @ @ - 100 , 9 + 95 , 7 @ @ public class ModelLoaderRegistryDebug 
 @ Override 
 public IBlockState getExtendedState ( IBlockState state , IBlockAccess world , BlockPos pos ) 
 { 
 - IModel model = ModelLoaderRegistry . getModel ( new ResourceLocation ( MODID . toLowerCase ( ) , " block / untitled2 . b3d " ) ) ; 
 - B3DLoader . B3DState defaultState = ( ( B3DLoader . Wrapper ) model ) . getDefaultState ( ) ; 
 - B3DLoader . B3DState newState = new B3DLoader . B3DState ( defaultState . getAnimation ( ) , counter ) ; 
 + B3DLoader . B3DState newState = new B3DLoader . B3DState ( null , counter ) ; 
 return ( ( IExtendedBlockState ) this . state . getBaseState ( ) ) . withProperty ( B3DLoader . B3DFrameProperty . instance , newState ) ; 
 } 
 
 @ @ - 120 , 106 + 113 , 4 @ @ public class ModelLoaderRegistryDebug 
 return false ; 
 } 
 } 
 - 
 - public static class DummyModelLoader implements ICustomModelLoader 
 - { 
 - public static final DummyModelLoader instance = new DummyModelLoader ( ) ; 
 - public static final ResourceLocation dummyTexture = new ResourceLocation ( " minecraft : blocks / dirt " ) ; 
 - 
 - public boolean accepts ( ResourceLocation modelLocation ) 
 - { 
 - return modelLocation . getResourceDomain ( ) . equals ( " forgedebug " ) & & modelLocation . getResourcePath ( ) . contains ( " dummymodel " ) ; 
 - } 
 - 
 - public IModel loadModel ( ResourceLocation model ) 
 - { 
 - return DummyModel . instance ; 
 - } 
 - 
 - public static enum DummyModel implements IModel 
 - { 
 - instance ; 
 - 
 - public Collection < ResourceLocation > getDependencies ( ) 
 - { 
 - return Collections . emptyList ( ) ; 
 - } 
 - 
 - public Collection < ResourceLocation > getTextures ( ) 
 - { 
 - return Collections . singletonList ( dummyTexture ) ; 
 - } 
 - 
 - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > textures ) 
 - { 
 - return new DummyBakedModel ( textures . apply ( dummyTexture ) ) ; 
 - } 
 - 
 - public IModelState getDefaultState ( ) 
 - { 
 - return ModelRotation . X0 _ Y0 ; 
 - } 
 - } 
 - 
 - public static class DummyBakedModel implements IFlexibleBakedModel 
 - { 
 - private final TextureAtlasSprite texture ; 
 - 
 - public DummyBakedModel ( TextureAtlasSprite texture ) 
 - { 
 - this . texture = texture ; 
 - } 
 - 
 - public List < BakedQuad > getFaceQuads ( EnumFacing side ) 
 - { 
 - return Collections . emptyList ( ) ; 
 - } 
 - 
 - private int [ ] vertexToInts ( float x , float y , float z , int color , float u , float v ) 
 - { 
 - return new int [ ] { 
 - Float . floatToRawIntBits ( x ) , 
 - Float . floatToRawIntBits ( y ) , 
 - Float . floatToRawIntBits ( z ) , 
 - color , 
 - Float . floatToRawIntBits ( texture . getInterpolatedU ( u ) ) , 
 - Float . floatToRawIntBits ( texture . getInterpolatedV ( v ) ) , 
 - 0 
 - } ; 
 - } 
 - 
 - public List < BakedQuad > getGeneralQuads ( ) 
 - { 
 - List < BakedQuad > ret = new ArrayList < BakedQuad > ( ) ; 
 - / / 1 half - way rotated quad looking UP 
 - ret . add ( new BakedQuad ( Ints . concat ( 
 - vertexToInts ( 0 , . 5f , . 5f , - 1 , 0 , 0 ) , 
 - vertexToInts ( . 5f , . 5f , 1 , - 1 , 0 , 16 ) , 
 - vertexToInts ( 1 , . 5f , . 5f , - 1 , 16 , 16 ) , 
 - vertexToInts ( . 5f , . 5f , 0 , - 1 , 16 , 0 ) 
 - ) , - 1 , EnumFacing . UP ) ) ; 
 - return ret ; 
 - } 
 - 
 - public boolean isGui3d ( ) { return true ; } 
 - 
 - public boolean isAmbientOcclusion ( ) { return true ; } 
 - 
 - public boolean isBuiltInRenderer ( ) { return false ; } 
 - 
 - public TextureAtlasSprite getTexture ( ) { return this . texture ; } 
 - 
 - public ItemCameraTransforms getItemCameraTransforms ( ) 
 - { 
 - return ItemCameraTransforms . DEFAULT ; 
 - } 
 - 
 - public VertexFormat getFormat ( ) 
 - { 
 - return Attributes . DEFAULT _ BAKED _ FORMAT ; 
 - } 
 - } 
 - 
 - public void onResourceManagerReload ( IResourceManager resourceManager ) { } 
 - } 
 } 
 diff - - git a / src / test / resources / assets / forgedebugmodelloaderregistry / blockstates / CustomModelBlock . json b / src / test / resources / assets / forgedebugmodelloaderregistry / blockstates / CustomModelBlock . json 
 index 1ebdfc8 . . c6db8d8 100644 
 - - - a / src / test / resources / assets / forgedebugmodelloaderregistry / blockstates / CustomModelBlock . json 
 + + + b / src / test / resources / assets / forgedebugmodelloaderregistry / blockstates / CustomModelBlock . json 
 @ @ - 1 , 5 + 1 , 18 @ @ 
 { 
 + " forge _ marker " : 1 , 
 + " defaults " : { 
 + " textures " : { 
 + " # texture " : " forgedebugmodelloaderregistry : texture " , 
 + " # chest " : " entity / chest / normal " 
 + } , 
 + " model " : " forgedebugmodelloaderregistry : chest . b3d " 
 + } , 
 " variants " : { 
 - " normal " : { " model " : " forgedebugmodelloaderregistry : untitled2 . b3d " } 
 + " normal " : { 
 + " dummy " : " " 
 + } , 
 + " inventory " : { 
 + " dummy " : " " 
 + } 
 } 
 } 
 diff - - git a / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / chest . b3d b / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / chest . b3d 
 new file mode 100644 
 index 0000000 . . b070d7a 
 Binary files / dev / null and b / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / chest . b3d differ 
 diff - - git a / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / untitled2 . b3d b / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / untitled2 . b3d 
 index 14e9c4d . . 8f4bd09 100644 
 Binary files a / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / untitled2 . b3d and b / src / test / resources / assets / forgedebugmodelloaderregistry / models / block / untitled2 . b3d differ
