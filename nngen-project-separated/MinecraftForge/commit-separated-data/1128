BLEU SCORE: 0.02383853510228548

TEST MSG: Filter more known libraries from potential mod canidates .
GENERATED MSG: Thoughts on how to do the modloading properly

TEST DIFF (one line): diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java b / fml / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java <nl> index a389421 . . 161f936 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java <nl> @ @ - 86 , 6 + 86 , 55 @ @ public class ModClassLoader extends URLClassLoader <nl> return STANDARD _ LIBRARIES ; <nl> } <nl> <nl> + public boolean isDefaultLibrary ( File file ) <nl> + { <nl> + / / Should really pull this from the json somehow , but we dont have that at runtime . <nl> + String name = file . getName ( ) ; <nl> + if ( ! name . endsWith ( " . jar " ) ) return false ; <nl> + String [ ] prefixes = <nl> + { <nl> + " launchwrapper - " , <nl> + " asm - all - " , <nl> + " akka - actor _ 2 . 11 - " , <nl> + " config - " , <nl> + " scala - " , <nl> + " jopt - simple - " , <nl> + " lzma - " , <nl> + " realms - " , <nl> + " httpclient - " , <nl> + " httpcore - " , <nl> + " vecmath - " , <nl> + " trove4j - " , <nl> + " icu4j - core - mojang - " , <nl> + " codecjorbis - " , <nl> + " codecwav - " , <nl> + " libraryjavawound - " , <nl> + " librarylwjglopenal - " , <nl> + " soundsystem - " , <nl> + " netty - all - " , <nl> + " quava - " , <nl> + " commons - lang3 - " , <nl> + " commons - compress - " , <nl> + " commons - logging - " , <nl> + " commons - io - " , <nl> + " commons - codec - " , <nl> + " jinput - " , <nl> + " jutils - " , <nl> + " gson - " , <nl> + " authlib - " , <nl> + " log4j - api - " , <nl> + " log4j - core - " , <nl> + " lwjgl - " , <nl> + " lwjgl _ util - " , <nl> + " twitch - " <nl> + } ; <nl> + for ( String s : prefixes ) <nl> + { <nl> + if ( name . startsWith ( s ) ) return true ; <nl> + } <nl> + return false ; <nl> + } <nl> + <nl> public void clearNegativeCacheFor ( Set < String > classList ) <nl> { <nl> mainClassLoader . clearNegativeEntries ( classList ) ; <nl> diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java b / fml / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java <nl> index 2350600 . . bf1814c 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java <nl> @ @ - 60 , 25 + 60 , 27 @ @ public class ModDiscoverer <nl> } <nl> else <nl> { <nl> - for ( int i = 0 ; i < minecraftSources . length ; i + + ) <nl> + int i = 0 ; <nl> + for ( File source : minecraftSources ) <nl> { <nl> - if ( minecraftSources [ i ] . isFile ( ) ) <nl> + if ( source . isFile ( ) ) <nl> { <nl> - if ( knownLibraries . contains ( minecraftSources [ i ] . getName ( ) ) ) <nl> + if ( knownLibraries . contains ( source . getName ( ) ) | | modClassLoader . isDefaultLibrary ( source ) ) <nl> { <nl> - FMLLog . finer ( " Skipping known library file % s " , minecraftSources [ i ] . getAbsolutePath ( ) ) ; <nl> + FMLLog . finer ( " Skipping known library file % s " , source . getAbsolutePath ( ) ) ; <nl> } <nl> else <nl> { <nl> - FMLLog . fine ( " Found a minecraft related file at % s , examining for mod candidates " , minecraftSources [ i ] . getAbsolutePath ( ) ) ; <nl> - addCandidate ( new ModCandidate ( minecraftSources [ i ] , minecraftSources [ i ] , ContainerType . JAR , i = = 0 , true ) ) ; <nl> + FMLLog . fine ( " Found a minecraft related file at % s , examining for mod candidates " , source . getAbsolutePath ( ) ) ; <nl> + addCandidate ( new ModCandidate ( source , source , ContainerType . JAR , i = = 0 , true ) ) ; <nl> } <nl> } <nl> else if ( minecraftSources [ i ] . isDirectory ( ) ) <nl> { <nl> - FMLLog . fine ( " Found a minecraft related directory at % s , examining for mod candidates " , minecraftSources [ i ] . getAbsolutePath ( ) ) ; <nl> - addCandidate ( new ModCandidate ( minecraftSources [ i ] , minecraftSources [ i ] , ContainerType . DIR , i = = 0 , true ) ) ; <nl> + FMLLog . fine ( " Found a minecraft related directory at % s , examining for mod candidates " , source . getAbsolutePath ( ) ) ; <nl> + addCandidate ( new ModCandidate ( source , source , ContainerType . DIR , i = = 0 , true ) ) ; <nl> } <nl> + i + + ; <nl> } <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / fml / src / fml / Mod . java b / fml / src / fml / Mod . java <nl> new file mode 100644 <nl> index 0000000 . . ae98b0c <nl> - - - / dev / null <nl> + + + b / fml / src / fml / Mod . java <nl> @ @ - 0 , 0 + 1 , 15 @ @ <nl> + package fml ; <nl> + <nl> + import java . lang . annotation . Retention ; <nl> + import java . lang . annotation . RetentionPolicy ; <nl> + <nl> + @ Retention ( RetentionPolicy . RUNTIME ) <nl> + public @ interface Mod { <nl> + String name ( ) default " " ; <nl> + String version ( ) default " " ; <nl> + boolean wantsPreInit ( ) default false ; <nl> + boolean wantsPostInit ( ) default false ; <nl> + public @ interface PreInit { } <nl> + public @ interface Init { } <nl> + public @ interface PostInit { } <nl> + } <nl> diff - - git a / fml / src / fml / server / FMLModContainer . java b / fml / src / fml / server / FMLModContainer . java <nl> new file mode 100644 <nl> index 0000000 . . dbd483a <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / FMLModContainer . java <nl> @ @ - 0 , 0 + 1 , 49 @ @ <nl> + package fml . server ; <nl> + <nl> + import fml . Mod ; <nl> + <nl> + public class FMLModContainer implements ModContainer { <nl> + private Mod modDescriptor ; <nl> + private Object modInstance ; <nl> + public FMLModContainer ( Class < ? > clazz ) { <nl> + modDescriptor = clazz . getAnnotation ( Mod . class ) ; <nl> + <nl> + try { <nl> + modInstance = clazz . newInstance ( ) ; <nl> + } catch ( Exception e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public boolean wantsPreInit ( ) { <nl> + return modDescriptor . wantsPreInit ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean wantsPostInit ( ) { <nl> + return modDescriptor . wantsPostInit ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void preInit ( ) { <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void init ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void postInit ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + public static ModContainer buildFor ( Class < ? > clazz ) { <nl> + return new FMLModContainer ( clazz ) ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / fml / src / fml / server / Loader . java b / fml / src / fml / server / Loader . java <nl> new file mode 100644 <nl> index 0000000 . . 5b289f0 <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / Loader . java <nl> @ @ - 0 , 0 + 1 , 193 @ @ <nl> + package fml . server ; <nl> + <nl> + import java . io . File ; <nl> + import java . io . FilenameFilter ; <nl> + import java . io . IOException ; <nl> + import java . net . MalformedURLException ; <nl> + import java . util . Arrays ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> + import java . util . logging . Logger ; <nl> + import java . util . regex . Matcher ; <nl> + import java . util . regex . Pattern ; <nl> + import java . util . zip . ZipEntry ; <nl> + import java . util . zip . ZipFile ; <nl> + <nl> + import fml . Mod ; <nl> + import fml . stubs . mcpserver . BaseMod ; <nl> + <nl> + public class Loader { <nl> + private enum State { NOINIT , LOADING , PREINIT , INIT , POSTINIT , UP , ERRORED } ; <nl> + private static State state ; <nl> + private static Logger LOG = Logger . getLogger ( " ForgeModLoader . Loader " ) ; <nl> + <nl> + private static List < ModContainer > mods ; <nl> + <nl> + private static ModClassLoader modClassLoader ; <nl> + <nl> + private static Pattern zipJar = Pattern . compile ( " ( [ \ \ w ] + ) . ( zip | jar ) $ " ) ; <nl> + private static Pattern modClass = Pattern . compile ( " ( . * ) ( mod _ [ ^ \ \ s ] + ) \ \ . class $ " ) ; <nl> + <nl> + public static Loader instance ; <nl> + <nl> + public static void run ( ) { <nl> + instance = new Loader ( ) ; <nl> + } <nl> + <nl> + private Loader ( ) { <nl> + state = State . NOINIT ; <nl> + load ( ) ; <nl> + preModInit ( ) ; <nl> + modInit ( ) ; <nl> + postModInit ( ) ; <nl> + state = State . UP ; <nl> + } <nl> + <nl> + private void preModInit ( ) { <nl> + state = State . PREINIT ; <nl> + for ( ModContainer mod : mods ) { <nl> + if ( mod . wantsPreInit ( ) ) { <nl> + mod . preInit ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void modInit ( ) { <nl> + state = State . INIT ; <nl> + for ( ModContainer mod : mods ) { <nl> + mod . init ( ) ; <nl> + } <nl> + } <nl> + <nl> + private void postModInit ( ) { <nl> + state = State . POSTINIT ; <nl> + for ( ModContainer mod : mods ) { <nl> + if ( mod . wantsPostInit ( ) ) { <nl> + mod . postInit ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void load ( ) { <nl> + File modsDir = new File ( " . " , " mods " ) ; <nl> + String canonicalModsPath ; <nl> + try { <nl> + canonicalModsPath = modsDir . getCanonicalPath ( ) ; <nl> + } catch ( IOException ioe ) { <nl> + LOG . severe ( String . format ( " Failed to resolve mods directory mods % s " , modsDir . getAbsolutePath ( ) ) ) ; <nl> + LOG . throwing ( " fml . server . Loader " , " initialize " , ioe ) ; <nl> + throw new LoaderException ( ioe ) ; <nl> + } <nl> + if ( ! modsDir . exists ( ) ) { <nl> + LOG . fine ( String . format ( " No mod directory found , creating one : % s " , canonicalModsPath ) ) ; <nl> + try { <nl> + modsDir . mkdir ( ) ; <nl> + } catch ( Exception e ) { <nl> + LOG . throwing ( " fml . server . Loader " , " initialize " , e ) ; <nl> + throw new LoaderException ( e ) ; <nl> + } <nl> + } <nl> + if ( ! modsDir . isDirectory ( ) ) { <nl> + LOG . severe ( String . format ( " Attempting to load mods from % s , which is not a directory " , canonicalModsPath ) ) ; <nl> + LoaderException loaderException = new LoaderException ( ) ; <nl> + LOG . throwing ( " fml . server . Loader " , " initialize " , loaderException ) ; <nl> + throw loaderException ; <nl> + } <nl> + File [ ] modList = modsDir . listFiles ( ) ; <nl> + / / Sort the files into alphabetical order first <nl> + Arrays . sort ( modList ) ; <nl> + <nl> + state = State . LOADING ; <nl> + for ( File modFile : modList ) { <nl> + if ( modFile . isDirectory ( ) ) { <nl> + LOG . info ( String . format ( " Found directory % s . Attempting load " , modFile . getName ( ) ) ) ; <nl> + attemptDirLoad ( modFile ) ; <nl> + } else { <nl> + Matcher matcher = zipJar . matcher ( modFile . getName ( ) ) ; <nl> + if ( matcher . find ( ) ) { <nl> + LOG . info ( String . format ( " Found zip or jar file % s . Attempting load . " , matcher . group ( 0 ) ) ) ; <nl> + attemptFileLoad ( modFile ) ; <nl> + } <nl> + } <nl> + } <nl> + if ( state = = State . ERRORED ) { <nl> + LOG . severe ( " A problem has occured during mod loading . Giving up now " ) ; <nl> + throw new RuntimeException ( " Giving up please " ) ; <nl> + } <nl> + } <nl> + <nl> + private void attemptDirLoad ( File modDir ) { <nl> + extendClassLoader ( modDir ) ; <nl> + <nl> + File [ ] content = modDir . listFiles ( new FilenameFilter ( ) { <nl> + @ Override <nl> + public boolean accept ( File dir , String name ) { <nl> + return modClass . matcher ( name ) . find ( ) ; <nl> + } <nl> + } ) ; <nl> + for ( File modClassFile : content ) { <nl> + LOG . fine ( String . format ( " Found a mod class % s in directory % s . Attempting to load it " , modClassFile . getName ( ) , modDir . getName ( ) ) ) ; <nl> + String clazzName = modClass . matcher ( modClassFile . getName ( ) ) . group ( 2 ) ; <nl> + loadModClass ( modDir , modClassFile . getName ( ) , clazzName ) ; <nl> + LOG . fine ( String . format ( " Successfully loaded mod class % s " , modClassFile . getName ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void loadModClass ( File classSource , String classFileName , String clazzName ) { <nl> + try { <nl> + Class < ? > clazz = Class . forName ( clazzName , true , modClassLoader ) ; <nl> + if ( clazz . isAnnotationPresent ( Mod . class ) ) { <nl> + / / an FML mod <nl> + mods . add ( FMLModContainer . buildFor ( clazz ) ) ; <nl> + } else if ( clazz . isAssignableFrom ( BaseMod . class ) ) { <nl> + / / a modloader mod <nl> + } else { <nl> + / / Unrecognized <nl> + } <nl> + } catch ( ClassNotFoundException e ) { <nl> + LOG . warning ( String . format ( " Failed to load mod class % s in % s " , classFileName , classSource . getName ( ) ) ) ; <nl> + LOG . throwing ( " fml . server . Loader " , " attemptDirLoad " , e ) ; <nl> + state = State . ERRORED ; <nl> + } <nl> + } <nl> + <nl> + private void extendClassLoader ( File file ) { <nl> + if ( modClassLoader = = null ) { <nl> + modClassLoader = new ModClassLoader ( ) ; <nl> + } <nl> + try { <nl> + modClassLoader . addFile ( file ) ; <nl> + } catch ( MalformedURLException e ) { <nl> + throw new LoaderException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + private void attemptFileLoad ( File modFile ) { <nl> + extendClassLoader ( modFile ) ; <nl> + <nl> + try { <nl> + ZipFile jar = new ZipFile ( modFile ) ; <nl> + for ( ZipEntry ze : Collections . list ( jar . entries ( ) ) ) { <nl> + Matcher match = modClass . matcher ( ze . getName ( ) ) ; <nl> + if ( match . find ( ) ) { <nl> + String pkg = match . group ( 1 ) . replace ( ' / ' , ' . ' ) ; <nl> + String clazzName = pkg + match . group ( 2 ) ; <nl> + loadModClass ( modFile , ze . getName ( ) , clazzName ) ; <nl> + } <nl> + } <nl> + } catch ( Exception e ) { <nl> + LOG . warning ( String . format ( " Zip file % s failed to read properly " , modFile . getName ( ) ) ) ; <nl> + LOG . throwing ( " fml . server . Loader " , " attemptFileLoad " , e ) ; <nl> + state = State . ERRORED ; <nl> + } <nl> + } <nl> + <nl> + class LoaderException extends RuntimeException { <nl> + public LoaderException ( Exception wrapped ) { <nl> + super ( wrapped ) ; <nl> + } <nl> + <nl> + public LoaderException ( ) { <nl> + } <nl> + } <nl> + } <nl> diff - - git a / fml / src / fml / server / ModClassLoader . java b / fml / src / fml / server / ModClassLoader . java <nl> new file mode 100644 <nl> index 0000000 . . 051c074 <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / ModClassLoader . java <nl> @ @ - 0 , 0 + 1 , 18 @ @ <nl> + package fml . server ; <nl> + <nl> + import java . io . File ; <nl> + import java . net . MalformedURLException ; <nl> + import java . net . URL ; <nl> + import java . net . URLClassLoader ; <nl> + <nl> + public class ModClassLoader extends URLClassLoader { <nl> + <nl> + public ModClassLoader ( ) { <nl> + super ( new URL [ 0 ] ) ; <nl> + } <nl> + <nl> + public void addFile ( File modFile ) throws MalformedURLException { <nl> + URL url = modFile . toURI ( ) . toURL ( ) ; <nl> + super . addURL ( url ) ; <nl> + } <nl> + } <nl> diff - - git a / fml / src / fml / server / ModContainer . java b / fml / src / fml / server / ModContainer . java <nl> new file mode 100644 <nl> index 0000000 . . 344806d <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / ModContainer . java <nl> @ @ - 0 , 0 + 1 , 9 @ @ <nl> + package fml . server ; <nl> + <nl> + public interface ModContainer { <nl> + boolean wantsPreInit ( ) ; <nl> + boolean wantsPostInit ( ) ; <nl> + void preInit ( ) ; <nl> + void init ( ) ; <nl> + void postInit ( ) ; <nl> + } <nl> diff - - git a / fml / src / fml / server / ModLoaderModContainer . java b / fml / src / fml / server / ModLoaderModContainer . java <nl> new file mode 100644 <nl> index 0000000 . . 69c3138 <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / ModLoaderModContainer . java <nl> @ @ - 0 , 0 + 1 , 30 @ @ <nl> + package fml . server ; <nl> + <nl> + public class ModLoaderModContainer implements ModContainer { <nl> + public boolean wantsPreInit ( ) { <nl> + return false ; <nl> + } <nl> + <nl> + public boolean wantsPostInit ( ) { <nl> + return false ; <nl> + } <nl> + <nl> + @ Override <nl> + public void preInit ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void init ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void postInit ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + } <nl> diff - - git a / fml / src / fml / stubs / mcpserver / BaseMod . java b / fml / src / fml / stubs / mcpserver / BaseMod . java <nl> index f0519c7 . . ebb6d07 100644 <nl> - - - a / fml / src / fml / stubs / mcpserver / BaseMod . java <nl> + + + b / fml / src / fml / stubs / mcpserver / BaseMod . java <nl> @ @ - 2 , 12 + 2 , 16 @ @ package fml . stubs . mcpserver ; <nl> <nl> import java . util . Random ; <nl> <nl> + import fml . Mod ; <nl> + <nl> + <nl> import net . minecraft . src . EntityPlayer ; <nl> import net . minecraft . src . IInventory ; <nl> import net . minecraft . src . ItemStack ; <nl> import net . minecraft . src . Packet250CustomPayload ; <nl> import net . minecraft . src . World ; <nl> <nl> + @ Mod ( name = " blah " , version = " blah " ) <nl> public interface BaseMod { <nl> int addFuel ( int id , int metadata ) ; <nl> <nl> @ @ - 25 , 8 + 29 , 10 @ @ public interface BaseMod { <nl> abstract String getVersion ( ) ; <nl> <nl> / / void keyboardEvent ( KeyBinding event ) ; <nl> + @ Mod . PreInit <nl> abstract void load ( ) ; <nl> <nl> + @ Mod . Init <nl> void modsLoaded ( ) ; <nl> <nl> void onItemPickup ( EntityPlayer player , ItemStack item ) ;

TEST DIFF:
diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java b / fml / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java 
 index a389421 . . 161f936 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / ModClassLoader . java 
 @ @ - 86 , 6 + 86 , 55 @ @ public class ModClassLoader extends URLClassLoader 
 return STANDARD _ LIBRARIES ; 
 } 
 
 + public boolean isDefaultLibrary ( File file ) 
 + { 
 + / / Should really pull this from the json somehow , but we dont have that at runtime . 
 + String name = file . getName ( ) ; 
 + if ( ! name . endsWith ( " . jar " ) ) return false ; 
 + String [ ] prefixes = 
 + { 
 + " launchwrapper - " , 
 + " asm - all - " , 
 + " akka - actor _ 2 . 11 - " , 
 + " config - " , 
 + " scala - " , 
 + " jopt - simple - " , 
 + " lzma - " , 
 + " realms - " , 
 + " httpclient - " , 
 + " httpcore - " , 
 + " vecmath - " , 
 + " trove4j - " , 
 + " icu4j - core - mojang - " , 
 + " codecjorbis - " , 
 + " codecwav - " , 
 + " libraryjavawound - " , 
 + " librarylwjglopenal - " , 
 + " soundsystem - " , 
 + " netty - all - " , 
 + " quava - " , 
 + " commons - lang3 - " , 
 + " commons - compress - " , 
 + " commons - logging - " , 
 + " commons - io - " , 
 + " commons - codec - " , 
 + " jinput - " , 
 + " jutils - " , 
 + " gson - " , 
 + " authlib - " , 
 + " log4j - api - " , 
 + " log4j - core - " , 
 + " lwjgl - " , 
 + " lwjgl _ util - " , 
 + " twitch - " 
 + } ; 
 + for ( String s : prefixes ) 
 + { 
 + if ( name . startsWith ( s ) ) return true ; 
 + } 
 + return false ; 
 + } 
 + 
 public void clearNegativeCacheFor ( Set < String > classList ) 
 { 
 mainClassLoader . clearNegativeEntries ( classList ) ; 
 diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java b / fml / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java 
 index 2350600 . . bf1814c 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java 
 @ @ - 60 , 25 + 60 , 27 @ @ public class ModDiscoverer 
 } 
 else 
 { 
 - for ( int i = 0 ; i < minecraftSources . length ; i + + ) 
 + int i = 0 ; 
 + for ( File source : minecraftSources ) 
 { 
 - if ( minecraftSources [ i ] . isFile ( ) ) 
 + if ( source . isFile ( ) ) 
 { 
 - if ( knownLibraries . contains ( minecraftSources [ i ] . getName ( ) ) ) 
 + if ( knownLibraries . contains ( source . getName ( ) ) | | modClassLoader . isDefaultLibrary ( source ) ) 
 { 
 - FMLLog . finer ( " Skipping known library file % s " , minecraftSources [ i ] . getAbsolutePath ( ) ) ; 
 + FMLLog . finer ( " Skipping known library file % s " , source . getAbsolutePath ( ) ) ; 
 } 
 else 
 { 
 - FMLLog . fine ( " Found a minecraft related file at % s , examining for mod candidates " , minecraftSources [ i ] . getAbsolutePath ( ) ) ; 
 - addCandidate ( new ModCandidate ( minecraftSources [ i ] , minecraftSources [ i ] , ContainerType . JAR , i = = 0 , true ) ) ; 
 + FMLLog . fine ( " Found a minecraft related file at % s , examining for mod candidates " , source . getAbsolutePath ( ) ) ; 
 + addCandidate ( new ModCandidate ( source , source , ContainerType . JAR , i = = 0 , true ) ) ; 
 } 
 } 
 else if ( minecraftSources [ i ] . isDirectory ( ) ) 
 { 
 - FMLLog . fine ( " Found a minecraft related directory at % s , examining for mod candidates " , minecraftSources [ i ] . getAbsolutePath ( ) ) ; 
 - addCandidate ( new ModCandidate ( minecraftSources [ i ] , minecraftSources [ i ] , ContainerType . DIR , i = = 0 , true ) ) ; 
 + FMLLog . fine ( " Found a minecraft related directory at % s , examining for mod candidates " , source . getAbsolutePath ( ) ) ; 
 + addCandidate ( new ModCandidate ( source , source , ContainerType . DIR , i = = 0 , true ) ) ; 
 } 
 + i + + ; 
 } 
 } 


NEAREST DIFF:
diff - - git a / fml / src / fml / Mod . java b / fml / src / fml / Mod . java 
 new file mode 100644 
 index 0000000 . . ae98b0c 
 - - - / dev / null 
 + + + b / fml / src / fml / Mod . java 
 @ @ - 0 , 0 + 1 , 15 @ @ 
 + package fml ; 
 + 
 + import java . lang . annotation . Retention ; 
 + import java . lang . annotation . RetentionPolicy ; 
 + 
 + @ Retention ( RetentionPolicy . RUNTIME ) 
 + public @ interface Mod { 
 + String name ( ) default " " ; 
 + String version ( ) default " " ; 
 + boolean wantsPreInit ( ) default false ; 
 + boolean wantsPostInit ( ) default false ; 
 + public @ interface PreInit { } 
 + public @ interface Init { } 
 + public @ interface PostInit { } 
 + } 
 diff - - git a / fml / src / fml / server / FMLModContainer . java b / fml / src / fml / server / FMLModContainer . java 
 new file mode 100644 
 index 0000000 . . dbd483a 
 - - - / dev / null 
 + + + b / fml / src / fml / server / FMLModContainer . java 
 @ @ - 0 , 0 + 1 , 49 @ @ 
 + package fml . server ; 
 + 
 + import fml . Mod ; 
 + 
 + public class FMLModContainer implements ModContainer { 
 + private Mod modDescriptor ; 
 + private Object modInstance ; 
 + public FMLModContainer ( Class < ? > clazz ) { 
 + modDescriptor = clazz . getAnnotation ( Mod . class ) ; 
 + 
 + try { 
 + modInstance = clazz . newInstance ( ) ; 
 + } catch ( Exception e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public boolean wantsPreInit ( ) { 
 + return modDescriptor . wantsPreInit ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean wantsPostInit ( ) { 
 + return modDescriptor . wantsPostInit ( ) ; 
 + } 
 + 
 + @ Override 
 + public void preInit ( ) { 
 + 
 + } 
 + 
 + @ Override 
 + public void init ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + @ Override 
 + public void postInit ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + public static ModContainer buildFor ( Class < ? > clazz ) { 
 + return new FMLModContainer ( clazz ) ; 
 + } 
 + 
 + } 
 diff - - git a / fml / src / fml / server / Loader . java b / fml / src / fml / server / Loader . java 
 new file mode 100644 
 index 0000000 . . 5b289f0 
 - - - / dev / null 
 + + + b / fml / src / fml / server / Loader . java 
 @ @ - 0 , 0 + 1 , 193 @ @ 
 + package fml . server ; 
 + 
 + import java . io . File ; 
 + import java . io . FilenameFilter ; 
 + import java . io . IOException ; 
 + import java . net . MalformedURLException ; 
 + import java . util . Arrays ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 + import java . util . logging . Logger ; 
 + import java . util . regex . Matcher ; 
 + import java . util . regex . Pattern ; 
 + import java . util . zip . ZipEntry ; 
 + import java . util . zip . ZipFile ; 
 + 
 + import fml . Mod ; 
 + import fml . stubs . mcpserver . BaseMod ; 
 + 
 + public class Loader { 
 + private enum State { NOINIT , LOADING , PREINIT , INIT , POSTINIT , UP , ERRORED } ; 
 + private static State state ; 
 + private static Logger LOG = Logger . getLogger ( " ForgeModLoader . Loader " ) ; 
 + 
 + private static List < ModContainer > mods ; 
 + 
 + private static ModClassLoader modClassLoader ; 
 + 
 + private static Pattern zipJar = Pattern . compile ( " ( [ \ \ w ] + ) . ( zip | jar ) $ " ) ; 
 + private static Pattern modClass = Pattern . compile ( " ( . * ) ( mod _ [ ^ \ \ s ] + ) \ \ . class $ " ) ; 
 + 
 + public static Loader instance ; 
 + 
 + public static void run ( ) { 
 + instance = new Loader ( ) ; 
 + } 
 + 
 + private Loader ( ) { 
 + state = State . NOINIT ; 
 + load ( ) ; 
 + preModInit ( ) ; 
 + modInit ( ) ; 
 + postModInit ( ) ; 
 + state = State . UP ; 
 + } 
 + 
 + private void preModInit ( ) { 
 + state = State . PREINIT ; 
 + for ( ModContainer mod : mods ) { 
 + if ( mod . wantsPreInit ( ) ) { 
 + mod . preInit ( ) ; 
 + } 
 + } 
 + } 
 + 
 + private void modInit ( ) { 
 + state = State . INIT ; 
 + for ( ModContainer mod : mods ) { 
 + mod . init ( ) ; 
 + } 
 + } 
 + 
 + private void postModInit ( ) { 
 + state = State . POSTINIT ; 
 + for ( ModContainer mod : mods ) { 
 + if ( mod . wantsPostInit ( ) ) { 
 + mod . postInit ( ) ; 
 + } 
 + } 
 + } 
 + 
 + private void load ( ) { 
 + File modsDir = new File ( " . " , " mods " ) ; 
 + String canonicalModsPath ; 
 + try { 
 + canonicalModsPath = modsDir . getCanonicalPath ( ) ; 
 + } catch ( IOException ioe ) { 
 + LOG . severe ( String . format ( " Failed to resolve mods directory mods % s " , modsDir . getAbsolutePath ( ) ) ) ; 
 + LOG . throwing ( " fml . server . Loader " , " initialize " , ioe ) ; 
 + throw new LoaderException ( ioe ) ; 
 + } 
 + if ( ! modsDir . exists ( ) ) { 
 + LOG . fine ( String . format ( " No mod directory found , creating one : % s " , canonicalModsPath ) ) ; 
 + try { 
 + modsDir . mkdir ( ) ; 
 + } catch ( Exception e ) { 
 + LOG . throwing ( " fml . server . Loader " , " initialize " , e ) ; 
 + throw new LoaderException ( e ) ; 
 + } 
 + } 
 + if ( ! modsDir . isDirectory ( ) ) { 
 + LOG . severe ( String . format ( " Attempting to load mods from % s , which is not a directory " , canonicalModsPath ) ) ; 
 + LoaderException loaderException = new LoaderException ( ) ; 
 + LOG . throwing ( " fml . server . Loader " , " initialize " , loaderException ) ; 
 + throw loaderException ; 
 + } 
 + File [ ] modList = modsDir . listFiles ( ) ; 
 + / / Sort the files into alphabetical order first 
 + Arrays . sort ( modList ) ; 
 + 
 + state = State . LOADING ; 
 + for ( File modFile : modList ) { 
 + if ( modFile . isDirectory ( ) ) { 
 + LOG . info ( String . format ( " Found directory % s . Attempting load " , modFile . getName ( ) ) ) ; 
 + attemptDirLoad ( modFile ) ; 
 + } else { 
 + Matcher matcher = zipJar . matcher ( modFile . getName ( ) ) ; 
 + if ( matcher . find ( ) ) { 
 + LOG . info ( String . format ( " Found zip or jar file % s . Attempting load . " , matcher . group ( 0 ) ) ) ; 
 + attemptFileLoad ( modFile ) ; 
 + } 
 + } 
 + } 
 + if ( state = = State . ERRORED ) { 
 + LOG . severe ( " A problem has occured during mod loading . Giving up now " ) ; 
 + throw new RuntimeException ( " Giving up please " ) ; 
 + } 
 + } 
 + 
 + private void attemptDirLoad ( File modDir ) { 
 + extendClassLoader ( modDir ) ; 
 + 
 + File [ ] content = modDir . listFiles ( new FilenameFilter ( ) { 
 + @ Override 
 + public boolean accept ( File dir , String name ) { 
 + return modClass . matcher ( name ) . find ( ) ; 
 + } 
 + } ) ; 
 + for ( File modClassFile : content ) { 
 + LOG . fine ( String . format ( " Found a mod class % s in directory % s . Attempting to load it " , modClassFile . getName ( ) , modDir . getName ( ) ) ) ; 
 + String clazzName = modClass . matcher ( modClassFile . getName ( ) ) . group ( 2 ) ; 
 + loadModClass ( modDir , modClassFile . getName ( ) , clazzName ) ; 
 + LOG . fine ( String . format ( " Successfully loaded mod class % s " , modClassFile . getName ( ) ) ) ; 
 + } 
 + } 
 + 
 + private void loadModClass ( File classSource , String classFileName , String clazzName ) { 
 + try { 
 + Class < ? > clazz = Class . forName ( clazzName , true , modClassLoader ) ; 
 + if ( clazz . isAnnotationPresent ( Mod . class ) ) { 
 + / / an FML mod 
 + mods . add ( FMLModContainer . buildFor ( clazz ) ) ; 
 + } else if ( clazz . isAssignableFrom ( BaseMod . class ) ) { 
 + / / a modloader mod 
 + } else { 
 + / / Unrecognized 
 + } 
 + } catch ( ClassNotFoundException e ) { 
 + LOG . warning ( String . format ( " Failed to load mod class % s in % s " , classFileName , classSource . getName ( ) ) ) ; 
 + LOG . throwing ( " fml . server . Loader " , " attemptDirLoad " , e ) ; 
 + state = State . ERRORED ; 
 + } 
 + } 
 + 
 + private void extendClassLoader ( File file ) { 
 + if ( modClassLoader = = null ) { 
 + modClassLoader = new ModClassLoader ( ) ; 
 + } 
 + try { 
 + modClassLoader . addFile ( file ) ; 
 + } catch ( MalformedURLException e ) { 
 + throw new LoaderException ( e ) ; 
 + } 
 + } 
 + 
 + private void attemptFileLoad ( File modFile ) { 
 + extendClassLoader ( modFile ) ; 
 + 
 + try { 
 + ZipFile jar = new ZipFile ( modFile ) ; 
 + for ( ZipEntry ze : Collections . list ( jar . entries ( ) ) ) { 
 + Matcher match = modClass . matcher ( ze . getName ( ) ) ; 
 + if ( match . find ( ) ) { 
 + String pkg = match . group ( 1 ) . replace ( ' / ' , ' . ' ) ; 
 + String clazzName = pkg + match . group ( 2 ) ; 
 + loadModClass ( modFile , ze . getName ( ) , clazzName ) ; 
 + } 
 + } 
 + } catch ( Exception e ) { 
 + LOG . warning ( String . format ( " Zip file % s failed to read properly " , modFile . getName ( ) ) ) ; 
 + LOG . throwing ( " fml . server . Loader " , " attemptFileLoad " , e ) ; 
 + state = State . ERRORED ; 
 + } 
 + } 
 + 
 + class LoaderException extends RuntimeException { 
 + public LoaderException ( Exception wrapped ) { 
 + super ( wrapped ) ; 
 + } 
 + 
 + public LoaderException ( ) { 
 + } 
 + } 
 + } 
 diff - - git a / fml / src / fml / server / ModClassLoader . java b / fml / src / fml / server / ModClassLoader . java 
 new file mode 100644 
 index 0000000 . . 051c074 
 - - - / dev / null 
 + + + b / fml / src / fml / server / ModClassLoader . java 
 @ @ - 0 , 0 + 1 , 18 @ @ 
 + package fml . server ; 
 + 
 + import java . io . File ; 
 + import java . net . MalformedURLException ; 
 + import java . net . URL ; 
 + import java . net . URLClassLoader ; 
 + 
 + public class ModClassLoader extends URLClassLoader { 
 + 
 + public ModClassLoader ( ) { 
 + super ( new URL [ 0 ] ) ; 
 + } 
 + 
 + public void addFile ( File modFile ) throws MalformedURLException { 
 + URL url = modFile . toURI ( ) . toURL ( ) ; 
 + super . addURL ( url ) ; 
 + } 
 + } 
 diff - - git a / fml / src / fml / server / ModContainer . java b / fml / src / fml / server / ModContainer . java 
 new file mode 100644 
 index 0000000 . . 344806d 
 - - - / dev / null 
 + + + b / fml / src / fml / server / ModContainer . java 
 @ @ - 0 , 0 + 1 , 9 @ @ 
 + package fml . server ; 
 + 
 + public interface ModContainer { 
 + boolean wantsPreInit ( ) ; 
 + boolean wantsPostInit ( ) ; 
 + void preInit ( ) ; 
 + void init ( ) ; 
 + void postInit ( ) ; 
 + } 
 diff - - git a / fml / src / fml / server / ModLoaderModContainer . java b / fml / src / fml / server / ModLoaderModContainer . java 
 new file mode 100644 
 index 0000000 . . 69c3138 
 - - - / dev / null 
 + + + b / fml / src / fml / server / ModLoaderModContainer . java 
 @ @ - 0 , 0 + 1 , 30 @ @ 
 + package fml . server ; 
 + 
 + public class ModLoaderModContainer implements ModContainer { 
 + public boolean wantsPreInit ( ) { 
 + return false ; 
 + } 
 + 
 + public boolean wantsPostInit ( ) { 
 + return false ; 
 + } 
 + 
 + @ Override 
 + public void preInit ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + @ Override 
 + public void init ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + @ Override 
 + public void postInit ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + } 
 diff - - git a / fml / src / fml / stubs / mcpserver / BaseMod . java b / fml / src / fml / stubs / mcpserver / BaseMod . java 
 index f0519c7 . . ebb6d07 100644 
 - - - a / fml / src / fml / stubs / mcpserver / BaseMod . java 
 + + + b / fml / src / fml / stubs / mcpserver / BaseMod . java 
 @ @ - 2 , 12 + 2 , 16 @ @ package fml . stubs . mcpserver ; 
 
 import java . util . Random ; 
 
 + import fml . Mod ; 
 + 
 + 
 import net . minecraft . src . EntityPlayer ; 
 import net . minecraft . src . IInventory ; 
 import net . minecraft . src . ItemStack ; 
 import net . minecraft . src . Packet250CustomPayload ; 
 import net . minecraft . src . World ; 
 
 + @ Mod ( name = " blah " , version = " blah " ) 
 public interface BaseMod { 
 int addFuel ( int id , int metadata ) ; 
 
 @ @ - 25 , 8 + 29 , 10 @ @ public interface BaseMod { 
 abstract String getVersion ( ) ; 
 
 / / void keyboardEvent ( KeyBinding event ) ; 
 + @ Mod . PreInit 
 abstract void load ( ) ; 
 
 + @ Mod . Init 
 void modsLoaded ( ) ; 
 
 void onItemPickup ( EntityPlayer player , ItemStack item ) ;
