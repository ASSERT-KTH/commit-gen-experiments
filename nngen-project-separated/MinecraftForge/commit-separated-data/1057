BLEU SCORE: 0.037477767366779206

TEST MSG: Thread errors should be correctly displayed in the crash report now
GENERATED MSG: Thoughts on how to do the modloading properly

TEST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java b / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java <nl> index 3422b9a . . 8fb3745 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java <nl> @ @ - 45 , 6 + 45 , 7 @ @ public class SplashProgress <nl> private static volatile boolean pause = false ; <nl> private static volatile boolean done = false ; <nl> private static Thread thread ; <nl> + private static volatile Throwable threadError ; <nl> private static int angle = 0 ; <nl> private static final Lock lock = new ReentrantLock ( true ) ; <nl> private static SplashFontRenderer fontRenderer ; <nl> @ @ - 322 , 12 + 323 , 20 @ @ public class SplashProgress <nl> public void uncaughtException ( Thread t , Throwable e ) <nl> { <nl> FMLLog . log ( Level . ERROR , e , " Splash thread Exception " ) ; <nl> - Minecraft . getMinecraft ( ) . crashed ( CrashReport . makeCrashReport ( e , " Splash thread " ) ) ; <nl> + threadError = e ; <nl> } <nl> } ) ; <nl> thread . start ( ) ; <nl> + checkThreadState ( ) ; <nl> } <nl> <nl> + private static void checkThreadState ( ) <nl> + { <nl> + if ( thread . getState ( ) = = Thread . State . TERMINATED | | threadError ! = null ) <nl> + { <nl> + throw new IllegalStateException ( " Splash thread " , threadError ) ; <nl> + } <nl> + } <nl> / * * <nl> * Call before you need to explicitly modify GL context state during loading . <nl> * Resource loading doesn ' t usually require this call . <nl> @ @ - 338 , 6 + 347 , 7 @ @ public class SplashProgress <nl> public static void pause ( ) <nl> { <nl> if ( ! enabled ) return ; <nl> + checkThreadState ( ) ; <nl> pause = true ; <nl> lock . lock ( ) ; <nl> try <nl> @ @ - 359 , 6 + 369 , 7 @ @ public class SplashProgress <nl> public static void resume ( ) <nl> { <nl> if ( ! enabled ) return ; <nl> + checkThreadState ( ) ; <nl> pause = false ; <nl> try <nl> { <nl> @ @ - 376 , 6 + 387 , 7 @ @ public class SplashProgress <nl> public static void finish ( ) <nl> { <nl> if ( ! enabled ) return ; <nl> + checkThreadState ( ) ; <nl> try <nl> { <nl> done = true ;
NEAREST DIFF (one line): diff - - git a / fml / src / fml / Mod . java b / fml / src / fml / Mod . java <nl> new file mode 100644 <nl> index 0000000 . . ae98b0c <nl> - - - / dev / null <nl> + + + b / fml / src / fml / Mod . java <nl> @ @ - 0 , 0 + 1 , 15 @ @ <nl> + package fml ; <nl> + <nl> + import java . lang . annotation . Retention ; <nl> + import java . lang . annotation . RetentionPolicy ; <nl> + <nl> + @ Retention ( RetentionPolicy . RUNTIME ) <nl> + public @ interface Mod { <nl> + String name ( ) default " " ; <nl> + String version ( ) default " " ; <nl> + boolean wantsPreInit ( ) default false ; <nl> + boolean wantsPostInit ( ) default false ; <nl> + public @ interface PreInit { } <nl> + public @ interface Init { } <nl> + public @ interface PostInit { } <nl> + } <nl> diff - - git a / fml / src / fml / server / FMLModContainer . java b / fml / src / fml / server / FMLModContainer . java <nl> new file mode 100644 <nl> index 0000000 . . dbd483a <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / FMLModContainer . java <nl> @ @ - 0 , 0 + 1 , 49 @ @ <nl> + package fml . server ; <nl> + <nl> + import fml . Mod ; <nl> + <nl> + public class FMLModContainer implements ModContainer { <nl> + private Mod modDescriptor ; <nl> + private Object modInstance ; <nl> + public FMLModContainer ( Class < ? > clazz ) { <nl> + modDescriptor = clazz . getAnnotation ( Mod . class ) ; <nl> + <nl> + try { <nl> + modInstance = clazz . newInstance ( ) ; <nl> + } catch ( Exception e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public boolean wantsPreInit ( ) { <nl> + return modDescriptor . wantsPreInit ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean wantsPostInit ( ) { <nl> + return modDescriptor . wantsPostInit ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void preInit ( ) { <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void init ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void postInit ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + public static ModContainer buildFor ( Class < ? > clazz ) { <nl> + return new FMLModContainer ( clazz ) ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / fml / src / fml / server / Loader . java b / fml / src / fml / server / Loader . java <nl> new file mode 100644 <nl> index 0000000 . . 5b289f0 <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / Loader . java <nl> @ @ - 0 , 0 + 1 , 193 @ @ <nl> + package fml . server ; <nl> + <nl> + import java . io . File ; <nl> + import java . io . FilenameFilter ; <nl> + import java . io . IOException ; <nl> + import java . net . MalformedURLException ; <nl> + import java . util . Arrays ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> + import java . util . logging . Logger ; <nl> + import java . util . regex . Matcher ; <nl> + import java . util . regex . Pattern ; <nl> + import java . util . zip . ZipEntry ; <nl> + import java . util . zip . ZipFile ; <nl> + <nl> + import fml . Mod ; <nl> + import fml . stubs . mcpserver . BaseMod ; <nl> + <nl> + public class Loader { <nl> + private enum State { NOINIT , LOADING , PREINIT , INIT , POSTINIT , UP , ERRORED } ; <nl> + private static State state ; <nl> + private static Logger LOG = Logger . getLogger ( " ForgeModLoader . Loader " ) ; <nl> + <nl> + private static List < ModContainer > mods ; <nl> + <nl> + private static ModClassLoader modClassLoader ; <nl> + <nl> + private static Pattern zipJar = Pattern . compile ( " ( [ \ \ w ] + ) . ( zip | jar ) $ " ) ; <nl> + private static Pattern modClass = Pattern . compile ( " ( . * ) ( mod _ [ ^ \ \ s ] + ) \ \ . class $ " ) ; <nl> + <nl> + public static Loader instance ; <nl> + <nl> + public static void run ( ) { <nl> + instance = new Loader ( ) ; <nl> + } <nl> + <nl> + private Loader ( ) { <nl> + state = State . NOINIT ; <nl> + load ( ) ; <nl> + preModInit ( ) ; <nl> + modInit ( ) ; <nl> + postModInit ( ) ; <nl> + state = State . UP ; <nl> + } <nl> + <nl> + private void preModInit ( ) { <nl> + state = State . PREINIT ; <nl> + for ( ModContainer mod : mods ) { <nl> + if ( mod . wantsPreInit ( ) ) { <nl> + mod . preInit ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void modInit ( ) { <nl> + state = State . INIT ; <nl> + for ( ModContainer mod : mods ) { <nl> + mod . init ( ) ; <nl> + } <nl> + } <nl> + <nl> + private void postModInit ( ) { <nl> + state = State . POSTINIT ; <nl> + for ( ModContainer mod : mods ) { <nl> + if ( mod . wantsPostInit ( ) ) { <nl> + mod . postInit ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void load ( ) { <nl> + File modsDir = new File ( " . " , " mods " ) ; <nl> + String canonicalModsPath ; <nl> + try { <nl> + canonicalModsPath = modsDir . getCanonicalPath ( ) ; <nl> + } catch ( IOException ioe ) { <nl> + LOG . severe ( String . format ( " Failed to resolve mods directory mods % s " , modsDir . getAbsolutePath ( ) ) ) ; <nl> + LOG . throwing ( " fml . server . Loader " , " initialize " , ioe ) ; <nl> + throw new LoaderException ( ioe ) ; <nl> + } <nl> + if ( ! modsDir . exists ( ) ) { <nl> + LOG . fine ( String . format ( " No mod directory found , creating one : % s " , canonicalModsPath ) ) ; <nl> + try { <nl> + modsDir . mkdir ( ) ; <nl> + } catch ( Exception e ) { <nl> + LOG . throwing ( " fml . server . Loader " , " initialize " , e ) ; <nl> + throw new LoaderException ( e ) ; <nl> + } <nl> + } <nl> + if ( ! modsDir . isDirectory ( ) ) { <nl> + LOG . severe ( String . format ( " Attempting to load mods from % s , which is not a directory " , canonicalModsPath ) ) ; <nl> + LoaderException loaderException = new LoaderException ( ) ; <nl> + LOG . throwing ( " fml . server . Loader " , " initialize " , loaderException ) ; <nl> + throw loaderException ; <nl> + } <nl> + File [ ] modList = modsDir . listFiles ( ) ; <nl> + / / Sort the files into alphabetical order first <nl> + Arrays . sort ( modList ) ; <nl> + <nl> + state = State . LOADING ; <nl> + for ( File modFile : modList ) { <nl> + if ( modFile . isDirectory ( ) ) { <nl> + LOG . info ( String . format ( " Found directory % s . Attempting load " , modFile . getName ( ) ) ) ; <nl> + attemptDirLoad ( modFile ) ; <nl> + } else { <nl> + Matcher matcher = zipJar . matcher ( modFile . getName ( ) ) ; <nl> + if ( matcher . find ( ) ) { <nl> + LOG . info ( String . format ( " Found zip or jar file % s . Attempting load . " , matcher . group ( 0 ) ) ) ; <nl> + attemptFileLoad ( modFile ) ; <nl> + } <nl> + } <nl> + } <nl> + if ( state = = State . ERRORED ) { <nl> + LOG . severe ( " A problem has occured during mod loading . Giving up now " ) ; <nl> + throw new RuntimeException ( " Giving up please " ) ; <nl> + } <nl> + } <nl> + <nl> + private void attemptDirLoad ( File modDir ) { <nl> + extendClassLoader ( modDir ) ; <nl> + <nl> + File [ ] content = modDir . listFiles ( new FilenameFilter ( ) { <nl> + @ Override <nl> + public boolean accept ( File dir , String name ) { <nl> + return modClass . matcher ( name ) . find ( ) ; <nl> + } <nl> + } ) ; <nl> + for ( File modClassFile : content ) { <nl> + LOG . fine ( String . format ( " Found a mod class % s in directory % s . Attempting to load it " , modClassFile . getName ( ) , modDir . getName ( ) ) ) ; <nl> + String clazzName = modClass . matcher ( modClassFile . getName ( ) ) . group ( 2 ) ; <nl> + loadModClass ( modDir , modClassFile . getName ( ) , clazzName ) ; <nl> + LOG . fine ( String . format ( " Successfully loaded mod class % s " , modClassFile . getName ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void loadModClass ( File classSource , String classFileName , String clazzName ) { <nl> + try { <nl> + Class < ? > clazz = Class . forName ( clazzName , true , modClassLoader ) ; <nl> + if ( clazz . isAnnotationPresent ( Mod . class ) ) { <nl> + / / an FML mod <nl> + mods . add ( FMLModContainer . buildFor ( clazz ) ) ; <nl> + } else if ( clazz . isAssignableFrom ( BaseMod . class ) ) { <nl> + / / a modloader mod <nl> + } else { <nl> + / / Unrecognized <nl> + } <nl> + } catch ( ClassNotFoundException e ) { <nl> + LOG . warning ( String . format ( " Failed to load mod class % s in % s " , classFileName , classSource . getName ( ) ) ) ; <nl> + LOG . throwing ( " fml . server . Loader " , " attemptDirLoad " , e ) ; <nl> + state = State . ERRORED ; <nl> + } <nl> + } <nl> + <nl> + private void extendClassLoader ( File file ) { <nl> + if ( modClassLoader = = null ) { <nl> + modClassLoader = new ModClassLoader ( ) ; <nl> + } <nl> + try { <nl> + modClassLoader . addFile ( file ) ; <nl> + } catch ( MalformedURLException e ) { <nl> + throw new LoaderException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + private void attemptFileLoad ( File modFile ) { <nl> + extendClassLoader ( modFile ) ; <nl> + <nl> + try { <nl> + ZipFile jar = new ZipFile ( modFile ) ; <nl> + for ( ZipEntry ze : Collections . list ( jar . entries ( ) ) ) { <nl> + Matcher match = modClass . matcher ( ze . getName ( ) ) ; <nl> + if ( match . find ( ) ) { <nl> + String pkg = match . group ( 1 ) . replace ( ' / ' , ' . ' ) ; <nl> + String clazzName = pkg + match . group ( 2 ) ; <nl> + loadModClass ( modFile , ze . getName ( ) , clazzName ) ; <nl> + } <nl> + } <nl> + } catch ( Exception e ) { <nl> + LOG . warning ( String . format ( " Zip file % s failed to read properly " , modFile . getName ( ) ) ) ; <nl> + LOG . throwing ( " fml . server . Loader " , " attemptFileLoad " , e ) ; <nl> + state = State . ERRORED ; <nl> + } <nl> + } <nl> + <nl> + class LoaderException extends RuntimeException { <nl> + public LoaderException ( Exception wrapped ) { <nl> + super ( wrapped ) ; <nl> + } <nl> + <nl> + public LoaderException ( ) { <nl> + } <nl> + } <nl> + } <nl> diff - - git a / fml / src / fml / server / ModClassLoader . java b / fml / src / fml / server / ModClassLoader . java <nl> new file mode 100644 <nl> index 0000000 . . 051c074 <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / ModClassLoader . java <nl> @ @ - 0 , 0 + 1 , 18 @ @ <nl> + package fml . server ; <nl> + <nl> + import java . io . File ; <nl> + import java . net . MalformedURLException ; <nl> + import java . net . URL ; <nl> + import java . net . URLClassLoader ; <nl> + <nl> + public class ModClassLoader extends URLClassLoader { <nl> + <nl> + public ModClassLoader ( ) { <nl> + super ( new URL [ 0 ] ) ; <nl> + } <nl> + <nl> + public void addFile ( File modFile ) throws MalformedURLException { <nl> + URL url = modFile . toURI ( ) . toURL ( ) ; <nl> + super . addURL ( url ) ; <nl> + } <nl> + } <nl> diff - - git a / fml / src / fml / server / ModContainer . java b / fml / src / fml / server / ModContainer . java <nl> new file mode 100644 <nl> index 0000000 . . 344806d <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / ModContainer . java <nl> @ @ - 0 , 0 + 1 , 9 @ @ <nl> + package fml . server ; <nl> + <nl> + public interface ModContainer { <nl> + boolean wantsPreInit ( ) ; <nl> + boolean wantsPostInit ( ) ; <nl> + void preInit ( ) ; <nl> + void init ( ) ; <nl> + void postInit ( ) ; <nl> + } <nl> diff - - git a / fml / src / fml / server / ModLoaderModContainer . java b / fml / src / fml / server / ModLoaderModContainer . java <nl> new file mode 100644 <nl> index 0000000 . . 69c3138 <nl> - - - / dev / null <nl> + + + b / fml / src / fml / server / ModLoaderModContainer . java <nl> @ @ - 0 , 0 + 1 , 30 @ @ <nl> + package fml . server ; <nl> + <nl> + public class ModLoaderModContainer implements ModContainer { <nl> + public boolean wantsPreInit ( ) { <nl> + return false ; <nl> + } <nl> + <nl> + public boolean wantsPostInit ( ) { <nl> + return false ; <nl> + } <nl> + <nl> + @ Override <nl> + public void preInit ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void init ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void postInit ( ) { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + } <nl> diff - - git a / fml / src / fml / stubs / mcpserver / BaseMod . java b / fml / src / fml / stubs / mcpserver / BaseMod . java <nl> index f0519c7 . . ebb6d07 100644 <nl> - - - a / fml / src / fml / stubs / mcpserver / BaseMod . java <nl> + + + b / fml / src / fml / stubs / mcpserver / BaseMod . java <nl> @ @ - 2 , 12 + 2 , 16 @ @ package fml . stubs . mcpserver ; <nl> <nl> import java . util . Random ; <nl> <nl> + import fml . Mod ; <nl> + <nl> + <nl> import net . minecraft . src . EntityPlayer ; <nl> import net . minecraft . src . IInventory ; <nl> import net . minecraft . src . ItemStack ; <nl> import net . minecraft . src . Packet250CustomPayload ; <nl> import net . minecraft . src . World ; <nl> <nl> + @ Mod ( name = " blah " , version = " blah " ) <nl> public interface BaseMod { <nl> int addFuel ( int id , int metadata ) ; <nl> <nl> @ @ - 25 , 8 + 29 , 10 @ @ public interface BaseMod { <nl> abstract String getVersion ( ) ; <nl> <nl> / / void keyboardEvent ( KeyBinding event ) ; <nl> + @ Mod . PreInit <nl> abstract void load ( ) ; <nl> <nl> + @ Mod . Init <nl> void modsLoaded ( ) ; <nl> <nl> void onItemPickup ( EntityPlayer player , ItemStack item ) ;

TEST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java b / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java 
 index 3422b9a . . 8fb3745 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java 
 + + + b / fml / src / main / java / cpw / mods / fml / client / SplashProgress . java 
 @ @ - 45 , 6 + 45 , 7 @ @ public class SplashProgress 
 private static volatile boolean pause = false ; 
 private static volatile boolean done = false ; 
 private static Thread thread ; 
 + private static volatile Throwable threadError ; 
 private static int angle = 0 ; 
 private static final Lock lock = new ReentrantLock ( true ) ; 
 private static SplashFontRenderer fontRenderer ; 
 @ @ - 322 , 12 + 323 , 20 @ @ public class SplashProgress 
 public void uncaughtException ( Thread t , Throwable e ) 
 { 
 FMLLog . log ( Level . ERROR , e , " Splash thread Exception " ) ; 
 - Minecraft . getMinecraft ( ) . crashed ( CrashReport . makeCrashReport ( e , " Splash thread " ) ) ; 
 + threadError = e ; 
 } 
 } ) ; 
 thread . start ( ) ; 
 + checkThreadState ( ) ; 
 } 
 
 + private static void checkThreadState ( ) 
 + { 
 + if ( thread . getState ( ) = = Thread . State . TERMINATED | | threadError ! = null ) 
 + { 
 + throw new IllegalStateException ( " Splash thread " , threadError ) ; 
 + } 
 + } 
 / * * 
 * Call before you need to explicitly modify GL context state during loading . 
 * Resource loading doesn ' t usually require this call . 
 @ @ - 338 , 6 + 347 , 7 @ @ public class SplashProgress 
 public static void pause ( ) 
 { 
 if ( ! enabled ) return ; 
 + checkThreadState ( ) ; 
 pause = true ; 
 lock . lock ( ) ; 
 try 
 @ @ - 359 , 6 + 369 , 7 @ @ public class SplashProgress 
 public static void resume ( ) 
 { 
 if ( ! enabled ) return ; 
 + checkThreadState ( ) ; 
 pause = false ; 
 try 
 { 
 @ @ - 376 , 6 + 387 , 7 @ @ public class SplashProgress 
 public static void finish ( ) 
 { 
 if ( ! enabled ) return ; 
 + checkThreadState ( ) ; 
 try 
 { 
 done = true ;

NEAREST DIFF:
diff - - git a / fml / src / fml / Mod . java b / fml / src / fml / Mod . java 
 new file mode 100644 
 index 0000000 . . ae98b0c 
 - - - / dev / null 
 + + + b / fml / src / fml / Mod . java 
 @ @ - 0 , 0 + 1 , 15 @ @ 
 + package fml ; 
 + 
 + import java . lang . annotation . Retention ; 
 + import java . lang . annotation . RetentionPolicy ; 
 + 
 + @ Retention ( RetentionPolicy . RUNTIME ) 
 + public @ interface Mod { 
 + String name ( ) default " " ; 
 + String version ( ) default " " ; 
 + boolean wantsPreInit ( ) default false ; 
 + boolean wantsPostInit ( ) default false ; 
 + public @ interface PreInit { } 
 + public @ interface Init { } 
 + public @ interface PostInit { } 
 + } 
 diff - - git a / fml / src / fml / server / FMLModContainer . java b / fml / src / fml / server / FMLModContainer . java 
 new file mode 100644 
 index 0000000 . . dbd483a 
 - - - / dev / null 
 + + + b / fml / src / fml / server / FMLModContainer . java 
 @ @ - 0 , 0 + 1 , 49 @ @ 
 + package fml . server ; 
 + 
 + import fml . Mod ; 
 + 
 + public class FMLModContainer implements ModContainer { 
 + private Mod modDescriptor ; 
 + private Object modInstance ; 
 + public FMLModContainer ( Class < ? > clazz ) { 
 + modDescriptor = clazz . getAnnotation ( Mod . class ) ; 
 + 
 + try { 
 + modInstance = clazz . newInstance ( ) ; 
 + } catch ( Exception e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public boolean wantsPreInit ( ) { 
 + return modDescriptor . wantsPreInit ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean wantsPostInit ( ) { 
 + return modDescriptor . wantsPostInit ( ) ; 
 + } 
 + 
 + @ Override 
 + public void preInit ( ) { 
 + 
 + } 
 + 
 + @ Override 
 + public void init ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + @ Override 
 + public void postInit ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + public static ModContainer buildFor ( Class < ? > clazz ) { 
 + return new FMLModContainer ( clazz ) ; 
 + } 
 + 
 + } 
 diff - - git a / fml / src / fml / server / Loader . java b / fml / src / fml / server / Loader . java 
 new file mode 100644 
 index 0000000 . . 5b289f0 
 - - - / dev / null 
 + + + b / fml / src / fml / server / Loader . java 
 @ @ - 0 , 0 + 1 , 193 @ @ 
 + package fml . server ; 
 + 
 + import java . io . File ; 
 + import java . io . FilenameFilter ; 
 + import java . io . IOException ; 
 + import java . net . MalformedURLException ; 
 + import java . util . Arrays ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 + import java . util . logging . Logger ; 
 + import java . util . regex . Matcher ; 
 + import java . util . regex . Pattern ; 
 + import java . util . zip . ZipEntry ; 
 + import java . util . zip . ZipFile ; 
 + 
 + import fml . Mod ; 
 + import fml . stubs . mcpserver . BaseMod ; 
 + 
 + public class Loader { 
 + private enum State { NOINIT , LOADING , PREINIT , INIT , POSTINIT , UP , ERRORED } ; 
 + private static State state ; 
 + private static Logger LOG = Logger . getLogger ( " ForgeModLoader . Loader " ) ; 
 + 
 + private static List < ModContainer > mods ; 
 + 
 + private static ModClassLoader modClassLoader ; 
 + 
 + private static Pattern zipJar = Pattern . compile ( " ( [ \ \ w ] + ) . ( zip | jar ) $ " ) ; 
 + private static Pattern modClass = Pattern . compile ( " ( . * ) ( mod _ [ ^ \ \ s ] + ) \ \ . class $ " ) ; 
 + 
 + public static Loader instance ; 
 + 
 + public static void run ( ) { 
 + instance = new Loader ( ) ; 
 + } 
 + 
 + private Loader ( ) { 
 + state = State . NOINIT ; 
 + load ( ) ; 
 + preModInit ( ) ; 
 + modInit ( ) ; 
 + postModInit ( ) ; 
 + state = State . UP ; 
 + } 
 + 
 + private void preModInit ( ) { 
 + state = State . PREINIT ; 
 + for ( ModContainer mod : mods ) { 
 + if ( mod . wantsPreInit ( ) ) { 
 + mod . preInit ( ) ; 
 + } 
 + } 
 + } 
 + 
 + private void modInit ( ) { 
 + state = State . INIT ; 
 + for ( ModContainer mod : mods ) { 
 + mod . init ( ) ; 
 + } 
 + } 
 + 
 + private void postModInit ( ) { 
 + state = State . POSTINIT ; 
 + for ( ModContainer mod : mods ) { 
 + if ( mod . wantsPostInit ( ) ) { 
 + mod . postInit ( ) ; 
 + } 
 + } 
 + } 
 + 
 + private void load ( ) { 
 + File modsDir = new File ( " . " , " mods " ) ; 
 + String canonicalModsPath ; 
 + try { 
 + canonicalModsPath = modsDir . getCanonicalPath ( ) ; 
 + } catch ( IOException ioe ) { 
 + LOG . severe ( String . format ( " Failed to resolve mods directory mods % s " , modsDir . getAbsolutePath ( ) ) ) ; 
 + LOG . throwing ( " fml . server . Loader " , " initialize " , ioe ) ; 
 + throw new LoaderException ( ioe ) ; 
 + } 
 + if ( ! modsDir . exists ( ) ) { 
 + LOG . fine ( String . format ( " No mod directory found , creating one : % s " , canonicalModsPath ) ) ; 
 + try { 
 + modsDir . mkdir ( ) ; 
 + } catch ( Exception e ) { 
 + LOG . throwing ( " fml . server . Loader " , " initialize " , e ) ; 
 + throw new LoaderException ( e ) ; 
 + } 
 + } 
 + if ( ! modsDir . isDirectory ( ) ) { 
 + LOG . severe ( String . format ( " Attempting to load mods from % s , which is not a directory " , canonicalModsPath ) ) ; 
 + LoaderException loaderException = new LoaderException ( ) ; 
 + LOG . throwing ( " fml . server . Loader " , " initialize " , loaderException ) ; 
 + throw loaderException ; 
 + } 
 + File [ ] modList = modsDir . listFiles ( ) ; 
 + / / Sort the files into alphabetical order first 
 + Arrays . sort ( modList ) ; 
 + 
 + state = State . LOADING ; 
 + for ( File modFile : modList ) { 
 + if ( modFile . isDirectory ( ) ) { 
 + LOG . info ( String . format ( " Found directory % s . Attempting load " , modFile . getName ( ) ) ) ; 
 + attemptDirLoad ( modFile ) ; 
 + } else { 
 + Matcher matcher = zipJar . matcher ( modFile . getName ( ) ) ; 
 + if ( matcher . find ( ) ) { 
 + LOG . info ( String . format ( " Found zip or jar file % s . Attempting load . " , matcher . group ( 0 ) ) ) ; 
 + attemptFileLoad ( modFile ) ; 
 + } 
 + } 
 + } 
 + if ( state = = State . ERRORED ) { 
 + LOG . severe ( " A problem has occured during mod loading . Giving up now " ) ; 
 + throw new RuntimeException ( " Giving up please " ) ; 
 + } 
 + } 
 + 
 + private void attemptDirLoad ( File modDir ) { 
 + extendClassLoader ( modDir ) ; 
 + 
 + File [ ] content = modDir . listFiles ( new FilenameFilter ( ) { 
 + @ Override 
 + public boolean accept ( File dir , String name ) { 
 + return modClass . matcher ( name ) . find ( ) ; 
 + } 
 + } ) ; 
 + for ( File modClassFile : content ) { 
 + LOG . fine ( String . format ( " Found a mod class % s in directory % s . Attempting to load it " , modClassFile . getName ( ) , modDir . getName ( ) ) ) ; 
 + String clazzName = modClass . matcher ( modClassFile . getName ( ) ) . group ( 2 ) ; 
 + loadModClass ( modDir , modClassFile . getName ( ) , clazzName ) ; 
 + LOG . fine ( String . format ( " Successfully loaded mod class % s " , modClassFile . getName ( ) ) ) ; 
 + } 
 + } 
 + 
 + private void loadModClass ( File classSource , String classFileName , String clazzName ) { 
 + try { 
 + Class < ? > clazz = Class . forName ( clazzName , true , modClassLoader ) ; 
 + if ( clazz . isAnnotationPresent ( Mod . class ) ) { 
 + / / an FML mod 
 + mods . add ( FMLModContainer . buildFor ( clazz ) ) ; 
 + } else if ( clazz . isAssignableFrom ( BaseMod . class ) ) { 
 + / / a modloader mod 
 + } else { 
 + / / Unrecognized 
 + } 
 + } catch ( ClassNotFoundException e ) { 
 + LOG . warning ( String . format ( " Failed to load mod class % s in % s " , classFileName , classSource . getName ( ) ) ) ; 
 + LOG . throwing ( " fml . server . Loader " , " attemptDirLoad " , e ) ; 
 + state = State . ERRORED ; 
 + } 
 + } 
 + 
 + private void extendClassLoader ( File file ) { 
 + if ( modClassLoader = = null ) { 
 + modClassLoader = new ModClassLoader ( ) ; 
 + } 
 + try { 
 + modClassLoader . addFile ( file ) ; 
 + } catch ( MalformedURLException e ) { 
 + throw new LoaderException ( e ) ; 
 + } 
 + } 
 + 
 + private void attemptFileLoad ( File modFile ) { 
 + extendClassLoader ( modFile ) ; 
 + 
 + try { 
 + ZipFile jar = new ZipFile ( modFile ) ; 
 + for ( ZipEntry ze : Collections . list ( jar . entries ( ) ) ) { 
 + Matcher match = modClass . matcher ( ze . getName ( ) ) ; 
 + if ( match . find ( ) ) { 
 + String pkg = match . group ( 1 ) . replace ( ' / ' , ' . ' ) ; 
 + String clazzName = pkg + match . group ( 2 ) ; 
 + loadModClass ( modFile , ze . getName ( ) , clazzName ) ; 
 + } 
 + } 
 + } catch ( Exception e ) { 
 + LOG . warning ( String . format ( " Zip file % s failed to read properly " , modFile . getName ( ) ) ) ; 
 + LOG . throwing ( " fml . server . Loader " , " attemptFileLoad " , e ) ; 
 + state = State . ERRORED ; 
 + } 
 + } 
 + 
 + class LoaderException extends RuntimeException { 
 + public LoaderException ( Exception wrapped ) { 
 + super ( wrapped ) ; 
 + } 
 + 
 + public LoaderException ( ) { 
 + } 
 + } 
 + } 
 diff - - git a / fml / src / fml / server / ModClassLoader . java b / fml / src / fml / server / ModClassLoader . java 
 new file mode 100644 
 index 0000000 . . 051c074 
 - - - / dev / null 
 + + + b / fml / src / fml / server / ModClassLoader . java 
 @ @ - 0 , 0 + 1 , 18 @ @ 
 + package fml . server ; 
 + 
 + import java . io . File ; 
 + import java . net . MalformedURLException ; 
 + import java . net . URL ; 
 + import java . net . URLClassLoader ; 
 + 
 + public class ModClassLoader extends URLClassLoader { 
 + 
 + public ModClassLoader ( ) { 
 + super ( new URL [ 0 ] ) ; 
 + } 
 + 
 + public void addFile ( File modFile ) throws MalformedURLException { 
 + URL url = modFile . toURI ( ) . toURL ( ) ; 
 + super . addURL ( url ) ; 
 + } 
 + } 
 diff - - git a / fml / src / fml / server / ModContainer . java b / fml / src / fml / server / ModContainer . java 
 new file mode 100644 
 index 0000000 . . 344806d 
 - - - / dev / null 
 + + + b / fml / src / fml / server / ModContainer . java 
 @ @ - 0 , 0 + 1 , 9 @ @ 
 + package fml . server ; 
 + 
 + public interface ModContainer { 
 + boolean wantsPreInit ( ) ; 
 + boolean wantsPostInit ( ) ; 
 + void preInit ( ) ; 
 + void init ( ) ; 
 + void postInit ( ) ; 
 + } 
 diff - - git a / fml / src / fml / server / ModLoaderModContainer . java b / fml / src / fml / server / ModLoaderModContainer . java 
 new file mode 100644 
 index 0000000 . . 69c3138 
 - - - / dev / null 
 + + + b / fml / src / fml / server / ModLoaderModContainer . java 
 @ @ - 0 , 0 + 1 , 30 @ @ 
 + package fml . server ; 
 + 
 + public class ModLoaderModContainer implements ModContainer { 
 + public boolean wantsPreInit ( ) { 
 + return false ; 
 + } 
 + 
 + public boolean wantsPostInit ( ) { 
 + return false ; 
 + } 
 + 
 + @ Override 
 + public void preInit ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + @ Override 
 + public void init ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + @ Override 
 + public void postInit ( ) { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + } 
 diff - - git a / fml / src / fml / stubs / mcpserver / BaseMod . java b / fml / src / fml / stubs / mcpserver / BaseMod . java 
 index f0519c7 . . ebb6d07 100644 
 - - - a / fml / src / fml / stubs / mcpserver / BaseMod . java 
 + + + b / fml / src / fml / stubs / mcpserver / BaseMod . java 
 @ @ - 2 , 12 + 2 , 16 @ @ package fml . stubs . mcpserver ; 
 
 import java . util . Random ; 
 
 + import fml . Mod ; 
 + 
 + 
 import net . minecraft . src . EntityPlayer ; 
 import net . minecraft . src . IInventory ; 
 import net . minecraft . src . ItemStack ; 
 import net . minecraft . src . Packet250CustomPayload ; 
 import net . minecraft . src . World ; 
 
 + @ Mod ( name = " blah " , version = " blah " ) 
 public interface BaseMod { 
 int addFuel ( int id , int metadata ) ; 
 
 @ @ - 25 , 8 + 29 , 10 @ @ public interface BaseMod { 
 abstract String getVersion ( ) ; 
 
 / / void keyboardEvent ( KeyBinding event ) ; 
 + @ Mod . PreInit 
 abstract void load ( ) ; 
 
 + @ Mod . Init 
 void modsLoaded ( ) ; 
 
 void onItemPickup ( EntityPlayer player , ItemStack item ) ;
