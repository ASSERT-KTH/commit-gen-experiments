BLEU SCORE: 0.017928600661603712

TEST MSG: Initial implementation of JSON based annotation scanning .
GENERATED MSG: Create custom shapeless recipe matching system . Should solve # 4516 damageable items in shapeless recipes .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / JarDiscoverer . java b / src / main / java / net / minecraftforge / fml / common / discovery / JarDiscoverer . java <nl> index 4fd756e . . b825e96 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / discovery / JarDiscoverer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / discovery / JarDiscoverer . java <nl> @ @ - 19 , 9 + 19 , 12 @ @ <nl> <nl> package net . minecraftforge . fml . common . discovery ; <nl> <nl> + import java . io . IOException ; <nl> import java . io . InputStream ; <nl> + import java . lang . reflect . Constructor ; <nl> import java . util . Collections ; <nl> import java . util . List ; <nl> + import java . util . Map . Entry ; <nl> import java . util . jar . JarFile ; <nl> <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> @ @ - 29 , 18 + 32 , 22 @ @ import net . minecraftforge . fml . common . LoaderException ; <nl> import net . minecraftforge . fml . common . MetadataCollection ; <nl> import net . minecraftforge . fml . common . ModContainer ; <nl> import net . minecraftforge . fml . common . ModContainerFactory ; <nl> + import net . minecraftforge . fml . common . discovery . ASMDataTable . ASMData ; <nl> import net . minecraftforge . fml . common . discovery . asm . ASMModParser ; <nl> - <nl> - import org . apache . commons . io . IOUtils ; <nl> - import org . apache . logging . log4j . Level ; <nl> + import net . minecraftforge . fml . common . discovery . json . JsonAnnotationLoader ; <nl> <nl> import java . util . regex . Matcher ; <nl> import java . util . zip . ZipEntry ; <nl> <nl> + import org . objectweb . asm . Type ; <nl> + <nl> import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Multimap ; <nl> <nl> public class JarDiscoverer implements ITypeDiscoverer <nl> { <nl> + private static final boolean ENABLE _ JSON _ TEST = " true " . equals ( System . getProperty ( " fml . enableJsonAnnotations " , " false " ) ) ; <nl> + <nl> @ Override <nl> public List < ModContainer > discover ( ModCandidate candidate , ASMDataTable table ) <nl> { <nl> @ @ - 63 , 48 + 70 , 91 @ @ public class JarDiscoverer implements ITypeDiscoverer <nl> FMLLog . log . debug ( " The mod container { } appears to be missing an mcmod . info file " , candidate . getModContainer ( ) . getName ( ) ) ; <nl> mc = MetadataCollection . from ( null , " " ) ; <nl> } <nl> - for ( ZipEntry ze : Collections . list ( jar . entries ( ) ) ) <nl> + <nl> + if ( ENABLE _ JSON _ TEST & & jar . getEntry ( JsonAnnotationLoader . ANNOTATION _ JSON ) ! = null ) <nl> + findClassesJSON ( candidate , table , jar , foundMods , mc ) ; <nl> + else <nl> + findClassesASM ( candidate , table , jar , foundMods , mc ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + FMLLog . log . warn ( " Zip file { } failed to read properly , it will be ignored " , candidate . getModContainer ( ) . getName ( ) , e ) ; <nl> + } <nl> + return foundMods ; <nl> + } <nl> + <nl> + private void findClassesASM ( ModCandidate candidate , ASMDataTable table , JarFile jar , List < ModContainer > foundMods , MetadataCollection mc ) throws IOException <nl> + { <nl> + for ( ZipEntry ze : Collections . list ( jar . entries ( ) ) ) <nl> + { <nl> + if ( ze . getName ( ) ! = null & & ze . getName ( ) . startsWith ( " _ _ MACOSX " ) ) <nl> + { <nl> + continue ; <nl> + } <nl> + Matcher match = classFile . matcher ( ze . getName ( ) ) ; <nl> + if ( match . matches ( ) ) <nl> { <nl> - if ( ze . getName ( ) ! = null & & ze . getName ( ) . startsWith ( " _ _ MACOSX " ) ) <nl> + ASMModParser modParser ; <nl> + try <nl> { <nl> - continue ; <nl> - } <nl> - Matcher match = classFile . matcher ( ze . getName ( ) ) ; <nl> - if ( match . matches ( ) ) <nl> - { <nl> - ASMModParser modParser ; <nl> - try <nl> - { <nl> - try ( InputStream inputStream = jar . getInputStream ( ze ) ) <nl> - { <nl> - modParser = new ASMModParser ( inputStream ) ; <nl> - } <nl> - candidate . addClassEntry ( ze . getName ( ) ) ; <nl> - } <nl> - catch ( LoaderException e ) <nl> - { <nl> - FMLLog . log . error ( " There was a problem reading the entry { } in the jar { } - probably a corrupt zip " , candidate . getModContainer ( ) . getPath ( ) , e ) ; <nl> - jar . close ( ) ; <nl> - throw e ; <nl> - } <nl> - modParser . validate ( ) ; <nl> - modParser . sendToTable ( table , candidate ) ; <nl> - ModContainer container = ModContainerFactory . instance ( ) . build ( modParser , candidate . getModContainer ( ) , candidate ) ; <nl> - if ( container ! = null ) <nl> + try ( InputStream inputStream = jar . getInputStream ( ze ) ) <nl> { <nl> - table . addContainer ( container ) ; <nl> - foundMods . add ( container ) ; <nl> - container . bindMetadata ( mc ) ; <nl> - container . setClassVersion ( modParser . getClassVersion ( ) ) ; <nl> + modParser = new ASMModParser ( inputStream ) ; <nl> } <nl> + candidate . addClassEntry ( ze . getName ( ) ) ; <nl> + } <nl> + catch ( LoaderException e ) <nl> + { <nl> + FMLLog . log . error ( " There was a problem reading the entry { } in the jar { } - probably a corrupt zip " , candidate . getModContainer ( ) . getPath ( ) , e ) ; <nl> + jar . close ( ) ; <nl> + throw e ; <nl> + } <nl> + modParser . validate ( ) ; <nl> + modParser . sendToTable ( table , candidate ) ; <nl> + ModContainer container = ModContainerFactory . instance ( ) . build ( modParser , candidate . getModContainer ( ) , candidate ) ; <nl> + if ( container ! = null ) <nl> + { <nl> + table . addContainer ( container ) ; <nl> + foundMods . add ( container ) ; <nl> + container . bindMetadata ( mc ) ; <nl> + container . setClassVersion ( modParser . getClassVersion ( ) ) ; <nl> } <nl> } <nl> } <nl> - catch ( Exception e ) <nl> + } <nl> + <nl> + private void findClassesJSON ( ModCandidate candidate , ASMDataTable table , JarFile jar , List < ModContainer > foundMods , MetadataCollection mc ) throws IOException <nl> + { <nl> + FMLLog . log . info ( " Loading jar { } annotation data from json " , candidate . getModContainer ( ) . getPath ( ) ) ; <nl> + ZipEntry json = jar . getEntry ( JsonAnnotationLoader . ANNOTATION _ JSON ) ; <nl> + Multimap < String , ASMData > annos = JsonAnnotationLoader . loadJson ( jar . getInputStream ( json ) , candidate , table ) ; <nl> + <nl> + for ( Entry < Type , Constructor < ? extends ModContainer > > entry : ModContainerFactory . modTypes . entrySet ( ) ) <nl> { <nl> - FMLLog . log . warn ( " Zip file { } failed to read properly , it will be ignored " , candidate . getModContainer ( ) . getName ( ) , e ) ; <nl> + Type type = entry . getKey ( ) ; <nl> + Constructor < ? extends ModContainer > ctr = entry . getValue ( ) ; <nl> + <nl> + for ( ASMData data : annos . get ( type . getClassName ( ) ) ) <nl> + { <nl> + FMLLog . log . debug ( " Identified a mod of type { } ( { } ) - loading " , type . getClassName ( ) , data . getClassName ( ) ) ; <nl> + try <nl> + { <nl> + ModContainer ret = ctr . newInstance ( data . getClassName ( ) , candidate , data . getAnnotationInfo ( ) ) ; <nl> + if ( ! ret . shouldLoadInEnvironment ( ) ) <nl> + FMLLog . log . debug ( " Skipping mod { } , container opted to not load . " , data . getClassName ( ) ) ; <nl> + else <nl> + { <nl> + table . addContainer ( ret ) ; <nl> + foundMods . add ( ret ) ; <nl> + ret . bindMetadata ( mc ) ; <nl> + / / ret . setClassVersion ( classVersion ) ; / / Not really needed anymore as we ' re forcing J8 . Maybe think of reinstating for J9 support ? After LaunchWraper re - do . <nl> + } <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + FMLLog . log . error ( " Unable to construct { } container " , data . getClassName ( ) , e ) ; <nl> + } <nl> + } <nl> } <nl> - return foundMods ; <nl> } <nl> - <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java b / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java <nl> index 4c18d8b . . 0720f3b 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java <nl> @ @ - 107 , 6 + 107 , 7 @ @ public class ModDiscoverer <nl> } <nl> else if ( modFile . isDirectory ( ) ) <nl> { <nl> + / / TODO Remove in 1 . 13 + Mods should never be directory based anymore . <nl> FMLLog . log . debug ( " Found a candidate mod directory { } " , modFile . getName ( ) ) ; <nl> addCandidate ( new ModCandidate ( modFile , modFile , ContainerType . DIR ) ) ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / asm / ModAnnotation . java b / src / main / java / net / minecraftforge / fml / common / discovery / asm / ModAnnotation . java <nl> index 1279368 . . 5bbafc8 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / discovery / asm / ModAnnotation . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / discovery / asm / ModAnnotation . java <nl> @ @ - 32 , 7 + 32 , 7 @ @ import com . google . common . collect . Maps ; <nl> <nl> public class ModAnnotation <nl> { <nl> - public class EnumHolder <nl> + public static class EnumHolder <nl> { <nl> private final String desc ; <nl> private final String value ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / json / ASMInfo . java b / src / main / java / net / minecraftforge / fml / common / discovery / json / ASMInfo . java <nl> new file mode 100644 <nl> index 0000000 . . bd8019a <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / common / discovery / json / ASMInfo . java <nl> @ @ - 0 , 0 + 1 , 165 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2018 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package net . minecraftforge . fml . common . discovery . json ; <nl> + <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . function . Function ; <nl> + <nl> + import org . apache . commons . lang3 . Validate ; <nl> + import org . objectweb . asm . Type ; <nl> + <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Maps ; <nl> + <nl> + import net . minecraftforge . fml . common . FMLLog ; <nl> + import net . minecraftforge . fml . common . discovery . asm . ModAnnotation . EnumHolder ; <nl> + <nl> + / / Package private , modders shouldn ' t access this . Do it through ASMDataTable . <nl> + class ASMInfo <nl> + { <nl> + String name ; <nl> + String [ ] interfaces ; <nl> + List < Annotation > annotations ; <nl> + private Map < Integer , Annotation > byID ; <nl> + <nl> + public Annotation getSubAnnotation ( int id ) <nl> + { <nl> + if ( byID = = null ) <nl> + { <nl> + byID = Maps . newHashMap ( ) ; <nl> + annotations . forEach ( a - > { if ( a . id ! = null ) byID . put ( a . id , a ) ; } ) ; <nl> + } <nl> + return byID . get ( id ) ; <nl> + } <nl> + <nl> + public enum TargetType { CLASS , FIELD , METHOD , SUBTYPE } ; <nl> + public enum ValueType <nl> + { <nl> + BOOL ( Boolean : : valueOf , v - > { boolean [ ] ret = new boolean [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Boolean . parseBoolean ( v [ x ] ) ; return ret ; } ) , <nl> + BYTE ( Byte : : valueOf , v - > { byte [ ] ret = new byte [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Byte . parseByte ( v [ x ] ) ; return ret ; } ) , <nl> + CHAR ( x - > x . charAt ( 0 ) , v - > { char [ ] ret = new char [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = v [ x ] . charAt ( 0 ) ; return ret ; } ) , <nl> + SHORT ( Short : : valueOf , v - > { short [ ] ret = new short [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Short . parseShort ( v [ x ] ) ; return ret ; } ) , <nl> + INT ( Integer : : valueOf , v - > { int [ ] ret = new int [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Integer . parseInt ( v [ x ] ) ; return ret ; } ) , <nl> + LONG ( Long : : valueOf , v - > { long [ ] ret = new long [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Long . parseLong ( v [ x ] ) ; return ret ; } ) , <nl> + FLOAT ( Float : : valueOf , v - > { float [ ] ret = new float [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Float . parseFloat ( v [ x ] ) ; return ret ; } ) , <nl> + DOUBLE ( Double : : valueOf , v - > { double [ ] ret = new double [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Double . parseDouble ( v [ x ] ) ; return ret ; } ) , <nl> + STRING ( x - > x , x - > x ) , <nl> + CLASS ( Type : : getType , v - > { Type [ ] ret = new Type [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Type . getType ( v [ x ] ) ; return ret ; } ) , <nl> + ENUM ( ValueType : : getEnumHolder , v - > { EnumHolder [ ] ret = new EnumHolder [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = ValueType . getEnumHolder ( v [ x ] ) ; return ret ; } ) , <nl> + ANNOTATION ( null , null ) , <nl> + NULL ( x - > null , x - > null ) ; <nl> + <nl> + public final Function < String , Object > single ; <nl> + public final Function < String [ ] , Object > array ; <nl> + <nl> + private ValueType ( Function < String , Object > single , Function < String [ ] , Object > array ) <nl> + { <nl> + this . single = single ; <nl> + this . array = array ; <nl> + } <nl> + <nl> + private static EnumHolder getEnumHolder ( String value ) <nl> + { <nl> + int idx = value . lastIndexOf ( ' / ' ) ; <nl> + if ( idx < = 1 ) <nl> + throw new IllegalArgumentException ( " Can not create a EnumHolder for value : " + value ) ; <nl> + return new EnumHolder ( value . substring ( 0 , idx - 1 ) , value . substring ( idx ) ) ; <nl> + } <nl> + } ; <nl> + <nl> + static class Annotation <nl> + { <nl> + TargetType type ; <nl> + String name ; <nl> + String target ; <nl> + Integer id ; <nl> + ValueHolder value ; <nl> + Map < String , ValueHolder > values ; <nl> + private Map < String , Object > _ values ; <nl> + <nl> + public Map < String , Object > getValues ( ASMInfo pool ) <nl> + { <nl> + if ( _ values = = null ) <nl> + { <nl> + _ values = Maps . newHashMap ( ) ; <nl> + if ( values ! = null ) <nl> + values . forEach ( ( k , v ) - > _ values . put ( k , v . get ( pool ) ) ) ; <nl> + else <nl> + _ values . put ( " value " , value ) ; <nl> + } <nl> + <nl> + return _ values ; <nl> + } <nl> + } <nl> + <nl> + static class ValueHolder <nl> + { <nl> + ValueType type ; <nl> + String value ; <nl> + String [ ] values ; <nl> + <nl> + private Object _ value ; <nl> + <nl> + private ValueType getType ( ) <nl> + { <nl> + return type = = null ? ValueType . STRING : type ; <nl> + } <nl> + <nl> + public Object get ( ASMInfo pool ) <nl> + { <nl> + if ( _ value = = null ) <nl> + { <nl> + if ( values ! = null ) <nl> + { <nl> + if ( type = = ValueType . ANNOTATION ) <nl> + { <nl> + List < Map < String , Object > > list = Lists . newArrayList ( ) ; <nl> + _ value = list ; <nl> + <nl> + for ( String s : values ) <nl> + { <nl> + Annotation sub = pool . getSubAnnotation ( Integer . parseInt ( s ) ) ; <nl> + if ( sub = = null ) <nl> + FMLLog . log . error ( " Invalid Sub - Annotation in Annotation JSON : " + s ) ; <nl> + else <nl> + list . add ( sub . getValues ( pool ) ) ; <nl> + } <nl> + } <nl> + else <nl> + _ value = getType ( ) . array . apply ( values ) ; <nl> + } <nl> + else <nl> + { <nl> + if ( type = = ValueType . ANNOTATION ) <nl> + { <nl> + Annotation sub = pool . getSubAnnotation ( Integer . parseInt ( value ) ) ; <nl> + if ( sub = = null ) <nl> + FMLLog . log . error ( " Invalid Sub - Annotation in Annotation JSON : " + value ) ; <nl> + else <nl> + _ value = sub . getValues ( pool ) ; <nl> + } <nl> + else <nl> + _ value = getType ( ) . single . apply ( value ) ; <nl> + } <nl> + } <nl> + return _ value ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / json / JsonAnnotationLoader . java b / src / main / java / net / minecraftforge / fml / common / discovery / json / JsonAnnotationLoader . java <nl> new file mode 100644 <nl> index 0000000 . . 8af098e <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / common / discovery / json / JsonAnnotationLoader . java <nl> @ @ - 0 , 0 + 1 , 77 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2018 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package net . minecraftforge . fml . common . discovery . json ; <nl> + <nl> + import java . io . InputStream ; <nl> + import java . io . InputStreamReader ; <nl> + import java . lang . reflect . Type ; <nl> + import java . util . Map ; <nl> + import java . util . Map . Entry ; <nl> + <nl> + import com . google . common . collect . HashMultimap ; <nl> + import com . google . common . collect . Multimap ; <nl> + import com . google . gson . Gson ; <nl> + import com . google . gson . GsonBuilder ; <nl> + import com . google . gson . reflect . TypeToken ; <nl> + <nl> + import net . minecraftforge . fml . common . discovery . ASMDataTable ; <nl> + import net . minecraftforge . fml . common . discovery . ASMDataTable . ASMData ; <nl> + import net . minecraftforge . fml . common . discovery . ModCandidate ; <nl> + import net . minecraftforge . fml . common . discovery . json . ASMInfo . Annotation ; <nl> + <nl> + public class JsonAnnotationLoader <nl> + { <nl> + public static final String ANNOTATION _ JSON = " META - INF / fml _ cache _ annotation . json " ; <nl> + private static final Gson GSON = new GsonBuilder ( ) . create ( ) ; <nl> + private static final Type INFO _ TABLE = new TypeToken < Map < String , ASMInfo > > ( ) { } . getType ( ) ; <nl> + <nl> + public static Multimap < String , ASMData > loadJson ( InputStream data , ModCandidate candidate , ASMDataTable table ) <nl> + { <nl> + Map < String , ASMInfo > map = GSON . fromJson ( new InputStreamReader ( data ) , INFO _ TABLE ) ; <nl> + Multimap < String , ASMData > ret = HashMultimap . create ( ) ; <nl> + <nl> + for ( Entry < String , ASMInfo > entry : map . entrySet ( ) ) <nl> + { <nl> + / / TODO : Java9 Multi - Release Jars , picking the correct class for the current platform . For now we just ignore them . <nl> + if ( entry . getKey ( ) . startsWith ( " META - INF / " ) ) <nl> + continue ; <nl> + <nl> + ASMInfo asm _ info = entry . getValue ( ) ; <nl> + if ( asm _ info . interfaces ! = null ) <nl> + { <nl> + for ( String type : asm _ info . interfaces ) <nl> + { <nl> + table . addASMData ( candidate , type , asm _ info . name , null , null ) ; <nl> + ret . put ( type , new ASMData ( candidate , type , asm _ info . name , null , null ) ) ; <nl> + } <nl> + } <nl> + <nl> + if ( asm _ info . annotations ! = null ) <nl> + { <nl> + for ( Annotation anno : asm _ info . annotations ) <nl> + { <nl> + table . addASMData ( candidate , anno . name , asm _ info . name , anno . target , anno . getValues ( asm _ info ) ) ; <nl> + ret . put ( anno . name , new ASMData ( candidate , anno . name , asm _ info . name , anno . target , anno . getValues ( asm _ info ) ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + return ret ; <nl> + } <nl> + } <nl> diff - - git a / src / test / java / net / minecraftforge / test / TestAnnotationParser . java b / src / test / java / net / minecraftforge / test / TestAnnotationParser . java <nl> new file mode 100644 <nl> index 0000000 . . 109364a <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / test / TestAnnotationParser . java <nl> @ @ - 0 , 0 + 1 , 172 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2018 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package net . minecraftforge . test ; <nl> + <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStream ; <nl> + import java . net . URL ; <nl> + import java . util . Collections ; <nl> + import java . util . regex . Matcher ; <nl> + import java . util . regex . Pattern ; <nl> + import java . util . zip . ZipEntry ; <nl> + import java . util . zip . ZipFile ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import net . minecraftforge . fml . common . discovery . ASMDataTable ; <nl> + import net . minecraftforge . fml . common . discovery . ContainerType ; <nl> + import net . minecraftforge . fml . common . discovery . ModCandidate ; <nl> + import net . minecraftforge . fml . common . discovery . asm . ASMModParser ; <nl> + import net . minecraftforge . fml . common . discovery . json . JsonAnnotationLoader ; <nl> + <nl> + public class TestAnnotationParser <nl> + { <nl> + private static String TEST _ JAR = " forestry _ 1 . 12 . 2 - 5 . 7 . 0 . 0 . jar " ; <nl> + public static Pattern classFile = Pattern . compile ( " [ ^ \ \ s \ \ $ ] + ( \ \ $ [ ^ \ \ s ] + ) ? \ \ . class $ " ) ; <nl> + private static final int RUN _ COUNT = 100 ; <nl> + <nl> + private File getFile ( ) <nl> + { <nl> + ClassLoader cl = getClass ( ) . getClassLoader ( ) ; <nl> + URL url = cl . getResource ( TEST _ JAR ) ; <nl> + return url = = null ? null : new File ( url . getFile ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationLoaderASM ( ) throws IOException <nl> + { <nl> + File jar = getFile ( ) ; <nl> + if ( jar = = null ) <nl> + return ; / / Skip this test if the test jar doesn ' t exist . <nl> + <nl> + Timer timer = new Timer ( ) ; <nl> + for ( int x = 0 ; x < RUN _ COUNT ; x + + ) <nl> + { <nl> + timer . start ( ) ; <nl> + loadAnnotationsASM ( jar ) ; <nl> + timer . end ( null ) ; <nl> + } <nl> + System . out . println ( " LoaderASM : " + timer . finish ( ) ) ; <nl> + } <nl> + <nl> + <nl> + @ Test <nl> + public void testAnnotationLoaderJSON ( ) throws IOException <nl> + { <nl> + File jar = getFile ( ) ; <nl> + if ( jar = = null ) <nl> + return ; / / Skip this test if the test jar doesn ' t exist . <nl> + <nl> + Timer timer = new Timer ( ) ; <nl> + for ( int x = 0 ; x < RUN _ COUNT ; x + + ) <nl> + { <nl> + timer . start ( ) ; <nl> + loadAnnotationsJSON ( jar ) ; <nl> + timer . end ( null ) ; <nl> + } <nl> + System . out . println ( " LoaderJSON : " + timer . finish ( ) ) ; <nl> + } <nl> + <nl> + private void loadAnnotationsASM ( File jar ) throws IOException <nl> + { <nl> + ASMDataTable dataTable = new ASMDataTable ( ) ; <nl> + ModCandidate candidate = new ModCandidate ( jar , jar , ContainerType . JAR ) ; <nl> + try ( ZipFile in = new ZipFile ( jar ) ) <nl> + { <nl> + for ( ZipEntry e : Collections . list ( in . entries ( ) ) ) <nl> + { <nl> + if ( e . getName ( ) ! = null & & e . getName ( ) . startsWith ( " _ _ MACOSX " ) ) <nl> + continue ; <nl> + <nl> + Matcher match = classFile . matcher ( e . getName ( ) ) ; <nl> + if ( match . matches ( ) ) <nl> + { <nl> + ASMModParser modParser ; <nl> + try ( InputStream inputStream = in . getInputStream ( e ) ) <nl> + { <nl> + modParser = new ASMModParser ( inputStream ) ; <nl> + } <nl> + / / candidate . addClassEntry ( e . getName ( ) ) ; <nl> + if ( modParser ! = null ) <nl> + modParser . sendToTable ( dataTable , candidate ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void loadAnnotationsJSON ( File jar ) throws IOException <nl> + { <nl> + ASMDataTable dataTable = new ASMDataTable ( ) ; <nl> + ModCandidate candidate = new ModCandidate ( jar , jar , ContainerType . JAR ) ; <nl> + try ( ZipFile in = new ZipFile ( jar ) ) <nl> + { <nl> + / / We need to loop everything to gather a list of class files , but as we ' re not reading every entry we should be faster ? <nl> + for ( ZipEntry e : Collections . list ( in . entries ( ) ) ) <nl> + { <nl> + if ( e . getName ( ) ! = null & & e . getName ( ) . startsWith ( " _ _ MACOSX " ) ) <nl> + continue ; <nl> + <nl> + Matcher match = classFile . matcher ( e . getName ( ) ) ; <nl> + if ( match . matches ( ) ) <nl> + { <nl> + / / We check for classes , make this fancier and support multi - release jars ? <nl> + / / candidate . addClassEntry ( e . getName ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + InputStream json _ input = in . getInputStream ( in . getEntry ( JsonAnnotationLoader . ANNOTATION _ JSON ) ) ; <nl> + JsonAnnotationLoader . loadJson ( json _ input , candidate , dataTable ) ; <nl> + } <nl> + } <nl> + <nl> + private static class Timer <nl> + { <nl> + private long start ; <nl> + private long min = Long . MAX _ VALUE ; <nl> + private long max = Long . MIN _ VALUE ; <nl> + private long total = 0 ; <nl> + private int count = 0 ; <nl> + <nl> + public void start ( ) <nl> + { <nl> + this . start = System . currentTimeMillis ( ) ; <nl> + } <nl> + public void end ( String message ) <nl> + { <nl> + long now = System . currentTimeMillis ( ) ; <nl> + long time = now - start ; <nl> + if ( message ! = null ) <nl> + System . out . println ( String . format ( message , time ) ) ; <nl> + min = Long . min ( min , time ) ; <nl> + max = Long . max ( max , time ) ; <nl> + total + = time ; <nl> + count + + ; <nl> + } <nl> + <nl> + public String finish ( ) <nl> + { <nl> + return " Runs : " + count + <nl> + " Min : " + min + <nl> + " Max : " + max + <nl> + " Total : " + total + <nl> + " Average : " + ( total / count ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch b / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch <nl> index 697a870 . . f9d344f 100644 <nl> - - - a / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch <nl> + + + b / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch <nl> @ @ - 1 , 6 + 1 , 11 @ @ <nl> - - - . . / src - base / minecraft / net / minecraft / item / crafting / Ingredient . java <nl> + + + . . / src - work / minecraft / net / minecraft / item / crafting / Ingredient . java <nl> - @ @ - 13 , 6 + 13 , 8 @ @ <nl> + @ @ - 8 , 11 + 8 , 11 @ @ <nl> + import net . minecraft . client . util . RecipeItemHelper ; <nl> + import net . minecraft . item . Item ; <nl> + import net . minecraft . item . ItemStack ; <nl> + - import net . minecraftforge . fml . relauncher . Side ; <nl> + - import net . minecraftforge . fml . relauncher . SideOnly ; <nl> <nl> public class Ingredient implements Predicate < ItemStack > <nl> { <nl> @ @ - 9 , 12 + 14 , 13 @ @ <nl> public static final Ingredient field _ 193370 _ a = new Ingredient ( new ItemStack [ 0 ] ) <nl> { <nl> public boolean apply ( @ Nullable ItemStack p _ apply _ 1 _ ) <nl> - @ @ - 21 , 17 + 23 , 34 @ @ <nl> + @ @ - 21 , 17 + 21 , 41 @ @ <nl> } <nl> } ; <nl> private final ItemStack [ ] field _ 193371 _ b ; <nl> + private final ItemStack [ ] matchingStacksExploded ; <nl> private IntList field _ 194140 _ c ; <nl> + + private final boolean isSimple ; <nl> <nl> + protected Ingredient ( int size ) <nl> + { <nl> @ @ - 23 , 6 + 29 , 7 @ @ <nl> + <nl> protected Ingredient ( ItemStack . . . p _ i47503 _ 1 _ ) <nl> { <nl> + + boolean simple = true ; <nl> this . field _ 193371 _ b = p _ i47503 _ 1 _ ; <nl> + net . minecraft . util . NonNullList < ItemStack > lst = net . minecraft . util . NonNullList . func _ 191196 _ a ( ) ; <nl> + for ( ItemStack s : p _ i47503 _ 1 _ ) <nl> @ @ - 30 , 11 + 37 , 16 @ @ <nl> + if ( s . func _ 190926 _ b ( ) ) <nl> + continue ; <nl> + if ( s . func _ 77960 _ j ( ) = = net . minecraftforge . oredict . OreDictionary . WILDCARD _ VALUE ) <nl> + + { <nl> + + if ( s . func _ 77973 _ b ( ) . func _ 77645 _ m ( ) ) <nl> + + simple = false ; <nl> + s . func _ 77973 _ b ( ) . func _ 150895 _ a ( net . minecraft . creativetab . CreativeTabs . field _ 78027 _ g , lst ) ; <nl> + + } <nl> + else <nl> + lst . add ( s ) ; <nl> + } <nl> + this . matchingStacksExploded = lst . toArray ( new ItemStack [ lst . size ( ) ] ) ; <nl> + + this . isSimple = simple & & this . matchingStacksExploded . length > 0 ; <nl> + Ingredient . INSTANCES . add ( this ) ; <nl> } <nl> <nl> @ @ - 46 , 7 + 58 , 7 @ @ <nl> } <nl> <nl> public boolean apply ( @ Nullable ItemStack p _ apply _ 1 _ ) <nl> - @ @ - 63 , 9 + 82 , 9 @ @ <nl> + @ @ - 63 , 9 + 87 , 9 @ @ <nl> { <nl> if ( this . field _ 194140 _ c = = null ) <nl> { <nl> @ @ - 58 , 7 + 70 , 7 @ @ <nl> { <nl> this . field _ 194140 _ c . add ( RecipeItemHelper . func _ 194113 _ b ( itemstack ) ) ; <nl> } <nl> - @ @ - 76 , 6 + 95 , 18 @ @ <nl> + @ @ - 76 , 6 + 100 , 18 @ @ <nl> return this . field _ 194140 _ c ; <nl> } <nl> <nl> @ @ - 77 , 7 + 89 , 7 @ @ <nl> public static Ingredient func _ 193367 _ a ( Item p _ 193367 _ 0 _ ) <nl> { <nl> return func _ 193369 _ a ( new ItemStack ( p _ 193367 _ 0 _ , 1 , 32767 ) ) ; <nl> - @ @ - 108 , 4 + 139 , 17 @ @ <nl> + @ @ - 108 , 4 + 144 , 22 @ @ <nl> <nl> return field _ 193370 _ a ; <nl> } <nl> @ @ - 94 , 4 + 106 , 9 @ @ <nl> + } <nl> + return new Ingredient ( lst . toArray ( new ItemStack [ lst . size ( ) ] ) ) ; <nl> + } <nl> + + <nl> + + public boolean isSimple ( ) <nl> + + { <nl> + + return isSimple | | this = = field _ 193370 _ a ; <nl> + + } <nl> } <nl> diff - - git a / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch b / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch <nl> index df082d0 . . 34e6831 100644 <nl> - - - a / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch <nl> + + + b / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch <nl> @ @ - 1 , 6 + 1 , 6 @ @ <nl> - - - . . / src - base / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java <nl> + + + . . / src - work / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java <nl> - @ @ - 10 , 10 + 10 , 8 @ @ <nl> + @ @ - 10 , 23 + 10 , 25 @ @ <nl> import net . minecraft . util . JsonUtils ; <nl> import net . minecraft . util . NonNullList ; <nl> import net . minecraft . world . World ; <nl> @ @ - 12 , 15 + 12 , 25 @ @ <nl> { <nl> private final ItemStack field _ 77580 _ a ; <nl> public final NonNullList < Ingredient > field _ 77579 _ b ; <nl> - @ @ - 26 , 7 + 24 , 6 @ @ <nl> + private final String field _ 194138 _ c ; <nl> + + private final boolean isSimple ; <nl> + <nl> + public ShapelessRecipes ( String p _ i47500 _ 1 _ , ItemStack p _ i47500 _ 2 _ , NonNullList < Ingredient > p _ i47500 _ 3 _ ) <nl> + { <nl> + this . field _ 194138 _ c = p _ i47500 _ 1 _ ; <nl> + this . field _ 77580 _ a = p _ i47500 _ 2 _ ; <nl> this . field _ 77579 _ b = p _ i47500 _ 3 _ ; <nl> + + boolean simple = true ; <nl> + + for ( Ingredient i : p _ i47500 _ 3 _ ) <nl> + + simple & = i . isSimple ( ) ; <nl> + + this . isSimple = simple ; <nl> } <nl> <nl> - @ SideOnly ( Side . CLIENT ) <nl> public String func _ 193358 _ e ( ) <nl> { <nl> return this . field _ 194138 _ c ; <nl> - @ @ - 50 , 10 + 47 , 7 @ @ <nl> + @ @ - 50 , 10 + 52 , 7 @ @ <nl> { <nl> ItemStack itemstack = p _ 179532 _ 1 _ . func _ 70301 _ a ( i ) ; <nl> <nl> @ @ - 32 , 17 + 42 , 18 @ @ <nl> } <nl> <nl> return nonnulllist ; <nl> - @ @ - 61 , 7 + 55 , 8 @ @ <nl> + @ @ - 61 , 7 + 60 , 9 @ @ <nl> <nl> public boolean func _ 77569 _ a ( InventoryCrafting p _ 77569 _ 1 _ , World p _ 77569 _ 2 _ ) <nl> { <nl> - List < Ingredient > list = Lists . newArrayList ( this . field _ 77579 _ b ) ; <nl> + int ingredientCount = 0 ; <nl> + net . minecraft . client . util . RecipeItemHelper recipeItemHelper = new net . minecraft . client . util . RecipeItemHelper ( ) ; <nl> + + List < ItemStack > inputs = Lists . newArrayList ( ) ; <nl> <nl> for ( int i = 0 ; i < p _ 77569 _ 1 _ . func _ 174923 _ h ( ) ; + + i ) <nl> { <nl> - @ @ - 71 , 27 + 66 , 13 @ @ <nl> + @ @ - 71 , 27 + 72 , 22 @ @ <nl> <nl> if ( ! itemstack . func _ 190926 _ b ( ) ) <nl> { <nl> @ @ - 63 , 17 + 74 , 26 @ @ <nl> - return false ; <nl> - } <nl> + + + ingredientCount ; <nl> - + recipeItemHelper . func _ 194112 _ a ( itemstack ) ; <nl> + + if ( this . isSimple ) <nl> + + recipeItemHelper . func _ 194112 _ a ( itemstack ) ; <nl> + + else <nl> + + inputs . add ( itemstack ) ; <nl> } <nl> } <nl> } <nl> <nl> - return list . isEmpty ( ) ; <nl> - + return ingredientCount = = this . field _ 77579 _ b . size ( ) & & recipeItemHelper . func _ 194116 _ a ( this , null ) ; <nl> + + if ( ingredientCount ! = this . field _ 77579 _ b . size ( ) ) <nl> + + return false ; <nl> + + <nl> + + if ( this . isSimple ) <nl> + + return recipeItemHelper . func _ 194116 _ a ( this , null ) ; <nl> + + <nl> + + return net . minecraftforge . common . util . RecipeMatcher . findMatches ( inputs , this . field _ 77579 _ b ) ! = null ; <nl> } <nl> <nl> public ItemStack func _ 77572 _ b ( InventoryCrafting p _ 77572 _ 1 _ ) <nl> - @ @ - 136 , 7 + 117 , 6 @ @ <nl> + @ @ - 136 , 7 + 132 , 6 @ @ <nl> return nonnulllist ; <nl> } <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java b / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java <nl> index 32a2c02 . . 60909dd 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java <nl> + + + b / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java <nl> @ @ - 20 , 11 + 20 , 17 @ @ public class CompoundIngredient extends Ingredient <nl> private Collection < Ingredient > children ; <nl> private ItemStack [ ] stacks ; <nl> private IntList itemIds ; <nl> + private final boolean isSimple ; <nl> <nl> protected CompoundIngredient ( Collection < Ingredient > children ) <nl> { <nl> super ( 0 ) ; <nl> this . children = children ; <nl> + <nl> + boolean simple = true ; <nl> + for ( Ingredient child : children ) <nl> + simple & = child . isSimple ( ) ; <nl> + this . isSimple = simple ; <nl> } <nl> <nl> @ Override <nl> @ @ - 78 , 4 + 84 , 10 @ @ public class CompoundIngredient extends Ingredient <nl> this . stacks = null ; <nl> / / Shouldn ' t need to invalidate children as this is only called form invalidateAll . . <nl> } <nl> + <nl> + @ Override <nl> + public boolean isSimple ( ) <nl> + { <nl> + return isSimple ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java b / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java <nl> index 3f7c31e . . 9a85682 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java <nl> + + + b / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java <nl> @ @ - 40 , 4 + 40 , 10 @ @ public class IngredientNBT extends Ingredient <nl> / / Can ' t use areItemStacksEqualUsingNBTShareTag because it compares stack size as well <nl> return this . stack . getItem ( ) = = input . getItem ( ) & & this . stack . getItemDamage ( ) = = input . getItemDamage ( ) & & ItemStack . areItemStackShareTagsEqual ( this . stack , input ) ; <nl> } <nl> + <nl> + @ Override <nl> + public boolean isSimple ( ) <nl> + { <nl> + return false ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java b / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java <nl> new file mode 100644 <nl> index 0000000 . . c8549ff <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java <nl> @ @ - 0 , 0 + 1 , 162 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package net . minecraftforge . common . util ; <nl> + <nl> + import java . util . BitSet ; <nl> + import java . util . LinkedList ; <nl> + import java . util . List ; <nl> + import java . util . Queue ; <nl> + <nl> + import com . google . common . base . Predicate ; <nl> + <nl> + public class RecipeMatcher <nl> + { <nl> + / * * <nl> + * Attempts to match inputs to the specified tests . In the best way that all inputs are used by one test . <nl> + * Will return null in any of these cases : <nl> + * input / test lengths don ' t match . This is only for matching paired outputs . <nl> + * any input doesn ' t match a test <nl> + * any test doesn ' t match a input <nl> + * If we are unable to determine a proper pair <nl> + * <nl> + * @ return An array mapping inputs to tests . ret [ x ] = y means input [ x ] = test [ y ] <nl> + * / <nl> + public static < T > int [ ] findMatches ( List < T > inputs , List < ? extends Predicate < T > > tests ) <nl> + { <nl> + int elements = inputs . size ( ) ; <nl> + if ( elements ! = tests . size ( ) ) <nl> + return null ; / / There will not be a 1 : 1 mapping of inputs - > tests <nl> + <nl> + int [ ] ret = new int [ elements ] ; <nl> + for ( int x = 0 ; x < elements ; x + + ) <nl> + ret [ x ] = - 1 ; <nl> + <nl> + / / [ UnusedInputs ] [ UnusedIngredients ] [ IngredientMatchMask ] . . . <nl> + BitSet data = new BitSet ( ( elements + 2 ) * elements ) ; <nl> + for ( int x = 0 ; x < elements ; x + + ) <nl> + { <nl> + int matched = 0 ; <nl> + int offset = ( x + 2 ) * elements ; <nl> + Predicate < T > test = tests . get ( x ) ; <nl> + <nl> + for ( int y = 0 ; y < elements ; y + + ) <nl> + { <nl> + if ( data . get ( y ) ) <nl> + continue ; <nl> + <nl> + if ( test . apply ( inputs . get ( y ) ) ) <nl> + { <nl> + data . set ( offset + y ) ; <nl> + matched + + ; <nl> + } <nl> + } <nl> + <nl> + if ( matched = = 0 ) <nl> + return null ; / / We have an test that matched non of the inputs <nl> + <nl> + if ( matched = = 1 ) <nl> + { <nl> + if ( ! claim ( ret , data , x , elements ) ) <nl> + return null ; / / We failed to claim this index , which means it caused something else to go to 0 matches , which makes the whole thing fail <nl> + } <nl> + } <nl> + <nl> + if ( data . nextClearBit ( 0 ) > = elements ) / / All items have been used , which means all tests have a match ! <nl> + return ret ; <nl> + <nl> + / / We should be in a state where multiple tests are satified by multiple inputs . So we need to try a branching recursive test . <nl> + / / However for performance reasons , we should probably make that check a sub - set of the entire graph . <nl> + if ( backtrack ( data , ret , 0 , elements ) ) <nl> + return ret ; <nl> + <nl> + return null ; / / Backtrack failed , no matches , we cry and go home now : ( <nl> + } <nl> + <nl> + / / This is bad . . . need to think of a better cascade , recursion instead of stack ? <nl> + private static boolean claim ( int [ ] ret , BitSet data , int claimed , int elements ) <nl> + { <nl> + Queue < Integer > pending = new LinkedList < Integer > ( ) ; <nl> + pending . add ( claimed ) ; <nl> + <nl> + while ( pending . peek ( ) ! = null ) <nl> + { <nl> + int test = pending . poll ( ) ; <nl> + int offset = ( test + 2 ) * elements ; <nl> + int used = data . nextSetBit ( offset ) - offset ; <nl> + <nl> + if ( used > = elements | | used < 0 ) <nl> + throw new IllegalStateException ( " What ? We matched something , but it wasn ' t set in the range of this test ! Test : " + test + " Used : " + used ) ; <nl> + <nl> + data . set ( used ) ; <nl> + data . set ( elements + test ) ; <nl> + ret [ used ] = test ; <nl> + <nl> + for ( int x = 0 ; x < elements ; x + + ) <nl> + { <nl> + offset = ( x + 2 ) * elements ; <nl> + if ( data . get ( offset + used ) & & ! data . get ( elements + x ) ) <nl> + { <nl> + data . clear ( offset + used ) ; <nl> + int count = 0 ; <nl> + for ( int y = offset ; y < offset + elements ; y + + ) <nl> + if ( data . get ( y ) ) <nl> + count + + ; <nl> + <nl> + if ( count = = 0 ) <nl> + return false ; / / Claiming this caused another test to lose its last match . . <nl> + <nl> + if ( count = = 1 ) <nl> + pending . add ( x ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + / / We use recursion here , why ? Because I feel like it . Also because we should only ever be working in data sets < 9 <nl> + private static boolean backtrack ( BitSet data , int [ ] ret , int start , int elements ) <nl> + { <nl> + int test = data . nextClearBit ( elements + start ) - elements ; <nl> + if ( test > = elements ) <nl> + return true ; / / Could not find the next unused test . <nl> + <nl> + if ( test < 0 ) <nl> + throw new IllegalStateException ( " This should never happen , negative test in backtrack ! " ) ; <nl> + <nl> + int offset = ( test + 2 ) * elements ; <nl> + for ( int x = 0 ; x < elements ; x + + ) <nl> + { <nl> + if ( ! data . get ( offset + x ) | | data . get ( x ) ) <nl> + continue ; <nl> + <nl> + data . set ( x ) ; <nl> + <nl> + if ( backtrack ( data , ret , test + 1 , elements ) ) <nl> + { <nl> + ret [ x ] = test ; <nl> + return true ; <nl> + } <nl> + <nl> + data . clear ( x ) ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / oredict / OreIngredient . java b / src / main / java / net / minecraftforge / oredict / OreIngredient . java <nl> index 11ae517 . . 9a017b9 100644 <nl> - - - a / src / main / java / net / minecraftforge / oredict / OreIngredient . java <nl> + + + b / src / main / java / net / minecraftforge / oredict / OreIngredient . java <nl> @ @ - 114 , 4 + 114 , 10 @ @ public class OreIngredient extends Ingredient <nl> this . itemIds = null ; <nl> this . array = null ; <nl> } <nl> + <nl> + @ Override <nl> + public boolean isSimple ( ) <nl> + { <nl> + return true ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java b / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java <nl> index 56d9485 . . db07357 100644 <nl> - - - a / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java <nl> + + + b / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java <nl> @ @ - 33 , 6 + 33 , 7 @ @ import net . minecraft . util . ResourceLocation ; <nl> import net . minecraft . world . World ; <nl> import net . minecraftforge . common . crafting . CraftingHelper ; <nl> import net . minecraftforge . common . crafting . JsonContext ; <nl> + import net . minecraftforge . common . util . RecipeMatcher ; <nl> import net . minecraftforge . registries . IForgeRegistryEntry ; <nl> <nl> import javax . annotation . Nonnull ; <nl> @ @ - 48 , 6 + 49 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> protected ItemStack output = ItemStack . EMPTY ; <nl> protected NonNullList < Ingredient > input = NonNullList . create ( ) ; <nl> protected ResourceLocation group ; <nl> + protected boolean isSimple = true ; <nl> <nl> public ShapelessOreRecipe ( ResourceLocation group , Block result , Object . . . recipe ) { this ( group , new ItemStack ( result ) , recipe ) ; } <nl> public ShapelessOreRecipe ( ResourceLocation group , Item result , Object . . . recipe ) { this ( group , new ItemStack ( result ) , recipe ) ; } <nl> @ @ - 56 , 6 + 58 , 8 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> this . group = group ; <nl> output = result . copy ( ) ; <nl> this . input = input ; <nl> + for ( Ingredient i : input ) <nl> + this . isSimple & = i . isSimple ( ) ; <nl> } <nl> public ShapelessOreRecipe ( ResourceLocation group , @ Nonnull ItemStack result , Object . . . recipe ) <nl> { <nl> @ @ - 67 , 6 + 71 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> if ( ing ! = null ) <nl> { <nl> input . add ( ing ) ; <nl> + this . isSimple & = ing . isSimple ( ) ; <nl> } <nl> else <nl> { <nl> @ @ - 94 , 6 + 99 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> { <nl> int ingredientCount = 0 ; <nl> RecipeItemHelper recipeItemHelper = new RecipeItemHelper ( ) ; <nl> + List < ItemStack > items = Lists . newArrayList ( ) ; <nl> <nl> for ( int i = 0 ; i < inv . getSizeInventory ( ) ; + + i ) <nl> { <nl> @ @ - 101 , 11 + 107 , 20 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> if ( ! itemstack . isEmpty ( ) ) <nl> { <nl> + + ingredientCount ; <nl> - recipeItemHelper . accountStack ( itemstack ) ; <nl> + if ( this . isSimple ) <nl> + recipeItemHelper . accountStack ( itemstack ) ; <nl> + else <nl> + items . add ( itemstack ) ; <nl> } <nl> } <nl> <nl> - return ingredientCount = = this . input . size ( ) & & recipeItemHelper . canCraft ( this , null ) ; <nl> + if ( ingredientCount ! = this . input . size ( ) ) <nl> + return false ; <nl> + <nl> + if ( this . isSimple ) <nl> + return recipeItemHelper . canCraft ( this , null ) ; <nl> + <nl> + return RecipeMatcher . findMatches ( items , this . input ) ! = null ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / test / java / net / minecraftforge / debug / RecipeTestMod . java b / src / test / java / net / minecraftforge / debug / RecipeTestMod . java <nl> index cc9c48c . . df3e1b8 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / RecipeTestMod . java <nl> + + + b / src / test / java / net / minecraftforge / debug / RecipeTestMod . java <nl> @ @ - 1 , 44 + 1 , 108 @ @ <nl> package net . minecraftforge . debug ; <nl> <nl> + import java . util . Random ; <nl> + <nl> + import net . minecraft . client . renderer . block . model . ModelResourceLocation ; <nl> + import net . minecraft . creativetab . CreativeTabs ; <nl> import net . minecraft . init . Blocks ; <nl> + import net . minecraft . item . Item ; <nl> import net . minecraft . item . ItemStack ; <nl> import net . minecraft . item . crafting . IRecipe ; <nl> import net . minecraft . item . crafting . ShapedRecipes ; <nl> + import net . minecraft . util . EnumActionResult ; <nl> import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . client . model . ModelLoader ; <nl> import net . minecraftforge . common . MinecraftForge ; <nl> import net . minecraftforge . common . crafting . CraftingHelper ; <nl> + import net . minecraftforge . debug . OnItemUseFirstTest . CommonProxy ; <nl> + import net . minecraftforge . debug . OnItemUseFirstTest . ItemTest ; <nl> import net . minecraftforge . event . RegistryEvent ; <nl> import net . minecraftforge . fml . common . Mod ; <nl> + import net . minecraftforge . fml . common . SidedProxy ; <nl> import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; <nl> + import net . minecraftforge . fml . common . registry . GameRegistry . ObjectHolder ; <nl> import net . minecraftforge . fml . relauncher . FMLLaunchHandler ; <nl> import net . minecraftforge . fml . relauncher . Side ; <nl> import net . minecraftforge . oredict . ShapedOreRecipe ; <nl> <nl> - @ Mod ( modid = " recipetest " , name = " Recipe test mod " , version = " 1 . 0 " , acceptableRemoteVersions = " * " ) <nl> + @ Mod ( modid = RecipeTestMod . MODID , name = " Recipe test mod " , version = " 1 . 0 " , acceptableRemoteVersions = " * " ) <nl> public class RecipeTestMod <nl> { <nl> + public static final String MODID = " recipetest " ; <nl> + private static final boolean ENABLED = true ; <nl> + @ SidedProxy <nl> + public static CommonProxy proxy = null ; <nl> + <nl> + <nl> @ Mod . EventHandler <nl> public void preinit ( FMLPreInitializationEvent event ) <nl> { <nl> - MinecraftForge . EVENT _ BUS . register ( this ) ; <nl> + if ( ENABLED ) <nl> + MinecraftForge . EVENT _ BUS . register ( this ) ; <nl> } <nl> <nl> @ SubscribeEvent <nl> public void registerRecipes ( RegistryEvent . Register < IRecipe > event ) <nl> { <nl> - ResourceLocation location1 = new ResourceLocation ( " recipetest " , " dirt " ) ; <nl> + ResourceLocation location1 = new ResourceLocation ( MODID , " dirt " ) ; <nl> ShapedOreRecipe recipe1 = new ShapedOreRecipe ( location1 , new ItemStack ( Blocks . DIAMOND _ BLOCK ) , " DDD " , ' D ' , new ItemStack ( Blocks . DIRT ) ) ; <nl> recipe1 . setRegistryName ( location1 ) ; <nl> event . getRegistry ( ) . register ( recipe1 ) ; <nl> <nl> if ( FMLLaunchHandler . side ( ) = = Side . SERVER ) <nl> { <nl> - ResourceLocation location2 = new ResourceLocation ( " recipetest " , " stone " ) ; <nl> + ResourceLocation location2 = new ResourceLocation ( MODID , " stone " ) ; <nl> CraftingHelper . ShapedPrimer primer1 = CraftingHelper . parseShaped ( " SSS " , ' S ' , new ItemStack ( Blocks . IRON _ BLOCK ) ) ; <nl> ShapedRecipes recipe2 = new ShapedRecipes ( location2 . getResourcePath ( ) , primer1 . width , primer1 . height , primer1 . input , new ItemStack ( Blocks . GOLD _ BLOCK ) ) ; <nl> recipe2 . setRegistryName ( location2 ) ; <nl> event . getRegistry ( ) . register ( recipe2 ) ; <nl> } <nl> } <nl> + <nl> + @ SubscribeEvent <nl> + public void registerItems ( RegistryEvent . Register < Item > event ) <nl> + { <nl> + proxy . registerItem ( event ) ; <nl> + } <nl> + <nl> + public static abstract class CommonProxy <nl> + { <nl> + protected Item TOOL ; <nl> + public void registerItem ( RegistryEvent . Register < Item > event ) <nl> + { <nl> + TOOL = new Item ( ) <nl> + { <nl> + Random RAND = new Random ( ) ; <nl> + @ Override <nl> + public ItemStack getContainerItem ( ItemStack in ) <nl> + { <nl> + ItemStack ret = in . copy ( ) ; <nl> + ret . attemptDamageItem ( 1 , RAND , null ) ; <nl> + return ret ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasContainerItem ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + } . setRegistryName ( MODID , " tool " ) . setMaxDamage ( 10 ) . setCreativeTab ( CreativeTabs . MISC ) . setUnlocalizedName ( " recipetest . tool " ) . setMaxStackSize ( 1 ) ; <nl> + event . getRegistry ( ) . register ( TOOL ) ; <nl> + } <nl> + } <nl> + <nl> + public static final class ServerProxy extends CommonProxy <nl> + { <nl> + } <nl> + <nl> + public static final class ClientProxy extends CommonProxy <nl> + { <nl> + @ Override <nl> + public void registerItem ( RegistryEvent . Register < Item > event ) <nl> + { <nl> + super . registerItem ( event ) ; <nl> + ModelLoader . setCustomModelResourceLocation ( TOOL , 0 , new ModelResourceLocation ( " minecraft : stick # inventory " ) ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / test / resources / assets / forge / recipes / shapeless _ damageable . json b / src / test / resources / assets / forge / recipes / shapeless _ damageable . json <nl> new file mode 100644 <nl> index 0000000 . . b345903 <nl> - - - / dev / null <nl> + + + b / src / test / resources / assets / forge / recipes / shapeless _ damageable . json <nl> @ @ - 0 , 0 + 1 , 13 @ @ <nl> + { <nl> + " type " : " minecraft : crafting _ shapeless " , <nl> + " ingredients " : [ <nl> + { <nl> + " item " : " minecraft : bow " , <nl> + " data " : 32767 <nl> + } <nl> + ] , <nl> + " result " : { <nl> + " item " : " minecraft : wool " , <nl> + " data " : 9 <nl> + } <nl> + } <nl> \ No newline at end of file <nl> diff - - git a / src / test / resources / assets / recipetest / recipes / tool _ complex . json b / src / test / resources / assets / recipetest / recipes / tool _ complex . json <nl> new file mode 100644 <nl> index 0000000 . . f2d6c81 <nl> - - - / dev / null <nl> + + + b / src / test / resources / assets / recipetest / recipes / tool _ complex . json <nl> @ @ - 0 , 0 + 1 , 21 @ @ <nl> + { <nl> + " type " : " minecraft : crafting _ shapeless " , <nl> + " ingredients " : [ <nl> + { <nl> + " item " : " tool " , <nl> + " data " : 32767 <nl> + } , <nl> + { <nl> + " item " : " minecraft : stone " , <nl> + " data " : 32767 <nl> + } , <nl> + { <nl> + " item " : " minecraft : stone " , <nl> + " data " : 0 <nl> + } <nl> + ] , <nl> + " result " : { <nl> + " item " : " minecraft : wool " , <nl> + " data " : 0 <nl> + } <nl> + } <nl> diff - - git a / src / test / resources / assets / recipetest / recipes / tool _ simple . json b / src / test / resources / assets / recipetest / recipes / tool _ simple . json <nl> new file mode 100644 <nl> index 0000000 . . 192c2fa <nl> - - - / dev / null <nl> + + + b / src / test / resources / assets / recipetest / recipes / tool _ simple . json <nl> @ @ - 0 , 0 + 1 , 13 @ @ <nl> + { <nl> + " type " : " minecraft : crafting _ shapeless " , <nl> + " ingredients " : [ <nl> + { <nl> + " item " : " tool " , <nl> + " data " : 32767 <nl> + } <nl> + ] , <nl> + " result " : { <nl> + " item " : " minecraft : wool " , <nl> + " data " : 9 <nl> + } <nl> + }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / JarDiscoverer . java b / src / main / java / net / minecraftforge / fml / common / discovery / JarDiscoverer . java 
 index 4fd756e . . b825e96 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / discovery / JarDiscoverer . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / discovery / JarDiscoverer . java 
 @ @ - 19 , 9 + 19 , 12 @ @ 
 
 package net . minecraftforge . fml . common . discovery ; 
 
 + import java . io . IOException ; 
 import java . io . InputStream ; 
 + import java . lang . reflect . Constructor ; 
 import java . util . Collections ; 
 import java . util . List ; 
 + import java . util . Map . Entry ; 
 import java . util . jar . JarFile ; 
 
 import net . minecraftforge . fml . common . FMLLog ; 
 @ @ - 29 , 18 + 32 , 22 @ @ import net . minecraftforge . fml . common . LoaderException ; 
 import net . minecraftforge . fml . common . MetadataCollection ; 
 import net . minecraftforge . fml . common . ModContainer ; 
 import net . minecraftforge . fml . common . ModContainerFactory ; 
 + import net . minecraftforge . fml . common . discovery . ASMDataTable . ASMData ; 
 import net . minecraftforge . fml . common . discovery . asm . ASMModParser ; 
 - 
 - import org . apache . commons . io . IOUtils ; 
 - import org . apache . logging . log4j . Level ; 
 + import net . minecraftforge . fml . common . discovery . json . JsonAnnotationLoader ; 
 
 import java . util . regex . Matcher ; 
 import java . util . zip . ZipEntry ; 
 
 + import org . objectweb . asm . Type ; 
 + 
 import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Multimap ; 
 
 public class JarDiscoverer implements ITypeDiscoverer 
 { 
 + private static final boolean ENABLE _ JSON _ TEST = " true " . equals ( System . getProperty ( " fml . enableJsonAnnotations " , " false " ) ) ; 
 + 
 @ Override 
 public List < ModContainer > discover ( ModCandidate candidate , ASMDataTable table ) 
 { 
 @ @ - 63 , 48 + 70 , 91 @ @ public class JarDiscoverer implements ITypeDiscoverer 
 FMLLog . log . debug ( " The mod container { } appears to be missing an mcmod . info file " , candidate . getModContainer ( ) . getName ( ) ) ; 
 mc = MetadataCollection . from ( null , " " ) ; 
 } 
 - for ( ZipEntry ze : Collections . list ( jar . entries ( ) ) ) 
 + 
 + if ( ENABLE _ JSON _ TEST & & jar . getEntry ( JsonAnnotationLoader . ANNOTATION _ JSON ) ! = null ) 
 + findClassesJSON ( candidate , table , jar , foundMods , mc ) ; 
 + else 
 + findClassesASM ( candidate , table , jar , foundMods , mc ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + FMLLog . log . warn ( " Zip file { } failed to read properly , it will be ignored " , candidate . getModContainer ( ) . getName ( ) , e ) ; 
 + } 
 + return foundMods ; 
 + } 
 + 
 + private void findClassesASM ( ModCandidate candidate , ASMDataTable table , JarFile jar , List < ModContainer > foundMods , MetadataCollection mc ) throws IOException 
 + { 
 + for ( ZipEntry ze : Collections . list ( jar . entries ( ) ) ) 
 + { 
 + if ( ze . getName ( ) ! = null & & ze . getName ( ) . startsWith ( " _ _ MACOSX " ) ) 
 + { 
 + continue ; 
 + } 
 + Matcher match = classFile . matcher ( ze . getName ( ) ) ; 
 + if ( match . matches ( ) ) 
 { 
 - if ( ze . getName ( ) ! = null & & ze . getName ( ) . startsWith ( " _ _ MACOSX " ) ) 
 + ASMModParser modParser ; 
 + try 
 { 
 - continue ; 
 - } 
 - Matcher match = classFile . matcher ( ze . getName ( ) ) ; 
 - if ( match . matches ( ) ) 
 - { 
 - ASMModParser modParser ; 
 - try 
 - { 
 - try ( InputStream inputStream = jar . getInputStream ( ze ) ) 
 - { 
 - modParser = new ASMModParser ( inputStream ) ; 
 - } 
 - candidate . addClassEntry ( ze . getName ( ) ) ; 
 - } 
 - catch ( LoaderException e ) 
 - { 
 - FMLLog . log . error ( " There was a problem reading the entry { } in the jar { } - probably a corrupt zip " , candidate . getModContainer ( ) . getPath ( ) , e ) ; 
 - jar . close ( ) ; 
 - throw e ; 
 - } 
 - modParser . validate ( ) ; 
 - modParser . sendToTable ( table , candidate ) ; 
 - ModContainer container = ModContainerFactory . instance ( ) . build ( modParser , candidate . getModContainer ( ) , candidate ) ; 
 - if ( container ! = null ) 
 + try ( InputStream inputStream = jar . getInputStream ( ze ) ) 
 { 
 - table . addContainer ( container ) ; 
 - foundMods . add ( container ) ; 
 - container . bindMetadata ( mc ) ; 
 - container . setClassVersion ( modParser . getClassVersion ( ) ) ; 
 + modParser = new ASMModParser ( inputStream ) ; 
 } 
 + candidate . addClassEntry ( ze . getName ( ) ) ; 
 + } 
 + catch ( LoaderException e ) 
 + { 
 + FMLLog . log . error ( " There was a problem reading the entry { } in the jar { } - probably a corrupt zip " , candidate . getModContainer ( ) . getPath ( ) , e ) ; 
 + jar . close ( ) ; 
 + throw e ; 
 + } 
 + modParser . validate ( ) ; 
 + modParser . sendToTable ( table , candidate ) ; 
 + ModContainer container = ModContainerFactory . instance ( ) . build ( modParser , candidate . getModContainer ( ) , candidate ) ; 
 + if ( container ! = null ) 
 + { 
 + table . addContainer ( container ) ; 
 + foundMods . add ( container ) ; 
 + container . bindMetadata ( mc ) ; 
 + container . setClassVersion ( modParser . getClassVersion ( ) ) ; 
 } 
 } 
 } 
 - catch ( Exception e ) 
 + } 
 + 
 + private void findClassesJSON ( ModCandidate candidate , ASMDataTable table , JarFile jar , List < ModContainer > foundMods , MetadataCollection mc ) throws IOException 
 + { 
 + FMLLog . log . info ( " Loading jar { } annotation data from json " , candidate . getModContainer ( ) . getPath ( ) ) ; 
 + ZipEntry json = jar . getEntry ( JsonAnnotationLoader . ANNOTATION _ JSON ) ; 
 + Multimap < String , ASMData > annos = JsonAnnotationLoader . loadJson ( jar . getInputStream ( json ) , candidate , table ) ; 
 + 
 + for ( Entry < Type , Constructor < ? extends ModContainer > > entry : ModContainerFactory . modTypes . entrySet ( ) ) 
 { 
 - FMLLog . log . warn ( " Zip file { } failed to read properly , it will be ignored " , candidate . getModContainer ( ) . getName ( ) , e ) ; 
 + Type type = entry . getKey ( ) ; 
 + Constructor < ? extends ModContainer > ctr = entry . getValue ( ) ; 
 + 
 + for ( ASMData data : annos . get ( type . getClassName ( ) ) ) 
 + { 
 + FMLLog . log . debug ( " Identified a mod of type { } ( { } ) - loading " , type . getClassName ( ) , data . getClassName ( ) ) ; 
 + try 
 + { 
 + ModContainer ret = ctr . newInstance ( data . getClassName ( ) , candidate , data . getAnnotationInfo ( ) ) ; 
 + if ( ! ret . shouldLoadInEnvironment ( ) ) 
 + FMLLog . log . debug ( " Skipping mod { } , container opted to not load . " , data . getClassName ( ) ) ; 
 + else 
 + { 
 + table . addContainer ( ret ) ; 
 + foundMods . add ( ret ) ; 
 + ret . bindMetadata ( mc ) ; 
 + / / ret . setClassVersion ( classVersion ) ; / / Not really needed anymore as we ' re forcing J8 . Maybe think of reinstating for J9 support ? After LaunchWraper re - do . 
 + } 
 + } 
 + catch ( Exception e ) 
 + { 
 + FMLLog . log . error ( " Unable to construct { } container " , data . getClassName ( ) , e ) ; 
 + } 
 + } 
 } 
 - return foundMods ; 
 } 
 - 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java b / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java 
 index 4c18d8b . . 0720f3b 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / discovery / ModDiscoverer . java 
 @ @ - 107 , 6 + 107 , 7 @ @ public class ModDiscoverer 
 } 
 else if ( modFile . isDirectory ( ) ) 
 { 
 + / / TODO Remove in 1 . 13 + Mods should never be directory based anymore . 
 FMLLog . log . debug ( " Found a candidate mod directory { } " , modFile . getName ( ) ) ; 
 addCandidate ( new ModCandidate ( modFile , modFile , ContainerType . DIR ) ) ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / asm / ModAnnotation . java b / src / main / java / net / minecraftforge / fml / common / discovery / asm / ModAnnotation . java 
 index 1279368 . . 5bbafc8 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / discovery / asm / ModAnnotation . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / discovery / asm / ModAnnotation . java 
 @ @ - 32 , 7 + 32 , 7 @ @ import com . google . common . collect . Maps ; 
 
 public class ModAnnotation 
 { 
 - public class EnumHolder 
 + public static class EnumHolder 
 { 
 private final String desc ; 
 private final String value ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / json / ASMInfo . java b / src / main / java / net / minecraftforge / fml / common / discovery / json / ASMInfo . java 
 new file mode 100644 
 index 0000000 . . bd8019a 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / common / discovery / json / ASMInfo . java 
 @ @ - 0 , 0 + 1 , 165 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2018 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package net . minecraftforge . fml . common . discovery . json ; 
 + 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . function . Function ; 
 + 
 + import org . apache . commons . lang3 . Validate ; 
 + import org . objectweb . asm . Type ; 
 + 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Maps ; 
 + 
 + import net . minecraftforge . fml . common . FMLLog ; 
 + import net . minecraftforge . fml . common . discovery . asm . ModAnnotation . EnumHolder ; 
 + 
 + / / Package private , modders shouldn ' t access this . Do it through ASMDataTable . 
 + class ASMInfo 
 + { 
 + String name ; 
 + String [ ] interfaces ; 
 + List < Annotation > annotations ; 
 + private Map < Integer , Annotation > byID ; 
 + 
 + public Annotation getSubAnnotation ( int id ) 
 + { 
 + if ( byID = = null ) 
 + { 
 + byID = Maps . newHashMap ( ) ; 
 + annotations . forEach ( a - > { if ( a . id ! = null ) byID . put ( a . id , a ) ; } ) ; 
 + } 
 + return byID . get ( id ) ; 
 + } 
 + 
 + public enum TargetType { CLASS , FIELD , METHOD , SUBTYPE } ; 
 + public enum ValueType 
 + { 
 + BOOL ( Boolean : : valueOf , v - > { boolean [ ] ret = new boolean [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Boolean . parseBoolean ( v [ x ] ) ; return ret ; } ) , 
 + BYTE ( Byte : : valueOf , v - > { byte [ ] ret = new byte [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Byte . parseByte ( v [ x ] ) ; return ret ; } ) , 
 + CHAR ( x - > x . charAt ( 0 ) , v - > { char [ ] ret = new char [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = v [ x ] . charAt ( 0 ) ; return ret ; } ) , 
 + SHORT ( Short : : valueOf , v - > { short [ ] ret = new short [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Short . parseShort ( v [ x ] ) ; return ret ; } ) , 
 + INT ( Integer : : valueOf , v - > { int [ ] ret = new int [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Integer . parseInt ( v [ x ] ) ; return ret ; } ) , 
 + LONG ( Long : : valueOf , v - > { long [ ] ret = new long [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Long . parseLong ( v [ x ] ) ; return ret ; } ) , 
 + FLOAT ( Float : : valueOf , v - > { float [ ] ret = new float [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Float . parseFloat ( v [ x ] ) ; return ret ; } ) , 
 + DOUBLE ( Double : : valueOf , v - > { double [ ] ret = new double [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Double . parseDouble ( v [ x ] ) ; return ret ; } ) , 
 + STRING ( x - > x , x - > x ) , 
 + CLASS ( Type : : getType , v - > { Type [ ] ret = new Type [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = Type . getType ( v [ x ] ) ; return ret ; } ) , 
 + ENUM ( ValueType : : getEnumHolder , v - > { EnumHolder [ ] ret = new EnumHolder [ v . length ] ; for ( int x = 0 ; x < v . length ; x + + ) ret [ x ] = ValueType . getEnumHolder ( v [ x ] ) ; return ret ; } ) , 
 + ANNOTATION ( null , null ) , 
 + NULL ( x - > null , x - > null ) ; 
 + 
 + public final Function < String , Object > single ; 
 + public final Function < String [ ] , Object > array ; 
 + 
 + private ValueType ( Function < String , Object > single , Function < String [ ] , Object > array ) 
 + { 
 + this . single = single ; 
 + this . array = array ; 
 + } 
 + 
 + private static EnumHolder getEnumHolder ( String value ) 
 + { 
 + int idx = value . lastIndexOf ( ' / ' ) ; 
 + if ( idx < = 1 ) 
 + throw new IllegalArgumentException ( " Can not create a EnumHolder for value : " + value ) ; 
 + return new EnumHolder ( value . substring ( 0 , idx - 1 ) , value . substring ( idx ) ) ; 
 + } 
 + } ; 
 + 
 + static class Annotation 
 + { 
 + TargetType type ; 
 + String name ; 
 + String target ; 
 + Integer id ; 
 + ValueHolder value ; 
 + Map < String , ValueHolder > values ; 
 + private Map < String , Object > _ values ; 
 + 
 + public Map < String , Object > getValues ( ASMInfo pool ) 
 + { 
 + if ( _ values = = null ) 
 + { 
 + _ values = Maps . newHashMap ( ) ; 
 + if ( values ! = null ) 
 + values . forEach ( ( k , v ) - > _ values . put ( k , v . get ( pool ) ) ) ; 
 + else 
 + _ values . put ( " value " , value ) ; 
 + } 
 + 
 + return _ values ; 
 + } 
 + } 
 + 
 + static class ValueHolder 
 + { 
 + ValueType type ; 
 + String value ; 
 + String [ ] values ; 
 + 
 + private Object _ value ; 
 + 
 + private ValueType getType ( ) 
 + { 
 + return type = = null ? ValueType . STRING : type ; 
 + } 
 + 
 + public Object get ( ASMInfo pool ) 
 + { 
 + if ( _ value = = null ) 
 + { 
 + if ( values ! = null ) 
 + { 
 + if ( type = = ValueType . ANNOTATION ) 
 + { 
 + List < Map < String , Object > > list = Lists . newArrayList ( ) ; 
 + _ value = list ; 
 + 
 + for ( String s : values ) 
 + { 
 + Annotation sub = pool . getSubAnnotation ( Integer . parseInt ( s ) ) ; 
 + if ( sub = = null ) 
 + FMLLog . log . error ( " Invalid Sub - Annotation in Annotation JSON : " + s ) ; 
 + else 
 + list . add ( sub . getValues ( pool ) ) ; 
 + } 
 + } 
 + else 
 + _ value = getType ( ) . array . apply ( values ) ; 
 + } 
 + else 
 + { 
 + if ( type = = ValueType . ANNOTATION ) 
 + { 
 + Annotation sub = pool . getSubAnnotation ( Integer . parseInt ( value ) ) ; 
 + if ( sub = = null ) 
 + FMLLog . log . error ( " Invalid Sub - Annotation in Annotation JSON : " + value ) ; 
 + else 
 + _ value = sub . getValues ( pool ) ; 
 + } 
 + else 
 + _ value = getType ( ) . single . apply ( value ) ; 
 + } 
 + } 
 + return _ value ; 
 + } 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / discovery / json / JsonAnnotationLoader . java b / src / main / java / net / minecraftforge / fml / common / discovery / json / JsonAnnotationLoader . java 
 new file mode 100644 
 index 0000000 . . 8af098e 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / common / discovery / json / JsonAnnotationLoader . java 
 @ @ - 0 , 0 + 1 , 77 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2018 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package net . minecraftforge . fml . common . discovery . json ; 
 + 
 + import java . io . InputStream ; 
 + import java . io . InputStreamReader ; 
 + import java . lang . reflect . Type ; 
 + import java . util . Map ; 
 + import java . util . Map . Entry ; 
 + 
 + import com . google . common . collect . HashMultimap ; 
 + import com . google . common . collect . Multimap ; 
 + import com . google . gson . Gson ; 
 + import com . google . gson . GsonBuilder ; 
 + import com . google . gson . reflect . TypeToken ; 
 + 
 + import net . minecraftforge . fml . common . discovery . ASMDataTable ; 
 + import net . minecraftforge . fml . common . discovery . ASMDataTable . ASMData ; 
 + import net . minecraftforge . fml . common . discovery . ModCandidate ; 
 + import net . minecraftforge . fml . common . discovery . json . ASMInfo . Annotation ; 
 + 
 + public class JsonAnnotationLoader 
 + { 
 + public static final String ANNOTATION _ JSON = " META - INF / fml _ cache _ annotation . json " ; 
 + private static final Gson GSON = new GsonBuilder ( ) . create ( ) ; 
 + private static final Type INFO _ TABLE = new TypeToken < Map < String , ASMInfo > > ( ) { } . getType ( ) ; 
 + 
 + public static Multimap < String , ASMData > loadJson ( InputStream data , ModCandidate candidate , ASMDataTable table ) 
 + { 
 + Map < String , ASMInfo > map = GSON . fromJson ( new InputStreamReader ( data ) , INFO _ TABLE ) ; 
 + Multimap < String , ASMData > ret = HashMultimap . create ( ) ; 
 + 
 + for ( Entry < String , ASMInfo > entry : map . entrySet ( ) ) 
 + { 
 + / / TODO : Java9 Multi - Release Jars , picking the correct class for the current platform . For now we just ignore them . 
 + if ( entry . getKey ( ) . startsWith ( " META - INF / " ) ) 
 + continue ; 
 + 
 + ASMInfo asm _ info = entry . getValue ( ) ; 
 + if ( asm _ info . interfaces ! = null ) 
 + { 
 + for ( String type : asm _ info . interfaces ) 
 + { 
 + table . addASMData ( candidate , type , asm _ info . name , null , null ) ; 
 + ret . put ( type , new ASMData ( candidate , type , asm _ info . name , null , null ) ) ; 
 + } 
 + } 
 + 
 + if ( asm _ info . annotations ! = null ) 
 + { 
 + for ( Annotation anno : asm _ info . annotations ) 
 + { 
 + table . addASMData ( candidate , anno . name , asm _ info . name , anno . target , anno . getValues ( asm _ info ) ) ; 
 + ret . put ( anno . name , new ASMData ( candidate , anno . name , asm _ info . name , anno . target , anno . getValues ( asm _ info ) ) ) ; 
 + } 
 + } 
 + } 
 + 
 + return ret ; 
 + } 
 + } 
 diff - - git a / src / test / java / net / minecraftforge / test / TestAnnotationParser . java b / src / test / java / net / minecraftforge / test / TestAnnotationParser . java 
 new file mode 100644 
 index 0000000 . . 109364a 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / test / TestAnnotationParser . java 
 @ @ - 0 , 0 + 1 , 172 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2018 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package net . minecraftforge . test ; 
 + 
 + import java . io . File ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . net . URL ; 
 + import java . util . Collections ; 
 + import java . util . regex . Matcher ; 
 + import java . util . regex . Pattern ; 
 + import java . util . zip . ZipEntry ; 
 + import java . util . zip . ZipFile ; 
 + 
 + import org . junit . Test ; 
 + 
 + import net . minecraftforge . fml . common . discovery . ASMDataTable ; 
 + import net . minecraftforge . fml . common . discovery . ContainerType ; 
 + import net . minecraftforge . fml . common . discovery . ModCandidate ; 
 + import net . minecraftforge . fml . common . discovery . asm . ASMModParser ; 
 + import net . minecraftforge . fml . common . discovery . json . JsonAnnotationLoader ; 
 + 
 + public class TestAnnotationParser 
 + { 
 + private static String TEST _ JAR = " forestry _ 1 . 12 . 2 - 5 . 7 . 0 . 0 . jar " ; 
 + public static Pattern classFile = Pattern . compile ( " [ ^ \ \ s \ \ $ ] + ( \ \ $ [ ^ \ \ s ] + ) ? \ \ . class $ " ) ; 
 + private static final int RUN _ COUNT = 100 ; 
 + 
 + private File getFile ( ) 
 + { 
 + ClassLoader cl = getClass ( ) . getClassLoader ( ) ; 
 + URL url = cl . getResource ( TEST _ JAR ) ; 
 + return url = = null ? null : new File ( url . getFile ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testAnnotationLoaderASM ( ) throws IOException 
 + { 
 + File jar = getFile ( ) ; 
 + if ( jar = = null ) 
 + return ; / / Skip this test if the test jar doesn ' t exist . 
 + 
 + Timer timer = new Timer ( ) ; 
 + for ( int x = 0 ; x < RUN _ COUNT ; x + + ) 
 + { 
 + timer . start ( ) ; 
 + loadAnnotationsASM ( jar ) ; 
 + timer . end ( null ) ; 
 + } 
 + System . out . println ( " LoaderASM : " + timer . finish ( ) ) ; 
 + } 
 + 
 + 
 + @ Test 
 + public void testAnnotationLoaderJSON ( ) throws IOException 
 + { 
 + File jar = getFile ( ) ; 
 + if ( jar = = null ) 
 + return ; / / Skip this test if the test jar doesn ' t exist . 
 + 
 + Timer timer = new Timer ( ) ; 
 + for ( int x = 0 ; x < RUN _ COUNT ; x + + ) 
 + { 
 + timer . start ( ) ; 
 + loadAnnotationsJSON ( jar ) ; 
 + timer . end ( null ) ; 
 + } 
 + System . out . println ( " LoaderJSON : " + timer . finish ( ) ) ; 
 + } 
 + 
 + private void loadAnnotationsASM ( File jar ) throws IOException 
 + { 
 + ASMDataTable dataTable = new ASMDataTable ( ) ; 
 + ModCandidate candidate = new ModCandidate ( jar , jar , ContainerType . JAR ) ; 
 + try ( ZipFile in = new ZipFile ( jar ) ) 
 + { 
 + for ( ZipEntry e : Collections . list ( in . entries ( ) ) ) 
 + { 
 + if ( e . getName ( ) ! = null & & e . getName ( ) . startsWith ( " _ _ MACOSX " ) ) 
 + continue ; 
 + 
 + Matcher match = classFile . matcher ( e . getName ( ) ) ; 
 + if ( match . matches ( ) ) 
 + { 
 + ASMModParser modParser ; 
 + try ( InputStream inputStream = in . getInputStream ( e ) ) 
 + { 
 + modParser = new ASMModParser ( inputStream ) ; 
 + } 
 + / / candidate . addClassEntry ( e . getName ( ) ) ; 
 + if ( modParser ! = null ) 
 + modParser . sendToTable ( dataTable , candidate ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + private void loadAnnotationsJSON ( File jar ) throws IOException 
 + { 
 + ASMDataTable dataTable = new ASMDataTable ( ) ; 
 + ModCandidate candidate = new ModCandidate ( jar , jar , ContainerType . JAR ) ; 
 + try ( ZipFile in = new ZipFile ( jar ) ) 
 + { 
 + / / We need to loop everything to gather a list of class files , but as we ' re not reading every entry we should be faster ? 
 + for ( ZipEntry e : Collections . list ( in . entries ( ) ) ) 
 + { 
 + if ( e . getName ( ) ! = null & & e . getName ( ) . startsWith ( " _ _ MACOSX " ) ) 
 + continue ; 
 + 
 + Matcher match = classFile . matcher ( e . getName ( ) ) ; 
 + if ( match . matches ( ) ) 
 + { 
 + / / We check for classes , make this fancier and support multi - release jars ? 
 + / / candidate . addClassEntry ( e . getName ( ) ) ; 
 + } 
 + } 
 + 
 + InputStream json _ input = in . getInputStream ( in . getEntry ( JsonAnnotationLoader . ANNOTATION _ JSON ) ) ; 
 + JsonAnnotationLoader . loadJson ( json _ input , candidate , dataTable ) ; 
 + } 
 + } 
 + 
 + private static class Timer 
 + { 
 + private long start ; 
 + private long min = Long . MAX _ VALUE ; 
 + private long max = Long . MIN _ VALUE ; 
 + private long total = 0 ; 
 + private int count = 0 ; 
 + 
 + public void start ( ) 
 + { 
 + this . start = System . currentTimeMillis ( ) ; 
 + } 
 + public void end ( String message ) 
 + { 
 + long now = System . currentTimeMillis ( ) ; 
 + long time = now - start ; 
 + if ( message ! = null ) 
 + System . out . println ( String . format ( message , time ) ) ; 
 + min = Long . min ( min , time ) ; 
 + max = Long . max ( max , time ) ; 
 + total + = time ; 
 + count + + ; 
 + } 
 + 
 + public String finish ( ) 
 + { 
 + return " Runs : " + count + 
 + " Min : " + min + 
 + " Max : " + max + 
 + " Total : " + total + 
 + " Average : " + ( total / count ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch b / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch 
 index 697a870 . . f9d344f 100644 
 - - - a / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch 
 + + + b / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch 
 @ @ - 1 , 6 + 1 , 11 @ @ 
 - - - . . / src - base / minecraft / net / minecraft / item / crafting / Ingredient . java 
 + + + . . / src - work / minecraft / net / minecraft / item / crafting / Ingredient . java 
 - @ @ - 13 , 6 + 13 , 8 @ @ 
 + @ @ - 8 , 11 + 8 , 11 @ @ 
 + import net . minecraft . client . util . RecipeItemHelper ; 
 + import net . minecraft . item . Item ; 
 + import net . minecraft . item . ItemStack ; 
 + - import net . minecraftforge . fml . relauncher . Side ; 
 + - import net . minecraftforge . fml . relauncher . SideOnly ; 
 
 public class Ingredient implements Predicate < ItemStack > 
 { 
 @ @ - 9 , 12 + 14 , 13 @ @ 
 public static final Ingredient field _ 193370 _ a = new Ingredient ( new ItemStack [ 0 ] ) 
 { 
 public boolean apply ( @ Nullable ItemStack p _ apply _ 1 _ ) 
 - @ @ - 21 , 17 + 23 , 34 @ @ 
 + @ @ - 21 , 17 + 21 , 41 @ @ 
 } 
 } ; 
 private final ItemStack [ ] field _ 193371 _ b ; 
 + private final ItemStack [ ] matchingStacksExploded ; 
 private IntList field _ 194140 _ c ; 
 + + private final boolean isSimple ; 
 
 + protected Ingredient ( int size ) 
 + { 
 @ @ - 23 , 6 + 29 , 7 @ @ 
 + 
 protected Ingredient ( ItemStack . . . p _ i47503 _ 1 _ ) 
 { 
 + + boolean simple = true ; 
 this . field _ 193371 _ b = p _ i47503 _ 1 _ ; 
 + net . minecraft . util . NonNullList < ItemStack > lst = net . minecraft . util . NonNullList . func _ 191196 _ a ( ) ; 
 + for ( ItemStack s : p _ i47503 _ 1 _ ) 
 @ @ - 30 , 11 + 37 , 16 @ @ 
 + if ( s . func _ 190926 _ b ( ) ) 
 + continue ; 
 + if ( s . func _ 77960 _ j ( ) = = net . minecraftforge . oredict . OreDictionary . WILDCARD _ VALUE ) 
 + + { 
 + + if ( s . func _ 77973 _ b ( ) . func _ 77645 _ m ( ) ) 
 + + simple = false ; 
 + s . func _ 77973 _ b ( ) . func _ 150895 _ a ( net . minecraft . creativetab . CreativeTabs . field _ 78027 _ g , lst ) ; 
 + + } 
 + else 
 + lst . add ( s ) ; 
 + } 
 + this . matchingStacksExploded = lst . toArray ( new ItemStack [ lst . size ( ) ] ) ; 
 + + this . isSimple = simple & & this . matchingStacksExploded . length > 0 ; 
 + Ingredient . INSTANCES . add ( this ) ; 
 } 
 
 @ @ - 46 , 7 + 58 , 7 @ @ 
 } 
 
 public boolean apply ( @ Nullable ItemStack p _ apply _ 1 _ ) 
 - @ @ - 63 , 9 + 82 , 9 @ @ 
 + @ @ - 63 , 9 + 87 , 9 @ @ 
 { 
 if ( this . field _ 194140 _ c = = null ) 
 { 
 @ @ - 58 , 7 + 70 , 7 @ @ 
 { 
 this . field _ 194140 _ c . add ( RecipeItemHelper . func _ 194113 _ b ( itemstack ) ) ; 
 } 
 - @ @ - 76 , 6 + 95 , 18 @ @ 
 + @ @ - 76 , 6 + 100 , 18 @ @ 
 return this . field _ 194140 _ c ; 
 } 
 
 @ @ - 77 , 7 + 89 , 7 @ @ 
 public static Ingredient func _ 193367 _ a ( Item p _ 193367 _ 0 _ ) 
 { 
 return func _ 193369 _ a ( new ItemStack ( p _ 193367 _ 0 _ , 1 , 32767 ) ) ; 
 - @ @ - 108 , 4 + 139 , 17 @ @ 
 + @ @ - 108 , 4 + 144 , 22 @ @ 
 
 return field _ 193370 _ a ; 
 } 
 @ @ - 94 , 4 + 106 , 9 @ @ 
 + } 
 + return new Ingredient ( lst . toArray ( new ItemStack [ lst . size ( ) ] ) ) ; 
 + } 
 + + 
 + + public boolean isSimple ( ) 
 + + { 
 + + return isSimple | | this = = field _ 193370 _ a ; 
 + + } 
 } 
 diff - - git a / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch b / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch 
 index df082d0 . . 34e6831 100644 
 - - - a / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch 
 + + + b / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 - - - . . / src - base / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java 
 + + + . . / src - work / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java 
 - @ @ - 10 , 10 + 10 , 8 @ @ 
 + @ @ - 10 , 23 + 10 , 25 @ @ 
 import net . minecraft . util . JsonUtils ; 
 import net . minecraft . util . NonNullList ; 
 import net . minecraft . world . World ; 
 @ @ - 12 , 15 + 12 , 25 @ @ 
 { 
 private final ItemStack field _ 77580 _ a ; 
 public final NonNullList < Ingredient > field _ 77579 _ b ; 
 - @ @ - 26 , 7 + 24 , 6 @ @ 
 + private final String field _ 194138 _ c ; 
 + + private final boolean isSimple ; 
 + 
 + public ShapelessRecipes ( String p _ i47500 _ 1 _ , ItemStack p _ i47500 _ 2 _ , NonNullList < Ingredient > p _ i47500 _ 3 _ ) 
 + { 
 + this . field _ 194138 _ c = p _ i47500 _ 1 _ ; 
 + this . field _ 77580 _ a = p _ i47500 _ 2 _ ; 
 this . field _ 77579 _ b = p _ i47500 _ 3 _ ; 
 + + boolean simple = true ; 
 + + for ( Ingredient i : p _ i47500 _ 3 _ ) 
 + + simple & = i . isSimple ( ) ; 
 + + this . isSimple = simple ; 
 } 
 
 - @ SideOnly ( Side . CLIENT ) 
 public String func _ 193358 _ e ( ) 
 { 
 return this . field _ 194138 _ c ; 
 - @ @ - 50 , 10 + 47 , 7 @ @ 
 + @ @ - 50 , 10 + 52 , 7 @ @ 
 { 
 ItemStack itemstack = p _ 179532 _ 1 _ . func _ 70301 _ a ( i ) ; 
 
 @ @ - 32 , 17 + 42 , 18 @ @ 
 } 
 
 return nonnulllist ; 
 - @ @ - 61 , 7 + 55 , 8 @ @ 
 + @ @ - 61 , 7 + 60 , 9 @ @ 
 
 public boolean func _ 77569 _ a ( InventoryCrafting p _ 77569 _ 1 _ , World p _ 77569 _ 2 _ ) 
 { 
 - List < Ingredient > list = Lists . newArrayList ( this . field _ 77579 _ b ) ; 
 + int ingredientCount = 0 ; 
 + net . minecraft . client . util . RecipeItemHelper recipeItemHelper = new net . minecraft . client . util . RecipeItemHelper ( ) ; 
 + + List < ItemStack > inputs = Lists . newArrayList ( ) ; 
 
 for ( int i = 0 ; i < p _ 77569 _ 1 _ . func _ 174923 _ h ( ) ; + + i ) 
 { 
 - @ @ - 71 , 27 + 66 , 13 @ @ 
 + @ @ - 71 , 27 + 72 , 22 @ @ 
 
 if ( ! itemstack . func _ 190926 _ b ( ) ) 
 { 
 @ @ - 63 , 17 + 74 , 26 @ @ 
 - return false ; 
 - } 
 + + + ingredientCount ; 
 - + recipeItemHelper . func _ 194112 _ a ( itemstack ) ; 
 + + if ( this . isSimple ) 
 + + recipeItemHelper . func _ 194112 _ a ( itemstack ) ; 
 + + else 
 + + inputs . add ( itemstack ) ; 
 } 
 } 
 } 
 
 - return list . isEmpty ( ) ; 
 - + return ingredientCount = = this . field _ 77579 _ b . size ( ) & & recipeItemHelper . func _ 194116 _ a ( this , null ) ; 
 + + if ( ingredientCount ! = this . field _ 77579 _ b . size ( ) ) 
 + + return false ; 
 + + 
 + + if ( this . isSimple ) 
 + + return recipeItemHelper . func _ 194116 _ a ( this , null ) ; 
 + + 
 + + return net . minecraftforge . common . util . RecipeMatcher . findMatches ( inputs , this . field _ 77579 _ b ) ! = null ; 
 } 
 
 public ItemStack func _ 77572 _ b ( InventoryCrafting p _ 77572 _ 1 _ ) 
 - @ @ - 136 , 7 + 117 , 6 @ @ 
 + @ @ - 136 , 7 + 132 , 6 @ @ 
 return nonnulllist ; 
 } 
 
 diff - - git a / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java b / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java 
 index 32a2c02 . . 60909dd 100644 
 - - - a / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java 
 + + + b / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java 
 @ @ - 20 , 11 + 20 , 17 @ @ public class CompoundIngredient extends Ingredient 
 private Collection < Ingredient > children ; 
 private ItemStack [ ] stacks ; 
 private IntList itemIds ; 
 + private final boolean isSimple ; 
 
 protected CompoundIngredient ( Collection < Ingredient > children ) 
 { 
 super ( 0 ) ; 
 this . children = children ; 
 + 
 + boolean simple = true ; 
 + for ( Ingredient child : children ) 
 + simple & = child . isSimple ( ) ; 
 + this . isSimple = simple ; 
 } 
 
 @ Override 
 @ @ - 78 , 4 + 84 , 10 @ @ public class CompoundIngredient extends Ingredient 
 this . stacks = null ; 
 / / Shouldn ' t need to invalidate children as this is only called form invalidateAll . . 
 } 
 + 
 + @ Override 
 + public boolean isSimple ( ) 
 + { 
 + return isSimple ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java b / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java 
 index 3f7c31e . . 9a85682 100644 
 - - - a / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java 
 + + + b / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java 
 @ @ - 40 , 4 + 40 , 10 @ @ public class IngredientNBT extends Ingredient 
 / / Can ' t use areItemStacksEqualUsingNBTShareTag because it compares stack size as well 
 return this . stack . getItem ( ) = = input . getItem ( ) & & this . stack . getItemDamage ( ) = = input . getItemDamage ( ) & & ItemStack . areItemStackShareTagsEqual ( this . stack , input ) ; 
 } 
 + 
 + @ Override 
 + public boolean isSimple ( ) 
 + { 
 + return false ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java b / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java 
 new file mode 100644 
 index 0000000 . . c8549ff 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java 
 @ @ - 0 , 0 + 1 , 162 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package net . minecraftforge . common . util ; 
 + 
 + import java . util . BitSet ; 
 + import java . util . LinkedList ; 
 + import java . util . List ; 
 + import java . util . Queue ; 
 + 
 + import com . google . common . base . Predicate ; 
 + 
 + public class RecipeMatcher 
 + { 
 + / * * 
 + * Attempts to match inputs to the specified tests . In the best way that all inputs are used by one test . 
 + * Will return null in any of these cases : 
 + * input / test lengths don ' t match . This is only for matching paired outputs . 
 + * any input doesn ' t match a test 
 + * any test doesn ' t match a input 
 + * If we are unable to determine a proper pair 
 + * 
 + * @ return An array mapping inputs to tests . ret [ x ] = y means input [ x ] = test [ y ] 
 + * / 
 + public static < T > int [ ] findMatches ( List < T > inputs , List < ? extends Predicate < T > > tests ) 
 + { 
 + int elements = inputs . size ( ) ; 
 + if ( elements ! = tests . size ( ) ) 
 + return null ; / / There will not be a 1 : 1 mapping of inputs - > tests 
 + 
 + int [ ] ret = new int [ elements ] ; 
 + for ( int x = 0 ; x < elements ; x + + ) 
 + ret [ x ] = - 1 ; 
 + 
 + / / [ UnusedInputs ] [ UnusedIngredients ] [ IngredientMatchMask ] . . . 
 + BitSet data = new BitSet ( ( elements + 2 ) * elements ) ; 
 + for ( int x = 0 ; x < elements ; x + + ) 
 + { 
 + int matched = 0 ; 
 + int offset = ( x + 2 ) * elements ; 
 + Predicate < T > test = tests . get ( x ) ; 
 + 
 + for ( int y = 0 ; y < elements ; y + + ) 
 + { 
 + if ( data . get ( y ) ) 
 + continue ; 
 + 
 + if ( test . apply ( inputs . get ( y ) ) ) 
 + { 
 + data . set ( offset + y ) ; 
 + matched + + ; 
 + } 
 + } 
 + 
 + if ( matched = = 0 ) 
 + return null ; / / We have an test that matched non of the inputs 
 + 
 + if ( matched = = 1 ) 
 + { 
 + if ( ! claim ( ret , data , x , elements ) ) 
 + return null ; / / We failed to claim this index , which means it caused something else to go to 0 matches , which makes the whole thing fail 
 + } 
 + } 
 + 
 + if ( data . nextClearBit ( 0 ) > = elements ) / / All items have been used , which means all tests have a match ! 
 + return ret ; 
 + 
 + / / We should be in a state where multiple tests are satified by multiple inputs . So we need to try a branching recursive test . 
 + / / However for performance reasons , we should probably make that check a sub - set of the entire graph . 
 + if ( backtrack ( data , ret , 0 , elements ) ) 
 + return ret ; 
 + 
 + return null ; / / Backtrack failed , no matches , we cry and go home now : ( 
 + } 
 + 
 + / / This is bad . . . need to think of a better cascade , recursion instead of stack ? 
 + private static boolean claim ( int [ ] ret , BitSet data , int claimed , int elements ) 
 + { 
 + Queue < Integer > pending = new LinkedList < Integer > ( ) ; 
 + pending . add ( claimed ) ; 
 + 
 + while ( pending . peek ( ) ! = null ) 
 + { 
 + int test = pending . poll ( ) ; 
 + int offset = ( test + 2 ) * elements ; 
 + int used = data . nextSetBit ( offset ) - offset ; 
 + 
 + if ( used > = elements | | used < 0 ) 
 + throw new IllegalStateException ( " What ? We matched something , but it wasn ' t set in the range of this test ! Test : " + test + " Used : " + used ) ; 
 + 
 + data . set ( used ) ; 
 + data . set ( elements + test ) ; 
 + ret [ used ] = test ; 
 + 
 + for ( int x = 0 ; x < elements ; x + + ) 
 + { 
 + offset = ( x + 2 ) * elements ; 
 + if ( data . get ( offset + used ) & & ! data . get ( elements + x ) ) 
 + { 
 + data . clear ( offset + used ) ; 
 + int count = 0 ; 
 + for ( int y = offset ; y < offset + elements ; y + + ) 
 + if ( data . get ( y ) ) 
 + count + + ; 
 + 
 + if ( count = = 0 ) 
 + return false ; / / Claiming this caused another test to lose its last match . . 
 + 
 + if ( count = = 1 ) 
 + pending . add ( x ) ; 
 + } 
 + } 
 + } 
 + 
 + return true ; 
 + } 
 + 
 + / / We use recursion here , why ? Because I feel like it . Also because we should only ever be working in data sets < 9 
 + private static boolean backtrack ( BitSet data , int [ ] ret , int start , int elements ) 
 + { 
 + int test = data . nextClearBit ( elements + start ) - elements ; 
 + if ( test > = elements ) 
 + return true ; / / Could not find the next unused test . 
 + 
 + if ( test < 0 ) 
 + throw new IllegalStateException ( " This should never happen , negative test in backtrack ! " ) ; 
 + 
 + int offset = ( test + 2 ) * elements ; 
 + for ( int x = 0 ; x < elements ; x + + ) 
 + { 
 + if ( ! data . get ( offset + x ) | | data . get ( x ) ) 
 + continue ; 
 + 
 + data . set ( x ) ; 
 + 
 + if ( backtrack ( data , ret , test + 1 , elements ) ) 
 + { 
 + ret [ x ] = test ; 
 + return true ; 
 + } 
 + 
 + data . clear ( x ) ; 
 + } 
 + 
 + return false ; 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / oredict / OreIngredient . java b / src / main / java / net / minecraftforge / oredict / OreIngredient . java 
 index 11ae517 . . 9a017b9 100644 
 - - - a / src / main / java / net / minecraftforge / oredict / OreIngredient . java 
 + + + b / src / main / java / net / minecraftforge / oredict / OreIngredient . java 
 @ @ - 114 , 4 + 114 , 10 @ @ public class OreIngredient extends Ingredient 
 this . itemIds = null ; 
 this . array = null ; 
 } 
 + 
 + @ Override 
 + public boolean isSimple ( ) 
 + { 
 + return true ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java b / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java 
 index 56d9485 . . db07357 100644 
 - - - a / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java 
 + + + b / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java 
 @ @ - 33 , 6 + 33 , 7 @ @ import net . minecraft . util . ResourceLocation ; 
 import net . minecraft . world . World ; 
 import net . minecraftforge . common . crafting . CraftingHelper ; 
 import net . minecraftforge . common . crafting . JsonContext ; 
 + import net . minecraftforge . common . util . RecipeMatcher ; 
 import net . minecraftforge . registries . IForgeRegistryEntry ; 
 
 import javax . annotation . Nonnull ; 
 @ @ - 48 , 6 + 49 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 protected ItemStack output = ItemStack . EMPTY ; 
 protected NonNullList < Ingredient > input = NonNullList . create ( ) ; 
 protected ResourceLocation group ; 
 + protected boolean isSimple = true ; 
 
 public ShapelessOreRecipe ( ResourceLocation group , Block result , Object . . . recipe ) { this ( group , new ItemStack ( result ) , recipe ) ; } 
 public ShapelessOreRecipe ( ResourceLocation group , Item result , Object . . . recipe ) { this ( group , new ItemStack ( result ) , recipe ) ; } 
 @ @ - 56 , 6 + 58 , 8 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 this . group = group ; 
 output = result . copy ( ) ; 
 this . input = input ; 
 + for ( Ingredient i : input ) 
 + this . isSimple & = i . isSimple ( ) ; 
 } 
 public ShapelessOreRecipe ( ResourceLocation group , @ Nonnull ItemStack result , Object . . . recipe ) 
 { 
 @ @ - 67 , 6 + 71 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 if ( ing ! = null ) 
 { 
 input . add ( ing ) ; 
 + this . isSimple & = ing . isSimple ( ) ; 
 } 
 else 
 { 
 @ @ - 94 , 6 + 99 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 { 
 int ingredientCount = 0 ; 
 RecipeItemHelper recipeItemHelper = new RecipeItemHelper ( ) ; 
 + List < ItemStack > items = Lists . newArrayList ( ) ; 
 
 for ( int i = 0 ; i < inv . getSizeInventory ( ) ; + + i ) 
 { 
 @ @ - 101 , 11 + 107 , 20 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 if ( ! itemstack . isEmpty ( ) ) 
 { 
 + + ingredientCount ; 
 - recipeItemHelper . accountStack ( itemstack ) ; 
 + if ( this . isSimple ) 
 + recipeItemHelper . accountStack ( itemstack ) ; 
 + else 
 + items . add ( itemstack ) ; 
 } 
 } 
 
 - return ingredientCount = = this . input . size ( ) & & recipeItemHelper . canCraft ( this , null ) ; 
 + if ( ingredientCount ! = this . input . size ( ) ) 
 + return false ; 
 + 
 + if ( this . isSimple ) 
 + return recipeItemHelper . canCraft ( this , null ) ; 
 + 
 + return RecipeMatcher . findMatches ( items , this . input ) ! = null ; 
 } 
 
 @ Override 
 diff - - git a / src / test / java / net / minecraftforge / debug / RecipeTestMod . java b / src / test / java / net / minecraftforge / debug / RecipeTestMod . java 
 index cc9c48c . . df3e1b8 100644 
 - - - a / src / test / java / net / minecraftforge / debug / RecipeTestMod . java 
 + + + b / src / test / java / net / minecraftforge / debug / RecipeTestMod . java 
 @ @ - 1 , 44 + 1 , 108 @ @ 
 package net . minecraftforge . debug ; 
 
 + import java . util . Random ; 
 + 
 + import net . minecraft . client . renderer . block . model . ModelResourceLocation ; 
 + import net . minecraft . creativetab . CreativeTabs ; 
 import net . minecraft . init . Blocks ; 
 + import net . minecraft . item . Item ; 
 import net . minecraft . item . ItemStack ; 
 import net . minecraft . item . crafting . IRecipe ; 
 import net . minecraft . item . crafting . ShapedRecipes ; 
 + import net . minecraft . util . EnumActionResult ; 
 import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . client . model . ModelLoader ; 
 import net . minecraftforge . common . MinecraftForge ; 
 import net . minecraftforge . common . crafting . CraftingHelper ; 
 + import net . minecraftforge . debug . OnItemUseFirstTest . CommonProxy ; 
 + import net . minecraftforge . debug . OnItemUseFirstTest . ItemTest ; 
 import net . minecraftforge . event . RegistryEvent ; 
 import net . minecraftforge . fml . common . Mod ; 
 + import net . minecraftforge . fml . common . SidedProxy ; 
 import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; 
 + import net . minecraftforge . fml . common . registry . GameRegistry . ObjectHolder ; 
 import net . minecraftforge . fml . relauncher . FMLLaunchHandler ; 
 import net . minecraftforge . fml . relauncher . Side ; 
 import net . minecraftforge . oredict . ShapedOreRecipe ; 
 
 - @ Mod ( modid = " recipetest " , name = " Recipe test mod " , version = " 1 . 0 " , acceptableRemoteVersions = " * " ) 
 + @ Mod ( modid = RecipeTestMod . MODID , name = " Recipe test mod " , version = " 1 . 0 " , acceptableRemoteVersions = " * " ) 
 public class RecipeTestMod 
 { 
 + public static final String MODID = " recipetest " ; 
 + private static final boolean ENABLED = true ; 
 + @ SidedProxy 
 + public static CommonProxy proxy = null ; 
 + 
 + 
 @ Mod . EventHandler 
 public void preinit ( FMLPreInitializationEvent event ) 
 { 
 - MinecraftForge . EVENT _ BUS . register ( this ) ; 
 + if ( ENABLED ) 
 + MinecraftForge . EVENT _ BUS . register ( this ) ; 
 } 
 
 @ SubscribeEvent 
 public void registerRecipes ( RegistryEvent . Register < IRecipe > event ) 
 { 
 - ResourceLocation location1 = new ResourceLocation ( " recipetest " , " dirt " ) ; 
 + ResourceLocation location1 = new ResourceLocation ( MODID , " dirt " ) ; 
 ShapedOreRecipe recipe1 = new ShapedOreRecipe ( location1 , new ItemStack ( Blocks . DIAMOND _ BLOCK ) , " DDD " , ' D ' , new ItemStack ( Blocks . DIRT ) ) ; 
 recipe1 . setRegistryName ( location1 ) ; 
 event . getRegistry ( ) . register ( recipe1 ) ; 
 
 if ( FMLLaunchHandler . side ( ) = = Side . SERVER ) 
 { 
 - ResourceLocation location2 = new ResourceLocation ( " recipetest " , " stone " ) ; 
 + ResourceLocation location2 = new ResourceLocation ( MODID , " stone " ) ; 
 CraftingHelper . ShapedPrimer primer1 = CraftingHelper . parseShaped ( " SSS " , ' S ' , new ItemStack ( Blocks . IRON _ BLOCK ) ) ; 
 ShapedRecipes recipe2 = new ShapedRecipes ( location2 . getResourcePath ( ) , primer1 . width , primer1 . height , primer1 . input , new ItemStack ( Blocks . GOLD _ BLOCK ) ) ; 
 recipe2 . setRegistryName ( location2 ) ; 
 event . getRegistry ( ) . register ( recipe2 ) ; 
 } 
 } 
 + 
 + @ SubscribeEvent 
 + public void registerItems ( RegistryEvent . Register < Item > event ) 
 + { 
 + proxy . registerItem ( event ) ; 
 + } 
 + 
 + public static abstract class CommonProxy 
 + { 
 + protected Item TOOL ; 
 + public void registerItem ( RegistryEvent . Register < Item > event ) 
 + { 
 + TOOL = new Item ( ) 
 + { 
 + Random RAND = new Random ( ) ; 
 + @ Override 
 + public ItemStack getContainerItem ( ItemStack in ) 
 + { 
 + ItemStack ret = in . copy ( ) ; 
 + ret . attemptDamageItem ( 1 , RAND , null ) ; 
 + return ret ; 
 + } 
 + 
 + @ Override 
 + public boolean hasContainerItem ( ) 
 + { 
 + return true ; 
 + } 
 + } . setRegistryName ( MODID , " tool " ) . setMaxDamage ( 10 ) . setCreativeTab ( CreativeTabs . MISC ) . setUnlocalizedName ( " recipetest . tool " ) . setMaxStackSize ( 1 ) ; 
 + event . getRegistry ( ) . register ( TOOL ) ; 
 + } 
 + } 
 + 
 + public static final class ServerProxy extends CommonProxy 
 + { 
 + } 
 + 
 + public static final class ClientProxy extends CommonProxy 
 + { 
 + @ Override 
 + public void registerItem ( RegistryEvent . Register < Item > event ) 
 + { 
 + super . registerItem ( event ) ; 
 + ModelLoader . setCustomModelResourceLocation ( TOOL , 0 , new ModelResourceLocation ( " minecraft : stick # inventory " ) ) ; 
 + } 
 + } 
 } 
 diff - - git a / src / test / resources / assets / forge / recipes / shapeless _ damageable . json b / src / test / resources / assets / forge / recipes / shapeless _ damageable . json 
 new file mode 100644 
 index 0000000 . . b345903 
 - - - / dev / null 
 + + + b / src / test / resources / assets / forge / recipes / shapeless _ damageable . json 
 @ @ - 0 , 0 + 1 , 13 @ @ 
 + { 
 + " type " : " minecraft : crafting _ shapeless " , 
 + " ingredients " : [ 
 + { 
 + " item " : " minecraft : bow " , 
 + " data " : 32767 
 + } 
 + ] , 
 + " result " : { 
 + " item " : " minecraft : wool " , 
 + " data " : 9 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / src / test / resources / assets / recipetest / recipes / tool _ complex . json b / src / test / resources / assets / recipetest / recipes / tool _ complex . json 
 new file mode 100644 
 index 0000000 . . f2d6c81 
 - - - / dev / null 
 + + + b / src / test / resources / assets / recipetest / recipes / tool _ complex . json 
 @ @ - 0 , 0 + 1 , 21 @ @ 
 + { 
 + " type " : " minecraft : crafting _ shapeless " , 
 + " ingredients " : [ 
 + { 
 + " item " : " tool " , 
 + " data " : 32767 
 + } , 
 + { 
 + " item " : " minecraft : stone " , 
 + " data " : 32767 
 + } , 
 + { 
 + " item " : " minecraft : stone " , 
 + " data " : 0 
 + } 
 + ] , 
 + " result " : { 
 + " item " : " minecraft : wool " , 
 + " data " : 0 
 + } 
 + } 
 diff - - git a / src / test / resources / assets / recipetest / recipes / tool _ simple . json b / src / test / resources / assets / recipetest / recipes / tool _ simple . json 
 new file mode 100644 
 index 0000000 . . 192c2fa 
 - - - / dev / null 
 + + + b / src / test / resources / assets / recipetest / recipes / tool _ simple . json 
 @ @ - 0 , 0 + 1 , 13 @ @ 
 + { 
 + " type " : " minecraft : crafting _ shapeless " , 
 + " ingredients " : [ 
 + { 
 + " item " : " tool " , 
 + " data " : 32767 
 + } 
 + ] , 
 + " result " : { 
 + " item " : " minecraft : wool " , 
 + " data " : 9 
 + } 
 + }
