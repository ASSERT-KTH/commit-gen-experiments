BLEU SCORE: 0.043008477182523305

TEST MSG: Written size does not include int bytes .
GENERATED MSG: Extend Region files to support > 1MB per chunk .

TEST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch b / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch <nl> index 21ba9b5 . . 56d8218 100644 <nl> - - - a / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch <nl> + + + b / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch <nl> @ @ - 21 , 7 + 21 , 7 @ @ <nl> + if ( length = = 255 ) { <nl> + if ( ( k > > 8 ) < = this . field _ 76714 _ f . size ( ) ) { / / We ' re maxed out , so we need to read the proper length from the section <nl> + this . field _ 76719 _ c . seek ( ( k > > 8 ) * 4096 ) ; <nl> - + length = ( this . field _ 76719 _ c . readInt ( ) / 4096 ) + 1 ; <nl> + + length = ( this . field _ 76719 _ c . readInt ( ) + 4 ) / 4096 + 1 ; <nl> + this . field _ 76719 _ c . seek ( j1 * 4 + 4 ) ; / / Go back to where we were <nl> + } <nl> + } <nl> @ @ - 41 , 7 + 41 , 7 @ @ <nl> int k = i & 255 ; <nl> + if ( k = = 255 ) { <nl> + this . field _ 76719 _ c . seek ( j * 4096 ) ; <nl> - + k = this . field _ 76719 _ c . readInt ( ) / 4096 + 1 ; <nl> + + k = ( this . field _ 76719 _ c . readInt ( ) + 4 ) / 4096 + 1 ; <nl> + } <nl> if ( j + k > this . field _ 76714 _ f . size ( ) ) { <nl> return null ; <nl> @ @ - 62 , 7 + 62 , 7 @ @ <nl> int k = i & 255 ; <nl> + if ( k = = 255 ) { <nl> + this . field _ 76719 _ c . seek ( j * 4096 ) ; <nl> - + k = this . field _ 76719 _ c . readInt ( ) / 4096 + 1 ; <nl> + + k = ( this . field _ 76719 _ c . readInt ( ) + 4 ) / 4096 + 1 ; <nl> + } <nl> int l = ( p _ 76706 _ 4 _ + 5 ) / 4096 + 1 ; <nl> if ( l > = 256 ) {
NEAREST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch b / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch <nl> new file mode 100644 <nl> index 0000000 . . 21ba9b5 <nl> - - - / dev / null <nl> + + + b / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch <nl> @ @ - 0 , 0 + 1 , 92 @ @ <nl> + - - - a / net / minecraft / world / chunk / storage / RegionFile . java <nl> + + + + b / net / minecraft / world / chunk / storage / RegionFile . java <nl> + @ @ - 18 , 6 + 18 , 10 @ @ <nl> + import net . minecraft . util . Util ; <nl> + <nl> + public class RegionFile { <nl> + + / / Minecraft is limited to 256 sections per chunk . So 1MB . This can easily be override . <nl> + + / / So we extend this to use the REAL size when the count is maxed by seeking to that section and reading the length . <nl> + + private static final boolean FORGE _ ENABLE _ EXTENDED _ SAVE = Boolean . parseBoolean ( System . getProperty ( " forge . enableExtendedSave " , " true " ) ) ; <nl> + + private static final org . apache . logging . log4j . Logger LOGGER = org . apache . logging . log4j . LogManager . getLogger ( ) ; <nl> + private static final byte [ ] field _ 76720 _ a = new byte [ 4096 ] ; <nl> + private final File field _ 76718 _ b ; <nl> + private RandomAccessFile field _ 76719 _ c ; <nl> + @ @ - 63 , 11 + 67 , 21 @ @ <nl> + for ( int j1 = 0 ; j1 < 1024 ; + + j1 ) { <nl> + int k = this . field _ 76719 _ c . readInt ( ) ; <nl> + this . field _ 76716 _ d [ j1 ] = k ; <nl> + - if ( k ! = 0 & & ( k > > 8 ) + ( k & 255 ) < = this . field _ 76714 _ f . size ( ) ) { <nl> + - for ( int l = 0 ; l < ( k & 255 ) ; + + l ) { <nl> + + int length = k & 255 ; <nl> + + if ( length = = 255 ) { <nl> + + if ( ( k > > 8 ) < = this . field _ 76714 _ f . size ( ) ) { / / We ' re maxed out , so we need to read the proper length from the section <nl> + + this . field _ 76719 _ c . seek ( ( k > > 8 ) * 4096 ) ; <nl> + + length = ( this . field _ 76719 _ c . readInt ( ) / 4096 ) + 1 ; <nl> + + this . field _ 76719 _ c . seek ( j1 * 4 + 4 ) ; / / Go back to where we were <nl> + + } <nl> + + } <nl> + + if ( k ! = 0 & & ( k > > 8 ) + length < = this . field _ 76714 _ f . size ( ) ) { <nl> + + for ( int l = 0 ; l < length ; + + l ) { <nl> + this . field _ 76714 _ f . set ( ( k > > 8 ) + l , false ) ; <nl> + } <nl> + } <nl> + + else if ( length > 0 ) <nl> + + LOGGER . warn ( " Invalid chunk : ( { } , { } ) Offset : { } Length : { } runs off end file . { } " , j1 % 32 , ( int ) ( j1 / 32 ) , k > > 8 , length , p _ i2001 _ 1 _ ) ; <nl> + } <nl> + <nl> + for ( int k1 = 0 ; k1 < 1024 ; + + k1 ) { <nl> + @ @ - 92 , 14 + 106 , 20 @ @ <nl> + } else { <nl> + int j = i > > 8 ; <nl> + int k = i & 255 ; <nl> + + if ( k = = 255 ) { <nl> + + this . field _ 76719 _ c . seek ( j * 4096 ) ; <nl> + + k = this . field _ 76719 _ c . readInt ( ) / 4096 + 1 ; <nl> + + } <nl> + if ( j + k > this . field _ 76714 _ f . size ( ) ) { <nl> + return null ; <nl> + } else { <nl> + this . field _ 76719 _ c . seek ( ( long ) ( j * 4096 ) ) ; <nl> + int l = this . field _ 76719 _ c . readInt ( ) ; <nl> + if ( l > 4096 * k ) { <nl> + + LOGGER . warn ( " Invalid chunk : ( { } , { } ) Offset : { } Invalid Size : { } > { } { } " , p _ 76704 _ 1 _ , p _ 76704 _ 2 _ , j , l , k * 4096 , field _ 76718 _ b ) ; <nl> + return null ; <nl> + } else if ( l < = 0 ) { <nl> + + LOGGER . warn ( " Invalid chunk : ( { } , { } ) Offset : { } Invalid Size : { } { } " , p _ 76704 _ 1 _ , p _ 76704 _ 2 _ , j , l , field _ 76718 _ b ) ; <nl> + return null ; <nl> + } else { <nl> + byte b0 = this . field _ 76719 _ c . readByte ( ) ; <nl> + @ @ - 162 , 9 + 182 , 14 @ @ <nl> + int i = this . func _ 76707 _ e ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ ) ; <nl> + int j = i > > 8 ; <nl> + int k = i & 255 ; <nl> + + if ( k = = 255 ) { <nl> + + this . field _ 76719 _ c . seek ( j * 4096 ) ; <nl> + + k = this . field _ 76719 _ c . readInt ( ) / 4096 + 1 ; <nl> + + } <nl> + int l = ( p _ 76706 _ 4 _ + 5 ) / 4096 + 1 ; <nl> + if ( l > = 256 ) { <nl> + - return ; <nl> + + if ( ! FORGE _ ENABLE _ EXTENDED _ SAVE ) return ; <nl> + + LOGGER . warn ( " Large Chunk Detected : ( { } , { } ) Size : { } { } " , p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , l , field _ 76718 _ b ) ; <nl> + } <nl> + <nl> + if ( j ! = 0 & & k = = l ) { <nl> + @ @ - 197 , 7 + 222 , 7 @ @ <nl> + <nl> + if ( j1 > = l ) { <nl> + j = l1 ; <nl> + - this . func _ 76711 _ a ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , l1 < < 8 | l ) ; <nl> + + this . func _ 76711 _ a ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , l1 < < 8 | ( l > 255 ? 255 : l ) ) ; <nl> + <nl> + for ( int j2 = 0 ; j2 < l ; + + j2 ) { <nl> + this . field _ 76714 _ f . set ( j + j2 , false ) ; <nl> + @ @ - 215 , 7 + 240 , 7 @ @ <nl> + <nl> + this . field _ 76715 _ g + = 4096 * l ; <nl> + this . func _ 76712 _ a ( j , p _ 76706 _ 3 _ , p _ 76706 _ 4 _ ) ; <nl> + - this . func _ 76711 _ a ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , j < < 8 | l ) ; <nl> + + this . func _ 76711 _ a ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , j < < 8 | ( l > 255 ? 255 : l ) ) ; <nl> + } <nl> + } <nl> +

TEST DIFF:
diff - - git a / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch b / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch 
 index 21ba9b5 . . 56d8218 100644 
 - - - a / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch 
 + + + b / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch 
 @ @ - 21 , 7 + 21 , 7 @ @ 
 + if ( length = = 255 ) { 
 + if ( ( k > > 8 ) < = this . field _ 76714 _ f . size ( ) ) { / / We ' re maxed out , so we need to read the proper length from the section 
 + this . field _ 76719 _ c . seek ( ( k > > 8 ) * 4096 ) ; 
 - + length = ( this . field _ 76719 _ c . readInt ( ) / 4096 ) + 1 ; 
 + + length = ( this . field _ 76719 _ c . readInt ( ) + 4 ) / 4096 + 1 ; 
 + this . field _ 76719 _ c . seek ( j1 * 4 + 4 ) ; / / Go back to where we were 
 + } 
 + } 
 @ @ - 41 , 7 + 41 , 7 @ @ 
 int k = i & 255 ; 
 + if ( k = = 255 ) { 
 + this . field _ 76719 _ c . seek ( j * 4096 ) ; 
 - + k = this . field _ 76719 _ c . readInt ( ) / 4096 + 1 ; 
 + + k = ( this . field _ 76719 _ c . readInt ( ) + 4 ) / 4096 + 1 ; 
 + } 
 if ( j + k > this . field _ 76714 _ f . size ( ) ) { 
 return null ; 
 @ @ - 62 , 7 + 62 , 7 @ @ 
 int k = i & 255 ; 
 + if ( k = = 255 ) { 
 + this . field _ 76719 _ c . seek ( j * 4096 ) ; 
 - + k = this . field _ 76719 _ c . readInt ( ) / 4096 + 1 ; 
 + + k = ( this . field _ 76719 _ c . readInt ( ) + 4 ) / 4096 + 1 ; 
 + } 
 int l = ( p _ 76706 _ 4 _ + 5 ) / 4096 + 1 ; 
 if ( l > = 256 ) {

NEAREST DIFF:
diff - - git a / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch b / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch 
 new file mode 100644 
 index 0000000 . . 21ba9b5 
 - - - / dev / null 
 + + + b / patches / minecraft / net / minecraft / world / chunk / storage / RegionFile . java . patch 
 @ @ - 0 , 0 + 1 , 92 @ @ 
 + - - - a / net / minecraft / world / chunk / storage / RegionFile . java 
 + + + + b / net / minecraft / world / chunk / storage / RegionFile . java 
 + @ @ - 18 , 6 + 18 , 10 @ @ 
 + import net . minecraft . util . Util ; 
 + 
 + public class RegionFile { 
 + + / / Minecraft is limited to 256 sections per chunk . So 1MB . This can easily be override . 
 + + / / So we extend this to use the REAL size when the count is maxed by seeking to that section and reading the length . 
 + + private static final boolean FORGE _ ENABLE _ EXTENDED _ SAVE = Boolean . parseBoolean ( System . getProperty ( " forge . enableExtendedSave " , " true " ) ) ; 
 + + private static final org . apache . logging . log4j . Logger LOGGER = org . apache . logging . log4j . LogManager . getLogger ( ) ; 
 + private static final byte [ ] field _ 76720 _ a = new byte [ 4096 ] ; 
 + private final File field _ 76718 _ b ; 
 + private RandomAccessFile field _ 76719 _ c ; 
 + @ @ - 63 , 11 + 67 , 21 @ @ 
 + for ( int j1 = 0 ; j1 < 1024 ; + + j1 ) { 
 + int k = this . field _ 76719 _ c . readInt ( ) ; 
 + this . field _ 76716 _ d [ j1 ] = k ; 
 + - if ( k ! = 0 & & ( k > > 8 ) + ( k & 255 ) < = this . field _ 76714 _ f . size ( ) ) { 
 + - for ( int l = 0 ; l < ( k & 255 ) ; + + l ) { 
 + + int length = k & 255 ; 
 + + if ( length = = 255 ) { 
 + + if ( ( k > > 8 ) < = this . field _ 76714 _ f . size ( ) ) { / / We ' re maxed out , so we need to read the proper length from the section 
 + + this . field _ 76719 _ c . seek ( ( k > > 8 ) * 4096 ) ; 
 + + length = ( this . field _ 76719 _ c . readInt ( ) / 4096 ) + 1 ; 
 + + this . field _ 76719 _ c . seek ( j1 * 4 + 4 ) ; / / Go back to where we were 
 + + } 
 + + } 
 + + if ( k ! = 0 & & ( k > > 8 ) + length < = this . field _ 76714 _ f . size ( ) ) { 
 + + for ( int l = 0 ; l < length ; + + l ) { 
 + this . field _ 76714 _ f . set ( ( k > > 8 ) + l , false ) ; 
 + } 
 + } 
 + + else if ( length > 0 ) 
 + + LOGGER . warn ( " Invalid chunk : ( { } , { } ) Offset : { } Length : { } runs off end file . { } " , j1 % 32 , ( int ) ( j1 / 32 ) , k > > 8 , length , p _ i2001 _ 1 _ ) ; 
 + } 
 + 
 + for ( int k1 = 0 ; k1 < 1024 ; + + k1 ) { 
 + @ @ - 92 , 14 + 106 , 20 @ @ 
 + } else { 
 + int j = i > > 8 ; 
 + int k = i & 255 ; 
 + + if ( k = = 255 ) { 
 + + this . field _ 76719 _ c . seek ( j * 4096 ) ; 
 + + k = this . field _ 76719 _ c . readInt ( ) / 4096 + 1 ; 
 + + } 
 + if ( j + k > this . field _ 76714 _ f . size ( ) ) { 
 + return null ; 
 + } else { 
 + this . field _ 76719 _ c . seek ( ( long ) ( j * 4096 ) ) ; 
 + int l = this . field _ 76719 _ c . readInt ( ) ; 
 + if ( l > 4096 * k ) { 
 + + LOGGER . warn ( " Invalid chunk : ( { } , { } ) Offset : { } Invalid Size : { } > { } { } " , p _ 76704 _ 1 _ , p _ 76704 _ 2 _ , j , l , k * 4096 , field _ 76718 _ b ) ; 
 + return null ; 
 + } else if ( l < = 0 ) { 
 + + LOGGER . warn ( " Invalid chunk : ( { } , { } ) Offset : { } Invalid Size : { } { } " , p _ 76704 _ 1 _ , p _ 76704 _ 2 _ , j , l , field _ 76718 _ b ) ; 
 + return null ; 
 + } else { 
 + byte b0 = this . field _ 76719 _ c . readByte ( ) ; 
 + @ @ - 162 , 9 + 182 , 14 @ @ 
 + int i = this . func _ 76707 _ e ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ ) ; 
 + int j = i > > 8 ; 
 + int k = i & 255 ; 
 + + if ( k = = 255 ) { 
 + + this . field _ 76719 _ c . seek ( j * 4096 ) ; 
 + + k = this . field _ 76719 _ c . readInt ( ) / 4096 + 1 ; 
 + + } 
 + int l = ( p _ 76706 _ 4 _ + 5 ) / 4096 + 1 ; 
 + if ( l > = 256 ) { 
 + - return ; 
 + + if ( ! FORGE _ ENABLE _ EXTENDED _ SAVE ) return ; 
 + + LOGGER . warn ( " Large Chunk Detected : ( { } , { } ) Size : { } { } " , p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , l , field _ 76718 _ b ) ; 
 + } 
 + 
 + if ( j ! = 0 & & k = = l ) { 
 + @ @ - 197 , 7 + 222 , 7 @ @ 
 + 
 + if ( j1 > = l ) { 
 + j = l1 ; 
 + - this . func _ 76711 _ a ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , l1 < < 8 | l ) ; 
 + + this . func _ 76711 _ a ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , l1 < < 8 | ( l > 255 ? 255 : l ) ) ; 
 + 
 + for ( int j2 = 0 ; j2 < l ; + + j2 ) { 
 + this . field _ 76714 _ f . set ( j + j2 , false ) ; 
 + @ @ - 215 , 7 + 240 , 7 @ @ 
 + 
 + this . field _ 76715 _ g + = 4096 * l ; 
 + this . func _ 76712 _ a ( j , p _ 76706 _ 3 _ , p _ 76706 _ 4 _ ) ; 
 + - this . func _ 76711 _ a ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , j < < 8 | l ) ; 
 + + this . func _ 76711 _ a ( p _ 76706 _ 1 _ , p _ 76706 _ 2 _ , j < < 8 | ( l > 255 ? 255 : l ) ) ; 
 + } 
 + } 
 +
