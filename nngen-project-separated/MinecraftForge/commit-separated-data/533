BLEU SCORE: 0.013139808552042212

TEST MSG: [ 1 . 11 ] Fix ItemHandlerHelper canStack and ItemStack areTagsEqual methods not checking capabilities
GENERATED MSG: Add Forge fluid handler test

TEST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / item / ItemStack . java . patch b / patches / minecraft / net / minecraft / item / ItemStack . java . patch <nl> index c66d1e3 . . 7bdbeb8 100644 <nl> - - - a / patches / minecraft / net / minecraft / item / ItemStack . java . patch <nl> + + + b / patches / minecraft / net / minecraft / item / ItemStack . java . patch <nl> @ @ - 186 , 6 + 186 , 15 @ @ <nl> <nl> if ( this . field _ 77990 _ d ! = null ) <nl> { <nl> + @ @ - 344 , 7 + 368 , 7 @ @ <nl> + <nl> + public static boolean func _ 77970 _ a ( ItemStack p _ 77970 _ 0 _ , ItemStack p _ 77970 _ 1 _ ) <nl> + { <nl> + - return p _ 77970 _ 0 _ . func _ 190926 _ b ( ) & & p _ 77970 _ 1 _ . func _ 190926 _ b ( ) ? true : ( ! p _ 77970 _ 0 _ . func _ 190926 _ b ( ) & & ! p _ 77970 _ 1 _ . func _ 190926 _ b ( ) ? ( p _ 77970 _ 0 _ . field _ 77990 _ d = = null & & p _ 77970 _ 1 _ . field _ 77990 _ d ! = null ? false : p _ 77970 _ 0 _ . field _ 77990 _ d = = null | | p _ 77970 _ 0 _ . field _ 77990 _ d . equals ( p _ 77970 _ 1 _ . field _ 77990 _ d ) ) : false ) ; <nl> + + return p _ 77970 _ 0 _ . func _ 190926 _ b ( ) & & p _ 77970 _ 1 _ . func _ 190926 _ b ( ) ? true : ( ! p _ 77970 _ 0 _ . func _ 190926 _ b ( ) & & ! p _ 77970 _ 1 _ . func _ 190926 _ b ( ) ? ( p _ 77970 _ 0 _ . field _ 77990 _ d = = null & & p _ 77970 _ 1 _ . field _ 77990 _ d ! = null ? false : ( p _ 77970 _ 0 _ . field _ 77990 _ d = = null | | p _ 77970 _ 0 _ . field _ 77990 _ d . equals ( p _ 77970 _ 1 _ . field _ 77990 _ d ) ) & & p _ 77970 _ 0 _ . areCapsCompatible ( p _ 77970 _ 1 _ ) ) : false ) ; <nl> + } <nl> + <nl> + public static boolean func _ 77989 _ b ( ItemStack p _ 77989 _ 0 _ , ItemStack p _ 77989 _ 1 _ ) <nl> @ @ - 758 , 6 + 782 , 7 @ @ <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / items / ItemHandlerHelper . java b / src / main / java / net / minecraftforge / items / ItemHandlerHelper . java <nl> index 8bdf297 . . a1b77c8 100644 <nl> - - - a / src / main / java / net / minecraftforge / items / ItemHandlerHelper . java <nl> + + + b / src / main / java / net / minecraftforge / items / ItemHandlerHelper . java <nl> @ @ - 54 , 12 + 54 , 10 @ @ public class ItemHandlerHelper <nl> <nl> public static boolean canItemStacksStack ( @ Nonnull ItemStack a , @ Nonnull ItemStack b ) <nl> { <nl> - if ( a . func _ 190926 _ b ( ) | | ! a . isItemEqual ( b ) ) <nl> + if ( a . func _ 190926 _ b ( ) | | ! a . isItemEqual ( b ) | | a . hasTagCompound ( ) ! = b . hasTagCompound ( ) ) <nl> return false ; <nl> <nl> - final NBTTagCompound aTag = a . getTagCompound ( ) ; <nl> - final NBTTagCompound bTag = b . getTagCompound ( ) ; <nl> - return ( aTag ! = null | | bTag = = null ) & & ( aTag = = null | | aTag . equals ( bTag ) ) ; <nl> + return ( ! a . hasTagCompound ( ) | | a . getTagCompound ( ) . equals ( b . getTagCompound ( ) ) ) & & a . areCapsCompatible ( b ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 80 , 9 + 78 , 10 @ @ public class ItemHandlerHelper <nl> if ( a . getHasSubtypes ( ) & & a . getMetadata ( ) ! = b . getMetadata ( ) ) <nl> return false ; <nl> <nl> - final NBTTagCompound aTag = a . getTagCompound ( ) ; <nl> - final NBTTagCompound bTag = b . getTagCompound ( ) ; <nl> - return ( aTag ! = null | | bTag = = null ) & & ( aTag = = null | | aTag . equals ( bTag ) ) ; <nl> + if ( a . hasTagCompound ( ) ! = b . hasTagCompound ( ) ) <nl> + return false ; <nl> + <nl> + return ( ! a . hasTagCompound ( ) | | a . getTagCompound ( ) . equals ( b . getTagCompound ( ) ) ) & & a . areCapsCompatible ( b ) ; <nl> } <nl> <nl> @ Nonnull <nl> diff - - git a / src / test / java / net / minecraftforge / test / TestCapabilityMod . java b / src / test / java / net / minecraftforge / test / TestCapabilityMod . java <nl> index 7ca33de . . 3cdd513 100644 <nl> - - - a / src / test / java / net / minecraftforge / test / TestCapabilityMod . java <nl> + + + b / src / test / java / net / minecraftforge / test / TestCapabilityMod . java <nl> @ @ - 3 , 6 + 3 , 7 @ @ package net . minecraftforge . test ; <nl> import net . minecraft . init . Blocks ; <nl> import net . minecraft . init . Items ; <nl> import net . minecraft . nbt . NBTBase ; <nl> + import net . minecraft . nbt . NBTTagCompound ; <nl> import net . minecraft . tileentity . TileEntity ; <nl> import net . minecraft . util . text . TextComponentString ; <nl> import net . minecraft . util . text . TextFormatting ; <nl> @ @ - 13 , 7 + 14 , 7 @ @ import net . minecraftforge . common . capabilities . Capability ; <nl> import net . minecraftforge . common . capabilities . Capability . IStorage ; <nl> import net . minecraftforge . common . capabilities . CapabilityInject ; <nl> import net . minecraftforge . common . capabilities . CapabilityManager ; <nl> - import net . minecraftforge . common . capabilities . ICapabilityProvider ; <nl> + import net . minecraftforge . common . capabilities . ICapabilitySerializable ; <nl> import net . minecraftforge . event . AttachCapabilitiesEvent ; <nl> import net . minecraftforge . event . entity . player . PlayerInteractEvent ; <nl> import net . minecraftforge . fml . common . Mod ; <nl> @ @ - 47 , 7 + 48 , 6 @ @ public class TestCapabilityMod <nl> @ SubscribeEvent <nl> public void onInteract ( PlayerInteractEvent . LeftClickBlock event ) <nl> { <nl> - if ( event . getItemStack ( ) . func _ 190926 _ b ( ) ) return ; <nl> if ( event . getItemStack ( ) . getItem ( ) ! = Items . STICK ) return ; <nl> <nl> / / This is just a example of how to interact with the TE , note the strong type binding that getCapability has <nl> @ @ - 58 , 13 + 58 , 27 @ @ public class TestCapabilityMod <nl> IExampleCapability inv = te . getCapability ( TEST _ CAP , event . getFace ( ) ) ; <nl> System . out . println ( " Hi I ' m a " + inv . getOwnerType ( ) ) ; <nl> } <nl> - if ( event . getWorld ( ) . getBlockState ( event . getPos ( ) ) . getBlock ( ) = = Blocks . DIRT ) <nl> + if ( event . getWorld ( ) . getBlockState ( event . getPos ( ) ) . getBlock ( ) = = Blocks . DIRT & & event . getItemStack ( ) . hasCapability ( TEST _ CAP , null ) ) <nl> { <nl> - event . getEntityPlayer ( ) . addChatMessage ( new TextComponentString ( TextFormatting . RED + " " + TextFormatting . ITALIC + " TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST " ) ) ; <nl> + IExampleCapability cap = event . getItemStack ( ) . getCapability ( TEST _ CAP , null ) ; <nl> + event . getEntityPlayer ( ) . addChatMessage ( new TextComponentString ( ( cap . getVal ( ) ? TextFormatting . GREEN : TextFormatting . RED ) + " " + TextFormatting . ITALIC + " TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST " ) ) ; <nl> event . setCanceled ( true ) ; <nl> } <nl> } <nl> <nl> + @ SubscribeEvent <nl> + public void onInteractItem ( PlayerInteractEvent . RightClickItem event ) <nl> + { <nl> + if ( ! event . getEntityPlayer ( ) . isSneaking ( ) ) return ; <nl> + if ( event . getItemStack ( ) . getItem ( ) ! = Items . STICK ) return ; <nl> + <nl> + if ( event . getItemStack ( ) . hasCapability ( TEST _ CAP , null ) ) <nl> + { <nl> + IExampleCapability cap = event . getItemStack ( ) . getCapability ( TEST _ CAP , null ) ; <nl> + cap . toggleVal ( ) ; <nl> + System . out . println ( " Test value is now : " + ( cap . getVal ( ) ? " TRUE " : " FALSE " ) ) ; <nl> + } <nl> + } <nl> <nl> / / Example of having this annotation on a method , this will be called when the capability is present . <nl> / / You could do something like register event handlers to attach these capabilities to objects , or <nl> @ @ - 75 , 6 + 89 , 54 @ @ public class TestCapabilityMod <nl> System . out . println ( " IExampleCapability was registered wheeeeee ! " ) ; <nl> } <nl> <nl> + / / Having the Provider implement the cap is not recommended as this creates a hard dep on the cap interface . <nl> + / / And does not allow for sidedness . <nl> + / / But as this is a example and we do not care about that here we go . <nl> + class Provider < V > implements ICapabilitySerializable < NBTTagCompound > , IExampleCapability <nl> + { <nl> + private V obj ; <nl> + private boolean value ; <nl> + <nl> + Provider ( V obj ) <nl> + { <nl> + this . obj = obj ; <nl> + } <nl> + @ Override <nl> + public boolean hasCapability ( @ Nonnull Capability < ? > capability , @ Nullable EnumFacing facing ) <nl> + { <nl> + return TEST _ CAP ! = null & & capability = = TEST _ CAP ; <nl> + } <nl> + @ Override <nl> + @ Nullable <nl> + public < T > T getCapability ( @ Nonnull Capability < T > capability , @ Nullable EnumFacing facing ) <nl> + { <nl> + if ( TEST _ CAP ! = null & & capability = = TEST _ CAP ) return TEST _ CAP . cast ( this ) ; <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public NBTTagCompound serializeNBT ( ) { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setBoolean ( " CapTestVal " , this . value ) ; <nl> + return tag ; <nl> + } <nl> + @ Override <nl> + public void deserializeNBT ( NBTTagCompound tag ) { <nl> + this . value = tag . getBoolean ( " CapTestVal " ) ; <nl> + } <nl> + @ Override <nl> + public String getOwnerType ( ) { <nl> + return obj . getClass ( ) . getName ( ) ; <nl> + } <nl> + @ Override <nl> + public boolean getVal ( ) { <nl> + return this . value ; <nl> + } <nl> + @ Override <nl> + public void toggleVal ( ) { <nl> + this . value = ! this . value ; <nl> + } <nl> + } <nl> + <nl> / / An example of how to attach a capability to an arbitrary Tile entity . <nl> / / Note : Doing this IS NOT recommended for normal implementations . <nl> / / If you control the TE it is HIGHLY recommend that you implement a fast <nl> @ @ - 83 , 39 + 145 , 17 @ @ public class TestCapabilityMod <nl> @ SubscribeEvent <nl> public void onTELoad ( AttachCapabilitiesEvent . TileEntity event ) <nl> { <nl> - / / Having the Provider implement the cap is not recomended as this creates a hard dep on the cap interface . <nl> - / / And doesnt allow for sidedness . <nl> - / / But as this is a example and we dont care about that here we go . <nl> - class Provider implements ICapabilityProvider , IExampleCapability <nl> - { <nl> - private TileEntity te ; <nl> - <nl> - Provider ( TileEntity te ) <nl> - { <nl> - this . te = te ; <nl> - } <nl> - @ Override <nl> - public boolean hasCapability ( @ Nonnull Capability < ? > capability , @ Nullable EnumFacing facing ) <nl> - { <nl> - return TEST _ CAP ! = null & & capability = = TEST _ CAP ; <nl> - } <nl> - @ Override <nl> - @ Nullable <nl> - public < T > T getCapability ( @ Nonnull Capability < T > capability , @ Nullable EnumFacing facing ) <nl> - { <nl> - if ( TEST _ CAP ! = null & & capability = = TEST _ CAP ) return TEST _ CAP . cast ( this ) ; <nl> - return null ; <nl> - } <nl> - @ Override <nl> - public String getOwnerType ( ) { <nl> - return te . getClass ( ) . getName ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / Attach it ! The resource location MUST be unique it ' s recomneded that you tag it with your modid and what the cap is . <nl> + / / Attach it ! The resource location MUST be unique it ' s recommended that you tag it with your modid and what the cap is . <nl> event . addCapability ( new ResourceLocation ( " forge . testcapmod : dummy _ cap " ) , new Provider ( event . getTileEntity ( ) ) ) ; <nl> } <nl> <nl> + @ SubscribeEvent <nl> + public void onItemLoad ( AttachCapabilitiesEvent . Item event ) <nl> + { <nl> + if ( event . getItemStack ( ) . getItem ( ) = = Items . STICK ) <nl> + event . addCapability ( new ResourceLocation ( " forge . testcapmod : dummy _ cap " ) , new Provider ( event . getItemStack ( ) ) ) ; <nl> + } <nl> + <nl> @ SuppressWarnings ( " rawtypes " ) <nl> @ SubscribeEvent <nl> public void attachEvent ( AttachCapabilitiesEvent event ) / / Test Raw type gets everything still . <nl> @ @ - 127 , 7 + 167 , 7 @ @ public class TestCapabilityMod <nl> public void attachTileEntity ( AttachCapabilitiesEvent < TileEntity > event ) <nl> { <nl> if ( ! ( event . getObject ( ) instanceof TileEntity ) ) <nl> - throw new IllegalArgumentException ( " Generic event handler failed ! Exprected Tile Entity got " + event . getObject ( ) ) ; <nl> + throw new IllegalArgumentException ( " Generic event handler failed ! Expected Tile Entity got " + event . getObject ( ) ) ; <nl> } <nl> <nl> / / Capabilities SHOULD be interfaces , NOT concrete classes , this allows for <nl> @ @ - 135 , 6 + 175 , 8 @ @ public class TestCapabilityMod <nl> public static interface IExampleCapability <nl> { <nl> String getOwnerType ( ) ; <nl> + boolean getVal ( ) ; <nl> + void toggleVal ( ) ; <nl> } <nl> <nl> / / Storage implementations are required , tho there is some flexibility here . <nl> @ @ - 160 , 5 + 202 , 10 @ @ public class TestCapabilityMod <nl> public String getOwnerType ( ) { <nl> return " Default Implementation ! " ; <nl> } <nl> + public boolean getVal ( ) { <nl> + return false ; <nl> + } <nl> + @ Override <nl> + public void toggleVal ( ) { } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / test / java / net / minecraftforge / debug / DynBucketTest . java b / src / test / java / net / minecraftforge / debug / DynBucketTest . java <nl> index e38452f . . ba06fcc 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / DynBucketTest . java <nl> + + + b / src / test / java / net / minecraftforge / debug / DynBucketTest . java <nl> @ @ - 54 , 9 + 54 , 14 @ @ public class DynBucketTest <nl> private static final ResourceLocation simpleTankName = new ResourceLocation ( MODID , " simpletank " ) ; <nl> private static final ResourceLocation testItemName = new ResourceLocation ( MODID , " testitem " ) ; <nl> <nl> + private static final boolean ENABLE = false ; <nl> + <nl> static <nl> { <nl> - FluidRegistry . enableUniversalBucket ( ) ; <nl> + if ( ENABLE ) <nl> + { <nl> + FluidRegistry . enableUniversalBucket ( ) ; <nl> + } <nl> } <nl> <nl> @ SidedProxy <nl> @ @ - 78 , 6 + 83 , 9 @ @ public class DynBucketTest <nl> @ Override <nl> void setupModels ( ) <nl> { <nl> + if ( ! ENABLE ) <nl> + return ; <nl> + <nl> ModelLoader . setBucketModelDefinition ( dynBucket ) ; <nl> <nl> final ModelResourceLocation bottle = new ModelResourceLocation ( new ResourceLocation ( " forge " , " dynbottle " ) , " inventory " ) ; <nl> @ @ - 99 , 6 + 107 , 9 @ @ public class DynBucketTest <nl> @ EventHandler <nl> public void preInit ( FMLPreInitializationEvent event ) <nl> { <nl> + if ( ! ENABLE ) <nl> + return ; <nl> + <nl> GameRegistry . register ( new TestItem ( ) , testItemName ) ; <nl> Block tank = new BlockSimpleTank ( ) ; <nl> GameRegistry . register ( tank , simpleTankName ) ; <nl> diff - - git a / src / test / java / net / minecraftforge / debug / ModelFluidDebug . java b / src / test / java / net / minecraftforge / debug / ModelFluidDebug . java <nl> index 9d92565 . . ccbfb40 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / ModelFluidDebug . java <nl> + + + b / src / test / java / net / minecraftforge / debug / ModelFluidDebug . java <nl> @ @ - 27 , 13 + 27 , 21 @ @ public class ModelFluidDebug <nl> public static final String MODID = " ForgeDebugModelFluid " ; <nl> public static final String VERSION = " 1 . 0 " ; <nl> <nl> + public static final boolean ENABLE = false ; <nl> + <nl> @ SidedProxy <nl> public static CommonProxy proxy ; <nl> <nl> public static final Fluid milkFluid = new Fluid ( " milk " , new ResourceLocation ( " forge " , " blocks / milk _ still " ) , new ResourceLocation ( " forge " , " blocks / milk _ flow " ) ) ; <nl> <nl> @ EventHandler <nl> - public void preInit ( FMLPreInitializationEvent event ) { proxy . preInit ( event ) ; } <nl> + public void preInit ( FMLPreInitializationEvent event ) <nl> + { <nl> + if ( ENABLE ) <nl> + { <nl> + proxy . preInit ( event ) ; <nl> + } <nl> + } <nl> <nl> public static class CommonProxy <nl> { <nl> diff - - git a / src / test / java / net / minecraftforge / test / FluidHandlerTest . java b / src / test / java / net / minecraftforge / test / FluidHandlerTest . java <nl> new file mode 100644 <nl> index 0000000 . . 0ed4331 <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / test / FluidHandlerTest . java <nl> @ @ - 0 , 0 + 1 , 108 @ @ <nl> + package net . minecraftforge . test ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + <nl> + import net . minecraft . creativetab . CreativeTabs ; <nl> + import net . minecraft . item . Item ; <nl> + import net . minecraft . item . ItemStack ; <nl> + import net . minecraftforge . fluids . Fluid ; <nl> + import net . minecraftforge . fluids . FluidRegistry ; <nl> + import net . minecraftforge . fluids . FluidStack ; <nl> + import net . minecraftforge . fluids . FluidUtil ; <nl> + import net . minecraftforge . fluids . capability . IFluidHandler ; <nl> + import net . minecraftforge . fml . common . FMLCommonHandler ; <nl> + import net . minecraftforge . fml . common . FMLLog ; <nl> + import net . minecraftforge . fml . common . Mod ; <nl> + import net . minecraftforge . fml . common . event . FMLLoadCompleteEvent ; <nl> + import net . minecraftforge . fml . common . registry . ForgeRegistries ; <nl> + import net . minecraftforge . fml . relauncher . Side ; <nl> + <nl> + @ Mod ( modid = " FluidHandlerTest " , name = " FluidHandlerTest " , version = " 0 . 0 . 0 " ) <nl> + public class FluidHandlerTest <nl> + { <nl> + 	 public static final boolean ENABLE = false ; <nl> + <nl> + 	 @ Mod . EventHandler <nl> + 	 public void loadComplete ( FMLLoadCompleteEvent event ) <nl> + 	 { <nl> + 	 	 if ( ! ENABLE | | FMLCommonHandler . instance ( ) . getSide ( ) ! = Side . CLIENT ) <nl> + 	 	 	 return ; <nl> + <nl> + 	 	 for ( ItemStack stack : getAllItems ( ) ) <nl> + 	 	 { <nl> + 	 	 	 testFluidContainer ( stack ) ; <nl> + 	 	 } <nl> + 	 } <nl> + <nl> + 	 private static void testFluidContainer ( ItemStack stack ) <nl> + 	 { <nl> + 	 	 ItemStack drainedStack = stack . copy ( ) ; <nl> + 	 	 IFluidHandler fluidHandler = FluidUtil . getFluidHandler ( drainedStack ) ; <nl> + 	 	 if ( fluidHandler ! = null ) <nl> + 	 	 { <nl> + 	 	 	 FluidStack drain = fluidHandler . drain ( Integer . MAX _ VALUE , true ) ; <nl> + 	 	 	 FMLLog . info ( " Draining " + stackString ( stack ) + " gives " + fluidString ( drain ) + " and " + stackString ( drainedStack ) ) ; <nl> + <nl> + 	 	 	 for ( Fluid fluid : FluidRegistry . getRegisteredFluids ( ) . values ( ) ) <nl> + 	 	 	 { <nl> + 	 	 	 	 ItemStack filledStack = stack . copy ( ) ; <nl> + 	 	 	 	 fluidHandler = FluidUtil . getFluidHandler ( filledStack ) ; <nl> + 	 	 	 	 if ( fluidHandler ! = null ) <nl> + 	 	 	 	 { <nl> + 	 	 	 	 	 int filled = fluidHandler . fill ( new FluidStack ( fluid , Integer . MAX _ VALUE ) , true ) ; <nl> + 	 	 	 	 	 if ( filled > 0 ) <nl> + 	 	 	 	 	 { <nl> + 	 	 	 	 	 	 FMLLog . info ( " Filling " + stackString ( stack ) + " with " + fluidString ( new FluidStack ( fluid , filled ) ) + " gives " + stackString ( filledStack ) ) ; <nl> + 	 	 	 	 	 } <nl> + 	 	 	 	 } <nl> + 	 	 	 } <nl> + 	 	 } <nl> + 	 } <nl> + <nl> + 	 private static String fluidString ( FluidStack stack ) <nl> + 	 { <nl> + 	 	 if ( stack = = null ) <nl> + 	 	 { <nl> + 	 	 	 return " no fluid " ; <nl> + 	 	 } <nl> + 	 	 else <nl> + 	 	 { <nl> + 	 	 	 return stack . amount + " mB " + stack . getLocalizedName ( ) ; <nl> + 	 	 } <nl> + 	 } <nl> + <nl> + 	 private static String stackString ( ItemStack stack ) <nl> + 	 { <nl> + 	 	 if ( stack = = null | | stack . stackSize < = 0 ) <nl> + 	 	 { <nl> + 	 	 	 return " no item " ; <nl> + 	 	 } <nl> + 	 	 else <nl> + 	 	 { <nl> + 	 	 	 String resourceDomain ; <nl> + 	 	 	 if ( stack . getItem ( ) = = null | | stack . getItem ( ) . getRegistryName ( ) = = null ) <nl> + 	 	 	 { <nl> + 	 	 	 	 resourceDomain = " unknown " ; <nl> + 	 	 	 } <nl> + 	 	 	 else <nl> + 	 	 	 { <nl> + 	 	 	 	 resourceDomain = stack . getItem ( ) . getRegistryName ( ) . getResourceDomain ( ) ; <nl> + 	 	 	 } <nl> + 	 	 	 return stack . stackSize + " " + stack . getDisplayName ( ) + " ( " + resourceDomain + " ) " ; <nl> + 	 	 } <nl> + 	 } <nl> + <nl> + 	 private static List < ItemStack > getAllItems ( ) <nl> + 	 { <nl> + 	 	 List < ItemStack > list = new ArrayList < ItemStack > ( ) ; <nl> + 	 	 for ( Item item : ForgeRegistries . ITEMS . getValues ( ) ) <nl> + 	 	 { <nl> + 	 	 	 for ( CreativeTabs tab : item . getCreativeTabs ( ) ) <nl> + 	 	 	 { <nl> + 	 	 	 	 item . getSubItems ( item , tab , list ) ; <nl> + 	 	 	 } <nl> + 	 	 } <nl> + 	 	 return list ; <nl> + 	 } <nl> + }

TEST DIFF:
diff - - git a / patches / minecraft / net / minecraft / item / ItemStack . java . patch b / patches / minecraft / net / minecraft / item / ItemStack . java . patch 
 index c66d1e3 . . 7bdbeb8 100644 
 - - - a / patches / minecraft / net / minecraft / item / ItemStack . java . patch 
 + + + b / patches / minecraft / net / minecraft / item / ItemStack . java . patch 
 @ @ - 186 , 6 + 186 , 15 @ @ 
 
 if ( this . field _ 77990 _ d ! = null ) 
 { 
 + @ @ - 344 , 7 + 368 , 7 @ @ 
 + 
 + public static boolean func _ 77970 _ a ( ItemStack p _ 77970 _ 0 _ , ItemStack p _ 77970 _ 1 _ ) 
 + { 
 + - return p _ 77970 _ 0 _ . func _ 190926 _ b ( ) & & p _ 77970 _ 1 _ . func _ 190926 _ b ( ) ? true : ( ! p _ 77970 _ 0 _ . func _ 190926 _ b ( ) & & ! p _ 77970 _ 1 _ . func _ 190926 _ b ( ) ? ( p _ 77970 _ 0 _ . field _ 77990 _ d = = null & & p _ 77970 _ 1 _ . field _ 77990 _ d ! = null ? false : p _ 77970 _ 0 _ . field _ 77990 _ d = = null | | p _ 77970 _ 0 _ . field _ 77990 _ d . equals ( p _ 77970 _ 1 _ . field _ 77990 _ d ) ) : false ) ; 
 + + return p _ 77970 _ 0 _ . func _ 190926 _ b ( ) & & p _ 77970 _ 1 _ . func _ 190926 _ b ( ) ? true : ( ! p _ 77970 _ 0 _ . func _ 190926 _ b ( ) & & ! p _ 77970 _ 1 _ . func _ 190926 _ b ( ) ? ( p _ 77970 _ 0 _ . field _ 77990 _ d = = null & & p _ 77970 _ 1 _ . field _ 77990 _ d ! = null ? false : ( p _ 77970 _ 0 _ . field _ 77990 _ d = = null | | p _ 77970 _ 0 _ . field _ 77990 _ d . equals ( p _ 77970 _ 1 _ . field _ 77990 _ d ) ) & & p _ 77970 _ 0 _ . areCapsCompatible ( p _ 77970 _ 1 _ ) ) : false ) ; 
 + } 
 + 
 + public static boolean func _ 77989 _ b ( ItemStack p _ 77989 _ 0 _ , ItemStack p _ 77989 _ 1 _ ) 
 @ @ - 758 , 6 + 782 , 7 @ @ 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / items / ItemHandlerHelper . java b / src / main / java / net / minecraftforge / items / ItemHandlerHelper . java 
 index 8bdf297 . . a1b77c8 100644 
 - - - a / src / main / java / net / minecraftforge / items / ItemHandlerHelper . java 
 + + + b / src / main / java / net / minecraftforge / items / ItemHandlerHelper . java 
 @ @ - 54 , 12 + 54 , 10 @ @ public class ItemHandlerHelper 
 
 public static boolean canItemStacksStack ( @ Nonnull ItemStack a , @ Nonnull ItemStack b ) 
 { 
 - if ( a . func _ 190926 _ b ( ) | | ! a . isItemEqual ( b ) ) 
 + if ( a . func _ 190926 _ b ( ) | | ! a . isItemEqual ( b ) | | a . hasTagCompound ( ) ! = b . hasTagCompound ( ) ) 
 return false ; 
 
 - final NBTTagCompound aTag = a . getTagCompound ( ) ; 
 - final NBTTagCompound bTag = b . getTagCompound ( ) ; 
 - return ( aTag ! = null | | bTag = = null ) & & ( aTag = = null | | aTag . equals ( bTag ) ) ; 
 + return ( ! a . hasTagCompound ( ) | | a . getTagCompound ( ) . equals ( b . getTagCompound ( ) ) ) & & a . areCapsCompatible ( b ) ; 
 } 
 
 / * * 
 @ @ - 80 , 9 + 78 , 10 @ @ public class ItemHandlerHelper 
 if ( a . getHasSubtypes ( ) & & a . getMetadata ( ) ! = b . getMetadata ( ) ) 
 return false ; 
 
 - final NBTTagCompound aTag = a . getTagCompound ( ) ; 
 - final NBTTagCompound bTag = b . getTagCompound ( ) ; 
 - return ( aTag ! = null | | bTag = = null ) & & ( aTag = = null | | aTag . equals ( bTag ) ) ; 
 + if ( a . hasTagCompound ( ) ! = b . hasTagCompound ( ) ) 
 + return false ; 
 + 
 + return ( ! a . hasTagCompound ( ) | | a . getTagCompound ( ) . equals ( b . getTagCompound ( ) ) ) & & a . areCapsCompatible ( b ) ; 
 } 
 
 @ Nonnull 
 diff - - git a / src / test / java / net / minecraftforge / test / TestCapabilityMod . java b / src / test / java / net / minecraftforge / test / TestCapabilityMod . java 
 index 7ca33de . . 3cdd513 100644 
 - - - a / src / test / java / net / minecraftforge / test / TestCapabilityMod . java 
 + + + b / src / test / java / net / minecraftforge / test / TestCapabilityMod . java 
 @ @ - 3 , 6 + 3 , 7 @ @ package net . minecraftforge . test ; 
 import net . minecraft . init . Blocks ; 
 import net . minecraft . init . Items ; 
 import net . minecraft . nbt . NBTBase ; 
 + import net . minecraft . nbt . NBTTagCompound ; 
 import net . minecraft . tileentity . TileEntity ; 
 import net . minecraft . util . text . TextComponentString ; 
 import net . minecraft . util . text . TextFormatting ; 
 @ @ - 13 , 7 + 14 , 7 @ @ import net . minecraftforge . common . capabilities . Capability ; 
 import net . minecraftforge . common . capabilities . Capability . IStorage ; 
 import net . minecraftforge . common . capabilities . CapabilityInject ; 
 import net . minecraftforge . common . capabilities . CapabilityManager ; 
 - import net . minecraftforge . common . capabilities . ICapabilityProvider ; 
 + import net . minecraftforge . common . capabilities . ICapabilitySerializable ; 
 import net . minecraftforge . event . AttachCapabilitiesEvent ; 
 import net . minecraftforge . event . entity . player . PlayerInteractEvent ; 
 import net . minecraftforge . fml . common . Mod ; 
 @ @ - 47 , 7 + 48 , 6 @ @ public class TestCapabilityMod 
 @ SubscribeEvent 
 public void onInteract ( PlayerInteractEvent . LeftClickBlock event ) 
 { 
 - if ( event . getItemStack ( ) . func _ 190926 _ b ( ) ) return ; 
 if ( event . getItemStack ( ) . getItem ( ) ! = Items . STICK ) return ; 
 
 / / This is just a example of how to interact with the TE , note the strong type binding that getCapability has 
 @ @ - 58 , 13 + 58 , 27 @ @ public class TestCapabilityMod 
 IExampleCapability inv = te . getCapability ( TEST _ CAP , event . getFace ( ) ) ; 
 System . out . println ( " Hi I ' m a " + inv . getOwnerType ( ) ) ; 
 } 
 - if ( event . getWorld ( ) . getBlockState ( event . getPos ( ) ) . getBlock ( ) = = Blocks . DIRT ) 
 + if ( event . getWorld ( ) . getBlockState ( event . getPos ( ) ) . getBlock ( ) = = Blocks . DIRT & & event . getItemStack ( ) . hasCapability ( TEST _ CAP , null ) ) 
 { 
 - event . getEntityPlayer ( ) . addChatMessage ( new TextComponentString ( TextFormatting . RED + " " + TextFormatting . ITALIC + " TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST " ) ) ; 
 + IExampleCapability cap = event . getItemStack ( ) . getCapability ( TEST _ CAP , null ) ; 
 + event . getEntityPlayer ( ) . addChatMessage ( new TextComponentString ( ( cap . getVal ( ) ? TextFormatting . GREEN : TextFormatting . RED ) + " " + TextFormatting . ITALIC + " TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST " ) ) ; 
 event . setCanceled ( true ) ; 
 } 
 } 
 
 + @ SubscribeEvent 
 + public void onInteractItem ( PlayerInteractEvent . RightClickItem event ) 
 + { 
 + if ( ! event . getEntityPlayer ( ) . isSneaking ( ) ) return ; 
 + if ( event . getItemStack ( ) . getItem ( ) ! = Items . STICK ) return ; 
 + 
 + if ( event . getItemStack ( ) . hasCapability ( TEST _ CAP , null ) ) 
 + { 
 + IExampleCapability cap = event . getItemStack ( ) . getCapability ( TEST _ CAP , null ) ; 
 + cap . toggleVal ( ) ; 
 + System . out . println ( " Test value is now : " + ( cap . getVal ( ) ? " TRUE " : " FALSE " ) ) ; 
 + } 
 + } 
 
 / / Example of having this annotation on a method , this will be called when the capability is present . 
 / / You could do something like register event handlers to attach these capabilities to objects , or 
 @ @ - 75 , 6 + 89 , 54 @ @ public class TestCapabilityMod 
 System . out . println ( " IExampleCapability was registered wheeeeee ! " ) ; 
 } 
 
 + / / Having the Provider implement the cap is not recommended as this creates a hard dep on the cap interface . 
 + / / And does not allow for sidedness . 
 + / / But as this is a example and we do not care about that here we go . 
 + class Provider < V > implements ICapabilitySerializable < NBTTagCompound > , IExampleCapability 
 + { 
 + private V obj ; 
 + private boolean value ; 
 + 
 + Provider ( V obj ) 
 + { 
 + this . obj = obj ; 
 + } 
 + @ Override 
 + public boolean hasCapability ( @ Nonnull Capability < ? > capability , @ Nullable EnumFacing facing ) 
 + { 
 + return TEST _ CAP ! = null & & capability = = TEST _ CAP ; 
 + } 
 + @ Override 
 + @ Nullable 
 + public < T > T getCapability ( @ Nonnull Capability < T > capability , @ Nullable EnumFacing facing ) 
 + { 
 + if ( TEST _ CAP ! = null & & capability = = TEST _ CAP ) return TEST _ CAP . cast ( this ) ; 
 + return null ; 
 + } 
 + @ Override 
 + public NBTTagCompound serializeNBT ( ) { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setBoolean ( " CapTestVal " , this . value ) ; 
 + return tag ; 
 + } 
 + @ Override 
 + public void deserializeNBT ( NBTTagCompound tag ) { 
 + this . value = tag . getBoolean ( " CapTestVal " ) ; 
 + } 
 + @ Override 
 + public String getOwnerType ( ) { 
 + return obj . getClass ( ) . getName ( ) ; 
 + } 
 + @ Override 
 + public boolean getVal ( ) { 
 + return this . value ; 
 + } 
 + @ Override 
 + public void toggleVal ( ) { 
 + this . value = ! this . value ; 
 + } 
 + } 
 + 
 / / An example of how to attach a capability to an arbitrary Tile entity . 
 / / Note : Doing this IS NOT recommended for normal implementations . 
 / / If you control the TE it is HIGHLY recommend that you implement a fast 
 @ @ - 83 , 39 + 145 , 17 @ @ public class TestCapabilityMod 
 @ SubscribeEvent 
 public void onTELoad ( AttachCapabilitiesEvent . TileEntity event ) 
 { 
 - / / Having the Provider implement the cap is not recomended as this creates a hard dep on the cap interface . 
 - / / And doesnt allow for sidedness . 
 - / / But as this is a example and we dont care about that here we go . 
 - class Provider implements ICapabilityProvider , IExampleCapability 
 - { 
 - private TileEntity te ; 
 - 
 - Provider ( TileEntity te ) 
 - { 
 - this . te = te ; 
 - } 
 - @ Override 
 - public boolean hasCapability ( @ Nonnull Capability < ? > capability , @ Nullable EnumFacing facing ) 
 - { 
 - return TEST _ CAP ! = null & & capability = = TEST _ CAP ; 
 - } 
 - @ Override 
 - @ Nullable 
 - public < T > T getCapability ( @ Nonnull Capability < T > capability , @ Nullable EnumFacing facing ) 
 - { 
 - if ( TEST _ CAP ! = null & & capability = = TEST _ CAP ) return TEST _ CAP . cast ( this ) ; 
 - return null ; 
 - } 
 - @ Override 
 - public String getOwnerType ( ) { 
 - return te . getClass ( ) . getName ( ) ; 
 - } 
 - } 
 - 
 - / / Attach it ! The resource location MUST be unique it ' s recomneded that you tag it with your modid and what the cap is . 
 + / / Attach it ! The resource location MUST be unique it ' s recommended that you tag it with your modid and what the cap is . 
 event . addCapability ( new ResourceLocation ( " forge . testcapmod : dummy _ cap " ) , new Provider ( event . getTileEntity ( ) ) ) ; 
 } 
 
 + @ SubscribeEvent 
 + public void onItemLoad ( AttachCapabilitiesEvent . Item event ) 
 + { 
 + if ( event . getItemStack ( ) . getItem ( ) = = Items . STICK ) 
 + event . addCapability ( new ResourceLocation ( " forge . testcapmod : dummy _ cap " ) , new Provider ( event . getItemStack ( ) ) ) ; 
 + } 
 + 
 @ SuppressWarnings ( " rawtypes " ) 
 @ SubscribeEvent 
 public void attachEvent ( AttachCapabilitiesEvent event ) / / Test Raw type gets everything still . 
 @ @ - 127 , 7 + 167 , 7 @ @ public class TestCapabilityMod 
 public void attachTileEntity ( AttachCapabilitiesEvent < TileEntity > event ) 
 { 
 if ( ! ( event . getObject ( ) instanceof TileEntity ) ) 
 - throw new IllegalArgumentException ( " Generic event handler failed ! Exprected Tile Entity got " + event . getObject ( ) ) ; 
 + throw new IllegalArgumentException ( " Generic event handler failed ! Expected Tile Entity got " + event . getObject ( ) ) ; 
 } 
 
 / / Capabilities SHOULD be interfaces , NOT concrete classes , this allows for 
 @ @ - 135 , 6 + 175 , 8 @ @ public class TestCapabilityMod 
 public static interface IExampleCapability 
 { 
 String getOwnerType ( ) ; 
 + boolean getVal ( ) ; 
 + void toggleVal ( ) ; 
 } 
 
 / / Storage implementations are required , tho there is some flexibility here . 
 @ @ - 160 , 5 + 202 , 10 @ @ public class TestCapabilityMod 
 public String getOwnerType ( ) { 
 return " Default Implementation ! " ; 
 } 
 + public boolean getVal ( ) { 
 + return false ; 
 + } 
 + @ Override 
 + public void toggleVal ( ) { } 
 } 
 }

NEAREST DIFF:
diff - - git a / src / test / java / net / minecraftforge / debug / DynBucketTest . java b / src / test / java / net / minecraftforge / debug / DynBucketTest . java 
 index e38452f . . ba06fcc 100644 
 - - - a / src / test / java / net / minecraftforge / debug / DynBucketTest . java 
 + + + b / src / test / java / net / minecraftforge / debug / DynBucketTest . java 
 @ @ - 54 , 9 + 54 , 14 @ @ public class DynBucketTest 
 private static final ResourceLocation simpleTankName = new ResourceLocation ( MODID , " simpletank " ) ; 
 private static final ResourceLocation testItemName = new ResourceLocation ( MODID , " testitem " ) ; 
 
 + private static final boolean ENABLE = false ; 
 + 
 static 
 { 
 - FluidRegistry . enableUniversalBucket ( ) ; 
 + if ( ENABLE ) 
 + { 
 + FluidRegistry . enableUniversalBucket ( ) ; 
 + } 
 } 
 
 @ SidedProxy 
 @ @ - 78 , 6 + 83 , 9 @ @ public class DynBucketTest 
 @ Override 
 void setupModels ( ) 
 { 
 + if ( ! ENABLE ) 
 + return ; 
 + 
 ModelLoader . setBucketModelDefinition ( dynBucket ) ; 
 
 final ModelResourceLocation bottle = new ModelResourceLocation ( new ResourceLocation ( " forge " , " dynbottle " ) , " inventory " ) ; 
 @ @ - 99 , 6 + 107 , 9 @ @ public class DynBucketTest 
 @ EventHandler 
 public void preInit ( FMLPreInitializationEvent event ) 
 { 
 + if ( ! ENABLE ) 
 + return ; 
 + 
 GameRegistry . register ( new TestItem ( ) , testItemName ) ; 
 Block tank = new BlockSimpleTank ( ) ; 
 GameRegistry . register ( tank , simpleTankName ) ; 
 diff - - git a / src / test / java / net / minecraftforge / debug / ModelFluidDebug . java b / src / test / java / net / minecraftforge / debug / ModelFluidDebug . java 
 index 9d92565 . . ccbfb40 100644 
 - - - a / src / test / java / net / minecraftforge / debug / ModelFluidDebug . java 
 + + + b / src / test / java / net / minecraftforge / debug / ModelFluidDebug . java 
 @ @ - 27 , 13 + 27 , 21 @ @ public class ModelFluidDebug 
 public static final String MODID = " ForgeDebugModelFluid " ; 
 public static final String VERSION = " 1 . 0 " ; 
 
 + public static final boolean ENABLE = false ; 
 + 
 @ SidedProxy 
 public static CommonProxy proxy ; 
 
 public static final Fluid milkFluid = new Fluid ( " milk " , new ResourceLocation ( " forge " , " blocks / milk _ still " ) , new ResourceLocation ( " forge " , " blocks / milk _ flow " ) ) ; 
 
 @ EventHandler 
 - public void preInit ( FMLPreInitializationEvent event ) { proxy . preInit ( event ) ; } 
 + public void preInit ( FMLPreInitializationEvent event ) 
 + { 
 + if ( ENABLE ) 
 + { 
 + proxy . preInit ( event ) ; 
 + } 
 + } 
 
 public static class CommonProxy 
 { 
 diff - - git a / src / test / java / net / minecraftforge / test / FluidHandlerTest . java b / src / test / java / net / minecraftforge / test / FluidHandlerTest . java 
 new file mode 100644 
 index 0000000 . . 0ed4331 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / test / FluidHandlerTest . java 
 @ @ - 0 , 0 + 1 , 108 @ @ 
 + package net . minecraftforge . test ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + 
 + import net . minecraft . creativetab . CreativeTabs ; 
 + import net . minecraft . item . Item ; 
 + import net . minecraft . item . ItemStack ; 
 + import net . minecraftforge . fluids . Fluid ; 
 + import net . minecraftforge . fluids . FluidRegistry ; 
 + import net . minecraftforge . fluids . FluidStack ; 
 + import net . minecraftforge . fluids . FluidUtil ; 
 + import net . minecraftforge . fluids . capability . IFluidHandler ; 
 + import net . minecraftforge . fml . common . FMLCommonHandler ; 
 + import net . minecraftforge . fml . common . FMLLog ; 
 + import net . minecraftforge . fml . common . Mod ; 
 + import net . minecraftforge . fml . common . event . FMLLoadCompleteEvent ; 
 + import net . minecraftforge . fml . common . registry . ForgeRegistries ; 
 + import net . minecraftforge . fml . relauncher . Side ; 
 + 
 + @ Mod ( modid = " FluidHandlerTest " , name = " FluidHandlerTest " , version = " 0 . 0 . 0 " ) 
 + public class FluidHandlerTest 
 + { 
 + 	 public static final boolean ENABLE = false ; 
 + 
 + 	 @ Mod . EventHandler 
 + 	 public void loadComplete ( FMLLoadCompleteEvent event ) 
 + 	 { 
 + 	 	 if ( ! ENABLE | | FMLCommonHandler . instance ( ) . getSide ( ) ! = Side . CLIENT ) 
 + 	 	 	 return ; 
 + 
 + 	 	 for ( ItemStack stack : getAllItems ( ) ) 
 + 	 	 { 
 + 	 	 	 testFluidContainer ( stack ) ; 
 + 	 	 } 
 + 	 } 
 + 
 + 	 private static void testFluidContainer ( ItemStack stack ) 
 + 	 { 
 + 	 	 ItemStack drainedStack = stack . copy ( ) ; 
 + 	 	 IFluidHandler fluidHandler = FluidUtil . getFluidHandler ( drainedStack ) ; 
 + 	 	 if ( fluidHandler ! = null ) 
 + 	 	 { 
 + 	 	 	 FluidStack drain = fluidHandler . drain ( Integer . MAX _ VALUE , true ) ; 
 + 	 	 	 FMLLog . info ( " Draining " + stackString ( stack ) + " gives " + fluidString ( drain ) + " and " + stackString ( drainedStack ) ) ; 
 + 
 + 	 	 	 for ( Fluid fluid : FluidRegistry . getRegisteredFluids ( ) . values ( ) ) 
 + 	 	 	 { 
 + 	 	 	 	 ItemStack filledStack = stack . copy ( ) ; 
 + 	 	 	 	 fluidHandler = FluidUtil . getFluidHandler ( filledStack ) ; 
 + 	 	 	 	 if ( fluidHandler ! = null ) 
 + 	 	 	 	 { 
 + 	 	 	 	 	 int filled = fluidHandler . fill ( new FluidStack ( fluid , Integer . MAX _ VALUE ) , true ) ; 
 + 	 	 	 	 	 if ( filled > 0 ) 
 + 	 	 	 	 	 { 
 + 	 	 	 	 	 	 FMLLog . info ( " Filling " + stackString ( stack ) + " with " + fluidString ( new FluidStack ( fluid , filled ) ) + " gives " + stackString ( filledStack ) ) ; 
 + 	 	 	 	 	 } 
 + 	 	 	 	 } 
 + 	 	 	 } 
 + 	 	 } 
 + 	 } 
 + 
 + 	 private static String fluidString ( FluidStack stack ) 
 + 	 { 
 + 	 	 if ( stack = = null ) 
 + 	 	 { 
 + 	 	 	 return " no fluid " ; 
 + 	 	 } 
 + 	 	 else 
 + 	 	 { 
 + 	 	 	 return stack . amount + " mB " + stack . getLocalizedName ( ) ; 
 + 	 	 } 
 + 	 } 
 + 
 + 	 private static String stackString ( ItemStack stack ) 
 + 	 { 
 + 	 	 if ( stack = = null | | stack . stackSize < = 0 ) 
 + 	 	 { 
 + 	 	 	 return " no item " ; 
 + 	 	 } 
 + 	 	 else 
 + 	 	 { 
 + 	 	 	 String resourceDomain ; 
 + 	 	 	 if ( stack . getItem ( ) = = null | | stack . getItem ( ) . getRegistryName ( ) = = null ) 
 + 	 	 	 { 
 + 	 	 	 	 resourceDomain = " unknown " ; 
 + 	 	 	 } 
 + 	 	 	 else 
 + 	 	 	 { 
 + 	 	 	 	 resourceDomain = stack . getItem ( ) . getRegistryName ( ) . getResourceDomain ( ) ; 
 + 	 	 	 } 
 + 	 	 	 return stack . stackSize + " " + stack . getDisplayName ( ) + " ( " + resourceDomain + " ) " ; 
 + 	 	 } 
 + 	 } 
 + 
 + 	 private static List < ItemStack > getAllItems ( ) 
 + 	 { 
 + 	 	 List < ItemStack > list = new ArrayList < ItemStack > ( ) ; 
 + 	 	 for ( Item item : ForgeRegistries . ITEMS . getValues ( ) ) 
 + 	 	 { 
 + 	 	 	 for ( CreativeTabs tab : item . getCreativeTabs ( ) ) 
 + 	 	 	 { 
 + 	 	 	 	 item . getSubItems ( item , tab , list ) ; 
 + 	 	 	 } 
 + 	 	 } 
 + 	 	 return list ; 
 + 	 } 
 + }
