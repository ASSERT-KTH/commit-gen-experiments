BLEU SCORE: 0.014199193612838947

TEST MSG: [ 1 . 12 ] Add support for client & server dependencies for mods
GENERATED MSG: Mod sorting

TEST DIFF (one line): diff - - git a / build . gradle b / build . gradle <nl> index 1a16a7e . . 8f89109 100644 <nl> - - - a / build . gradle <nl> + + + b / build . gradle <nl> @ @ - 66 , 8 + 66 , 10 @ @ version = getVersionFromJava ( file ( " src / main / java / net / minecraftforge / common / Forge <nl> extractForgeSources { exclude " * * / SideOnly . java " , " * * / Side . java " } <nl> extractForgeResources { exclude " * * / log4j2 . xml " } <nl> <nl> - genGradleProjects { <nl> - addTestCompileDep " junit : junit : 4 . 12 " <nl> + genGradleProjects { <nl> + addTestCompileDep " junit : junit : 4 . 12 " / / TODO update unit tests to junit 5 and remove this <nl> + addTestCompileDep " org . junit . jupiter : junit - jupiter - api : 5 . 0 . 0 " <nl> + addTestCompileDep " org . opentest4j : opentest4j : 1 . 0 . 0 " / / needed for junit 5 <nl> addTestCompileDep " org . hamcrest : hamcrest - core : 1 . 3 " <nl> filter { dep - > ! dep . contains ( " scala " ) } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLModContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLModContainer . java <nl> index d63e4b6 . . 3cc51e8 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / FMLModContainer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / FMLModContainer . java <nl> @ @ - 51 , 6 + 51 , 7 @ @ import net . minecraftforge . fml . common . event . FMLFingerprintViolationEvent ; <nl> import net . minecraftforge . fml . common . network . NetworkRegistry ; <nl> import net . minecraftforge . fml . common . versioning . ArtifactVersion ; <nl> import net . minecraftforge . fml . common . versioning . DefaultArtifactVersion ; <nl> + import net . minecraftforge . fml . common . versioning . DependencyParser ; <nl> import net . minecraftforge . fml . common . versioning . VersionParser ; <nl> import net . minecraftforge . fml . common . versioning . VersionRange ; <nl> import net . minecraftforge . fml . relauncher . Side ; <nl> @ @ - 67 , 14 + 68 , 11 @ @ import java . util . function . Function ; <nl> import com . google . common . base . Strings ; <nl> import com . google . common . collect . ArrayListMultimap ; <nl> import com . google . common . collect . ImmutableList ; <nl> - import com . google . common . collect . ImmutableList . Builder ; <nl> import com . google . common . collect . ImmutableMap ; <nl> import com . google . common . collect . ImmutableSet ; <nl> import com . google . common . collect . ListMultimap ; <nl> - import com . google . common . collect . Lists ; <nl> import com . google . common . collect . Maps ; <nl> import com . google . common . collect . SetMultimap ; <nl> - import com . google . common . collect . Sets ; <nl> import com . google . common . eventbus . EventBus ; <nl> import com . google . common . eventbus . Subscribe ; <nl> <nl> @ @ - 140 , 19 + 138 , 18 @ @ public class FMLModContainer implements ModContainer <nl> String modid = ( String ) this . descriptor . get ( " modid " ) ; <nl> if ( Strings . isNullOrEmpty ( modid ) ) <nl> { <nl> - throw new IllegalArgumentException ( " Modid cannot be null or empty " ) ; <nl> + throw new IllegalArgumentException ( " The modId is null or empty " ) ; <nl> } <nl> if ( modid . length ( ) > 64 ) <nl> { <nl> - FMLLog . bigWarning ( " The modid { } is longer than the recommended maximum of 64 characters . Truncation is enforced in 1 . 11 " , modid ) ; <nl> - throw new IllegalArgumentException ( String . format ( " The modid % s is longer than the recommended maximum of 64 characters . Truncation is enforced in 1 . 11 " , modid ) ) ; <nl> + throw new IllegalArgumentException ( String . format ( " The modId % s is longer than the maximum of 64 characters . " , modid ) ) ; <nl> } <nl> if ( ! modid . equals ( modid . toLowerCase ( Locale . ENGLISH ) ) ) <nl> { <nl> - FMLLog . bigWarning ( " The modid { } is not the same as it ' s lowercase version . Lowercasing is enforced in 1 . 11 " , modid ) ; <nl> - throw new IllegalArgumentException ( String . format ( " The modid % s is not the same as it ' s lowercase version . Lowercasing will be enforced in 1 . 11 " , modid ) ) ; <nl> + throw new IllegalArgumentException ( String . format ( " The modId % s must be all lowercase . " , modid ) ) ; <nl> } <nl> } <nl> + <nl> private ILanguageAdapter getLanguageAdapter ( ) <nl> { <nl> if ( languageAdapter = = null ) <nl> @ @ - 212 , 17 + 209 , 15 @ @ public class FMLModContainer implements ModContainer <nl> <nl> if ( overridesMetadata | | ! modMetadata . useDependencyInformation ) <nl> { <nl> - Set < ArtifactVersion > requirements = Sets . newHashSet ( ) ; <nl> - List < ArtifactVersion > dependencies = Lists . newArrayList ( ) ; <nl> - List < ArtifactVersion > dependants = Lists . newArrayList ( ) ; <nl> annotationDependencies = ( String ) descriptor . get ( " dependencies " ) ; <nl> - Loader . instance ( ) . computeDependencies ( annotationDependencies , requirements , dependencies , dependants ) ; <nl> - dependants . addAll ( Loader . instance ( ) . getInjectedBefore ( getModId ( ) ) ) ; <nl> - dependencies . addAll ( Loader . instance ( ) . getInjectedAfter ( getModId ( ) ) ) ; <nl> - modMetadata . requiredMods = requirements ; <nl> - modMetadata . dependencies = dependencies ; <nl> - modMetadata . dependants = dependants ; <nl> - modLog . trace ( " Parsed dependency info : { } { } { } " , requirements , dependencies , dependants ) ; <nl> + DependencyParser dependencyParser = new DependencyParser ( getModId ( ) , FMLCommonHandler . instance ( ) . getSide ( ) ) ; <nl> + DependencyParser . DependencyInfo info = dependencyParser . parseDependencies ( annotationDependencies ) ; <nl> + info . dependants . addAll ( Loader . instance ( ) . getInjectedBefore ( getModId ( ) ) ) ; <nl> + info . dependencies . addAll ( Loader . instance ( ) . getInjectedAfter ( getModId ( ) ) ) ; <nl> + modMetadata . requiredMods = info . requirements ; <nl> + modMetadata . dependencies = info . dependencies ; <nl> + modMetadata . dependants = info . dependants ; <nl> + modLog . trace ( " Parsed dependency info : Requirements : { } After : { } Before : { } " , info . requirements , info . dependencies , info . dependants ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / Loader . java b / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> index 5646f8b . . d38e7c1 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> @ @ - 26 , 7 + 26 , 6 @ @ import java . io . IOException ; <nl> import java . io . InputStream ; <nl> import java . net . MalformedURLException ; <nl> import java . util . ArrayList ; <nl> - import java . util . Collections ; <nl> import java . util . Comparator ; <nl> import java . util . Iterator ; <nl> import java . util . List ; <nl> @ @ - 35 , 6 + 34 , 7 @ @ import java . util . Properties ; <nl> import java . util . Set ; <nl> <nl> import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . common . ForgeVersion ; <nl> import net . minecraftforge . common . capabilities . CapabilityManager ; <nl> import net . minecraftforge . common . config . ConfigManager ; <nl> import net . minecraftforge . common . crafting . CraftingHelper ; <nl> @ @ - 52 , 6 + 52 , 7 @ @ import net . minecraftforge . fml . common . toposort . ModSortingException ; <nl> import net . minecraftforge . fml . common . toposort . TopologicalSort ; <nl> import net . minecraftforge . fml . common . toposort . ModSortingException . SortingExceptionData ; <nl> import net . minecraftforge . fml . common . versioning . ArtifactVersion ; <nl> + import net . minecraftforge . fml . common . versioning . DependencyParser ; <nl> import net . minecraftforge . fml . common . versioning . VersionParser ; <nl> import net . minecraftforge . fml . relauncher . ModListHelper ; <nl> import net . minecraftforge . fml . relauncher . Side ; <nl> @ @ - 62 , 7 + 63 , 6 @ @ import org . apache . commons . io . IOUtils ; <nl> import org . apache . logging . log4j . Level ; <nl> <nl> import com . google . common . base . CharMatcher ; <nl> - import java . util . function . Function ; <nl> import com . google . common . base . Joiner ; <nl> import com . google . common . base . Splitter ; <nl> import com . google . common . collect . ArrayListMultimap ; <nl> @ @ - 124 , 9 + 124 , 7 @ @ import javax . annotation . Nullable ; <nl> @ SuppressWarnings ( " unused " ) <nl> public class Loader <nl> { <nl> - public static final String MC _ VERSION = net . minecraftforge . common . ForgeVersion . mcVersion ; <nl> - private static final Splitter DEPENDENCYPARTSPLITTER = Splitter . on ( " : " ) . omitEmptyStrings ( ) . trimResults ( ) ; <nl> - private static final Splitter DEPENDENCYSPLITTER = Splitter . on ( " ; " ) . omitEmptyStrings ( ) . trimResults ( ) ; <nl> + public static final String MC _ VERSION = ForgeVersion . mcVersion ; <nl> / * * <nl> * The singleton instance <nl> * / <nl> @ @ - 695 , 77 + 693 , 17 @ @ public class Loader <nl> return modClassLoader ; <nl> } <nl> <nl> + / * * <nl> + * @ deprecated use { @ link DependencyParser # parseDependencies ( String ) } <nl> + * / <nl> + @ Deprecated / / TODO : remove in 1 . 13 <nl> public void computeDependencies ( String dependencyString , Set < ArtifactVersion > requirements , List < ArtifactVersion > dependencies , List < ArtifactVersion > dependants ) <nl> { <nl> - if ( dependencyString = = null | | dependencyString . length ( ) = = 0 ) <nl> - { <nl> - return ; <nl> - } <nl> - <nl> - boolean parseFailure = false ; <nl> - <nl> - for ( String dep : DEPENDENCYSPLITTER . split ( dependencyString ) ) <nl> - { <nl> - List < String > depparts = Lists . newArrayList ( DEPENDENCYPARTSPLITTER . split ( dep ) ) ; <nl> - / / Need two parts to the string <nl> - if ( depparts . size ( ) ! = 2 ) <nl> - { <nl> - parseFailure = true ; <nl> - continue ; <nl> - } <nl> - String instruction = depparts . get ( 0 ) ; <nl> - String target = depparts . get ( 1 ) ; <nl> - boolean targetIsAll = target . startsWith ( " * " ) ; <nl> - <nl> - / / Cannot have an " all " relationship with anything except pure * <nl> - if ( targetIsAll & & target . length ( ) > 1 ) <nl> - { <nl> - parseFailure = true ; <nl> - continue ; <nl> - } <nl> - <nl> - / / If this is a required element , add it to the required list <nl> - if ( " required - before " . equals ( instruction ) | | " required - after " . equals ( instruction ) ) <nl> - { <nl> - / / You can ' t require everything <nl> - if ( ! targetIsAll ) <nl> - { <nl> - requirements . add ( VersionParser . parseVersionReference ( target ) ) ; <nl> - } <nl> - else <nl> - { <nl> - parseFailure = true ; <nl> - continue ; <nl> - } <nl> - } <nl> - <nl> - / / You cannot have a versioned dependency on everything <nl> - if ( targetIsAll & & target . indexOf ( ' @ ' ) > - 1 ) <nl> - { <nl> - parseFailure = true ; <nl> - continue ; <nl> - } <nl> - / / before elements are things we are loaded before ( so they are our dependants ) <nl> - if ( " required - before " . equals ( instruction ) | | " before " . equals ( instruction ) ) <nl> - { <nl> - dependants . add ( VersionParser . parseVersionReference ( target ) ) ; <nl> - } <nl> - / / after elements are things that load before we do ( so they are out dependencies ) <nl> - else if ( " required - after " . equals ( instruction ) | | " after " . equals ( instruction ) ) <nl> - { <nl> - dependencies . add ( VersionParser . parseVersionReference ( target ) ) ; <nl> - } <nl> - else <nl> - { <nl> - parseFailure = true ; <nl> - } <nl> - } <nl> - <nl> - if ( parseFailure ) <nl> - { <nl> - FMLLog . log . warn ( " Unable to parse dependency string { } " , dependencyString ) ; <nl> - throw new LoaderException ( String . format ( " Unable to parse dependency string % s " , dependencyString ) ) ; <nl> - } <nl> + DependencyParser dependencyParser = new DependencyParser ( " unknown " , FMLCommonHandler . instance ( ) . getSide ( ) ) ; <nl> + DependencyParser . DependencyInfo info = dependencyParser . parseDependencies ( dependencyString ) ; <nl> + requirements . addAll ( info . requirements ) ; <nl> + dependencies . addAll ( info . dependencies ) ; <nl> + dependants . addAll ( info . dependants ) ; <nl> } <nl> <nl> public Map < String , ModContainer > getIndexedModList ( ) <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / Mod . java b / src / main / java / net / minecraftforge / fml / common / Mod . java <nl> index 7ff9bd6 . . 97608a5 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / Mod . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / Mod . java <nl> @ @ - 101 , 24 + 101 , 37 @ @ public @ interface Mod <nl> / * * <nl> * A dependency string for this mod , which specifies which mod ( s ) it depends on in order to run . <nl> * <nl> - * A dependency string can start with the following four prefixes : <nl> - * before , after , required - before , required - after <nl> + * A dependency string must start with a combination of these prefixes , separated by " - " : <nl> + * [ before , after ] , [ required ] , [ client , server ] <nl> + * At least one " before " , " after " , or " required " must be specified . <nl> * Then " : " and the mod id . <nl> - * <nl> - * Optionally , a version range can be specified for the mod by adding " @ " and then the version range . <nl> - * The version range format is described in the javadoc here : { @ link VersionRange # createFromVersionSpec ( java . lang . String ) } <nl> + * Then a version range should be specified for the mod by adding " @ " and the version range . <nl> + * The version range format is described in the javadoc here : <nl> + * { @ link VersionRange # createFromVersionSpec ( java . lang . String ) } <nl> + * Then a " ; " . <nl> * <nl> * If a " required " mod is missing , or a mod exists with a version outside the specified range , <nl> * the game will not start and an error screen will tell the player which versions are required . <nl> * <nl> * Example : <nl> - * Our example mod is a dedicated addon to mod1 and has optional integration with mod2 . <nl> - * It uses new features that were introduced in forge version 14 . 21 . 1 . 2395 and mod2 version 4 . 7 . 0 <nl> + * Our example mod : <nl> + * * depends on Forge and uses new features that were introduced in Forge version 14 . 21 . 1 . 2395 <nl> + * " required : forge @ [ 14 . 21 . 1 . 2395 , ) ; " <nl> + * * is a dedicated addon to mod1 and has to have its event handlers run after mod1 ' s are run , <nl> + * " required - after : mod1 ; " <nl> + * * has optional integration with mod2 which depends on features introduced in mod2 version 4 . 7 . 0 , <nl> + * " after : mod2 @ [ 4 . 7 . 0 , ) ; " <nl> + * * depends on a client - side - only rendering library called rendermod <nl> + * " required - client : rendermod ; " <nl> * <nl> - * the dependencies string = " after : forge @ [ 14 . 21 . 1 . 2395 , ) ; required - after : mod1 ; after : mod2 @ [ 4 . 7 . 0 , ) ; " <nl> + * The full dependencies string is all of those combined : <nl> + * " required : forge @ [ 14 . 21 . 1 . 2395 , ) ; required - after : mod1 ; after : mod2 @ [ 4 . 7 . 0 , ) ; required - client : rendermod ; " <nl> * <nl> * This will stop the game and display an error message if any of these is true : <nl> - * The installed forge is too old , mod1 is missing , or an old version of mod2 is present . <nl> + * The installed forge is too old , <nl> + * mod1 is missing , <nl> + * an old version of mod2 is present , <nl> + * rendermod is missing on the client . <nl> * / <nl> String dependencies ( ) default " " ; <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / versioning / DependencyParser . java b / src / main / java / net / minecraftforge / fml / common / versioning / DependencyParser . java <nl> new file mode 100644 <nl> index 0000000 . . ac34202 <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / common / versioning / DependencyParser . java <nl> @ @ - 0 , 0 + 1 , 221 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . fml . common . versioning ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . HashSet ; <nl> + import java . util . List ; <nl> + import java . util . Locale ; <nl> + import java . util . Set ; <nl> + <nl> + import com . google . common . base . Splitter ; <nl> + import com . google . common . base . Strings ; <nl> + import com . google . common . collect . ImmutableList ; <nl> + import net . minecraftforge . fml . common . LoaderException ; <nl> + import net . minecraftforge . fml . relauncher . Side ; <nl> + import org . apache . logging . log4j . LogManager ; <nl> + import org . apache . logging . log4j . Logger ; <nl> + <nl> + public final class DependencyParser <nl> + { <nl> + public static class DependencyInfo <nl> + { <nl> + public final Set < ArtifactVersion > requirements = new HashSet < > ( ) ; <nl> + public final List < ArtifactVersion > dependencies = new ArrayList < > ( ) ; <nl> + public final List < ArtifactVersion > dependants = new ArrayList < > ( ) ; <nl> + } <nl> + <nl> + private static final Logger LOGGER = LogManager . getLogger ( " FML " ) ; <nl> + private static final ImmutableList < String > DEPENDENCY _ INSTRUCTIONS = ImmutableList . of ( " client " , " server " , " required " , " before " , " after " ) ; <nl> + private static final Splitter DEPENDENCY _ INSTRUCTIONS _ SPLITTER = Splitter . on ( " - " ) . omitEmptyStrings ( ) . trimResults ( ) ; <nl> + private static final Splitter DEPENDENCY _ PART _ SPLITTER = Splitter . on ( " : " ) . omitEmptyStrings ( ) . trimResults ( ) ; <nl> + private static final Splitter DEPENDENCY _ SPLITTER = Splitter . on ( " ; " ) . omitEmptyStrings ( ) . trimResults ( ) ; <nl> + <nl> + private final String modId ; <nl> + private final Side side ; <nl> + <nl> + public DependencyParser ( String modId , Side side ) <nl> + { <nl> + this . modId = modId ; <nl> + this . side = side ; <nl> + } <nl> + <nl> + public DependencyInfo parseDependencies ( String dependencyString ) <nl> + { <nl> + DependencyInfo info = new DependencyInfo ( ) ; <nl> + if ( dependencyString = = null | | dependencyString . length ( ) = = 0 ) <nl> + { <nl> + return info ; <nl> + } <nl> + <nl> + for ( String dep : DEPENDENCY _ SPLITTER . split ( dependencyString ) ) <nl> + { <nl> + final List < String > depParts = DEPENDENCY _ PART _ SPLITTER . splitToList ( dep ) ; <nl> + if ( depParts . size ( ) ! = 2 ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " Dependency string needs 2 parts . " ) ; <nl> + } <nl> + <nl> + final List < String > instructions = DEPENDENCY _ INSTRUCTIONS _ SPLITTER . splitToList ( depParts . get ( 0 ) ) ; <nl> + final String target = depParts . get ( 1 ) ; <nl> + parseDependency ( dep , instructions , target , info ) ; <nl> + } <nl> + return info ; <nl> + } <nl> + <nl> + private void parseDependency ( String dep , List < String > instructions , String target , DependencyInfo info ) <nl> + { <nl> + final boolean targetIsAll = target . startsWith ( " * " ) ; <nl> + final boolean targetIsBounded = target . contains ( " @ " ) ; <nl> + if ( targetIsAll ) <nl> + { <nl> + if ( target . length ( ) > 1 ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " Cannot have an \ " all \ " ( * ) relationship with anything except pure * " ) ; <nl> + } <nl> + else if ( targetIsBounded ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " You cannot have a versioned dependency on everything ( * ) " ) ; <nl> + } <nl> + } <nl> + <nl> + Side depSide = null ; <nl> + String depOrder = null ; <nl> + boolean depRequired = false ; <nl> + <nl> + for ( String instruction : instructions ) <nl> + { <nl> + if ( " client " . equals ( instruction ) ) <nl> + { <nl> + if ( depSide ! = null ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " Up to one side ( client or server ) can be specified . " ) ; <nl> + } <nl> + depSide = Side . CLIENT ; <nl> + } <nl> + else if ( " server " . equals ( instruction ) ) <nl> + { <nl> + if ( depSide ! = null ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " Up to one side ( client or server ) can be specified . " ) ; <nl> + } <nl> + depSide = Side . SERVER ; <nl> + } <nl> + else if ( " required " . equals ( instruction ) ) <nl> + { <nl> + if ( depRequired ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " ' required ' can only be specified once . " ) ; <nl> + } <nl> + if ( targetIsAll ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " You can ' t ' require ' everything ( * ) " ) ; <nl> + } <nl> + depRequired = true ; <nl> + } <nl> + else if ( " before " . equals ( instruction ) | | " after " . equals ( instruction ) ) <nl> + { <nl> + if ( depOrder ! = null ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " ' before ' or ' after ' can only be specified once . " ) ; <nl> + } <nl> + depOrder = instruction ; <nl> + } <nl> + else <nl> + { <nl> + throw new DependencyParserException ( modId , dep , String . format ( " Found invalid instruction ' % s ' . Only % s are allowed . " , instruction , DEPENDENCY _ INSTRUCTIONS ) ) ; <nl> + } <nl> + } <nl> + <nl> + ArtifactVersion artifactVersion ; <nl> + try <nl> + { <nl> + artifactVersion = VersionParser . parseVersionReference ( target ) ; <nl> + } <nl> + catch ( RuntimeException e ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " Could not parse version string . " , e ) ; <nl> + } <nl> + <nl> + if ( ! targetIsAll ) <nl> + { <nl> + String depModId = artifactVersion . getLabel ( ) ; <nl> + sanityCheckModId ( modId , dep , depModId ) ; <nl> + } <nl> + <nl> + if ( ! depRequired & & depOrder = = null ) <nl> + { <nl> + throw new DependencyParserException ( modId , dep , " ' required ' , ' client ' , or ' server ' must be specified . " ) ; <nl> + } <nl> + <nl> + if ( depSide = = null | | depSide = = this . side ) <nl> + { <nl> + if ( depRequired ) <nl> + { <nl> + info . requirements . add ( artifactVersion ) ; <nl> + } <nl> + <nl> + if ( " before " . equals ( depOrder ) ) <nl> + { <nl> + info . dependants . add ( artifactVersion ) ; <nl> + } <nl> + else if ( " after " . equals ( depOrder ) ) <nl> + { <nl> + info . dependencies . add ( artifactVersion ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / / TODO 1 . 13 : throw these exceptions instead of logging them <nl> + / * * Based on { @ link net . minecraftforge . fml . common . FMLModContainer # sanityCheckModId ( ) } * / <nl> + private static void sanityCheckModId ( String modId , String dep , String depModId ) <nl> + { <nl> + if ( Strings . isNullOrEmpty ( depModId ) ) <nl> + { <nl> + LOGGER . error ( new DependencyParserException ( modId , dep , " The modId is null or empty " ) . getMessage ( ) ) ; <nl> + } <nl> + else if ( depModId . length ( ) > 64 ) <nl> + { <nl> + LOGGER . error ( new DependencyParserException ( modId , dep , String . format ( " The modId ' % s ' is longer than the maximum of 64 characters . " , depModId ) ) . getMessage ( ) ) ; <nl> + } <nl> + else if ( ! depModId . equals ( depModId . toLowerCase ( Locale . ENGLISH ) ) ) <nl> + { <nl> + LOGGER . error ( new DependencyParserException ( modId , dep , String . format ( " The modId ' % s ' must be all lowercase . " , depModId ) ) . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + private static class DependencyParserException extends LoaderException <nl> + { <nl> + public DependencyParserException ( String modId , String dependencyString , String explanation ) <nl> + { <nl> + super ( formatMessage ( modId , dependencyString , explanation ) ) ; <nl> + } <nl> + <nl> + public DependencyParserException ( String modId , String dependencyString , String explanation , Throwable cause ) <nl> + { <nl> + super ( formatMessage ( modId , dependencyString , explanation ) , cause ) ; <nl> + } <nl> + <nl> + public static String formatMessage ( String modId , String dependencyString , String explanation ) <nl> + { <nl> + return String . format ( " Unable to parse dependency for mod ' % s ' with dependency string ' % s ' . % s " , modId , dependencyString , explanation ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / versioning / VersionParser . java b / src / main / java / net / minecraftforge / fml / common / versioning / VersionParser . java <nl> index 95a85bb . . 3a6d109 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / versioning / VersionParser . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / versioning / VersionParser . java <nl> @ @ - 21 , 11 + 21 , 8 @ @ package net . minecraftforge . fml . common . versioning ; <nl> <nl> import java . util . List ; <nl> <nl> - import net . minecraftforge . fml . common . FMLLog ; <nl> import net . minecraftforge . fml . common . LoaderException ; <nl> <nl> - import org . apache . logging . log4j . Level ; <nl> - <nl> import com . google . common . base . Splitter ; <nl> import com . google . common . base . Strings ; <nl> import com . google . common . collect . Lists ; <nl> @ @ - 76 , 8 + 73 , 7 @ @ public class VersionParser <nl> } <nl> catch ( InvalidVersionSpecificationException e ) <nl> { <nl> - FMLLog . log . error ( " Unable to parse a version range specification successfully { } " , range , e ) ; <nl> - throw new LoaderException ( e ) ; <nl> + throw new LoaderException ( " Unable to parse a version range specification successfully " + range , e ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / test / java / net / minecraftforge / fml / test / DependencyParserTest . java b / src / test / java / net / minecraftforge / fml / test / DependencyParserTest . java <nl> new file mode 100644 <nl> index 0000000 . . 2beb94c <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / fml / test / DependencyParserTest . java <nl> @ @ - 0 , 0 + 1 , 304 @ @ <nl> + package net . minecraftforge . fml . test ; <nl> + <nl> + import static org . junit . jupiter . api . Assertions . * ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . Collection ; <nl> + import java . util . List ; <nl> + <nl> + import com . google . common . collect . ImmutableList ; <nl> + import net . minecraftforge . fml . common . versioning . DependencyParser ; <nl> + import net . minecraftforge . fml . relauncher . Side ; <nl> + <nl> + import com . google . common . base . Functions ; <nl> + import com . google . common . collect . Collections2 ; <nl> + import com . google . common . collect . Sets ; <nl> + <nl> + import net . minecraftforge . fml . common . LoaderException ; <nl> + import org . junit . jupiter . api . BeforeAll ; <nl> + import org . junit . jupiter . api . Test ; <nl> + <nl> + public class DependencyParserTest <nl> + { <nl> + private static DependencyParser clientDependencyParser ; <nl> + private static DependencyParser serverDependencyParser ; <nl> + private static List < DependencyParser > parsers ; <nl> + <nl> + @ BeforeAll <nl> + public static void beforeAll ( ) <nl> + { <nl> + clientDependencyParser = new DependencyParser ( " test " , Side . CLIENT ) ; <nl> + serverDependencyParser = new DependencyParser ( " test " , Side . SERVER ) ; <nl> + parsers = ImmutableList . of ( clientDependencyParser , serverDependencyParser ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingNothing ( ) <nl> + { <nl> + List < String > strings = new ArrayList < > ( ) ; <nl> + strings . add ( null ) ; <nl> + strings . add ( " " ) ; <nl> + strings . add ( " ; ; ; ; ; ; ; " ) ; <nl> + strings . add ( " ; ; ; ; ; ; ; " ) ; <nl> + for ( String string : strings ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + DependencyParser . DependencyInfo info = parser . parseDependencies ( string ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependants . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependencies . isEmpty ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingRequired ( ) <nl> + { <nl> + String mod = " supermod3000 @ [ 1 . 2 , ) " ; <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + DependencyParser . DependencyInfo info = parser . parseDependencies ( " required : " + mod ) ; <nl> + assertContainsSameToString ( info . requirements , Sets . newHashSet ( mod ) ) ; <nl> + assertTrue ( info . dependants . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependencies . isEmpty ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingBefore ( ) <nl> + { <nl> + String mod = " supermod3000 @ [ 1 . 2 , ) " ; <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + DependencyParser . DependencyInfo info = parser . parseDependencies ( " before : " + mod ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertContainsSameToString ( info . dependants , Sets . newHashSet ( mod ) ) ; <nl> + assertTrue ( info . dependencies . isEmpty ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingAfter ( ) <nl> + { <nl> + String mod = " supermod3000 @ [ 1 . 2 , ) " ; <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + DependencyParser . DependencyInfo info = parser . parseDependencies ( " after : " + mod ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependants . isEmpty ( ) ) ; <nl> + assertContainsSameToString ( info . dependencies , Sets . newHashSet ( mod ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingNoPrefix ( ) <nl> + { <nl> + String mod = " supermod3000 @ [ 1 . 2 , ) " ; <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( mod ) ; <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingCombined ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + String dependencyString = " after : supermod2000 @ [ 1 . 3 , ) ; required - before : yetanothermod ; required : modw " ; <nl> + DependencyParser . DependencyInfo info = parser . parseDependencies ( dependencyString ) ; <nl> + assertContainsSameToString ( info . requirements , Sets . newHashSet ( " yetanothermod " , " modw " ) ) ; <nl> + assertContainsSameToString ( info . dependencies , Sets . newHashSet ( " supermod2000 @ [ 1 . 3 , ) " ) ) ; <nl> + assertContainsSameToString ( info . dependants , Sets . newHashSet ( " yetanothermod " ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingSided ( ) <nl> + { <nl> + String mod = " testmod @ [ 1 . 0 , 2 . 0 ) " ; <nl> + { <nl> + DependencyParser . DependencyInfo info = clientDependencyParser . parseDependencies ( " client - after : " + mod ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependants . isEmpty ( ) ) ; <nl> + assertContainsSameToString ( info . dependencies , Sets . newHashSet ( mod ) ) ; <nl> + } <nl> + <nl> + { <nl> + DependencyParser . DependencyInfo info = clientDependencyParser . parseDependencies ( " server - after : testmod @ [ 1 . 0 , 2 . 0 ) ; server - required : testmod2 ; server - after : testmod3 ; server - before : testmod4 " ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependants . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependencies . isEmpty ( ) ) ; <nl> + } <nl> + <nl> + { <nl> + DependencyParser . DependencyInfo info = clientDependencyParser . parseDependencies ( " client - before : testmod @ [ 1 . 0 , 2 . 0 ) ; server - required : testmod2 ; server - after : testmod3 ; server - before : testmod4 " ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertContainsSameToString ( info . dependants , Sets . newHashSet ( mod ) ) ; <nl> + assertTrue ( info . dependencies . isEmpty ( ) ) ; <nl> + } <nl> + <nl> + { <nl> + DependencyParser . DependencyInfo info = serverDependencyParser . parseDependencies ( " server - before : " + mod ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertContainsSameToString ( info . dependants , Sets . newHashSet ( mod ) ) ; <nl> + assertTrue ( info . dependencies . isEmpty ( ) ) ; <nl> + } <nl> + <nl> + { <nl> + DependencyParser . DependencyInfo info = serverDependencyParser . parseDependencies ( " client - before : testmod @ [ 1 . 0 , 2 . 0 ) ; client - required : testmod2 ; client - after : testmod3 ; client - before : testmod4 " ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependants . isEmpty ( ) ) ; <nl> + assertTrue ( info . dependencies . isEmpty ( ) ) ; <nl> + } <nl> + <nl> + { <nl> + DependencyParser . DependencyInfo info = serverDependencyParser . parseDependencies ( " server - before : testmod @ [ 1 . 0 , 2 . 0 ) ; client - required : testmod2 ; client - after : testmod3 ; client - before : testmod4 " ) ; <nl> + assertTrue ( info . requirements . isEmpty ( ) ) ; <nl> + assertContainsSameToString ( info . dependants , Sets . newHashSet ( mod ) ) ; <nl> + assertTrue ( info . dependencies . isEmpty ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingInvalidDependencyInstructions ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " gibberishtext : amod " ) ; <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingInvalidDependencyVersionClient ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " amod @ [ 10 " ) ; <nl> + } ) ; <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " client : amod @ [ 10 " ) ; <nl> + } ) ; <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " server : amod @ [ 10 " ) ; <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> + / / TODO : enable this in 1 . 13 <nl> + / / @ Test ( expected = LoaderException . class ) <nl> + / / public void testParsingUppercaseModId ( ) <nl> + / / { <nl> + / / for ( DependencyParser parser : parsers ) <nl> + / / { <nl> + / / assertThrows ( LoaderException . class , ( ) - > { <nl> + / / parser . parseDependencies ( " Forge @ [ 1 . 0 ] " ) ; <nl> + / / } ) ; <nl> + / / assertThrows ( LoaderException . class , ( ) - > { <nl> + / / parser . parseDependencies ( " client : Forge @ [ 1 . 0 ] " ) ; <nl> + / / } ) ; <nl> + / / assertThrows ( LoaderException . class , ( ) - > { <nl> + / / parser . parseDependencies ( " server : Forge @ [ 1 . 0 ] " ) ; <nl> + / / } ) ; <nl> + / / } <nl> + / / } <nl> + <nl> + @ Test <nl> + public void testParsingSoftDepWithNoVersion ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " amod " ) ; <nl> + } ) ; <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " client : amod " ) ; <nl> + } ) ; <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " server : amod " ) ; <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingDepAfterAll ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + parser . parseDependencies ( " after : * " ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingDepBeforeAll ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + parser . parseDependencies ( " before : * " ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingDepOnAll ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " * " ) ; <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingSidedDepOnAll ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " client : * " ) ; <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingRequireAll ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " required : * " ) ; <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testParsingVersionedAll ( ) <nl> + { <nl> + for ( DependencyParser parser : parsers ) <nl> + { <nl> + assertThrows ( LoaderException . class , ( ) - > { <nl> + parser . parseDependencies ( " * @ [ 1 . 0 ] " ) ; <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> + public static void assertContainsSameToString ( Collection < ? > c1 , Collection < String > expected ) <nl> + { <nl> + Collection < String > transformedToString = Collections2 . transform ( c1 , Functions . toStringFunction ( ) ) ; <nl> + assertContainsSame ( transformedToString , expected ) ; <nl> + } <nl> + <nl> + public static < T > void assertContainsSame ( Collection < T > c1 , Collection < T > c2 ) <nl> + { <nl> + if ( ! c1 . containsAll ( c2 ) | | ! c2 . containsAll ( c1 ) ) <nl> + { <nl> + fail ( c1 + " does not contain the same as " + c2 ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / fml / . settings / org . eclipse . ltk . core . refactoring . prefs b / fml / . settings / org . eclipse . ltk . core . refactoring . prefs <nl> new file mode 100644 <nl> index 0000000 . . b196c64 <nl> - - - / dev / null <nl> + + + b / fml / . settings / org . eclipse . ltk . core . refactoring . prefs <nl> @ @ - 0 , 0 + 1 , 2 @ @ <nl> + eclipse . preferences . version = 1 <nl> + org . eclipse . ltk . core . refactoring . enable . project . refactoring . history = false <nl> diff - - git a / fml / . settings / org . eclipse . m2e . core . prefs b / fml / . settings / org . eclipse . m2e . core . prefs <nl> new file mode 100644 <nl> index 0000000 . . f897a7f <nl> - - - / dev / null <nl> + + + b / fml / . settings / org . eclipse . m2e . core . prefs <nl> @ @ - 0 , 0 + 1 , 4 @ @ <nl> + activeProfiles = <nl> + eclipse . preferences . version = 1 <nl> + resolveWorkspaceProjects = true <nl> + version = 1 <nl> diff - - git a / fml / common / cpw / mods / fml / common / FMLModContainer . java b / fml / common / cpw / mods / fml / common / FMLModContainer . java <nl> index 77184e7 . . c33b911 100644 <nl> - - - a / fml / common / cpw / mods / fml / common / FMLModContainer . java <nl> + + + b / fml / common / cpw / mods / fml / common / FMLModContainer . java <nl> @ @ - 18 , 8 + 18 , 16 @ @ import java . util . List ; <nl> public class FMLModContainer implements ModContainer { <nl> private Mod modDescriptor ; <nl> private Object modInstance ; <nl> + private String source ; <nl> <nl> + public FMLModContainer ( String source ) { <nl> + this . source = source ; <nl> + } <nl> + <nl> public FMLModContainer ( Class < ? > clazz ) { <nl> + if ( clazz = = null ) { <nl> + return ; <nl> + } <nl> modDescriptor = clazz . getAnnotation ( Mod . class ) ; <nl> <nl> try { <nl> @ @ - 86 , 8 + 94 , 7 @ @ public class FMLModContainer implements ModContainer { <nl> <nl> @ Override <nl> public String getSource ( ) { <nl> - / / TODO Auto - generated method stub <nl> - return null ; <nl> + return source ; <nl> } <nl> <nl> @ Override <nl> @ @ - 189 , 4 + 196 , 11 @ @ public class FMLModContainer implements ModContainer { <nl> return new ArrayList < String > ( 0 ) ; <nl> } <nl> <nl> + / * ( non - Javadoc ) <nl> + * @ see java . lang . Object # toString ( ) <nl> + * / <nl> + @ Override <nl> + public String toString ( ) { <nl> + return getSource ( ) ; <nl> + } <nl> } <nl> diff - - git a / fml / common / cpw / mods / fml / common / Loader . java b / fml / common / cpw / mods / fml / common / Loader . java <nl> index 8ca6b7c . . 9cbad60 100644 <nl> - - - a / fml / common / cpw / mods / fml / common / Loader . java <nl> + + + b / fml / common / cpw / mods / fml / common / Loader . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import java . util . regex . Pattern ; <nl> import java . util . zip . ZipEntry ; <nl> import java . util . zip . ZipFile ; <nl> <nl> + import cpw . mods . fml . common . toposort . ModSorter ; <nl> import cpw . mods . fml . server . FMLHandler ; <nl> <nl> public class Loader { <nl> @ @ - 78 , 6 + 79 , 7 @ @ public class Loader { <nl> } <nl> <nl> private void sortModList ( ) { <nl> + log . fine ( " Verifying mod dependencies are satisfied " ) ; <nl> for ( ModContainer mod : mods ) { <nl> if ( ! namedMods . keySet ( ) . containsAll ( mod . getDependencies ( ) ) ) { <nl> log . severe ( String . format ( " The mod % s requires mods % s to be available , one or more are not " , mod . getName ( ) , mod . getDependencies ( ) ) ) ; <nl> @ @ - 86 , 6 + 88 , 17 @ @ public class Loader { <nl> throw new LoaderException ( ) ; <nl> } <nl> } <nl> + log . fine ( " All dependencies are satisfied " ) ; <nl> + ModSorter sorter = new ModSorter ( mods , namedMods ) ; <nl> + try { <nl> + log . fine ( " Sorting mods into an ordered list " ) ; <nl> + mods = sorter . sort ( ) ; <nl> + log . fine ( String . format ( " Mod list sorted % s " , mods ) ) ; <nl> + } catch ( IllegalArgumentException iae ) { <nl> + log . severe ( " A dependency cycle was detected in the input mod set so they cannot load them in order " ) ; <nl> + log . throwing ( " Loader " , " sortModList " , iae ) ; <nl> + throw new LoaderException ( iae ) ; <nl> + } <nl> } <nl> <nl> private void preModInit ( ) { <nl> diff - - git a / fml / common / cpw / mods / fml / common / toposort / ModSorter . java b / fml / common / cpw / mods / fml / common / toposort / ModSorter . java <nl> new file mode 100644 <nl> index 0000000 . . 5115fb4 <nl> - - - / dev / null <nl> + + + b / fml / common / cpw / mods / fml / common / toposort / ModSorter . java <nl> @ @ - 0 , 0 + 1 , 93 @ @ <nl> + / * <nl> + * The FML Forge Mod Loader suite . Copyright ( C ) 2012 cpw <nl> + * <nl> + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> + * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package cpw . mods . fml . common . toposort ; <nl> + <nl> + import java . util . Arrays ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + <nl> + import cpw . mods . fml . common . FMLModContainer ; <nl> + import cpw . mods . fml . common . ModContainer ; <nl> + import cpw . mods . fml . common . toposort . TopologicalSort . DirectedGraph ; <nl> + <nl> + / * * <nl> + * @ author cpw <nl> + * <nl> + * / <nl> + public class ModSorter { <nl> + private DirectedGraph < ModContainer > modGraph ; <nl> + <nl> + private ModContainer beforeAll = new FMLModContainer ( " DummyBeforeAll " ) ; <nl> + private ModContainer afterAll = new FMLModContainer ( " DummyAfterAll " ) ; <nl> + private ModContainer before = new FMLModContainer ( " DummyBefore " ) ; <nl> + private ModContainer after = new FMLModContainer ( " DummyAfter " ) ; <nl> + <nl> + public ModSorter ( List < ModContainer > modList , Map < String , ModContainer > nameLookup ) { <nl> + buildGraph ( modList , nameLookup ) ; <nl> + } <nl> + <nl> + private void buildGraph ( List < ModContainer > modList , Map < String , ModContainer > nameLookup ) { <nl> + modGraph = new DirectedGraph < ModContainer > ( ) ; <nl> + modGraph . addNode ( beforeAll ) ; <nl> + modGraph . addNode ( before ) ; <nl> + modGraph . addNode ( afterAll ) ; <nl> + modGraph . addNode ( after ) ; <nl> + <nl> + modGraph . addEdge ( before , after ) ; <nl> + modGraph . addEdge ( beforeAll , before ) ; <nl> + modGraph . addEdge ( after , afterAll ) ; <nl> + for ( ModContainer mod : modList ) { <nl> + modGraph . addNode ( mod ) ; <nl> + } <nl> + for ( ModContainer mod : modList ) { <nl> + boolean preDepAdded = false ; <nl> + boolean postDepAdded = false ; <nl> + for ( String dep : mod . getPreDepends ( ) ) { <nl> + preDepAdded = true ; <nl> + if ( dep . equals ( " * " ) ) { <nl> + / / We are " after " everything <nl> + modGraph . addEdge ( mod , afterAll ) ; <nl> + modGraph . addEdge ( after , mod ) ; <nl> + postDepAdded = true ; <nl> + } else { <nl> + modGraph . addEdge ( before , mod ) ; <nl> + modGraph . addEdge ( nameLookup . get ( dep ) , mod ) ; <nl> + } <nl> + } <nl> + for ( String dep : mod . getPostDepends ( ) ) { <nl> + postDepAdded = true ; <nl> + if ( dep . equals ( " * " ) ) { <nl> + / / We are " before " everything <nl> + modGraph . addEdge ( beforeAll , mod ) ; <nl> + modGraph . addEdge ( mod , before ) ; <nl> + preDepAdded = true ; <nl> + } else { <nl> + modGraph . addEdge ( mod , after ) ; <nl> + modGraph . addEdge ( mod , nameLookup . get ( dep ) ) ; <nl> + } <nl> + } <nl> + if ( ! preDepAdded ) { <nl> + modGraph . addEdge ( before , mod ) ; <nl> + } <nl> + if ( ! postDepAdded ) { <nl> + modGraph . addEdge ( mod , after ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public List < ModContainer > sort ( ) { <nl> + List < ModContainer > sortedList = TopologicalSort . topologicalSort ( modGraph ) ; <nl> + sortedList . removeAll ( Arrays . asList ( new ModContainer [ ] { beforeAll , before , after , afterAll } ) ) ; <nl> + return sortedList ; <nl> + } <nl> + } <nl> diff - - git a / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java b / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java <nl> new file mode 100644 <nl> index 0000000 . . 37b5bf2 <nl> - - - / dev / null <nl> + + + b / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java <nl> @ @ - 0 , 0 + 1 , 155 @ @ <nl> + / * <nl> + * The FML Forge Mod Loader suite . <nl> + * Copyright ( C ) 2012 cpw <nl> + * <nl> + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> + * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package cpw . mods . fml . common . toposort ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . HashSet ; <nl> + import java . util . Iterator ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . NoSuchElementException ; <nl> + import java . util . Set ; <nl> + <nl> + / * * <nl> + * Topological sort for mod loading <nl> + * <nl> + * Based on a variety of sources , including http : / / keithschwarz . com / interesting / code / ? dir = topological - sort <nl> + * @ author cpw <nl> + * <nl> + * / <nl> + public class TopologicalSort { <nl> + public static class DirectedGraph < T > implements Iterable < T > { <nl> + private final Map < T , Set < T > > graph = new HashMap < T , Set < T > > ( ) ; <nl> + <nl> + public boolean addNode ( T node ) { <nl> + / / Ignore nodes already added <nl> + if ( graph . containsKey ( node ) ) { <nl> + return false ; <nl> + } <nl> + graph . put ( node , new HashSet < T > ( ) ) ; <nl> + return true ; <nl> + } <nl> + <nl> + public void addEdge ( T from , T to ) { <nl> + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { <nl> + throw new NoSuchElementException ( " Missing nodes from graph " ) ; <nl> + } <nl> + graph . get ( from ) . add ( to ) ; <nl> + } <nl> + <nl> + public void removeEdge ( T from , T to ) { <nl> + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { <nl> + throw new NoSuchElementException ( " Missing nodes from graph " ) ; <nl> + } <nl> + graph . get ( from ) . remove ( to ) ; <nl> + } <nl> + <nl> + public boolean edgeExists ( T from , T to ) { <nl> + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { <nl> + throw new NoSuchElementException ( " Missing nodes from graph " ) ; <nl> + } <nl> + return graph . get ( from ) . contains ( to ) ; <nl> + } <nl> + <nl> + public Set < T > edgesFrom ( T from ) { <nl> + if ( ! graph . containsKey ( from ) ) { <nl> + throw new NoSuchElementException ( " Missing node from graph " ) ; <nl> + } <nl> + return Collections . unmodifiableSet ( graph . get ( from ) ) ; <nl> + } <nl> + @ Override <nl> + public Iterator < T > iterator ( ) { <nl> + return graph . keySet ( ) . iterator ( ) ; <nl> + } <nl> + <nl> + public int size ( ) { <nl> + return graph . size ( ) ; <nl> + } <nl> + <nl> + public boolean isEmpty ( ) { <nl> + return graph . isEmpty ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) { <nl> + return graph . toString ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Sort the input graph into a topologically sorted list <nl> + * <nl> + * Uses the reverse depth first search as outlined in . . . <nl> + * @ param graph <nl> + * @ return <nl> + * / <nl> + public static < T > List < T > topologicalSort ( DirectedGraph < T > graph ) { <nl> + DirectedGraph < T > rGraph = reverse ( graph ) ; <nl> + <nl> + List < T > sortedResult = new ArrayList < T > ( ) ; <nl> + Set < T > visitedNodes = new HashSet < T > ( ) ; <nl> + <nl> + / / A list of " fully explored " nodes . Leftovers in here indicate cycles in the graph <nl> + Set < T > expandedNodes = new HashSet < T > ( ) ; <nl> + <nl> + for ( T node : rGraph ) { <nl> + explore ( node , rGraph , sortedResult , visitedNodes , expandedNodes ) ; <nl> + } <nl> + <nl> + return sortedResult ; <nl> + } <nl> + <nl> + public static < T > DirectedGraph < T > reverse ( DirectedGraph < T > graph ) { <nl> + DirectedGraph < T > result = new DirectedGraph < T > ( ) ; <nl> + for ( T node : graph ) { <nl> + result . addNode ( node ) ; <nl> + } <nl> + for ( T from : graph ) { <nl> + for ( T to : graph . edgesFrom ( from ) ) { <nl> + result . addEdge ( to , from ) ; <nl> + } <nl> + } <nl> + <nl> + return result ; <nl> + } <nl> + <nl> + public static < T > void explore ( T node , DirectedGraph < T > graph , List < T > sortedResult , Set < T > visitedNodes , Set < T > expandedNodes ) { <nl> + / / Have we been here before ? <nl> + if ( visitedNodes . contains ( node ) ) { <nl> + / / And have completed this node before <nl> + if ( expandedNodes . contains ( node ) ) { <nl> + / / Then we ' re fine <nl> + return ; <nl> + } <nl> + System . out . printf ( " % s : % s \ n % s \ n % s \ n " , node , sortedResult , visitedNodes , expandedNodes ) ; <nl> + throw new IllegalArgumentException ( " There was a cycle detected in the input graph , sorting is not possible " ) ; <nl> + } <nl> + <nl> + / / Visit this node <nl> + visitedNodes . add ( node ) ; <nl> + <nl> + / / Recursively explore inbound edges <nl> + for ( T inbound : graph . edgesFrom ( node ) ) { <nl> + explore ( inbound , graph , sortedResult , visitedNodes , expandedNodes ) ; <nl> + } <nl> + <nl> + / / Add ourselves now <nl> + sortedResult . add ( node ) ; <nl> + <nl> + / / And mark ourselves as explored <nl> + expandedNodes . add ( node ) ; <nl> + } <nl> + } <nl> diff - - git a / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java b / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java <nl> index 8c57058 . . 922e4f8 100644 <nl> - - - a / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java <nl> + + + b / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java <nl> @ @ - 14 , 7 + 14 , 6 @ @ <nl> package cpw . mods . fml . server ; <nl> <nl> import java . util . ArrayList ; <nl> - import java . util . Collections ; <nl> import java . util . List ; <nl> import java . util . StringTokenizer ; <nl> <nl> @ @ - 32 , 6 + 31 , 9 @ @ public class ModLoaderModContainer implements ModContainer { <nl> private BaseMod mod ; <nl> private boolean isTicking ; <nl> private String modSource ; <nl> + private ArrayList < String > dependencies ; <nl> + private ArrayList < String > preDependencies ; <nl> + private ArrayList < String > postDependencies ; <nl> public ModLoaderModContainer ( Class < ? extends BaseMod > modClazz , String modSource ) { <nl> this . modClazz = modClazz ; <nl> this . modSource = modSource ; <nl> @ @ - 174 , 15 + 176 , 13 @ @ public class ModLoaderModContainer implements ModContainer { <nl> public ICraftingHandler getCraftingHandler ( ) { <nl> return mod ; <nl> } <nl> - <nl> - / * ( non - Javadoc ) <nl> - * @ see cpw . mods . fml . common . ModContainer # getDependencies ( ) <nl> - * / <nl> - @ Override <nl> - public List < String > getDependencies ( ) { <nl> - ArrayList < String > dependencies = new ArrayList < String > ( 10 ) ; <nl> + <nl> + private void computeDependencies ( ) { <nl> + dependencies = new ArrayList < String > ( ) ; <nl> + preDependencies = new ArrayList < String > ( ) ; <nl> + postDependencies = new ArrayList < String > ( ) ; <nl> if ( mod . getPriorities ( ) = = null | | mod . getPriorities ( ) . length ( ) = = 0 ) { <nl> - return dependencies ; <nl> + return ; <nl> } <nl> StringTokenizer st = new StringTokenizer ( mod . getPriorities ( ) , " ; " ) ; <nl> for ( ; st . hasMoreTokens ( ) ; ) { <nl> @ @ - 194 , 19 + 194 , 44 @ @ public class ModLoaderModContainer implements ModContainer { <nl> if ( " required - before " . equals ( depparts [ 0 ] ) | | " required - after " . equals ( depparts [ 0 ] ) ) { <nl> dependencies . add ( depparts [ 1 ] ) ; <nl> } <nl> + <nl> + if ( " required - before " . equals ( depparts [ 0 ] ) | | " before " . equals ( depparts [ 0 ] ) ) { <nl> + preDependencies . add ( depparts [ 1 ] ) ; <nl> + } <nl> + <nl> + if ( " required - after " . equals ( depparts [ 0 ] ) | | " after " . equals ( depparts [ 0 ] ) ) { <nl> + postDependencies . add ( depparts [ 1 ] ) ; <nl> + } <nl> + } <nl> + } <nl> + / * ( non - Javadoc ) <nl> + * @ see cpw . mods . fml . common . ModContainer # getDependencies ( ) <nl> + * / <nl> + @ Override <nl> + public List < String > getDependencies ( ) { <nl> + if ( dependencies = = null ) { <nl> + computeDependencies ( ) ; <nl> } <nl> return dependencies ; <nl> } <nl> <nl> @ Override <nl> public List < String > getPreDepends ( ) { <nl> - / / TODO Auto - generated method stub <nl> - return null ; <nl> + if ( dependencies = = null ) { <nl> + computeDependencies ( ) ; <nl> + } <nl> + return preDependencies ; <nl> } <nl> <nl> @ Override <nl> public List < String > getPostDepends ( ) { <nl> - / / TODO Auto - generated method stub <nl> - return null ; <nl> + if ( dependencies = = null ) { <nl> + computeDependencies ( ) ; <nl> + } <nl> + return postDependencies ; <nl> + } <nl> + <nl> + public String toString ( ) { <nl> + return modSource ; <nl> } <nl> } <nl> diff - - git a / fml / test / cpw / mods / fml / test / LoaderTests . java b / fml / test / cpw / mods / fml / test / LoaderTests . java <nl> new file mode 100644 <nl> index 0000000 . . 28e1b41 <nl> - - - / dev / null <nl> + + + b / fml / test / cpw / mods / fml / test / LoaderTests . java <nl> @ @ - 0 , 0 + 1 , 214 @ @ <nl> + / * <nl> + * The FML Forge Mod Loader suite . <nl> + * Copyright ( C ) 2012 cpw <nl> + * <nl> + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> + * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package cpw . mods . fml . test ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + <nl> + import net . minecraft . src . BaseMod ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . Before ; <nl> + import org . junit . Test ; <nl> + import static org . junit . Assert . * ; <nl> + <nl> + import cpw . mods . fml . common . ModContainer ; <nl> + import cpw . mods . fml . common . toposort . ModSorter ; <nl> + import cpw . mods . fml . server . ModLoaderModContainer ; <nl> + <nl> + <nl> + public class LoaderTests { <nl> + <nl> + private ModContainer mc1 ; <nl> + private ModContainer mc2 ; <nl> + private ModContainer mc3 ; <nl> + private ModContainer mc4 ; <nl> + private ModContainer mc5 ; <nl> + private ModContainer mc6 ; <nl> + private ModContainer mc7 ; <nl> + private ModContainer mc8 ; <nl> + <nl> + @ Before <nl> + public void setUp ( ) throws Exception { <nl> + mc1 = new ModLoaderModContainer ( Mod1 . class , " Test1 " ) ; <nl> + mc1 . preInit ( ) ; <nl> + mc2 = new ModLoaderModContainer ( Mod2 . class , " Test2 " ) ; <nl> + mc2 . preInit ( ) ; <nl> + mc3 = new ModLoaderModContainer ( Mod3 . class , " Test3 " ) ; <nl> + mc3 . preInit ( ) ; <nl> + mc4 = new ModLoaderModContainer ( Mod4 . class , " Test4 " ) ; <nl> + mc4 . preInit ( ) ; <nl> + mc5 = new ModLoaderModContainer ( Mod5 . class , " Test5 " ) ; <nl> + mc5 . preInit ( ) ; <nl> + mc6 = new ModLoaderModContainer ( Mod5 . class , " Test6 " ) ; <nl> + mc6 . preInit ( ) ; <nl> + mc7 = new ModLoaderModContainer ( Mod5 . class , " Test7 " ) ; <nl> + mc7 . preInit ( ) ; <nl> + mc8 = new ModLoaderModContainer ( Mod5 . class , " Test8 " ) ; <nl> + mc8 . preInit ( ) ; <nl> + } <nl> + <nl> + @ After <nl> + public void tearDown ( ) throws Exception { <nl> + } <nl> + <nl> + @ Test <nl> + public void testModSorting ( ) { <nl> + HashMap < String , ModContainer > modList = new HashMap < String , ModContainer > ( ) ; <nl> + modList . put ( " Mod1 " , mc1 ) ; <nl> + modList . put ( " Mod2 " , mc2 ) ; <nl> + modList . put ( " Mod3 " , mc3 ) ; <nl> + modList . put ( " Mod4 " , mc4 ) ; <nl> + modList . put ( " Mod5 " , mc5 ) ; <nl> + modList . put ( " Mod6 " , mc6 ) ; <nl> + modList . put ( " Mod7 " , mc7 ) ; <nl> + modList . put ( " Mod8 " , mc8 ) ; <nl> + ModSorter ms = new ModSorter ( Collections . list ( Collections . enumeration ( modList . values ( ) ) ) , modList ) ; <nl> + List < ModContainer > mods = ms . sort ( ) ; <nl> + assertEquals ( " Eight mods " , 8 , mods . size ( ) ) ; <nl> + System . out . printf ( " % s \ n " , mods ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testModPrioritiesParsing ( ) { <nl> + / / Mod 1 <nl> + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; <nl> + <nl> + / / Mod 2 <nl> + assertTrue ( " Empty hard dependencies for Mod2 " , mc2 . getDependencies ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( " Mod2 postdepends on * " , mc1 . getPostDepends ( ) . contains ( " * " ) ) ; <nl> + <nl> + / / Mod 3 <nl> + assertEquals ( " Two hard dependencies for Mod3 " , 2 , mc1 . getDependencies ( ) . size ( ) ) ; <nl> + assertTrue ( " Hard dependencies for Mod3 contains Mod4 " , mc1 . getDependencies ( ) . contains ( " Mod4 " ) ) ; <nl> + assertTrue ( " Hard dependencies for Mod3 contains Mod2 " , mc1 . getDependencies ( ) . contains ( " Mod2 " ) ) ; <nl> + assertEquals ( " One pre depends for Mod3 " , 1 , mc1 . getPreDepends ( ) . size ( ) ) ; <nl> + assertEquals ( " One post depends for Mod3 " , 1 , mc1 . getPostDepends ( ) . size ( ) ) ; <nl> + <nl> + / / Mod 4 <nl> + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; <nl> + <nl> + / / Mod 5 <nl> + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; <nl> + } <nl> + <nl> + public static class Mod1 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " before : * " ; <nl> + } <nl> + } <nl> + public static class Mod2 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " after : * " ; <nl> + } <nl> + } <nl> + public static class Mod3 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " required - before : Mod4 ; required - after : Mod5 " ; <nl> + } <nl> + } <nl> + public static class Mod4 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " required - before : Mod2 ; after : Mod3 ; required - after : Mod1 " ; <nl> + } <nl> + } <nl> + public static class Mod5 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " " ; <nl> + } <nl> + } <nl> + public static class Mod6 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " " ; <nl> + } <nl> + } <nl> + public static class Mod7 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " " ; <nl> + } <nl> + } <nl> + public static class Mod8 extends BaseMod { <nl> + @ Override <nl> + public String getVersion ( ) { <nl> + return null ; <nl> + } <nl> + @ Override <nl> + public void load ( ) { <nl> + } <nl> + @ Override <nl> + public String getPriorities ( ) { <nl> + return " before : Mod7 " ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / fml / test / fml / test / LoaderTests . java b / fml / test / fml / test / LoaderTests . java <nl> deleted file mode 100644 <nl> index 8330e88 . . 0000000 <nl> - - - a / fml / test / fml / test / LoaderTests . java <nl> + + + / dev / null <nl> @ @ - 1 , 37 + 0 , 0 @ @ <nl> - / * <nl> - * The FML Forge Mod Loader suite . <nl> - * Copyright ( C ) 2012 cpw <nl> - * <nl> - * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> - * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> - * <nl> - * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> - * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> - * <nl> - * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> - * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> - * / <nl> - package fml . test ; <nl> - <nl> - import org . junit . After ; <nl> - import org . junit . Before ; <nl> - import org . junit . Test ; <nl> - <nl> - import cpw . mods . fml . common . Loader ; <nl> - <nl> - <nl> - public class LoaderTests { <nl> - <nl> - @ Before <nl> - public void setUp ( ) throws Exception { <nl> - } <nl> - <nl> - @ After <nl> - public void tearDown ( ) throws Exception { <nl> - } <nl> - <nl> - @ Test <nl> - public void testModLoading ( ) { <nl> - Loader . instance ( ) . loadMods ( ) ; <nl> - } <nl> - }

TEST DIFF:
diff - - git a / build . gradle b / build . gradle 
 index 1a16a7e . . 8f89109 100644 
 - - - a / build . gradle 
 + + + b / build . gradle 
 @ @ - 66 , 8 + 66 , 10 @ @ version = getVersionFromJava ( file ( " src / main / java / net / minecraftforge / common / Forge 
 extractForgeSources { exclude " * * / SideOnly . java " , " * * / Side . java " } 
 extractForgeResources { exclude " * * / log4j2 . xml " } 
 
 - genGradleProjects { 
 - addTestCompileDep " junit : junit : 4 . 12 " 
 + genGradleProjects { 
 + addTestCompileDep " junit : junit : 4 . 12 " / / TODO update unit tests to junit 5 and remove this 
 + addTestCompileDep " org . junit . jupiter : junit - jupiter - api : 5 . 0 . 0 " 
 + addTestCompileDep " org . opentest4j : opentest4j : 1 . 0 . 0 " / / needed for junit 5 
 addTestCompileDep " org . hamcrest : hamcrest - core : 1 . 3 " 
 filter { dep - > ! dep . contains ( " scala " ) } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLModContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLModContainer . java 
 index d63e4b6 . . 3cc51e8 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / FMLModContainer . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / FMLModContainer . java 
 @ @ - 51 , 6 + 51 , 7 @ @ import net . minecraftforge . fml . common . event . FMLFingerprintViolationEvent ; 
 import net . minecraftforge . fml . common . network . NetworkRegistry ; 
 import net . minecraftforge . fml . common . versioning . ArtifactVersion ; 
 import net . minecraftforge . fml . common . versioning . DefaultArtifactVersion ; 
 + import net . minecraftforge . fml . common . versioning . DependencyParser ; 
 import net . minecraftforge . fml . common . versioning . VersionParser ; 
 import net . minecraftforge . fml . common . versioning . VersionRange ; 
 import net . minecraftforge . fml . relauncher . Side ; 
 @ @ - 67 , 14 + 68 , 11 @ @ import java . util . function . Function ; 
 import com . google . common . base . Strings ; 
 import com . google . common . collect . ArrayListMultimap ; 
 import com . google . common . collect . ImmutableList ; 
 - import com . google . common . collect . ImmutableList . Builder ; 
 import com . google . common . collect . ImmutableMap ; 
 import com . google . common . collect . ImmutableSet ; 
 import com . google . common . collect . ListMultimap ; 
 - import com . google . common . collect . Lists ; 
 import com . google . common . collect . Maps ; 
 import com . google . common . collect . SetMultimap ; 
 - import com . google . common . collect . Sets ; 
 import com . google . common . eventbus . EventBus ; 
 import com . google . common . eventbus . Subscribe ; 
 
 @ @ - 140 , 19 + 138 , 18 @ @ public class FMLModContainer implements ModContainer 
 String modid = ( String ) this . descriptor . get ( " modid " ) ; 
 if ( Strings . isNullOrEmpty ( modid ) ) 
 { 
 - throw new IllegalArgumentException ( " Modid cannot be null or empty " ) ; 
 + throw new IllegalArgumentException ( " The modId is null or empty " ) ; 
 } 
 if ( modid . length ( ) > 64 ) 
 { 
 - FMLLog . bigWarning ( " The modid { } is longer than the recommended maximum of 64 characters . Truncation is enforced in 1 . 11 " , modid ) ; 
 - throw new IllegalArgumentException ( String . format ( " The modid % s is longer than the recommended maximum of 64 characters . Truncation is enforced in 1 . 11 " , modid ) ) ; 
 + throw new IllegalArgumentException ( String . format ( " The modId % s is longer than the maximum of 64 characters . " , modid ) ) ; 
 } 
 if ( ! modid . equals ( modid . toLowerCase ( Locale . ENGLISH ) ) ) 
 { 
 - FMLLog . bigWarning ( " The modid { } is not the same as it ' s lowercase version . Lowercasing is enforced in 1 . 11 " , modid ) ; 
 - throw new IllegalArgumentException ( String . format ( " The modid % s is not the same as it ' s lowercase version . Lowercasing will be enforced in 1 . 11 " , modid ) ) ; 
 + throw new IllegalArgumentException ( String . format ( " The modId % s must be all lowercase . " , modid ) ) ; 
 } 
 } 
 + 
 private ILanguageAdapter getLanguageAdapter ( ) 
 { 
 if ( languageAdapter = = null ) 
 @ @ - 212 , 17 + 209 , 15 @ @ public class FMLModContainer implements ModContainer 
 
 if ( overridesMetadata | | ! modMetadata . useDependencyInformation ) 
 { 
 - Set < ArtifactVersion > requirements = Sets . newHashSet ( ) ; 
 - List < ArtifactVersion > dependencies = Lists . newArrayList ( ) ; 
 - List < ArtifactVersion > dependants = Lists . newArrayList ( ) ; 
 annotationDependencies = ( String ) descriptor . get ( " dependencies " ) ; 
 - Loader . instance ( ) . computeDependencies ( annotationDependencies , requirements , dependencies , dependants ) ; 
 - dependants . addAll ( Loader . instance ( ) . getInjectedBefore ( getModId ( ) ) ) ; 
 - dependencies . addAll ( Loader . instance ( ) . getInjectedAfter ( getModId ( ) ) ) ; 
 - modMetadata . requiredMods = requirements ; 
 - modMetadata . dependencies = dependencies ; 
 - modMetadata . dependants = dependants ; 
 - modLog . trace ( " Parsed dependency info : { } { } { } " , requirements , dependencies , dependants ) ; 
 + DependencyParser dependencyParser = new DependencyParser ( getModId ( ) , FMLCommonHandler . instance ( ) . getSide ( ) ) ; 
 + DependencyParser . DependencyInfo info = dependencyParser . parseDependencies ( annotationDependencies ) ; 
 + info . dependants . addAll ( Loader . instance ( ) . getInjectedBefore ( getModId ( ) ) ) ; 
 + info . dependencies . addAll ( Loader . instance ( ) . getInjectedAfter ( getModId ( ) ) ) ; 
 + modMetadata . requiredMods = info . requirements ; 
 + modMetadata . dependencies = info . dependencies ; 
 + modMetadata . dependants = info . dependants ; 
 + modLog . trace ( " Parsed dependency info : Requirements : { } After : { } Before : { } " , info . requirements , info . dependencies , info . dependants ) ; 
 } 
 else 
 { 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / Loader . java b / src / main / java / net / minecraftforge / fml / common / Loader . java 
 index 5646f8b . . d38e7c1 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / Loader . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / Loader . java 
 @ @ - 26 , 7 + 26 , 6 @ @ import java . io . IOException ; 
 import java . io . InputStream ; 
 import java . net . MalformedURLException ; 
 import java . util . ArrayList ; 
 - import java . util . Collections ; 
 import java . util . Comparator ; 
 import java . util . Iterator ; 
 import java . util . List ; 
 @ @ - 35 , 6 + 34 , 7 @ @ import java . util . Properties ; 
 import java . util . Set ; 
 
 import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . common . ForgeVersion ; 
 import net . minecraftforge . common . capabilities . CapabilityManager ; 
 import net . minecraftforge . common . config . ConfigManager ; 
 import net . minecraftforge . common . crafting . CraftingHelper ; 
 @ @ - 52 , 6 + 52 , 7 @ @ import net . minecraftforge . fml . common . toposort . ModSortingException ; 
 import net . minecraftforge . fml . common . toposort . TopologicalSort ; 
 import net . minecraftforge . fml . common . toposort . ModSortingException . SortingExceptionData ; 
 import net . minecraftforge . fml . common . versioning . ArtifactVersion ; 
 + import net . minecraftforge . fml . common . versioning . DependencyParser ; 
 import net . minecraftforge . fml . common . versioning . VersionParser ; 
 import net . minecraftforge . fml . relauncher . ModListHelper ; 
 import net . minecraftforge . fml . relauncher . Side ; 
 @ @ - 62 , 7 + 63 , 6 @ @ import org . apache . commons . io . IOUtils ; 
 import org . apache . logging . log4j . Level ; 
 
 import com . google . common . base . CharMatcher ; 
 - import java . util . function . Function ; 
 import com . google . common . base . Joiner ; 
 import com . google . common . base . Splitter ; 
 import com . google . common . collect . ArrayListMultimap ; 
 @ @ - 124 , 9 + 124 , 7 @ @ import javax . annotation . Nullable ; 
 @ SuppressWarnings ( " unused " ) 
 public class Loader 
 { 
 - public static final String MC _ VERSION = net . minecraftforge . common . ForgeVersion . mcVersion ; 
 - private static final Splitter DEPENDENCYPARTSPLITTER = Splitter . on ( " : " ) . omitEmptyStrings ( ) . trimResults ( ) ; 
 - private static final Splitter DEPENDENCYSPLITTER = Splitter . on ( " ; " ) . omitEmptyStrings ( ) . trimResults ( ) ; 
 + public static final String MC _ VERSION = ForgeVersion . mcVersion ; 
 / * * 
 * The singleton instance 
 * / 
 @ @ - 695 , 77 + 693 , 17 @ @ public class Loader 
 return modClassLoader ; 
 } 
 
 + / * * 
 + * @ deprecated use { @ link DependencyParser # parseDependencies ( String ) } 
 + * / 
 + @ Deprecated / / TODO : remove in 1 . 13 
 public void computeDependencies ( String dependencyString , Set < ArtifactVersion > requirements , List < ArtifactVersion > dependencies , List < ArtifactVersion > dependants ) 
 { 
 - if ( dependencyString = = null | | dependencyString . length ( ) = = 0 ) 
 - { 
 - return ; 
 - } 
 - 
 - boolean parseFailure = false ; 
 - 
 - for ( String dep : DEPENDENCYSPLITTER . split ( dependencyString ) ) 
 - { 
 - List < String > depparts = Lists . newArrayList ( DEPENDENCYPARTSPLITTER . split ( dep ) ) ; 
 - / / Need two parts to the string 
 - if ( depparts . size ( ) ! = 2 ) 
 - { 
 - parseFailure = true ; 
 - continue ; 
 - } 
 - String instruction = depparts . get ( 0 ) ; 
 - String target = depparts . get ( 1 ) ; 
 - boolean targetIsAll = target . startsWith ( " * " ) ; 
 - 
 - / / Cannot have an " all " relationship with anything except pure * 
 - if ( targetIsAll & & target . length ( ) > 1 ) 
 - { 
 - parseFailure = true ; 
 - continue ; 
 - } 
 - 
 - / / If this is a required element , add it to the required list 
 - if ( " required - before " . equals ( instruction ) | | " required - after " . equals ( instruction ) ) 
 - { 
 - / / You can ' t require everything 
 - if ( ! targetIsAll ) 
 - { 
 - requirements . add ( VersionParser . parseVersionReference ( target ) ) ; 
 - } 
 - else 
 - { 
 - parseFailure = true ; 
 - continue ; 
 - } 
 - } 
 - 
 - / / You cannot have a versioned dependency on everything 
 - if ( targetIsAll & & target . indexOf ( ' @ ' ) > - 1 ) 
 - { 
 - parseFailure = true ; 
 - continue ; 
 - } 
 - / / before elements are things we are loaded before ( so they are our dependants ) 
 - if ( " required - before " . equals ( instruction ) | | " before " . equals ( instruction ) ) 
 - { 
 - dependants . add ( VersionParser . parseVersionReference ( target ) ) ; 
 - } 
 - / / after elements are things that load before we do ( so they are out dependencies ) 
 - else if ( " required - after " . equals ( instruction ) | | " after " . equals ( instruction ) ) 
 - { 
 - dependencies . add ( VersionParser . parseVersionReference ( target ) ) ; 
 - } 
 - else 
 - { 
 - parseFailure = true ; 
 - } 
 - } 
 - 
 - if ( parseFailure ) 
 - { 
 - FMLLog . log . warn ( " Unable to parse dependency string { } " , dependencyString ) ; 
 - throw new LoaderException ( String . format ( " Unable to parse dependency string % s " , dependencyString ) ) ; 
 - } 
 + DependencyParser dependencyParser = new DependencyParser ( " unknown " , FMLCommonHandler . instance ( ) . getSide ( ) ) ; 
 + DependencyParser . DependencyInfo info = dependencyParser . parseDependencies ( dependencyString ) ; 
 + requirements . addAll ( info . requirements ) ; 
 + dependencies . addAll ( info . dependencies ) ; 
 + dependants . addAll ( info . dependants ) ; 
 } 
 
 public Map < String , ModContainer > getIndexedModList ( ) 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / Mod . java b / src / main / java / net / minecraftforge / fml / common / Mod . java 
 index 7ff9bd6 . . 97608a5 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / Mod . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / Mod . java 
 @ @ - 101 , 24 + 101 , 37 @ @ public @ interface Mod 
 / * * 
 * A dependency string for this mod , which specifies which mod ( s ) it depends on in order to run . 
 * 
 - * A dependency string can start with the following four prefixes : 
 - * before , after , required - before , required - after 
 + * A dependency string must start with a combination of these prefixes , separated by " - " : 
 + * [ before , after ] , [ required ] , [ client , server ] 
 + * At least one " before " , " after " , or " required " must be specified . 
 * Then " : " and the mod id . 
 - * 
 - * Optionally , a version range can be specified for the mod by adding " @ " and then the version range . 
 - * The version range format is described in the javadoc here : { @ link VersionRange # createFromVersionSpec ( java . lang . String ) } 
 + * Then a version range should be specified for the mod by adding " @ " and the version range . 
 + * The version range format is described in the javadoc here : 
 + * { @ link VersionRange # createFromVersionSpec ( java . lang . String ) } 
 + * Then a " ; " . 
 * 
 * If a " required " mod is missing , or a mod exists with a version outside the specified range , 
 * the game will not start and an error screen will tell the player which versions are required . 
 * 
 * Example : 
 - * Our example mod is a dedicated addon to mod1 and has optional integration with mod2 . 
 - * It uses new features that were introduced in forge version 14 . 21 . 1 . 2395 and mod2 version 4 . 7 . 0 
 + * Our example mod : 
 + * * depends on Forge and uses new features that were introduced in Forge version 14 . 21 . 1 . 2395 
 + * " required : forge @ [ 14 . 21 . 1 . 2395 , ) ; " 
 + * * is a dedicated addon to mod1 and has to have its event handlers run after mod1 ' s are run , 
 + * " required - after : mod1 ; " 
 + * * has optional integration with mod2 which depends on features introduced in mod2 version 4 . 7 . 0 , 
 + * " after : mod2 @ [ 4 . 7 . 0 , ) ; " 
 + * * depends on a client - side - only rendering library called rendermod 
 + * " required - client : rendermod ; " 
 * 
 - * the dependencies string = " after : forge @ [ 14 . 21 . 1 . 2395 , ) ; required - after : mod1 ; after : mod2 @ [ 4 . 7 . 0 , ) ; " 
 + * The full dependencies string is all of those combined : 
 + * " required : forge @ [ 14 . 21 . 1 . 2395 , ) ; required - after : mod1 ; after : mod2 @ [ 4 . 7 . 0 , ) ; required - client : rendermod ; " 
 * 
 * This will stop the game and display an error message if any of these is true : 
 - * The installed forge is too old , mod1 is missing , or an old version of mod2 is present . 
 + * The installed forge is too old , 
 + * mod1 is missing , 
 + * an old version of mod2 is present , 
 + * rendermod is missing on the client . 
 * / 
 String dependencies ( ) default " " ; 
 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / versioning / DependencyParser . java b / src / main / java / net / minecraftforge / fml / common / versioning / DependencyParser . java 
 new file mode 100644 
 index 0000000 . . ac34202 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / common / versioning / DependencyParser . java 
 @ @ - 0 , 0 + 1 , 221 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . fml . common . versioning ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . HashSet ; 
 + import java . util . List ; 
 + import java . util . Locale ; 
 + import java . util . Set ; 
 + 
 + import com . google . common . base . Splitter ; 
 + import com . google . common . base . Strings ; 
 + import com . google . common . collect . ImmutableList ; 
 + import net . minecraftforge . fml . common . LoaderException ; 
 + import net . minecraftforge . fml . relauncher . Side ; 
 + import org . apache . logging . log4j . LogManager ; 
 + import org . apache . logging . log4j . Logger ; 
 + 
 + public final class DependencyParser 
 + { 
 + public static class DependencyInfo 
 + { 
 + public final Set < ArtifactVersion > requirements = new HashSet < > ( ) ; 
 + public final List < ArtifactVersion > dependencies = new ArrayList < > ( ) ; 
 + public final List < ArtifactVersion > dependants = new ArrayList < > ( ) ; 
 + } 
 + 
 + private static final Logger LOGGER = LogManager . getLogger ( " FML " ) ; 
 + private static final ImmutableList < String > DEPENDENCY _ INSTRUCTIONS = ImmutableList . of ( " client " , " server " , " required " , " before " , " after " ) ; 
 + private static final Splitter DEPENDENCY _ INSTRUCTIONS _ SPLITTER = Splitter . on ( " - " ) . omitEmptyStrings ( ) . trimResults ( ) ; 
 + private static final Splitter DEPENDENCY _ PART _ SPLITTER = Splitter . on ( " : " ) . omitEmptyStrings ( ) . trimResults ( ) ; 
 + private static final Splitter DEPENDENCY _ SPLITTER = Splitter . on ( " ; " ) . omitEmptyStrings ( ) . trimResults ( ) ; 
 + 
 + private final String modId ; 
 + private final Side side ; 
 + 
 + public DependencyParser ( String modId , Side side ) 
 + { 
 + this . modId = modId ; 
 + this . side = side ; 
 + } 
 + 
 + public DependencyInfo parseDependencies ( String dependencyString ) 
 + { 
 + DependencyInfo info = new DependencyInfo ( ) ; 
 + if ( dependencyString = = null | | dependencyString . length ( ) = = 0 ) 
 + { 
 + return info ; 
 + } 
 + 
 + for ( String dep : DEPENDENCY _ SPLITTER . split ( dependencyString ) ) 
 + { 
 + final List < String > depParts = DEPENDENCY _ PART _ SPLITTER . splitToList ( dep ) ; 
 + if ( depParts . size ( ) ! = 2 ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " Dependency string needs 2 parts . " ) ; 
 + } 
 + 
 + final List < String > instructions = DEPENDENCY _ INSTRUCTIONS _ SPLITTER . splitToList ( depParts . get ( 0 ) ) ; 
 + final String target = depParts . get ( 1 ) ; 
 + parseDependency ( dep , instructions , target , info ) ; 
 + } 
 + return info ; 
 + } 
 + 
 + private void parseDependency ( String dep , List < String > instructions , String target , DependencyInfo info ) 
 + { 
 + final boolean targetIsAll = target . startsWith ( " * " ) ; 
 + final boolean targetIsBounded = target . contains ( " @ " ) ; 
 + if ( targetIsAll ) 
 + { 
 + if ( target . length ( ) > 1 ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " Cannot have an \ " all \ " ( * ) relationship with anything except pure * " ) ; 
 + } 
 + else if ( targetIsBounded ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " You cannot have a versioned dependency on everything ( * ) " ) ; 
 + } 
 + } 
 + 
 + Side depSide = null ; 
 + String depOrder = null ; 
 + boolean depRequired = false ; 
 + 
 + for ( String instruction : instructions ) 
 + { 
 + if ( " client " . equals ( instruction ) ) 
 + { 
 + if ( depSide ! = null ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " Up to one side ( client or server ) can be specified . " ) ; 
 + } 
 + depSide = Side . CLIENT ; 
 + } 
 + else if ( " server " . equals ( instruction ) ) 
 + { 
 + if ( depSide ! = null ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " Up to one side ( client or server ) can be specified . " ) ; 
 + } 
 + depSide = Side . SERVER ; 
 + } 
 + else if ( " required " . equals ( instruction ) ) 
 + { 
 + if ( depRequired ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " ' required ' can only be specified once . " ) ; 
 + } 
 + if ( targetIsAll ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " You can ' t ' require ' everything ( * ) " ) ; 
 + } 
 + depRequired = true ; 
 + } 
 + else if ( " before " . equals ( instruction ) | | " after " . equals ( instruction ) ) 
 + { 
 + if ( depOrder ! = null ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " ' before ' or ' after ' can only be specified once . " ) ; 
 + } 
 + depOrder = instruction ; 
 + } 
 + else 
 + { 
 + throw new DependencyParserException ( modId , dep , String . format ( " Found invalid instruction ' % s ' . Only % s are allowed . " , instruction , DEPENDENCY _ INSTRUCTIONS ) ) ; 
 + } 
 + } 
 + 
 + ArtifactVersion artifactVersion ; 
 + try 
 + { 
 + artifactVersion = VersionParser . parseVersionReference ( target ) ; 
 + } 
 + catch ( RuntimeException e ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " Could not parse version string . " , e ) ; 
 + } 
 + 
 + if ( ! targetIsAll ) 
 + { 
 + String depModId = artifactVersion . getLabel ( ) ; 
 + sanityCheckModId ( modId , dep , depModId ) ; 
 + } 
 + 
 + if ( ! depRequired & & depOrder = = null ) 
 + { 
 + throw new DependencyParserException ( modId , dep , " ' required ' , ' client ' , or ' server ' must be specified . " ) ; 
 + } 
 + 
 + if ( depSide = = null | | depSide = = this . side ) 
 + { 
 + if ( depRequired ) 
 + { 
 + info . requirements . add ( artifactVersion ) ; 
 + } 
 + 
 + if ( " before " . equals ( depOrder ) ) 
 + { 
 + info . dependants . add ( artifactVersion ) ; 
 + } 
 + else if ( " after " . equals ( depOrder ) ) 
 + { 
 + info . dependencies . add ( artifactVersion ) ; 
 + } 
 + } 
 + } 
 + 
 + / / TODO 1 . 13 : throw these exceptions instead of logging them 
 + / * * Based on { @ link net . minecraftforge . fml . common . FMLModContainer # sanityCheckModId ( ) } * / 
 + private static void sanityCheckModId ( String modId , String dep , String depModId ) 
 + { 
 + if ( Strings . isNullOrEmpty ( depModId ) ) 
 + { 
 + LOGGER . error ( new DependencyParserException ( modId , dep , " The modId is null or empty " ) . getMessage ( ) ) ; 
 + } 
 + else if ( depModId . length ( ) > 64 ) 
 + { 
 + LOGGER . error ( new DependencyParserException ( modId , dep , String . format ( " The modId ' % s ' is longer than the maximum of 64 characters . " , depModId ) ) . getMessage ( ) ) ; 
 + } 
 + else if ( ! depModId . equals ( depModId . toLowerCase ( Locale . ENGLISH ) ) ) 
 + { 
 + LOGGER . error ( new DependencyParserException ( modId , dep , String . format ( " The modId ' % s ' must be all lowercase . " , depModId ) ) . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + private static class DependencyParserException extends LoaderException 
 + { 
 + public DependencyParserException ( String modId , String dependencyString , String explanation ) 
 + { 
 + super ( formatMessage ( modId , dependencyString , explanation ) ) ; 
 + } 
 + 
 + public DependencyParserException ( String modId , String dependencyString , String explanation , Throwable cause ) 
 + { 
 + super ( formatMessage ( modId , dependencyString , explanation ) , cause ) ; 
 + } 
 + 
 + public static String formatMessage ( String modId , String dependencyString , String explanation ) 
 + { 
 + return String . format ( " Unable to parse dependency for mod ' % s ' with dependency string ' % s ' . % s " , modId , dependencyString , explanation ) ; 
 + } 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / versioning / VersionParser . java b / src / main / java / net / minecraftforge / fml / common / versioning / VersionParser . java 
 index 95a85bb . . 3a6d109 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / versioning / VersionParser . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / versioning / VersionParser . java 
 @ @ - 21 , 11 + 21 , 8 @ @ package net . minecraftforge . fml . common . versioning ; 
 
 import java . util . List ; 
 
 - import net . minecraftforge . fml . common . FMLLog ; 
 import net . minecraftforge . fml . common . LoaderException ; 
 
 - import org . apache . logging . log4j . Level ; 
 - 
 import com . google . common . base . Splitter ; 
 import com . google . common . base . Strings ; 
 import com . google . common . collect . Lists ; 
 @ @ - 76 , 8 + 73 , 7 @ @ public class VersionParser 
 } 
 catch ( InvalidVersionSpecificationException e ) 
 { 
 - FMLLog . log . error ( " Unable to parse a version range specification successfully { } " , range , e ) ; 
 - throw new LoaderException ( e ) ; 
 + throw new LoaderException ( " Unable to parse a version range specification successfully " + range , e ) ; 
 } 
 } 
 } 
 diff - - git a / src / test / java / net / minecraftforge / fml / test / DependencyParserTest . java b / src / test / java / net / minecraftforge / fml / test / DependencyParserTest . java 
 new file mode 100644 
 index 0000000 . . 2beb94c 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / fml / test / DependencyParserTest . java 
 @ @ - 0 , 0 + 1 , 304 @ @ 
 + package net . minecraftforge . fml . test ; 
 + 
 + import static org . junit . jupiter . api . Assertions . * ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . Collection ; 
 + import java . util . List ; 
 + 
 + import com . google . common . collect . ImmutableList ; 
 + import net . minecraftforge . fml . common . versioning . DependencyParser ; 
 + import net . minecraftforge . fml . relauncher . Side ; 
 + 
 + import com . google . common . base . Functions ; 
 + import com . google . common . collect . Collections2 ; 
 + import com . google . common . collect . Sets ; 
 + 
 + import net . minecraftforge . fml . common . LoaderException ; 
 + import org . junit . jupiter . api . BeforeAll ; 
 + import org . junit . jupiter . api . Test ; 
 + 
 + public class DependencyParserTest 
 + { 
 + private static DependencyParser clientDependencyParser ; 
 + private static DependencyParser serverDependencyParser ; 
 + private static List < DependencyParser > parsers ; 
 + 
 + @ BeforeAll 
 + public static void beforeAll ( ) 
 + { 
 + clientDependencyParser = new DependencyParser ( " test " , Side . CLIENT ) ; 
 + serverDependencyParser = new DependencyParser ( " test " , Side . SERVER ) ; 
 + parsers = ImmutableList . of ( clientDependencyParser , serverDependencyParser ) ; 
 + } 
 + 
 + @ Test 
 + public void testParsingNothing ( ) 
 + { 
 + List < String > strings = new ArrayList < > ( ) ; 
 + strings . add ( null ) ; 
 + strings . add ( " " ) ; 
 + strings . add ( " ; ; ; ; ; ; ; " ) ; 
 + strings . add ( " ; ; ; ; ; ; ; " ) ; 
 + for ( String string : strings ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + DependencyParser . DependencyInfo info = parser . parseDependencies ( string ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertTrue ( info . dependants . isEmpty ( ) ) ; 
 + assertTrue ( info . dependencies . isEmpty ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingRequired ( ) 
 + { 
 + String mod = " supermod3000 @ [ 1 . 2 , ) " ; 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + DependencyParser . DependencyInfo info = parser . parseDependencies ( " required : " + mod ) ; 
 + assertContainsSameToString ( info . requirements , Sets . newHashSet ( mod ) ) ; 
 + assertTrue ( info . dependants . isEmpty ( ) ) ; 
 + assertTrue ( info . dependencies . isEmpty ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingBefore ( ) 
 + { 
 + String mod = " supermod3000 @ [ 1 . 2 , ) " ; 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + DependencyParser . DependencyInfo info = parser . parseDependencies ( " before : " + mod ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertContainsSameToString ( info . dependants , Sets . newHashSet ( mod ) ) ; 
 + assertTrue ( info . dependencies . isEmpty ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingAfter ( ) 
 + { 
 + String mod = " supermod3000 @ [ 1 . 2 , ) " ; 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + DependencyParser . DependencyInfo info = parser . parseDependencies ( " after : " + mod ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertTrue ( info . dependants . isEmpty ( ) ) ; 
 + assertContainsSameToString ( info . dependencies , Sets . newHashSet ( mod ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingNoPrefix ( ) 
 + { 
 + String mod = " supermod3000 @ [ 1 . 2 , ) " ; 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( mod ) ; 
 + } ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingCombined ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + String dependencyString = " after : supermod2000 @ [ 1 . 3 , ) ; required - before : yetanothermod ; required : modw " ; 
 + DependencyParser . DependencyInfo info = parser . parseDependencies ( dependencyString ) ; 
 + assertContainsSameToString ( info . requirements , Sets . newHashSet ( " yetanothermod " , " modw " ) ) ; 
 + assertContainsSameToString ( info . dependencies , Sets . newHashSet ( " supermod2000 @ [ 1 . 3 , ) " ) ) ; 
 + assertContainsSameToString ( info . dependants , Sets . newHashSet ( " yetanothermod " ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingSided ( ) 
 + { 
 + String mod = " testmod @ [ 1 . 0 , 2 . 0 ) " ; 
 + { 
 + DependencyParser . DependencyInfo info = clientDependencyParser . parseDependencies ( " client - after : " + mod ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertTrue ( info . dependants . isEmpty ( ) ) ; 
 + assertContainsSameToString ( info . dependencies , Sets . newHashSet ( mod ) ) ; 
 + } 
 + 
 + { 
 + DependencyParser . DependencyInfo info = clientDependencyParser . parseDependencies ( " server - after : testmod @ [ 1 . 0 , 2 . 0 ) ; server - required : testmod2 ; server - after : testmod3 ; server - before : testmod4 " ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertTrue ( info . dependants . isEmpty ( ) ) ; 
 + assertTrue ( info . dependencies . isEmpty ( ) ) ; 
 + } 
 + 
 + { 
 + DependencyParser . DependencyInfo info = clientDependencyParser . parseDependencies ( " client - before : testmod @ [ 1 . 0 , 2 . 0 ) ; server - required : testmod2 ; server - after : testmod3 ; server - before : testmod4 " ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertContainsSameToString ( info . dependants , Sets . newHashSet ( mod ) ) ; 
 + assertTrue ( info . dependencies . isEmpty ( ) ) ; 
 + } 
 + 
 + { 
 + DependencyParser . DependencyInfo info = serverDependencyParser . parseDependencies ( " server - before : " + mod ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertContainsSameToString ( info . dependants , Sets . newHashSet ( mod ) ) ; 
 + assertTrue ( info . dependencies . isEmpty ( ) ) ; 
 + } 
 + 
 + { 
 + DependencyParser . DependencyInfo info = serverDependencyParser . parseDependencies ( " client - before : testmod @ [ 1 . 0 , 2 . 0 ) ; client - required : testmod2 ; client - after : testmod3 ; client - before : testmod4 " ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertTrue ( info . dependants . isEmpty ( ) ) ; 
 + assertTrue ( info . dependencies . isEmpty ( ) ) ; 
 + } 
 + 
 + { 
 + DependencyParser . DependencyInfo info = serverDependencyParser . parseDependencies ( " server - before : testmod @ [ 1 . 0 , 2 . 0 ) ; client - required : testmod2 ; client - after : testmod3 ; client - before : testmod4 " ) ; 
 + assertTrue ( info . requirements . isEmpty ( ) ) ; 
 + assertContainsSameToString ( info . dependants , Sets . newHashSet ( mod ) ) ; 
 + assertTrue ( info . dependencies . isEmpty ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingInvalidDependencyInstructions ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " gibberishtext : amod " ) ; 
 + } ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingInvalidDependencyVersionClient ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " amod @ [ 10 " ) ; 
 + } ) ; 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " client : amod @ [ 10 " ) ; 
 + } ) ; 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " server : amod @ [ 10 " ) ; 
 + } ) ; 
 + } 
 + } 
 + 
 + / / TODO : enable this in 1 . 13 
 + / / @ Test ( expected = LoaderException . class ) 
 + / / public void testParsingUppercaseModId ( ) 
 + / / { 
 + / / for ( DependencyParser parser : parsers ) 
 + / / { 
 + / / assertThrows ( LoaderException . class , ( ) - > { 
 + / / parser . parseDependencies ( " Forge @ [ 1 . 0 ] " ) ; 
 + / / } ) ; 
 + / / assertThrows ( LoaderException . class , ( ) - > { 
 + / / parser . parseDependencies ( " client : Forge @ [ 1 . 0 ] " ) ; 
 + / / } ) ; 
 + / / assertThrows ( LoaderException . class , ( ) - > { 
 + / / parser . parseDependencies ( " server : Forge @ [ 1 . 0 ] " ) ; 
 + / / } ) ; 
 + / / } 
 + / / } 
 + 
 + @ Test 
 + public void testParsingSoftDepWithNoVersion ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " amod " ) ; 
 + } ) ; 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " client : amod " ) ; 
 + } ) ; 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " server : amod " ) ; 
 + } ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingDepAfterAll ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + parser . parseDependencies ( " after : * " ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingDepBeforeAll ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + parser . parseDependencies ( " before : * " ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingDepOnAll ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " * " ) ; 
 + } ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingSidedDepOnAll ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " client : * " ) ; 
 + } ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingRequireAll ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " required : * " ) ; 
 + } ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testParsingVersionedAll ( ) 
 + { 
 + for ( DependencyParser parser : parsers ) 
 + { 
 + assertThrows ( LoaderException . class , ( ) - > { 
 + parser . parseDependencies ( " * @ [ 1 . 0 ] " ) ; 
 + } ) ; 
 + } 
 + } 
 + 
 + public static void assertContainsSameToString ( Collection < ? > c1 , Collection < String > expected ) 
 + { 
 + Collection < String > transformedToString = Collections2 . transform ( c1 , Functions . toStringFunction ( ) ) ; 
 + assertContainsSame ( transformedToString , expected ) ; 
 + } 
 + 
 + public static < T > void assertContainsSame ( Collection < T > c1 , Collection < T > c2 ) 
 + { 
 + if ( ! c1 . containsAll ( c2 ) | | ! c2 . containsAll ( c1 ) ) 
 + { 
 + fail ( c1 + " does not contain the same as " + c2 ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / fml / . settings / org . eclipse . ltk . core . refactoring . prefs b / fml / . settings / org . eclipse . ltk . core . refactoring . prefs 
 new file mode 100644 
 index 0000000 . . b196c64 
 - - - / dev / null 
 + + + b / fml / . settings / org . eclipse . ltk . core . refactoring . prefs 
 @ @ - 0 , 0 + 1 , 2 @ @ 
 + eclipse . preferences . version = 1 
 + org . eclipse . ltk . core . refactoring . enable . project . refactoring . history = false 
 diff - - git a / fml / . settings / org . eclipse . m2e . core . prefs b / fml / . settings / org . eclipse . m2e . core . prefs 
 new file mode 100644 
 index 0000000 . . f897a7f 
 - - - / dev / null 
 + + + b / fml / . settings / org . eclipse . m2e . core . prefs 
 @ @ - 0 , 0 + 1 , 4 @ @ 
 + activeProfiles = 
 + eclipse . preferences . version = 1 
 + resolveWorkspaceProjects = true 
 + version = 1 
 diff - - git a / fml / common / cpw / mods / fml / common / FMLModContainer . java b / fml / common / cpw / mods / fml / common / FMLModContainer . java 
 index 77184e7 . . c33b911 100644 
 - - - a / fml / common / cpw / mods / fml / common / FMLModContainer . java 
 + + + b / fml / common / cpw / mods / fml / common / FMLModContainer . java 
 @ @ - 18 , 8 + 18 , 16 @ @ import java . util . List ; 
 public class FMLModContainer implements ModContainer { 
 private Mod modDescriptor ; 
 private Object modInstance ; 
 + private String source ; 
 
 + public FMLModContainer ( String source ) { 
 + this . source = source ; 
 + } 
 + 
 public FMLModContainer ( Class < ? > clazz ) { 
 + if ( clazz = = null ) { 
 + return ; 
 + } 
 modDescriptor = clazz . getAnnotation ( Mod . class ) ; 
 
 try { 
 @ @ - 86 , 8 + 94 , 7 @ @ public class FMLModContainer implements ModContainer { 
 
 @ Override 
 public String getSource ( ) { 
 - / / TODO Auto - generated method stub 
 - return null ; 
 + return source ; 
 } 
 
 @ Override 
 @ @ - 189 , 4 + 196 , 11 @ @ public class FMLModContainer implements ModContainer { 
 return new ArrayList < String > ( 0 ) ; 
 } 
 
 + / * ( non - Javadoc ) 
 + * @ see java . lang . Object # toString ( ) 
 + * / 
 + @ Override 
 + public String toString ( ) { 
 + return getSource ( ) ; 
 + } 
 } 
 diff - - git a / fml / common / cpw / mods / fml / common / Loader . java b / fml / common / cpw / mods / fml / common / Loader . java 
 index 8ca6b7c . . 9cbad60 100644 
 - - - a / fml / common / cpw / mods / fml / common / Loader . java 
 + + + b / fml / common / cpw / mods / fml / common / Loader . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import java . util . regex . Pattern ; 
 import java . util . zip . ZipEntry ; 
 import java . util . zip . ZipFile ; 
 
 + import cpw . mods . fml . common . toposort . ModSorter ; 
 import cpw . mods . fml . server . FMLHandler ; 
 
 public class Loader { 
 @ @ - 78 , 6 + 79 , 7 @ @ public class Loader { 
 } 
 
 private void sortModList ( ) { 
 + log . fine ( " Verifying mod dependencies are satisfied " ) ; 
 for ( ModContainer mod : mods ) { 
 if ( ! namedMods . keySet ( ) . containsAll ( mod . getDependencies ( ) ) ) { 
 log . severe ( String . format ( " The mod % s requires mods % s to be available , one or more are not " , mod . getName ( ) , mod . getDependencies ( ) ) ) ; 
 @ @ - 86 , 6 + 88 , 17 @ @ public class Loader { 
 throw new LoaderException ( ) ; 
 } 
 } 
 + log . fine ( " All dependencies are satisfied " ) ; 
 + ModSorter sorter = new ModSorter ( mods , namedMods ) ; 
 + try { 
 + log . fine ( " Sorting mods into an ordered list " ) ; 
 + mods = sorter . sort ( ) ; 
 + log . fine ( String . format ( " Mod list sorted % s " , mods ) ) ; 
 + } catch ( IllegalArgumentException iae ) { 
 + log . severe ( " A dependency cycle was detected in the input mod set so they cannot load them in order " ) ; 
 + log . throwing ( " Loader " , " sortModList " , iae ) ; 
 + throw new LoaderException ( iae ) ; 
 + } 
 } 
 
 private void preModInit ( ) { 
 diff - - git a / fml / common / cpw / mods / fml / common / toposort / ModSorter . java b / fml / common / cpw / mods / fml / common / toposort / ModSorter . java 
 new file mode 100644 
 index 0000000 . . 5115fb4 
 - - - / dev / null 
 + + + b / fml / common / cpw / mods / fml / common / toposort / ModSorter . java 
 @ @ - 0 , 0 + 1 , 93 @ @ 
 + / * 
 + * The FML Forge Mod Loader suite . Copyright ( C ) 2012 cpw 
 + * 
 + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 + * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package cpw . mods . fml . common . toposort ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + 
 + import cpw . mods . fml . common . FMLModContainer ; 
 + import cpw . mods . fml . common . ModContainer ; 
 + import cpw . mods . fml . common . toposort . TopologicalSort . DirectedGraph ; 
 + 
 + / * * 
 + * @ author cpw 
 + * 
 + * / 
 + public class ModSorter { 
 + private DirectedGraph < ModContainer > modGraph ; 
 + 
 + private ModContainer beforeAll = new FMLModContainer ( " DummyBeforeAll " ) ; 
 + private ModContainer afterAll = new FMLModContainer ( " DummyAfterAll " ) ; 
 + private ModContainer before = new FMLModContainer ( " DummyBefore " ) ; 
 + private ModContainer after = new FMLModContainer ( " DummyAfter " ) ; 
 + 
 + public ModSorter ( List < ModContainer > modList , Map < String , ModContainer > nameLookup ) { 
 + buildGraph ( modList , nameLookup ) ; 
 + } 
 + 
 + private void buildGraph ( List < ModContainer > modList , Map < String , ModContainer > nameLookup ) { 
 + modGraph = new DirectedGraph < ModContainer > ( ) ; 
 + modGraph . addNode ( beforeAll ) ; 
 + modGraph . addNode ( before ) ; 
 + modGraph . addNode ( afterAll ) ; 
 + modGraph . addNode ( after ) ; 
 + 
 + modGraph . addEdge ( before , after ) ; 
 + modGraph . addEdge ( beforeAll , before ) ; 
 + modGraph . addEdge ( after , afterAll ) ; 
 + for ( ModContainer mod : modList ) { 
 + modGraph . addNode ( mod ) ; 
 + } 
 + for ( ModContainer mod : modList ) { 
 + boolean preDepAdded = false ; 
 + boolean postDepAdded = false ; 
 + for ( String dep : mod . getPreDepends ( ) ) { 
 + preDepAdded = true ; 
 + if ( dep . equals ( " * " ) ) { 
 + / / We are " after " everything 
 + modGraph . addEdge ( mod , afterAll ) ; 
 + modGraph . addEdge ( after , mod ) ; 
 + postDepAdded = true ; 
 + } else { 
 + modGraph . addEdge ( before , mod ) ; 
 + modGraph . addEdge ( nameLookup . get ( dep ) , mod ) ; 
 + } 
 + } 
 + for ( String dep : mod . getPostDepends ( ) ) { 
 + postDepAdded = true ; 
 + if ( dep . equals ( " * " ) ) { 
 + / / We are " before " everything 
 + modGraph . addEdge ( beforeAll , mod ) ; 
 + modGraph . addEdge ( mod , before ) ; 
 + preDepAdded = true ; 
 + } else { 
 + modGraph . addEdge ( mod , after ) ; 
 + modGraph . addEdge ( mod , nameLookup . get ( dep ) ) ; 
 + } 
 + } 
 + if ( ! preDepAdded ) { 
 + modGraph . addEdge ( before , mod ) ; 
 + } 
 + if ( ! postDepAdded ) { 
 + modGraph . addEdge ( mod , after ) ; 
 + } 
 + } 
 + } 
 + 
 + public List < ModContainer > sort ( ) { 
 + List < ModContainer > sortedList = TopologicalSort . topologicalSort ( modGraph ) ; 
 + sortedList . removeAll ( Arrays . asList ( new ModContainer [ ] { beforeAll , before , after , afterAll } ) ) ; 
 + return sortedList ; 
 + } 
 + } 
 diff - - git a / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java b / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java 
 new file mode 100644 
 index 0000000 . . 37b5bf2 
 - - - / dev / null 
 + + + b / fml / common / cpw / mods / fml / common / toposort / TopologicalSort . java 
 @ @ - 0 , 0 + 1 , 155 @ @ 
 + / * 
 + * The FML Forge Mod Loader suite . 
 + * Copyright ( C ) 2012 cpw 
 + * 
 + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 + * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package cpw . mods . fml . common . toposort ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . HashSet ; 
 + import java . util . Iterator ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . NoSuchElementException ; 
 + import java . util . Set ; 
 + 
 + / * * 
 + * Topological sort for mod loading 
 + * 
 + * Based on a variety of sources , including http : / / keithschwarz . com / interesting / code / ? dir = topological - sort 
 + * @ author cpw 
 + * 
 + * / 
 + public class TopologicalSort { 
 + public static class DirectedGraph < T > implements Iterable < T > { 
 + private final Map < T , Set < T > > graph = new HashMap < T , Set < T > > ( ) ; 
 + 
 + public boolean addNode ( T node ) { 
 + / / Ignore nodes already added 
 + if ( graph . containsKey ( node ) ) { 
 + return false ; 
 + } 
 + graph . put ( node , new HashSet < T > ( ) ) ; 
 + return true ; 
 + } 
 + 
 + public void addEdge ( T from , T to ) { 
 + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { 
 + throw new NoSuchElementException ( " Missing nodes from graph " ) ; 
 + } 
 + graph . get ( from ) . add ( to ) ; 
 + } 
 + 
 + public void removeEdge ( T from , T to ) { 
 + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { 
 + throw new NoSuchElementException ( " Missing nodes from graph " ) ; 
 + } 
 + graph . get ( from ) . remove ( to ) ; 
 + } 
 + 
 + public boolean edgeExists ( T from , T to ) { 
 + if ( ! ( graph . containsKey ( from ) & & graph . containsKey ( to ) ) ) { 
 + throw new NoSuchElementException ( " Missing nodes from graph " ) ; 
 + } 
 + return graph . get ( from ) . contains ( to ) ; 
 + } 
 + 
 + public Set < T > edgesFrom ( T from ) { 
 + if ( ! graph . containsKey ( from ) ) { 
 + throw new NoSuchElementException ( " Missing node from graph " ) ; 
 + } 
 + return Collections . unmodifiableSet ( graph . get ( from ) ) ; 
 + } 
 + @ Override 
 + public Iterator < T > iterator ( ) { 
 + return graph . keySet ( ) . iterator ( ) ; 
 + } 
 + 
 + public int size ( ) { 
 + return graph . size ( ) ; 
 + } 
 + 
 + public boolean isEmpty ( ) { 
 + return graph . isEmpty ( ) ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) { 
 + return graph . toString ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Sort the input graph into a topologically sorted list 
 + * 
 + * Uses the reverse depth first search as outlined in . . . 
 + * @ param graph 
 + * @ return 
 + * / 
 + public static < T > List < T > topologicalSort ( DirectedGraph < T > graph ) { 
 + DirectedGraph < T > rGraph = reverse ( graph ) ; 
 + 
 + List < T > sortedResult = new ArrayList < T > ( ) ; 
 + Set < T > visitedNodes = new HashSet < T > ( ) ; 
 + 
 + / / A list of " fully explored " nodes . Leftovers in here indicate cycles in the graph 
 + Set < T > expandedNodes = new HashSet < T > ( ) ; 
 + 
 + for ( T node : rGraph ) { 
 + explore ( node , rGraph , sortedResult , visitedNodes , expandedNodes ) ; 
 + } 
 + 
 + return sortedResult ; 
 + } 
 + 
 + public static < T > DirectedGraph < T > reverse ( DirectedGraph < T > graph ) { 
 + DirectedGraph < T > result = new DirectedGraph < T > ( ) ; 
 + for ( T node : graph ) { 
 + result . addNode ( node ) ; 
 + } 
 + for ( T from : graph ) { 
 + for ( T to : graph . edgesFrom ( from ) ) { 
 + result . addEdge ( to , from ) ; 
 + } 
 + } 
 + 
 + return result ; 
 + } 
 + 
 + public static < T > void explore ( T node , DirectedGraph < T > graph , List < T > sortedResult , Set < T > visitedNodes , Set < T > expandedNodes ) { 
 + / / Have we been here before ? 
 + if ( visitedNodes . contains ( node ) ) { 
 + / / And have completed this node before 
 + if ( expandedNodes . contains ( node ) ) { 
 + / / Then we ' re fine 
 + return ; 
 + } 
 + System . out . printf ( " % s : % s \ n % s \ n % s \ n " , node , sortedResult , visitedNodes , expandedNodes ) ; 
 + throw new IllegalArgumentException ( " There was a cycle detected in the input graph , sorting is not possible " ) ; 
 + } 
 + 
 + / / Visit this node 
 + visitedNodes . add ( node ) ; 
 + 
 + / / Recursively explore inbound edges 
 + for ( T inbound : graph . edgesFrom ( node ) ) { 
 + explore ( inbound , graph , sortedResult , visitedNodes , expandedNodes ) ; 
 + } 
 + 
 + / / Add ourselves now 
 + sortedResult . add ( node ) ; 
 + 
 + / / And mark ourselves as explored 
 + expandedNodes . add ( node ) ; 
 + } 
 + } 
 diff - - git a / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java b / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java 
 index 8c57058 . . 922e4f8 100644 
 - - - a / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java 
 + + + b / fml / server / cpw / mods / fml / server / ModLoaderModContainer . java 
 @ @ - 14 , 7 + 14 , 6 @ @ 
 package cpw . mods . fml . server ; 
 
 import java . util . ArrayList ; 
 - import java . util . Collections ; 
 import java . util . List ; 
 import java . util . StringTokenizer ; 
 
 @ @ - 32 , 6 + 31 , 9 @ @ public class ModLoaderModContainer implements ModContainer { 
 private BaseMod mod ; 
 private boolean isTicking ; 
 private String modSource ; 
 + private ArrayList < String > dependencies ; 
 + private ArrayList < String > preDependencies ; 
 + private ArrayList < String > postDependencies ; 
 public ModLoaderModContainer ( Class < ? extends BaseMod > modClazz , String modSource ) { 
 this . modClazz = modClazz ; 
 this . modSource = modSource ; 
 @ @ - 174 , 15 + 176 , 13 @ @ public class ModLoaderModContainer implements ModContainer { 
 public ICraftingHandler getCraftingHandler ( ) { 
 return mod ; 
 } 
 - 
 - / * ( non - Javadoc ) 
 - * @ see cpw . mods . fml . common . ModContainer # getDependencies ( ) 
 - * / 
 - @ Override 
 - public List < String > getDependencies ( ) { 
 - ArrayList < String > dependencies = new ArrayList < String > ( 10 ) ; 
 + 
 + private void computeDependencies ( ) { 
 + dependencies = new ArrayList < String > ( ) ; 
 + preDependencies = new ArrayList < String > ( ) ; 
 + postDependencies = new ArrayList < String > ( ) ; 
 if ( mod . getPriorities ( ) = = null | | mod . getPriorities ( ) . length ( ) = = 0 ) { 
 - return dependencies ; 
 + return ; 
 } 
 StringTokenizer st = new StringTokenizer ( mod . getPriorities ( ) , " ; " ) ; 
 for ( ; st . hasMoreTokens ( ) ; ) { 
 @ @ - 194 , 19 + 194 , 44 @ @ public class ModLoaderModContainer implements ModContainer { 
 if ( " required - before " . equals ( depparts [ 0 ] ) | | " required - after " . equals ( depparts [ 0 ] ) ) { 
 dependencies . add ( depparts [ 1 ] ) ; 
 } 
 + 
 + if ( " required - before " . equals ( depparts [ 0 ] ) | | " before " . equals ( depparts [ 0 ] ) ) { 
 + preDependencies . add ( depparts [ 1 ] ) ; 
 + } 
 + 
 + if ( " required - after " . equals ( depparts [ 0 ] ) | | " after " . equals ( depparts [ 0 ] ) ) { 
 + postDependencies . add ( depparts [ 1 ] ) ; 
 + } 
 + } 
 + } 
 + / * ( non - Javadoc ) 
 + * @ see cpw . mods . fml . common . ModContainer # getDependencies ( ) 
 + * / 
 + @ Override 
 + public List < String > getDependencies ( ) { 
 + if ( dependencies = = null ) { 
 + computeDependencies ( ) ; 
 } 
 return dependencies ; 
 } 
 
 @ Override 
 public List < String > getPreDepends ( ) { 
 - / / TODO Auto - generated method stub 
 - return null ; 
 + if ( dependencies = = null ) { 
 + computeDependencies ( ) ; 
 + } 
 + return preDependencies ; 
 } 
 
 @ Override 
 public List < String > getPostDepends ( ) { 
 - / / TODO Auto - generated method stub 
 - return null ; 
 + if ( dependencies = = null ) { 
 + computeDependencies ( ) ; 
 + } 
 + return postDependencies ; 
 + } 
 + 
 + public String toString ( ) { 
 + return modSource ; 
 } 
 } 
 diff - - git a / fml / test / cpw / mods / fml / test / LoaderTests . java b / fml / test / cpw / mods / fml / test / LoaderTests . java 
 new file mode 100644 
 index 0000000 . . 28e1b41 
 - - - / dev / null 
 + + + b / fml / test / cpw / mods / fml / test / LoaderTests . java 
 @ @ - 0 , 0 + 1 , 214 @ @ 
 + / * 
 + * The FML Forge Mod Loader suite . 
 + * Copyright ( C ) 2012 cpw 
 + * 
 + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 + * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package cpw . mods . fml . test ; 
 + 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + 
 + import net . minecraft . src . BaseMod ; 
 + 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Test ; 
 + import static org . junit . Assert . * ; 
 + 
 + import cpw . mods . fml . common . ModContainer ; 
 + import cpw . mods . fml . common . toposort . ModSorter ; 
 + import cpw . mods . fml . server . ModLoaderModContainer ; 
 + 
 + 
 + public class LoaderTests { 
 + 
 + private ModContainer mc1 ; 
 + private ModContainer mc2 ; 
 + private ModContainer mc3 ; 
 + private ModContainer mc4 ; 
 + private ModContainer mc5 ; 
 + private ModContainer mc6 ; 
 + private ModContainer mc7 ; 
 + private ModContainer mc8 ; 
 + 
 + @ Before 
 + public void setUp ( ) throws Exception { 
 + mc1 = new ModLoaderModContainer ( Mod1 . class , " Test1 " ) ; 
 + mc1 . preInit ( ) ; 
 + mc2 = new ModLoaderModContainer ( Mod2 . class , " Test2 " ) ; 
 + mc2 . preInit ( ) ; 
 + mc3 = new ModLoaderModContainer ( Mod3 . class , " Test3 " ) ; 
 + mc3 . preInit ( ) ; 
 + mc4 = new ModLoaderModContainer ( Mod4 . class , " Test4 " ) ; 
 + mc4 . preInit ( ) ; 
 + mc5 = new ModLoaderModContainer ( Mod5 . class , " Test5 " ) ; 
 + mc5 . preInit ( ) ; 
 + mc6 = new ModLoaderModContainer ( Mod5 . class , " Test6 " ) ; 
 + mc6 . preInit ( ) ; 
 + mc7 = new ModLoaderModContainer ( Mod5 . class , " Test7 " ) ; 
 + mc7 . preInit ( ) ; 
 + mc8 = new ModLoaderModContainer ( Mod5 . class , " Test8 " ) ; 
 + mc8 . preInit ( ) ; 
 + } 
 + 
 + @ After 
 + public void tearDown ( ) throws Exception { 
 + } 
 + 
 + @ Test 
 + public void testModSorting ( ) { 
 + HashMap < String , ModContainer > modList = new HashMap < String , ModContainer > ( ) ; 
 + modList . put ( " Mod1 " , mc1 ) ; 
 + modList . put ( " Mod2 " , mc2 ) ; 
 + modList . put ( " Mod3 " , mc3 ) ; 
 + modList . put ( " Mod4 " , mc4 ) ; 
 + modList . put ( " Mod5 " , mc5 ) ; 
 + modList . put ( " Mod6 " , mc6 ) ; 
 + modList . put ( " Mod7 " , mc7 ) ; 
 + modList . put ( " Mod8 " , mc8 ) ; 
 + ModSorter ms = new ModSorter ( Collections . list ( Collections . enumeration ( modList . values ( ) ) ) , modList ) ; 
 + List < ModContainer > mods = ms . sort ( ) ; 
 + assertEquals ( " Eight mods " , 8 , mods . size ( ) ) ; 
 + System . out . printf ( " % s \ n " , mods ) ; 
 + } 
 + 
 + @ Test 
 + public void testModPrioritiesParsing ( ) { 
 + / / Mod 1 
 + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; 
 + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; 
 + 
 + / / Mod 2 
 + assertTrue ( " Empty hard dependencies for Mod2 " , mc2 . getDependencies ( ) . isEmpty ( ) ) ; 
 + assertTrue ( " Mod2 postdepends on * " , mc1 . getPostDepends ( ) . contains ( " * " ) ) ; 
 + 
 + / / Mod 3 
 + assertEquals ( " Two hard dependencies for Mod3 " , 2 , mc1 . getDependencies ( ) . size ( ) ) ; 
 + assertTrue ( " Hard dependencies for Mod3 contains Mod4 " , mc1 . getDependencies ( ) . contains ( " Mod4 " ) ) ; 
 + assertTrue ( " Hard dependencies for Mod3 contains Mod2 " , mc1 . getDependencies ( ) . contains ( " Mod2 " ) ) ; 
 + assertEquals ( " One pre depends for Mod3 " , 1 , mc1 . getPreDepends ( ) . size ( ) ) ; 
 + assertEquals ( " One post depends for Mod3 " , 1 , mc1 . getPostDepends ( ) . size ( ) ) ; 
 + 
 + / / Mod 4 
 + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; 
 + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; 
 + 
 + / / Mod 5 
 + assertTrue ( " Empty hard dependencies for Mod1 " , mc1 . getDependencies ( ) . isEmpty ( ) ) ; 
 + assertTrue ( " Mod1 predepends on * " , mc1 . getPreDepends ( ) . contains ( " * " ) ) ; 
 + } 
 + 
 + public static class Mod1 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " before : * " ; 
 + } 
 + } 
 + public static class Mod2 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " after : * " ; 
 + } 
 + } 
 + public static class Mod3 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " required - before : Mod4 ; required - after : Mod5 " ; 
 + } 
 + } 
 + public static class Mod4 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " required - before : Mod2 ; after : Mod3 ; required - after : Mod1 " ; 
 + } 
 + } 
 + public static class Mod5 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " " ; 
 + } 
 + } 
 + public static class Mod6 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " " ; 
 + } 
 + } 
 + public static class Mod7 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " " ; 
 + } 
 + } 
 + public static class Mod8 extends BaseMod { 
 + @ Override 
 + public String getVersion ( ) { 
 + return null ; 
 + } 
 + @ Override 
 + public void load ( ) { 
 + } 
 + @ Override 
 + public String getPriorities ( ) { 
 + return " before : Mod7 " ; 
 + } 
 + } 
 + } 
 diff - - git a / fml / test / fml / test / LoaderTests . java b / fml / test / fml / test / LoaderTests . java 
 deleted file mode 100644 
 index 8330e88 . . 0000000 
 - - - a / fml / test / fml / test / LoaderTests . java 
 + + + / dev / null 
 @ @ - 1 , 37 + 0 , 0 @ @ 
 - / * 
 - * The FML Forge Mod Loader suite . 
 - * Copyright ( C ) 2012 cpw 
 - * 
 - * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 - * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 - * 
 - * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 - * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 - * 
 - * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 - * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 - * / 
 - package fml . test ; 
 - 
 - import org . junit . After ; 
 - import org . junit . Before ; 
 - import org . junit . Test ; 
 - 
 - import cpw . mods . fml . common . Loader ; 
 - 
 - 
 - public class LoaderTests { 
 - 
 - @ Before 
 - public void setUp ( ) throws Exception { 
 - } 
 - 
 - @ After 
 - public void tearDown ( ) throws Exception { 
 - } 
 - 
 - @ Test 
 - public void testModLoading ( ) { 
 - Loader . instance ( ) . loadMods ( ) ; 
 - } 
 - }
