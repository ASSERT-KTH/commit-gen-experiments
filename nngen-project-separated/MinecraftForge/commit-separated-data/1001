BLEU SCORE: 0.05693025330278466

TEST MSG: Fixed perspective transformations for item models .
GENERATED MSG: Techne model loader ( incomplete for debugging )

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / Attributes . java b / src / main / java / net / minecraftforge / client / model / Attributes . java <nl> index 8baf244 . . 4544930 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / Attributes . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / Attributes . java <nl> @ @ - 1 , 8 + 1 , 12 @ @ <nl> package net . minecraftforge . client . model ; <nl> <nl> import java . nio . ByteBuffer ; <nl> + import java . util . Arrays ; <nl> import java . util . List ; <nl> <nl> + import javax . vecmath . Vector4f ; <nl> + <nl> + import net . minecraft . client . renderer . block . model . BakedQuad ; <nl> import net . minecraft . client . renderer . vertex . VertexFormat ; <nl> import net . minecraft . client . renderer . vertex . VertexFormatElement ; <nl> import net . minecraft . client . renderer . vertex . VertexFormatElement . EnumType ; <nl> @ @ - 104 , 4 + 108 , 33 @ @ public class Attributes <nl> } <nl> } <nl> } <nl> + <nl> + public static BakedQuad transform ( TRSRTransformation transform , BakedQuad quad , VertexFormat format ) <nl> + { <nl> + for ( VertexFormatElement e : ( List < VertexFormatElement > ) format . getElements ( ) ) <nl> + { <nl> + if ( e . getUsage ( ) = = VertexFormatElement . EnumUsage . POSITION ) <nl> + { <nl> + if ( e . getType ( ) ! = VertexFormatElement . EnumType . FLOAT ) <nl> + { <nl> + throw new IllegalArgumentException ( " can only transform float position " ) ; <nl> + } <nl> + int [ ] data = Arrays . copyOf ( quad . getVertexData ( ) , quad . getVertexData ( ) . length ) ; <nl> + float [ ] pos = new float [ ] { 0f , 0f , 0f , 1f } ; <nl> + for ( int i = 0 ; i < Math . min ( 4 , e . getElementCount ( ) ) ; i + + ) <nl> + { <nl> + pos [ i ] = Float . intBitsToFloat ( data [ e . getOffset ( ) / 4 + i ] ) ; <nl> + } <nl> + Vector4f vec = new Vector4f ( pos ) ; <nl> + transform . getMatrix ( ) . transform ( vec ) ; <nl> + vec . get ( pos ) ; <nl> + for ( int i = 0 ; i < Math . min ( 4 , e . getElementCount ( ) ) ; i + + ) <nl> + { <nl> + data [ e . getOffset ( ) / 4 + i ] = Float . floatToRawIntBits ( pos [ i ] ) ; <nl> + } <nl> + return new BakedQuad ( data , quad . getTintIndex ( ) , quad . getFace ( ) ) ; <nl> + } <nl> + } <nl> + return quad ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / IPerspectiveAwareModel . java b / src / main / java / net / minecraftforge / client / model / IPerspectiveAwareModel . java <nl> index 930437b . . cb10dc9 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / IPerspectiveAwareModel . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / IPerspectiveAwareModel . java <nl> @ @ - 2 , 12 + 2 , 11 @ @ package net . minecraftforge . client . model ; <nl> <nl> import javax . vecmath . Matrix4f ; <nl> <nl> - import org . apache . commons . lang3 . tuple . Pair ; <nl> - <nl> - import net . minecraft . item . ItemStack ; <nl> import net . minecraft . client . renderer . block . model . ItemCameraTransforms . TransformType ; <nl> import net . minecraft . client . resources . model . IBakedModel ; <nl> <nl> + import org . apache . commons . lang3 . tuple . Pair ; <nl> + <nl> / * <nl> * Model that changes based on the rendering perspective <nl> * ( first - person , GUI , e . t . c - see TransformType ) <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / IPerspectiveState . java b / src / main / java / net / minecraftforge / client / model / IPerspectiveState . java <nl> new file mode 100644 <nl> index 0000000 . . ca9d25d <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / client / model / IPerspectiveState . java <nl> @ @ - 0 , 0 + 1 , 58 @ @ <nl> + package net . minecraftforge . client . model ; <nl> + <nl> + import java . util . Map ; <nl> + <nl> + import net . minecraft . client . renderer . block . model . ItemCameraTransforms ; <nl> + import net . minecraft . client . renderer . block . model . ItemCameraTransforms . TransformType ; <nl> + <nl> + import com . google . common . collect . ImmutableMap ; <nl> + import com . google . common . collect . Maps ; <nl> + <nl> + / * * <nl> + * IModelState that can change depending on the perspective . <nl> + * / <nl> + public interface IPerspectiveState extends IModelState <nl> + { <nl> + / * * <nl> + * @ return the additional state that needs to be applied for each part when in given perspective type . <nl> + * / <nl> + public IModelState forPerspective ( TransformType type ) ; <nl> + <nl> + public static class Impl implements IPerspectiveState <nl> + { <nl> + private final IModelState parent ; <nl> + private final ImmutableMap < TransformType , IModelState > states ; <nl> + <nl> + public Impl ( IModelState parent , ImmutableMap < TransformType , IModelState > states ) <nl> + { <nl> + this . parent = parent ; <nl> + this . states = states ; <nl> + } <nl> + <nl> + public Impl ( IModelState parent , ItemCameraTransforms transforms ) <nl> + { <nl> + this ( parent , getMap ( transforms ) ) ; <nl> + } <nl> + <nl> + private static ImmutableMap < TransformType , IModelState > getMap ( ItemCameraTransforms transforms ) <nl> + { <nl> + Map < TransformType , IModelState > map = Maps . newHashMap ( ) ; <nl> + map . put ( TransformType . NONE , TRSRTransformation . identity ( ) ) ; <nl> + map . put ( TransformType . THIRD _ PERSON , transforms . thirdPerson ) ; <nl> + map . put ( TransformType . FIRST _ PERSON , transforms . firstPerson ) ; <nl> + map . put ( TransformType . GUI , transforms . gui ) ; <nl> + map . put ( TransformType . HEAD , transforms . head ) ; <nl> + return Maps . immutableEnumMap ( map ) ; <nl> + } <nl> + <nl> + public TRSRTransformation apply ( IModelPart part ) <nl> + { <nl> + return parent . apply ( part ) ; <nl> + } <nl> + <nl> + public IModelState forPerspective ( TransformType type ) <nl> + { <nl> + return states . getOrDefault ( type , TRSRTransformation . identity ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / ItemLayerModel . java b / src / main / java / net / minecraftforge / client / model / ItemLayerModel . java <nl> index 4276430 . . d80d81b 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / ItemLayerModel . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / ItemLayerModel . java <nl> @ @ - 4 , 27 + 4 , 35 @ @ import java . nio . ByteBuffer ; <nl> import java . util . Arrays ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> + import java . util . Map ; <nl> + <nl> + import javax . vecmath . Matrix4f ; <nl> <nl> import net . minecraft . client . renderer . block . model . BakedQuad ; <nl> import net . minecraft . client . renderer . block . model . ItemCameraTransforms ; <nl> + import net . minecraft . client . renderer . block . model . ItemCameraTransforms . TransformType ; <nl> import net . minecraft . client . renderer . block . model . ModelBlock ; <nl> import net . minecraft . client . renderer . texture . TextureAtlasSprite ; <nl> import net . minecraft . client . renderer . vertex . VertexFormat ; <nl> import net . minecraft . client . renderer . vertex . VertexFormatElement ; <nl> import net . minecraft . client . resources . IResourceManager ; <nl> + import net . minecraft . client . resources . model . IBakedModel ; <nl> import net . minecraft . util . EnumFacing ; <nl> import net . minecraft . util . ResourceLocation ; <nl> - import net . minecraftforge . fml . common . FMLLog ; <nl> <nl> + import org . apache . commons . lang3 . tuple . Pair ; <nl> import org . lwjgl . BufferUtils ; <nl> <nl> import com . google . common . base . Function ; <nl> import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . ImmutableMap ; <nl> + import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . Maps ; <nl> <nl> public class ItemLayerModel implements IRetexturableModel { <nl> <nl> public static final ItemLayerModel instance = new ItemLayerModel ( ImmutableList . < ResourceLocation > of ( ) ) ; <nl> + <nl> private final ImmutableList < ResourceLocation > textures ; <nl> <nl> public ItemLayerModel ( ImmutableList < ResourceLocation > textures ) <nl> @ @ - 75 , 29 + 83 , 53 @ @ public class ItemLayerModel implements IRetexturableModel { <nl> return new ItemLayerModel ( builder . build ( ) ) ; <nl> } <nl> <nl> - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> + public IFlexibleBakedModel bake ( IModelState state , final VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> { <nl> ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; <nl> + final TRSRTransformation transform = state . apply ( this ) ; <nl> for ( int i = 0 ; i < textures . size ( ) ; i + + ) <nl> { <nl> TextureAtlasSprite sprite = bakedTextureGetter . apply ( textures . get ( i ) ) ; <nl> - builder . addAll ( getQuadsForSprite ( i , sprite , format ) ) ; <nl> + builder . addAll ( Iterables . transform ( getQuadsForSprite ( i , sprite , format ) , new Function < BakedQuad , BakedQuad > ( ) <nl> + { <nl> + public BakedQuad apply ( BakedQuad input ) <nl> + { <nl> + return Attributes . transform ( transform , input , format ) ; <nl> + } <nl> + } ) ) ; <nl> } <nl> TextureAtlasSprite particle = bakedTextureGetter . apply ( textures . isEmpty ( ) ? new ResourceLocation ( " missingno " ) : textures . get ( 0 ) ) ; <nl> + if ( state instanceof IPerspectiveState ) <nl> + { <nl> + IPerspectiveState ps = ( IPerspectiveState ) state ; <nl> + Map < TransformType , TRSRTransformation > map = Maps . newHashMap ( ) ; <nl> + for ( TransformType type : TransformType . values ( ) ) <nl> + { <nl> + map . put ( type , ps . forPerspective ( type ) . apply ( this ) ) ; <nl> + } <nl> + return new BakedModel ( builder . build ( ) , particle , format , Maps . immutableEnumMap ( map ) ) ; <nl> + } <nl> return new BakedModel ( builder . build ( ) , particle , format ) ; <nl> } <nl> <nl> - public static class BakedModel implements IFlexibleBakedModel <nl> + public static class BakedModel implements IFlexibleBakedModel , IPerspectiveAwareModel <nl> { <nl> private final ImmutableList < BakedQuad > quads ; <nl> private final TextureAtlasSprite particle ; <nl> private final VertexFormat format ; <nl> + private final ImmutableMap < TransformType , TRSRTransformation > transforms ; <nl> <nl> public BakedModel ( ImmutableList < BakedQuad > quads , TextureAtlasSprite particle , VertexFormat format ) <nl> { <nl> + this ( quads , particle , format , ImmutableMap . < TransformType , TRSRTransformation > of ( ) ) ; <nl> + } <nl> + <nl> + public BakedModel ( ImmutableList < BakedQuad > quads , TextureAtlasSprite particle , VertexFormat format , ImmutableMap < TransformType , TRSRTransformation > transforms ) <nl> + { <nl> this . quads = quads ; <nl> this . particle = particle ; <nl> this . format = format ; <nl> + this . transforms = transforms ; <nl> } <nl> <nl> public boolean isAmbientOcclusion ( ) { return true ; } <nl> @ @ - 108 , 9 + 140 , 17 @ @ public class ItemLayerModel implements IRetexturableModel { <nl> public List < BakedQuad > getFaceQuads ( EnumFacing side ) { return ImmutableList . of ( ) ; } <nl> public List < BakedQuad > getGeneralQuads ( ) { return quads ; } <nl> public VertexFormat getFormat ( ) { return format ; } <nl> + <nl> + @ Override <nl> + public Pair < IBakedModel , Matrix4f > handlePerspective ( TransformType cameraTransformType ) <nl> + { <nl> + TRSRTransformation tr = transforms . getOrDefault ( cameraTransformType , TRSRTransformation . identity ( ) ) ; <nl> + Matrix4f mat = tr = = TRSRTransformation . identity ( ) ? null : tr . getMatrix ( ) ; <nl> + return Pair . of ( ( IBakedModel ) this , mat ) ; <nl> + } <nl> } <nl> <nl> - public static final ImmutableList < BakedQuad > getQuadsForSprite ( int tint , TextureAtlasSprite sprite , VertexFormat format ) <nl> + public ImmutableList < BakedQuad > getQuadsForSprite ( int tint , TextureAtlasSprite sprite , VertexFormat format ) <nl> { <nl> ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; <nl> <nl> @ @ - 131 , 7 + 171 , 7 @ @ public class ItemLayerModel implements IRetexturableModel { <nl> ptu = true ; <nl> for ( int u = 0 ; u < uMax ; u + + ) <nl> { <nl> - boolean t = ( pixels [ u + ( vMax - 1 - v ) * uMax ] > > 24 & 0xFF ) = = 0 ; <nl> + boolean t = isTransparent ( pixels , uMax , vMax , u , v ) ; <nl> if ( ptu & & ! t ) / / left - transparent , right - opaque <nl> { <nl> builder . add ( buildSideQuad ( buf , format , EnumFacing . WEST , tint , sprite , u , v ) ) ; <nl> @ @ - 182 , 6 + 222 , 11 @ @ public class ItemLayerModel implements IRetexturableModel { <nl> return builder . build ( ) ; <nl> } <nl> <nl> + protected boolean isTransparent ( int [ ] pixels , int uMax , int vMax , int u , int v ) <nl> + { <nl> + return ( pixels [ u + ( vMax - 1 - v ) * uMax ] > > 24 & 0xFF ) = = 0 ; <nl> + } <nl> + <nl> private static BakedQuad buildSideQuad ( ByteBuffer buf , VertexFormat format , EnumFacing side , int tint , TextureAtlasSprite sprite , int u , int v ) <nl> { <nl> float x0 = ( float ) u / sprite . getIconWidth ( ) ; <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> index 2327d5b . . db598fd 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> @ @ - 320 , 10 + 320 , 11 @ @ public class ModelLoader extends ModelBakery <nl> throw new IllegalArgumentException ( " can ' t bake vanilla models to the format that doesn ' t fit into the default one : " + format ) ; <nl> } <nl> ModelBlock model = this . model ; <nl> - if ( hasItemModel ( model ) ) return new ItemLayerModel ( model ) . bake ( state , format , bakedTextureGetter ) ; / / model = makeItemModel ( model ) ; <nl> if ( model = = null ) return getMissingModel ( ) . bake ( state , format , bakedTextureGetter ) ; <nl> - if ( isCustomRenderer ( model ) ) return new IFlexibleBakedModel . Wrapper ( new BuiltInModel ( new ItemCameraTransforms ( model . getThirdPersonTransform ( ) , model . getFirstPersonTransform ( ) , model . getHeadTransform ( ) , model . getInGuiTransform ( ) ) ) , Attributes . DEFAULT _ BAKED _ FORMAT ) ; <nl> - return new IFlexibleBakedModel . Wrapper ( bakeModel ( model , state . apply ( this ) , state instanceof UVLock ) , Attributes . DEFAULT _ BAKED _ FORMAT ) ; <nl> + ItemCameraTransforms transforms = new ItemCameraTransforms ( model . getThirdPersonTransform ( ) , model . getFirstPersonTransform ( ) , model . getHeadTransform ( ) , model . getInGuiTransform ( ) ) ; <nl> + if ( hasItemModel ( model ) ) return new ItemLayerModel ( model ) . bake ( new IPerspectiveState . Impl ( state , transforms ) , format , bakedTextureGetter ) ; <nl> + if ( isCustomRenderer ( model ) ) return new IFlexibleBakedModel . Wrapper ( new BuiltInModel ( transforms ) , format ) ; <nl> + return new IFlexibleBakedModel . Wrapper ( bakeModel ( model , state . apply ( this ) , state instanceof UVLock ) , format ) ; <nl> } <nl> <nl> public IModelState getDefaultState ( ) <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java b / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java <nl> index cd1eb84 . . ea53d8f 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java <nl> @ @ - 53 , 7 + 53 , 7 @ @ public class TRSRTransformation implements IModelState , ITransformation <nl> <nl> public TRSRTransformation ( ItemTransformVec3f transform ) <nl> { <nl> - this ( transform . translation , quatFromYXZ ( transform . rotation ) , transform . scale , null ) ; <nl> + this ( transform . translation , quatFromYXZDegrees ( transform . rotation ) , transform . scale , null ) ; <nl> } <nl> <nl> public TRSRTransformation ( ModelRotation rotation ) <nl> @ @ - 97 , 6 + 97 , 11 @ @ public class TRSRTransformation implements IModelState , ITransformation <nl> } <nl> } <nl> <nl> + public static Quat4f quatFromYXZDegrees ( Vector3f yxz ) <nl> + { <nl> + return quatFromYXZ ( ( float ) Math . toRadians ( yxz . y ) , ( float ) Math . toRadians ( yxz . x ) , ( float ) Math . toRadians ( yxz . z ) ) ; <nl> + } <nl> + <nl> public static Quat4f quatFromYXZ ( Vector3f yxz ) <nl> { <nl> return quatFromYXZ ( yxz . y , yxz . x , yxz . z ) ;
NEAREST DIFF (one line): diff - - git a / client / net / minecraftforge / client / model / AdvancedModelLoader . java b / client / net / minecraftforge / client / model / AdvancedModelLoader . java <nl> index d2e8882 . . b29ca1c 100644 <nl> - - - a / client / net / minecraftforge / client / model / AdvancedModelLoader . java <nl> + + + b / client / net / minecraftforge / client / model / AdvancedModelLoader . java <nl> @ @ - 6 , 6 + 6 , 7 @ @ import java . util . Collection ; <nl> import java . util . Map ; <nl> <nl> import net . minecraftforge . client . model . obj . ObjModelLoader ; <nl> + import net . minecraftforge . client . model . techne . TechneModelLoader ; <nl> <nl> import com . google . common . collect . Maps ; <nl> <nl> @ @ - 52 , 7 + 53 , 7 @ @ public class AdvancedModelLoader { <nl> FMLLog . severe ( " The resource name % s is not valid " , resourceName ) ; <nl> throw new IllegalArgumentException ( " The resource name is not valid " ) ; <nl> } <nl> - String suffix = resourceName . substring ( i ) ; <nl> + String suffix = resourceName . substring ( i + 1 ) ; <nl> IModelCustomLoader loader = instances . get ( suffix ) ; <nl> if ( loader = = null ) <nl> { <nl> @ @ - 78 , 5 + 79 , 6 @ @ public class AdvancedModelLoader { <nl> static <nl> { <nl> registerModelHandler ( new ObjModelLoader ( ) ) ; <nl> + registerModelHandler ( new TechneModelLoader ( ) ) ; <nl> } <nl> } <nl> diff - - git a / client / net / minecraftforge / client / model / techne / TechneModel . java b / client / net / minecraftforge / client / model / techne / TechneModel . java <nl> new file mode 100644 <nl> index 0000000 . . 4e55650 <nl> - - - / dev / null <nl> + + + b / client / net / minecraftforge / client / model / techne / TechneModel . java <nl> @ @ - 0 , 0 + 1 , 308 @ @ <nl> + package net . minecraftforge . client . model . techne ; <nl> + <nl> + import java . awt . image . BufferedImage ; <nl> + import java . io . ByteArrayInputStream ; <nl> + import java . io . File ; <nl> + import java . io . FileOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . net . URL ; <nl> + import java . util . Arrays ; <nl> + import java . util . HashMap ; <nl> + import java . util . LinkedHashMap ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . zip . ZipEntry ; <nl> + import java . util . zip . ZipException ; <nl> + import java . util . zip . ZipFile ; <nl> + import java . util . zip . ZipInputStream ; <nl> + <nl> + import javax . imageio . ImageIO ; <nl> + import javax . xml . parsers . DocumentBuilder ; <nl> + import javax . xml . parsers . DocumentBuilderFactory ; <nl> + import javax . xml . parsers . ParserConfigurationException ; <nl> + <nl> + import org . lwjgl . opengl . GL11 ; <nl> + import org . w3c . dom . Document ; <nl> + import org . w3c . dom . NamedNodeMap ; <nl> + import org . w3c . dom . Node ; <nl> + import org . w3c . dom . NodeList ; <nl> + import org . xml . sax . SAXException ; <nl> + <nl> + import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import cpw . mods . fml . relauncher . SideOnly ; <nl> + <nl> + import net . minecraft . client . Minecraft ; <nl> + import net . minecraft . client . model . ModelBase ; <nl> + import net . minecraft . client . model . ModelRenderer ; <nl> + import net . minecraft . client . renderer . RenderEngine ; <nl> + import net . minecraftforge . client . model . IModelCustom ; <nl> + import net . minecraftforge . client . model . ModelFormatException ; <nl> + <nl> + @ SideOnly ( Side . CLIENT ) <nl> + public class TechneModel extends ModelBase implements IModelCustom { <nl> + public static final List < String > cubeTypes = Arrays . asList ( <nl> + " d9e621f7 - 957f - 4b77 - b1ae - 20dcd0da7751 " , <nl> + " de81aa14 - bd60 - 4228 - 8d8d - 5238bcd3caaa " <nl> + ) ; <nl> + <nl> + private String fileName ; <nl> + private Map < String , byte [ ] > zipFile = new HashMap < String , byte [ ] > ( ) ; <nl> + <nl> + private Map < String , ModelRenderer > parts = new LinkedHashMap < String , ModelRenderer > ( ) ; <nl> + private String texture = null ; <nl> + private int textureName ; <nl> + private boolean textureNameSet = false ; <nl> + <nl> + public TechneModel ( String fileName , URL resource ) throws ModelFormatException <nl> + { <nl> + this . fileName = fileName ; <nl> + loadTechneModel ( resource ) ; <nl> + } <nl> + <nl> + private void loadTechneModel ( URL fileURL ) throws ModelFormatException <nl> + { <nl> + try <nl> + { <nl> + ZipInputStream zipInput = new ZipInputStream ( fileURL . openStream ( ) ) ; <nl> + <nl> + ZipEntry entry ; <nl> + while ( ( entry = zipInput . getNextEntry ( ) ) ! = null ) <nl> + { <nl> + byte [ ] data = new byte [ ( int ) entry . getSize ( ) ] ; <nl> + zipInput . read ( data ) ; <nl> + zipFile . put ( entry . getName ( ) , data ) ; <nl> + } <nl> + <nl> + byte [ ] modelXml = zipFile . get ( " model . xml " ) ; <nl> + if ( modelXml = = null ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " contains no model . xml file " ) ; <nl> + } <nl> + <nl> + DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; <nl> + DocumentBuilder documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; <nl> + Document document = documentBuilder . parse ( new ByteArrayInputStream ( modelXml ) ) ; <nl> + <nl> + NodeList nodeListTechne = document . getElementsByTagName ( " Techne " ) ; <nl> + if ( nodeListTechne . getLength ( ) < 1 ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " contains no Techne tag " ) ; <nl> + } <nl> + <nl> + NodeList nodeListModel = document . getElementsByTagName ( " Model " ) ; <nl> + if ( nodeListModel . getLength ( ) < 1 ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " contains no Model tag " ) ; <nl> + } <nl> + <nl> + NamedNodeMap modelAttributes = nodeListModel . item ( 0 ) . getAttributes ( ) ; <nl> + if ( modelAttributes = = null ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " contains a Model tag with no attributes " ) ; <nl> + } <nl> + <nl> + Node modelTexture = modelAttributes . getNamedItem ( " texture " ) ; <nl> + if ( modelTexture ! = null ) <nl> + { <nl> + texture = modelTexture . getTextContent ( ) ; <nl> + } <nl> + <nl> + NodeList shapes = document . getElementsByTagName ( " Shape " ) ; <nl> + for ( int i = 0 ; i < shapes . getLength ( ) ; i + + ) <nl> + { <nl> + Node shape = shapes . item ( i ) ; <nl> + NamedNodeMap shapeAttributes = shape . getAttributes ( ) ; <nl> + if ( shapeAttributes = = null ) <nl> + { <nl> + throw new ModelFormatException ( " Shape # " + ( i + 1 ) + " in " + fileName + " has no attributes " ) ; <nl> + } <nl> + <nl> + Node name = shapeAttributes . getNamedItem ( " name " ) ; <nl> + String shapeName = null ; <nl> + if ( name ! = null ) <nl> + { <nl> + shapeName = name . getNodeValue ( ) ; <nl> + } <nl> + if ( shapeName = = null ) <nl> + { <nl> + shapeName = " Shape # " + ( i + 1 ) ; <nl> + } <nl> + <nl> + Node type = shapeAttributes . getNamedItem ( " type " ) ; <nl> + if ( type = = null ) <nl> + { <nl> + throw new ModelFormatException ( " Shape [ " + shapeName + " ] in " + fileName + " has no type " ) ; <nl> + } <nl> + String shapeType = type . getNodeValue ( ) ; <nl> + if ( shapeType = = null ) <nl> + { <nl> + throw new ModelFormatException ( " Shape [ " + shapeName + " ] in " + fileName + " has an invalid type " ) ; <nl> + } <nl> + if ( ! cubeTypes . contains ( shapeType ) ) <nl> + { <nl> + FMLLog . warning ( " Model shape [ " + shapeName + " ] in " + fileName + " is not a cube , ignoring " ) ; <nl> + continue ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + boolean mirrored = false ; <nl> + String [ ] offset = new String [ 3 ] ; <nl> + String [ ] position = new String [ 3 ] ; <nl> + String [ ] rotation = new String [ 3 ] ; <nl> + String [ ] size = new String [ 3 ] ; <nl> + String [ ] textureOffset = new String [ 2 ] ; <nl> + <nl> + NodeList shapeChildren = shape . getChildNodes ( ) ; <nl> + for ( int j = 0 ; j < shapeChildren . getLength ( ) ; j + + ) <nl> + { <nl> + Node shapeChild = shapeChildren . item ( j ) ; <nl> + <nl> + String shapeChildName = shapeChild . getNodeName ( ) ; <nl> + String shapeChildValue = shapeChild . getTextContent ( ) ; <nl> + if ( shapeChildValue ! = null ) <nl> + { <nl> + shapeChildValue = shapeChildValue . trim ( ) ; <nl> + <nl> + if ( shapeChildName . equals ( " IsMirrored " ) ) <nl> + { <nl> + mirrored = ! shapeChildValue . equals ( " False " ) ; <nl> + } <nl> + else if ( shapeChildName . equals ( " Offset " ) ) <nl> + { <nl> + offset = shapeChildValue . split ( " , " ) ; <nl> + } <nl> + else if ( shapeChildName . equals ( " Position " ) ) <nl> + { <nl> + position = shapeChildValue . split ( " , " ) ; <nl> + } <nl> + else if ( shapeChildName . equals ( " Rotation " ) ) <nl> + { <nl> + rotation = shapeChildValue . split ( " , " ) ; <nl> + } <nl> + else if ( shapeChildName . equals ( " Size " ) ) <nl> + { <nl> + size = shapeChildValue . split ( " , " ) ; <nl> + } <nl> + else if ( shapeChildName . equals ( " TextureOffset " ) ) <nl> + { <nl> + textureOffset = shapeChildValue . split ( " , " ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / / That ' s what the ModelBase subclassing is needed for <nl> + ModelRenderer cube = new ModelRenderer ( this , Integer . parseInt ( textureOffset [ 0 ] ) , Integer . parseInt ( textureOffset [ 1 ] ) ) ; <nl> + cube . mirror = mirrored ; <nl> + cube . addBox ( Float . parseFloat ( offset [ 0 ] ) , Float . parseFloat ( offset [ 1 ] ) , Float . parseFloat ( offset [ 2 ] ) , Integer . parseInt ( size [ 0 ] ) , Integer . parseInt ( size [ 1 ] ) , Integer . parseInt ( size [ 2 ] ) ) ; <nl> + cube . setRotationPoint ( Float . parseFloat ( position [ 0 ] ) , Float . parseFloat ( position [ 1 ] ) - 23 . 4F , Float . parseFloat ( position [ 2 ] ) ) ; <nl> + <nl> + cube . rotateAngleX = ( float ) Math . toRadians ( Float . parseFloat ( rotation [ 0 ] ) ) ; <nl> + cube . rotateAngleY = ( float ) Math . toRadians ( Float . parseFloat ( rotation [ 1 ] ) ) ; <nl> + cube . rotateAngleZ = ( float ) Math . toRadians ( Float . parseFloat ( rotation [ 2 ] ) ) ; <nl> + <nl> + parts . put ( shapeName , cube ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + FMLLog . warning ( " Model shape [ " + shapeName + " ] in " + fileName + " contains malformed integers within its data , ignoring " ) ; <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + } <nl> + catch ( ZipException e ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " is not a valid zip file " ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " could not be read " , e ) ; <nl> + } <nl> + catch ( ParserConfigurationException e ) <nl> + { <nl> + / / hush <nl> + } <nl> + catch ( SAXException e ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " contains invalid XML " , e ) ; <nl> + } <nl> + } <nl> + <nl> + private void bindTexture ( ) <nl> + { <nl> + if ( texture ! = null ) <nl> + { <nl> + if ( ! textureNameSet ) <nl> + { <nl> + <nl> + try <nl> + { <nl> + byte [ ] textureEntry = zipFile . get ( texture ) ; <nl> + if ( textureEntry = = null ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " has no such texture " + texture ) ; <nl> + } <nl> + System . out . println ( textureEntry . length ) ; <nl> + BufferedImage image = ImageIO . read ( new ByteArrayInputStream ( textureEntry ) ) ; <nl> + textureName = Minecraft . getMinecraft ( ) . renderEngine . allocateAndSetupTexture ( image ) ; <nl> + textureNameSet = true ; <nl> + } <nl> + catch ( ZipException e ) <nl> + { <nl> + throw new ModelFormatException ( " Model " + fileName + " is not a valid zip file " ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + try <nl> + { <nl> + FileOutputStream fileOutput = new FileOutputStream ( " techne _ texture _ debug . png " ) ; <nl> + fileOutput . write ( zipFile . get ( texture ) ) ; <nl> + fileOutput . flush ( ) ; <nl> + fileOutput . close ( ) ; <nl> + } <nl> + catch ( Throwable e1 ) <nl> + { <nl> + } <nl> + <nl> + throw new ModelFormatException ( " Texture for model " + fileName + " could not be read " , e ) ; <nl> + } <nl> + } <nl> + <nl> + if ( textureNameSet ) <nl> + { <nl> + GL11 . glBindTexture ( GL11 . GL _ TEXTURE _ 2D , textureName ) ; <nl> + Minecraft . getMinecraft ( ) . renderEngine . resetBoundTexture ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public String getType ( ) <nl> + { <nl> + return " tcn " ; <nl> + } <nl> + <nl> + @ Override <nl> + public void renderAll ( ) <nl> + { <nl> + bindTexture ( ) ; <nl> + <nl> + for ( ModelRenderer part : parts . values ( ) ) <nl> + { <nl> + part . renderWithRotation ( 1 . 0F ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void renderPart ( String partName ) <nl> + { <nl> + bindTexture ( ) ; <nl> + <nl> + ModelRenderer part = parts . get ( partName ) ; <nl> + if ( part ! = null ) <nl> + { <nl> + part . renderWithRotation ( 1 . 0F ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / client / net / minecraftforge / client / model / techne / TechneModelLoader . java b / client / net / minecraftforge / client / model / techne / TechneModelLoader . java <nl> new file mode 100644 <nl> index 0000000 . . 0c9f182 <nl> - - - / dev / null <nl> + + + b / client / net / minecraftforge / client / model / techne / TechneModelLoader . java <nl> @ @ - 0 , 0 + 1 , 34 @ @ <nl> + package net . minecraftforge . client . model . techne ; <nl> + <nl> + import java . net . URL ; <nl> + <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import cpw . mods . fml . relauncher . SideOnly ; <nl> + <nl> + import net . minecraftforge . client . model . IModelCustom ; <nl> + import net . minecraftforge . client . model . IModelCustomLoader ; <nl> + import net . minecraftforge . client . model . ModelFormatException ; <nl> + <nl> + @ SideOnly ( Side . CLIENT ) <nl> + public class TechneModelLoader implements IModelCustomLoader { <nl> + <nl> + @ Override <nl> + public String getType ( ) <nl> + { <nl> + return " Techne model " ; <nl> + } <nl> + <nl> + private static final String [ ] types = { " tcn " } ; <nl> + @ Override <nl> + public String [ ] getSuffixes ( ) <nl> + { <nl> + return types ; <nl> + } <nl> + <nl> + @ Override <nl> + public IModelCustom loadInstance ( String resourceName , URL resource ) throws ModelFormatException <nl> + { <nl> + return new TechneModel ( resourceName , resource ) ; <nl> + } <nl> + <nl> + }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / Attributes . java b / src / main / java / net / minecraftforge / client / model / Attributes . java 
 index 8baf244 . . 4544930 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / Attributes . java 
 + + + b / src / main / java / net / minecraftforge / client / model / Attributes . java 
 @ @ - 1 , 8 + 1 , 12 @ @ 
 package net . minecraftforge . client . model ; 
 
 import java . nio . ByteBuffer ; 
 + import java . util . Arrays ; 
 import java . util . List ; 
 
 + import javax . vecmath . Vector4f ; 
 + 
 + import net . minecraft . client . renderer . block . model . BakedQuad ; 
 import net . minecraft . client . renderer . vertex . VertexFormat ; 
 import net . minecraft . client . renderer . vertex . VertexFormatElement ; 
 import net . minecraft . client . renderer . vertex . VertexFormatElement . EnumType ; 
 @ @ - 104 , 4 + 108 , 33 @ @ public class Attributes 
 } 
 } 
 } 
 + 
 + public static BakedQuad transform ( TRSRTransformation transform , BakedQuad quad , VertexFormat format ) 
 + { 
 + for ( VertexFormatElement e : ( List < VertexFormatElement > ) format . getElements ( ) ) 
 + { 
 + if ( e . getUsage ( ) = = VertexFormatElement . EnumUsage . POSITION ) 
 + { 
 + if ( e . getType ( ) ! = VertexFormatElement . EnumType . FLOAT ) 
 + { 
 + throw new IllegalArgumentException ( " can only transform float position " ) ; 
 + } 
 + int [ ] data = Arrays . copyOf ( quad . getVertexData ( ) , quad . getVertexData ( ) . length ) ; 
 + float [ ] pos = new float [ ] { 0f , 0f , 0f , 1f } ; 
 + for ( int i = 0 ; i < Math . min ( 4 , e . getElementCount ( ) ) ; i + + ) 
 + { 
 + pos [ i ] = Float . intBitsToFloat ( data [ e . getOffset ( ) / 4 + i ] ) ; 
 + } 
 + Vector4f vec = new Vector4f ( pos ) ; 
 + transform . getMatrix ( ) . transform ( vec ) ; 
 + vec . get ( pos ) ; 
 + for ( int i = 0 ; i < Math . min ( 4 , e . getElementCount ( ) ) ; i + + ) 
 + { 
 + data [ e . getOffset ( ) / 4 + i ] = Float . floatToRawIntBits ( pos [ i ] ) ; 
 + } 
 + return new BakedQuad ( data , quad . getTintIndex ( ) , quad . getFace ( ) ) ; 
 + } 
 + } 
 + return quad ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / client / model / IPerspectiveAwareModel . java b / src / main / java / net / minecraftforge / client / model / IPerspectiveAwareModel . java 
 index 930437b . . cb10dc9 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / IPerspectiveAwareModel . java 
 + + + b / src / main / java / net / minecraftforge / client / model / IPerspectiveAwareModel . java 
 @ @ - 2 , 12 + 2 , 11 @ @ package net . minecraftforge . client . model ; 
 
 import javax . vecmath . Matrix4f ; 
 
 - import org . apache . commons . lang3 . tuple . Pair ; 
 - 
 - import net . minecraft . item . ItemStack ; 
 import net . minecraft . client . renderer . block . model . ItemCameraTransforms . TransformType ; 
 import net . minecraft . client . resources . model . IBakedModel ; 
 
 + import org . apache . commons . lang3 . tuple . Pair ; 
 + 
 / * 
 * Model that changes based on the rendering perspective 
 * ( first - person , GUI , e . t . c - see TransformType ) 
 diff - - git a / src / main / java / net / minecraftforge / client / model / IPerspectiveState . java b / src / main / java / net / minecraftforge / client / model / IPerspectiveState . java 
 new file mode 100644 
 index 0000000 . . ca9d25d 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / client / model / IPerspectiveState . java 
 @ @ - 0 , 0 + 1 , 58 @ @ 
 + package net . minecraftforge . client . model ; 
 + 
 + import java . util . Map ; 
 + 
 + import net . minecraft . client . renderer . block . model . ItemCameraTransforms ; 
 + import net . minecraft . client . renderer . block . model . ItemCameraTransforms . TransformType ; 
 + 
 + import com . google . common . collect . ImmutableMap ; 
 + import com . google . common . collect . Maps ; 
 + 
 + / * * 
 + * IModelState that can change depending on the perspective . 
 + * / 
 + public interface IPerspectiveState extends IModelState 
 + { 
 + / * * 
 + * @ return the additional state that needs to be applied for each part when in given perspective type . 
 + * / 
 + public IModelState forPerspective ( TransformType type ) ; 
 + 
 + public static class Impl implements IPerspectiveState 
 + { 
 + private final IModelState parent ; 
 + private final ImmutableMap < TransformType , IModelState > states ; 
 + 
 + public Impl ( IModelState parent , ImmutableMap < TransformType , IModelState > states ) 
 + { 
 + this . parent = parent ; 
 + this . states = states ; 
 + } 
 + 
 + public Impl ( IModelState parent , ItemCameraTransforms transforms ) 
 + { 
 + this ( parent , getMap ( transforms ) ) ; 
 + } 
 + 
 + private static ImmutableMap < TransformType , IModelState > getMap ( ItemCameraTransforms transforms ) 
 + { 
 + Map < TransformType , IModelState > map = Maps . newHashMap ( ) ; 
 + map . put ( TransformType . NONE , TRSRTransformation . identity ( ) ) ; 
 + map . put ( TransformType . THIRD _ PERSON , transforms . thirdPerson ) ; 
 + map . put ( TransformType . FIRST _ PERSON , transforms . firstPerson ) ; 
 + map . put ( TransformType . GUI , transforms . gui ) ; 
 + map . put ( TransformType . HEAD , transforms . head ) ; 
 + return Maps . immutableEnumMap ( map ) ; 
 + } 
 + 
 + public TRSRTransformation apply ( IModelPart part ) 
 + { 
 + return parent . apply ( part ) ; 
 + } 
 + 
 + public IModelState forPerspective ( TransformType type ) 
 + { 
 + return states . getOrDefault ( type , TRSRTransformation . identity ( ) ) ; 
 + } 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / client / model / ItemLayerModel . java b / src / main / java / net / minecraftforge / client / model / ItemLayerModel . java 
 index 4276430 . . d80d81b 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / ItemLayerModel . java 
 + + + b / src / main / java / net / minecraftforge / client / model / ItemLayerModel . java 
 @ @ - 4 , 27 + 4 , 35 @ @ import java . nio . ByteBuffer ; 
 import java . util . Arrays ; 
 import java . util . Collection ; 
 import java . util . List ; 
 + import java . util . Map ; 
 + 
 + import javax . vecmath . Matrix4f ; 
 
 import net . minecraft . client . renderer . block . model . BakedQuad ; 
 import net . minecraft . client . renderer . block . model . ItemCameraTransforms ; 
 + import net . minecraft . client . renderer . block . model . ItemCameraTransforms . TransformType ; 
 import net . minecraft . client . renderer . block . model . ModelBlock ; 
 import net . minecraft . client . renderer . texture . TextureAtlasSprite ; 
 import net . minecraft . client . renderer . vertex . VertexFormat ; 
 import net . minecraft . client . renderer . vertex . VertexFormatElement ; 
 import net . minecraft . client . resources . IResourceManager ; 
 + import net . minecraft . client . resources . model . IBakedModel ; 
 import net . minecraft . util . EnumFacing ; 
 import net . minecraft . util . ResourceLocation ; 
 - import net . minecraftforge . fml . common . FMLLog ; 
 
 + import org . apache . commons . lang3 . tuple . Pair ; 
 import org . lwjgl . BufferUtils ; 
 
 import com . google . common . base . Function ; 
 import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . ImmutableMap ; 
 + import com . google . common . collect . Iterables ; 
 + import com . google . common . collect . Maps ; 
 
 public class ItemLayerModel implements IRetexturableModel { 
 
 public static final ItemLayerModel instance = new ItemLayerModel ( ImmutableList . < ResourceLocation > of ( ) ) ; 
 + 
 private final ImmutableList < ResourceLocation > textures ; 
 
 public ItemLayerModel ( ImmutableList < ResourceLocation > textures ) 
 @ @ - 75 , 29 + 83 , 53 @ @ public class ItemLayerModel implements IRetexturableModel { 
 return new ItemLayerModel ( builder . build ( ) ) ; 
 } 
 
 - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 + public IFlexibleBakedModel bake ( IModelState state , final VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 { 
 ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; 
 + final TRSRTransformation transform = state . apply ( this ) ; 
 for ( int i = 0 ; i < textures . size ( ) ; i + + ) 
 { 
 TextureAtlasSprite sprite = bakedTextureGetter . apply ( textures . get ( i ) ) ; 
 - builder . addAll ( getQuadsForSprite ( i , sprite , format ) ) ; 
 + builder . addAll ( Iterables . transform ( getQuadsForSprite ( i , sprite , format ) , new Function < BakedQuad , BakedQuad > ( ) 
 + { 
 + public BakedQuad apply ( BakedQuad input ) 
 + { 
 + return Attributes . transform ( transform , input , format ) ; 
 + } 
 + } ) ) ; 
 } 
 TextureAtlasSprite particle = bakedTextureGetter . apply ( textures . isEmpty ( ) ? new ResourceLocation ( " missingno " ) : textures . get ( 0 ) ) ; 
 + if ( state instanceof IPerspectiveState ) 
 + { 
 + IPerspectiveState ps = ( IPerspectiveState ) state ; 
 + Map < TransformType , TRSRTransformation > map = Maps . newHashMap ( ) ; 
 + for ( TransformType type : TransformType . values ( ) ) 
 + { 
 + map . put ( type , ps . forPerspective ( type ) . apply ( this ) ) ; 
 + } 
 + return new BakedModel ( builder . build ( ) , particle , format , Maps . immutableEnumMap ( map ) ) ; 
 + } 
 return new BakedModel ( builder . build ( ) , particle , format ) ; 
 } 
 
 - public static class BakedModel implements IFlexibleBakedModel 
 + public static class BakedModel implements IFlexibleBakedModel , IPerspectiveAwareModel 
 { 
 private final ImmutableList < BakedQuad > quads ; 
 private final TextureAtlasSprite particle ; 
 private final VertexFormat format ; 
 + private final ImmutableMap < TransformType , TRSRTransformation > transforms ; 
 
 public BakedModel ( ImmutableList < BakedQuad > quads , TextureAtlasSprite particle , VertexFormat format ) 
 { 
 + this ( quads , particle , format , ImmutableMap . < TransformType , TRSRTransformation > of ( ) ) ; 
 + } 
 + 
 + public BakedModel ( ImmutableList < BakedQuad > quads , TextureAtlasSprite particle , VertexFormat format , ImmutableMap < TransformType , TRSRTransformation > transforms ) 
 + { 
 this . quads = quads ; 
 this . particle = particle ; 
 this . format = format ; 
 + this . transforms = transforms ; 
 } 
 
 public boolean isAmbientOcclusion ( ) { return true ; } 
 @ @ - 108 , 9 + 140 , 17 @ @ public class ItemLayerModel implements IRetexturableModel { 
 public List < BakedQuad > getFaceQuads ( EnumFacing side ) { return ImmutableList . of ( ) ; } 
 public List < BakedQuad > getGeneralQuads ( ) { return quads ; } 
 public VertexFormat getFormat ( ) { return format ; } 
 + 
 + @ Override 
 + public Pair < IBakedModel , Matrix4f > handlePerspective ( TransformType cameraTransformType ) 
 + { 
 + TRSRTransformation tr = transforms . getOrDefault ( cameraTransformType , TRSRTransformation . identity ( ) ) ; 
 + Matrix4f mat = tr = = TRSRTransformation . identity ( ) ? null : tr . getMatrix ( ) ; 
 + return Pair . of ( ( IBakedModel ) this , mat ) ; 
 + } 
 } 
 
 - public static final ImmutableList < BakedQuad > getQuadsForSprite ( int tint , TextureAtlasSprite sprite , VertexFormat format ) 
 + public ImmutableList < BakedQuad > getQuadsForSprite ( int tint , TextureAtlasSprite sprite , VertexFormat format ) 
 { 
 ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; 
 
 @ @ - 131 , 7 + 171 , 7 @ @ public class ItemLayerModel implements IRetexturableModel { 
 ptu = true ; 
 for ( int u = 0 ; u < uMax ; u + + ) 
 { 
 - boolean t = ( pixels [ u + ( vMax - 1 - v ) * uMax ] > > 24 & 0xFF ) = = 0 ; 
 + boolean t = isTransparent ( pixels , uMax , vMax , u , v ) ; 
 if ( ptu & & ! t ) / / left - transparent , right - opaque 
 { 
 builder . add ( buildSideQuad ( buf , format , EnumFacing . WEST , tint , sprite , u , v ) ) ; 
 @ @ - 182 , 6 + 222 , 11 @ @ public class ItemLayerModel implements IRetexturableModel { 
 return builder . build ( ) ; 
 } 
 
 + protected boolean isTransparent ( int [ ] pixels , int uMax , int vMax , int u , int v ) 
 + { 
 + return ( pixels [ u + ( vMax - 1 - v ) * uMax ] > > 24 & 0xFF ) = = 0 ; 
 + } 
 + 
 private static BakedQuad buildSideQuad ( ByteBuffer buf , VertexFormat format , EnumFacing side , int tint , TextureAtlasSprite sprite , int u , int v ) 
 { 
 float x0 = ( float ) u / sprite . getIconWidth ( ) ; 
 diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 index 2327d5b . . db598fd 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 @ @ - 320 , 10 + 320 , 11 @ @ public class ModelLoader extends ModelBakery 
 throw new IllegalArgumentException ( " can ' t bake vanilla models to the format that doesn ' t fit into the default one : " + format ) ; 
 } 
 ModelBlock model = this . model ; 
 - if ( hasItemModel ( model ) ) return new ItemLayerModel ( model ) . bake ( state , format , bakedTextureGetter ) ; / / model = makeItemModel ( model ) ; 
 if ( model = = null ) return getMissingModel ( ) . bake ( state , format , bakedTextureGetter ) ; 
 - if ( isCustomRenderer ( model ) ) return new IFlexibleBakedModel . Wrapper ( new BuiltInModel ( new ItemCameraTransforms ( model . getThirdPersonTransform ( ) , model . getFirstPersonTransform ( ) , model . getHeadTransform ( ) , model . getInGuiTransform ( ) ) ) , Attributes . DEFAULT _ BAKED _ FORMAT ) ; 
 - return new IFlexibleBakedModel . Wrapper ( bakeModel ( model , state . apply ( this ) , state instanceof UVLock ) , Attributes . DEFAULT _ BAKED _ FORMAT ) ; 
 + ItemCameraTransforms transforms = new ItemCameraTransforms ( model . getThirdPersonTransform ( ) , model . getFirstPersonTransform ( ) , model . getHeadTransform ( ) , model . getInGuiTransform ( ) ) ; 
 + if ( hasItemModel ( model ) ) return new ItemLayerModel ( model ) . bake ( new IPerspectiveState . Impl ( state , transforms ) , format , bakedTextureGetter ) ; 
 + if ( isCustomRenderer ( model ) ) return new IFlexibleBakedModel . Wrapper ( new BuiltInModel ( transforms ) , format ) ; 
 + return new IFlexibleBakedModel . Wrapper ( bakeModel ( model , state . apply ( this ) , state instanceof UVLock ) , format ) ; 
 } 
 
 public IModelState getDefaultState ( ) 
 diff - - git a / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java b / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java 
 index cd1eb84 . . ea53d8f 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java 
 + + + b / src / main / java / net / minecraftforge / client / model / TRSRTransformation . java 
 @ @ - 53 , 7 + 53 , 7 @ @ public class TRSRTransformation implements IModelState , ITransformation 
 
 public TRSRTransformation ( ItemTransformVec3f transform ) 
 { 
 - this ( transform . translation , quatFromYXZ ( transform . rotation ) , transform . scale , null ) ; 
 + this ( transform . translation , quatFromYXZDegrees ( transform . rotation ) , transform . scale , null ) ; 
 } 
 
 public TRSRTransformation ( ModelRotation rotation ) 
 @ @ - 97 , 6 + 97 , 11 @ @ public class TRSRTransformation implements IModelState , ITransformation 
 } 
 } 
 
 + public static Quat4f quatFromYXZDegrees ( Vector3f yxz ) 
 + { 
 + return quatFromYXZ ( ( float ) Math . toRadians ( yxz . y ) , ( float ) Math . toRadians ( yxz . x ) , ( float ) Math . toRadians ( yxz . z ) ) ; 
 + } 
 + 
 public static Quat4f quatFromYXZ ( Vector3f yxz ) 
 { 
 return quatFromYXZ ( yxz . y , yxz . x , yxz . z ) ;

NEAREST DIFF:
diff - - git a / client / net / minecraftforge / client / model / AdvancedModelLoader . java b / client / net / minecraftforge / client / model / AdvancedModelLoader . java 
 index d2e8882 . . b29ca1c 100644 
 - - - a / client / net / minecraftforge / client / model / AdvancedModelLoader . java 
 + + + b / client / net / minecraftforge / client / model / AdvancedModelLoader . java 
 @ @ - 6 , 6 + 6 , 7 @ @ import java . util . Collection ; 
 import java . util . Map ; 
 
 import net . minecraftforge . client . model . obj . ObjModelLoader ; 
 + import net . minecraftforge . client . model . techne . TechneModelLoader ; 
 
 import com . google . common . collect . Maps ; 
 
 @ @ - 52 , 7 + 53 , 7 @ @ public class AdvancedModelLoader { 
 FMLLog . severe ( " The resource name % s is not valid " , resourceName ) ; 
 throw new IllegalArgumentException ( " The resource name is not valid " ) ; 
 } 
 - String suffix = resourceName . substring ( i ) ; 
 + String suffix = resourceName . substring ( i + 1 ) ; 
 IModelCustomLoader loader = instances . get ( suffix ) ; 
 if ( loader = = null ) 
 { 
 @ @ - 78 , 5 + 79 , 6 @ @ public class AdvancedModelLoader { 
 static 
 { 
 registerModelHandler ( new ObjModelLoader ( ) ) ; 
 + registerModelHandler ( new TechneModelLoader ( ) ) ; 
 } 
 } 
 diff - - git a / client / net / minecraftforge / client / model / techne / TechneModel . java b / client / net / minecraftforge / client / model / techne / TechneModel . java 
 new file mode 100644 
 index 0000000 . . 4e55650 
 - - - / dev / null 
 + + + b / client / net / minecraftforge / client / model / techne / TechneModel . java 
 @ @ - 0 , 0 + 1 , 308 @ @ 
 + package net . minecraftforge . client . model . techne ; 
 + 
 + import java . awt . image . BufferedImage ; 
 + import java . io . ByteArrayInputStream ; 
 + import java . io . File ; 
 + import java . io . FileOutputStream ; 
 + import java . io . IOException ; 
 + import java . net . URL ; 
 + import java . util . Arrays ; 
 + import java . util . HashMap ; 
 + import java . util . LinkedHashMap ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . zip . ZipEntry ; 
 + import java . util . zip . ZipException ; 
 + import java . util . zip . ZipFile ; 
 + import java . util . zip . ZipInputStream ; 
 + 
 + import javax . imageio . ImageIO ; 
 + import javax . xml . parsers . DocumentBuilder ; 
 + import javax . xml . parsers . DocumentBuilderFactory ; 
 + import javax . xml . parsers . ParserConfigurationException ; 
 + 
 + import org . lwjgl . opengl . GL11 ; 
 + import org . w3c . dom . Document ; 
 + import org . w3c . dom . NamedNodeMap ; 
 + import org . w3c . dom . Node ; 
 + import org . w3c . dom . NodeList ; 
 + import org . xml . sax . SAXException ; 
 + 
 + import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . relauncher . Side ; 
 + import cpw . mods . fml . relauncher . SideOnly ; 
 + 
 + import net . minecraft . client . Minecraft ; 
 + import net . minecraft . client . model . ModelBase ; 
 + import net . minecraft . client . model . ModelRenderer ; 
 + import net . minecraft . client . renderer . RenderEngine ; 
 + import net . minecraftforge . client . model . IModelCustom ; 
 + import net . minecraftforge . client . model . ModelFormatException ; 
 + 
 + @ SideOnly ( Side . CLIENT ) 
 + public class TechneModel extends ModelBase implements IModelCustom { 
 + public static final List < String > cubeTypes = Arrays . asList ( 
 + " d9e621f7 - 957f - 4b77 - b1ae - 20dcd0da7751 " , 
 + " de81aa14 - bd60 - 4228 - 8d8d - 5238bcd3caaa " 
 + ) ; 
 + 
 + private String fileName ; 
 + private Map < String , byte [ ] > zipFile = new HashMap < String , byte [ ] > ( ) ; 
 + 
 + private Map < String , ModelRenderer > parts = new LinkedHashMap < String , ModelRenderer > ( ) ; 
 + private String texture = null ; 
 + private int textureName ; 
 + private boolean textureNameSet = false ; 
 + 
 + public TechneModel ( String fileName , URL resource ) throws ModelFormatException 
 + { 
 + this . fileName = fileName ; 
 + loadTechneModel ( resource ) ; 
 + } 
 + 
 + private void loadTechneModel ( URL fileURL ) throws ModelFormatException 
 + { 
 + try 
 + { 
 + ZipInputStream zipInput = new ZipInputStream ( fileURL . openStream ( ) ) ; 
 + 
 + ZipEntry entry ; 
 + while ( ( entry = zipInput . getNextEntry ( ) ) ! = null ) 
 + { 
 + byte [ ] data = new byte [ ( int ) entry . getSize ( ) ] ; 
 + zipInput . read ( data ) ; 
 + zipFile . put ( entry . getName ( ) , data ) ; 
 + } 
 + 
 + byte [ ] modelXml = zipFile . get ( " model . xml " ) ; 
 + if ( modelXml = = null ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " contains no model . xml file " ) ; 
 + } 
 + 
 + DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; 
 + DocumentBuilder documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; 
 + Document document = documentBuilder . parse ( new ByteArrayInputStream ( modelXml ) ) ; 
 + 
 + NodeList nodeListTechne = document . getElementsByTagName ( " Techne " ) ; 
 + if ( nodeListTechne . getLength ( ) < 1 ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " contains no Techne tag " ) ; 
 + } 
 + 
 + NodeList nodeListModel = document . getElementsByTagName ( " Model " ) ; 
 + if ( nodeListModel . getLength ( ) < 1 ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " contains no Model tag " ) ; 
 + } 
 + 
 + NamedNodeMap modelAttributes = nodeListModel . item ( 0 ) . getAttributes ( ) ; 
 + if ( modelAttributes = = null ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " contains a Model tag with no attributes " ) ; 
 + } 
 + 
 + Node modelTexture = modelAttributes . getNamedItem ( " texture " ) ; 
 + if ( modelTexture ! = null ) 
 + { 
 + texture = modelTexture . getTextContent ( ) ; 
 + } 
 + 
 + NodeList shapes = document . getElementsByTagName ( " Shape " ) ; 
 + for ( int i = 0 ; i < shapes . getLength ( ) ; i + + ) 
 + { 
 + Node shape = shapes . item ( i ) ; 
 + NamedNodeMap shapeAttributes = shape . getAttributes ( ) ; 
 + if ( shapeAttributes = = null ) 
 + { 
 + throw new ModelFormatException ( " Shape # " + ( i + 1 ) + " in " + fileName + " has no attributes " ) ; 
 + } 
 + 
 + Node name = shapeAttributes . getNamedItem ( " name " ) ; 
 + String shapeName = null ; 
 + if ( name ! = null ) 
 + { 
 + shapeName = name . getNodeValue ( ) ; 
 + } 
 + if ( shapeName = = null ) 
 + { 
 + shapeName = " Shape # " + ( i + 1 ) ; 
 + } 
 + 
 + Node type = shapeAttributes . getNamedItem ( " type " ) ; 
 + if ( type = = null ) 
 + { 
 + throw new ModelFormatException ( " Shape [ " + shapeName + " ] in " + fileName + " has no type " ) ; 
 + } 
 + String shapeType = type . getNodeValue ( ) ; 
 + if ( shapeType = = null ) 
 + { 
 + throw new ModelFormatException ( " Shape [ " + shapeName + " ] in " + fileName + " has an invalid type " ) ; 
 + } 
 + if ( ! cubeTypes . contains ( shapeType ) ) 
 + { 
 + FMLLog . warning ( " Model shape [ " + shapeName + " ] in " + fileName + " is not a cube , ignoring " ) ; 
 + continue ; 
 + } 
 + 
 + try 
 + { 
 + boolean mirrored = false ; 
 + String [ ] offset = new String [ 3 ] ; 
 + String [ ] position = new String [ 3 ] ; 
 + String [ ] rotation = new String [ 3 ] ; 
 + String [ ] size = new String [ 3 ] ; 
 + String [ ] textureOffset = new String [ 2 ] ; 
 + 
 + NodeList shapeChildren = shape . getChildNodes ( ) ; 
 + for ( int j = 0 ; j < shapeChildren . getLength ( ) ; j + + ) 
 + { 
 + Node shapeChild = shapeChildren . item ( j ) ; 
 + 
 + String shapeChildName = shapeChild . getNodeName ( ) ; 
 + String shapeChildValue = shapeChild . getTextContent ( ) ; 
 + if ( shapeChildValue ! = null ) 
 + { 
 + shapeChildValue = shapeChildValue . trim ( ) ; 
 + 
 + if ( shapeChildName . equals ( " IsMirrored " ) ) 
 + { 
 + mirrored = ! shapeChildValue . equals ( " False " ) ; 
 + } 
 + else if ( shapeChildName . equals ( " Offset " ) ) 
 + { 
 + offset = shapeChildValue . split ( " , " ) ; 
 + } 
 + else if ( shapeChildName . equals ( " Position " ) ) 
 + { 
 + position = shapeChildValue . split ( " , " ) ; 
 + } 
 + else if ( shapeChildName . equals ( " Rotation " ) ) 
 + { 
 + rotation = shapeChildValue . split ( " , " ) ; 
 + } 
 + else if ( shapeChildName . equals ( " Size " ) ) 
 + { 
 + size = shapeChildValue . split ( " , " ) ; 
 + } 
 + else if ( shapeChildName . equals ( " TextureOffset " ) ) 
 + { 
 + textureOffset = shapeChildValue . split ( " , " ) ; 
 + } 
 + } 
 + } 
 + 
 + / / That ' s what the ModelBase subclassing is needed for 
 + ModelRenderer cube = new ModelRenderer ( this , Integer . parseInt ( textureOffset [ 0 ] ) , Integer . parseInt ( textureOffset [ 1 ] ) ) ; 
 + cube . mirror = mirrored ; 
 + cube . addBox ( Float . parseFloat ( offset [ 0 ] ) , Float . parseFloat ( offset [ 1 ] ) , Float . parseFloat ( offset [ 2 ] ) , Integer . parseInt ( size [ 0 ] ) , Integer . parseInt ( size [ 1 ] ) , Integer . parseInt ( size [ 2 ] ) ) ; 
 + cube . setRotationPoint ( Float . parseFloat ( position [ 0 ] ) , Float . parseFloat ( position [ 1 ] ) - 23 . 4F , Float . parseFloat ( position [ 2 ] ) ) ; 
 + 
 + cube . rotateAngleX = ( float ) Math . toRadians ( Float . parseFloat ( rotation [ 0 ] ) ) ; 
 + cube . rotateAngleY = ( float ) Math . toRadians ( Float . parseFloat ( rotation [ 1 ] ) ) ; 
 + cube . rotateAngleZ = ( float ) Math . toRadians ( Float . parseFloat ( rotation [ 2 ] ) ) ; 
 + 
 + parts . put ( shapeName , cube ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + FMLLog . warning ( " Model shape [ " + shapeName + " ] in " + fileName + " contains malformed integers within its data , ignoring " ) ; 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + } 
 + catch ( ZipException e ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " is not a valid zip file " ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " could not be read " , e ) ; 
 + } 
 + catch ( ParserConfigurationException e ) 
 + { 
 + / / hush 
 + } 
 + catch ( SAXException e ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " contains invalid XML " , e ) ; 
 + } 
 + } 
 + 
 + private void bindTexture ( ) 
 + { 
 + if ( texture ! = null ) 
 + { 
 + if ( ! textureNameSet ) 
 + { 
 + 
 + try 
 + { 
 + byte [ ] textureEntry = zipFile . get ( texture ) ; 
 + if ( textureEntry = = null ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " has no such texture " + texture ) ; 
 + } 
 + System . out . println ( textureEntry . length ) ; 
 + BufferedImage image = ImageIO . read ( new ByteArrayInputStream ( textureEntry ) ) ; 
 + textureName = Minecraft . getMinecraft ( ) . renderEngine . allocateAndSetupTexture ( image ) ; 
 + textureNameSet = true ; 
 + } 
 + catch ( ZipException e ) 
 + { 
 + throw new ModelFormatException ( " Model " + fileName + " is not a valid zip file " ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + try 
 + { 
 + FileOutputStream fileOutput = new FileOutputStream ( " techne _ texture _ debug . png " ) ; 
 + fileOutput . write ( zipFile . get ( texture ) ) ; 
 + fileOutput . flush ( ) ; 
 + fileOutput . close ( ) ; 
 + } 
 + catch ( Throwable e1 ) 
 + { 
 + } 
 + 
 + throw new ModelFormatException ( " Texture for model " + fileName + " could not be read " , e ) ; 
 + } 
 + } 
 + 
 + if ( textureNameSet ) 
 + { 
 + GL11 . glBindTexture ( GL11 . GL _ TEXTURE _ 2D , textureName ) ; 
 + Minecraft . getMinecraft ( ) . renderEngine . resetBoundTexture ( ) ; 
 + } 
 + } 
 + } 
 + 
 + @ Override 
 + public String getType ( ) 
 + { 
 + return " tcn " ; 
 + } 
 + 
 + @ Override 
 + public void renderAll ( ) 
 + { 
 + bindTexture ( ) ; 
 + 
 + for ( ModelRenderer part : parts . values ( ) ) 
 + { 
 + part . renderWithRotation ( 1 . 0F ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void renderPart ( String partName ) 
 + { 
 + bindTexture ( ) ; 
 + 
 + ModelRenderer part = parts . get ( partName ) ; 
 + if ( part ! = null ) 
 + { 
 + part . renderWithRotation ( 1 . 0F ) ; 
 + } 
 + } 
 + } 
 diff - - git a / client / net / minecraftforge / client / model / techne / TechneModelLoader . java b / client / net / minecraftforge / client / model / techne / TechneModelLoader . java 
 new file mode 100644 
 index 0000000 . . 0c9f182 
 - - - / dev / null 
 + + + b / client / net / minecraftforge / client / model / techne / TechneModelLoader . java 
 @ @ - 0 , 0 + 1 , 34 @ @ 
 + package net . minecraftforge . client . model . techne ; 
 + 
 + import java . net . URL ; 
 + 
 + import cpw . mods . fml . relauncher . Side ; 
 + import cpw . mods . fml . relauncher . SideOnly ; 
 + 
 + import net . minecraftforge . client . model . IModelCustom ; 
 + import net . minecraftforge . client . model . IModelCustomLoader ; 
 + import net . minecraftforge . client . model . ModelFormatException ; 
 + 
 + @ SideOnly ( Side . CLIENT ) 
 + public class TechneModelLoader implements IModelCustomLoader { 
 + 
 + @ Override 
 + public String getType ( ) 
 + { 
 + return " Techne model " ; 
 + } 
 + 
 + private static final String [ ] types = { " tcn " } ; 
 + @ Override 
 + public String [ ] getSuffixes ( ) 
 + { 
 + return types ; 
 + } 
 + 
 + @ Override 
 + public IModelCustom loadInstance ( String resourceName , URL resource ) throws ModelFormatException 
 + { 
 + return new TechneModel ( resourceName , resource ) ; 
 + } 
 + 
 + }
