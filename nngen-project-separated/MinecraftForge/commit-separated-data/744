BLEU SCORE: 0.01650404559570943

TEST MSG: Properly deprecate and link the replacement methods in GameRegistry . Add helper method for registering a block with default ItemBlock because people keep complaining - . -
GENERATED MSG: First draft of add alias . It is probably not properly persistent atm .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / GameRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / GameRegistry . java <nl> index 41bf24b . . 290b225 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / GameRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / GameRegistry . java <nl> @ @ - 133 , 6 + 133 , 8 @ @ public class GameRegistry <nl> * Always ensure the object is already named using { @ link IForgeRegistryEntry # setRegistryName ( ResourceLocation ) } <nl> * or another mechanism . <nl> * <nl> + * Note : That DOES NOT create the ItemBlock for you if this is a Block , you should register that item separately . <nl> + * <nl> * @ param object The object to register with a registry <nl> * @ param < K > The registry supertype <nl> * @ throws IllegalArgumentException if the object is not yet named ( use { @ link # register ( IForgeRegistryEntry , ResourceLocation ) } instead ) <nl> @ @ - 147 , 6 + 149 , 10 @ @ public class GameRegistry <nl> * Register the unnamed { @ link IForgeRegistry } object with the registry system . <nl> * Always make sure you have not previously named the object . <nl> * <nl> + * It is advised that you set the object ' s registry name and use { @ link # register ( IForgeRegistryEntry ) } instead . <nl> + * <nl> + * Note : That DOES NOT create the ItemBlock for you if this is a Block , you should register that item separately . <nl> + * <nl> * @ param object The object to register <nl> * @ param name The name to register it with <nl> * @ param < K > The registry supertype <nl> @ @ - 157 , 31 + 163 , 23 @ @ public class GameRegistry <nl> { <nl> return GameData . register ( object , name ) ; <nl> } <nl> - / * * <nl> - * Register an item with the item registry with a the name specified in Item . getRegistryName ( ) <nl> - * <nl> - * @ param item The item to register <nl> - * / <nl> - @ Deprecated <nl> - public static void registerItem ( Item item ) <nl> - { <nl> - registerItem ( item , item . getRegistryName ( ) . toString ( ) ) ; <nl> - } <nl> + <nl> <nl> / * * <nl> - * Register an item with the item registry with a custom name : this allows for easier server - > client resolution <nl> + * Registers a named block with the Block registry . This WILL create a new ItemBlock for you with the <nl> + * same name and register it with the ItemRegistry . This method is created as a convince method for <nl> + * modder and SHOULD NOT be used . Modders should create and register their ItemBlocks like normal items . <nl> * <nl> - * @ param item The item to register <nl> - * @ param name The mod - unique name of the item <nl> + * @ param block The block to register with a registry <nl> + * @ throws IllegalArgumentException if the object is not yet named <nl> + * @ return The block <nl> * / <nl> - @ Deprecated <nl> - public static void registerItem ( Item item , String name ) <nl> + @ Deprecated / / Modders SHOULD NOT use this , so it ' ll stay deprecated . Purely added to make lazy modders happy - . - <nl> + public static Block registerWithItem ( Block block ) <nl> { <nl> - if ( Strings . isNullOrEmpty ( name ) ) <nl> - { <nl> - throw new IllegalArgumentException ( " Attempted to register a block with no name : " + item ) ; <nl> - } <nl> - GameData . getMain ( ) . registerItem ( item , name ) ; <nl> + register ( block ) ; <nl> + register ( new ItemBlock ( block ) . setRegistryName ( block . getRegistryName ( ) ) ) ; <nl> + return block ; <nl> } <nl> <nl> / * * <nl> @ @ - 200 , 117 + 198 , 6 @ @ public class GameRegistry <nl> GameData . getMain ( ) . registerSubstitutionAlias ( nameToSubstitute , type , object ) ; <nl> } <nl> <nl> - / * * <nl> - * Register a block with the name that Block . getRegistryName returns . <nl> - * <nl> - * @ param block The block to register <nl> - * / <nl> - @ Deprecated <nl> - public static Block registerBlock ( Block block ) <nl> - { <nl> - return registerBlock ( block , block . getRegistryName ( ) . toString ( ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Register a block with the specified mod specific name <nl> - * <nl> - * @ param block The block to register <nl> - * @ param name The mod - unique name to register it as , will get prefixed by your modid . <nl> - * / <nl> - @ Deprecated <nl> - public static Block registerBlock ( Block block , String name ) <nl> - { <nl> - return registerBlock ( block , ItemBlock . class , name ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Register a block with the world , with the specified item class using Block . getRegistryName ' s name <nl> - * <nl> - * @ param block The block to register <nl> - * @ param itemclass The item type to register with it : null registers a block without associated item . <nl> - * / <nl> - @ Deprecated <nl> - public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass ) <nl> - { <nl> - return registerBlock ( block , itemclass , block . getRegistryName ( ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Register a block with the world , with the specified item class and block name <nl> - * <nl> - * @ param block The block to register <nl> - * @ param itemclass The item type to register with it : null registers a block without associated item . <nl> - * @ param name The mod - unique name to register it as , will get prefixed by your modid . <nl> - * / <nl> - @ Deprecated <nl> - public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , String name ) <nl> - { <nl> - return registerBlock ( block , itemclass , name , new Object [ ] { } ) ; <nl> - } <nl> - <nl> - <nl> - / * * <nl> - * Register a block with the world , with the specified item class using Block . getRegistryName ' s name <nl> - * <nl> - * @ param block The block to register <nl> - * @ param itemclass The item type to register with it : null registers a block without associated item . <nl> - * @ param itemCtorArgs Arguments to pass ( after the required { @ code Block } parameter ) to the ItemBlock constructor ( optional ) . <nl> - * / <nl> - @ Deprecated <nl> - public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , Object . . . itemCtorArgs ) <nl> - { <nl> - return registerBlock ( block , itemclass , block . getRegistryName ( ) . toString ( ) , itemCtorArgs ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Register a block with the world , with the specified item class , block name and owning modId <nl> - * <nl> - * @ param block The block to register <nl> - * @ param itemclass The item type to register with it : null registers a block without associated item . <nl> - * @ param name The mod - unique name to register it as , will get prefixed by your modid . <nl> - * @ param itemCtorArgs Arguments to pass ( after the required { @ code Block } parameter ) to the ItemBlock constructor ( optional ) . <nl> - * / <nl> - @ Deprecated <nl> - public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , String name , Object . . . itemCtorArgs ) <nl> - { <nl> - if ( Strings . isNullOrEmpty ( name ) ) <nl> - { <nl> - throw new IllegalArgumentException ( " Attempted to register a block with no name : " + block ) ; <nl> - } <nl> - if ( Loader . instance ( ) . isInState ( LoaderState . CONSTRUCTING ) ) <nl> - { <nl> - FMLLog . warning ( " The mod % s is attempting to register a block whilst it it being constructed . This is bad modding practice - please use a proper mod lifecycle event . " , Loader . instance ( ) . activeModContainer ( ) ) ; <nl> - } <nl> - try <nl> - { <nl> - assert block ! = null : " registerBlock : block cannot be null " ; <nl> - ItemBlock i = null ; <nl> - if ( itemclass ! = null ) <nl> - { <nl> - Class < ? > [ ] ctorArgClasses = new Class < ? > [ itemCtorArgs . length + 1 ] ; <nl> - ctorArgClasses [ 0 ] = Block . class ; <nl> - for ( int idx = 1 ; idx < ctorArgClasses . length ; idx + + ) <nl> - { <nl> - ctorArgClasses [ idx ] = itemCtorArgs [ idx - 1 ] . getClass ( ) ; <nl> - } <nl> - Constructor < ? extends ItemBlock > itemCtor = itemclass . getConstructor ( ctorArgClasses ) ; <nl> - i = itemCtor . newInstance ( ObjectArrays . concat ( block , itemCtorArgs ) ) ; <nl> - } <nl> - / / block registration has to happen first <nl> - GameData . getMain ( ) . registerBlock ( block , name ) ; <nl> - if ( i ! = null ) <nl> - { <nl> - GameData . getMain ( ) . registerItem ( i , name ) ; <nl> - GameData . getBlockItemMap ( ) . put ( block , i ) ; <nl> - } <nl> - return block ; <nl> - } catch ( Exception e ) <nl> - { <nl> - FMLLog . log ( Level . ERROR , e , " Caught an exception during block registration " ) ; <nl> - throw new LoaderException ( e ) ; <nl> - } <nl> - } <nl> - <nl> public static void addRecipe ( ItemStack output , Object . . . params ) <nl> { <nl> addShapedRecipe ( output , params ) ; <nl> @ @ - 387 , 32 + 274 , 6 @ @ public class GameRegistry <nl> return fuelValue ; <nl> } <nl> <nl> - / * * <nl> - * Look up a mod block in the global " named item list " <nl> - * <nl> - * @ param modId The modid owning the block <nl> - * @ param name The name of the block itself <nl> - * @ return The block or null if not found <nl> - * / <nl> - @ Deprecated <nl> - public static Block findBlock ( String modId , String name ) <nl> - { <nl> - return GameData . findBlock ( modId , name ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Look up a mod item in the global " named item list " <nl> - * <nl> - * @ param modId The modid owning the item <nl> - * @ param name The name of the item itself <nl> - * @ return The item or null if not found <nl> - * / <nl> - @ Deprecated <nl> - public static Item findItem ( String modId , String name ) <nl> - { <nl> - return GameData . findItem ( modId , name ) ; <nl> - } <nl> - <nl> public enum Type <nl> { <nl> BLOCK , <nl> @ @ - 520 , 4 + 381 , 132 @ @ public class GameRegistry <nl> return is ; <nl> } <nl> <nl> + <nl> + <nl> + <nl> + / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = DEPRECATED / INTERNAL MODDERS DO NOT USE = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> + / * * <nl> + * Use { @ link # register ( IForgeRegistryEntry ) } instead <nl> + * / <nl> + @ Deprecated public static void registerItem ( Item item ) { register ( item ) ; } <nl> + / * * <nl> + * Use { @ link # register ( IForgeRegistryEntry ) } instead <nl> + * / <nl> + @ Deprecated <nl> + public static void registerItem ( Item item , String name ) <nl> + { <nl> + if ( item . getRegistryName ( ) = = null & & Strings . isNullOrEmpty ( name ) ) <nl> + throw new IllegalArgumentException ( " Attempted to register a item with no name : " + item ) ; <nl> + if ( item . getRegistryName ( ) ! = null & & ! item . getRegistryName ( ) . toString ( ) . equals ( name ) ) <nl> + throw new IllegalArgumentException ( " Attempted to register a item with conflicting names . Old : " + item . getRegistryName ( ) + " New : " + name ) ; <nl> + register ( item . getRegistryName ( ) = = null ? item . setRegistryName ( name ) : item ) ; <nl> + } <nl> + / * * <nl> + * Use { @ link # register ( IForgeRegistryEntry ) } instead <nl> + * / <nl> + @ Deprecated <nl> + public static Block registerBlock ( Block block ) <nl> + { <nl> + register ( block ) ; <nl> + register ( new ItemBlock ( block ) . setRegistryName ( block . getRegistryName ( ) ) ) ; <nl> + return block ; <nl> + } <nl> + / * * <nl> + * Use { @ link # register ( IForgeRegistryEntry ) } instead <nl> + * / <nl> + @ Deprecated <nl> + public static Block registerBlock ( Block block , String name ) <nl> + { <nl> + if ( block . getRegistryName ( ) = = null & & Strings . isNullOrEmpty ( name ) ) <nl> + throw new IllegalArgumentException ( " Attempted to register a Block with no name : " + block ) ; <nl> + if ( block . getRegistryName ( ) ! = null & & ! block . getRegistryName ( ) . toString ( ) . equals ( name ) ) <nl> + throw new IllegalArgumentException ( " Attempted to register a Block with conflicting names . Old : " + block . getRegistryName ( ) + " New : " + name ) ; <nl> + return registerBlock ( block . getRegistryName ( ) ! = null ? block : block . setRegistryName ( name ) ) ; <nl> + } <nl> + / * * <nl> + * Use { @ link # register ( IForgeRegistryEntry ) } instead <nl> + * / <nl> + @ Deprecated public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass ) { return registerBlock ( block , itemclass , block . getRegistryName ( ) ) ; } <nl> + / * * <nl> + * Use { @ link # register ( IForgeRegistryEntry ) } instead <nl> + * / <nl> + @ Deprecated public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , String name ) { return registerBlock ( block , itemclass , name , new Object [ ] { } ) ; } <nl> + / * * <nl> + * Use { @ link # register ( IForgeRegistryEntry ) } instead <nl> + * / <nl> + @ Deprecated public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , Object . . . itemCtorArgs ) { return registerBlock ( block , itemclass , block . getRegistryName ( ) . toString ( ) , itemCtorArgs ) ; } <nl> + / * * <nl> + * Use { @ link # register ( IForgeRegistryEntry ) } instead <nl> + * / <nl> + @ Deprecated <nl> + public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , String name , Object . . . itemCtorArgs ) <nl> + { <nl> + if ( Strings . isNullOrEmpty ( name ) ) <nl> + { <nl> + throw new IllegalArgumentException ( " Attempted to register a block with no name : " + block ) ; <nl> + } <nl> + if ( Loader . instance ( ) . isInState ( LoaderState . CONSTRUCTING ) ) <nl> + { <nl> + FMLLog . warning ( " The mod % s is attempting to register a block whilst it it being constructed . This is bad modding practice - please use a proper mod lifecycle event . " , Loader . instance ( ) . activeModContainer ( ) ) ; <nl> + } <nl> + try <nl> + { <nl> + assert block ! = null : " registerBlock : block cannot be null " ; <nl> + if ( block . getRegistryName ( ) ! = null & & ! block . getRegistryName ( ) . toString ( ) . equals ( name ) ) <nl> + throw new IllegalArgumentException ( " Attempted to register a Block with conflicting names . Old : " + block . getRegistryName ( ) + " New : " + name ) ; <nl> + ItemBlock i = null ; <nl> + if ( itemclass ! = null ) <nl> + { <nl> + Class < ? > [ ] ctorArgClasses = new Class < ? > [ itemCtorArgs . length + 1 ] ; <nl> + ctorArgClasses [ 0 ] = Block . class ; <nl> + for ( int idx = 1 ; idx < ctorArgClasses . length ; idx + + ) <nl> + { <nl> + ctorArgClasses [ idx ] = itemCtorArgs [ idx - 1 ] . getClass ( ) ; <nl> + } <nl> + Constructor < ? extends ItemBlock > itemCtor = itemclass . getConstructor ( ctorArgClasses ) ; <nl> + i = itemCtor . newInstance ( ObjectArrays . concat ( block , itemCtorArgs ) ) ; <nl> + } <nl> + / / block registration has to happen first <nl> + register ( block . getRegistryName ( ) = = null ? block . setRegistryName ( name ) : block ) ; <nl> + if ( i ! = null ) <nl> + register ( i . setRegistryName ( name ) ) ; <nl> + return block ; <nl> + } catch ( Exception e ) <nl> + { <nl> + FMLLog . log ( Level . ERROR , e , " Caught an exception during block registration " ) ; <nl> + throw new LoaderException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * <nl> + * Use Block . REGISTRY . getValue ( ResourceLocation ) instead ! <nl> + * <nl> + * <nl> + * Look up a mod block in the global " named item list " <nl> + * <nl> + * @ param modId The modid owning the block <nl> + * @ param name The name of the block itself <nl> + * @ return The block or null if not found <nl> + * / <nl> + @ Deprecated <nl> + public static Block findBlock ( String modId , String name ) <nl> + { <nl> + return GameData . findBlock ( modId , name ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Use Item . REGISTRY . getValue ( ResourceLocation ) instead ! <nl> + * <nl> + * Look up a mod item in the global " named item list " <nl> + * <nl> + * @ param modId The modid owning the item <nl> + * @ param name The name of the item itself <nl> + * @ return The item or null if not found <nl> + * / <nl> + @ Deprecated <nl> + public static Item findItem ( String modId , String name ) <nl> + { <nl> + return GameData . findItem ( modId , name ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java b / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java <nl> index fd20bb7 . . 03f8e58 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java <nl> @ @ - 30 , 6 + 30 , 8 @ @ import net . minecraft . world . storage . WorldInfo ; <nl> <nl> import org . apache . logging . log4j . Level ; <nl> <nl> + import com . google . common . collect . BiMap ; <nl> + import com . google . common . collect . HashBiMap ; <nl> import com . google . common . collect . Maps ; <nl> import com . google . common . eventbus . EventBus ; <nl> import com . google . common . eventbus . Subscribe ; <nl> @ @ - 124 , 6 + 126 , 15 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> blockAliasList . appendTag ( tag ) ; <nl> } <nl> fmlData . setTag ( " BlockAliases " , blockAliasList ) ; <nl> + NBTTagList blockPersistentAliasList = new NBTTagList ( ) ; <nl> + for ( Entry < String , String > entry : GameData . getBlockRegistry ( ) . getPersistentAliases ( ) . entrySet ( ) ) <nl> + { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setString ( " K " , entry . getKey ( ) ) ; <nl> + tag . setString ( " V " , entry . getValue ( ) ) ; <nl> + blockPersistentAliasList . appendTag ( tag ) ; <nl> + } <nl> + fmlData . setTag ( " PersistentBlockAliases " , blockPersistentAliasList ) ; <nl> / / item aliases <nl> NBTTagList itemAliasList = new NBTTagList ( ) ; <nl> for ( Entry < String , String > entry : GameData . getItemRegistry ( ) . getAliases ( ) . entrySet ( ) ) <nl> @ @ - 135 , 6 + 146 , 15 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> } <nl> fmlData . setTag ( " ItemAliases " , itemAliasList ) ; <nl> <nl> + NBTTagList itemPersistentAliasList = new NBTTagList ( ) ; <nl> + for ( Entry < String , String > entry : GameData . getItemRegistry ( ) . getPersistentAliases ( ) . entrySet ( ) ) <nl> + { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setString ( " K " , entry . getKey ( ) ) ; <nl> + tag . setString ( " V " , entry . getValue ( ) ) ; <nl> + itemPersistentAliasList . appendTag ( tag ) ; <nl> + } <nl> + fmlData . setTag ( " ItemPersistentAliases " , itemPersistentAliasList ) ; <nl> return fmlData ; <nl> } <nl> <nl> @ @ - 225 , 6 + 245 , 16 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; <nl> blockAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; <nl> } <nl> + BiMap < String , String > blockPersistentAliases = HashBiMap . create ( ) ; <nl> + if ( tag . hasKey ( " BlockPersistentAliases " , 10 ) ) <nl> + { <nl> + list = tag . getTagList ( " BlockPersistentAliases " , 10 ) ; <nl> + for ( int i = 0 ; i < list . tagCount ( ) ; i + + ) <nl> + { <nl> + NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; <nl> + blockPersistentAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; <nl> + } <nl> + } <nl> / / item aliases <nl> Map < String , String > itemAliases = new HashMap < String , String > ( ) ; <nl> list = tag . getTagList ( " ItemAliases " , 10 ) ; <nl> @ @ - 234 , 6 + 264 , 16 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> itemAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; <nl> } <nl> <nl> + BiMap < String , String > itemPersistentAliases = HashBiMap . create ( ) ; <nl> + if ( tag . hasKey ( " ItemPersistentAliases " , 10 ) ) <nl> + { <nl> + list = tag . getTagList ( " ItemPersistentAliases " , 10 ) ; <nl> + for ( int i = 0 ; i < list . tagCount ( ) ; i + + ) <nl> + { <nl> + NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; <nl> + itemPersistentAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; <nl> + } <nl> + } <nl> failedElements = GameData . injectWorldIDMap ( dataList , blockedIds , blockAliases , itemAliases , true , true ) ; <nl> } <nl> <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java <nl> new file mode 100644 <nl> index 0000000 . . aedd66b <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java <nl> @ @ - 0 , 0 + 1 , 9 @ @ <nl> + package cpw . mods . fml . common . registry ; <nl> + <nl> + public class ExistingAliasException extends Exception { <nl> + public ExistingAliasException ( String fromName , String toName ) { <nl> + } <nl> + <nl> + private static final long serialVersionUID = 1L ; <nl> + <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> index 78adb35 . . 8503c51 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> @ @ - 13 , 6 + 13 , 9 @ @ import net . minecraft . item . ItemBlock ; <nl> import net . minecraft . util . ObjectIntIdentityMap ; <nl> import net . minecraft . util . RegistryNamespaced ; <nl> <nl> + import com . google . common . collect . BiMap ; <nl> + import com . google . common . collect . HashBiMap ; <nl> + import com . google . common . collect . ImmutableBiMap ; <nl> import com . google . common . collect . ImmutableMap ; <nl> <nl> import cpw . mods . fml . common . FMLLog ; <nl> @ @ - 28 , 6 + 31 , 7 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> / / aliases redirecting legacy names to the actual name , may need recursive application to find the final name . <nl> / / these need to be registry specific , it ' s possible to only have a loosely linked item for a block which may get renamed by itself . <nl> private final Map < String , String > aliases = new HashMap < String , String > ( ) ; <nl> + private BiMap < String , String > persistentAliases = HashBiMap . create ( ) ; <nl> <nl> FMLControlledNamespacedRegistry ( String optionalDefault , int maxIdValue , int minIdValue , Class < I > type , char discriminator ) <nl> { <nl> @ @ - 231 , 6 + 235 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> * / <nl> public I getRaw ( String name ) <nl> { <nl> + String aliasName = persistentAliases . get ( name ) ; <nl> + name = aliasName ! = null ? aliasName : name ; <nl> + <nl> I ret = superType . cast ( super . getObject ( name ) ) ; <nl> <nl> if ( ret = = null ) / / no match , try aliases recursively <nl> @ @ - 315 , 6 + 322 , 10 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> return ImmutableMap . copyOf ( aliases ) ; <nl> } <nl> <nl> + public Map < String , String > getPersistentAliases ( ) <nl> + { <nl> + return ImmutableBiMap . copyOf ( persistentAliases ) ; <nl> + } <nl> / * * <nl> * Add the specified object to the registry . <nl> * <nl> @ @ - 429 , 4 + 440 , 12 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> public RegistryDelegate < I > getDelegate ( I thing , Class < I > clazz ) { <nl> return GameData . buildDelegate ( thing , clazz ) ; <nl> } <nl> + <nl> + public void addPersistentAlias ( String fromName , String toName ) throws ExistingAliasException { <nl> + if ( persistentAliases . containsKey ( fromName ) | | persistentAliases . containsKey ( toName ) | | persistentAliases . containsValue ( fromName ) | | persistentAliases . containsValue ( toName ) ) <nl> + { <nl> + throw new ExistingAliasException ( fromName , toName ) ; <nl> + } <nl> + persistentAliases . put ( fromName , toName ) ; <nl> + } <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> index e701bad . . 5394989 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> @ @ - 949 , 6 + 949 , 10 @ @ public class GameData { <nl> FMLLog . fine ( " Registry consistency check successful " ) ; <nl> } <nl> <nl> + void registerPersistentAlias ( String fromName , String toName , GameRegistry . Type type ) throws ExistingAliasException <nl> + { <nl> + type . getRegistry ( ) . addPersistentAlias ( fromName , toName ) ; <nl> + } <nl> static < T > RegistryDelegate < T > buildDelegate ( T referant , Class < T > type ) <nl> { <nl> return new RegistryDelegate . Delegate < T > ( referant , type ) ; <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> index dfd90f6 . . 6a26bb3 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> @ @ - 145 , 9 + 145 , 19 @ @ public class GameRegistry <nl> } <nl> <nl> <nl> - public static void addAlias ( String alias , String forName , GameRegistry . Type type ) <nl> + / * * <nl> + * Add a forced persistent alias for the block or item to another block or item . This will have <nl> + * the effect of using the substituted block or item instead of the original , whereever it is <nl> + * referenced . <nl> + * <nl> + * @ param toName The name to link to ( this is the NEW block or item ) <nl> + * @ param fromName The name to link from ( this is the OLD block or item being substituted ) <nl> + * @ param type The type ( Block or Item ) <nl> + * @ throws ExistingAliasException if someone else has already registered an alias either from or to one of the names <nl> + * / <nl> + public static void addAlias ( String toName , String fromName , GameRegistry . Type type ) throws ExistingAliasException <nl> { <nl> - <nl> + GameData . getMain ( ) . registerPersistentAlias ( fromName , toName , type ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 300 , 67 + 310 , 67 @ @ public class GameRegistry <nl> } <nl> <nl> / * * <nl> - 	 * Look up a mod block in the global " named item list " <nl> - 	 * @ param modId The modid owning the block <nl> - 	 * @ param name The name of the block itself <nl> - 	 * @ return The block or null if not found <nl> - 	 * / <nl> - 	 public static Block findBlock ( String modId , String name ) <nl> - 	 { <nl> - 	 return GameData . findBlock ( modId , name ) ; <nl> - 	 } <nl> - <nl> - 	 / * * <nl> - 	 * Look up a mod item in the global " named item list " <nl> - 	 * @ param modId The modid owning the item <nl> - 	 * @ param name The name of the item itself <nl> - 	 * @ return The item or null if not found <nl> - 	 * / <nl> - 	 public static Item findItem ( String modId , String name ) <nl> + * Look up a mod block in the global " named item list " <nl> + * @ param modId The modid owning the block <nl> + * @ param name The name of the block itself <nl> + * @ return The block or null if not found <nl> + * / <nl> + public static Block findBlock ( String modId , String name ) <nl> + { <nl> + return GameData . findBlock ( modId , name ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Look up a mod item in the global " named item list " <nl> + * @ param modId The modid owning the item <nl> + * @ param name The name of the item itself <nl> + * @ return The item or null if not found <nl> + * / <nl> + public static Item findItem ( String modId , String name ) <nl> { <nl> return GameData . findItem ( modId , name ) ; <nl> } <nl> <nl> - 	 / * * <nl> - 	 * Manually register a custom item stack with FML for later tracking . It is automatically scoped with the active modid <nl> - 	 * <nl> - 	 * @ param name The name to register it under <nl> - 	 * @ param itemStack The itemstack to register <nl> - 	 * / <nl> - 	 public static void registerCustomItemStack ( String name , ItemStack itemStack ) <nl> - 	 { <nl> - 	 GameData . registerCustomItemStack ( name , itemStack ) ; <nl> - 	 } <nl> - 	 / * * <nl> - 	 * Lookup an itemstack based on mod and name . It will create " default " itemstacks from blocks and items if no <nl> - 	 * explicit itemstack is found . <nl> - 	 * <nl> - 	 * If it is built from a block , the metadata is by default the " wildcard " value . <nl> - 	 * <nl> - 	 * Custom itemstacks can be dumped from minecraft by setting the system property fml . dumpRegistry to true <nl> - 	 * ( - Dfml . dumpRegistry = true on the command line will work ) <nl> - 	 * <nl> - 	 * @ param modId The modid of the stack owner <nl> - 	 * @ param name The name of the stack <nl> - 	 * @ param stackSize The size of the stack returned <nl> - 	 * @ return The custom itemstack or null if no such itemstack was found <nl> - 	 * / <nl> - 	 public static ItemStack findItemStack ( String modId , String name , int stackSize ) <nl> - 	 { <nl> - 	 ItemStack foundStack = GameData . findItemStack ( modId , name ) ; <nl> - 	 if ( foundStack ! = null ) <nl> - 	 { <nl> + / * * <nl> + * Manually register a custom item stack with FML for later tracking . It is automatically scoped with the active modid <nl> + * <nl> + * @ param name The name to register it under <nl> + * @ param itemStack The itemstack to register <nl> + * / <nl> + public static void registerCustomItemStack ( String name , ItemStack itemStack ) <nl> + { <nl> + GameData . registerCustomItemStack ( name , itemStack ) ; <nl> + } <nl> + / * * <nl> + * Lookup an itemstack based on mod and name . It will create " default " itemstacks from blocks and items if no <nl> + * explicit itemstack is found . <nl> + * <nl> + * If it is built from a block , the metadata is by default the " wildcard " value . <nl> + * <nl> + * Custom itemstacks can be dumped from minecraft by setting the system property fml . dumpRegistry to true <nl> + * ( - Dfml . dumpRegistry = true on the command line will work ) <nl> + * <nl> + * @ param modId The modid of the stack owner <nl> + * @ param name The name of the stack <nl> + * @ param stackSize The size of the stack returned <nl> + * @ return The custom itemstack or null if no such itemstack was found <nl> + * / <nl> + public static ItemStack findItemStack ( String modId , String name , int stackSize ) <nl> + { <nl> + ItemStack foundStack = GameData . findItemStack ( modId , name ) ; <nl> + if ( foundStack ! = null ) <nl> + { <nl> ItemStack is = foundStack . copy ( ) ; <nl> - 	 is . stackSize = Math . min ( stackSize , is . getMaxStackSize ( ) ) ; <nl> - 	 return is ; <nl> - 	 } <nl> - 	 return null ; <nl> - 	 } <nl> - <nl> - 	 public static final class UniqueIdentifier <nl> - 	 { <nl> - 	 public final String modId ; <nl> - 	 public final String name ; <nl> + is . stackSize = Math . min ( stackSize , is . getMaxStackSize ( ) ) ; <nl> + return is ; <nl> + } <nl> + return null ; <nl> + } <nl> + <nl> + public static final class UniqueIdentifier <nl> + { <nl> + public final String modId ; <nl> + public final String name ; <nl> UniqueIdentifier ( String modId , String name ) <nl> { <nl> this . modId = modId ; <nl> @ @ - 394 , 24 + 404 , 41 @ @ public class GameRegistry <nl> { <nl> return String . format ( " % s : % s " , modId , name ) ; <nl> } <nl> - 	 } <nl> + } <nl> + <nl> + public static enum Type { <nl> + BLOCK <nl> + { <nl> + @ Override <nl> + public FMLControlledNamespacedRegistry < ? > getRegistry ( ) { <nl> + return GameData . getBlockRegistry ( ) ; <nl> + } <nl> + } , <nl> + ITEM <nl> + { <nl> + @ Override <nl> + public FMLControlledNamespacedRegistry < ? > getRegistry ( ) { <nl> + return GameData . getItemRegistry ( ) ; <nl> + } <nl> + } ; <nl> <nl> - 	 public static enum Type { BLOCK , ITEM } <nl> + public abstract FMLControlledNamespacedRegistry < ? > getRegistry ( ) ; <nl> + } <nl> / * * <nl> - 	 * Look up the mod identifier data for a block . <nl> - 	 * Returns null if there is no mod specified mod identifier data , or it is part of a <nl> - 	 * custom itemstack definition { @ link # registerCustomItemStack } <nl> - 	 * <nl> - 	 * Note : uniqueness and persistence is only guaranteed by mods using the game registry <nl> - 	 * correctly . <nl> - 	 * <nl> - 	 * @ param block to lookup <nl> + * Look up the mod identifier data for a block . <nl> + * Returns null if there is no mod specified mod identifier data , or it is part of a <nl> + * custom itemstack definition { @ link # registerCustomItemStack } <nl> + * <nl> + * Note : uniqueness and persistence is only guaranteed by mods using the game registry <nl> + * correctly . <nl> + * <nl> + * @ param block to lookup <nl> * @ return a { @ link UniqueIdentifier } for the block or null <nl> - 	 * / <nl> - 	 public static UniqueIdentifier findUniqueIdentifierFor ( Block block ) <nl> - 	 { <nl> - 	 return GameData . getUniqueName ( block ) ; <nl> - 	 } <nl> + * / <nl> + public static UniqueIdentifier findUniqueIdentifierFor ( Block block ) <nl> + { <nl> + return GameData . getUniqueName ( block ) ; <nl> + } <nl> / * * <nl> * Look up the mod identifier data for an item . <nl> * Returns null if there is no mod specified mod identifier data , or it is part of a

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / GameRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / GameRegistry . java 
 index 41bf24b . . 290b225 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / GameRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / GameRegistry . java 
 @ @ - 133 , 6 + 133 , 8 @ @ public class GameRegistry 
 * Always ensure the object is already named using { @ link IForgeRegistryEntry # setRegistryName ( ResourceLocation ) } 
 * or another mechanism . 
 * 
 + * Note : That DOES NOT create the ItemBlock for you if this is a Block , you should register that item separately . 
 + * 
 * @ param object The object to register with a registry 
 * @ param < K > The registry supertype 
 * @ throws IllegalArgumentException if the object is not yet named ( use { @ link # register ( IForgeRegistryEntry , ResourceLocation ) } instead ) 
 @ @ - 147 , 6 + 149 , 10 @ @ public class GameRegistry 
 * Register the unnamed { @ link IForgeRegistry } object with the registry system . 
 * Always make sure you have not previously named the object . 
 * 
 + * It is advised that you set the object ' s registry name and use { @ link # register ( IForgeRegistryEntry ) } instead . 
 + * 
 + * Note : That DOES NOT create the ItemBlock for you if this is a Block , you should register that item separately . 
 + * 
 * @ param object The object to register 
 * @ param name The name to register it with 
 * @ param < K > The registry supertype 
 @ @ - 157 , 31 + 163 , 23 @ @ public class GameRegistry 
 { 
 return GameData . register ( object , name ) ; 
 } 
 - / * * 
 - * Register an item with the item registry with a the name specified in Item . getRegistryName ( ) 
 - * 
 - * @ param item The item to register 
 - * / 
 - @ Deprecated 
 - public static void registerItem ( Item item ) 
 - { 
 - registerItem ( item , item . getRegistryName ( ) . toString ( ) ) ; 
 - } 
 + 
 
 / * * 
 - * Register an item with the item registry with a custom name : this allows for easier server - > client resolution 
 + * Registers a named block with the Block registry . This WILL create a new ItemBlock for you with the 
 + * same name and register it with the ItemRegistry . This method is created as a convince method for 
 + * modder and SHOULD NOT be used . Modders should create and register their ItemBlocks like normal items . 
 * 
 - * @ param item The item to register 
 - * @ param name The mod - unique name of the item 
 + * @ param block The block to register with a registry 
 + * @ throws IllegalArgumentException if the object is not yet named 
 + * @ return The block 
 * / 
 - @ Deprecated 
 - public static void registerItem ( Item item , String name ) 
 + @ Deprecated / / Modders SHOULD NOT use this , so it ' ll stay deprecated . Purely added to make lazy modders happy - . - 
 + public static Block registerWithItem ( Block block ) 
 { 
 - if ( Strings . isNullOrEmpty ( name ) ) 
 - { 
 - throw new IllegalArgumentException ( " Attempted to register a block with no name : " + item ) ; 
 - } 
 - GameData . getMain ( ) . registerItem ( item , name ) ; 
 + register ( block ) ; 
 + register ( new ItemBlock ( block ) . setRegistryName ( block . getRegistryName ( ) ) ) ; 
 + return block ; 
 } 
 
 / * * 
 @ @ - 200 , 117 + 198 , 6 @ @ public class GameRegistry 
 GameData . getMain ( ) . registerSubstitutionAlias ( nameToSubstitute , type , object ) ; 
 } 
 
 - / * * 
 - * Register a block with the name that Block . getRegistryName returns . 
 - * 
 - * @ param block The block to register 
 - * / 
 - @ Deprecated 
 - public static Block registerBlock ( Block block ) 
 - { 
 - return registerBlock ( block , block . getRegistryName ( ) . toString ( ) ) ; 
 - } 
 - 
 - / * * 
 - * Register a block with the specified mod specific name 
 - * 
 - * @ param block The block to register 
 - * @ param name The mod - unique name to register it as , will get prefixed by your modid . 
 - * / 
 - @ Deprecated 
 - public static Block registerBlock ( Block block , String name ) 
 - { 
 - return registerBlock ( block , ItemBlock . class , name ) ; 
 - } 
 - 
 - / * * 
 - * Register a block with the world , with the specified item class using Block . getRegistryName ' s name 
 - * 
 - * @ param block The block to register 
 - * @ param itemclass The item type to register with it : null registers a block without associated item . 
 - * / 
 - @ Deprecated 
 - public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass ) 
 - { 
 - return registerBlock ( block , itemclass , block . getRegistryName ( ) ) ; 
 - } 
 - 
 - / * * 
 - * Register a block with the world , with the specified item class and block name 
 - * 
 - * @ param block The block to register 
 - * @ param itemclass The item type to register with it : null registers a block without associated item . 
 - * @ param name The mod - unique name to register it as , will get prefixed by your modid . 
 - * / 
 - @ Deprecated 
 - public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , String name ) 
 - { 
 - return registerBlock ( block , itemclass , name , new Object [ ] { } ) ; 
 - } 
 - 
 - 
 - / * * 
 - * Register a block with the world , with the specified item class using Block . getRegistryName ' s name 
 - * 
 - * @ param block The block to register 
 - * @ param itemclass The item type to register with it : null registers a block without associated item . 
 - * @ param itemCtorArgs Arguments to pass ( after the required { @ code Block } parameter ) to the ItemBlock constructor ( optional ) . 
 - * / 
 - @ Deprecated 
 - public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , Object . . . itemCtorArgs ) 
 - { 
 - return registerBlock ( block , itemclass , block . getRegistryName ( ) . toString ( ) , itemCtorArgs ) ; 
 - } 
 - 
 - / * * 
 - * Register a block with the world , with the specified item class , block name and owning modId 
 - * 
 - * @ param block The block to register 
 - * @ param itemclass The item type to register with it : null registers a block without associated item . 
 - * @ param name The mod - unique name to register it as , will get prefixed by your modid . 
 - * @ param itemCtorArgs Arguments to pass ( after the required { @ code Block } parameter ) to the ItemBlock constructor ( optional ) . 
 - * / 
 - @ Deprecated 
 - public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , String name , Object . . . itemCtorArgs ) 
 - { 
 - if ( Strings . isNullOrEmpty ( name ) ) 
 - { 
 - throw new IllegalArgumentException ( " Attempted to register a block with no name : " + block ) ; 
 - } 
 - if ( Loader . instance ( ) . isInState ( LoaderState . CONSTRUCTING ) ) 
 - { 
 - FMLLog . warning ( " The mod % s is attempting to register a block whilst it it being constructed . This is bad modding practice - please use a proper mod lifecycle event . " , Loader . instance ( ) . activeModContainer ( ) ) ; 
 - } 
 - try 
 - { 
 - assert block ! = null : " registerBlock : block cannot be null " ; 
 - ItemBlock i = null ; 
 - if ( itemclass ! = null ) 
 - { 
 - Class < ? > [ ] ctorArgClasses = new Class < ? > [ itemCtorArgs . length + 1 ] ; 
 - ctorArgClasses [ 0 ] = Block . class ; 
 - for ( int idx = 1 ; idx < ctorArgClasses . length ; idx + + ) 
 - { 
 - ctorArgClasses [ idx ] = itemCtorArgs [ idx - 1 ] . getClass ( ) ; 
 - } 
 - Constructor < ? extends ItemBlock > itemCtor = itemclass . getConstructor ( ctorArgClasses ) ; 
 - i = itemCtor . newInstance ( ObjectArrays . concat ( block , itemCtorArgs ) ) ; 
 - } 
 - / / block registration has to happen first 
 - GameData . getMain ( ) . registerBlock ( block , name ) ; 
 - if ( i ! = null ) 
 - { 
 - GameData . getMain ( ) . registerItem ( i , name ) ; 
 - GameData . getBlockItemMap ( ) . put ( block , i ) ; 
 - } 
 - return block ; 
 - } catch ( Exception e ) 
 - { 
 - FMLLog . log ( Level . ERROR , e , " Caught an exception during block registration " ) ; 
 - throw new LoaderException ( e ) ; 
 - } 
 - } 
 - 
 public static void addRecipe ( ItemStack output , Object . . . params ) 
 { 
 addShapedRecipe ( output , params ) ; 
 @ @ - 387 , 32 + 274 , 6 @ @ public class GameRegistry 
 return fuelValue ; 
 } 
 
 - / * * 
 - * Look up a mod block in the global " named item list " 
 - * 
 - * @ param modId The modid owning the block 
 - * @ param name The name of the block itself 
 - * @ return The block or null if not found 
 - * / 
 - @ Deprecated 
 - public static Block findBlock ( String modId , String name ) 
 - { 
 - return GameData . findBlock ( modId , name ) ; 
 - } 
 - 
 - / * * 
 - * Look up a mod item in the global " named item list " 
 - * 
 - * @ param modId The modid owning the item 
 - * @ param name The name of the item itself 
 - * @ return The item or null if not found 
 - * / 
 - @ Deprecated 
 - public static Item findItem ( String modId , String name ) 
 - { 
 - return GameData . findItem ( modId , name ) ; 
 - } 
 - 
 public enum Type 
 { 
 BLOCK , 
 @ @ - 520 , 4 + 381 , 132 @ @ public class GameRegistry 
 return is ; 
 } 
 
 + 
 + 
 + 
 + / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = DEPRECATED / INTERNAL MODDERS DO NOT USE = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 + / * * 
 + * Use { @ link # register ( IForgeRegistryEntry ) } instead 
 + * / 
 + @ Deprecated public static void registerItem ( Item item ) { register ( item ) ; } 
 + / * * 
 + * Use { @ link # register ( IForgeRegistryEntry ) } instead 
 + * / 
 + @ Deprecated 
 + public static void registerItem ( Item item , String name ) 
 + { 
 + if ( item . getRegistryName ( ) = = null & & Strings . isNullOrEmpty ( name ) ) 
 + throw new IllegalArgumentException ( " Attempted to register a item with no name : " + item ) ; 
 + if ( item . getRegistryName ( ) ! = null & & ! item . getRegistryName ( ) . toString ( ) . equals ( name ) ) 
 + throw new IllegalArgumentException ( " Attempted to register a item with conflicting names . Old : " + item . getRegistryName ( ) + " New : " + name ) ; 
 + register ( item . getRegistryName ( ) = = null ? item . setRegistryName ( name ) : item ) ; 
 + } 
 + / * * 
 + * Use { @ link # register ( IForgeRegistryEntry ) } instead 
 + * / 
 + @ Deprecated 
 + public static Block registerBlock ( Block block ) 
 + { 
 + register ( block ) ; 
 + register ( new ItemBlock ( block ) . setRegistryName ( block . getRegistryName ( ) ) ) ; 
 + return block ; 
 + } 
 + / * * 
 + * Use { @ link # register ( IForgeRegistryEntry ) } instead 
 + * / 
 + @ Deprecated 
 + public static Block registerBlock ( Block block , String name ) 
 + { 
 + if ( block . getRegistryName ( ) = = null & & Strings . isNullOrEmpty ( name ) ) 
 + throw new IllegalArgumentException ( " Attempted to register a Block with no name : " + block ) ; 
 + if ( block . getRegistryName ( ) ! = null & & ! block . getRegistryName ( ) . toString ( ) . equals ( name ) ) 
 + throw new IllegalArgumentException ( " Attempted to register a Block with conflicting names . Old : " + block . getRegistryName ( ) + " New : " + name ) ; 
 + return registerBlock ( block . getRegistryName ( ) ! = null ? block : block . setRegistryName ( name ) ) ; 
 + } 
 + / * * 
 + * Use { @ link # register ( IForgeRegistryEntry ) } instead 
 + * / 
 + @ Deprecated public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass ) { return registerBlock ( block , itemclass , block . getRegistryName ( ) ) ; } 
 + / * * 
 + * Use { @ link # register ( IForgeRegistryEntry ) } instead 
 + * / 
 + @ Deprecated public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , String name ) { return registerBlock ( block , itemclass , name , new Object [ ] { } ) ; } 
 + / * * 
 + * Use { @ link # register ( IForgeRegistryEntry ) } instead 
 + * / 
 + @ Deprecated public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , Object . . . itemCtorArgs ) { return registerBlock ( block , itemclass , block . getRegistryName ( ) . toString ( ) , itemCtorArgs ) ; } 
 + / * * 
 + * Use { @ link # register ( IForgeRegistryEntry ) } instead 
 + * / 
 + @ Deprecated 
 + public static Block registerBlock ( Block block , Class < ? extends ItemBlock > itemclass , String name , Object . . . itemCtorArgs ) 
 + { 
 + if ( Strings . isNullOrEmpty ( name ) ) 
 + { 
 + throw new IllegalArgumentException ( " Attempted to register a block with no name : " + block ) ; 
 + } 
 + if ( Loader . instance ( ) . isInState ( LoaderState . CONSTRUCTING ) ) 
 + { 
 + FMLLog . warning ( " The mod % s is attempting to register a block whilst it it being constructed . This is bad modding practice - please use a proper mod lifecycle event . " , Loader . instance ( ) . activeModContainer ( ) ) ; 
 + } 
 + try 
 + { 
 + assert block ! = null : " registerBlock : block cannot be null " ; 
 + if ( block . getRegistryName ( ) ! = null & & ! block . getRegistryName ( ) . toString ( ) . equals ( name ) ) 
 + throw new IllegalArgumentException ( " Attempted to register a Block with conflicting names . Old : " + block . getRegistryName ( ) + " New : " + name ) ; 
 + ItemBlock i = null ; 
 + if ( itemclass ! = null ) 
 + { 
 + Class < ? > [ ] ctorArgClasses = new Class < ? > [ itemCtorArgs . length + 1 ] ; 
 + ctorArgClasses [ 0 ] = Block . class ; 
 + for ( int idx = 1 ; idx < ctorArgClasses . length ; idx + + ) 
 + { 
 + ctorArgClasses [ idx ] = itemCtorArgs [ idx - 1 ] . getClass ( ) ; 
 + } 
 + Constructor < ? extends ItemBlock > itemCtor = itemclass . getConstructor ( ctorArgClasses ) ; 
 + i = itemCtor . newInstance ( ObjectArrays . concat ( block , itemCtorArgs ) ) ; 
 + } 
 + / / block registration has to happen first 
 + register ( block . getRegistryName ( ) = = null ? block . setRegistryName ( name ) : block ) ; 
 + if ( i ! = null ) 
 + register ( i . setRegistryName ( name ) ) ; 
 + return block ; 
 + } catch ( Exception e ) 
 + { 
 + FMLLog . log ( Level . ERROR , e , " Caught an exception during block registration " ) ; 
 + throw new LoaderException ( e ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * 
 + * Use Block . REGISTRY . getValue ( ResourceLocation ) instead ! 
 + * 
 + * 
 + * Look up a mod block in the global " named item list " 
 + * 
 + * @ param modId The modid owning the block 
 + * @ param name The name of the block itself 
 + * @ return The block or null if not found 
 + * / 
 + @ Deprecated 
 + public static Block findBlock ( String modId , String name ) 
 + { 
 + return GameData . findBlock ( modId , name ) ; 
 + } 
 + 
 + / * * 
 + * Use Item . REGISTRY . getValue ( ResourceLocation ) instead ! 
 + * 
 + * Look up a mod item in the global " named item list " 
 + * 
 + * @ param modId The modid owning the item 
 + * @ param name The name of the item itself 
 + * @ return The item or null if not found 
 + * / 
 + @ Deprecated 
 + public static Item findItem ( String modId , String name ) 
 + { 
 + return GameData . findItem ( modId , name ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java b / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java 
 index fd20bb7 . . 03f8e58 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java 
 @ @ - 30 , 6 + 30 , 8 @ @ import net . minecraft . world . storage . WorldInfo ; 
 
 import org . apache . logging . log4j . Level ; 
 
 + import com . google . common . collect . BiMap ; 
 + import com . google . common . collect . HashBiMap ; 
 import com . google . common . collect . Maps ; 
 import com . google . common . eventbus . EventBus ; 
 import com . google . common . eventbus . Subscribe ; 
 @ @ - 124 , 6 + 126 , 15 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 blockAliasList . appendTag ( tag ) ; 
 } 
 fmlData . setTag ( " BlockAliases " , blockAliasList ) ; 
 + NBTTagList blockPersistentAliasList = new NBTTagList ( ) ; 
 + for ( Entry < String , String > entry : GameData . getBlockRegistry ( ) . getPersistentAliases ( ) . entrySet ( ) ) 
 + { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setString ( " K " , entry . getKey ( ) ) ; 
 + tag . setString ( " V " , entry . getValue ( ) ) ; 
 + blockPersistentAliasList . appendTag ( tag ) ; 
 + } 
 + fmlData . setTag ( " PersistentBlockAliases " , blockPersistentAliasList ) ; 
 / / item aliases 
 NBTTagList itemAliasList = new NBTTagList ( ) ; 
 for ( Entry < String , String > entry : GameData . getItemRegistry ( ) . getAliases ( ) . entrySet ( ) ) 
 @ @ - 135 , 6 + 146 , 15 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 } 
 fmlData . setTag ( " ItemAliases " , itemAliasList ) ; 
 
 + NBTTagList itemPersistentAliasList = new NBTTagList ( ) ; 
 + for ( Entry < String , String > entry : GameData . getItemRegistry ( ) . getPersistentAliases ( ) . entrySet ( ) ) 
 + { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setString ( " K " , entry . getKey ( ) ) ; 
 + tag . setString ( " V " , entry . getValue ( ) ) ; 
 + itemPersistentAliasList . appendTag ( tag ) ; 
 + } 
 + fmlData . setTag ( " ItemPersistentAliases " , itemPersistentAliasList ) ; 
 return fmlData ; 
 } 
 
 @ @ - 225 , 6 + 245 , 16 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; 
 blockAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; 
 } 
 + BiMap < String , String > blockPersistentAliases = HashBiMap . create ( ) ; 
 + if ( tag . hasKey ( " BlockPersistentAliases " , 10 ) ) 
 + { 
 + list = tag . getTagList ( " BlockPersistentAliases " , 10 ) ; 
 + for ( int i = 0 ; i < list . tagCount ( ) ; i + + ) 
 + { 
 + NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; 
 + blockPersistentAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; 
 + } 
 + } 
 / / item aliases 
 Map < String , String > itemAliases = new HashMap < String , String > ( ) ; 
 list = tag . getTagList ( " ItemAliases " , 10 ) ; 
 @ @ - 234 , 6 + 264 , 16 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 itemAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; 
 } 
 
 + BiMap < String , String > itemPersistentAliases = HashBiMap . create ( ) ; 
 + if ( tag . hasKey ( " ItemPersistentAliases " , 10 ) ) 
 + { 
 + list = tag . getTagList ( " ItemPersistentAliases " , 10 ) ; 
 + for ( int i = 0 ; i < list . tagCount ( ) ; i + + ) 
 + { 
 + NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; 
 + itemPersistentAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; 
 + } 
 + } 
 failedElements = GameData . injectWorldIDMap ( dataList , blockedIds , blockAliases , itemAliases , true , true ) ; 
 } 
 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java 
 new file mode 100644 
 index 0000000 . . aedd66b 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java 
 @ @ - 0 , 0 + 1 , 9 @ @ 
 + package cpw . mods . fml . common . registry ; 
 + 
 + public class ExistingAliasException extends Exception { 
 + public ExistingAliasException ( String fromName , String toName ) { 
 + } 
 + 
 + private static final long serialVersionUID = 1L ; 
 + 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 index 78adb35 . . 8503c51 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 @ @ - 13 , 6 + 13 , 9 @ @ import net . minecraft . item . ItemBlock ; 
 import net . minecraft . util . ObjectIntIdentityMap ; 
 import net . minecraft . util . RegistryNamespaced ; 
 
 + import com . google . common . collect . BiMap ; 
 + import com . google . common . collect . HashBiMap ; 
 + import com . google . common . collect . ImmutableBiMap ; 
 import com . google . common . collect . ImmutableMap ; 
 
 import cpw . mods . fml . common . FMLLog ; 
 @ @ - 28 , 6 + 31 , 7 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 / / aliases redirecting legacy names to the actual name , may need recursive application to find the final name . 
 / / these need to be registry specific , it ' s possible to only have a loosely linked item for a block which may get renamed by itself . 
 private final Map < String , String > aliases = new HashMap < String , String > ( ) ; 
 + private BiMap < String , String > persistentAliases = HashBiMap . create ( ) ; 
 
 FMLControlledNamespacedRegistry ( String optionalDefault , int maxIdValue , int minIdValue , Class < I > type , char discriminator ) 
 { 
 @ @ - 231 , 6 + 235 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 * / 
 public I getRaw ( String name ) 
 { 
 + String aliasName = persistentAliases . get ( name ) ; 
 + name = aliasName ! = null ? aliasName : name ; 
 + 
 I ret = superType . cast ( super . getObject ( name ) ) ; 
 
 if ( ret = = null ) / / no match , try aliases recursively 
 @ @ - 315 , 6 + 322 , 10 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 return ImmutableMap . copyOf ( aliases ) ; 
 } 
 
 + public Map < String , String > getPersistentAliases ( ) 
 + { 
 + return ImmutableBiMap . copyOf ( persistentAliases ) ; 
 + } 
 / * * 
 * Add the specified object to the registry . 
 * 
 @ @ - 429 , 4 + 440 , 12 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 public RegistryDelegate < I > getDelegate ( I thing , Class < I > clazz ) { 
 return GameData . buildDelegate ( thing , clazz ) ; 
 } 
 + 
 + public void addPersistentAlias ( String fromName , String toName ) throws ExistingAliasException { 
 + if ( persistentAliases . containsKey ( fromName ) | | persistentAliases . containsKey ( toName ) | | persistentAliases . containsValue ( fromName ) | | persistentAliases . containsValue ( toName ) ) 
 + { 
 + throw new ExistingAliasException ( fromName , toName ) ; 
 + } 
 + persistentAliases . put ( fromName , toName ) ; 
 + } 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 index e701bad . . 5394989 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 @ @ - 949 , 6 + 949 , 10 @ @ public class GameData { 
 FMLLog . fine ( " Registry consistency check successful " ) ; 
 } 
 
 + void registerPersistentAlias ( String fromName , String toName , GameRegistry . Type type ) throws ExistingAliasException 
 + { 
 + type . getRegistry ( ) . addPersistentAlias ( fromName , toName ) ; 
 + } 
 static < T > RegistryDelegate < T > buildDelegate ( T referant , Class < T > type ) 
 { 
 return new RegistryDelegate . Delegate < T > ( referant , type ) ; 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 index dfd90f6 . . 6a26bb3 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 @ @ - 145 , 9 + 145 , 19 @ @ public class GameRegistry 
 } 
 
 
 - public static void addAlias ( String alias , String forName , GameRegistry . Type type ) 
 + / * * 
 + * Add a forced persistent alias for the block or item to another block or item . This will have 
 + * the effect of using the substituted block or item instead of the original , whereever it is 
 + * referenced . 
 + * 
 + * @ param toName The name to link to ( this is the NEW block or item ) 
 + * @ param fromName The name to link from ( this is the OLD block or item being substituted ) 
 + * @ param type The type ( Block or Item ) 
 + * @ throws ExistingAliasException if someone else has already registered an alias either from or to one of the names 
 + * / 
 + public static void addAlias ( String toName , String fromName , GameRegistry . Type type ) throws ExistingAliasException 
 { 
 - 
 + GameData . getMain ( ) . registerPersistentAlias ( fromName , toName , type ) ; 
 } 
 
 / * * 
 @ @ - 300 , 67 + 310 , 67 @ @ public class GameRegistry 
 } 
 
 / * * 
 - 	 * Look up a mod block in the global " named item list " 
 - 	 * @ param modId The modid owning the block 
 - 	 * @ param name The name of the block itself 
 - 	 * @ return The block or null if not found 
 - 	 * / 
 - 	 public static Block findBlock ( String modId , String name ) 
 - 	 { 
 - 	 return GameData . findBlock ( modId , name ) ; 
 - 	 } 
 - 
 - 	 / * * 
 - 	 * Look up a mod item in the global " named item list " 
 - 	 * @ param modId The modid owning the item 
 - 	 * @ param name The name of the item itself 
 - 	 * @ return The item or null if not found 
 - 	 * / 
 - 	 public static Item findItem ( String modId , String name ) 
 + * Look up a mod block in the global " named item list " 
 + * @ param modId The modid owning the block 
 + * @ param name The name of the block itself 
 + * @ return The block or null if not found 
 + * / 
 + public static Block findBlock ( String modId , String name ) 
 + { 
 + return GameData . findBlock ( modId , name ) ; 
 + } 
 + 
 + / * * 
 + * Look up a mod item in the global " named item list " 
 + * @ param modId The modid owning the item 
 + * @ param name The name of the item itself 
 + * @ return The item or null if not found 
 + * / 
 + public static Item findItem ( String modId , String name ) 
 { 
 return GameData . findItem ( modId , name ) ; 
 } 
 
 - 	 / * * 
 - 	 * Manually register a custom item stack with FML for later tracking . It is automatically scoped with the active modid 
 - 	 * 
 - 	 * @ param name The name to register it under 
 - 	 * @ param itemStack The itemstack to register 
 - 	 * / 
 - 	 public static void registerCustomItemStack ( String name , ItemStack itemStack ) 
 - 	 { 
 - 	 GameData . registerCustomItemStack ( name , itemStack ) ; 
 - 	 } 
 - 	 / * * 
 - 	 * Lookup an itemstack based on mod and name . It will create " default " itemstacks from blocks and items if no 
 - 	 * explicit itemstack is found . 
 - 	 * 
 - 	 * If it is built from a block , the metadata is by default the " wildcard " value . 
 - 	 * 
 - 	 * Custom itemstacks can be dumped from minecraft by setting the system property fml . dumpRegistry to true 
 - 	 * ( - Dfml . dumpRegistry = true on the command line will work ) 
 - 	 * 
 - 	 * @ param modId The modid of the stack owner 
 - 	 * @ param name The name of the stack 
 - 	 * @ param stackSize The size of the stack returned 
 - 	 * @ return The custom itemstack or null if no such itemstack was found 
 - 	 * / 
 - 	 public static ItemStack findItemStack ( String modId , String name , int stackSize ) 
 - 	 { 
 - 	 ItemStack foundStack = GameData . findItemStack ( modId , name ) ; 
 - 	 if ( foundStack ! = null ) 
 - 	 { 
 + / * * 
 + * Manually register a custom item stack with FML for later tracking . It is automatically scoped with the active modid 
 + * 
 + * @ param name The name to register it under 
 + * @ param itemStack The itemstack to register 
 + * / 
 + public static void registerCustomItemStack ( String name , ItemStack itemStack ) 
 + { 
 + GameData . registerCustomItemStack ( name , itemStack ) ; 
 + } 
 + / * * 
 + * Lookup an itemstack based on mod and name . It will create " default " itemstacks from blocks and items if no 
 + * explicit itemstack is found . 
 + * 
 + * If it is built from a block , the metadata is by default the " wildcard " value . 
 + * 
 + * Custom itemstacks can be dumped from minecraft by setting the system property fml . dumpRegistry to true 
 + * ( - Dfml . dumpRegistry = true on the command line will work ) 
 + * 
 + * @ param modId The modid of the stack owner 
 + * @ param name The name of the stack 
 + * @ param stackSize The size of the stack returned 
 + * @ return The custom itemstack or null if no such itemstack was found 
 + * / 
 + public static ItemStack findItemStack ( String modId , String name , int stackSize ) 
 + { 
 + ItemStack foundStack = GameData . findItemStack ( modId , name ) ; 
 + if ( foundStack ! = null ) 
 + { 
 ItemStack is = foundStack . copy ( ) ; 
 - 	 is . stackSize = Math . min ( stackSize , is . getMaxStackSize ( ) ) ; 
 - 	 return is ; 
 - 	 } 
 - 	 return null ; 
 - 	 } 
 - 
 - 	 public static final class UniqueIdentifier 
 - 	 { 
 - 	 public final String modId ; 
 - 	 public final String name ; 
 + is . stackSize = Math . min ( stackSize , is . getMaxStackSize ( ) ) ; 
 + return is ; 
 + } 
 + return null ; 
 + } 
 + 
 + public static final class UniqueIdentifier 
 + { 
 + public final String modId ; 
 + public final String name ; 
 UniqueIdentifier ( String modId , String name ) 
 { 
 this . modId = modId ; 
 @ @ - 394 , 24 + 404 , 41 @ @ public class GameRegistry 
 { 
 return String . format ( " % s : % s " , modId , name ) ; 
 } 
 - 	 } 
 + } 
 + 
 + public static enum Type { 
 + BLOCK 
 + { 
 + @ Override 
 + public FMLControlledNamespacedRegistry < ? > getRegistry ( ) { 
 + return GameData . getBlockRegistry ( ) ; 
 + } 
 + } , 
 + ITEM 
 + { 
 + @ Override 
 + public FMLControlledNamespacedRegistry < ? > getRegistry ( ) { 
 + return GameData . getItemRegistry ( ) ; 
 + } 
 + } ; 
 
 - 	 public static enum Type { BLOCK , ITEM } 
 + public abstract FMLControlledNamespacedRegistry < ? > getRegistry ( ) ; 
 + } 
 / * * 
 - 	 * Look up the mod identifier data for a block . 
 - 	 * Returns null if there is no mod specified mod identifier data , or it is part of a 
 - 	 * custom itemstack definition { @ link # registerCustomItemStack } 
 - 	 * 
 - 	 * Note : uniqueness and persistence is only guaranteed by mods using the game registry 
 - 	 * correctly . 
 - 	 * 
 - 	 * @ param block to lookup 
 + * Look up the mod identifier data for a block . 
 + * Returns null if there is no mod specified mod identifier data , or it is part of a 
 + * custom itemstack definition { @ link # registerCustomItemStack } 
 + * 
 + * Note : uniqueness and persistence is only guaranteed by mods using the game registry 
 + * correctly . 
 + * 
 + * @ param block to lookup 
 * @ return a { @ link UniqueIdentifier } for the block or null 
 - 	 * / 
 - 	 public static UniqueIdentifier findUniqueIdentifierFor ( Block block ) 
 - 	 { 
 - 	 return GameData . getUniqueName ( block ) ; 
 - 	 } 
 + * / 
 + public static UniqueIdentifier findUniqueIdentifierFor ( Block block ) 
 + { 
 + return GameData . getUniqueName ( block ) ; 
 + } 
 / * * 
 * Look up the mod identifier data for an item . 
 * Returns null if there is no mod specified mod identifier data , or it is part of a
