BLEU SCORE: 0.02269295753552573

TEST MSG: Add a simple network API . .
GENERATED MSG: Add a FML outbound target for all players tracking a point or entity in the world . Closes # 3677

TEST DIFF (one line): diff - - git a / Jenkinsfile b / Jenkinsfile <nl> index ce3cb48 . . 3143b76 100644 <nl> - - - a / Jenkinsfile <nl> + + + b / Jenkinsfile <nl> @ @ - 52 , 8 + 52 , 8 @ @ pipeline { <nl> ] ) { <nl> sh ' . / gradlew $ { GRADLE _ ARGS } : forge : publish - PforgeMavenUser = $ { FORGE _ MAVEN _ USR } - PforgeMavenPassword = $ { FORGE _ MAVEN _ PSW } - PkeystoreKeyPass = $ { KEYSTORE _ KEYPASS } - PkeystoreStorePass = $ { KEYSTORE _ STOREPASS } - Pkeystore = $ { KEYSTORE } - PcrowdinKey = $ { CROWDIN } ' <nl> } <nl> - / / We ' re testing so use the test group <nl> - sh ' curl - - user $ { FORGE _ MAVEN } http : / / files . minecraftforge . net / maven / manage / promote / latest / net . minecraftforge . test . forge / $ { MYVERSION } ' <nl> + / / We ' re not testing anymore so don ' t use the test group <nl> + sh ' curl - - user $ { FORGE _ MAVEN } http : / / files . minecraftforge . net / maven / manage / promote / latest / net . minecraftforge . forge / $ { MYVERSION } ' <nl> } <nl> } <nl> stage ( ' test _ publish _ pr ' ) { / / Publish to local repo to test full process , but don ' t include credentials so it can ' t sign / publish to maven <nl> diff - - git a / src / main / java / net / minecraftforge / fml / LogicalSidedProvider . java b / src / main / java / net / minecraftforge / fml / LogicalSidedProvider . java <nl> index 85c0d8b . . 03eafed 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / LogicalSidedProvider . java <nl> + + + b / src / main / java / net / minecraftforge / fml / LogicalSidedProvider . java <nl> @ @ - 27 , 7 + 27 , 9 @ @ import java . util . function . Supplier ; <nl> <nl> public enum LogicalSidedProvider <nl> { <nl> - WORKQUEUE ( ( c ) - > c . get ( ) , ( s ) - > s . get ( ) ) ; <nl> + WORKQUEUE ( ( c ) - > c . get ( ) , ( s ) - > s . get ( ) ) , <nl> + INSTANCE ( ( c ) - > c . get ( ) , ( s ) - > s . get ( ) ) <nl> + ; <nl> private static Supplier < Minecraft > client ; <nl> private static Supplier < MinecraftServer > server ; <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / PacketDistributor . java b / src / main / java / net / minecraftforge / fml / network / PacketDistributor . java <nl> new file mode 100644 <nl> index 0000000 . . 6f8277e <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / network / PacketDistributor . java <nl> @ @ - 0 , 0 + 1 , 265 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 - 2019 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . fml . network ; <nl> + <nl> + import net . minecraft . client . Minecraft ; <nl> + import net . minecraft . entity . Entity ; <nl> + import net . minecraft . entity . player . EntityPlayerMP ; <nl> + import net . minecraft . network . NetworkManager ; <nl> + import net . minecraft . network . Packet ; <nl> + import net . minecraft . server . MinecraftServer ; <nl> + import net . minecraft . world . WorldServer ; <nl> + import net . minecraft . world . chunk . Chunk ; <nl> + import net . minecraft . world . dimension . DimensionType ; <nl> + import net . minecraftforge . fml . LogicalSide ; <nl> + import net . minecraftforge . fml . LogicalSidedProvider ; <nl> + <nl> + import java . util . List ; <nl> + import java . util . function . BiFunction ; <nl> + import java . util . function . Consumer ; <nl> + import java . util . function . Supplier ; <nl> + <nl> + / * * <nl> + * Means to distribute packets in various ways <nl> + * <nl> + * @ see net . minecraftforge . fml . network . simple . SimpleChannel # send ( PacketTarget , Object ) <nl> + * <nl> + * @ param < T > <nl> + * / <nl> + public class PacketDistributor < T > { <nl> + / * * <nl> + * Send to the player specified in the Supplier <nl> + * < br / > <nl> + * { @ link # with ( Supplier ) } Player <nl> + * / <nl> + public static final PacketDistributor < EntityPlayerMP > PLAYER = new PacketDistributor < > ( PacketDistributor : : playerConsumer , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + / * * <nl> + * Send to everyone in the dimension specified in the Supplier <nl> + * < br / > <nl> + * { @ link # with ( Supplier ) } DimensionType <nl> + * / <nl> + public static final PacketDistributor < DimensionType > DIMENSION = new PacketDistributor < > ( PacketDistributor : : playerListDimConsumer , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + / * * <nl> + * Send to everyone near the { @ link TargetPoint } specified in the Supplier <nl> + * < br / > <nl> + * { @ link # with ( Supplier ) } TargetPoint <nl> + * / <nl> + public static final PacketDistributor < TargetPoint > NEAR = new PacketDistributor < > ( PacketDistributor : : playerListPointConsumer , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + / * * <nl> + * Send to everyone <nl> + * < br / > <nl> + * { @ link # noArg ( ) } <nl> + * / <nl> + public static final PacketDistributor < Void > ALL = new PacketDistributor < > ( PacketDistributor : : playerListAll , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + / * * <nl> + * Send to the server ( CLIENT to SERVER ) <nl> + * < br / > <nl> + * { @ link # noArg ( ) } <nl> + * / <nl> + public static final PacketDistributor < Void > SERVER = new PacketDistributor < > ( PacketDistributor : : clientToServer , NetworkDirection . PLAY _ TO _ SERVER ) ; <nl> + / * * <nl> + * Send to all tracking the Entity in the Supplier <nl> + * < br / > <nl> + * { @ link # with ( Supplier ) } Entity <nl> + * / <nl> + public static final PacketDistributor < Entity > TRACKING _ ENTITY = new PacketDistributor < > ( PacketDistributor : : trackingEntity , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + / * * <nl> + * Send to all tracking the Entity and Player in the Supplier <nl> + * < br / > <nl> + * { @ link # with ( Supplier ) } Entity <nl> + * / <nl> + public static final PacketDistributor < Entity > TRACKING _ ENTITY _ AND _ SELF = new PacketDistributor < > ( PacketDistributor : : trackingEntityAndSelf , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + / * * <nl> + * Send to all tracking the Chunk in the Supplier <nl> + * < br / > <nl> + * { @ link # with ( Supplier ) } Chunk <nl> + * / <nl> + public static final PacketDistributor < Chunk > TRACKING _ CHUNK = new PacketDistributor < > ( PacketDistributor : : trackingChunk , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + / * * <nl> + * Send to the supplied list of NetworkManager instances in the Supplier <nl> + * < br / > <nl> + * { @ link # with ( Supplier ) } List of NetworkManager <nl> + * / <nl> + public static final PacketDistributor < List < NetworkManager > > NMLIST = new PacketDistributor < > ( PacketDistributor : : networkManagerList , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + <nl> + public static final class TargetPoint { <nl> + <nl> + private final EntityPlayerMP excluded ; <nl> + private final double x ; <nl> + private final double y ; <nl> + private final double z ; <nl> + private final double r2 ; <nl> + private final DimensionType dim ; <nl> + <nl> + / * * <nl> + * A target point with excluded entity <nl> + * <nl> + * @ param excluded Entity to exclude <nl> + * @ param x X <nl> + * @ param y Y <nl> + * @ param z Z <nl> + * @ param r2 Radius <nl> + * @ param dim DimensionType <nl> + * / <nl> + public TargetPoint ( final EntityPlayerMP excluded , final double x , final double y , final double z , final double r2 , final DimensionType dim ) { <nl> + this . excluded = excluded ; <nl> + this . x = x ; <nl> + this . y = y ; <nl> + this . z = z ; <nl> + this . r2 = r2 ; <nl> + this . dim = dim ; <nl> + } <nl> + <nl> + / * * <nl> + * A target point without excluded entity <nl> + * @ param x X <nl> + * @ param y Y <nl> + * @ param z Z <nl> + * @ param r2 Radius <nl> + * @ param dim DimensionType <nl> + * / <nl> + public TargetPoint ( final double x , final double y , final double z , final double r2 , final DimensionType dim ) { <nl> + this . excluded = null ; <nl> + this . x = x ; <nl> + this . y = y ; <nl> + this . z = z ; <nl> + this . r2 = r2 ; <nl> + this . dim = dim ; <nl> + } <nl> + <nl> + / * * <nl> + * Helper to build a TargetPoint without excluded Entity <nl> + * @ param x X <nl> + * @ param y Y <nl> + * @ param z Z <nl> + * @ param r2 Radius <nl> + * @ param dim DimensionType <nl> + * @ return A TargetPoint supplier <nl> + * / <nl> + public static Supplier < TargetPoint > p ( double x , double y , double z , double r2 , DimensionType dim ) { <nl> + TargetPoint tp = new TargetPoint ( x , y , z , r2 , dim ) ; <nl> + return ( ) - > tp ; <nl> + } <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * A Distributor curried with a specific value instance , for actual dispatch <nl> + * <nl> + * @ see net . minecraftforge . fml . network . simple . SimpleChannel # send ( PacketTarget , Object ) <nl> + * <nl> + * / <nl> + public static class PacketTarget { <nl> + private final Consumer < Packet < ? > > packetConsumer ; <nl> + private final PacketDistributor < ? > distributor ; <nl> + PacketTarget ( final Consumer < Packet < ? > > packetConsumer , final PacketDistributor < ? > distributor ) { <nl> + this . packetConsumer = packetConsumer ; <nl> + this . distributor = distributor ; <nl> + } <nl> + <nl> + public void send ( Packet < ? > packet ) { <nl> + packetConsumer . accept ( packet ) ; <nl> + } <nl> + <nl> + public NetworkDirection getDirection ( ) { <nl> + return distributor . direction ; <nl> + } <nl> + <nl> + } <nl> + <nl> + private final BiFunction < PacketDistributor < T > , Supplier < T > , Consumer < Packet < ? > > > functor ; <nl> + private final NetworkDirection direction ; <nl> + <nl> + public PacketDistributor ( BiFunction < PacketDistributor < T > , Supplier < T > , Consumer < Packet < ? > > > functor , NetworkDirection direction ) { <nl> + this . functor = functor ; <nl> + this . direction = direction ; <nl> + } <nl> + <nl> + / * * <nl> + * Apply the supplied value to the specific distributor to generate an instance for sending packets to . <nl> + * @ param input The input to apply <nl> + * @ return A curried instance <nl> + * / <nl> + public PacketTarget with ( Supplier < T > input ) { <nl> + return new PacketTarget ( functor . apply ( this , input ) , this ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Apply a no argument value to a distributor to generate an instance for sending packets to . <nl> + * <nl> + * @ see # ALL <nl> + * @ see # SERVER <nl> + * @ return A curried instance <nl> + * / <nl> + public PacketTarget noArg ( ) { <nl> + return new PacketTarget ( functor . apply ( this , ( ) - > null ) , this ) ; <nl> + } <nl> + <nl> + private Consumer < Packet < ? > > playerConsumer ( final Supplier < EntityPlayerMP > entityPlayerMPSupplier ) { <nl> + return p - > entityPlayerMPSupplier . get ( ) . connection . netManager . sendPacket ( p ) ; <nl> + } <nl> + private Consumer < Packet < ? > > playerListDimConsumer ( final Supplier < DimensionType > dimensionTypeSupplier ) { <nl> + return p - > getServer ( ) . getPlayerList ( ) . sendPacketToAllPlayersInDimension ( p , dimensionTypeSupplier . get ( ) ) ; <nl> + } <nl> + <nl> + private Consumer < Packet < ? > > playerListAll ( final Supplier < Void > voidSupplier ) { <nl> + return p - > getServer ( ) . getPlayerList ( ) . sendPacketToAllPlayers ( p ) ; <nl> + } <nl> + <nl> + private Consumer < Packet < ? > > clientToServer ( final Supplier < Void > voidSupplier ) { <nl> + return p - > Minecraft . getInstance ( ) . getConnection ( ) . sendPacket ( p ) ; <nl> + } <nl> + <nl> + private Consumer < Packet < ? > > playerListPointConsumer ( final Supplier < TargetPoint > targetPointSupplier ) { <nl> + return p - > { <nl> + final TargetPoint tp = targetPointSupplier . get ( ) ; <nl> + getServer ( ) . getPlayerList ( ) . sendToAllNearExcept ( tp . excluded , tp . x , tp . y , tp . z , tp . r2 , tp . dim , p ) ; <nl> + } ; <nl> + } <nl> + <nl> + private Consumer < Packet < ? > > trackingEntity ( final Supplier < Entity > entitySupplier ) { <nl> + return p - > { <nl> + final Entity entity = entitySupplier . get ( ) ; <nl> + getServer ( ) . getWorld ( entity . dimension ) . getEntityTracker ( ) . sendToTracking ( entity , p ) ; <nl> + } ; <nl> + } <nl> + <nl> + private Consumer < Packet < ? > > trackingEntityAndSelf ( final Supplier < Entity > entitySupplier ) { <nl> + return p - > { <nl> + final Entity entity = entitySupplier . get ( ) ; <nl> + getServer ( ) . getWorld ( entity . dimension ) . getEntityTracker ( ) . sendToTrackingAndSelf ( entity , p ) ; <nl> + } ; <nl> + } <nl> + <nl> + private Consumer < Packet < ? > > trackingChunk ( final Supplier < Chunk > chunkPosSupplier ) { <nl> + return p - > { <nl> + final Chunk chunk = chunkPosSupplier . get ( ) ; <nl> + ( ( WorldServer ) chunk . getWorld ( ) ) . getPlayerChunkMap ( ) . getEntry ( chunk . x , chunk . z ) . sendPacket ( p ) ; <nl> + } ; <nl> + } <nl> + <nl> + private Consumer < Packet < ? > > networkManagerList ( final Supplier < List < NetworkManager > > nmListSupplier ) { <nl> + return p - > nmListSupplier . get ( ) . forEach ( nm - > nm . sendPacket ( p ) ) ; <nl> + } <nl> + <nl> + private MinecraftServer getServer ( ) { <nl> + return LogicalSidedProvider . INSTANCE . get ( LogicalSide . SERVER ) ; <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> index aba1c15 . . 0309144 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import net . minecraft . client . Minecraft ; <nl> import net . minecraft . network . NetworkManager ; <nl> import net . minecraft . network . Packet ; <nl> import net . minecraft . network . PacketBuffer ; <nl> + import net . minecraft . world . dimension . DimensionType ; <nl> import net . minecraftforge . fml . network . * ; <nl> import org . apache . commons . lang3 . tuple . Pair ; <nl> <nl> @ @ - 86 , 6 + 87 , 21 @ @ public class SimpleChannel <nl> manager . sendPacket ( toVanillaPacket ( message , direction ) ) ; <nl> } <nl> <nl> + / * * <nl> + * Send a message to the { @ link PacketDistributor . PacketTarget } from a { @ link PacketDistributor } instance . <nl> + * <nl> + * < pre > <nl> + * channel . send ( PacketDistributor . PLAYER . with ( ( ) - > player ) , message ) <nl> + * < / pre > <nl> + * <nl> + * @ param target The curried target from a PacketDistributor <nl> + * @ param message The message to send <nl> + * @ param < MSG > The type of the message <nl> + * / <nl> + public < MSG > void send ( PacketDistributor . PacketTarget target , MSG message ) { <nl> + target . send ( toVanillaPacket ( message , target . getDirection ( ) ) ) ; <nl> + } <nl> + <nl> public < MSG > Packet < ? > toVanillaPacket ( MSG message , NetworkDirection direction ) <nl> { <nl> return direction . buildPacket ( toBuffer ( message ) , instance . getChannelName ( ) ) . getThis ( ) ;
NEAREST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch b / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch <nl> index b4a9796 . . 7868457 100644 <nl> - - - a / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch <nl> + + + b / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch <nl> @ @ - 150 , 3 + 150 , 13 @ @ <nl> { <nl> this . func _ 187273 _ a ( this . field _ 187282 _ b . func _ 72688 _ a ( ) . func _ 175625 _ s ( blockpos1 ) ) ; <nl> } <nl> + @ @ - 311 , 4 + 348 , 9 @ @ <nl> + <nl> + return d0 ; <nl> + } <nl> + + <nl> + + public List < EntityPlayerMP > getWatchingPlayers ( ) <nl> + + { <nl> + + return func _ 187274 _ e ( ) ? java . util . Collections . unmodifiableList ( field _ 187283 _ c ) : java . util . Collections . emptyList ( ) ; <nl> + + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java b / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java <nl> index cf75d2f . . bb87206 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import io . netty . channel . ChannelHandlerContext ; <nl> import java . util . EnumMap ; <nl> <nl> import net . minecraft . client . network . NetHandlerPlayClient ; <nl> + import net . minecraft . entity . Entity ; <nl> import net . minecraft . entity . player . EntityPlayerMP ; <nl> import net . minecraft . network . NetHandlerPlayServer ; <nl> import net . minecraftforge . fml . common . FMLCommonHandler ; <nl> @ @ - 178 , 6 + 179 , 33 @ @ public class FMLEventChannel { <nl> } <nl> <nl> / * * <nl> + * Send to all tracking the point <nl> + * The { @ code range } field of the { @ link NetworkRegistry . TargetPoint } is ignored . <nl> + * @ param pkt <nl> + * @ param point <nl> + * / <nl> + public void sendToAllTracking ( FMLProxyPacket pkt , NetworkRegistry . TargetPoint point ) <nl> + { <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ POINT ) ; <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( point ) ; <nl> + channels . get ( Side . SERVER ) . writeAndFlush ( pkt ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Send to all tracking the entity <nl> + * This is not equivalent to { @ link # sendToAllTracking ( FMLProxyPacket , NetworkRegistry . TargetPoint ) } <nl> + * because entities have different tracking distances based on their type . <nl> + * @ param pkt <nl> + * @ param entity <nl> + * / <nl> + public void sendToAllTracking ( FMLProxyPacket pkt , Entity entity ) <nl> + { <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ ENTITY ) ; <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( entity ) ; <nl> + channels . get ( Side . SERVER ) . writeAndFlush ( pkt ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } <nl> + <nl> + / * * <nl> * Send to all in a dimension <nl> * @ param pkt <nl> * @ param dimensionId <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java b / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java <nl> index a84b9ef . . 9d1f144 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java <nl> @ @ - 26 , 9 + 26 , 17 @ @ import io . netty . channel . embedded . EmbeddedChannel ; <nl> import io . netty . util . AttributeKey ; <nl> <nl> import java . util . List ; <nl> + import java . util . Set ; <nl> <nl> + import net . minecraft . entity . Entity ; <nl> + import net . minecraft . entity . player . EntityPlayer ; <nl> import net . minecraft . entity . player . EntityPlayerMP ; <nl> import net . minecraft . network . NetworkManager ; <nl> + import net . minecraft . server . management . PlayerChunkMap ; <nl> + import net . minecraft . server . management . PlayerChunkMapEntry ; <nl> + import net . minecraft . util . math . MathHelper ; <nl> + import net . minecraft . world . WorldServer ; <nl> + import net . minecraftforge . common . DimensionManager ; <nl> import net . minecraftforge . common . util . FakePlayer ; <nl> import net . minecraftforge . fml . common . FMLCommonHandler ; <nl> import net . minecraftforge . fml . common . network . NetworkRegistry . TargetPoint ; <nl> @ @ - 232 , 6 + 240 , 79 @ @ public class FMLOutboundHandler extends ChannelOutboundHandlerAdapter { <nl> } <nl> } , <nl> / * * <nl> + * The packet is sent to all players that are watching the Chunk containing the supplied { @ link TargetPoint } . <nl> + * The { @ code range } field of the { @ link TargetPoint } is ignored . <nl> + * / <nl> + TRACKING _ POINT ( Sets . immutableEnumSet ( Side . SERVER ) ) <nl> + { <nl> + @ Override <nl> + public void validateArgs ( Object args ) <nl> + { <nl> + if ( ! ( args instanceof TargetPoint ) ) <nl> + { <nl> + throw new RuntimeException ( " TRACKING _ POINT expects a TargetPoint argument " ) ; <nl> + } <nl> + } <nl> + <nl> + @ Nullable <nl> + @ Override <nl> + public List < NetworkDispatcher > selectNetworks ( Object args , ChannelHandlerContext context , FMLProxyPacket packet ) <nl> + { <nl> + TargetPoint tp = ( TargetPoint ) args ; <nl> + WorldServer world = DimensionManager . getWorld ( tp . dimension ) ; <nl> + if ( world = = null ) <nl> + { <nl> + return ImmutableList . of ( ) ; <nl> + } <nl> + <nl> + PlayerChunkMapEntry entry = world . getPlayerChunkMap ( ) . getEntry ( MathHelper . floor ( tp . x ) > > 4 , MathHelper . floor ( tp . z ) > > 4 ) ; <nl> + if ( entry = = null ) <nl> + { <nl> + return ImmutableList . of ( ) ; <nl> + } <nl> + <nl> + ImmutableList . Builder < NetworkDispatcher > builder = ImmutableList . builder ( ) ; <nl> + for ( EntityPlayerMP player : entry . getWatchingPlayers ( ) ) <nl> + { <nl> + NetworkDispatcher dispatcher = player . connection . netManager . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> + if ( dispatcher ! = null ) builder . add ( dispatcher ) ; <nl> + } <nl> + return builder . build ( ) ; <nl> + } <nl> + } , <nl> + / * * <nl> + * The packet is sent to all players tracking the supplied { @ link Entity } . This is different from { @ link # TRACKING _ POINT } because Entities <nl> + * can have different tracking distances depending on their type . <nl> + * / <nl> + TRACKING _ ENTITY ( Sets . immutableEnumSet ( Side . SERVER ) ) <nl> + { <nl> + @ Override <nl> + public void validateArgs ( Object args ) <nl> + { <nl> + if ( ! ( args instanceof Entity ) ) <nl> + { <nl> + throw new RuntimeException ( " TRACKING _ ENTITY expects an Entity argument " ) ; <nl> + } <nl> + } <nl> + <nl> + @ Nullable <nl> + @ Override <nl> + public List < NetworkDispatcher > selectNetworks ( Object args , ChannelHandlerContext context , FMLProxyPacket packet ) <nl> + { <nl> + Entity e = ( Entity ) args ; <nl> + Set < ? extends EntityPlayer > players = FMLCommonHandler . instance ( ) . getMinecraftServerInstance ( ) <nl> + . getWorld ( e . dimension ) . getEntityTracker ( ) . getTrackingPlayers ( e ) ; <nl> + <nl> + ImmutableList . Builder < NetworkDispatcher > builder = ImmutableList . builder ( ) ; <nl> + for ( EntityPlayer player : players ) <nl> + { <nl> + NetworkDispatcher dispatcher = ( ( EntityPlayerMP ) player ) . connection . netManager . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> + if ( dispatcher ! = null ) builder . add ( dispatcher ) ; <nl> + } <nl> + return builder . build ( ) ; <nl> + } <nl> + } , <nl> + / * * <nl> * The packet is sent to the server this client is currently conversing with . <nl> * @ author cpw <nl> * <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> index b4cda09 . . 9f1a5d9 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import io . netty . channel . ChannelFutureListener ; <nl> import java . lang . reflect . Method ; <nl> import java . util . EnumMap ; <nl> <nl> + import net . minecraft . entity . Entity ; <nl> import net . minecraft . util . IThreadListener ; <nl> <nl> import io . netty . channel . ChannelHandler ; <nl> @ @ - 264 , 6 + 265 , 37 @ @ public class SimpleNetworkWrapper { <nl> } <nl> <nl> / * * <nl> + * Sends this message to everyone tracking a point . <nl> + * The { @ link IMessageHandler } for this message type should be on the CLIENT side . <nl> + * The { @ code range } field of the { @ link TargetPoint } is ignored . <nl> + * <nl> + * @ param message The message to send <nl> + * @ param point The tracked { @ link TargetPoint } around which to send <nl> + * / <nl> + public void sendToAllTracking ( IMessage message , NetworkRegistry . TargetPoint point ) <nl> + { <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ POINT ) ; <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( point ) ; <nl> + channels . get ( Side . SERVER ) . writeAndFlush ( message ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Sends this message to everyone tracking an entity . <nl> + * The { @ link IMessageHandler } for this message type should be on the CLIENT side . <nl> + * This is not equivalent to { @ link # sendToAllTracking ( IMessage , TargetPoint ) } <nl> + * because entities have different tracking distances based on their type . <nl> + * <nl> + * @ param message The message to send <nl> + * @ param entity The tracked entity around which to send <nl> + * / <nl> + public void sendToAllTracking ( IMessage message , Entity entity ) <nl> + { <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ ENTITY ) ; <nl> + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( entity ) ; <nl> + channels . get ( Side . SERVER ) . writeAndFlush ( message ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; <nl> + } <nl> + <nl> + / * * <nl> * Send this message to everyone within the supplied dimension . <nl> * The { @ link IMessageHandler } for this message type should be on the CLIENT side . <nl> * <nl> diff - - git a / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java b / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java <nl> new file mode 100644 <nl> index 0000000 . . f121ce5 <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java <nl> @ @ - 0 , 0 + 1 , 122 @ @ <nl> + package net . minecraftforge . debug ; <nl> + <nl> + import io . netty . buffer . ByteBuf ; <nl> + import net . minecraft . entity . item . EntityItemFrame ; <nl> + import net . minecraft . init . Items ; <nl> + import net . minecraftforge . event . entity . EntityJoinWorldEvent ; <nl> + import net . minecraftforge . fml . common . Mod ; <nl> + import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> + import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; <nl> + import net . minecraftforge . fml . common . gameevent . TickEvent ; <nl> + import net . minecraftforge . fml . common . network . NetworkRegistry ; <nl> + import net . minecraftforge . fml . common . network . simpleimpl . IMessage ; <nl> + import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; <nl> + import net . minecraftforge . fml . common . network . simpleimpl . MessageContext ; <nl> + import net . minecraftforge . fml . common . network . simpleimpl . SimpleNetworkWrapper ; <nl> + import net . minecraftforge . fml . relauncher . Side ; <nl> + import org . apache . logging . log4j . LogManager ; <nl> + import org . apache . logging . log4j . Logger ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . Set ; <nl> + import java . util . WeakHashMap ; <nl> + <nl> + @ Mod ( modid = TrackingTargetTest . ID , name = " Tracking Target Test " , acceptableRemoteVersions = " * " ) <nl> + @ Mod . EventBusSubscriber <nl> + public class TrackingTargetTest <nl> + { <nl> + public static final String ID = " trackingtargettest " ; <nl> + private static boolean ENABLED = false ; <nl> + private static final SimpleNetworkWrapper NET = new SimpleNetworkWrapper ( ID ) ; <nl> + private static final Logger LOGGER = LogManager . getLogger ( ID ) ; <nl> + <nl> + @ Mod . EventHandler <nl> + public static void preinit ( FMLPreInitializationEvent evt ) <nl> + { <nl> + NET . registerMessage ( TestMessageHandler . class , TestMessage . class , 0 , Side . CLIENT ) ; <nl> + NET . registerMessage ( TestEntityMessageHandler . class , TestEntityMessage . class , 1 , Side . CLIENT ) ; <nl> + } <nl> + <nl> + / / Every 3 seconds , send a message to all players tracking overworld ( 500 , 500 ) . <nl> + / / If you move sufficiently far away ( i . e greater than the server render distance ) from ( 500 , 500 ) , you should stop receiving the messages . <nl> + @ SubscribeEvent <nl> + public static void tick ( TickEvent . WorldTickEvent evt ) <nl> + { <nl> + if ( ENABLED & & evt . side = = Side . SERVER & & evt . phase = = TickEvent . Phase . END ) <nl> + { <nl> + if ( evt . world . getWorldTime ( ) % 60 = = 0 ) <nl> + { <nl> + NetworkRegistry . TargetPoint pt = new NetworkRegistry . TargetPoint ( 0 , 500 , 0 , 500 , - 1 ) ; <nl> + NET . sendToAllTracking ( new TestMessage ( ) , pt ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public static class TestMessage implements IMessage <nl> + { <nl> + @ Override <nl> + public void fromBytes ( ByteBuf buf ) { } <nl> + <nl> + @ Override <nl> + public void toBytes ( ByteBuf buf ) { } <nl> + } <nl> + <nl> + public static class TestMessageHandler implements IMessageHandler < TestMessage , IMessage > <nl> + { <nl> + @ Override <nl> + public IMessage onMessage ( TestMessage message , MessageContext ctx ) <nl> + { <nl> + LOGGER . info ( " Received tracking point test message " ) ; <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + / / Every 3 seconds , send a message to all players tracking any item frame with a stick in it <nl> + / / If you move sufficiently far away from the frame , you should stop receiving the messages . <nl> + private static final Set < EntityItemFrame > FRAMES = Collections . newSetFromMap ( new WeakHashMap < > ( ) ) ; <nl> + @ SubscribeEvent <nl> + public static void frameJoin ( EntityJoinWorldEvent evt ) <nl> + { <nl> + if ( ENABLED & & ! evt . getWorld ( ) . isRemote & & evt . getEntity ( ) instanceof EntityItemFrame ) <nl> + { <nl> + FRAMES . add ( ( EntityItemFrame ) evt . getEntity ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ SubscribeEvent <nl> + public static void tickEntity ( TickEvent . WorldTickEvent evt ) <nl> + { <nl> + if ( ENABLED & & evt . side = = Side . SERVER & & evt . phase = = TickEvent . Phase . END ) <nl> + { <nl> + if ( evt . world . getWorldTime ( ) % 60 = = 0 ) <nl> + { <nl> + for ( EntityItemFrame frame : FRAMES ) <nl> + { <nl> + if ( ! frame . isDead & & ! frame . getDisplayedItem ( ) . isEmpty ( ) & & frame . getDisplayedItem ( ) . getItem ( ) = = Items . STICK ) <nl> + { <nl> + NET . sendToAllTracking ( new TestEntityMessage ( ) , frame ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + public static class TestEntityMessage implements IMessage <nl> + { <nl> + @ Override <nl> + public void fromBytes ( ByteBuf buf ) { } <nl> + <nl> + @ Override <nl> + public void toBytes ( ByteBuf buf ) { } <nl> + } <nl> + <nl> + public static class TestEntityMessageHandler implements IMessageHandler < TestEntityMessage , IMessage > <nl> + { <nl> + @ Override <nl> + public IMessage onMessage ( TestEntityMessage message , MessageContext ctx ) <nl> + { <nl> + LOGGER . info ( " Received tracking point test entity message " ) ; <nl> + return null ; <nl> + } <nl> + } <nl> + }

TEST DIFF:
diff - - git a / Jenkinsfile b / Jenkinsfile 
 index ce3cb48 . . 3143b76 100644 
 - - - a / Jenkinsfile 
 + + + b / Jenkinsfile 
 @ @ - 52 , 8 + 52 , 8 @ @ pipeline { 
 ] ) { 
 sh ' . / gradlew $ { GRADLE _ ARGS } : forge : publish - PforgeMavenUser = $ { FORGE _ MAVEN _ USR } - PforgeMavenPassword = $ { FORGE _ MAVEN _ PSW } - PkeystoreKeyPass = $ { KEYSTORE _ KEYPASS } - PkeystoreStorePass = $ { KEYSTORE _ STOREPASS } - Pkeystore = $ { KEYSTORE } - PcrowdinKey = $ { CROWDIN } ' 
 } 
 - / / We ' re testing so use the test group 
 - sh ' curl - - user $ { FORGE _ MAVEN } http : / / files . minecraftforge . net / maven / manage / promote / latest / net . minecraftforge . test . forge / $ { MYVERSION } ' 
 + / / We ' re not testing anymore so don ' t use the test group 
 + sh ' curl - - user $ { FORGE _ MAVEN } http : / / files . minecraftforge . net / maven / manage / promote / latest / net . minecraftforge . forge / $ { MYVERSION } ' 
 } 
 } 
 stage ( ' test _ publish _ pr ' ) { / / Publish to local repo to test full process , but don ' t include credentials so it can ' t sign / publish to maven 
 diff - - git a / src / main / java / net / minecraftforge / fml / LogicalSidedProvider . java b / src / main / java / net / minecraftforge / fml / LogicalSidedProvider . java 
 index 85c0d8b . . 03eafed 100644 
 - - - a / src / main / java / net / minecraftforge / fml / LogicalSidedProvider . java 
 + + + b / src / main / java / net / minecraftforge / fml / LogicalSidedProvider . java 
 @ @ - 27 , 7 + 27 , 9 @ @ import java . util . function . Supplier ; 
 
 public enum LogicalSidedProvider 
 { 
 - WORKQUEUE ( ( c ) - > c . get ( ) , ( s ) - > s . get ( ) ) ; 
 + WORKQUEUE ( ( c ) - > c . get ( ) , ( s ) - > s . get ( ) ) , 
 + INSTANCE ( ( c ) - > c . get ( ) , ( s ) - > s . get ( ) ) 
 + ; 
 private static Supplier < Minecraft > client ; 
 private static Supplier < MinecraftServer > server ; 
 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / PacketDistributor . java b / src / main / java / net / minecraftforge / fml / network / PacketDistributor . java 
 new file mode 100644 
 index 0000000 . . 6f8277e 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / network / PacketDistributor . java 
 @ @ - 0 , 0 + 1 , 265 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 - 2019 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . fml . network ; 
 + 
 + import net . minecraft . client . Minecraft ; 
 + import net . minecraft . entity . Entity ; 
 + import net . minecraft . entity . player . EntityPlayerMP ; 
 + import net . minecraft . network . NetworkManager ; 
 + import net . minecraft . network . Packet ; 
 + import net . minecraft . server . MinecraftServer ; 
 + import net . minecraft . world . WorldServer ; 
 + import net . minecraft . world . chunk . Chunk ; 
 + import net . minecraft . world . dimension . DimensionType ; 
 + import net . minecraftforge . fml . LogicalSide ; 
 + import net . minecraftforge . fml . LogicalSidedProvider ; 
 + 
 + import java . util . List ; 
 + import java . util . function . BiFunction ; 
 + import java . util . function . Consumer ; 
 + import java . util . function . Supplier ; 
 + 
 + / * * 
 + * Means to distribute packets in various ways 
 + * 
 + * @ see net . minecraftforge . fml . network . simple . SimpleChannel # send ( PacketTarget , Object ) 
 + * 
 + * @ param < T > 
 + * / 
 + public class PacketDistributor < T > { 
 + / * * 
 + * Send to the player specified in the Supplier 
 + * < br / > 
 + * { @ link # with ( Supplier ) } Player 
 + * / 
 + public static final PacketDistributor < EntityPlayerMP > PLAYER = new PacketDistributor < > ( PacketDistributor : : playerConsumer , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + / * * 
 + * Send to everyone in the dimension specified in the Supplier 
 + * < br / > 
 + * { @ link # with ( Supplier ) } DimensionType 
 + * / 
 + public static final PacketDistributor < DimensionType > DIMENSION = new PacketDistributor < > ( PacketDistributor : : playerListDimConsumer , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + / * * 
 + * Send to everyone near the { @ link TargetPoint } specified in the Supplier 
 + * < br / > 
 + * { @ link # with ( Supplier ) } TargetPoint 
 + * / 
 + public static final PacketDistributor < TargetPoint > NEAR = new PacketDistributor < > ( PacketDistributor : : playerListPointConsumer , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + / * * 
 + * Send to everyone 
 + * < br / > 
 + * { @ link # noArg ( ) } 
 + * / 
 + public static final PacketDistributor < Void > ALL = new PacketDistributor < > ( PacketDistributor : : playerListAll , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + / * * 
 + * Send to the server ( CLIENT to SERVER ) 
 + * < br / > 
 + * { @ link # noArg ( ) } 
 + * / 
 + public static final PacketDistributor < Void > SERVER = new PacketDistributor < > ( PacketDistributor : : clientToServer , NetworkDirection . PLAY _ TO _ SERVER ) ; 
 + / * * 
 + * Send to all tracking the Entity in the Supplier 
 + * < br / > 
 + * { @ link # with ( Supplier ) } Entity 
 + * / 
 + public static final PacketDistributor < Entity > TRACKING _ ENTITY = new PacketDistributor < > ( PacketDistributor : : trackingEntity , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + / * * 
 + * Send to all tracking the Entity and Player in the Supplier 
 + * < br / > 
 + * { @ link # with ( Supplier ) } Entity 
 + * / 
 + public static final PacketDistributor < Entity > TRACKING _ ENTITY _ AND _ SELF = new PacketDistributor < > ( PacketDistributor : : trackingEntityAndSelf , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + / * * 
 + * Send to all tracking the Chunk in the Supplier 
 + * < br / > 
 + * { @ link # with ( Supplier ) } Chunk 
 + * / 
 + public static final PacketDistributor < Chunk > TRACKING _ CHUNK = new PacketDistributor < > ( PacketDistributor : : trackingChunk , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + / * * 
 + * Send to the supplied list of NetworkManager instances in the Supplier 
 + * < br / > 
 + * { @ link # with ( Supplier ) } List of NetworkManager 
 + * / 
 + public static final PacketDistributor < List < NetworkManager > > NMLIST = new PacketDistributor < > ( PacketDistributor : : networkManagerList , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + 
 + public static final class TargetPoint { 
 + 
 + private final EntityPlayerMP excluded ; 
 + private final double x ; 
 + private final double y ; 
 + private final double z ; 
 + private final double r2 ; 
 + private final DimensionType dim ; 
 + 
 + / * * 
 + * A target point with excluded entity 
 + * 
 + * @ param excluded Entity to exclude 
 + * @ param x X 
 + * @ param y Y 
 + * @ param z Z 
 + * @ param r2 Radius 
 + * @ param dim DimensionType 
 + * / 
 + public TargetPoint ( final EntityPlayerMP excluded , final double x , final double y , final double z , final double r2 , final DimensionType dim ) { 
 + this . excluded = excluded ; 
 + this . x = x ; 
 + this . y = y ; 
 + this . z = z ; 
 + this . r2 = r2 ; 
 + this . dim = dim ; 
 + } 
 + 
 + / * * 
 + * A target point without excluded entity 
 + * @ param x X 
 + * @ param y Y 
 + * @ param z Z 
 + * @ param r2 Radius 
 + * @ param dim DimensionType 
 + * / 
 + public TargetPoint ( final double x , final double y , final double z , final double r2 , final DimensionType dim ) { 
 + this . excluded = null ; 
 + this . x = x ; 
 + this . y = y ; 
 + this . z = z ; 
 + this . r2 = r2 ; 
 + this . dim = dim ; 
 + } 
 + 
 + / * * 
 + * Helper to build a TargetPoint without excluded Entity 
 + * @ param x X 
 + * @ param y Y 
 + * @ param z Z 
 + * @ param r2 Radius 
 + * @ param dim DimensionType 
 + * @ return A TargetPoint supplier 
 + * / 
 + public static Supplier < TargetPoint > p ( double x , double y , double z , double r2 , DimensionType dim ) { 
 + TargetPoint tp = new TargetPoint ( x , y , z , r2 , dim ) ; 
 + return ( ) - > tp ; 
 + } 
 + 
 + } 
 + 
 + / * * 
 + * A Distributor curried with a specific value instance , for actual dispatch 
 + * 
 + * @ see net . minecraftforge . fml . network . simple . SimpleChannel # send ( PacketTarget , Object ) 
 + * 
 + * / 
 + public static class PacketTarget { 
 + private final Consumer < Packet < ? > > packetConsumer ; 
 + private final PacketDistributor < ? > distributor ; 
 + PacketTarget ( final Consumer < Packet < ? > > packetConsumer , final PacketDistributor < ? > distributor ) { 
 + this . packetConsumer = packetConsumer ; 
 + this . distributor = distributor ; 
 + } 
 + 
 + public void send ( Packet < ? > packet ) { 
 + packetConsumer . accept ( packet ) ; 
 + } 
 + 
 + public NetworkDirection getDirection ( ) { 
 + return distributor . direction ; 
 + } 
 + 
 + } 
 + 
 + private final BiFunction < PacketDistributor < T > , Supplier < T > , Consumer < Packet < ? > > > functor ; 
 + private final NetworkDirection direction ; 
 + 
 + public PacketDistributor ( BiFunction < PacketDistributor < T > , Supplier < T > , Consumer < Packet < ? > > > functor , NetworkDirection direction ) { 
 + this . functor = functor ; 
 + this . direction = direction ; 
 + } 
 + 
 + / * * 
 + * Apply the supplied value to the specific distributor to generate an instance for sending packets to . 
 + * @ param input The input to apply 
 + * @ return A curried instance 
 + * / 
 + public PacketTarget with ( Supplier < T > input ) { 
 + return new PacketTarget ( functor . apply ( this , input ) , this ) ; 
 + } 
 + 
 + / * * 
 + * Apply a no argument value to a distributor to generate an instance for sending packets to . 
 + * 
 + * @ see # ALL 
 + * @ see # SERVER 
 + * @ return A curried instance 
 + * / 
 + public PacketTarget noArg ( ) { 
 + return new PacketTarget ( functor . apply ( this , ( ) - > null ) , this ) ; 
 + } 
 + 
 + private Consumer < Packet < ? > > playerConsumer ( final Supplier < EntityPlayerMP > entityPlayerMPSupplier ) { 
 + return p - > entityPlayerMPSupplier . get ( ) . connection . netManager . sendPacket ( p ) ; 
 + } 
 + private Consumer < Packet < ? > > playerListDimConsumer ( final Supplier < DimensionType > dimensionTypeSupplier ) { 
 + return p - > getServer ( ) . getPlayerList ( ) . sendPacketToAllPlayersInDimension ( p , dimensionTypeSupplier . get ( ) ) ; 
 + } 
 + 
 + private Consumer < Packet < ? > > playerListAll ( final Supplier < Void > voidSupplier ) { 
 + return p - > getServer ( ) . getPlayerList ( ) . sendPacketToAllPlayers ( p ) ; 
 + } 
 + 
 + private Consumer < Packet < ? > > clientToServer ( final Supplier < Void > voidSupplier ) { 
 + return p - > Minecraft . getInstance ( ) . getConnection ( ) . sendPacket ( p ) ; 
 + } 
 + 
 + private Consumer < Packet < ? > > playerListPointConsumer ( final Supplier < TargetPoint > targetPointSupplier ) { 
 + return p - > { 
 + final TargetPoint tp = targetPointSupplier . get ( ) ; 
 + getServer ( ) . getPlayerList ( ) . sendToAllNearExcept ( tp . excluded , tp . x , tp . y , tp . z , tp . r2 , tp . dim , p ) ; 
 + } ; 
 + } 
 + 
 + private Consumer < Packet < ? > > trackingEntity ( final Supplier < Entity > entitySupplier ) { 
 + return p - > { 
 + final Entity entity = entitySupplier . get ( ) ; 
 + getServer ( ) . getWorld ( entity . dimension ) . getEntityTracker ( ) . sendToTracking ( entity , p ) ; 
 + } ; 
 + } 
 + 
 + private Consumer < Packet < ? > > trackingEntityAndSelf ( final Supplier < Entity > entitySupplier ) { 
 + return p - > { 
 + final Entity entity = entitySupplier . get ( ) ; 
 + getServer ( ) . getWorld ( entity . dimension ) . getEntityTracker ( ) . sendToTrackingAndSelf ( entity , p ) ; 
 + } ; 
 + } 
 + 
 + private Consumer < Packet < ? > > trackingChunk ( final Supplier < Chunk > chunkPosSupplier ) { 
 + return p - > { 
 + final Chunk chunk = chunkPosSupplier . get ( ) ; 
 + ( ( WorldServer ) chunk . getWorld ( ) ) . getPlayerChunkMap ( ) . getEntry ( chunk . x , chunk . z ) . sendPacket ( p ) ; 
 + } ; 
 + } 
 + 
 + private Consumer < Packet < ? > > networkManagerList ( final Supplier < List < NetworkManager > > nmListSupplier ) { 
 + return p - > nmListSupplier . get ( ) . forEach ( nm - > nm . sendPacket ( p ) ) ; 
 + } 
 + 
 + private MinecraftServer getServer ( ) { 
 + return LogicalSidedProvider . INSTANCE . get ( LogicalSide . SERVER ) ; 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 index aba1c15 . . 0309144 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import net . minecraft . client . Minecraft ; 
 import net . minecraft . network . NetworkManager ; 
 import net . minecraft . network . Packet ; 
 import net . minecraft . network . PacketBuffer ; 
 + import net . minecraft . world . dimension . DimensionType ; 
 import net . minecraftforge . fml . network . * ; 
 import org . apache . commons . lang3 . tuple . Pair ; 
 
 @ @ - 86 , 6 + 87 , 21 @ @ public class SimpleChannel 
 manager . sendPacket ( toVanillaPacket ( message , direction ) ) ; 
 } 
 
 + / * * 
 + * Send a message to the { @ link PacketDistributor . PacketTarget } from a { @ link PacketDistributor } instance . 
 + * 
 + * < pre > 
 + * channel . send ( PacketDistributor . PLAYER . with ( ( ) - > player ) , message ) 
 + * < / pre > 
 + * 
 + * @ param target The curried target from a PacketDistributor 
 + * @ param message The message to send 
 + * @ param < MSG > The type of the message 
 + * / 
 + public < MSG > void send ( PacketDistributor . PacketTarget target , MSG message ) { 
 + target . send ( toVanillaPacket ( message , target . getDirection ( ) ) ) ; 
 + } 
 + 
 public < MSG > Packet < ? > toVanillaPacket ( MSG message , NetworkDirection direction ) 
 { 
 return direction . buildPacket ( toBuffer ( message ) , instance . getChannelName ( ) ) . getThis ( ) ;

NEAREST DIFF:
diff - - git a / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch b / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch 
 index b4a9796 . . 7868457 100644 
 - - - a / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch 
 + + + b / patches / minecraft / net / minecraft / server / management / PlayerChunkMapEntry . java . patch 
 @ @ - 150 , 3 + 150 , 13 @ @ 
 { 
 this . func _ 187273 _ a ( this . field _ 187282 _ b . func _ 72688 _ a ( ) . func _ 175625 _ s ( blockpos1 ) ) ; 
 } 
 + @ @ - 311 , 4 + 348 , 9 @ @ 
 + 
 + return d0 ; 
 + } 
 + + 
 + + public List < EntityPlayerMP > getWatchingPlayers ( ) 
 + + { 
 + + return func _ 187274 _ e ( ) ? java . util . Collections . unmodifiableList ( field _ 187283 _ c ) : java . util . Collections . emptyList ( ) ; 
 + + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java b / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java 
 index cf75d2f . . bb87206 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / FMLEventChannel . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import io . netty . channel . ChannelHandlerContext ; 
 import java . util . EnumMap ; 
 
 import net . minecraft . client . network . NetHandlerPlayClient ; 
 + import net . minecraft . entity . Entity ; 
 import net . minecraft . entity . player . EntityPlayerMP ; 
 import net . minecraft . network . NetHandlerPlayServer ; 
 import net . minecraftforge . fml . common . FMLCommonHandler ; 
 @ @ - 178 , 6 + 179 , 33 @ @ public class FMLEventChannel { 
 } 
 
 / * * 
 + * Send to all tracking the point 
 + * The { @ code range } field of the { @ link NetworkRegistry . TargetPoint } is ignored . 
 + * @ param pkt 
 + * @ param point 
 + * / 
 + public void sendToAllTracking ( FMLProxyPacket pkt , NetworkRegistry . TargetPoint point ) 
 + { 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ POINT ) ; 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( point ) ; 
 + channels . get ( Side . SERVER ) . writeAndFlush ( pkt ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } 
 + 
 + / * * 
 + * Send to all tracking the entity 
 + * This is not equivalent to { @ link # sendToAllTracking ( FMLProxyPacket , NetworkRegistry . TargetPoint ) } 
 + * because entities have different tracking distances based on their type . 
 + * @ param pkt 
 + * @ param entity 
 + * / 
 + public void sendToAllTracking ( FMLProxyPacket pkt , Entity entity ) 
 + { 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ ENTITY ) ; 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( entity ) ; 
 + channels . get ( Side . SERVER ) . writeAndFlush ( pkt ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } 
 + 
 + / * * 
 * Send to all in a dimension 
 * @ param pkt 
 * @ param dimensionId 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java b / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java 
 index a84b9ef . . 9d1f144 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / FMLOutboundHandler . java 
 @ @ - 26 , 9 + 26 , 17 @ @ import io . netty . channel . embedded . EmbeddedChannel ; 
 import io . netty . util . AttributeKey ; 
 
 import java . util . List ; 
 + import java . util . Set ; 
 
 + import net . minecraft . entity . Entity ; 
 + import net . minecraft . entity . player . EntityPlayer ; 
 import net . minecraft . entity . player . EntityPlayerMP ; 
 import net . minecraft . network . NetworkManager ; 
 + import net . minecraft . server . management . PlayerChunkMap ; 
 + import net . minecraft . server . management . PlayerChunkMapEntry ; 
 + import net . minecraft . util . math . MathHelper ; 
 + import net . minecraft . world . WorldServer ; 
 + import net . minecraftforge . common . DimensionManager ; 
 import net . minecraftforge . common . util . FakePlayer ; 
 import net . minecraftforge . fml . common . FMLCommonHandler ; 
 import net . minecraftforge . fml . common . network . NetworkRegistry . TargetPoint ; 
 @ @ - 232 , 6 + 240 , 79 @ @ public class FMLOutboundHandler extends ChannelOutboundHandlerAdapter { 
 } 
 } , 
 / * * 
 + * The packet is sent to all players that are watching the Chunk containing the supplied { @ link TargetPoint } . 
 + * The { @ code range } field of the { @ link TargetPoint } is ignored . 
 + * / 
 + TRACKING _ POINT ( Sets . immutableEnumSet ( Side . SERVER ) ) 
 + { 
 + @ Override 
 + public void validateArgs ( Object args ) 
 + { 
 + if ( ! ( args instanceof TargetPoint ) ) 
 + { 
 + throw new RuntimeException ( " TRACKING _ POINT expects a TargetPoint argument " ) ; 
 + } 
 + } 
 + 
 + @ Nullable 
 + @ Override 
 + public List < NetworkDispatcher > selectNetworks ( Object args , ChannelHandlerContext context , FMLProxyPacket packet ) 
 + { 
 + TargetPoint tp = ( TargetPoint ) args ; 
 + WorldServer world = DimensionManager . getWorld ( tp . dimension ) ; 
 + if ( world = = null ) 
 + { 
 + return ImmutableList . of ( ) ; 
 + } 
 + 
 + PlayerChunkMapEntry entry = world . getPlayerChunkMap ( ) . getEntry ( MathHelper . floor ( tp . x ) > > 4 , MathHelper . floor ( tp . z ) > > 4 ) ; 
 + if ( entry = = null ) 
 + { 
 + return ImmutableList . of ( ) ; 
 + } 
 + 
 + ImmutableList . Builder < NetworkDispatcher > builder = ImmutableList . builder ( ) ; 
 + for ( EntityPlayerMP player : entry . getWatchingPlayers ( ) ) 
 + { 
 + NetworkDispatcher dispatcher = player . connection . netManager . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 + if ( dispatcher ! = null ) builder . add ( dispatcher ) ; 
 + } 
 + return builder . build ( ) ; 
 + } 
 + } , 
 + / * * 
 + * The packet is sent to all players tracking the supplied { @ link Entity } . This is different from { @ link # TRACKING _ POINT } because Entities 
 + * can have different tracking distances depending on their type . 
 + * / 
 + TRACKING _ ENTITY ( Sets . immutableEnumSet ( Side . SERVER ) ) 
 + { 
 + @ Override 
 + public void validateArgs ( Object args ) 
 + { 
 + if ( ! ( args instanceof Entity ) ) 
 + { 
 + throw new RuntimeException ( " TRACKING _ ENTITY expects an Entity argument " ) ; 
 + } 
 + } 
 + 
 + @ Nullable 
 + @ Override 
 + public List < NetworkDispatcher > selectNetworks ( Object args , ChannelHandlerContext context , FMLProxyPacket packet ) 
 + { 
 + Entity e = ( Entity ) args ; 
 + Set < ? extends EntityPlayer > players = FMLCommonHandler . instance ( ) . getMinecraftServerInstance ( ) 
 + . getWorld ( e . dimension ) . getEntityTracker ( ) . getTrackingPlayers ( e ) ; 
 + 
 + ImmutableList . Builder < NetworkDispatcher > builder = ImmutableList . builder ( ) ; 
 + for ( EntityPlayer player : players ) 
 + { 
 + NetworkDispatcher dispatcher = ( ( EntityPlayerMP ) player ) . connection . netManager . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 + if ( dispatcher ! = null ) builder . add ( dispatcher ) ; 
 + } 
 + return builder . build ( ) ; 
 + } 
 + } , 
 + / * * 
 * The packet is sent to the server this client is currently conversing with . 
 * @ author cpw 
 * 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 index b4cda09 . . 9f1a5d9 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import io . netty . channel . ChannelFutureListener ; 
 import java . lang . reflect . Method ; 
 import java . util . EnumMap ; 
 
 + import net . minecraft . entity . Entity ; 
 import net . minecraft . util . IThreadListener ; 
 
 import io . netty . channel . ChannelHandler ; 
 @ @ - 264 , 6 + 265 , 37 @ @ public class SimpleNetworkWrapper { 
 } 
 
 / * * 
 + * Sends this message to everyone tracking a point . 
 + * The { @ link IMessageHandler } for this message type should be on the CLIENT side . 
 + * The { @ code range } field of the { @ link TargetPoint } is ignored . 
 + * 
 + * @ param message The message to send 
 + * @ param point The tracked { @ link TargetPoint } around which to send 
 + * / 
 + public void sendToAllTracking ( IMessage message , NetworkRegistry . TargetPoint point ) 
 + { 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ POINT ) ; 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( point ) ; 
 + channels . get ( Side . SERVER ) . writeAndFlush ( message ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } 
 + 
 + / * * 
 + * Sends this message to everyone tracking an entity . 
 + * The { @ link IMessageHandler } for this message type should be on the CLIENT side . 
 + * This is not equivalent to { @ link # sendToAllTracking ( IMessage , TargetPoint ) } 
 + * because entities have different tracking distances based on their type . 
 + * 
 + * @ param message The message to send 
 + * @ param entity The tracked entity around which to send 
 + * / 
 + public void sendToAllTracking ( IMessage message , Entity entity ) 
 + { 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGET ) . set ( FMLOutboundHandler . OutboundTarget . TRACKING _ ENTITY ) ; 
 + channels . get ( Side . SERVER ) . attr ( FMLOutboundHandler . FML _ MESSAGETARGETARGS ) . set ( entity ) ; 
 + channels . get ( Side . SERVER ) . writeAndFlush ( message ) . addListener ( ChannelFutureListener . FIRE _ EXCEPTION _ ON _ FAILURE ) ; 
 + } 
 + 
 + / * * 
 * Send this message to everyone within the supplied dimension . 
 * The { @ link IMessageHandler } for this message type should be on the CLIENT side . 
 * 
 diff - - git a / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java b / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java 
 new file mode 100644 
 index 0000000 . . f121ce5 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / debug / TrackingTargetTest . java 
 @ @ - 0 , 0 + 1 , 122 @ @ 
 + package net . minecraftforge . debug ; 
 + 
 + import io . netty . buffer . ByteBuf ; 
 + import net . minecraft . entity . item . EntityItemFrame ; 
 + import net . minecraft . init . Items ; 
 + import net . minecraftforge . event . entity . EntityJoinWorldEvent ; 
 + import net . minecraftforge . fml . common . Mod ; 
 + import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 + import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; 
 + import net . minecraftforge . fml . common . gameevent . TickEvent ; 
 + import net . minecraftforge . fml . common . network . NetworkRegistry ; 
 + import net . minecraftforge . fml . common . network . simpleimpl . IMessage ; 
 + import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; 
 + import net . minecraftforge . fml . common . network . simpleimpl . MessageContext ; 
 + import net . minecraftforge . fml . common . network . simpleimpl . SimpleNetworkWrapper ; 
 + import net . minecraftforge . fml . relauncher . Side ; 
 + import org . apache . logging . log4j . LogManager ; 
 + import org . apache . logging . log4j . Logger ; 
 + 
 + import java . util . Collections ; 
 + import java . util . Set ; 
 + import java . util . WeakHashMap ; 
 + 
 + @ Mod ( modid = TrackingTargetTest . ID , name = " Tracking Target Test " , acceptableRemoteVersions = " * " ) 
 + @ Mod . EventBusSubscriber 
 + public class TrackingTargetTest 
 + { 
 + public static final String ID = " trackingtargettest " ; 
 + private static boolean ENABLED = false ; 
 + private static final SimpleNetworkWrapper NET = new SimpleNetworkWrapper ( ID ) ; 
 + private static final Logger LOGGER = LogManager . getLogger ( ID ) ; 
 + 
 + @ Mod . EventHandler 
 + public static void preinit ( FMLPreInitializationEvent evt ) 
 + { 
 + NET . registerMessage ( TestMessageHandler . class , TestMessage . class , 0 , Side . CLIENT ) ; 
 + NET . registerMessage ( TestEntityMessageHandler . class , TestEntityMessage . class , 1 , Side . CLIENT ) ; 
 + } 
 + 
 + / / Every 3 seconds , send a message to all players tracking overworld ( 500 , 500 ) . 
 + / / If you move sufficiently far away ( i . e greater than the server render distance ) from ( 500 , 500 ) , you should stop receiving the messages . 
 + @ SubscribeEvent 
 + public static void tick ( TickEvent . WorldTickEvent evt ) 
 + { 
 + if ( ENABLED & & evt . side = = Side . SERVER & & evt . phase = = TickEvent . Phase . END ) 
 + { 
 + if ( evt . world . getWorldTime ( ) % 60 = = 0 ) 
 + { 
 + NetworkRegistry . TargetPoint pt = new NetworkRegistry . TargetPoint ( 0 , 500 , 0 , 500 , - 1 ) ; 
 + NET . sendToAllTracking ( new TestMessage ( ) , pt ) ; 
 + } 
 + } 
 + } 
 + 
 + public static class TestMessage implements IMessage 
 + { 
 + @ Override 
 + public void fromBytes ( ByteBuf buf ) { } 
 + 
 + @ Override 
 + public void toBytes ( ByteBuf buf ) { } 
 + } 
 + 
 + public static class TestMessageHandler implements IMessageHandler < TestMessage , IMessage > 
 + { 
 + @ Override 
 + public IMessage onMessage ( TestMessage message , MessageContext ctx ) 
 + { 
 + LOGGER . info ( " Received tracking point test message " ) ; 
 + return null ; 
 + } 
 + } 
 + 
 + / / Every 3 seconds , send a message to all players tracking any item frame with a stick in it 
 + / / If you move sufficiently far away from the frame , you should stop receiving the messages . 
 + private static final Set < EntityItemFrame > FRAMES = Collections . newSetFromMap ( new WeakHashMap < > ( ) ) ; 
 + @ SubscribeEvent 
 + public static void frameJoin ( EntityJoinWorldEvent evt ) 
 + { 
 + if ( ENABLED & & ! evt . getWorld ( ) . isRemote & & evt . getEntity ( ) instanceof EntityItemFrame ) 
 + { 
 + FRAMES . add ( ( EntityItemFrame ) evt . getEntity ( ) ) ; 
 + } 
 + } 
 + 
 + @ SubscribeEvent 
 + public static void tickEntity ( TickEvent . WorldTickEvent evt ) 
 + { 
 + if ( ENABLED & & evt . side = = Side . SERVER & & evt . phase = = TickEvent . Phase . END ) 
 + { 
 + if ( evt . world . getWorldTime ( ) % 60 = = 0 ) 
 + { 
 + for ( EntityItemFrame frame : FRAMES ) 
 + { 
 + if ( ! frame . isDead & & ! frame . getDisplayedItem ( ) . isEmpty ( ) & & frame . getDisplayedItem ( ) . getItem ( ) = = Items . STICK ) 
 + { 
 + NET . sendToAllTracking ( new TestEntityMessage ( ) , frame ) ; 
 + } 
 + } 
 + } 
 + } 
 + } 
 + 
 + public static class TestEntityMessage implements IMessage 
 + { 
 + @ Override 
 + public void fromBytes ( ByteBuf buf ) { } 
 + 
 + @ Override 
 + public void toBytes ( ByteBuf buf ) { } 
 + } 
 + 
 + public static class TestEntityMessageHandler implements IMessageHandler < TestEntityMessage , IMessage > 
 + { 
 + @ Override 
 + public IMessage onMessage ( TestEntityMessage message , MessageContext ctx ) 
 + { 
 + LOGGER . info ( " Received tracking point test entity message " ) ; 
 + return null ; 
 + } 
 + } 
 + }
