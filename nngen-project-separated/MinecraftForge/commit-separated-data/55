BLEU SCORE: 0.033864985683445356

TEST MSG: Tidy up network initialization , and force it to classload early in
GENERATED MSG: Implement a GUI packet and GUIFACTORY for triggering from the server .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / ModLoader . java b / src / main / java / net / minecraftforge / fml / ModLoader . java <nl> index 473b61c . . 3887c49 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / ModLoader . java <nl> + + + b / src / main / java / net / minecraftforge / fml / ModLoader . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import net . minecraftforge . fml . loading . FMLPaths ; <nl> import net . minecraftforge . fml . loading . LoadingModList ; <nl> import net . minecraftforge . fml . loading . moddiscovery . ModFile ; <nl> import net . minecraftforge . fml . loading . moddiscovery . ModFileInfo ; <nl> + import net . minecraftforge . fml . network . FMLNetworkConstants ; <nl> import net . minecraftforge . forgespi . language . IModInfo ; <nl> import net . minecraftforge . forgespi . language . IModLanguageProvider ; <nl> import net . minecraftforge . registries . GameData ; <nl> @ @ - 99 , 6 + 100 , 7 @ @ public class ModLoader <nl> this . loadingModList = FMLLoader . getLoadingModList ( ) ; <nl> this . loadingExceptions = FMLLoader . getLoadingModList ( ) . <nl> getErrors ( ) . stream ( ) . flatMap ( ModLoadingException : : fromEarlyException ) . collect ( Collectors . toList ( ) ) ; <nl> + LOGGER . info ( CORE , " Loading Network data for FML net version : { } " , FMLNetworkConstants . NETVERSION ) ; <nl> } <nl> <nl> public static ModLoader get ( ) <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeHandler . java b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeHandler . java <nl> index 1e9a7fd . . 7a8cb91 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeHandler . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeHandler . java <nl> @ @ - 19 , 7 + 19 , 6 @ @ <nl> <nl> package net . minecraftforge . fml . network ; <nl> <nl> - import io . netty . util . AttributeKey ; <nl> import net . minecraft . network . NetworkManager ; <nl> import net . minecraft . network . PacketBuffer ; <nl> import net . minecraft . network . NetHandlerLoginServer ; <nl> @ @ - 27 , 9 + 26 , 7 @ @ import net . minecraft . util . ResourceLocation ; <nl> import net . minecraft . util . text . TextComponentString ; <nl> import net . minecraftforge . fml . config . ConfigTracker ; <nl> import net . minecraftforge . fml . network . simple . SimpleChannel ; <nl> - import net . minecraftforge . fml . util . ThreeConsumer ; <nl> import net . minecraftforge . registries . ForgeRegistry ; <nl> - import net . minecraftforge . registries . RegistryManager ; <nl> import org . apache . logging . log4j . LogManager ; <nl> import org . apache . logging . log4j . Logger ; <nl> import org . apache . logging . log4j . Marker ; <nl> @ @ - 37 , 8 + 34 , 12 @ @ import org . apache . logging . log4j . MarkerManager ; <nl> <nl> import com . google . common . collect . Maps ; <nl> <nl> - import java . util . * ; <nl> - import java . util . function . BiConsumer ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . HashSet ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> import java . util . function . Supplier ; <nl> <nl> import static net . minecraftforge . registries . ForgeRegistry . REGISTRIES ; <nl> @ @ - 47 , 9 + 48 , 9 @ @ import static net . minecraftforge . registries . ForgeRegistry . REGISTRIES ; <nl> * Instance responsible for handling the overall FML network handshake . <nl> * <nl> * < p > An instance is created during { @ link net . minecraft . network . handshake . client . CPacketHandshake } handling , and attached <nl> - * to the { @ link NetworkManager # channel } via { @ link # FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY } . <nl> + * to the { @ link NetworkManager # channel } via { @ link FMLNetworkConstants # FML _ HANDSHAKE _ HANDLER } . <nl> * <nl> - * < p > The { @ link # channel } is a { @ link SimpleChannel } with standard messages flowing in both directions . <nl> + * < p > The { @ link FMLNetworkConstants # handshakeChannel } is a { @ link SimpleChannel } with standard messages flowing in both directions . <nl> * <nl> * < p > The { @ link # loginWrapper } transforms these messages into { @ link net . minecraft . network . login . client . CPacketCustomPayloadLogin } <nl> * and { @ link net . minecraft . network . login . server . SPacketCustomPayloadLogin } compatible messages , by means of wrapping . <nl> @ @ - 76 , 75 + 77 , 10 @ @ import static net . minecraftforge . registries . ForgeRegistry . REGISTRIES ; <nl> public class FMLHandshakeHandler { <nl> static final Marker FMLHSMARKER = MarkerManager . getMarker ( " FMLHANDSHAKE " ) . setParents ( FMLNetworkConstants . NETWORK ) ; <nl> private static final Logger LOGGER = LogManager . getLogger ( ) ; <nl> - static final ResourceLocation FML _ HANDSHAKE _ RESOURCE = new ResourceLocation ( " fml : handshake " ) ; <nl> - private static final AttributeKey < FMLHandshakeHandler > FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY = AttributeKey . newInstance ( " fml : handshake " ) ; <nl> <nl> private static final FMLLoginWrapper loginWrapper = new FMLLoginWrapper ( ) ; <nl> - private static SimpleChannel channel ; <nl> - static { <nl> - channel = NetworkRegistry . ChannelBuilder . named ( FML _ HANDSHAKE _ RESOURCE ) . <nl> - clientAcceptedVersions ( a - > true ) . <nl> - serverAcceptedVersions ( a - > true ) . <nl> - networkProtocolVersion ( ( ) - > FMLNetworkConstants . NETVERSION ) . <nl> - simpleChannel ( ) ; <nl> - channel . messageBuilder ( FMLHandshakeMessages . C2SAcknowledge . class , 99 ) . <nl> - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> - decoder ( FMLHandshakeMessages . C2SAcknowledge : : decode ) . <nl> - encoder ( FMLHandshakeMessages . C2SAcknowledge : : encode ) . <nl> - consumer ( indexFirst ( FMLHandshakeHandler : : handleClientAck ) ) . <nl> - add ( ) ; <nl> - channel . messageBuilder ( FMLHandshakeMessages . S2CModList . class , 1 ) . <nl> - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> - decoder ( FMLHandshakeMessages . S2CModList : : decode ) . <nl> - encoder ( FMLHandshakeMessages . S2CModList : : encode ) . <nl> - markAsLoginPacket ( ) . <nl> - consumer ( biConsumerFor ( FMLHandshakeHandler : : handleServerModListOnClient ) ) . <nl> - add ( ) ; <nl> - channel . messageBuilder ( FMLHandshakeMessages . C2SModListReply . class , 2 ) . <nl> - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> - decoder ( FMLHandshakeMessages . C2SModListReply : : decode ) . <nl> - encoder ( FMLHandshakeMessages . C2SModListReply : : encode ) . <nl> - consumer ( indexFirst ( FMLHandshakeHandler : : handleClientModListOnServer ) ) . <nl> - add ( ) ; <nl> - channel . messageBuilder ( FMLHandshakeMessages . S2CRegistry . class , 3 ) . <nl> - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> - decoder ( FMLHandshakeMessages . S2CRegistry : : decode ) . <nl> - encoder ( FMLHandshakeMessages . S2CRegistry : : encode ) . <nl> - buildLoginPacketList ( RegistryManager : : generateRegistryPackets ) . / / TODO : Make this non - static , and store a cache on the client . <nl> - consumer ( biConsumerFor ( FMLHandshakeHandler : : handleRegistryMessage ) ) . <nl> - add ( ) ; <nl> - channel . messageBuilder ( FMLHandshakeMessages . S2CConfigData . class , 4 ) . <nl> - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> - decoder ( FMLHandshakeMessages . S2CConfigData : : decode ) . <nl> - encoder ( FMLHandshakeMessages . S2CConfigData : : encode ) . <nl> - buildLoginPacketList ( ConfigTracker . INSTANCE : : syncConfigs ) . <nl> - consumer ( biConsumerFor ( FMLHandshakeHandler : : handleConfigSync ) ) . <nl> - add ( ) ; <nl> - } <nl> <nl> - / * * <nl> - * Transforms a two - argument instance method reference into a { @ link BiConsumer } based on the { @ link # getHandshake ( Supplier ) } function . <nl> - * <nl> - * @ param consumer A two argument instance method reference <nl> - * @ param < MSG > message type <nl> - * @ return A { @ link BiConsumer } for use in message handling <nl> - * / <nl> - private static < MSG extends FMLHandshakeMessages . LoginIndexedMessage > BiConsumer < MSG , Supplier < NetworkEvent . Context > > biConsumerFor ( ThreeConsumer < FMLHandshakeHandler , ? super MSG , ? super Supplier < NetworkEvent . Context > > consumer ) <nl> - { <nl> - return ( m , c ) - > ThreeConsumer . bindArgs ( consumer , m , c ) . accept ( getHandshake ( c ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Transforms a two - argument instance method reference into a { @ link BiConsumer } { @ link # biConsumerFor ( ThreeConsumer ) } , first calling the { @ link # handleIndexedMessage ( FMLHandshakeMessages . LoginIndexedMessage , Supplier ) } <nl> - * method to handle index tracking . Used for client to server replies . <nl> - * @ param next The method reference to call after index handling <nl> - * @ param < MSG > message type <nl> - * @ return A { @ link BiConsumer } for use in message handling <nl> - * / <nl> - private static < MSG extends FMLHandshakeMessages . LoginIndexedMessage > BiConsumer < MSG , Supplier < NetworkEvent . Context > > indexFirst ( ThreeConsumer < FMLHandshakeHandler , MSG , Supplier < NetworkEvent . Context > > next ) <nl> - { <nl> - final BiConsumer < MSG , Supplier < NetworkEvent . Context > > loginIndexedMessageSupplierBiConsumer = biConsumerFor ( FMLHandshakeHandler : : handleIndexedMessage ) ; <nl> - return loginIndexedMessageSupplierBiConsumer . andThen ( biConsumerFor ( next ) ) ; <nl> + static { <nl> } <nl> <nl> / * * <nl> @ @ - 155 , 22 + 91 , 12 @ @ public class FMLHandshakeHandler { <nl> * @ param direction The { @ link NetworkDirection } for this connection : { @ link NetworkDirection # LOGIN _ TO _ SERVER } or { @ link NetworkDirection # LOGIN _ TO _ CLIENT } <nl> * / <nl> static void registerHandshake ( NetworkManager manager , NetworkDirection direction ) { <nl> - manager . channel ( ) . attr ( FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY ) . compareAndSet ( null , new FMLHandshakeHandler ( manager , direction ) ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Retrieve the handshake from the { @ link NetworkEvent . Context } <nl> - * <nl> - * @ param contextSupplier the { @ link NetworkEvent . Context } <nl> - * @ return The handshake handler for the connection <nl> - * / <nl> - private static FMLHandshakeHandler getHandshake ( Supplier < NetworkEvent . Context > contextSupplier ) { <nl> - return contextSupplier . get ( ) . attr ( FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY ) . get ( ) ; <nl> + manager . channel ( ) . attr ( FMLNetworkConstants . FML _ HANDSHAKE _ HANDLER ) . compareAndSet ( null , new FMLHandshakeHandler ( manager , direction ) ) ; <nl> } <nl> <nl> static boolean tickLogin ( NetworkManager networkManager ) <nl> { <nl> - return networkManager . channel ( ) . attr ( FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY ) . get ( ) . tickServer ( ) ; <nl> + return networkManager . channel ( ) . attr ( FMLNetworkConstants . FML _ HANDSHAKE _ HANDLER ) . get ( ) . tickServer ( ) ; <nl> } <nl> <nl> private List < NetworkRegistry . LoginPayload > messageList ; <nl> @ @ - 197 , 7 + 123 , 7 @ @ public class FMLHandshakeHandler { <nl> } <nl> } <nl> <nl> - private void handleServerModListOnClient ( FMLHandshakeMessages . S2CModList serverModList , Supplier < NetworkEvent . Context > c ) <nl> + void handleServerModListOnClient ( FMLHandshakeMessages . S2CModList serverModList , Supplier < NetworkEvent . Context > c ) <nl> { <nl> LOGGER . debug ( FMLHSMARKER , " Logging into server with mod list [ { } ] " , String . join ( " , " , serverModList . getModList ( ) ) ) ; <nl> boolean accepted = NetworkRegistry . validateClientChannels ( serverModList . getChannels ( ) ) ; <nl> @ @ - 207 , 18 + 133 , 18 @ @ public class FMLHandshakeHandler { <nl> c . get ( ) . getNetworkManager ( ) . closeChannel ( new TextComponentString ( " Connection closed - mismatched mod channel list " ) ) ; <nl> return ; <nl> } <nl> - channel . reply ( new FMLHandshakeMessages . C2SModListReply ( ) , c . get ( ) ) ; <nl> + FMLNetworkConstants . handshakeChannel . reply ( new FMLHandshakeMessages . C2SModListReply ( ) , c . get ( ) ) ; <nl> <nl> LOGGER . debug ( FMLHSMARKER , " Accepted server connection " ) ; <nl> / / Set the modded marker on the channel so we know we got packets <nl> - c . get ( ) . getNetworkManager ( ) . channel ( ) . attr ( FMLNetworkConstants . FML _ MARKER ) . set ( FMLNetworkConstants . NETVERSION ) ; <nl> + c . get ( ) . getNetworkManager ( ) . channel ( ) . attr ( FMLNetworkConstants . FML _ NETVERSION ) . set ( FMLNetworkConstants . NETVERSION ) ; <nl> <nl> this . registriesToReceive = new HashSet < > ( serverModList . getRegistries ( ) ) ; <nl> this . registrySnapshots = Maps . newHashMap ( ) ; <nl> LOGGER . debug ( REGISTRIES , " Expecting { } registries : { } " , ( ) - > this . registriesToReceive . size ( ) , ( ) - > this . registriesToReceive ) ; <nl> } <nl> <nl> - private < MSG extends FMLHandshakeMessages . LoginIndexedMessage > void handleIndexedMessage ( MSG message , Supplier < NetworkEvent . Context > c ) <nl> + < MSG extends FMLHandshakeMessages . LoginIndexedMessage > void handleIndexedMessage ( MSG message , Supplier < NetworkEvent . Context > c ) <nl> { <nl> LOGGER . debug ( FMLHSMARKER , " Received client indexed reply { } of type { } " , message . getLoginIndex ( ) , message . getClass ( ) . getName ( ) ) ; <nl> boolean removed = this . sentMessages . removeIf ( i - > i = = message . getLoginIndex ( ) ) ; <nl> @ @ - 227 , 7 + 153 , 7 @ @ public class FMLHandshakeHandler { <nl> } <nl> } <nl> <nl> - private void handleClientModListOnServer ( FMLHandshakeMessages . C2SModListReply clientModList , Supplier < NetworkEvent . Context > c ) <nl> + void handleClientModListOnServer ( FMLHandshakeMessages . C2SModListReply clientModList , Supplier < NetworkEvent . Context > c ) <nl> { <nl> LOGGER . debug ( FMLHSMARKER , " Received client connection with modlist [ { } ] " , String . join ( " , " , clientModList . getModList ( ) ) ) ; <nl> boolean accepted = NetworkRegistry . validateServerChannels ( clientModList . getChannels ( ) ) ; <nl> @ @ - 240 , 12 + 166 , 12 @ @ public class FMLHandshakeHandler { <nl> LOGGER . debug ( FMLHSMARKER , " Accepted client connection mod list " ) ; <nl> } <nl> <nl> - private void handleRegistryMessage ( final FMLHandshakeMessages . S2CRegistry registryPacket , final Supplier < NetworkEvent . Context > contextSupplier ) { <nl> + void handleRegistryMessage ( final FMLHandshakeMessages . S2CRegistry registryPacket , final Supplier < NetworkEvent . Context > contextSupplier ) { <nl> LOGGER . debug ( FMLHSMARKER , " Received registry packet for { } " , registryPacket . getRegistryName ( ) ) ; <nl> this . registriesToReceive . remove ( registryPacket . getRegistryName ( ) ) ; <nl> this . registrySnapshots . put ( registryPacket . getRegistryName ( ) , registryPacket . getSnapshot ( ) ) ; <nl> contextSupplier . get ( ) . setPacketHandled ( true ) ; <nl> - channel . reply ( new FMLHandshakeMessages . C2SAcknowledge ( ) , contextSupplier . get ( ) ) ; <nl> + FMLNetworkConstants . handshakeChannel . reply ( new FMLHandshakeMessages . C2SAcknowledge ( ) , contextSupplier . get ( ) ) ; <nl> <nl> if ( this . registriesToReceive . isEmpty ( ) ) { <nl> / / TODO : @ cpw injectSnapshot Needs to be on the world thread . And maybe block the network / login so we don ' t get world data before we finish ? <nl> @ @ - 253 , 16 + 179 , 16 @ @ public class FMLHandshakeHandler { <nl> } <nl> } <nl> <nl> - private void handleClientAck ( final FMLHandshakeMessages . C2SAcknowledge msg , final Supplier < NetworkEvent . Context > contextSupplier ) { <nl> + void handleClientAck ( final FMLHandshakeMessages . C2SAcknowledge msg , final Supplier < NetworkEvent . Context > contextSupplier ) { <nl> LOGGER . debug ( FMLHSMARKER , " Received acknowledgement from client " ) ; <nl> contextSupplier . get ( ) . setPacketHandled ( true ) ; <nl> } <nl> <nl> - private void handleConfigSync ( final FMLHandshakeMessages . S2CConfigData msg , final Supplier < NetworkEvent . Context > contextSupplier ) { <nl> + void handleConfigSync ( final FMLHandshakeMessages . S2CConfigData msg , final Supplier < NetworkEvent . Context > contextSupplier ) { <nl> LOGGER . debug ( FMLHSMARKER , " Received config sync from server " ) ; <nl> ConfigTracker . INSTANCE . receiveSyncedConfig ( msg , contextSupplier ) ; <nl> contextSupplier . get ( ) . setPacketHandled ( true ) ; <nl> - channel . reply ( new FMLHandshakeMessages . C2SAcknowledge ( ) , contextSupplier . get ( ) ) ; <nl> + FMLNetworkConstants . handshakeChannel . reply ( new FMLHandshakeMessages . C2SAcknowledge ( ) , contextSupplier . get ( ) ) ; <nl> } <nl> / * * <nl> * FML will send packets , from Server to Client , from the messages queue until the queue is drained . Each message <nl> @ @ - 289 , 7 + 215 , 7 @ @ public class FMLHandshakeHandler { <nl> / / we ' re done when sentMessages is empty <nl> if ( sentMessages . isEmpty ( ) & & packetPosition > = messageList . size ( ) - 1 ) { <nl> / / clear ourselves - we ' re done ! <nl> - this . manager . channel ( ) . attr ( FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY ) . set ( null ) ; <nl> + this . manager . channel ( ) . attr ( FMLNetworkConstants . FML _ HANDSHAKE _ HANDLER ) . set ( null ) ; <nl> LOGGER . debug ( FMLHSMARKER , " Handshake complete ! " ) ; <nl> return true ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessages . java b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessages . java <nl> index de4cc93 . . 373df14 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessages . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessages . java <nl> @ @ - 21 , 7 + 21 , 6 @ @ package net . minecraftforge . fml . network ; <nl> <nl> import net . minecraft . network . PacketBuffer ; <nl> import net . minecraft . util . ResourceLocation ; <nl> - import net . minecraftforge . common . util . HexDumper ; <nl> import net . minecraftforge . fml . ModList ; <nl> import net . minecraftforge . fml . loading . moddiscovery . ModInfo ; <nl> import net . minecraftforge . registries . ForgeRegistry ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLLoginWrapper . java b / src / main / java / net / minecraftforge / fml / network / FMLLoginWrapper . java <nl> index d282839 . . 682c10e 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / FMLLoginWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / FMLLoginWrapper . java <nl> @ @ - 49 , 7 + 49 , 7 @ @ public class FMLLoginWrapper { <nl> private < T extends NetworkEvent > void wrapperReceived ( final T packet ) { <nl> final NetworkEvent . Context wrappedContext = packet . getSource ( ) . get ( ) ; <nl> final PacketBuffer payload = packet . getPayload ( ) ; <nl> - ResourceLocation targetNetworkReceiver = FMLHandshakeHandler . FML _ HANDSHAKE _ RESOURCE ; <nl> + ResourceLocation targetNetworkReceiver = FMLNetworkConstants . FML _ HANDSHAKE _ RESOURCE ; <nl> PacketBuffer data = null ; <nl> if ( payload ! = null ) { <nl> targetNetworkReceiver = payload . readResourceLocation ( ) ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLNetworkConstants . java b / src / main / java / net / minecraftforge / fml / network / FMLNetworkConstants . java <nl> index 9c02758 . . 0c2dbe2 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / FMLNetworkConstants . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / FMLNetworkConstants . java <nl> @ @ - 20 , 6 + 20 , 8 @ @ <nl> package net . minecraftforge . fml . network ; <nl> <nl> import io . netty . util . AttributeKey ; <nl> + import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . fml . network . simple . SimpleChannel ; <nl> import org . apache . logging . log4j . Marker ; <nl> import org . apache . logging . log4j . MarkerManager ; <nl> <nl> @ @ - 32 , 6 + 34 , 12 @ @ public class FMLNetworkConstants <nl> public static final int FMLNETVERSION = 2 ; <nl> public static final String NETVERSION = FMLNETMARKER + FMLNETVERSION ; <nl> public static final String NOVERSION = " NONE " ; <nl> + <nl> static final Marker NETWORK = MarkerManager . getMarker ( " FMLNETWORK " ) ; <nl> - static final AttributeKey < String > FML _ MARKER = AttributeKey . valueOf ( " fml : marker " ) ; <nl> + static final AttributeKey < String > FML _ NETVERSION = AttributeKey . valueOf ( " fml : netversion " ) ; <nl> + static final AttributeKey < FMLHandshakeHandler > FML _ HANDSHAKE _ HANDLER = AttributeKey . valueOf ( " fml : handshake " ) ; <nl> + static final ResourceLocation FML _ HANDSHAKE _ RESOURCE = new ResourceLocation ( " fml : handshake " ) ; <nl> + static final ResourceLocation FML _ PLAY _ RESOURCE = new ResourceLocation ( " fml : play " ) ; <nl> + static final SimpleChannel handshakeChannel = NetworkInitialization . getHandshakeChannel ( ) ; <nl> + static final SimpleChannel playChannel = NetworkInitialization . getPlayChannel ( ) ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLPlayHandler . java b / src / main / java / net / minecraftforge / fml / network / FMLPlayHandler . java <nl> deleted file mode 100644 <nl> index 052f03e . . 0000000 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / FMLPlayHandler . java <nl> + + + / dev / null <nl> @ @ - 1 , 38 + 0 , 0 @ @ <nl> - / * <nl> - * Minecraft Forge <nl> - * Copyright ( c ) 2016 - 2019 . <nl> - * <nl> - * This library is free software ; you can redistribute it and / or <nl> - * modify it under the terms of the GNU Lesser General Public <nl> - * License as published by the Free Software Foundation version 2 . 1 <nl> - * of the License . <nl> - * <nl> - * This library is distributed in the hope that it will be useful , <nl> - * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> - * <nl> - * You should have received a copy of the GNU Lesser General Public <nl> - * License along with this library ; if not , write to the Free Software <nl> - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> - * / <nl> - <nl> - package net . minecraftforge . fml . network ; <nl> - <nl> - import net . minecraft . util . ResourceLocation ; <nl> - import net . minecraftforge . fml . network . simple . SimpleChannel ; <nl> - <nl> - public class FMLPlayHandler <nl> - { <nl> - public static final SimpleChannel channel = NetworkRegistry . ChannelBuilder <nl> - . named ( new ResourceLocation ( " fml " , " play " ) ) <nl> - . clientAcceptedVersions ( a - > true ) <nl> - . serverAcceptedVersions ( a - > true ) <nl> - . networkProtocolVersion ( ( ) - > FMLNetworkConstants . NETVERSION ) <nl> - . simpleChannel ( ) ; <nl> - static <nl> - { <nl> - channel . registerMessage ( 0 , FMLPlayMessages . SpawnEntity . class , FMLPlayMessages . SpawnEntity : : encode , FMLPlayMessages . SpawnEntity : : decode , FMLPlayMessages . SpawnEntity : : handle ) ; <nl> - channel . registerMessage ( 1 , FMLPlayMessages . OpenContainer . class , FMLPlayMessages . OpenContainer : : encode , FMLPlayMessages . OpenContainer : : decode , FMLPlayMessages . OpenContainer : : handle ) ; <nl> - } <nl> - } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> index f76e9e8 . . 4d9f27a 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> @ @ - 52 , 14 + 52 , 14 @ @ public class NetworkHooks <nl> <nl> public static ConnectionType getConnectionType ( final Supplier < NetworkManager > connection ) <nl> { <nl> - return ConnectionType . forVersionFlag ( connection . get ( ) . channel ( ) . attr ( FMLNetworkConstants . FML _ MARKER ) . get ( ) ) ; <nl> + return ConnectionType . forVersionFlag ( connection . get ( ) . channel ( ) . attr ( FMLNetworkConstants . FML _ NETVERSION ) . get ( ) ) ; <nl> } <nl> <nl> public static Packet < ? > getEntitySpawningPacket ( Entity entity ) <nl> { <nl> if ( ! entity . getType ( ) . usesVanillaSpawning ( ) ) <nl> { <nl> - return FMLPlayHandler . channel . toVanillaPacket ( new FMLPlayMessages . SpawnEntity ( entity ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + return FMLNetworkConstants . playChannel . toVanillaPacket ( new FMLPlayMessages . SpawnEntity ( entity ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> } <nl> return null ; <nl> } <nl> @ @ - 71 , 14 + 71 , 14 @ @ public class NetworkHooks <nl> <nl> public static void registerServerLoginChannel ( NetworkManager manager , CPacketHandshake packet ) <nl> { <nl> - manager . channel ( ) . attr ( FMLNetworkConstants . FML _ MARKER ) . set ( packet . getFMLVersion ( ) ) ; <nl> + manager . channel ( ) . attr ( FMLNetworkConstants . FML _ NETVERSION ) . set ( packet . getFMLVersion ( ) ) ; <nl> FMLHandshakeHandler . registerHandshake ( manager , NetworkDirection . LOGIN _ TO _ CLIENT ) ; <nl> } <nl> <nl> public static void registerClientLoginChannel ( NetworkManager manager ) <nl> { <nl> if ( manager = = null | | manager . channel ( ) = = null ) return ; <nl> - manager . channel ( ) . attr ( FMLNetworkConstants . FML _ MARKER ) . set ( FMLNetworkConstants . NOVERSION ) ; <nl> + manager . channel ( ) . attr ( FMLNetworkConstants . FML _ NETVERSION ) . set ( FMLNetworkConstants . NOVERSION ) ; <nl> FMLHandshakeHandler . registerHandshake ( manager , NetworkDirection . LOGIN _ TO _ SERVER ) ; <nl> } <nl> <nl> @ @ - 167 , 7 + 167 , 7 @ @ public class NetworkHooks <nl> throw new IllegalArgumentException ( " Invalid PacketBuffer for openGui , found " + output . readableBytes ( ) + " bytes " ) ; <nl> } <nl> FMLPlayMessages . OpenContainer msg = new FMLPlayMessages . OpenContainer ( id , openContainerId , output ) ; <nl> - FMLPlayHandler . channel . sendTo ( msg , player . connection . getNetworkManager ( ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> + FMLNetworkConstants . playChannel . sendTo ( msg , player . connection . getNetworkManager ( ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> <nl> Container c = containerSupplier . createContainer ( player . inventory , player ) ; <nl> player . openContainer = c ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkInitialization . java b / src / main / java / net / minecraftforge / fml / network / NetworkInitialization . java <nl> new file mode 100644 <nl> index 0000000 . . b9d7c90 <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkInitialization . java <nl> @ @ - 0 , 0 + 1 , 139 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 - 2019 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . fml . network ; <nl> + <nl> + import net . minecraftforge . fml . config . ConfigTracker ; <nl> + import net . minecraftforge . fml . network . simple . SimpleChannel ; <nl> + import net . minecraftforge . fml . util . ThreeConsumer ; <nl> + import net . minecraftforge . registries . RegistryManager ; <nl> + <nl> + import java . util . function . BiConsumer ; <nl> + import java . util . function . Supplier ; <nl> + <nl> + class NetworkInitialization { <nl> + <nl> + public static SimpleChannel getHandshakeChannel ( ) { <nl> + SimpleChannel handshakeChannel = NetworkRegistry . ChannelBuilder . <nl> + named ( FMLNetworkConstants . FML _ HANDSHAKE _ RESOURCE ) . <nl> + clientAcceptedVersions ( a - > true ) . <nl> + serverAcceptedVersions ( a - > true ) . <nl> + networkProtocolVersion ( ( ) - > FMLNetworkConstants . NETVERSION ) . <nl> + simpleChannel ( ) ; <nl> + <nl> + handshakeChannel . messageBuilder ( FMLHandshakeMessages . C2SAcknowledge . class , 99 ) . <nl> + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> + decoder ( FMLHandshakeMessages . C2SAcknowledge : : decode ) . <nl> + encoder ( FMLHandshakeMessages . C2SAcknowledge : : encode ) . <nl> + consumer ( indexFirst ( FMLHandshakeHandler : : handleClientAck ) ) . <nl> + add ( ) ; <nl> + <nl> + handshakeChannel . messageBuilder ( FMLHandshakeMessages . S2CModList . class , 1 ) . <nl> + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> + decoder ( FMLHandshakeMessages . S2CModList : : decode ) . <nl> + encoder ( FMLHandshakeMessages . S2CModList : : encode ) . <nl> + markAsLoginPacket ( ) . <nl> + consumer ( biConsumerFor ( FMLHandshakeHandler : : handleServerModListOnClient ) ) . <nl> + add ( ) ; <nl> + <nl> + handshakeChannel . messageBuilder ( FMLHandshakeMessages . C2SModListReply . class , 2 ) . <nl> + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> + decoder ( FMLHandshakeMessages . C2SModListReply : : decode ) . <nl> + encoder ( FMLHandshakeMessages . C2SModListReply : : encode ) . <nl> + consumer ( indexFirst ( FMLHandshakeHandler : : handleClientModListOnServer ) ) . <nl> + add ( ) ; <nl> + <nl> + handshakeChannel . messageBuilder ( FMLHandshakeMessages . S2CRegistry . class , 3 ) . <nl> + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> + decoder ( FMLHandshakeMessages . S2CRegistry : : decode ) . <nl> + encoder ( FMLHandshakeMessages . S2CRegistry : : encode ) . <nl> + buildLoginPacketList ( RegistryManager : : generateRegistryPackets ) . / / TODO : Make this non - static , and store a cache on the client . <nl> + consumer ( biConsumerFor ( FMLHandshakeHandler : : handleRegistryMessage ) ) . <nl> + add ( ) ; <nl> + <nl> + handshakeChannel . messageBuilder ( FMLHandshakeMessages . S2CConfigData . class , 4 ) . <nl> + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . <nl> + decoder ( FMLHandshakeMessages . S2CConfigData : : decode ) . <nl> + encoder ( FMLHandshakeMessages . S2CConfigData : : encode ) . <nl> + buildLoginPacketList ( ConfigTracker . INSTANCE : : syncConfigs ) . <nl> + consumer ( biConsumerFor ( FMLHandshakeHandler : : handleConfigSync ) ) . <nl> + add ( ) ; <nl> + <nl> + return handshakeChannel ; <nl> + } <nl> + <nl> + public static SimpleChannel getPlayChannel ( ) { <nl> + SimpleChannel playChannel = NetworkRegistry . ChannelBuilder <nl> + . named ( FMLNetworkConstants . FML _ PLAY _ RESOURCE ) <nl> + . clientAcceptedVersions ( a - > true ) <nl> + . serverAcceptedVersions ( a - > true ) <nl> + . networkProtocolVersion ( ( ) - > FMLNetworkConstants . NETVERSION ) <nl> + . simpleChannel ( ) ; <nl> + <nl> + playChannel . messageBuilder ( FMLPlayMessages . SpawnEntity . class , 0 ) . <nl> + decoder ( FMLPlayMessages . SpawnEntity : : decode ) . <nl> + encoder ( FMLPlayMessages . SpawnEntity : : encode ) . <nl> + consumer ( FMLPlayMessages . SpawnEntity : : handle ) . <nl> + add ( ) ; <nl> + <nl> + playChannel . messageBuilder ( FMLPlayMessages . OpenContainer . class , 1 ) . <nl> + decoder ( FMLPlayMessages . OpenContainer : : decode ) . <nl> + encoder ( FMLPlayMessages . OpenContainer : : encode ) . <nl> + consumer ( FMLPlayMessages . OpenContainer : : handle ) . <nl> + add ( ) ; <nl> + <nl> + return playChannel ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Transforms a two - argument instance method reference into a { @ link BiConsumer } based on the { @ link # getHandshake ( Supplier ) } function . <nl> + * <nl> + * @ param consumer A two argument instance method reference <nl> + * @ param < MSG > message type <nl> + * @ return A { @ link BiConsumer } for use in message handling <nl> + * / <nl> + private static < MSG extends FMLHandshakeMessages . LoginIndexedMessage > BiConsumer < MSG , Supplier < NetworkEvent . Context > > biConsumerFor ( ThreeConsumer < FMLHandshakeHandler , ? super MSG , ? super Supplier < NetworkEvent . Context > > consumer ) <nl> + { <nl> + return ( m , c ) - > ThreeConsumer . bindArgs ( consumer , m , c ) . accept ( getHandshake ( c ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Transforms a two - argument instance method reference into a { @ link BiConsumer } { @ link # biConsumerFor ( ThreeConsumer ) } , first calling the { @ link # handleIndexedMessage ( FMLHandshakeMessages . LoginIndexedMessage , Supplier ) } <nl> + * method to handle index tracking . Used for client to server replies . <nl> + * @ param next The method reference to call after index handling <nl> + * @ param < MSG > message type <nl> + * @ return A { @ link BiConsumer } for use in message handling <nl> + * / <nl> + private static < MSG extends FMLHandshakeMessages . LoginIndexedMessage > BiConsumer < MSG , Supplier < NetworkEvent . Context > > indexFirst ( ThreeConsumer < FMLHandshakeHandler , MSG , Supplier < NetworkEvent . Context > > next ) <nl> + { <nl> + final BiConsumer < MSG , Supplier < NetworkEvent . Context > > loginIndexedMessageSupplierBiConsumer = biConsumerFor ( FMLHandshakeHandler : : handleIndexedMessage ) ; <nl> + return loginIndexedMessageSupplierBiConsumer . andThen ( biConsumerFor ( next ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve the handshake from the { @ link NetworkEvent . Context } <nl> + * <nl> + * @ param contextSupplier the { @ link NetworkEvent . Context } <nl> + * @ return The handshake handler for the connection <nl> + * / <nl> + private static FMLHandshakeHandler getHandshake ( Supplier < NetworkEvent . Context > contextSupplier ) { <nl> + return contextSupplier . get ( ) . attr ( FMLNetworkConstants . FML _ HANDSHAKE _ HANDLER ) . get ( ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / DeferredWorkQueue . java b / src / main / java / net / minecraftforge / fml / DeferredWorkQueue . java <nl> index 3a51300 . . 8227193 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / DeferredWorkQueue . java <nl> + + + b / src / main / java / net / minecraftforge / fml / DeferredWorkQueue . java <nl> @ @ - 109 , 7 + 109 , 7 @ @ public class DeferredWorkQueue <nl> * @ return A { @ link CompletableFuture } that completes at said time <nl> * / <nl> public static CompletableFuture < Void > runLater ( Runnable workToEnqueue ) { <nl> - currentOwner . set ( ModThreadContext . get ( ) . getActiveContainer ( ) ) ; <nl> + currentOwner . set ( ModLoadingContext . get ( ) . getActiveContainer ( ) ) ; <nl> return CompletableFuture . runAsync ( workToEnqueue , deferredExecutor ) . exceptionally ( DeferredWorkQueue . handleException ( ) ) ; <nl> } <nl> <nl> @ @ - 154 , 7 + 154 , 7 @ @ public class DeferredWorkQueue <nl> * @ return A { @ link CompletableFuture } that completes at said time <nl> * / <nl> public static < T > CompletableFuture < T > getLater ( Supplier < T > workToEnqueue ) { <nl> - currentOwner . set ( ModThreadContext . get ( ) . getActiveContainer ( ) ) ; <nl> + currentOwner . set ( ModLoadingContext . get ( ) . getActiveContainer ( ) ) ; <nl> return CompletableFuture . supplyAsync ( workToEnqueue , deferredExecutor ) . exceptionally ( DeferredWorkQueue . handleException ( ) ) ; <nl> } <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / fml / ExtensionPoint . java b / src / main / java / net / minecraftforge / fml / ExtensionPoint . java <nl> index d087bc0 . . 9cce0ba 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / ExtensionPoint . java <nl> + + + b / src / main / java / net / minecraftforge / fml / ExtensionPoint . java <nl> @ @ - 22 , 14 + 22 , 23 @ @ package net . minecraftforge . fml ; <nl> import net . minecraft . client . Minecraft ; <nl> import net . minecraft . client . gui . GuiScreen ; <nl> import net . minecraft . resources . IResourcePack ; <nl> + import net . minecraftforge . fml . network . FMLPlayMessages ; <nl> import net . minecraftforge . fml . packs . ModFileResourcePack ; <nl> <nl> import java . util . function . BiFunction ; <nl> + import java . util . function . Function ; <nl> <nl> public class ExtensionPoint < T > <nl> { <nl> - public static final ExtensionPoint < BiFunction < Minecraft , GuiScreen , GuiScreen > > GUIFACTORY = new ExtensionPoint < > ( ) ; <nl> + public static final ExtensionPoint < BiFunction < Minecraft , GuiScreen , GuiScreen > > CONFIGGUIFACTORY = new ExtensionPoint < > ( ) ; <nl> public static final ExtensionPoint < BiFunction < Minecraft , ModFileResourcePack , IResourcePack > > RESOURCEPACK = new ExtensionPoint < > ( ) ; <nl> + <nl> + / * * <nl> + * Register with { @ link ModLoadingContext # } <nl> + * / <nl> + public static final ExtensionPoint < Function < FMLPlayMessages . OpenContainer , GuiScreen > > GUIFACTORY = new ExtensionPoint < > ( ) ; <nl> + <nl> + <nl> private Class < T > type ; <nl> <nl> private ExtensionPoint ( ) { <nl> diff - - git a / src / main / java / net / minecraftforge / fml / ModContainer . java b / src / main / java / net / minecraftforge / fml / ModContainer . java <nl> index 4afbf87 . . 92a7c7a 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / ModContainer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / ModContainer . java <nl> @ @ - 115 , 11 + 115 , 11 @ @ public abstract class ModContainer <nl> } <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> - public < T > Optional < T > getCustomExtension ( ExtensionPoint point ) { <nl> + public < T > Optional < T > getCustomExtension ( ExtensionPoint < T > point ) { <nl> return Optional . ofNullable ( ( T ) extensionPoints . getOrDefault ( point , ( ) - > null ) . get ( ) ) ; <nl> } <nl> <nl> - public < T > void registerExtensionPoint ( ExtensionPoint point , Supplier < T > extension ) <nl> + public < T > void registerExtensionPoint ( ExtensionPoint < T > point , Supplier < T > extension ) <nl> { <nl> extensionPoints . put ( point , extension ) ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / ModLoadingContext . java b / src / main / java / net / minecraftforge / fml / ModLoadingContext . java <nl> new file mode 100644 <nl> index 0000000 . . d654666 <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / ModLoadingContext . java <nl> @ @ - 0 , 0 + 1 , 52 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 - 2019 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . fml ; <nl> + <nl> + import java . util . function . Supplier ; <nl> + <nl> + public class ModLoadingContext <nl> + { <nl> + private static ThreadLocal < ModLoadingContext > context = ThreadLocal . withInitial ( ModLoadingContext : : new ) ; <nl> + <nl> + public static ModLoadingContext get ( ) { <nl> + return context . get ( ) ; <nl> + } <nl> + <nl> + private ModContainer activeContainer ; <nl> + <nl> + public void setActiveContainer ( final ModContainer container ) { <nl> + this . activeContainer = container ; <nl> + } <nl> + <nl> + public ModContainer getActiveContainer ( ) { <nl> + return activeContainer = = null ? DefaultModContainers . MINECRAFT : activeContainer ; <nl> + } <nl> + <nl> + / * * <nl> + * Register an { @ link ExtensionPoint } with the mod container . <nl> + * @ param point The extension point to register <nl> + * @ param extension An extension operator <nl> + * @ param < T > The type signature of the extension operator <nl> + * / <nl> + public < T > void registerExtensionPoint ( ExtensionPoint < T > point , Supplier < T > extension ) { <nl> + getActiveContainer ( ) . registerExtensionPoint ( point , extension ) ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / ModThreadContext . java b / src / main / java / net / minecraftforge / fml / ModThreadContext . java <nl> deleted file mode 100644 <nl> index 9bf7e8f . . 0000000 <nl> - - - a / src / main / java / net / minecraftforge / fml / ModThreadContext . java <nl> + + + / dev / null <nl> @ @ - 1 , 39 + 0 , 0 @ @ <nl> - / * <nl> - * Minecraft Forge <nl> - * Copyright ( c ) 2016 - 2019 . <nl> - * <nl> - * This library is free software ; you can redistribute it and / or <nl> - * modify it under the terms of the GNU Lesser General Public <nl> - * License as published by the Free Software Foundation version 2 . 1 <nl> - * of the License . <nl> - * <nl> - * This library is distributed in the hope that it will be useful , <nl> - * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> - * <nl> - * You should have received a copy of the GNU Lesser General Public <nl> - * License along with this library ; if not , write to the Free Software <nl> - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> - * / <nl> - <nl> - package net . minecraftforge . fml ; <nl> - <nl> - public class ModThreadContext <nl> - { <nl> - private static ThreadLocal < ModThreadContext > context = ThreadLocal . withInitial ( ModThreadContext : : new ) ; <nl> - <nl> - public static ModThreadContext get ( ) { <nl> - return context . get ( ) ; <nl> - } <nl> - <nl> - private ModContainer activeContainer ; <nl> - <nl> - public void setActiveContainer ( final ModContainer container ) { <nl> - this . activeContainer = container ; <nl> - } <nl> - <nl> - public ModContainer getActiveContainer ( ) { <nl> - return activeContainer = = null ? DefaultModContainers . MINECRAFT : activeContainer ; <nl> - } <nl> - } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / client / ConfigGuiHandler . java b / src / main / java / net / minecraftforge / fml / client / ConfigGuiHandler . java <nl> index b258b4c . . c12d63f 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / client / ConfigGuiHandler . java <nl> + + + b / src / main / java / net / minecraftforge / fml / client / ConfigGuiHandler . java <nl> @ @ - 33 , 6 + 33 , 6 @ @ public class ConfigGuiHandler <nl> public static Optional < BiFunction < Minecraft , GuiScreen , GuiScreen > > getGuiFactoryFor ( ModInfo selectedMod ) <nl> { <nl> return ModList . get ( ) . getModContainerById ( selectedMod . getModId ( ) ) . <nl> - flatMap ( mc - > mc . getCustomExtension ( ExtensionPoint . GUIFACTORY ) ) ; <nl> + flatMap ( mc - > mc . getCustomExtension ( ExtensionPoint . CONFIGGUIFACTORY ) ) ; <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModContainer . java b / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModContainer . java <nl> index af47613 . . e226229 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModContainer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModContainer . java <nl> @ @ - 28 , 7 + 28 , 7 @ @ import net . minecraftforge . fml . LifecycleEventProvider ; <nl> import net . minecraftforge . fml . ModContainer ; <nl> import net . minecraftforge . fml . ModLoadingException ; <nl> import net . minecraftforge . fml . ModLoadingStage ; <nl> - import net . minecraftforge . fml . ModThreadContext ; <nl> + import net . minecraftforge . fml . ModLoadingContext ; <nl> import net . minecraftforge . forgespi . language . IModInfo ; <nl> import net . minecraftforge . forgespi . language . ModFileScanData ; <nl> <nl> @ @ - 94 , 7 + 94 , 7 @ @ public class FMLModContainer extends ModContainer <nl> <nl> private void beforeEvent ( LifecycleEventProvider . LifecycleEvent lifecycleEvent ) { <nl> FMLModLoadingContext . get ( ) . setActiveContainer ( this ) ; <nl> - ModThreadContext . get ( ) . setActiveContainer ( this ) ; <nl> + ModLoadingContext . get ( ) . setActiveContainer ( this ) ; <nl> } <nl> <nl> private void fireEvent ( LifecycleEventProvider . LifecycleEvent lifecycleEvent ) { <nl> @ @ - 113 , 7 + 113 , 7 @ @ public class FMLModContainer extends ModContainer <nl> } <nl> <nl> private void afterEvent ( LifecycleEventProvider . LifecycleEvent lifecycleEvent ) { <nl> - ModThreadContext . get ( ) . setActiveContainer ( null ) ; <nl> + ModLoadingContext . get ( ) . setActiveContainer ( null ) ; <nl> FMLModLoadingContext . get ( ) . setActiveContainer ( null ) ; <nl> if ( getCurrentState ( ) = = ModLoadingStage . ERROR ) { <nl> LOGGER . error ( LOADING , " An error occurred while dispatching event { } to { } " , lifecycleEvent . fromStage ( ) , getModId ( ) ) ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModLoadingContext . java b / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModLoadingContext . java <nl> index 2c4459a . . 3a6cfd7 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModLoadingContext . java <nl> + + + b / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModLoadingContext . java <nl> @ @ - 34 , 23 + 34 , 26 @ @ public class FMLModLoadingContext <nl> return context . get ( ) ; <nl> } <nl> <nl> - public < T > void registerExtensionPoint ( ExtensionPoint < T > point , Supplier < T > extension ) { <nl> - getActiveContainer ( ) . registerExtensionPoint ( point , extension ) ; <nl> - } <nl> - <nl> public void registerConfig ( ModConfig . Type type , ForgeConfigSpec spec ) { <nl> - activeContainer . addConfig ( new ModConfig ( type , spec , activeContainer ) ) ; <nl> + getActiveContainer ( ) . addConfig ( new ModConfig ( type , spec , getActiveContainer ( ) ) ) ; <nl> } <nl> <nl> public void registerConfig ( ModConfig . Type type , ForgeConfigSpec spec , String fileName ) { <nl> - activeContainer . addConfig ( new ModConfig ( type , spec , activeContainer , fileName ) ) ; <nl> + getActiveContainer ( ) . addConfig ( new ModConfig ( type , spec , getActiveContainer ( ) , fileName ) ) ; <nl> } <nl> <nl> + / * * <nl> + * @ return The mod ' s event bus , to allow subscription to Mod specific events <nl> + * / <nl> public IEventBus getModEventBus ( ) <nl> { <nl> return getActiveContainer ( ) . getEventBus ( ) ; <nl> } <nl> <nl> + / * * <nl> + * Only valid during { @ link net . minecraftforge . fml . event . lifecycle . ModLifecycleEvent } dispatch and Mod construction <nl> + * @ return the active FML container <nl> + * / <nl> public FMLModContainer getActiveContainer ( ) <nl> { <nl> return activeContainer ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLPlayMessages . java b / src / main / java / net / minecraftforge / fml / network / FMLPlayMessages . java <nl> index ab10cd9 . . 34436ee 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / FMLPlayMessages . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / FMLPlayMessages . java <nl> @ @ - 19 , 20 + 19 , 19 @ @ <nl> <nl> package net . minecraftforge . fml . network ; <nl> <nl> - import io . netty . buffer . ByteBuf ; <nl> import io . netty . buffer . Unpooled ; <nl> import net . minecraft . client . Minecraft ; <nl> - import net . minecraft . client . gui . GuiScreen ; <nl> import net . minecraft . entity . Entity ; <nl> import net . minecraft . entity . EntityTracker ; <nl> import net . minecraft . entity . EntityType ; <nl> import net . minecraft . network . PacketBuffer ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraft . util . math . MathHelper ; <nl> + import net . minecraftforge . fml . ExtensionPoint ; <nl> + import net . minecraftforge . fml . ModList ; <nl> import net . minecraftforge . fml . common . registry . IEntityAdditionalSpawnData ; <nl> <nl> import java . util . UUID ; <nl> - import java . util . function . Function ; <nl> import java . util . function . Supplier ; <nl> <nl> public class FMLPlayMessages <nl> @ @ - 166 , 9 + 165 , 9 @ @ public class FMLPlayMessages <nl> { <nl> private final ResourceLocation id ; <nl> private final int windowId ; <nl> - private final byte [ ] additionalData ; <nl> + private final PacketBuffer additionalData ; <nl> <nl> - public OpenContainer ( ResourceLocation id , int windowId , byte [ ] additionalData ) <nl> + OpenContainer ( ResourceLocation id , int windowId , PacketBuffer additionalData ) <nl> { <nl> this . id = id ; <nl> this . windowId = windowId ; <nl> @ @ - 179 , 27 + 178 , 34 @ @ public class FMLPlayMessages <nl> { <nl> buf . writeResourceLocation ( msg . id ) ; <nl> buf . writeVarInt ( msg . windowId ) ; <nl> - buf . writeByteArray ( msg . additionalData ) ; <nl> + buf . writeBytes ( msg . additionalData ) ; <nl> } <nl> <nl> public static OpenContainer decode ( PacketBuffer buf ) <nl> { <nl> - return new OpenContainer ( buf . readResourceLocation ( ) , buf . readVarInt ( ) , buf . readByteArray ( ) ) ; <nl> + return new OpenContainer ( buf . readResourceLocation ( ) , buf . readVarInt ( ) , new PacketBuffer ( Unpooled . wrappedBuffer ( buf . readByteArray ( 32600 ) ) ) ) ; <nl> } <nl> <nl> public static void handle ( OpenContainer msg , Supplier < NetworkEvent . Context > ctx ) <nl> { <nl> - ctx . get ( ) . enqueueWork ( ( ) - > { <nl> - Supplier < Function < ByteBuf , GuiScreen > > sup = NetworkRegistry . guiHandlers . get ( msg . id ) ; <nl> - if ( sup ! = null ) { <nl> - GuiScreen gui = sup . get ( ) . apply ( Unpooled . wrappedBuffer ( msg . additionalData ) ) ; <nl> - if ( gui ! = null ) { <nl> - Minecraft . getInstance ( ) . displayGuiScreen ( gui ) ; <nl> - Minecraft . getInstance ( ) . player . openContainer . windowId = msg . windowId ; <nl> - } <nl> - } <nl> - } ) ; <nl> + ctx . get ( ) . enqueueWork ( ( ) - > ModList . get ( ) . getModContainerById ( msg . id . getNamespace ( ) ) . ifPresent ( mc - > <nl> + mc . getCustomExtension ( ExtensionPoint . GUIFACTORY ) . map ( f - > f . apply ( msg ) ) . ifPresent ( gui - > { <nl> + Minecraft . getInstance ( ) . displayGuiScreen ( gui ) ; <nl> + Minecraft . getInstance ( ) . player . openContainer . windowId = msg . windowId ; <nl> + } ) ) ) ; <nl> ctx . get ( ) . setPacketHandled ( true ) ; <nl> } <nl> + <nl> + public final ResourceLocation getId ( ) { <nl> + return this . id ; <nl> + } <nl> + <nl> + public int getWindowId ( ) { <nl> + return windowId ; <nl> + } <nl> + <nl> + public PacketBuffer getAdditionalData ( ) { <nl> + return additionalData ; <nl> + } <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> index cb16e72 . . 20131bb 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> @ @ - 19 , 13 + 19 , 14 @ @ <nl> <nl> package net . minecraftforge . fml . network ; <nl> <nl> - import io . netty . buffer . ByteBuf ; <nl> + import io . netty . buffer . Unpooled ; <nl> import net . minecraft . entity . Entity ; <nl> import net . minecraft . entity . player . EntityPlayerMP ; <nl> import net . minecraft . inventory . Container ; <nl> import net . minecraft . network . NetHandlerPlayServer ; <nl> import net . minecraft . network . NetworkManager ; <nl> import net . minecraft . network . Packet ; <nl> + import net . minecraft . network . PacketBuffer ; <nl> import net . minecraft . network . handshake . client . CPacketHandshake ; <nl> import net . minecraft . server . network . NetHandlerLoginServer ; <nl> import net . minecraft . util . ResourceLocation ; <nl> @ @ - 87 , 10 + 88 , 22 @ @ public class NetworkHooks <nl> return FMLHandshakeHandler . tickLogin ( networkManager ) ; <nl> } <nl> <nl> - public static void openGui ( EntityPlayerMP player , IInteractionObject container , @ Nullable ByteBuf extraData ) <nl> + / * * <nl> + * Server method to tell the client to open a GUI on behalf of the server <nl> + * <nl> + * The { @ link IInteractionObject # getGuiID ( ) } is treated as a { @ link ResourceLocation } . <nl> + * It should refer to a valid modId namespace , to trigger opening on the client . <nl> + * The namespace is directly used to lookup the modId in the client side . <nl> + * <nl> + * @ param player The player to open the GUI for <nl> + * @ param containerSupplier The Container Supplier <nl> + * @ param extraData Additional data for the GUI <nl> + * / <nl> + public static void openGui ( EntityPlayerMP player , IInteractionObject containerSupplier , @ Nullable PacketBuffer extraData ) <nl> { <nl> - ResourceLocation id = new ResourceLocation ( container . getGuiID ( ) ) ; <nl> - Container c = container . createContainer ( player . inventory , player ) ; <nl> + if ( player . world . isRemote ) return ; <nl> + ResourceLocation id = new ResourceLocation ( containerSupplier . getGuiID ( ) ) ; <nl> + Container c = containerSupplier . createContainer ( player . inventory , player ) ; <nl> player . closeScreen ( ) ; <nl> player . getNextWindowId ( ) ; <nl> player . openContainer = c ; <nl> @ @ - 98 , 14 + 111 , 13 @ @ public class NetworkHooks <nl> player . openContainer . addListener ( player ) ; <nl> MinecraftForge . EVENT _ BUS . post ( new PlayerContainerEvent . Open ( player , c ) ) ; <nl> <nl> - byte [ ] additional ; <nl> if ( extraData = = null ) { <nl> - additional = new byte [ 0 ] ; <nl> - } else { <nl> - additional = new byte [ extraData . readableBytes ( ) ] ; <nl> - extraData . readBytes ( additional ) ; <nl> + extraData = new PacketBuffer ( Unpooled . buffer ( ) ) ; <nl> } <nl> - FMLPlayMessages . OpenContainer msg = new FMLPlayMessages . OpenContainer ( id , player . currentWindowId , additional ) ; <nl> + if ( extraData . readableBytes ( ) > 32600 ) { <nl> + throw new IllegalArgumentException ( " GUI Open packet too large : " + extraData . readableBytes ( ) ) ; <nl> + } <nl> + FMLPlayMessages . OpenContainer msg = new FMLPlayMessages . OpenContainer ( id , player . currentWindowId , extraData ) ; <nl> FMLPlayHandler . channel . sendTo ( msg , player . connection . getNetworkManager ( ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> index 36e6717 . . 41a60c4 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> @ @ - 19 , 8 + 19 , 6 @ @ <nl> <nl> package net . minecraftforge . fml . network ; <nl> <nl> - import io . netty . buffer . ByteBuf ; <nl> - import net . minecraft . client . gui . GuiScreen ; <nl> import net . minecraft . nbt . NBTTagCompound ; <nl> import net . minecraft . nbt . NBTTagList ; <nl> import net . minecraft . network . NetworkManager ; <nl> @ @ - 34 , 10 + 32 , 12 @ @ import org . apache . logging . log4j . Logger ; <nl> import org . apache . logging . log4j . Marker ; <nl> import org . apache . logging . log4j . MarkerManager ; <nl> <nl> - import java . util . * ; <nl> - import java . util . concurrent . ConcurrentHashMap ; <nl> + import java . util . ArrayList ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Optional ; <nl> import java . util . function . BiFunction ; <nl> - import java . util . function . Function ; <nl> import java . util . function . Predicate ; <nl> import java . util . function . Supplier ; <nl> import java . util . stream . Collectors ; <nl> @ @ - 51 , 21 + 51 , 6 @ @ public class NetworkRegistry <nl> private static final Marker NETREGISTRY = MarkerManager . getMarker ( " NETREGISTRY " ) ; <nl> <nl> private static Map < ResourceLocation , NetworkInstance > instances = new HashMap < > ( ) ; <nl> - static final Map < ResourceLocation , Supplier < Function < ByteBuf , GuiScreen > > > guiHandlers = new ConcurrentHashMap < > ( ) ; <nl> - <nl> - / * * <nl> - * Registers a client - side GUI handler for the given ID . <nl> - * The function takes any extra data provided to { @ link net . minecraft . entity . player . EntityPlayer # openGui } <nl> - * and returns a { @ link GuiScreen } to display . <nl> - * Call this during { @ link net . minecraftforge . fml . event . lifecycle . FMLClientSetupEvent } . <nl> - * This method is safe to call in parallel mod loading <nl> - * @ param id <nl> - * @ param handler <nl> - * / <nl> - public static void registerGui ( ResourceLocation id , Supplier < Function < ByteBuf , GuiScreen > > handler ) <nl> - { <nl> - guiHandlers . put ( id , handler ) ; <nl> - } <nl> <nl> / * * <nl> * Special value for clientAcceptedVersions and serverAcceptedVersions predicates indicating the other side lacks <nl> diff - - git a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> index a9c3bf9 . . d259c3b 100644 <nl> - - - a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> @ @ - 28 , 13 + 28 , 12 @ @ import java . util . Map ; <nl> import java . util . Map . Entry ; <nl> <nl> import javax . annotation . Nonnull ; <nl> - import net . minecraftforge . fml . ModThreadContext ; <nl> + import net . minecraftforge . fml . ModLoadingContext ; <nl> import net . minecraftforge . fml . common . ObfuscationReflectionHelper ; <nl> import net . minecraftforge . fml . loading . AdvancedLogMessageAdapter ; <nl> import org . apache . commons . lang3 . Validate ; <nl> <nl> import java . util . Set ; <nl> - import java . util . stream . Collectors ; <nl> <nl> import com . google . common . base . Preconditions ; <nl> import com . google . common . collect . ArrayListMultimap ; <nl> @ @ - 280 , 7 + 279 , 7 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> <nl> int add ( int id , V value ) <nl> { <nl> - final String owner = ModThreadContext . get ( ) . getActiveContainer ( ) . getNamespace ( ) ; <nl> + final String owner = ModLoadingContext . get ( ) . getActiveContainer ( ) . getNamespace ( ) ; <nl> return add ( id , value , owner ) ; <nl> } <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / registries / GameData . java b / src / main / java / net / minecraftforge / registries / GameData . java <nl> index 24203a5 . . 7cdbd6b 100644 <nl> - - - a / src / main / java / net / minecraftforge / registries / GameData . java <nl> + + + b / src / main / java / net / minecraftforge / registries / GameData . java <nl> @ @ - 42 , 7 + 42 , 7 @ @ import net . minecraftforge . common . MinecraftForge ; <nl> import net . minecraftforge . event . RegistryEvent ; <nl> import net . minecraftforge . event . RegistryEvent . MissingMappings ; <nl> import net . minecraftforge . fml . LifecycleEventProvider ; <nl> - import net . minecraftforge . fml . ModThreadContext ; <nl> + import net . minecraftforge . fml . ModLoadingContext ; <nl> import net . minecraftforge . fml . StartupQuery ; <nl> import net . minecraftforge . fml . common . EnhancedRuntimeException ; <nl> import net . minecraftforge . fml . common . registry . VillagerRegistry . VillagerProfession ; <nl> @ @ - 51 , 8 + 51 , 6 @ @ import net . minecraftforge . fml . loading . AdvancedLogMessageAdapter ; <nl> import org . apache . commons . lang3 . Validate ; <nl> import org . apache . logging . log4j . LogManager ; <nl> import org . apache . logging . log4j . Logger ; <nl> - import org . apache . logging . log4j . Marker ; <nl> - import org . apache . logging . log4j . MarkerManager ; <nl> <nl> import javax . annotation . Nullable ; <nl> import java . lang . reflect . Field ; <nl> @ @ - 66 , 7 + 64 , 6 @ @ import java . util . function . Consumer ; <nl> import java . util . function . Predicate ; <nl> import java . util . stream . Collectors ; <nl> <nl> - import static net . minecraftforge . fml . Logging . CORE ; <nl> import static net . minecraftforge . registries . ForgeRegistry . REGISTRIES ; <nl> <nl> / * * <nl> @ @ - 828 , 7 + 825 , 7 @ @ public class GameData <nl> int index = name . lastIndexOf ( ' : ' ) ; <nl> String oldPrefix = index = = - 1 ? " " : name . substring ( 0 , index ) . toLowerCase ( Locale . ROOT ) ; <nl> name = index = = - 1 ? name : name . substring ( index + 1 ) ; <nl> - String prefix = ModThreadContext . get ( ) . getActiveContainer ( ) . getNamespace ( ) ; <nl> + String prefix = ModLoadingContext . get ( ) . getActiveContainer ( ) . getNamespace ( ) ; <nl> if ( ! oldPrefix . equals ( prefix ) & & oldPrefix . length ( ) > 0 ) <nl> { <nl> LogManager . getLogger ( ) . info ( " Potentially Dangerous alternative prefix ` { } ` for name ` { } ` , expected ` { } ` . This could be a intended override , but in most cases indicates a broken mod . " , oldPrefix , name , prefix ) ;

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / ModLoader . java b / src / main / java / net / minecraftforge / fml / ModLoader . java 
 index 473b61c . . 3887c49 100644 
 - - - a / src / main / java / net / minecraftforge / fml / ModLoader . java 
 + + + b / src / main / java / net / minecraftforge / fml / ModLoader . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import net . minecraftforge . fml . loading . FMLPaths ; 
 import net . minecraftforge . fml . loading . LoadingModList ; 
 import net . minecraftforge . fml . loading . moddiscovery . ModFile ; 
 import net . minecraftforge . fml . loading . moddiscovery . ModFileInfo ; 
 + import net . minecraftforge . fml . network . FMLNetworkConstants ; 
 import net . minecraftforge . forgespi . language . IModInfo ; 
 import net . minecraftforge . forgespi . language . IModLanguageProvider ; 
 import net . minecraftforge . registries . GameData ; 
 @ @ - 99 , 6 + 100 , 7 @ @ public class ModLoader 
 this . loadingModList = FMLLoader . getLoadingModList ( ) ; 
 this . loadingExceptions = FMLLoader . getLoadingModList ( ) . 
 getErrors ( ) . stream ( ) . flatMap ( ModLoadingException : : fromEarlyException ) . collect ( Collectors . toList ( ) ) ; 
 + LOGGER . info ( CORE , " Loading Network data for FML net version : { } " , FMLNetworkConstants . NETVERSION ) ; 
 } 
 
 public static ModLoader get ( ) 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeHandler . java b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeHandler . java 
 index 1e9a7fd . . 7a8cb91 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeHandler . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeHandler . java 
 @ @ - 19 , 7 + 19 , 6 @ @ 
 
 package net . minecraftforge . fml . network ; 
 
 - import io . netty . util . AttributeKey ; 
 import net . minecraft . network . NetworkManager ; 
 import net . minecraft . network . PacketBuffer ; 
 import net . minecraft . network . NetHandlerLoginServer ; 
 @ @ - 27 , 9 + 26 , 7 @ @ import net . minecraft . util . ResourceLocation ; 
 import net . minecraft . util . text . TextComponentString ; 
 import net . minecraftforge . fml . config . ConfigTracker ; 
 import net . minecraftforge . fml . network . simple . SimpleChannel ; 
 - import net . minecraftforge . fml . util . ThreeConsumer ; 
 import net . minecraftforge . registries . ForgeRegistry ; 
 - import net . minecraftforge . registries . RegistryManager ; 
 import org . apache . logging . log4j . LogManager ; 
 import org . apache . logging . log4j . Logger ; 
 import org . apache . logging . log4j . Marker ; 
 @ @ - 37 , 8 + 34 , 12 @ @ import org . apache . logging . log4j . MarkerManager ; 
 
 import com . google . common . collect . Maps ; 
 
 - import java . util . * ; 
 - import java . util . function . BiConsumer ; 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . HashSet ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 import java . util . function . Supplier ; 
 
 import static net . minecraftforge . registries . ForgeRegistry . REGISTRIES ; 
 @ @ - 47 , 9 + 48 , 9 @ @ import static net . minecraftforge . registries . ForgeRegistry . REGISTRIES ; 
 * Instance responsible for handling the overall FML network handshake . 
 * 
 * < p > An instance is created during { @ link net . minecraft . network . handshake . client . CPacketHandshake } handling , and attached 
 - * to the { @ link NetworkManager # channel } via { @ link # FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY } . 
 + * to the { @ link NetworkManager # channel } via { @ link FMLNetworkConstants # FML _ HANDSHAKE _ HANDLER } . 
 * 
 - * < p > The { @ link # channel } is a { @ link SimpleChannel } with standard messages flowing in both directions . 
 + * < p > The { @ link FMLNetworkConstants # handshakeChannel } is a { @ link SimpleChannel } with standard messages flowing in both directions . 
 * 
 * < p > The { @ link # loginWrapper } transforms these messages into { @ link net . minecraft . network . login . client . CPacketCustomPayloadLogin } 
 * and { @ link net . minecraft . network . login . server . SPacketCustomPayloadLogin } compatible messages , by means of wrapping . 
 @ @ - 76 , 75 + 77 , 10 @ @ import static net . minecraftforge . registries . ForgeRegistry . REGISTRIES ; 
 public class FMLHandshakeHandler { 
 static final Marker FMLHSMARKER = MarkerManager . getMarker ( " FMLHANDSHAKE " ) . setParents ( FMLNetworkConstants . NETWORK ) ; 
 private static final Logger LOGGER = LogManager . getLogger ( ) ; 
 - static final ResourceLocation FML _ HANDSHAKE _ RESOURCE = new ResourceLocation ( " fml : handshake " ) ; 
 - private static final AttributeKey < FMLHandshakeHandler > FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY = AttributeKey . newInstance ( " fml : handshake " ) ; 
 
 private static final FMLLoginWrapper loginWrapper = new FMLLoginWrapper ( ) ; 
 - private static SimpleChannel channel ; 
 - static { 
 - channel = NetworkRegistry . ChannelBuilder . named ( FML _ HANDSHAKE _ RESOURCE ) . 
 - clientAcceptedVersions ( a - > true ) . 
 - serverAcceptedVersions ( a - > true ) . 
 - networkProtocolVersion ( ( ) - > FMLNetworkConstants . NETVERSION ) . 
 - simpleChannel ( ) ; 
 - channel . messageBuilder ( FMLHandshakeMessages . C2SAcknowledge . class , 99 ) . 
 - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 - decoder ( FMLHandshakeMessages . C2SAcknowledge : : decode ) . 
 - encoder ( FMLHandshakeMessages . C2SAcknowledge : : encode ) . 
 - consumer ( indexFirst ( FMLHandshakeHandler : : handleClientAck ) ) . 
 - add ( ) ; 
 - channel . messageBuilder ( FMLHandshakeMessages . S2CModList . class , 1 ) . 
 - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 - decoder ( FMLHandshakeMessages . S2CModList : : decode ) . 
 - encoder ( FMLHandshakeMessages . S2CModList : : encode ) . 
 - markAsLoginPacket ( ) . 
 - consumer ( biConsumerFor ( FMLHandshakeHandler : : handleServerModListOnClient ) ) . 
 - add ( ) ; 
 - channel . messageBuilder ( FMLHandshakeMessages . C2SModListReply . class , 2 ) . 
 - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 - decoder ( FMLHandshakeMessages . C2SModListReply : : decode ) . 
 - encoder ( FMLHandshakeMessages . C2SModListReply : : encode ) . 
 - consumer ( indexFirst ( FMLHandshakeHandler : : handleClientModListOnServer ) ) . 
 - add ( ) ; 
 - channel . messageBuilder ( FMLHandshakeMessages . S2CRegistry . class , 3 ) . 
 - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 - decoder ( FMLHandshakeMessages . S2CRegistry : : decode ) . 
 - encoder ( FMLHandshakeMessages . S2CRegistry : : encode ) . 
 - buildLoginPacketList ( RegistryManager : : generateRegistryPackets ) . / / TODO : Make this non - static , and store a cache on the client . 
 - consumer ( biConsumerFor ( FMLHandshakeHandler : : handleRegistryMessage ) ) . 
 - add ( ) ; 
 - channel . messageBuilder ( FMLHandshakeMessages . S2CConfigData . class , 4 ) . 
 - loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 - decoder ( FMLHandshakeMessages . S2CConfigData : : decode ) . 
 - encoder ( FMLHandshakeMessages . S2CConfigData : : encode ) . 
 - buildLoginPacketList ( ConfigTracker . INSTANCE : : syncConfigs ) . 
 - consumer ( biConsumerFor ( FMLHandshakeHandler : : handleConfigSync ) ) . 
 - add ( ) ; 
 - } 
 
 - / * * 
 - * Transforms a two - argument instance method reference into a { @ link BiConsumer } based on the { @ link # getHandshake ( Supplier ) } function . 
 - * 
 - * @ param consumer A two argument instance method reference 
 - * @ param < MSG > message type 
 - * @ return A { @ link BiConsumer } for use in message handling 
 - * / 
 - private static < MSG extends FMLHandshakeMessages . LoginIndexedMessage > BiConsumer < MSG , Supplier < NetworkEvent . Context > > biConsumerFor ( ThreeConsumer < FMLHandshakeHandler , ? super MSG , ? super Supplier < NetworkEvent . Context > > consumer ) 
 - { 
 - return ( m , c ) - > ThreeConsumer . bindArgs ( consumer , m , c ) . accept ( getHandshake ( c ) ) ; 
 - } 
 - 
 - / * * 
 - * Transforms a two - argument instance method reference into a { @ link BiConsumer } { @ link # biConsumerFor ( ThreeConsumer ) } , first calling the { @ link # handleIndexedMessage ( FMLHandshakeMessages . LoginIndexedMessage , Supplier ) } 
 - * method to handle index tracking . Used for client to server replies . 
 - * @ param next The method reference to call after index handling 
 - * @ param < MSG > message type 
 - * @ return A { @ link BiConsumer } for use in message handling 
 - * / 
 - private static < MSG extends FMLHandshakeMessages . LoginIndexedMessage > BiConsumer < MSG , Supplier < NetworkEvent . Context > > indexFirst ( ThreeConsumer < FMLHandshakeHandler , MSG , Supplier < NetworkEvent . Context > > next ) 
 - { 
 - final BiConsumer < MSG , Supplier < NetworkEvent . Context > > loginIndexedMessageSupplierBiConsumer = biConsumerFor ( FMLHandshakeHandler : : handleIndexedMessage ) ; 
 - return loginIndexedMessageSupplierBiConsumer . andThen ( biConsumerFor ( next ) ) ; 
 + static { 
 } 
 
 / * * 
 @ @ - 155 , 22 + 91 , 12 @ @ public class FMLHandshakeHandler { 
 * @ param direction The { @ link NetworkDirection } for this connection : { @ link NetworkDirection # LOGIN _ TO _ SERVER } or { @ link NetworkDirection # LOGIN _ TO _ CLIENT } 
 * / 
 static void registerHandshake ( NetworkManager manager , NetworkDirection direction ) { 
 - manager . channel ( ) . attr ( FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY ) . compareAndSet ( null , new FMLHandshakeHandler ( manager , direction ) ) ; 
 - } 
 - 
 - / * * 
 - * Retrieve the handshake from the { @ link NetworkEvent . Context } 
 - * 
 - * @ param contextSupplier the { @ link NetworkEvent . Context } 
 - * @ return The handshake handler for the connection 
 - * / 
 - private static FMLHandshakeHandler getHandshake ( Supplier < NetworkEvent . Context > contextSupplier ) { 
 - return contextSupplier . get ( ) . attr ( FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY ) . get ( ) ; 
 + manager . channel ( ) . attr ( FMLNetworkConstants . FML _ HANDSHAKE _ HANDLER ) . compareAndSet ( null , new FMLHandshakeHandler ( manager , direction ) ) ; 
 } 
 
 static boolean tickLogin ( NetworkManager networkManager ) 
 { 
 - return networkManager . channel ( ) . attr ( FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY ) . get ( ) . tickServer ( ) ; 
 + return networkManager . channel ( ) . attr ( FMLNetworkConstants . FML _ HANDSHAKE _ HANDLER ) . get ( ) . tickServer ( ) ; 
 } 
 
 private List < NetworkRegistry . LoginPayload > messageList ; 
 @ @ - 197 , 7 + 123 , 7 @ @ public class FMLHandshakeHandler { 
 } 
 } 
 
 - private void handleServerModListOnClient ( FMLHandshakeMessages . S2CModList serverModList , Supplier < NetworkEvent . Context > c ) 
 + void handleServerModListOnClient ( FMLHandshakeMessages . S2CModList serverModList , Supplier < NetworkEvent . Context > c ) 
 { 
 LOGGER . debug ( FMLHSMARKER , " Logging into server with mod list [ { } ] " , String . join ( " , " , serverModList . getModList ( ) ) ) ; 
 boolean accepted = NetworkRegistry . validateClientChannels ( serverModList . getChannels ( ) ) ; 
 @ @ - 207 , 18 + 133 , 18 @ @ public class FMLHandshakeHandler { 
 c . get ( ) . getNetworkManager ( ) . closeChannel ( new TextComponentString ( " Connection closed - mismatched mod channel list " ) ) ; 
 return ; 
 } 
 - channel . reply ( new FMLHandshakeMessages . C2SModListReply ( ) , c . get ( ) ) ; 
 + FMLNetworkConstants . handshakeChannel . reply ( new FMLHandshakeMessages . C2SModListReply ( ) , c . get ( ) ) ; 
 
 LOGGER . debug ( FMLHSMARKER , " Accepted server connection " ) ; 
 / / Set the modded marker on the channel so we know we got packets 
 - c . get ( ) . getNetworkManager ( ) . channel ( ) . attr ( FMLNetworkConstants . FML _ MARKER ) . set ( FMLNetworkConstants . NETVERSION ) ; 
 + c . get ( ) . getNetworkManager ( ) . channel ( ) . attr ( FMLNetworkConstants . FML _ NETVERSION ) . set ( FMLNetworkConstants . NETVERSION ) ; 
 
 this . registriesToReceive = new HashSet < > ( serverModList . getRegistries ( ) ) ; 
 this . registrySnapshots = Maps . newHashMap ( ) ; 
 LOGGER . debug ( REGISTRIES , " Expecting { } registries : { } " , ( ) - > this . registriesToReceive . size ( ) , ( ) - > this . registriesToReceive ) ; 
 } 
 
 - private < MSG extends FMLHandshakeMessages . LoginIndexedMessage > void handleIndexedMessage ( MSG message , Supplier < NetworkEvent . Context > c ) 
 + < MSG extends FMLHandshakeMessages . LoginIndexedMessage > void handleIndexedMessage ( MSG message , Supplier < NetworkEvent . Context > c ) 
 { 
 LOGGER . debug ( FMLHSMARKER , " Received client indexed reply { } of type { } " , message . getLoginIndex ( ) , message . getClass ( ) . getName ( ) ) ; 
 boolean removed = this . sentMessages . removeIf ( i - > i = = message . getLoginIndex ( ) ) ; 
 @ @ - 227 , 7 + 153 , 7 @ @ public class FMLHandshakeHandler { 
 } 
 } 
 
 - private void handleClientModListOnServer ( FMLHandshakeMessages . C2SModListReply clientModList , Supplier < NetworkEvent . Context > c ) 
 + void handleClientModListOnServer ( FMLHandshakeMessages . C2SModListReply clientModList , Supplier < NetworkEvent . Context > c ) 
 { 
 LOGGER . debug ( FMLHSMARKER , " Received client connection with modlist [ { } ] " , String . join ( " , " , clientModList . getModList ( ) ) ) ; 
 boolean accepted = NetworkRegistry . validateServerChannels ( clientModList . getChannels ( ) ) ; 
 @ @ - 240 , 12 + 166 , 12 @ @ public class FMLHandshakeHandler { 
 LOGGER . debug ( FMLHSMARKER , " Accepted client connection mod list " ) ; 
 } 
 
 - private void handleRegistryMessage ( final FMLHandshakeMessages . S2CRegistry registryPacket , final Supplier < NetworkEvent . Context > contextSupplier ) { 
 + void handleRegistryMessage ( final FMLHandshakeMessages . S2CRegistry registryPacket , final Supplier < NetworkEvent . Context > contextSupplier ) { 
 LOGGER . debug ( FMLHSMARKER , " Received registry packet for { } " , registryPacket . getRegistryName ( ) ) ; 
 this . registriesToReceive . remove ( registryPacket . getRegistryName ( ) ) ; 
 this . registrySnapshots . put ( registryPacket . getRegistryName ( ) , registryPacket . getSnapshot ( ) ) ; 
 contextSupplier . get ( ) . setPacketHandled ( true ) ; 
 - channel . reply ( new FMLHandshakeMessages . C2SAcknowledge ( ) , contextSupplier . get ( ) ) ; 
 + FMLNetworkConstants . handshakeChannel . reply ( new FMLHandshakeMessages . C2SAcknowledge ( ) , contextSupplier . get ( ) ) ; 
 
 if ( this . registriesToReceive . isEmpty ( ) ) { 
 / / TODO : @ cpw injectSnapshot Needs to be on the world thread . And maybe block the network / login so we don ' t get world data before we finish ? 
 @ @ - 253 , 16 + 179 , 16 @ @ public class FMLHandshakeHandler { 
 } 
 } 
 
 - private void handleClientAck ( final FMLHandshakeMessages . C2SAcknowledge msg , final Supplier < NetworkEvent . Context > contextSupplier ) { 
 + void handleClientAck ( final FMLHandshakeMessages . C2SAcknowledge msg , final Supplier < NetworkEvent . Context > contextSupplier ) { 
 LOGGER . debug ( FMLHSMARKER , " Received acknowledgement from client " ) ; 
 contextSupplier . get ( ) . setPacketHandled ( true ) ; 
 } 
 
 - private void handleConfigSync ( final FMLHandshakeMessages . S2CConfigData msg , final Supplier < NetworkEvent . Context > contextSupplier ) { 
 + void handleConfigSync ( final FMLHandshakeMessages . S2CConfigData msg , final Supplier < NetworkEvent . Context > contextSupplier ) { 
 LOGGER . debug ( FMLHSMARKER , " Received config sync from server " ) ; 
 ConfigTracker . INSTANCE . receiveSyncedConfig ( msg , contextSupplier ) ; 
 contextSupplier . get ( ) . setPacketHandled ( true ) ; 
 - channel . reply ( new FMLHandshakeMessages . C2SAcknowledge ( ) , contextSupplier . get ( ) ) ; 
 + FMLNetworkConstants . handshakeChannel . reply ( new FMLHandshakeMessages . C2SAcknowledge ( ) , contextSupplier . get ( ) ) ; 
 } 
 / * * 
 * FML will send packets , from Server to Client , from the messages queue until the queue is drained . Each message 
 @ @ - 289 , 7 + 215 , 7 @ @ public class FMLHandshakeHandler { 
 / / we ' re done when sentMessages is empty 
 if ( sentMessages . isEmpty ( ) & & packetPosition > = messageList . size ( ) - 1 ) { 
 / / clear ourselves - we ' re done ! 
 - this . manager . channel ( ) . attr ( FML _ HANDSHAKE _ HANDLER _ ATTRIBUTE _ KEY ) . set ( null ) ; 
 + this . manager . channel ( ) . attr ( FMLNetworkConstants . FML _ HANDSHAKE _ HANDLER ) . set ( null ) ; 
 LOGGER . debug ( FMLHSMARKER , " Handshake complete ! " ) ; 
 return true ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessages . java b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessages . java 
 index de4cc93 . . 373df14 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessages . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessages . java 
 @ @ - 21 , 7 + 21 , 6 @ @ package net . minecraftforge . fml . network ; 
 
 import net . minecraft . network . PacketBuffer ; 
 import net . minecraft . util . ResourceLocation ; 
 - import net . minecraftforge . common . util . HexDumper ; 
 import net . minecraftforge . fml . ModList ; 
 import net . minecraftforge . fml . loading . moddiscovery . ModInfo ; 
 import net . minecraftforge . registries . ForgeRegistry ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLLoginWrapper . java b / src / main / java / net / minecraftforge / fml / network / FMLLoginWrapper . java 
 index d282839 . . 682c10e 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / FMLLoginWrapper . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / FMLLoginWrapper . java 
 @ @ - 49 , 7 + 49 , 7 @ @ public class FMLLoginWrapper { 
 private < T extends NetworkEvent > void wrapperReceived ( final T packet ) { 
 final NetworkEvent . Context wrappedContext = packet . getSource ( ) . get ( ) ; 
 final PacketBuffer payload = packet . getPayload ( ) ; 
 - ResourceLocation targetNetworkReceiver = FMLHandshakeHandler . FML _ HANDSHAKE _ RESOURCE ; 
 + ResourceLocation targetNetworkReceiver = FMLNetworkConstants . FML _ HANDSHAKE _ RESOURCE ; 
 PacketBuffer data = null ; 
 if ( payload ! = null ) { 
 targetNetworkReceiver = payload . readResourceLocation ( ) ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLNetworkConstants . java b / src / main / java / net / minecraftforge / fml / network / FMLNetworkConstants . java 
 index 9c02758 . . 0c2dbe2 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / FMLNetworkConstants . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / FMLNetworkConstants . java 
 @ @ - 20 , 6 + 20 , 8 @ @ 
 package net . minecraftforge . fml . network ; 
 
 import io . netty . util . AttributeKey ; 
 + import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . fml . network . simple . SimpleChannel ; 
 import org . apache . logging . log4j . Marker ; 
 import org . apache . logging . log4j . MarkerManager ; 
 
 @ @ - 32 , 6 + 34 , 12 @ @ public class FMLNetworkConstants 
 public static final int FMLNETVERSION = 2 ; 
 public static final String NETVERSION = FMLNETMARKER + FMLNETVERSION ; 
 public static final String NOVERSION = " NONE " ; 
 + 
 static final Marker NETWORK = MarkerManager . getMarker ( " FMLNETWORK " ) ; 
 - static final AttributeKey < String > FML _ MARKER = AttributeKey . valueOf ( " fml : marker " ) ; 
 + static final AttributeKey < String > FML _ NETVERSION = AttributeKey . valueOf ( " fml : netversion " ) ; 
 + static final AttributeKey < FMLHandshakeHandler > FML _ HANDSHAKE _ HANDLER = AttributeKey . valueOf ( " fml : handshake " ) ; 
 + static final ResourceLocation FML _ HANDSHAKE _ RESOURCE = new ResourceLocation ( " fml : handshake " ) ; 
 + static final ResourceLocation FML _ PLAY _ RESOURCE = new ResourceLocation ( " fml : play " ) ; 
 + static final SimpleChannel handshakeChannel = NetworkInitialization . getHandshakeChannel ( ) ; 
 + static final SimpleChannel playChannel = NetworkInitialization . getPlayChannel ( ) ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLPlayHandler . java b / src / main / java / net / minecraftforge / fml / network / FMLPlayHandler . java 
 deleted file mode 100644 
 index 052f03e . . 0000000 
 - - - a / src / main / java / net / minecraftforge / fml / network / FMLPlayHandler . java 
 + + + / dev / null 
 @ @ - 1 , 38 + 0 , 0 @ @ 
 - / * 
 - * Minecraft Forge 
 - * Copyright ( c ) 2016 - 2019 . 
 - * 
 - * This library is free software ; you can redistribute it and / or 
 - * modify it under the terms of the GNU Lesser General Public 
 - * License as published by the Free Software Foundation version 2 . 1 
 - * of the License . 
 - * 
 - * This library is distributed in the hope that it will be useful , 
 - * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 - * 
 - * You should have received a copy of the GNU Lesser General Public 
 - * License along with this library ; if not , write to the Free Software 
 - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 - * / 
 - 
 - package net . minecraftforge . fml . network ; 
 - 
 - import net . minecraft . util . ResourceLocation ; 
 - import net . minecraftforge . fml . network . simple . SimpleChannel ; 
 - 
 - public class FMLPlayHandler 
 - { 
 - public static final SimpleChannel channel = NetworkRegistry . ChannelBuilder 
 - . named ( new ResourceLocation ( " fml " , " play " ) ) 
 - . clientAcceptedVersions ( a - > true ) 
 - . serverAcceptedVersions ( a - > true ) 
 - . networkProtocolVersion ( ( ) - > FMLNetworkConstants . NETVERSION ) 
 - . simpleChannel ( ) ; 
 - static 
 - { 
 - channel . registerMessage ( 0 , FMLPlayMessages . SpawnEntity . class , FMLPlayMessages . SpawnEntity : : encode , FMLPlayMessages . SpawnEntity : : decode , FMLPlayMessages . SpawnEntity : : handle ) ; 
 - channel . registerMessage ( 1 , FMLPlayMessages . OpenContainer . class , FMLPlayMessages . OpenContainer : : encode , FMLPlayMessages . OpenContainer : : decode , FMLPlayMessages . OpenContainer : : handle ) ; 
 - } 
 - } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 index f76e9e8 . . 4d9f27a 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 @ @ - 52 , 14 + 52 , 14 @ @ public class NetworkHooks 
 
 public static ConnectionType getConnectionType ( final Supplier < NetworkManager > connection ) 
 { 
 - return ConnectionType . forVersionFlag ( connection . get ( ) . channel ( ) . attr ( FMLNetworkConstants . FML _ MARKER ) . get ( ) ) ; 
 + return ConnectionType . forVersionFlag ( connection . get ( ) . channel ( ) . attr ( FMLNetworkConstants . FML _ NETVERSION ) . get ( ) ) ; 
 } 
 
 public static Packet < ? > getEntitySpawningPacket ( Entity entity ) 
 { 
 if ( ! entity . getType ( ) . usesVanillaSpawning ( ) ) 
 { 
 - return FMLPlayHandler . channel . toVanillaPacket ( new FMLPlayMessages . SpawnEntity ( entity ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + return FMLNetworkConstants . playChannel . toVanillaPacket ( new FMLPlayMessages . SpawnEntity ( entity ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 } 
 return null ; 
 } 
 @ @ - 71 , 14 + 71 , 14 @ @ public class NetworkHooks 
 
 public static void registerServerLoginChannel ( NetworkManager manager , CPacketHandshake packet ) 
 { 
 - manager . channel ( ) . attr ( FMLNetworkConstants . FML _ MARKER ) . set ( packet . getFMLVersion ( ) ) ; 
 + manager . channel ( ) . attr ( FMLNetworkConstants . FML _ NETVERSION ) . set ( packet . getFMLVersion ( ) ) ; 
 FMLHandshakeHandler . registerHandshake ( manager , NetworkDirection . LOGIN _ TO _ CLIENT ) ; 
 } 
 
 public static void registerClientLoginChannel ( NetworkManager manager ) 
 { 
 if ( manager = = null | | manager . channel ( ) = = null ) return ; 
 - manager . channel ( ) . attr ( FMLNetworkConstants . FML _ MARKER ) . set ( FMLNetworkConstants . NOVERSION ) ; 
 + manager . channel ( ) . attr ( FMLNetworkConstants . FML _ NETVERSION ) . set ( FMLNetworkConstants . NOVERSION ) ; 
 FMLHandshakeHandler . registerHandshake ( manager , NetworkDirection . LOGIN _ TO _ SERVER ) ; 
 } 
 
 @ @ - 167 , 7 + 167 , 7 @ @ public class NetworkHooks 
 throw new IllegalArgumentException ( " Invalid PacketBuffer for openGui , found " + output . readableBytes ( ) + " bytes " ) ; 
 } 
 FMLPlayMessages . OpenContainer msg = new FMLPlayMessages . OpenContainer ( id , openContainerId , output ) ; 
 - FMLPlayHandler . channel . sendTo ( msg , player . connection . getNetworkManager ( ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 + FMLNetworkConstants . playChannel . sendTo ( msg , player . connection . getNetworkManager ( ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 
 Container c = containerSupplier . createContainer ( player . inventory , player ) ; 
 player . openContainer = c ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkInitialization . java b / src / main / java / net / minecraftforge / fml / network / NetworkInitialization . java 
 new file mode 100644 
 index 0000000 . . b9d7c90 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkInitialization . java 
 @ @ - 0 , 0 + 1 , 139 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 - 2019 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . fml . network ; 
 + 
 + import net . minecraftforge . fml . config . ConfigTracker ; 
 + import net . minecraftforge . fml . network . simple . SimpleChannel ; 
 + import net . minecraftforge . fml . util . ThreeConsumer ; 
 + import net . minecraftforge . registries . RegistryManager ; 
 + 
 + import java . util . function . BiConsumer ; 
 + import java . util . function . Supplier ; 
 + 
 + class NetworkInitialization { 
 + 
 + public static SimpleChannel getHandshakeChannel ( ) { 
 + SimpleChannel handshakeChannel = NetworkRegistry . ChannelBuilder . 
 + named ( FMLNetworkConstants . FML _ HANDSHAKE _ RESOURCE ) . 
 + clientAcceptedVersions ( a - > true ) . 
 + serverAcceptedVersions ( a - > true ) . 
 + networkProtocolVersion ( ( ) - > FMLNetworkConstants . NETVERSION ) . 
 + simpleChannel ( ) ; 
 + 
 + handshakeChannel . messageBuilder ( FMLHandshakeMessages . C2SAcknowledge . class , 99 ) . 
 + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 + decoder ( FMLHandshakeMessages . C2SAcknowledge : : decode ) . 
 + encoder ( FMLHandshakeMessages . C2SAcknowledge : : encode ) . 
 + consumer ( indexFirst ( FMLHandshakeHandler : : handleClientAck ) ) . 
 + add ( ) ; 
 + 
 + handshakeChannel . messageBuilder ( FMLHandshakeMessages . S2CModList . class , 1 ) . 
 + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 + decoder ( FMLHandshakeMessages . S2CModList : : decode ) . 
 + encoder ( FMLHandshakeMessages . S2CModList : : encode ) . 
 + markAsLoginPacket ( ) . 
 + consumer ( biConsumerFor ( FMLHandshakeHandler : : handleServerModListOnClient ) ) . 
 + add ( ) ; 
 + 
 + handshakeChannel . messageBuilder ( FMLHandshakeMessages . C2SModListReply . class , 2 ) . 
 + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 + decoder ( FMLHandshakeMessages . C2SModListReply : : decode ) . 
 + encoder ( FMLHandshakeMessages . C2SModListReply : : encode ) . 
 + consumer ( indexFirst ( FMLHandshakeHandler : : handleClientModListOnServer ) ) . 
 + add ( ) ; 
 + 
 + handshakeChannel . messageBuilder ( FMLHandshakeMessages . S2CRegistry . class , 3 ) . 
 + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 + decoder ( FMLHandshakeMessages . S2CRegistry : : decode ) . 
 + encoder ( FMLHandshakeMessages . S2CRegistry : : encode ) . 
 + buildLoginPacketList ( RegistryManager : : generateRegistryPackets ) . / / TODO : Make this non - static , and store a cache on the client . 
 + consumer ( biConsumerFor ( FMLHandshakeHandler : : handleRegistryMessage ) ) . 
 + add ( ) ; 
 + 
 + handshakeChannel . messageBuilder ( FMLHandshakeMessages . S2CConfigData . class , 4 ) . 
 + loginIndex ( FMLHandshakeMessages . LoginIndexedMessage : : getLoginIndex , FMLHandshakeMessages . LoginIndexedMessage : : setLoginIndex ) . 
 + decoder ( FMLHandshakeMessages . S2CConfigData : : decode ) . 
 + encoder ( FMLHandshakeMessages . S2CConfigData : : encode ) . 
 + buildLoginPacketList ( ConfigTracker . INSTANCE : : syncConfigs ) . 
 + consumer ( biConsumerFor ( FMLHandshakeHandler : : handleConfigSync ) ) . 
 + add ( ) ; 
 + 
 + return handshakeChannel ; 
 + } 
 + 
 + public static SimpleChannel getPlayChannel ( ) { 
 + SimpleChannel playChannel = NetworkRegistry . ChannelBuilder 
 + . named ( FMLNetworkConstants . FML _ PLAY _ RESOURCE ) 
 + . clientAcceptedVersions ( a - > true ) 
 + . serverAcceptedVersions ( a - > true ) 
 + . networkProtocolVersion ( ( ) - > FMLNetworkConstants . NETVERSION ) 
 + . simpleChannel ( ) ; 
 + 
 + playChannel . messageBuilder ( FMLPlayMessages . SpawnEntity . class , 0 ) . 
 + decoder ( FMLPlayMessages . SpawnEntity : : decode ) . 
 + encoder ( FMLPlayMessages . SpawnEntity : : encode ) . 
 + consumer ( FMLPlayMessages . SpawnEntity : : handle ) . 
 + add ( ) ; 
 + 
 + playChannel . messageBuilder ( FMLPlayMessages . OpenContainer . class , 1 ) . 
 + decoder ( FMLPlayMessages . OpenContainer : : decode ) . 
 + encoder ( FMLPlayMessages . OpenContainer : : encode ) . 
 + consumer ( FMLPlayMessages . OpenContainer : : handle ) . 
 + add ( ) ; 
 + 
 + return playChannel ; 
 + } 
 + 
 + 
 + / * * 
 + * Transforms a two - argument instance method reference into a { @ link BiConsumer } based on the { @ link # getHandshake ( Supplier ) } function . 
 + * 
 + * @ param consumer A two argument instance method reference 
 + * @ param < MSG > message type 
 + * @ return A { @ link BiConsumer } for use in message handling 
 + * / 
 + private static < MSG extends FMLHandshakeMessages . LoginIndexedMessage > BiConsumer < MSG , Supplier < NetworkEvent . Context > > biConsumerFor ( ThreeConsumer < FMLHandshakeHandler , ? super MSG , ? super Supplier < NetworkEvent . Context > > consumer ) 
 + { 
 + return ( m , c ) - > ThreeConsumer . bindArgs ( consumer , m , c ) . accept ( getHandshake ( c ) ) ; 
 + } 
 + 
 + / * * 
 + * Transforms a two - argument instance method reference into a { @ link BiConsumer } { @ link # biConsumerFor ( ThreeConsumer ) } , first calling the { @ link # handleIndexedMessage ( FMLHandshakeMessages . LoginIndexedMessage , Supplier ) } 
 + * method to handle index tracking . Used for client to server replies . 
 + * @ param next The method reference to call after index handling 
 + * @ param < MSG > message type 
 + * @ return A { @ link BiConsumer } for use in message handling 
 + * / 
 + private static < MSG extends FMLHandshakeMessages . LoginIndexedMessage > BiConsumer < MSG , Supplier < NetworkEvent . Context > > indexFirst ( ThreeConsumer < FMLHandshakeHandler , MSG , Supplier < NetworkEvent . Context > > next ) 
 + { 
 + final BiConsumer < MSG , Supplier < NetworkEvent . Context > > loginIndexedMessageSupplierBiConsumer = biConsumerFor ( FMLHandshakeHandler : : handleIndexedMessage ) ; 
 + return loginIndexedMessageSupplierBiConsumer . andThen ( biConsumerFor ( next ) ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve the handshake from the { @ link NetworkEvent . Context } 
 + * 
 + * @ param contextSupplier the { @ link NetworkEvent . Context } 
 + * @ return The handshake handler for the connection 
 + * / 
 + private static FMLHandshakeHandler getHandshake ( Supplier < NetworkEvent . Context > contextSupplier ) { 
 + return contextSupplier . get ( ) . attr ( FMLNetworkConstants . FML _ HANDSHAKE _ HANDLER ) . get ( ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / DeferredWorkQueue . java b / src / main / java / net / minecraftforge / fml / DeferredWorkQueue . java 
 index 3a51300 . . 8227193 100644 
 - - - a / src / main / java / net / minecraftforge / fml / DeferredWorkQueue . java 
 + + + b / src / main / java / net / minecraftforge / fml / DeferredWorkQueue . java 
 @ @ - 109 , 7 + 109 , 7 @ @ public class DeferredWorkQueue 
 * @ return A { @ link CompletableFuture } that completes at said time 
 * / 
 public static CompletableFuture < Void > runLater ( Runnable workToEnqueue ) { 
 - currentOwner . set ( ModThreadContext . get ( ) . getActiveContainer ( ) ) ; 
 + currentOwner . set ( ModLoadingContext . get ( ) . getActiveContainer ( ) ) ; 
 return CompletableFuture . runAsync ( workToEnqueue , deferredExecutor ) . exceptionally ( DeferredWorkQueue . handleException ( ) ) ; 
 } 
 
 @ @ - 154 , 7 + 154 , 7 @ @ public class DeferredWorkQueue 
 * @ return A { @ link CompletableFuture } that completes at said time 
 * / 
 public static < T > CompletableFuture < T > getLater ( Supplier < T > workToEnqueue ) { 
 - currentOwner . set ( ModThreadContext . get ( ) . getActiveContainer ( ) ) ; 
 + currentOwner . set ( ModLoadingContext . get ( ) . getActiveContainer ( ) ) ; 
 return CompletableFuture . supplyAsync ( workToEnqueue , deferredExecutor ) . exceptionally ( DeferredWorkQueue . handleException ( ) ) ; 
 } 
 
 diff - - git a / src / main / java / net / minecraftforge / fml / ExtensionPoint . java b / src / main / java / net / minecraftforge / fml / ExtensionPoint . java 
 index d087bc0 . . 9cce0ba 100644 
 - - - a / src / main / java / net / minecraftforge / fml / ExtensionPoint . java 
 + + + b / src / main / java / net / minecraftforge / fml / ExtensionPoint . java 
 @ @ - 22 , 14 + 22 , 23 @ @ package net . minecraftforge . fml ; 
 import net . minecraft . client . Minecraft ; 
 import net . minecraft . client . gui . GuiScreen ; 
 import net . minecraft . resources . IResourcePack ; 
 + import net . minecraftforge . fml . network . FMLPlayMessages ; 
 import net . minecraftforge . fml . packs . ModFileResourcePack ; 
 
 import java . util . function . BiFunction ; 
 + import java . util . function . Function ; 
 
 public class ExtensionPoint < T > 
 { 
 - public static final ExtensionPoint < BiFunction < Minecraft , GuiScreen , GuiScreen > > GUIFACTORY = new ExtensionPoint < > ( ) ; 
 + public static final ExtensionPoint < BiFunction < Minecraft , GuiScreen , GuiScreen > > CONFIGGUIFACTORY = new ExtensionPoint < > ( ) ; 
 public static final ExtensionPoint < BiFunction < Minecraft , ModFileResourcePack , IResourcePack > > RESOURCEPACK = new ExtensionPoint < > ( ) ; 
 + 
 + / * * 
 + * Register with { @ link ModLoadingContext # } 
 + * / 
 + public static final ExtensionPoint < Function < FMLPlayMessages . OpenContainer , GuiScreen > > GUIFACTORY = new ExtensionPoint < > ( ) ; 
 + 
 + 
 private Class < T > type ; 
 
 private ExtensionPoint ( ) { 
 diff - - git a / src / main / java / net / minecraftforge / fml / ModContainer . java b / src / main / java / net / minecraftforge / fml / ModContainer . java 
 index 4afbf87 . . 92a7c7a 100644 
 - - - a / src / main / java / net / minecraftforge / fml / ModContainer . java 
 + + + b / src / main / java / net / minecraftforge / fml / ModContainer . java 
 @ @ - 115 , 11 + 115 , 11 @ @ public abstract class ModContainer 
 } 
 
 @ SuppressWarnings ( " unchecked " ) 
 - public < T > Optional < T > getCustomExtension ( ExtensionPoint point ) { 
 + public < T > Optional < T > getCustomExtension ( ExtensionPoint < T > point ) { 
 return Optional . ofNullable ( ( T ) extensionPoints . getOrDefault ( point , ( ) - > null ) . get ( ) ) ; 
 } 
 
 - public < T > void registerExtensionPoint ( ExtensionPoint point , Supplier < T > extension ) 
 + public < T > void registerExtensionPoint ( ExtensionPoint < T > point , Supplier < T > extension ) 
 { 
 extensionPoints . put ( point , extension ) ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / ModLoadingContext . java b / src / main / java / net / minecraftforge / fml / ModLoadingContext . java 
 new file mode 100644 
 index 0000000 . . d654666 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / ModLoadingContext . java 
 @ @ - 0 , 0 + 1 , 52 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 - 2019 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . fml ; 
 + 
 + import java . util . function . Supplier ; 
 + 
 + public class ModLoadingContext 
 + { 
 + private static ThreadLocal < ModLoadingContext > context = ThreadLocal . withInitial ( ModLoadingContext : : new ) ; 
 + 
 + public static ModLoadingContext get ( ) { 
 + return context . get ( ) ; 
 + } 
 + 
 + private ModContainer activeContainer ; 
 + 
 + public void setActiveContainer ( final ModContainer container ) { 
 + this . activeContainer = container ; 
 + } 
 + 
 + public ModContainer getActiveContainer ( ) { 
 + return activeContainer = = null ? DefaultModContainers . MINECRAFT : activeContainer ; 
 + } 
 + 
 + / * * 
 + * Register an { @ link ExtensionPoint } with the mod container . 
 + * @ param point The extension point to register 
 + * @ param extension An extension operator 
 + * @ param < T > The type signature of the extension operator 
 + * / 
 + public < T > void registerExtensionPoint ( ExtensionPoint < T > point , Supplier < T > extension ) { 
 + getActiveContainer ( ) . registerExtensionPoint ( point , extension ) ; 
 + } 
 + 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / ModThreadContext . java b / src / main / java / net / minecraftforge / fml / ModThreadContext . java 
 deleted file mode 100644 
 index 9bf7e8f . . 0000000 
 - - - a / src / main / java / net / minecraftforge / fml / ModThreadContext . java 
 + + + / dev / null 
 @ @ - 1 , 39 + 0 , 0 @ @ 
 - / * 
 - * Minecraft Forge 
 - * Copyright ( c ) 2016 - 2019 . 
 - * 
 - * This library is free software ; you can redistribute it and / or 
 - * modify it under the terms of the GNU Lesser General Public 
 - * License as published by the Free Software Foundation version 2 . 1 
 - * of the License . 
 - * 
 - * This library is distributed in the hope that it will be useful , 
 - * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 - * 
 - * You should have received a copy of the GNU Lesser General Public 
 - * License along with this library ; if not , write to the Free Software 
 - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 - * / 
 - 
 - package net . minecraftforge . fml ; 
 - 
 - public class ModThreadContext 
 - { 
 - private static ThreadLocal < ModThreadContext > context = ThreadLocal . withInitial ( ModThreadContext : : new ) ; 
 - 
 - public static ModThreadContext get ( ) { 
 - return context . get ( ) ; 
 - } 
 - 
 - private ModContainer activeContainer ; 
 - 
 - public void setActiveContainer ( final ModContainer container ) { 
 - this . activeContainer = container ; 
 - } 
 - 
 - public ModContainer getActiveContainer ( ) { 
 - return activeContainer = = null ? DefaultModContainers . MINECRAFT : activeContainer ; 
 - } 
 - } 
 diff - - git a / src / main / java / net / minecraftforge / fml / client / ConfigGuiHandler . java b / src / main / java / net / minecraftforge / fml / client / ConfigGuiHandler . java 
 index b258b4c . . c12d63f 100644 
 - - - a / src / main / java / net / minecraftforge / fml / client / ConfigGuiHandler . java 
 + + + b / src / main / java / net / minecraftforge / fml / client / ConfigGuiHandler . java 
 @ @ - 33 , 6 + 33 , 6 @ @ public class ConfigGuiHandler 
 public static Optional < BiFunction < Minecraft , GuiScreen , GuiScreen > > getGuiFactoryFor ( ModInfo selectedMod ) 
 { 
 return ModList . get ( ) . getModContainerById ( selectedMod . getModId ( ) ) . 
 - flatMap ( mc - > mc . getCustomExtension ( ExtensionPoint . GUIFACTORY ) ) ; 
 + flatMap ( mc - > mc . getCustomExtension ( ExtensionPoint . CONFIGGUIFACTORY ) ) ; 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModContainer . java b / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModContainer . java 
 index af47613 . . e226229 100644 
 - - - a / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModContainer . java 
 + + + b / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModContainer . java 
 @ @ - 28 , 7 + 28 , 7 @ @ import net . minecraftforge . fml . LifecycleEventProvider ; 
 import net . minecraftforge . fml . ModContainer ; 
 import net . minecraftforge . fml . ModLoadingException ; 
 import net . minecraftforge . fml . ModLoadingStage ; 
 - import net . minecraftforge . fml . ModThreadContext ; 
 + import net . minecraftforge . fml . ModLoadingContext ; 
 import net . minecraftforge . forgespi . language . IModInfo ; 
 import net . minecraftforge . forgespi . language . ModFileScanData ; 
 
 @ @ - 94 , 7 + 94 , 7 @ @ public class FMLModContainer extends ModContainer 
 
 private void beforeEvent ( LifecycleEventProvider . LifecycleEvent lifecycleEvent ) { 
 FMLModLoadingContext . get ( ) . setActiveContainer ( this ) ; 
 - ModThreadContext . get ( ) . setActiveContainer ( this ) ; 
 + ModLoadingContext . get ( ) . setActiveContainer ( this ) ; 
 } 
 
 private void fireEvent ( LifecycleEventProvider . LifecycleEvent lifecycleEvent ) { 
 @ @ - 113 , 7 + 113 , 7 @ @ public class FMLModContainer extends ModContainer 
 } 
 
 private void afterEvent ( LifecycleEventProvider . LifecycleEvent lifecycleEvent ) { 
 - ModThreadContext . get ( ) . setActiveContainer ( null ) ; 
 + ModLoadingContext . get ( ) . setActiveContainer ( null ) ; 
 FMLModLoadingContext . get ( ) . setActiveContainer ( null ) ; 
 if ( getCurrentState ( ) = = ModLoadingStage . ERROR ) { 
 LOGGER . error ( LOADING , " An error occurred while dispatching event { } to { } " , lifecycleEvent . fromStage ( ) , getModId ( ) ) ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModLoadingContext . java b / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModLoadingContext . java 
 index 2c4459a . . 3a6cfd7 100644 
 - - - a / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModLoadingContext . java 
 + + + b / src / main / java / net / minecraftforge / fml / javafmlmod / FMLModLoadingContext . java 
 @ @ - 34 , 23 + 34 , 26 @ @ public class FMLModLoadingContext 
 return context . get ( ) ; 
 } 
 
 - public < T > void registerExtensionPoint ( ExtensionPoint < T > point , Supplier < T > extension ) { 
 - getActiveContainer ( ) . registerExtensionPoint ( point , extension ) ; 
 - } 
 - 
 public void registerConfig ( ModConfig . Type type , ForgeConfigSpec spec ) { 
 - activeContainer . addConfig ( new ModConfig ( type , spec , activeContainer ) ) ; 
 + getActiveContainer ( ) . addConfig ( new ModConfig ( type , spec , getActiveContainer ( ) ) ) ; 
 } 
 
 public void registerConfig ( ModConfig . Type type , ForgeConfigSpec spec , String fileName ) { 
 - activeContainer . addConfig ( new ModConfig ( type , spec , activeContainer , fileName ) ) ; 
 + getActiveContainer ( ) . addConfig ( new ModConfig ( type , spec , getActiveContainer ( ) , fileName ) ) ; 
 } 
 
 + / * * 
 + * @ return The mod ' s event bus , to allow subscription to Mod specific events 
 + * / 
 public IEventBus getModEventBus ( ) 
 { 
 return getActiveContainer ( ) . getEventBus ( ) ; 
 } 
 
 + / * * 
 + * Only valid during { @ link net . minecraftforge . fml . event . lifecycle . ModLifecycleEvent } dispatch and Mod construction 
 + * @ return the active FML container 
 + * / 
 public FMLModContainer getActiveContainer ( ) 
 { 
 return activeContainer ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLPlayMessages . java b / src / main / java / net / minecraftforge / fml / network / FMLPlayMessages . java 
 index ab10cd9 . . 34436ee 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / FMLPlayMessages . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / FMLPlayMessages . java 
 @ @ - 19 , 20 + 19 , 19 @ @ 
 
 package net . minecraftforge . fml . network ; 
 
 - import io . netty . buffer . ByteBuf ; 
 import io . netty . buffer . Unpooled ; 
 import net . minecraft . client . Minecraft ; 
 - import net . minecraft . client . gui . GuiScreen ; 
 import net . minecraft . entity . Entity ; 
 import net . minecraft . entity . EntityTracker ; 
 import net . minecraft . entity . EntityType ; 
 import net . minecraft . network . PacketBuffer ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraft . util . math . MathHelper ; 
 + import net . minecraftforge . fml . ExtensionPoint ; 
 + import net . minecraftforge . fml . ModList ; 
 import net . minecraftforge . fml . common . registry . IEntityAdditionalSpawnData ; 
 
 import java . util . UUID ; 
 - import java . util . function . Function ; 
 import java . util . function . Supplier ; 
 
 public class FMLPlayMessages 
 @ @ - 166 , 9 + 165 , 9 @ @ public class FMLPlayMessages 
 { 
 private final ResourceLocation id ; 
 private final int windowId ; 
 - private final byte [ ] additionalData ; 
 + private final PacketBuffer additionalData ; 
 
 - public OpenContainer ( ResourceLocation id , int windowId , byte [ ] additionalData ) 
 + OpenContainer ( ResourceLocation id , int windowId , PacketBuffer additionalData ) 
 { 
 this . id = id ; 
 this . windowId = windowId ; 
 @ @ - 179 , 27 + 178 , 34 @ @ public class FMLPlayMessages 
 { 
 buf . writeResourceLocation ( msg . id ) ; 
 buf . writeVarInt ( msg . windowId ) ; 
 - buf . writeByteArray ( msg . additionalData ) ; 
 + buf . writeBytes ( msg . additionalData ) ; 
 } 
 
 public static OpenContainer decode ( PacketBuffer buf ) 
 { 
 - return new OpenContainer ( buf . readResourceLocation ( ) , buf . readVarInt ( ) , buf . readByteArray ( ) ) ; 
 + return new OpenContainer ( buf . readResourceLocation ( ) , buf . readVarInt ( ) , new PacketBuffer ( Unpooled . wrappedBuffer ( buf . readByteArray ( 32600 ) ) ) ) ; 
 } 
 
 public static void handle ( OpenContainer msg , Supplier < NetworkEvent . Context > ctx ) 
 { 
 - ctx . get ( ) . enqueueWork ( ( ) - > { 
 - Supplier < Function < ByteBuf , GuiScreen > > sup = NetworkRegistry . guiHandlers . get ( msg . id ) ; 
 - if ( sup ! = null ) { 
 - GuiScreen gui = sup . get ( ) . apply ( Unpooled . wrappedBuffer ( msg . additionalData ) ) ; 
 - if ( gui ! = null ) { 
 - Minecraft . getInstance ( ) . displayGuiScreen ( gui ) ; 
 - Minecraft . getInstance ( ) . player . openContainer . windowId = msg . windowId ; 
 - } 
 - } 
 - } ) ; 
 + ctx . get ( ) . enqueueWork ( ( ) - > ModList . get ( ) . getModContainerById ( msg . id . getNamespace ( ) ) . ifPresent ( mc - > 
 + mc . getCustomExtension ( ExtensionPoint . GUIFACTORY ) . map ( f - > f . apply ( msg ) ) . ifPresent ( gui - > { 
 + Minecraft . getInstance ( ) . displayGuiScreen ( gui ) ; 
 + Minecraft . getInstance ( ) . player . openContainer . windowId = msg . windowId ; 
 + } ) ) ) ; 
 ctx . get ( ) . setPacketHandled ( true ) ; 
 } 
 + 
 + public final ResourceLocation getId ( ) { 
 + return this . id ; 
 + } 
 + 
 + public int getWindowId ( ) { 
 + return windowId ; 
 + } 
 + 
 + public PacketBuffer getAdditionalData ( ) { 
 + return additionalData ; 
 + } 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 index cb16e72 . . 20131bb 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 @ @ - 19 , 13 + 19 , 14 @ @ 
 
 package net . minecraftforge . fml . network ; 
 
 - import io . netty . buffer . ByteBuf ; 
 + import io . netty . buffer . Unpooled ; 
 import net . minecraft . entity . Entity ; 
 import net . minecraft . entity . player . EntityPlayerMP ; 
 import net . minecraft . inventory . Container ; 
 import net . minecraft . network . NetHandlerPlayServer ; 
 import net . minecraft . network . NetworkManager ; 
 import net . minecraft . network . Packet ; 
 + import net . minecraft . network . PacketBuffer ; 
 import net . minecraft . network . handshake . client . CPacketHandshake ; 
 import net . minecraft . server . network . NetHandlerLoginServer ; 
 import net . minecraft . util . ResourceLocation ; 
 @ @ - 87 , 10 + 88 , 22 @ @ public class NetworkHooks 
 return FMLHandshakeHandler . tickLogin ( networkManager ) ; 
 } 
 
 - public static void openGui ( EntityPlayerMP player , IInteractionObject container , @ Nullable ByteBuf extraData ) 
 + / * * 
 + * Server method to tell the client to open a GUI on behalf of the server 
 + * 
 + * The { @ link IInteractionObject # getGuiID ( ) } is treated as a { @ link ResourceLocation } . 
 + * It should refer to a valid modId namespace , to trigger opening on the client . 
 + * The namespace is directly used to lookup the modId in the client side . 
 + * 
 + * @ param player The player to open the GUI for 
 + * @ param containerSupplier The Container Supplier 
 + * @ param extraData Additional data for the GUI 
 + * / 
 + public static void openGui ( EntityPlayerMP player , IInteractionObject containerSupplier , @ Nullable PacketBuffer extraData ) 
 { 
 - ResourceLocation id = new ResourceLocation ( container . getGuiID ( ) ) ; 
 - Container c = container . createContainer ( player . inventory , player ) ; 
 + if ( player . world . isRemote ) return ; 
 + ResourceLocation id = new ResourceLocation ( containerSupplier . getGuiID ( ) ) ; 
 + Container c = containerSupplier . createContainer ( player . inventory , player ) ; 
 player . closeScreen ( ) ; 
 player . getNextWindowId ( ) ; 
 player . openContainer = c ; 
 @ @ - 98 , 14 + 111 , 13 @ @ public class NetworkHooks 
 player . openContainer . addListener ( player ) ; 
 MinecraftForge . EVENT _ BUS . post ( new PlayerContainerEvent . Open ( player , c ) ) ; 
 
 - byte [ ] additional ; 
 if ( extraData = = null ) { 
 - additional = new byte [ 0 ] ; 
 - } else { 
 - additional = new byte [ extraData . readableBytes ( ) ] ; 
 - extraData . readBytes ( additional ) ; 
 + extraData = new PacketBuffer ( Unpooled . buffer ( ) ) ; 
 } 
 - FMLPlayMessages . OpenContainer msg = new FMLPlayMessages . OpenContainer ( id , player . currentWindowId , additional ) ; 
 + if ( extraData . readableBytes ( ) > 32600 ) { 
 + throw new IllegalArgumentException ( " GUI Open packet too large : " + extraData . readableBytes ( ) ) ; 
 + } 
 + FMLPlayMessages . OpenContainer msg = new FMLPlayMessages . OpenContainer ( id , player . currentWindowId , extraData ) ; 
 FMLPlayHandler . channel . sendTo ( msg , player . connection . getNetworkManager ( ) , NetworkDirection . PLAY _ TO _ CLIENT ) ; 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 index 36e6717 . . 41a60c4 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 @ @ - 19 , 8 + 19 , 6 @ @ 
 
 package net . minecraftforge . fml . network ; 
 
 - import io . netty . buffer . ByteBuf ; 
 - import net . minecraft . client . gui . GuiScreen ; 
 import net . minecraft . nbt . NBTTagCompound ; 
 import net . minecraft . nbt . NBTTagList ; 
 import net . minecraft . network . NetworkManager ; 
 @ @ - 34 , 10 + 32 , 12 @ @ import org . apache . logging . log4j . Logger ; 
 import org . apache . logging . log4j . Marker ; 
 import org . apache . logging . log4j . MarkerManager ; 
 
 - import java . util . * ; 
 - import java . util . concurrent . ConcurrentHashMap ; 
 + import java . util . ArrayList ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Optional ; 
 import java . util . function . BiFunction ; 
 - import java . util . function . Function ; 
 import java . util . function . Predicate ; 
 import java . util . function . Supplier ; 
 import java . util . stream . Collectors ; 
 @ @ - 51 , 21 + 51 , 6 @ @ public class NetworkRegistry 
 private static final Marker NETREGISTRY = MarkerManager . getMarker ( " NETREGISTRY " ) ; 
 
 private static Map < ResourceLocation , NetworkInstance > instances = new HashMap < > ( ) ; 
 - static final Map < ResourceLocation , Supplier < Function < ByteBuf , GuiScreen > > > guiHandlers = new ConcurrentHashMap < > ( ) ; 
 - 
 - / * * 
 - * Registers a client - side GUI handler for the given ID . 
 - * The function takes any extra data provided to { @ link net . minecraft . entity . player . EntityPlayer # openGui } 
 - * and returns a { @ link GuiScreen } to display . 
 - * Call this during { @ link net . minecraftforge . fml . event . lifecycle . FMLClientSetupEvent } . 
 - * This method is safe to call in parallel mod loading 
 - * @ param id 
 - * @ param handler 
 - * / 
 - public static void registerGui ( ResourceLocation id , Supplier < Function < ByteBuf , GuiScreen > > handler ) 
 - { 
 - guiHandlers . put ( id , handler ) ; 
 - } 
 
 / * * 
 * Special value for clientAcceptedVersions and serverAcceptedVersions predicates indicating the other side lacks 
 diff - - git a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 index a9c3bf9 . . d259c3b 100644 
 - - - a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 + + + b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 @ @ - 28 , 13 + 28 , 12 @ @ import java . util . Map ; 
 import java . util . Map . Entry ; 
 
 import javax . annotation . Nonnull ; 
 - import net . minecraftforge . fml . ModThreadContext ; 
 + import net . minecraftforge . fml . ModLoadingContext ; 
 import net . minecraftforge . fml . common . ObfuscationReflectionHelper ; 
 import net . minecraftforge . fml . loading . AdvancedLogMessageAdapter ; 
 import org . apache . commons . lang3 . Validate ; 
 
 import java . util . Set ; 
 - import java . util . stream . Collectors ; 
 
 import com . google . common . base . Preconditions ; 
 import com . google . common . collect . ArrayListMultimap ; 
 @ @ - 280 , 7 + 279 , 7 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 
 int add ( int id , V value ) 
 { 
 - final String owner = ModThreadContext . get ( ) . getActiveContainer ( ) . getNamespace ( ) ; 
 + final String owner = ModLoadingContext . get ( ) . getActiveContainer ( ) . getNamespace ( ) ; 
 return add ( id , value , owner ) ; 
 } 
 
 diff - - git a / src / main / java / net / minecraftforge / registries / GameData . java b / src / main / java / net / minecraftforge / registries / GameData . java 
 index 24203a5 . . 7cdbd6b 100644 
 - - - a / src / main / java / net / minecraftforge / registries / GameData . java 
 + + + b / src / main / java / net / minecraftforge / registries / GameData . java 
 @ @ - 42 , 7 + 42 , 7 @ @ import net . minecraftforge . common . MinecraftForge ; 
 import net . minecraftforge . event . RegistryEvent ; 
 import net . minecraftforge . event . RegistryEvent . MissingMappings ; 
 import net . minecraftforge . fml . LifecycleEventProvider ; 
 - import net . minecraftforge . fml . ModThreadContext ; 
 + import net . minecraftforge . fml . ModLoadingContext ; 
 import net . minecraftforge . fml . StartupQuery ; 
 import net . minecraftforge . fml . common . EnhancedRuntimeException ; 
 import net . minecraftforge . fml . common . registry . VillagerRegistry . VillagerProfession ; 
 @ @ - 51 , 8 + 51 , 6 @ @ import net . minecraftforge . fml . loading . AdvancedLogMessageAdapter ; 
 import org . apache . commons . lang3 . Validate ; 
 import org . apache . logging . log4j . LogManager ; 
 import org . apache . logging . log4j . Logger ; 
 - import org . apache . logging . log4j . Marker ; 
 - import org . apache . logging . log4j . MarkerManager ; 
 
 import javax . annotation . Nullable ; 
 import java . lang . reflect . Field ; 
 @ @ - 66 , 7 + 64 , 6 @ @ import java . util . function . Consumer ; 
 import java . util . function . Predicate ; 
 import java . util . stream . Collectors ; 
 
 - import static net . minecraftforge . fml . Logging . CORE ; 
 import static net . minecraftforge . registries . ForgeRegistry . REGISTRIES ; 
 
 / * * 
 @ @ - 828 , 7 + 825 , 7 @ @ public class GameData 
 int index = name . lastIndexOf ( ' : ' ) ; 
 String oldPrefix = index = = - 1 ? " " : name . substring ( 0 , index ) . toLowerCase ( Locale . ROOT ) ; 
 name = index = = - 1 ? name : name . substring ( index + 1 ) ; 
 - String prefix = ModThreadContext . get ( ) . getActiveContainer ( ) . getNamespace ( ) ; 
 + String prefix = ModLoadingContext . get ( ) . getActiveContainer ( ) . getNamespace ( ) ; 
 if ( ! oldPrefix . equals ( prefix ) & & oldPrefix . length ( ) > 0 ) 
 { 
 LogManager . getLogger ( ) . info ( " Potentially Dangerous alternative prefix ` { } ` for name ` { } ` , expected ` { } ` . This could be a intended override , but in most cases indicates a broken mod . " , oldPrefix , name , prefix ) ;
