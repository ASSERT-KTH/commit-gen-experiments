BLEU SCORE: 0.01578994121820227

TEST MSG: Try a different way of doing the callback , it removes the derpitude , but at
GENERATED MSG: Fix the netty bug introduced by netty commit https : / / github . com / netty / netty / commit / 29fdb160f33776c76f0b46aada48a9c9f3babcbf

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java <nl> index 2611ee1 . . fa8430b 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java <nl> @ @ - 75 , 11 + 75 , 11 @ @ import org . apache . logging . log4j . Level ; <nl> public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > implements ChannelOutboundHandler { <nl> private static boolean DEBUG _ HANDSHAKE = Boolean . parseBoolean ( System . getProperty ( " fml . debugNetworkHandshake " , " false " ) ) ; <nl> private static enum ConnectionState { <nl> - OPENING , AWAITING _ HANDSHAKE , HANDSHAKING , HANDSHAKECOMPLETE , FINALIZING , CONNECTED ; <nl> + OPENING , AWAITING _ HANDSHAKE , HANDSHAKING , HANDSHAKECOMPLETE , FINALIZING , CONNECTED <nl> } <nl> <nl> private static enum ConnectionType { <nl> - MODDED , BUKKIT , VANILLA ; <nl> + MODDED , BUKKIT , VANILLA <nl> } <nl> <nl> public static NetworkDispatcher get ( NetworkManager manager ) <nl> @ @ - 116 , 20 + 116 , 6 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im <nl> private Map < String , String > modList ; <nl> private int overrideLoginDim ; <nl> <nl> - private static final Field ordered ; <nl> - <nl> - static { <nl> - try <nl> - { <nl> - ordered = Class . forName ( " io . netty . channel . AbstractChannelHandlerContext " ) . getDeclaredField ( " ordered " ) ; <nl> - ordered . setAccessible ( true ) ; <nl> - } <nl> - catch ( NoSuchFieldException | ClassNotFoundException e ) <nl> - { <nl> - FMLLog . log ( Level . FATAL , " WOW , Netty changed , * * * * HAXXXXX * * * * " , e ) ; <nl> - throw new Error ( e ) ; <nl> - } <nl> - } <nl> public NetworkDispatcher ( NetworkManager manager ) <nl> { <nl> super ( false ) ; <nl> @ @ - 188 , 32 + 174 , 7 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im <nl> { <nl> this . manager . channel ( ) . config ( ) . setAutoRead ( false ) ; <nl> / / Insert ourselves into the pipeline <nl> - final ChannelPipeline cp = this . manager . channel ( ) . pipeline ( ) . addBefore ( " packet _ handler " , " fml : packet _ handler " , this ) ; <nl> - / / THIS IS A GHASTLY HACK TO FIX A STUPID " FEATURE " IN NETTY <nl> - / / We force the " AbstractChannelHandlerContext " order field to false - because we don ' t want <nl> - / / our handshake handler to " WAIT " until it ' s completed the " handlerAdded " method , before becoming active <nl> - / / in the pipeline <nl> - final ChannelHandlerContext context = cp . context ( this ) ; <nl> - try <nl> - { <nl> - ordered . set ( context , false ) ; <nl> - } <nl> - catch ( IllegalAccessException e ) <nl> - { <nl> - FMLLog . log ( Level . FATAL , " Wow , that reflection failed ! " , e ) ; <nl> - throw new Error ( e ) ; <nl> - } <nl> - <nl> - } <nl> - <nl> - public void clientToServerHandshake ( ) <nl> - { <nl> - insertIntoChannel ( ) ; <nl> - } <nl> - <nl> - @ Override <nl> - public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception <nl> - { <nl> + this . manager . channel ( ) . pipeline ( ) . addBefore ( " packet _ handler " , " fml : packet _ handler " , this ) ; <nl> if ( this . state ! = null ) { <nl> FMLLog . getLogger ( ) . log ( Level . INFO , " Opening channel which already seems to have a state set . This is a vanilla connection . Handshake handler will stop now " ) ; <nl> this . manager . channel ( ) . config ( ) . setAutoRead ( true ) ; <nl> @ @ - 226 , 6 + 187 , 11 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im <nl> this . manager . channel ( ) . config ( ) . setAutoRead ( true ) ; <nl> } <nl> <nl> + public void clientToServerHandshake ( ) <nl> + { <nl> + insertIntoChannel ( ) ; <nl> + } <nl> + <nl> int serverInitiateHandshake ( ) <nl> { <nl> / / Send mod salutation to the client
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java <nl> index 63163e3 . . 2611ee1 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ package net . minecraftforge . fml . common . network . handshake ; <nl> import io . netty . buffer . Unpooled ; <nl> import io . netty . channel . ChannelHandlerContext ; <nl> import io . netty . channel . ChannelOutboundHandler ; <nl> + import io . netty . channel . ChannelPipeline ; <nl> import io . netty . channel . ChannelPromise ; <nl> import io . netty . channel . SimpleChannelInboundHandler ; <nl> import io . netty . channel . embedded . EmbeddedChannel ; <nl> @ @ - 30 , 6 + 31 , 7 @ @ import io . netty . util . concurrent . Future ; <nl> import io . netty . util . concurrent . GenericFutureListener ; <nl> <nl> import java . io . IOException ; <nl> + import java . lang . reflect . Field ; <nl> import java . net . SocketAddress ; <nl> import java . nio . channels . ClosedChannelException ; <nl> import java . util . Collections ; <nl> @ @ - 71 , 7 + 73 , 7 @ @ import org . apache . logging . log4j . Level ; <nl> <nl> / / TODO build test suites to validate the behaviour of this stuff and make it less annoyingly magical <nl> public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > implements ChannelOutboundHandler { <nl> - private static boolean DEBUG _ HANDSHAKE = Boolean . parseBoolean ( System . getProperty ( " fml . debugNetworkHandshake " , " true " ) ) ; <nl> + private static boolean DEBUG _ HANDSHAKE = Boolean . parseBoolean ( System . getProperty ( " fml . debugNetworkHandshake " , " false " ) ) ; <nl> private static enum ConnectionState { <nl> OPENING , AWAITING _ HANDSHAKE , HANDSHAKING , HANDSHAKECOMPLETE , FINALIZING , CONNECTED ; <nl> } <nl> @ @ - 114 , 6 + 116 , 20 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im <nl> private Map < String , String > modList ; <nl> private int overrideLoginDim ; <nl> <nl> + private static final Field ordered ; <nl> + <nl> + static { <nl> + try <nl> + { <nl> + ordered = Class . forName ( " io . netty . channel . AbstractChannelHandlerContext " ) . getDeclaredField ( " ordered " ) ; <nl> + ordered . setAccessible ( true ) ; <nl> + } <nl> + catch ( NoSuchFieldException | ClassNotFoundException e ) <nl> + { <nl> + FMLLog . log ( Level . FATAL , " WOW , Netty changed , * * * * HAXXXXX * * * * " , e ) ; <nl> + throw new Error ( e ) ; <nl> + } <nl> + } <nl> public NetworkDispatcher ( NetworkManager manager ) <nl> { <nl> super ( false ) ; <nl> @ @ - 172 , 7 + 188 , 22 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im <nl> { <nl> this . manager . channel ( ) . config ( ) . setAutoRead ( false ) ; <nl> / / Insert ourselves into the pipeline <nl> - this . manager . channel ( ) . pipeline ( ) . addBefore ( " packet _ handler " , " fml : packet _ handler " , this ) ; <nl> + final ChannelPipeline cp = this . manager . channel ( ) . pipeline ( ) . addBefore ( " packet _ handler " , " fml : packet _ handler " , this ) ; <nl> + / / THIS IS A GHASTLY HACK TO FIX A STUPID " FEATURE " IN NETTY <nl> + / / We force the " AbstractChannelHandlerContext " order field to false - because we don ' t want <nl> + / / our handshake handler to " WAIT " until it ' s completed the " handlerAdded " method , before becoming active <nl> + / / in the pipeline <nl> + final ChannelHandlerContext context = cp . context ( this ) ; <nl> + try <nl> + { <nl> + ordered . set ( context , false ) ; <nl> + } <nl> + catch ( IllegalAccessException e ) <nl> + { <nl> + FMLLog . log ( Level . FATAL , " Wow , that reflection failed ! " , e ) ; <nl> + throw new Error ( e ) ; <nl> + } <nl> + <nl> } <nl> <nl> public void clientToServerHandshake ( )

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java 
 index 2611ee1 . . fa8430b 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java 
 @ @ - 75 , 11 + 75 , 11 @ @ import org . apache . logging . log4j . Level ; 
 public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > implements ChannelOutboundHandler { 
 private static boolean DEBUG _ HANDSHAKE = Boolean . parseBoolean ( System . getProperty ( " fml . debugNetworkHandshake " , " false " ) ) ; 
 private static enum ConnectionState { 
 - OPENING , AWAITING _ HANDSHAKE , HANDSHAKING , HANDSHAKECOMPLETE , FINALIZING , CONNECTED ; 
 + OPENING , AWAITING _ HANDSHAKE , HANDSHAKING , HANDSHAKECOMPLETE , FINALIZING , CONNECTED 
 } 
 
 private static enum ConnectionType { 
 - MODDED , BUKKIT , VANILLA ; 
 + MODDED , BUKKIT , VANILLA 
 } 
 
 public static NetworkDispatcher get ( NetworkManager manager ) 
 @ @ - 116 , 20 + 116 , 6 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im 
 private Map < String , String > modList ; 
 private int overrideLoginDim ; 
 
 - private static final Field ordered ; 
 - 
 - static { 
 - try 
 - { 
 - ordered = Class . forName ( " io . netty . channel . AbstractChannelHandlerContext " ) . getDeclaredField ( " ordered " ) ; 
 - ordered . setAccessible ( true ) ; 
 - } 
 - catch ( NoSuchFieldException | ClassNotFoundException e ) 
 - { 
 - FMLLog . log ( Level . FATAL , " WOW , Netty changed , * * * * HAXXXXX * * * * " , e ) ; 
 - throw new Error ( e ) ; 
 - } 
 - } 
 public NetworkDispatcher ( NetworkManager manager ) 
 { 
 super ( false ) ; 
 @ @ - 188 , 32 + 174 , 7 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im 
 { 
 this . manager . channel ( ) . config ( ) . setAutoRead ( false ) ; 
 / / Insert ourselves into the pipeline 
 - final ChannelPipeline cp = this . manager . channel ( ) . pipeline ( ) . addBefore ( " packet _ handler " , " fml : packet _ handler " , this ) ; 
 - / / THIS IS A GHASTLY HACK TO FIX A STUPID " FEATURE " IN NETTY 
 - / / We force the " AbstractChannelHandlerContext " order field to false - because we don ' t want 
 - / / our handshake handler to " WAIT " until it ' s completed the " handlerAdded " method , before becoming active 
 - / / in the pipeline 
 - final ChannelHandlerContext context = cp . context ( this ) ; 
 - try 
 - { 
 - ordered . set ( context , false ) ; 
 - } 
 - catch ( IllegalAccessException e ) 
 - { 
 - FMLLog . log ( Level . FATAL , " Wow , that reflection failed ! " , e ) ; 
 - throw new Error ( e ) ; 
 - } 
 - 
 - } 
 - 
 - public void clientToServerHandshake ( ) 
 - { 
 - insertIntoChannel ( ) ; 
 - } 
 - 
 - @ Override 
 - public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception 
 - { 
 + this . manager . channel ( ) . pipeline ( ) . addBefore ( " packet _ handler " , " fml : packet _ handler " , this ) ; 
 if ( this . state ! = null ) { 
 FMLLog . getLogger ( ) . log ( Level . INFO , " Opening channel which already seems to have a state set . This is a vanilla connection . Handshake handler will stop now " ) ; 
 this . manager . channel ( ) . config ( ) . setAutoRead ( true ) ; 
 @ @ - 226 , 6 + 187 , 11 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im 
 this . manager . channel ( ) . config ( ) . setAutoRead ( true ) ; 
 } 
 
 + public void clientToServerHandshake ( ) 
 + { 
 + insertIntoChannel ( ) ; 
 + } 
 + 
 int serverInitiateHandshake ( ) 
 { 
 / / Send mod salutation to the client

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java 
 index 63163e3 . . 2611ee1 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / NetworkDispatcher . java 
 @ @ - 22 , 6 + 22 , 7 @ @ package net . minecraftforge . fml . common . network . handshake ; 
 import io . netty . buffer . Unpooled ; 
 import io . netty . channel . ChannelHandlerContext ; 
 import io . netty . channel . ChannelOutboundHandler ; 
 + import io . netty . channel . ChannelPipeline ; 
 import io . netty . channel . ChannelPromise ; 
 import io . netty . channel . SimpleChannelInboundHandler ; 
 import io . netty . channel . embedded . EmbeddedChannel ; 
 @ @ - 30 , 6 + 31 , 7 @ @ import io . netty . util . concurrent . Future ; 
 import io . netty . util . concurrent . GenericFutureListener ; 
 
 import java . io . IOException ; 
 + import java . lang . reflect . Field ; 
 import java . net . SocketAddress ; 
 import java . nio . channels . ClosedChannelException ; 
 import java . util . Collections ; 
 @ @ - 71 , 7 + 73 , 7 @ @ import org . apache . logging . log4j . Level ; 
 
 / / TODO build test suites to validate the behaviour of this stuff and make it less annoyingly magical 
 public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > implements ChannelOutboundHandler { 
 - private static boolean DEBUG _ HANDSHAKE = Boolean . parseBoolean ( System . getProperty ( " fml . debugNetworkHandshake " , " true " ) ) ; 
 + private static boolean DEBUG _ HANDSHAKE = Boolean . parseBoolean ( System . getProperty ( " fml . debugNetworkHandshake " , " false " ) ) ; 
 private static enum ConnectionState { 
 OPENING , AWAITING _ HANDSHAKE , HANDSHAKING , HANDSHAKECOMPLETE , FINALIZING , CONNECTED ; 
 } 
 @ @ - 114 , 6 + 116 , 20 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im 
 private Map < String , String > modList ; 
 private int overrideLoginDim ; 
 
 + private static final Field ordered ; 
 + 
 + static { 
 + try 
 + { 
 + ordered = Class . forName ( " io . netty . channel . AbstractChannelHandlerContext " ) . getDeclaredField ( " ordered " ) ; 
 + ordered . setAccessible ( true ) ; 
 + } 
 + catch ( NoSuchFieldException | ClassNotFoundException e ) 
 + { 
 + FMLLog . log ( Level . FATAL , " WOW , Netty changed , * * * * HAXXXXX * * * * " , e ) ; 
 + throw new Error ( e ) ; 
 + } 
 + } 
 public NetworkDispatcher ( NetworkManager manager ) 
 { 
 super ( false ) ; 
 @ @ - 172 , 7 + 188 , 22 @ @ public class NetworkDispatcher extends SimpleChannelInboundHandler < Packet < ? > > im 
 { 
 this . manager . channel ( ) . config ( ) . setAutoRead ( false ) ; 
 / / Insert ourselves into the pipeline 
 - this . manager . channel ( ) . pipeline ( ) . addBefore ( " packet _ handler " , " fml : packet _ handler " , this ) ; 
 + final ChannelPipeline cp = this . manager . channel ( ) . pipeline ( ) . addBefore ( " packet _ handler " , " fml : packet _ handler " , this ) ; 
 + / / THIS IS A GHASTLY HACK TO FIX A STUPID " FEATURE " IN NETTY 
 + / / We force the " AbstractChannelHandlerContext " order field to false - because we don ' t want 
 + / / our handshake handler to " WAIT " until it ' s completed the " handlerAdded " method , before becoming active 
 + / / in the pipeline 
 + final ChannelHandlerContext context = cp . context ( this ) ; 
 + try 
 + { 
 + ordered . set ( context , false ) ; 
 + } 
 + catch ( IllegalAccessException e ) 
 + { 
 + FMLLog . log ( Level . FATAL , " Wow , that reflection failed ! " , e ) ; 
 + throw new Error ( e ) ; 
 + } 
 + 
 } 
 
 public void clientToServerHandshake ( )
