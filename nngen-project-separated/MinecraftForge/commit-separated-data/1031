BLEU SCORE: 0.044808361601213584

TEST MSG: Add in an ItemStackHolder - a way to inject ItemStacks without having to have complex lookup code everywhere .
GENERATED MSG: Add in the objectholder , autopopulated by FML based on simple rules . Allows

TEST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / Loader . java b / fml / src / main / java / cpw / mods / fml / common / Loader . java <nl> index 006af1b . . 4de8f74 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / Loader . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / Loader . java <nl> @ @ - 75 , 6 + 75 , 7 @ @ import cpw . mods . fml . common . functions . ArtifactVersionNameFunction ; <nl> import cpw . mods . fml . common . functions . ModIdFunction ; <nl> import cpw . mods . fml . common . registry . GameData ; <nl> import cpw . mods . fml . common . registry . GameRegistry . Type ; <nl> + import cpw . mods . fml . common . registry . ItemStackHolderInjector ; <nl> import cpw . mods . fml . common . registry . ObjectHolderRegistry ; <nl> import cpw . mods . fml . common . toposort . ModSorter ; <nl> import cpw . mods . fml . common . toposort . ModSortingException ; <nl> @ @ - 530 , 8 + 531 , 10 @ @ public class Loader <nl> return ; <nl> } <nl> ObjectHolderRegistry . INSTANCE . findObjectHolders ( discoverer . getASMTable ( ) ) ; <nl> + ItemStackHolderInjector . INSTANCE . findHolders ( discoverer . getASMTable ( ) ) ; <nl> modController . distributeStateMessage ( LoaderState . PREINITIALIZATION , discoverer . getASMTable ( ) , canonicalConfigDir ) ; <nl> ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; <nl> + ItemStackHolderInjector . INSTANCE . inject ( ) ; <nl> modController . transition ( LoaderState . INITIALIZATION , false ) ; <nl> progressBar . step ( " Initializing Minecraft Engine " ) ; <nl> } <nl> @ @ - 714 , 6 + 717 , 7 @ @ public class Loader <nl> progressBar . step ( " Initializing mods Phase 3 " ) ; <nl> modController . transition ( LoaderState . POSTINITIALIZATION , false ) ; <nl> modController . distributeStateMessage ( FMLInterModComms . IMCEvent . class ) ; <nl> + ItemStackHolderInjector . INSTANCE . inject ( ) ; <nl> modController . distributeStateMessage ( LoaderState . POSTINITIALIZATION ) ; <nl> progressBar . step ( " Finishing up " ) ; <nl> modController . transition ( LoaderState . AVAILABLE , false ) ; <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> index 62c45bf . . 4b84fe3 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> @ @ - 32 , 6 + 32 , 10 @ @ import net . minecraft . item . ItemStack ; <nl> import net . minecraft . item . crafting . CraftingManager ; <nl> import net . minecraft . item . crafting . FurnaceRecipes ; <nl> import net . minecraft . item . crafting . IRecipe ; <nl> + import net . minecraft . nbt . JsonToNBT ; <nl> + import net . minecraft . nbt . NBTBase ; <nl> + import net . minecraft . nbt . NBTException ; <nl> + import net . minecraft . nbt . NBTTagCompound ; <nl> import net . minecraft . tileentity . TileEntity ; <nl> import net . minecraft . world . World ; <nl> import net . minecraft . world . chunk . IChunkProvider ; <nl> @ @ - 39 , 6 + 43 , 8 @ @ import net . minecraft . world . chunk . IChunkProvider ; <nl> import org . apache . logging . log4j . Level ; <nl> <nl> import com . google . common . base . Objects ; <nl> + import com . google . common . base . Strings ; <nl> + import com . google . common . base . Throwables ; <nl> import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . Lists ; <nl> import com . google . common . collect . Maps ; <nl> @ @ - 476 , 4 + 482 , 70 @ @ public class GameRegistry <nl> * / <nl> String value ( ) ; <nl> } <nl> + <nl> + @ Retention ( RetentionPolicy . RUNTIME ) <nl> + @ Target ( ElementType . FIELD ) <nl> + public @ interface ItemStackHolder <nl> + { <nl> + / * * <nl> + * The registry name of the item being looked up . <nl> + * @ return The registry name <nl> + * / <nl> + public String value ( ) ; <nl> + <nl> + / * * <nl> + * The metadata or damage value for the itemstack , defaults to 0 . <nl> + * @ return the metadata value <nl> + * / <nl> + public int meta ( ) default 0 ; <nl> + <nl> + / * * <nl> + * The string serialized nbt value for the itemstack . Defaults to empty for no nbt . <nl> + * <nl> + * @ return a nbt string <nl> + * / <nl> + public String nbt ( ) default " " ; <nl> + } <nl> + <nl> + / * * <nl> + * Makes an { @ link ItemStack } based on the itemName reference , with supplied meta , stackSize and nbt , if possible <nl> + * <nl> + * Will return null if the item doesn ' t exist ( because it ' s not from a loaded mod for example ) <nl> + * Will throw a { @ link RuntimeException } if the nbtString is invalid for use in an { @ link ItemStack } <nl> + * <nl> + * @ param itemName a registry name reference <nl> + * @ param meta the meta <nl> + * @ param stackSize the stack size <nl> + * @ param nbtString an nbt stack as a string , will be processed by { @ link JsonToNBT } <nl> + * @ return a new itemstack <nl> + * / <nl> + public static ItemStack makeItemStack ( String itemName , int meta , int stackSize , String nbtString ) <nl> + { <nl> + if ( itemName = = null ) throw new IllegalArgumentException ( " The itemName cannot be null " ) ; <nl> + Item item = GameData . getItemRegistry ( ) . getObject ( itemName ) ; <nl> + if ( item = = null ) { <nl> + FMLLog . getLogger ( ) . log ( Level . TRACE , " Unable to find item with name { } " , itemName ) ; <nl> + return null ; <nl> + } <nl> + ItemStack is = new ItemStack ( item , 1 , meta ) ; <nl> + if ( ! Strings . isNullOrEmpty ( nbtString ) ) { <nl> + NBTBase nbttag = null ; <nl> + try <nl> + { <nl> + nbttag = JsonToNBT . func _ 150315 _ a ( nbtString ) ; <nl> + } catch ( NBTException e ) <nl> + { <nl> + FMLLog . getLogger ( ) . log ( Level . WARN , " Encountered an exception parsing ItemStack NBT string { } " , nbtString , e ) ; <nl> + throw Throwables . propagate ( e ) ; <nl> + } <nl> + if ( ! ( nbttag instanceof NBTTagCompound ) ) { <nl> + FMLLog . getLogger ( ) . log ( Level . WARN , " Unexpected NBT string - multiple values { } " , nbtString ) ; <nl> + throw new RuntimeException ( " Invalid NBT JSON " ) ; <nl> + } else { <nl> + is . setTagCompound ( ( NBTTagCompound ) nbttag ) ; <nl> + } <nl> + } <nl> + return is ; <nl> + } <nl> + <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderInjector . java b / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderInjector . java <nl> new file mode 100644 <nl> index 0000000 . . fe8b47e <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderInjector . java <nl> @ @ - 0 , 0 + 1 , 80 @ @ <nl> + package cpw . mods . fml . common . registry ; <nl> + <nl> + import java . lang . reflect . Field ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + <nl> + import org . apache . logging . log4j . Level ; <nl> + <nl> + import com . google . common . base . Throwables ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Maps ; <nl> + <nl> + import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . common . discovery . ASMDataTable ; <nl> + import cpw . mods . fml . common . discovery . ASMDataTable . ASMData ; <nl> + <nl> + public enum ItemStackHolderInjector <nl> + { <nl> + INSTANCE ; <nl> + <nl> + private List < ItemStackHolderRef > itemStackHolders = Lists . newArrayList ( ) ; <nl> + <nl> + public void inject ( ) { <nl> + FMLLog . getLogger ( ) . log ( Level . INFO , " Injecting itemstacks " ) ; <nl> + for ( ItemStackHolderRef ishr : itemStackHolders ) { <nl> + ishr . apply ( ) ; <nl> + } <nl> + FMLLog . getLogger ( ) . log ( Level . INFO , " Itemstack injection complete " ) ; <nl> + } <nl> + <nl> + public void findHolders ( ASMDataTable table ) { <nl> + FMLLog . info ( " Identifying ItemStackHolder annotations " ) ; <nl> + Set < ASMData > allItemStackHolders = table . getAll ( GameRegistry . ItemStackHolder . class . getName ( ) ) ; <nl> + Map < String , Class < ? > > classCache = Maps . newHashMap ( ) ; <nl> + for ( ASMData data : allItemStackHolders ) <nl> + { <nl> + String className = data . getClassName ( ) ; <nl> + String annotationTarget = data . getObjectName ( ) ; <nl> + String value = ( String ) data . getAnnotationInfo ( ) . get ( " value " ) ; <nl> + int meta = data . getAnnotationInfo ( ) . containsKey ( " meta " ) ? ( Integer ) data . getAnnotationInfo ( ) . get ( " meta " ) : 0 ; <nl> + String nbt = data . getAnnotationInfo ( ) . containsKey ( " nbt " ) ? ( String ) data . getAnnotationInfo ( ) . get ( " nbt " ) : " " ; <nl> + addHolder ( classCache , className , annotationTarget , value , meta , nbt ) ; <nl> + } <nl> + FMLLog . info ( " Found % d ItemStackHolder annotations " , allItemStackHolders . size ( ) ) ; <nl> + <nl> + } <nl> + <nl> + private void addHolder ( Map < String , Class < ? > > classCache , String className , String annotationTarget , String value , Integer meta , String nbt ) <nl> + { <nl> + Class < ? > clazz ; <nl> + if ( classCache . containsKey ( className ) ) <nl> + { <nl> + clazz = classCache . get ( className ) ; <nl> + } <nl> + else <nl> + { <nl> + try <nl> + { <nl> + clazz = Class . forName ( className , true , getClass ( ) . getClassLoader ( ) ) ; <nl> + classCache . put ( className , clazz ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + / / unpossible ? <nl> + throw Throwables . propagate ( ex ) ; <nl> + } <nl> + } <nl> + try <nl> + { <nl> + Field f = clazz . getField ( annotationTarget ) ; <nl> + itemStackHolders . add ( new ItemStackHolderRef ( f , value , meta , nbt ) ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + / / unpossible ? <nl> + throw Throwables . propagate ( ex ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderRef . java b / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderRef . java <nl> new file mode 100644 <nl> index 0000000 . . 18f9adc <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderRef . java <nl> @ @ - 0 , 0 + 1 , 84 @ @ <nl> + package cpw . mods . fml . common . registry ; <nl> + <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . Method ; <nl> + import java . lang . reflect . Modifier ; <nl> + <nl> + import net . minecraft . item . ItemStack ; <nl> + <nl> + import org . apache . logging . log4j . Level ; <nl> + <nl> + import com . google . common . base . Throwables ; <nl> + <nl> + import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . common . registry . GameRegistry . ItemStackHolder ; <nl> + <nl> + <nl> + / * * <nl> + * Internal class used in tracking { @ link ItemStackHolder } references <nl> + * <nl> + * @ author cpw <nl> + * <nl> + * / <nl> + class ItemStackHolderRef { <nl> + private Field field ; <nl> + private String itemName ; <nl> + private int meta ; <nl> + private String serializednbt ; <nl> + <nl> + <nl> + ItemStackHolderRef ( Field field , String itemName , int meta , String serializednbt ) <nl> + { <nl> + this . field = field ; <nl> + this . itemName = itemName ; <nl> + this . meta = meta ; <nl> + this . serializednbt = serializednbt ; <nl> + makeWritable ( field ) ; <nl> + } <nl> + <nl> + private static Field modifiersField ; <nl> + private static Object reflectionFactory ; <nl> + private static Method newFieldAccessor ; <nl> + private static Method fieldAccessorSet ; <nl> + private static void makeWritable ( Field f ) <nl> + { <nl> + try <nl> + { <nl> + if ( modifiersField = = null ) <nl> + { <nl> + Method getReflectionFactory = Class . forName ( " sun . reflect . ReflectionFactory " ) . getDeclaredMethod ( " getReflectionFactory " ) ; <nl> + reflectionFactory = getReflectionFactory . invoke ( null ) ; <nl> + newFieldAccessor = Class . forName ( " sun . reflect . ReflectionFactory " ) . getDeclaredMethod ( " newFieldAccessor " , Field . class , boolean . class ) ; <nl> + fieldAccessorSet = Class . forName ( " sun . reflect . FieldAccessor " ) . getDeclaredMethod ( " set " , Object . class , Object . class ) ; <nl> + modifiersField = Field . class . getDeclaredField ( " modifiers " ) ; <nl> + modifiersField . setAccessible ( true ) ; <nl> + } <nl> + modifiersField . setInt ( f , f . getModifiers ( ) & ~ Modifier . FINAL ) ; <nl> + } catch ( Exception e ) <nl> + { <nl> + throw Throwables . propagate ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public void apply ( ) <nl> + { <nl> + ItemStack is ; <nl> + try <nl> + { <nl> + is = GameRegistry . makeItemStack ( itemName , meta , 1 , serializednbt ) ; <nl> + } catch ( RuntimeException e ) <nl> + { <nl> + FMLLog . getLogger ( ) . log ( Level . ERROR , " Caught exception processing itemstack { } , { } , { } in annotation at { } . { } " , itemName , meta , serializednbt , field . getClass ( ) . getName ( ) , field . getName ( ) ) ; <nl> + throw e ; <nl> + } <nl> + try <nl> + { <nl> + Object fieldAccessor = newFieldAccessor . invoke ( reflectionFactory , field , false ) ; <nl> + fieldAccessorSet . invoke ( fieldAccessor , null , is ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + FMLLog . getLogger ( ) . log ( Level . WARN , " Unable to set { } with value { } , { } , { } " , this . field , this . itemName , this . meta , this . serializednbt ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / Loader . java b / fml / src / main / java / cpw / mods / fml / common / Loader . java <nl> index f59c841 . . 375ba08 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / Loader . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / Loader . java <nl> @ @ - 62 , 6 + 62 , 7 @ @ import cpw . mods . fml . common . functions . ArtifactVersionNameFunction ; <nl> import cpw . mods . fml . common . functions . ModIdFunction ; <nl> import cpw . mods . fml . common . registry . GameData ; <nl> import cpw . mods . fml . common . registry . GameRegistry . Type ; <nl> + import cpw . mods . fml . common . registry . ObjectHolderRegistry ; <nl> import cpw . mods . fml . common . toposort . ModSorter ; <nl> import cpw . mods . fml . common . toposort . ModSortingException ; <nl> import cpw . mods . fml . common . toposort . ModSortingException . SortingExceptionData ; <nl> @ @ - 502 , 12 + 503 , 14 @ @ public class Loader <nl> <nl> public void preinitializeMods ( ) <nl> { <nl> + ObjectHolderRegistry . INSTANCE . findObjectHolders ( discoverer . getASMTable ( ) ) ; <nl> if ( ! modController . isInState ( LoaderState . PREINITIALIZATION ) ) <nl> { <nl> FMLLog . warning ( " There were errors previously . Not beginning mod initialization phase " ) ; <nl> return ; <nl> } <nl> modController . distributeStateMessage ( LoaderState . PREINITIALIZATION , discoverer . getASMTable ( ) , canonicalConfigDir ) ; <nl> + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; <nl> modController . transition ( LoaderState . INITIALIZATION , false ) ; <nl> } <nl> <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> index 79d92d7 . . d253fd0 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> @ @ - 530 , 6 + 530 , 8 @ @ public class GameData { <nl> getMain ( ) . iBlockRegistry . dump ( ) ; <nl> getMain ( ) . iItemRegistry . dump ( ) ; <nl> Loader . instance ( ) . fireRemapEvent ( remaps ) ; <nl> + / / The id map changed , ensure we apply object holders <nl> + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; <nl> return ImmutableList . of ( ) ; <nl> } <nl> <nl> @ @ - 664 , 6 + 666 , 8 @ @ public class GameData { <nl> <nl> getMain ( ) . set ( frozen ) ; <nl> } <nl> + / / the id mapping has reverted , ensure we sync up the object holders <nl> + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; <nl> } <nl> <nl> protected static boolean isFrozen ( FMLControlledNamespacedRegistry < ? > registry ) <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> index da0352d . . dfd90f6 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> @ @ - 12 , 6 + 12 , 10 @ @ <nl> <nl> package cpw . mods . fml . common . registry ; <nl> <nl> + import java . lang . annotation . ElementType ; <nl> + import java . lang . annotation . Retention ; <nl> + import java . lang . annotation . RetentionPolicy ; <nl> + import java . lang . annotation . Target ; <nl> import java . lang . reflect . Constructor ; <nl> import java . util . ArrayList ; <nl> import java . util . Collections ; <nl> @ @ - 424 , 4 + 428 , 24 @ @ public class GameRegistry <nl> return GameData . getUniqueName ( item ) ; <nl> } <nl> <nl> + <nl> + <nl> + / * * <nl> + * This will cause runtime injection of public static final fields to occur at various points <nl> + * where mod blocks and items < em > could < / em > be subject to change . This allows for dynamic <nl> + * substitution to occur . <nl> + * <nl> + * / <nl> + @ Retention ( RetentionPolicy . RUNTIME ) <nl> + @ Target ( { ElementType . TYPE , ElementType . FIELD } ) <nl> + public @ interface ObjectHolder { <nl> + / * * <nl> + * If used on a class , this represents a modid only . <nl> + * If used on a field , it represents a name , which can be abbreviated or complete . <nl> + * Abbreviated names derive their modid from an enclosing ObjectHolder at the class level . <nl> + * <nl> + * @ return either a modid or a name based on the rules above <nl> + * / <nl> + String value ( ) ; <nl> + } <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRef . java b / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRef . java <nl> new file mode 100644 <nl> index 0000000 . . 65e2082 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRef . java <nl> @ @ - 0 , 0 + 1 , 101 @ @ <nl> + package cpw . mods . fml . common . registry ; <nl> + <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . Method ; <nl> + import java . lang . reflect . Modifier ; <nl> + import org . apache . logging . log4j . Level ; <nl> + import com . google . common . base . Throwables ; <nl> + import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . common . registry . GameRegistry . ObjectHolder ; <nl> + import net . minecraft . block . Block ; <nl> + import net . minecraft . item . Item ; <nl> + <nl> + <nl> + / * * <nl> + * Internal class used in tracking { @ link ObjectHolder } references <nl> + * <nl> + * @ author cpw <nl> + * <nl> + * / <nl> + class ObjectHolderRef { <nl> + private Field field ; <nl> + private String injectedObject ; <nl> + private boolean isBlock ; <nl> + private boolean isItem ; <nl> + <nl> + <nl> + ObjectHolderRef ( Field field , String injectedObject , boolean extractFromExistingValues ) <nl> + { <nl> + this . field = field ; <nl> + this . isBlock = Block . class . isAssignableFrom ( field . getType ( ) ) ; <nl> + this . isItem = Item . class . isAssignableFrom ( field . getType ( ) ) ; <nl> + if ( extractFromExistingValues ) <nl> + { <nl> + try <nl> + { <nl> + Object existing = field . get ( null ) ; <nl> + this . injectedObject = isBlock ? GameData . getBlockRegistry ( ) . getNameForObject ( existing ) : <nl> + isItem ? GameData . getItemRegistry ( ) . getNameForObject ( existing ) : null ; <nl> + } catch ( Exception e ) <nl> + { <nl> + throw Throwables . propagate ( e ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + this . injectedObject = injectedObject ; <nl> + } <nl> + <nl> + if ( this . injectedObject = = null | | ! isValid ( ) ) <nl> + { <nl> + throw new IllegalStateException ( " The ObjectHolder annotation cannot apply to a field that is not an Item or Block " ) ; <nl> + } <nl> + makeWritable ( field ) ; <nl> + } <nl> + <nl> + private static Field modifiersField ; <nl> + private static Object reflectionFactory ; <nl> + private static Method newFieldAccessor ; <nl> + private static Method fieldAccessorSet ; <nl> + private static void makeWritable ( Field f ) <nl> + { <nl> + try <nl> + { <nl> + if ( modifiersField = = null ) <nl> + { <nl> + Method getReflectionFactory = Class . forName ( " sun . reflect . ReflectionFactory " ) . getDeclaredMethod ( " getReflectionFactory " ) ; <nl> + reflectionFactory = getReflectionFactory . invoke ( null ) ; <nl> + newFieldAccessor = Class . forName ( " sun . reflect . ReflectionFactory " ) . getDeclaredMethod ( " newFieldAccessor " , Field . class , boolean . class ) ; <nl> + fieldAccessorSet = Class . forName ( " sun . reflect . FieldAccessor " ) . getDeclaredMethod ( " set " , Object . class , Object . class ) ; <nl> + modifiersField = Field . class . getDeclaredField ( " modifiers " ) ; <nl> + modifiersField . setAccessible ( true ) ; <nl> + } <nl> + modifiersField . setInt ( f , f . getModifiers ( ) & ~ Modifier . FINAL ) ; <nl> + } catch ( Exception e ) <nl> + { <nl> + throw Throwables . propagate ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public boolean isValid ( ) <nl> + { <nl> + return isBlock | | isItem ; <nl> + } <nl> + public void apply ( ) <nl> + { <nl> + Object thing ; <nl> + if ( isBlock ) <nl> + thing = GameData . getBlockRegistry ( ) . getObject ( injectedObject ) ; <nl> + else <nl> + thing = GameData . getItemRegistry ( ) . getObject ( injectedObject ) ; <nl> + try <nl> + { <nl> + Object fieldAccessor = newFieldAccessor . invoke ( reflectionFactory , field , false ) ; <nl> + fieldAccessorSet . invoke ( fieldAccessor , null , thing ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + FMLLog . log ( Level . WARN , e , " Unable to set % s with value % s ( % s ) " , this . field , thing , this . injectedObject ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRegistry . java <nl> new file mode 100644 <nl> index 0000000 . . d4dbb0c <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRegistry . java <nl> @ @ - 0 , 0 + 1 , 123 @ @ <nl> + package cpw . mods . fml . common . registry ; <nl> + <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . Modifier ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + import com . google . common . base . Throwables ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Maps ; <nl> + import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . common . discovery . ASMDataTable ; <nl> + import cpw . mods . fml . common . discovery . ASMDataTable . ASMData ; <nl> + import cpw . mods . fml . common . registry . GameRegistry . ObjectHolder ; <nl> + <nl> + / * * <nl> + * Internal registry for tracking { @ link ObjectHolder } references <nl> + * @ author cpw <nl> + * <nl> + * / <nl> + public enum ObjectHolderRegistry { <nl> + INSTANCE ; <nl> + private List < ObjectHolderRef > objectHolders = Lists . newArrayList ( ) ; <nl> + <nl> + public void findObjectHolders ( ASMDataTable table ) <nl> + { <nl> + FMLLog . info ( " Processing ObjectHolder annotations " ) ; <nl> + Set < ASMData > allObjectHolders = table . getAll ( GameRegistry . ObjectHolder . class . getName ( ) ) ; <nl> + Map < String , String > classModIds = Maps . newHashMap ( ) ; <nl> + Map < String , Class < ? > > classCache = Maps . newHashMap ( ) ; <nl> + for ( ASMData data : allObjectHolders ) <nl> + { <nl> + String className = data . getClassName ( ) ; <nl> + String annotationTarget = data . getObjectName ( ) ; <nl> + String value = ( String ) data . getAnnotationInfo ( ) . get ( " value " ) ; <nl> + boolean isClass = className . equals ( annotationTarget ) ; <nl> + scanTarget ( classModIds , classCache , className , annotationTarget , value , isClass , false ) ; <nl> + } <nl> + scanTarget ( classModIds , classCache , " net . minecraft . init . Blocks " , null , " minecraft " , true , true ) ; <nl> + scanTarget ( classModIds , classCache , " net . minecraft . init . Items " , null , " minecraft " , true , true ) ; <nl> + FMLLog . info ( " Found % d ObjectHolder annotations " , objectHolders . size ( ) ) ; <nl> + } <nl> + <nl> + private void scanTarget ( Map < String , String > classModIds , Map < String , Class < ? > > classCache , String className , String annotationTarget , String value , boolean isClass , boolean extractFromValue ) <nl> + { <nl> + Class < ? > clazz ; <nl> + if ( classCache . containsKey ( className ) ) <nl> + { <nl> + clazz = classCache . get ( className ) ; <nl> + } <nl> + else <nl> + { <nl> + try <nl> + { <nl> + clazz = Class . forName ( className , true , getClass ( ) . getClassLoader ( ) ) ; <nl> + classCache . put ( className , clazz ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + / / unpossible ? <nl> + throw Throwables . propagate ( ex ) ; <nl> + } <nl> + } <nl> + if ( isClass ) <nl> + { <nl> + scanClassForFields ( classModIds , className , value , clazz , extractFromValue ) ; <nl> + } <nl> + else <nl> + { <nl> + if ( value . indexOf ( ' : ' ) = = - 1 ) <nl> + { <nl> + String prefix = classModIds . get ( className ) ; <nl> + if ( prefix = = null ) <nl> + { <nl> + FMLLog . warning ( " Found an unqualified ObjectHolder annotation ( % s ) without a modid context at % s . % s , ignoring " , value , className , annotationTarget ) ; <nl> + throw new IllegalStateException ( " Unqualified reference to ObjectHolder " ) ; <nl> + } <nl> + value = prefix + " : " + value ; <nl> + } <nl> + try <nl> + { <nl> + Field f = clazz . getField ( annotationTarget ) ; <nl> + addHolderReference ( new ObjectHolderRef ( f , value , extractFromValue ) ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + / / unpossible ? <nl> + throw Throwables . propagate ( ex ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void scanClassForFields ( Map < String , String > classModIds , String className , String value , Class < ? > clazz , boolean extractFromExistingValues ) <nl> + { <nl> + classModIds . put ( className , value ) ; <nl> + for ( Field f : clazz . getFields ( ) ) <nl> + { <nl> + int mods = f . getModifiers ( ) ; <nl> + boolean isMatch = Modifier . isPublic ( mods ) & & Modifier . isStatic ( mods ) & & Modifier . isFinal ( mods ) ; <nl> + if ( ! isMatch | | f . isAnnotationPresent ( ObjectHolder . class ) ) <nl> + { <nl> + continue ; <nl> + } <nl> + addHolderReference ( new ObjectHolderRef ( f , value + " : " + f . getName ( ) , extractFromExistingValues ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void addHolderReference ( ObjectHolderRef ref ) <nl> + { <nl> + objectHolders . add ( ref ) ; <nl> + } <nl> + <nl> + public void applyObjectHolders ( ) <nl> + { <nl> + FMLLog . info ( " Applying holder lookups " ) ; <nl> + for ( ObjectHolderRef ohr : objectHolders ) <nl> + { <nl> + ohr . apply ( ) ; <nl> + } <nl> + FMLLog . info ( " Holder lookups applied " ) ; <nl> + } <nl> + <nl> + }

TEST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / Loader . java b / fml / src / main / java / cpw / mods / fml / common / Loader . java 
 index 006af1b . . 4de8f74 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / Loader . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / Loader . java 
 @ @ - 75 , 6 + 75 , 7 @ @ import cpw . mods . fml . common . functions . ArtifactVersionNameFunction ; 
 import cpw . mods . fml . common . functions . ModIdFunction ; 
 import cpw . mods . fml . common . registry . GameData ; 
 import cpw . mods . fml . common . registry . GameRegistry . Type ; 
 + import cpw . mods . fml . common . registry . ItemStackHolderInjector ; 
 import cpw . mods . fml . common . registry . ObjectHolderRegistry ; 
 import cpw . mods . fml . common . toposort . ModSorter ; 
 import cpw . mods . fml . common . toposort . ModSortingException ; 
 @ @ - 530 , 8 + 531 , 10 @ @ public class Loader 
 return ; 
 } 
 ObjectHolderRegistry . INSTANCE . findObjectHolders ( discoverer . getASMTable ( ) ) ; 
 + ItemStackHolderInjector . INSTANCE . findHolders ( discoverer . getASMTable ( ) ) ; 
 modController . distributeStateMessage ( LoaderState . PREINITIALIZATION , discoverer . getASMTable ( ) , canonicalConfigDir ) ; 
 ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; 
 + ItemStackHolderInjector . INSTANCE . inject ( ) ; 
 modController . transition ( LoaderState . INITIALIZATION , false ) ; 
 progressBar . step ( " Initializing Minecraft Engine " ) ; 
 } 
 @ @ - 714 , 6 + 717 , 7 @ @ public class Loader 
 progressBar . step ( " Initializing mods Phase 3 " ) ; 
 modController . transition ( LoaderState . POSTINITIALIZATION , false ) ; 
 modController . distributeStateMessage ( FMLInterModComms . IMCEvent . class ) ; 
 + ItemStackHolderInjector . INSTANCE . inject ( ) ; 
 modController . distributeStateMessage ( LoaderState . POSTINITIALIZATION ) ; 
 progressBar . step ( " Finishing up " ) ; 
 modController . transition ( LoaderState . AVAILABLE , false ) ; 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 index 62c45bf . . 4b84fe3 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 @ @ - 32 , 6 + 32 , 10 @ @ import net . minecraft . item . ItemStack ; 
 import net . minecraft . item . crafting . CraftingManager ; 
 import net . minecraft . item . crafting . FurnaceRecipes ; 
 import net . minecraft . item . crafting . IRecipe ; 
 + import net . minecraft . nbt . JsonToNBT ; 
 + import net . minecraft . nbt . NBTBase ; 
 + import net . minecraft . nbt . NBTException ; 
 + import net . minecraft . nbt . NBTTagCompound ; 
 import net . minecraft . tileentity . TileEntity ; 
 import net . minecraft . world . World ; 
 import net . minecraft . world . chunk . IChunkProvider ; 
 @ @ - 39 , 6 + 43 , 8 @ @ import net . minecraft . world . chunk . IChunkProvider ; 
 import org . apache . logging . log4j . Level ; 
 
 import com . google . common . base . Objects ; 
 + import com . google . common . base . Strings ; 
 + import com . google . common . base . Throwables ; 
 import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . Lists ; 
 import com . google . common . collect . Maps ; 
 @ @ - 476 , 4 + 482 , 70 @ @ public class GameRegistry 
 * / 
 String value ( ) ; 
 } 
 + 
 + @ Retention ( RetentionPolicy . RUNTIME ) 
 + @ Target ( ElementType . FIELD ) 
 + public @ interface ItemStackHolder 
 + { 
 + / * * 
 + * The registry name of the item being looked up . 
 + * @ return The registry name 
 + * / 
 + public String value ( ) ; 
 + 
 + / * * 
 + * The metadata or damage value for the itemstack , defaults to 0 . 
 + * @ return the metadata value 
 + * / 
 + public int meta ( ) default 0 ; 
 + 
 + / * * 
 + * The string serialized nbt value for the itemstack . Defaults to empty for no nbt . 
 + * 
 + * @ return a nbt string 
 + * / 
 + public String nbt ( ) default " " ; 
 + } 
 + 
 + / * * 
 + * Makes an { @ link ItemStack } based on the itemName reference , with supplied meta , stackSize and nbt , if possible 
 + * 
 + * Will return null if the item doesn ' t exist ( because it ' s not from a loaded mod for example ) 
 + * Will throw a { @ link RuntimeException } if the nbtString is invalid for use in an { @ link ItemStack } 
 + * 
 + * @ param itemName a registry name reference 
 + * @ param meta the meta 
 + * @ param stackSize the stack size 
 + * @ param nbtString an nbt stack as a string , will be processed by { @ link JsonToNBT } 
 + * @ return a new itemstack 
 + * / 
 + public static ItemStack makeItemStack ( String itemName , int meta , int stackSize , String nbtString ) 
 + { 
 + if ( itemName = = null ) throw new IllegalArgumentException ( " The itemName cannot be null " ) ; 
 + Item item = GameData . getItemRegistry ( ) . getObject ( itemName ) ; 
 + if ( item = = null ) { 
 + FMLLog . getLogger ( ) . log ( Level . TRACE , " Unable to find item with name { } " , itemName ) ; 
 + return null ; 
 + } 
 + ItemStack is = new ItemStack ( item , 1 , meta ) ; 
 + if ( ! Strings . isNullOrEmpty ( nbtString ) ) { 
 + NBTBase nbttag = null ; 
 + try 
 + { 
 + nbttag = JsonToNBT . func _ 150315 _ a ( nbtString ) ; 
 + } catch ( NBTException e ) 
 + { 
 + FMLLog . getLogger ( ) . log ( Level . WARN , " Encountered an exception parsing ItemStack NBT string { } " , nbtString , e ) ; 
 + throw Throwables . propagate ( e ) ; 
 + } 
 + if ( ! ( nbttag instanceof NBTTagCompound ) ) { 
 + FMLLog . getLogger ( ) . log ( Level . WARN , " Unexpected NBT string - multiple values { } " , nbtString ) ; 
 + throw new RuntimeException ( " Invalid NBT JSON " ) ; 
 + } else { 
 + is . setTagCompound ( ( NBTTagCompound ) nbttag ) ; 
 + } 
 + } 
 + return is ; 
 + } 
 + 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderInjector . java b / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderInjector . java 
 new file mode 100644 
 index 0000000 . . fe8b47e 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderInjector . java 
 @ @ - 0 , 0 + 1 , 80 @ @ 
 + package cpw . mods . fml . common . registry ; 
 + 
 + import java . lang . reflect . Field ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + 
 + import org . apache . logging . log4j . Level ; 
 + 
 + import com . google . common . base . Throwables ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Maps ; 
 + 
 + import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . common . discovery . ASMDataTable ; 
 + import cpw . mods . fml . common . discovery . ASMDataTable . ASMData ; 
 + 
 + public enum ItemStackHolderInjector 
 + { 
 + INSTANCE ; 
 + 
 + private List < ItemStackHolderRef > itemStackHolders = Lists . newArrayList ( ) ; 
 + 
 + public void inject ( ) { 
 + FMLLog . getLogger ( ) . log ( Level . INFO , " Injecting itemstacks " ) ; 
 + for ( ItemStackHolderRef ishr : itemStackHolders ) { 
 + ishr . apply ( ) ; 
 + } 
 + FMLLog . getLogger ( ) . log ( Level . INFO , " Itemstack injection complete " ) ; 
 + } 
 + 
 + public void findHolders ( ASMDataTable table ) { 
 + FMLLog . info ( " Identifying ItemStackHolder annotations " ) ; 
 + Set < ASMData > allItemStackHolders = table . getAll ( GameRegistry . ItemStackHolder . class . getName ( ) ) ; 
 + Map < String , Class < ? > > classCache = Maps . newHashMap ( ) ; 
 + for ( ASMData data : allItemStackHolders ) 
 + { 
 + String className = data . getClassName ( ) ; 
 + String annotationTarget = data . getObjectName ( ) ; 
 + String value = ( String ) data . getAnnotationInfo ( ) . get ( " value " ) ; 
 + int meta = data . getAnnotationInfo ( ) . containsKey ( " meta " ) ? ( Integer ) data . getAnnotationInfo ( ) . get ( " meta " ) : 0 ; 
 + String nbt = data . getAnnotationInfo ( ) . containsKey ( " nbt " ) ? ( String ) data . getAnnotationInfo ( ) . get ( " nbt " ) : " " ; 
 + addHolder ( classCache , className , annotationTarget , value , meta , nbt ) ; 
 + } 
 + FMLLog . info ( " Found % d ItemStackHolder annotations " , allItemStackHolders . size ( ) ) ; 
 + 
 + } 
 + 
 + private void addHolder ( Map < String , Class < ? > > classCache , String className , String annotationTarget , String value , Integer meta , String nbt ) 
 + { 
 + Class < ? > clazz ; 
 + if ( classCache . containsKey ( className ) ) 
 + { 
 + clazz = classCache . get ( className ) ; 
 + } 
 + else 
 + { 
 + try 
 + { 
 + clazz = Class . forName ( className , true , getClass ( ) . getClassLoader ( ) ) ; 
 + classCache . put ( className , clazz ) ; 
 + } 
 + catch ( Exception ex ) 
 + { 
 + / / unpossible ? 
 + throw Throwables . propagate ( ex ) ; 
 + } 
 + } 
 + try 
 + { 
 + Field f = clazz . getField ( annotationTarget ) ; 
 + itemStackHolders . add ( new ItemStackHolderRef ( f , value , meta , nbt ) ) ; 
 + } 
 + catch ( Exception ex ) 
 + { 
 + / / unpossible ? 
 + throw Throwables . propagate ( ex ) ; 
 + } 
 + } 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderRef . java b / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderRef . java 
 new file mode 100644 
 index 0000000 . . 18f9adc 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ItemStackHolderRef . java 
 @ @ - 0 , 0 + 1 , 84 @ @ 
 + package cpw . mods . fml . common . registry ; 
 + 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . Method ; 
 + import java . lang . reflect . Modifier ; 
 + 
 + import net . minecraft . item . ItemStack ; 
 + 
 + import org . apache . logging . log4j . Level ; 
 + 
 + import com . google . common . base . Throwables ; 
 + 
 + import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . common . registry . GameRegistry . ItemStackHolder ; 
 + 
 + 
 + / * * 
 + * Internal class used in tracking { @ link ItemStackHolder } references 
 + * 
 + * @ author cpw 
 + * 
 + * / 
 + class ItemStackHolderRef { 
 + private Field field ; 
 + private String itemName ; 
 + private int meta ; 
 + private String serializednbt ; 
 + 
 + 
 + ItemStackHolderRef ( Field field , String itemName , int meta , String serializednbt ) 
 + { 
 + this . field = field ; 
 + this . itemName = itemName ; 
 + this . meta = meta ; 
 + this . serializednbt = serializednbt ; 
 + makeWritable ( field ) ; 
 + } 
 + 
 + private static Field modifiersField ; 
 + private static Object reflectionFactory ; 
 + private static Method newFieldAccessor ; 
 + private static Method fieldAccessorSet ; 
 + private static void makeWritable ( Field f ) 
 + { 
 + try 
 + { 
 + if ( modifiersField = = null ) 
 + { 
 + Method getReflectionFactory = Class . forName ( " sun . reflect . ReflectionFactory " ) . getDeclaredMethod ( " getReflectionFactory " ) ; 
 + reflectionFactory = getReflectionFactory . invoke ( null ) ; 
 + newFieldAccessor = Class . forName ( " sun . reflect . ReflectionFactory " ) . getDeclaredMethod ( " newFieldAccessor " , Field . class , boolean . class ) ; 
 + fieldAccessorSet = Class . forName ( " sun . reflect . FieldAccessor " ) . getDeclaredMethod ( " set " , Object . class , Object . class ) ; 
 + modifiersField = Field . class . getDeclaredField ( " modifiers " ) ; 
 + modifiersField . setAccessible ( true ) ; 
 + } 
 + modifiersField . setInt ( f , f . getModifiers ( ) & ~ Modifier . FINAL ) ; 
 + } catch ( Exception e ) 
 + { 
 + throw Throwables . propagate ( e ) ; 
 + } 
 + } 
 + 
 + public void apply ( ) 
 + { 
 + ItemStack is ; 
 + try 
 + { 
 + is = GameRegistry . makeItemStack ( itemName , meta , 1 , serializednbt ) ; 
 + } catch ( RuntimeException e ) 
 + { 
 + FMLLog . getLogger ( ) . log ( Level . ERROR , " Caught exception processing itemstack { } , { } , { } in annotation at { } . { } " , itemName , meta , serializednbt , field . getClass ( ) . getName ( ) , field . getName ( ) ) ; 
 + throw e ; 
 + } 
 + try 
 + { 
 + Object fieldAccessor = newFieldAccessor . invoke ( reflectionFactory , field , false ) ; 
 + fieldAccessorSet . invoke ( fieldAccessor , null , is ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + FMLLog . getLogger ( ) . log ( Level . WARN , " Unable to set { } with value { } , { } , { } " , this . field , this . itemName , this . meta , this . serializednbt ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / Loader . java b / fml / src / main / java / cpw / mods / fml / common / Loader . java 
 index f59c841 . . 375ba08 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / Loader . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / Loader . java 
 @ @ - 62 , 6 + 62 , 7 @ @ import cpw . mods . fml . common . functions . ArtifactVersionNameFunction ; 
 import cpw . mods . fml . common . functions . ModIdFunction ; 
 import cpw . mods . fml . common . registry . GameData ; 
 import cpw . mods . fml . common . registry . GameRegistry . Type ; 
 + import cpw . mods . fml . common . registry . ObjectHolderRegistry ; 
 import cpw . mods . fml . common . toposort . ModSorter ; 
 import cpw . mods . fml . common . toposort . ModSortingException ; 
 import cpw . mods . fml . common . toposort . ModSortingException . SortingExceptionData ; 
 @ @ - 502 , 12 + 503 , 14 @ @ public class Loader 
 
 public void preinitializeMods ( ) 
 { 
 + ObjectHolderRegistry . INSTANCE . findObjectHolders ( discoverer . getASMTable ( ) ) ; 
 if ( ! modController . isInState ( LoaderState . PREINITIALIZATION ) ) 
 { 
 FMLLog . warning ( " There were errors previously . Not beginning mod initialization phase " ) ; 
 return ; 
 } 
 modController . distributeStateMessage ( LoaderState . PREINITIALIZATION , discoverer . getASMTable ( ) , canonicalConfigDir ) ; 
 + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; 
 modController . transition ( LoaderState . INITIALIZATION , false ) ; 
 } 
 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 index 79d92d7 . . d253fd0 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 @ @ - 530 , 6 + 530 , 8 @ @ public class GameData { 
 getMain ( ) . iBlockRegistry . dump ( ) ; 
 getMain ( ) . iItemRegistry . dump ( ) ; 
 Loader . instance ( ) . fireRemapEvent ( remaps ) ; 
 + / / The id map changed , ensure we apply object holders 
 + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; 
 return ImmutableList . of ( ) ; 
 } 
 
 @ @ - 664 , 6 + 666 , 8 @ @ public class GameData { 
 
 getMain ( ) . set ( frozen ) ; 
 } 
 + / / the id mapping has reverted , ensure we sync up the object holders 
 + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; 
 } 
 
 protected static boolean isFrozen ( FMLControlledNamespacedRegistry < ? > registry ) 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 index da0352d . . dfd90f6 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 @ @ - 12 , 6 + 12 , 10 @ @ 
 
 package cpw . mods . fml . common . registry ; 
 
 + import java . lang . annotation . ElementType ; 
 + import java . lang . annotation . Retention ; 
 + import java . lang . annotation . RetentionPolicy ; 
 + import java . lang . annotation . Target ; 
 import java . lang . reflect . Constructor ; 
 import java . util . ArrayList ; 
 import java . util . Collections ; 
 @ @ - 424 , 4 + 428 , 24 @ @ public class GameRegistry 
 return GameData . getUniqueName ( item ) ; 
 } 
 
 + 
 + 
 + / * * 
 + * This will cause runtime injection of public static final fields to occur at various points 
 + * where mod blocks and items < em > could < / em > be subject to change . This allows for dynamic 
 + * substitution to occur . 
 + * 
 + * / 
 + @ Retention ( RetentionPolicy . RUNTIME ) 
 + @ Target ( { ElementType . TYPE , ElementType . FIELD } ) 
 + public @ interface ObjectHolder { 
 + / * * 
 + * If used on a class , this represents a modid only . 
 + * If used on a field , it represents a name , which can be abbreviated or complete . 
 + * Abbreviated names derive their modid from an enclosing ObjectHolder at the class level . 
 + * 
 + * @ return either a modid or a name based on the rules above 
 + * / 
 + String value ( ) ; 
 + } 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRef . java b / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRef . java 
 new file mode 100644 
 index 0000000 . . 65e2082 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRef . java 
 @ @ - 0 , 0 + 1 , 101 @ @ 
 + package cpw . mods . fml . common . registry ; 
 + 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . Method ; 
 + import java . lang . reflect . Modifier ; 
 + import org . apache . logging . log4j . Level ; 
 + import com . google . common . base . Throwables ; 
 + import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . common . registry . GameRegistry . ObjectHolder ; 
 + import net . minecraft . block . Block ; 
 + import net . minecraft . item . Item ; 
 + 
 + 
 + / * * 
 + * Internal class used in tracking { @ link ObjectHolder } references 
 + * 
 + * @ author cpw 
 + * 
 + * / 
 + class ObjectHolderRef { 
 + private Field field ; 
 + private String injectedObject ; 
 + private boolean isBlock ; 
 + private boolean isItem ; 
 + 
 + 
 + ObjectHolderRef ( Field field , String injectedObject , boolean extractFromExistingValues ) 
 + { 
 + this . field = field ; 
 + this . isBlock = Block . class . isAssignableFrom ( field . getType ( ) ) ; 
 + this . isItem = Item . class . isAssignableFrom ( field . getType ( ) ) ; 
 + if ( extractFromExistingValues ) 
 + { 
 + try 
 + { 
 + Object existing = field . get ( null ) ; 
 + this . injectedObject = isBlock ? GameData . getBlockRegistry ( ) . getNameForObject ( existing ) : 
 + isItem ? GameData . getItemRegistry ( ) . getNameForObject ( existing ) : null ; 
 + } catch ( Exception e ) 
 + { 
 + throw Throwables . propagate ( e ) ; 
 + } 
 + } 
 + else 
 + { 
 + this . injectedObject = injectedObject ; 
 + } 
 + 
 + if ( this . injectedObject = = null | | ! isValid ( ) ) 
 + { 
 + throw new IllegalStateException ( " The ObjectHolder annotation cannot apply to a field that is not an Item or Block " ) ; 
 + } 
 + makeWritable ( field ) ; 
 + } 
 + 
 + private static Field modifiersField ; 
 + private static Object reflectionFactory ; 
 + private static Method newFieldAccessor ; 
 + private static Method fieldAccessorSet ; 
 + private static void makeWritable ( Field f ) 
 + { 
 + try 
 + { 
 + if ( modifiersField = = null ) 
 + { 
 + Method getReflectionFactory = Class . forName ( " sun . reflect . ReflectionFactory " ) . getDeclaredMethod ( " getReflectionFactory " ) ; 
 + reflectionFactory = getReflectionFactory . invoke ( null ) ; 
 + newFieldAccessor = Class . forName ( " sun . reflect . ReflectionFactory " ) . getDeclaredMethod ( " newFieldAccessor " , Field . class , boolean . class ) ; 
 + fieldAccessorSet = Class . forName ( " sun . reflect . FieldAccessor " ) . getDeclaredMethod ( " set " , Object . class , Object . class ) ; 
 + modifiersField = Field . class . getDeclaredField ( " modifiers " ) ; 
 + modifiersField . setAccessible ( true ) ; 
 + } 
 + modifiersField . setInt ( f , f . getModifiers ( ) & ~ Modifier . FINAL ) ; 
 + } catch ( Exception e ) 
 + { 
 + throw Throwables . propagate ( e ) ; 
 + } 
 + } 
 + 
 + public boolean isValid ( ) 
 + { 
 + return isBlock | | isItem ; 
 + } 
 + public void apply ( ) 
 + { 
 + Object thing ; 
 + if ( isBlock ) 
 + thing = GameData . getBlockRegistry ( ) . getObject ( injectedObject ) ; 
 + else 
 + thing = GameData . getItemRegistry ( ) . getObject ( injectedObject ) ; 
 + try 
 + { 
 + Object fieldAccessor = newFieldAccessor . invoke ( reflectionFactory , field , false ) ; 
 + fieldAccessorSet . invoke ( fieldAccessor , null , thing ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + FMLLog . log ( Level . WARN , e , " Unable to set % s with value % s ( % s ) " , this . field , thing , this . injectedObject ) ; 
 + } 
 + } 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRegistry . java 
 new file mode 100644 
 index 0000000 . . d4dbb0c 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ObjectHolderRegistry . java 
 @ @ - 0 , 0 + 1 , 123 @ @ 
 + package cpw . mods . fml . common . registry ; 
 + 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . Modifier ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + import com . google . common . base . Throwables ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Maps ; 
 + import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . common . discovery . ASMDataTable ; 
 + import cpw . mods . fml . common . discovery . ASMDataTable . ASMData ; 
 + import cpw . mods . fml . common . registry . GameRegistry . ObjectHolder ; 
 + 
 + / * * 
 + * Internal registry for tracking { @ link ObjectHolder } references 
 + * @ author cpw 
 + * 
 + * / 
 + public enum ObjectHolderRegistry { 
 + INSTANCE ; 
 + private List < ObjectHolderRef > objectHolders = Lists . newArrayList ( ) ; 
 + 
 + public void findObjectHolders ( ASMDataTable table ) 
 + { 
 + FMLLog . info ( " Processing ObjectHolder annotations " ) ; 
 + Set < ASMData > allObjectHolders = table . getAll ( GameRegistry . ObjectHolder . class . getName ( ) ) ; 
 + Map < String , String > classModIds = Maps . newHashMap ( ) ; 
 + Map < String , Class < ? > > classCache = Maps . newHashMap ( ) ; 
 + for ( ASMData data : allObjectHolders ) 
 + { 
 + String className = data . getClassName ( ) ; 
 + String annotationTarget = data . getObjectName ( ) ; 
 + String value = ( String ) data . getAnnotationInfo ( ) . get ( " value " ) ; 
 + boolean isClass = className . equals ( annotationTarget ) ; 
 + scanTarget ( classModIds , classCache , className , annotationTarget , value , isClass , false ) ; 
 + } 
 + scanTarget ( classModIds , classCache , " net . minecraft . init . Blocks " , null , " minecraft " , true , true ) ; 
 + scanTarget ( classModIds , classCache , " net . minecraft . init . Items " , null , " minecraft " , true , true ) ; 
 + FMLLog . info ( " Found % d ObjectHolder annotations " , objectHolders . size ( ) ) ; 
 + } 
 + 
 + private void scanTarget ( Map < String , String > classModIds , Map < String , Class < ? > > classCache , String className , String annotationTarget , String value , boolean isClass , boolean extractFromValue ) 
 + { 
 + Class < ? > clazz ; 
 + if ( classCache . containsKey ( className ) ) 
 + { 
 + clazz = classCache . get ( className ) ; 
 + } 
 + else 
 + { 
 + try 
 + { 
 + clazz = Class . forName ( className , true , getClass ( ) . getClassLoader ( ) ) ; 
 + classCache . put ( className , clazz ) ; 
 + } 
 + catch ( Exception ex ) 
 + { 
 + / / unpossible ? 
 + throw Throwables . propagate ( ex ) ; 
 + } 
 + } 
 + if ( isClass ) 
 + { 
 + scanClassForFields ( classModIds , className , value , clazz , extractFromValue ) ; 
 + } 
 + else 
 + { 
 + if ( value . indexOf ( ' : ' ) = = - 1 ) 
 + { 
 + String prefix = classModIds . get ( className ) ; 
 + if ( prefix = = null ) 
 + { 
 + FMLLog . warning ( " Found an unqualified ObjectHolder annotation ( % s ) without a modid context at % s . % s , ignoring " , value , className , annotationTarget ) ; 
 + throw new IllegalStateException ( " Unqualified reference to ObjectHolder " ) ; 
 + } 
 + value = prefix + " : " + value ; 
 + } 
 + try 
 + { 
 + Field f = clazz . getField ( annotationTarget ) ; 
 + addHolderReference ( new ObjectHolderRef ( f , value , extractFromValue ) ) ; 
 + } 
 + catch ( Exception ex ) 
 + { 
 + / / unpossible ? 
 + throw Throwables . propagate ( ex ) ; 
 + } 
 + } 
 + } 
 + 
 + private void scanClassForFields ( Map < String , String > classModIds , String className , String value , Class < ? > clazz , boolean extractFromExistingValues ) 
 + { 
 + classModIds . put ( className , value ) ; 
 + for ( Field f : clazz . getFields ( ) ) 
 + { 
 + int mods = f . getModifiers ( ) ; 
 + boolean isMatch = Modifier . isPublic ( mods ) & & Modifier . isStatic ( mods ) & & Modifier . isFinal ( mods ) ; 
 + if ( ! isMatch | | f . isAnnotationPresent ( ObjectHolder . class ) ) 
 + { 
 + continue ; 
 + } 
 + addHolderReference ( new ObjectHolderRef ( f , value + " : " + f . getName ( ) , extractFromExistingValues ) ) ; 
 + } 
 + } 
 + 
 + private void addHolderReference ( ObjectHolderRef ref ) 
 + { 
 + objectHolders . add ( ref ) ; 
 + } 
 + 
 + public void applyObjectHolders ( ) 
 + { 
 + FMLLog . info ( " Applying holder lookups " ) ; 
 + for ( ObjectHolderRef ohr : objectHolders ) 
 + { 
 + ohr . apply ( ) ; 
 + } 
 + FMLLog . info ( " Holder lookups applied " ) ; 
 + } 
 + 
 + }
