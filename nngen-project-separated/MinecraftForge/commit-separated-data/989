BLEU SCORE: 0.027611988917697356

TEST MSG: Add an EnumHelper hook and fixed an issue
GENERATED MSG: Simple chunkloading implementation

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / BiomeManager . java b / src / main / java / net / minecraftforge / common / BiomeManager . java <nl> index ee584e2 . . 1b45176 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / BiomeManager . java <nl> + + + b / src / main / java / net / minecraftforge / common / BiomeManager . java <nl> @ @ - 175 , 7 + 175 , 7 @ @ public class BiomeManager <nl> if ( t . name ( ) . equals ( name ) ) return t ; <nl> } <nl> <nl> - BiomeType ret = EnumHelper . addEnum ( BiomeType . class , name , BiomeType . class ) ; <nl> + BiomeType ret = EnumHelper . addEnum ( BiomeType . class , name , new Class [ 0 ] , new Object [ 0 ] ) ; <nl> <nl> if ( ret . ordinal ( ) > = biomes . length ) <nl> { <nl> diff - - git a / src / main / java / net / minecraftforge / common / EnumPlantType . java b / src / main / java / net / minecraftforge / common / EnumPlantType . java <nl> index 3622e6c . . 648d3dc 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / EnumPlantType . java <nl> + + + b / src / main / java / net / minecraftforge / common / EnumPlantType . java <nl> @ @ - 1 , 5 + 1 , 7 @ @ <nl> package net . minecraftforge . common ; <nl> <nl> + import net . minecraftforge . common . util . EnumHelper ; <nl> + <nl> public enum EnumPlantType <nl> { <nl> Plains , <nl> @ @ - 8 , 5 + 10 , 27 @ @ public enum EnumPlantType <nl> Cave , <nl> Water , <nl> Nether , <nl> - Crop <nl> - } <nl> \ No newline at end of file <nl> + Crop ; <nl> + <nl> + / * * <nl> + * Getting a custom { @ link EnumPlantType } , or an existing one if it has the same name as that one . Your plant should implement { @ link IPlantable } <nl> + * and return this custom type in { @ link IPlantable # getPlantType ( net . minecraft . world . IBlockAccess , net . minecraft . util . BlockPos ) } . <nl> + * <nl> + * < p > If your new plant grows on blocks like any one of them above , never create a new { @ link EnumPlantType } . <nl> + * This enumeration is only functioning in <nl> + * { @ link net . minecraft . block . Block # canSustainPlant ( net . minecraft . world . IBlockAccess , net . minecraft . util . BlockPos , net . minecraft . util . EnumFacing , IPlantable ) } , <nl> + * which you are supposed to override this function in your new block and create a new plant type to grow on that block . <nl> + * <nl> + * < p > You can create an instance of your plant type in your API and let your / others mods access it . It will be faster than calling this method . <nl> + * @ param name the name of the type of plant , you had better follow the style above <nl> + * @ return the acquired { @ EnumPlantType } , a new one if not found . <nl> + * / <nl> + public static EnumPlantType getPlantType ( String name ) <nl> + { <nl> + for ( EnumPlantType t : values ( ) ) <nl> + { <nl> + if ( t . name ( ) . equalsIgnoreCase ( name ) ) return t ; <nl> + } <nl> + return EnumHelper . addEnum ( EnumPlantType . class , name , new Class [ 0 ] , new Object [ 0 ] ) ; <nl> + } <nl> + } <nl> diff - - git a / src / test / java / net / minecraftforge / debug / EnumPlantTypeTest . java b / src / test / java / net / minecraftforge / debug / EnumPlantTypeTest . java <nl> new file mode 100644 <nl> index 0000000 . . 2f7e7aa <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / debug / EnumPlantTypeTest . java <nl> @ @ - 0 , 0 + 1 , 49 @ @ <nl> + package net . minecraftforge . debug ; <nl> + <nl> + import net . minecraftforge . common . BiomeManager . BiomeType ; <nl> + import net . minecraftforge . common . EnumPlantType ; <nl> + import net . minecraftforge . fml . common . Mod ; <nl> + import net . minecraftforge . fml . common . event . FMLInitializationEvent ; <nl> + import org . apache . logging . log4j . Logger ; <nl> + import org . apache . logging . log4j . LogManager ; <nl> + <nl> + @ Mod ( modid = " enumplanttypetest " ) <nl> + public class EnumPlantTypeTest <nl> + { <nl> + 	 private static Logger LOGGER = LogManager . getLogger ( ) ; <nl> + 	 <nl> + 	 @ Mod . EventHandler <nl> + 	 public void onInit ( FMLInitializationEvent event ) <nl> + 	 { <nl> + 	 	 BiomeType biomeType = null ; <nl> + 	 	 try <nl> + 	 	 { <nl> + 	 	 	 biomeType = BiomeType . getType ( " FAKE " ) ; <nl> + 	 	 } <nl> + 	 	 catch ( NullPointerException npe ) <nl> + 	 	 { <nl> + 	 	 	 LOGGER . warn ( " EnumHelper in BiomeType is working incorrectly ! " , npe ) ; <nl> + 	 	 } <nl> + 	 	 finally <nl> + 	 	 { <nl> + 	 	 if ( biomeType = = null | | ! biomeType . name ( ) . equals ( " FAKE " ) ) <nl> + 	 	 	 LOGGER . warn ( " EnumHelper in BiomeType is working incorrectly ! " ) ; <nl> + 	 	 } <nl> + 	 EnumPlantType plantType = null ; <nl> + 	 if ( plantType = = null | | ! plantType . name ( ) . equals ( " FAKE " ) ) <nl> + 	 	 ; <nl> + 	 try <nl> + 	 	 { <nl> + 	 	 plantType = EnumPlantType . getPlantType ( " FAKE " ) ; <nl> + 	 	 } <nl> + 	 	 catch ( NullPointerException npe ) <nl> + 	 	 { <nl> + 	 	 	 LOGGER . warn ( " EnumHelper in EnumPlantType is working incorrectly ! " , npe ) ; <nl> + 	 	 } <nl> + 	 	 finally <nl> + 	 	 { <nl> + 	 	 if ( plantType = = null | | ! plantType . name ( ) . equals ( " FAKE " ) ) <nl> + 	 	 	 LOGGER . warn ( " EnumHelper in EnumPlantType is working incorrectly ! " ) ; <nl> + 	 	 } <nl> + 	 } <nl> + }
NEAREST DIFF (one line): diff - - git a / common / net / minecraftforge / common / ForgeHooks . java b / common / net / minecraftforge / common / ForgeHooks . java <nl> index 05ca957 . . 49ba9c7 100644 <nl> - - - a / common / net / minecraftforge / common / ForgeHooks . java <nl> + + + b / common / net / minecraftforge / common / ForgeHooks . java <nl> @ @ - 1 , 8 + 1 , 13 @ @ <nl> package net . minecraftforge . common ; <nl> <nl> import java . util . * ; <nl> + import java . util . Map . Entry ; <nl> + <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> + import com . google . common . collect . ListMultimap ; <nl> <nl> import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . common . Loader ; <nl> <nl> import net . minecraft . src . * ; <nl> import net . minecraftforge . event . entity . item . ItemTossEvent ; <nl> @ @ - 354 , 4 + 359 , 55 @ @ public class ForgeHooks <nl> player . joinEntityItemWithWorld ( event . entityItem ) ; <nl> return event . entityItem ; <nl> } <nl> + public static void dumpPersistentChunks ( WorldInfo worldInfo , ListMultimap < ChunkCoordIntPair , String > persistentChunks ) <nl> + { <nl> + worldInfo . forgeWorldData = new NBTTagCompound ( ) ; <nl> + <nl> + NBTTagList chunkDataList = new NBTTagList ( ) ; <nl> + for ( Entry < ChunkCoordIntPair , Collection < String > > entry : persistentChunks . asMap ( ) . entrySet ( ) ) <nl> + { <nl> + NBTTagCompound dataList = new NBTTagCompound ( ) ; <nl> + dataList . setIntArray ( " Chunk " , new int [ ] { entry . getKey ( ) . chunkXPos , entry . getKey ( ) . chunkZPos } ) ; <nl> + NBTTagList modList = new NBTTagList ( ) ; <nl> + for ( String modId : entry . getValue ( ) ) <nl> + { <nl> + modList . appendTag ( new NBTTagString ( modId , " " ) ) ; <nl> + } <nl> + dataList . setTag ( " Mods " , modList ) ; <nl> + chunkDataList . appendTag ( dataList ) ; <nl> + } <nl> + worldInfo . forgeWorldData . setTag ( " PersistentChunks " , chunkDataList ) ; <nl> + } <nl> + <nl> + public static ListMultimap < ChunkCoordIntPair , String > loadPersistentChunkData ( WorldInfo worldInfo ) <nl> + { <nl> + ArrayListMultimap < ChunkCoordIntPair , String > chunkList = ArrayListMultimap . < ChunkCoordIntPair , String > create ( ) ; <nl> + <nl> + if ( worldInfo = = null | | worldInfo . forgeWorldData = = null ) <nl> + { <nl> + return chunkList ; <nl> + } <nl> + <nl> + NBTTagList chunkDataList = worldInfo . forgeWorldData . getTagList ( " PersistentChunks " ) ; <nl> + for ( int i = 0 ; i < chunkDataList . tagCount ( ) ; i + + ) <nl> + { <nl> + NBTTagCompound dataList = ( NBTTagCompound ) chunkDataList . tagAt ( i ) ; <nl> + int [ ] ccpairint = dataList . getIntArray ( " Chunk " ) ; <nl> + ChunkCoordIntPair ccpair = new ChunkCoordIntPair ( ccpairint [ 0 ] , ccpairint [ 1 ] ) ; <nl> + NBTTagList modList = dataList . getTagList ( " Mods " ) ; <nl> + for ( int j = 0 ; j < modList . tagCount ( ) ; j + + ) <nl> + { <nl> + String modId = modList . tagAt ( j ) . getName ( ) ; <nl> + if ( Loader . isModLoaded ( modId ) ) <nl> + { <nl> + chunkList . put ( ccpair , modId ) ; <nl> + } <nl> + else <nl> + { <nl> + FMLLog . warning ( " The mod % s is not present - it ' s chunks will not be persisted any longer " , modId ) ; <nl> + } <nl> + } <nl> + } <nl> + return chunkList ; <nl> + } <nl> } <nl> diff - - git a / common / net / minecraftforge / common / MinecraftForge . java b / common / net / minecraftforge / common / MinecraftForge . java <nl> index fe1dc83 . . 46c1388 100644 <nl> - - - a / common / net / minecraftforge / common / MinecraftForge . java <nl> + + + b / common / net / minecraftforge / common / MinecraftForge . java <nl> @ @ - 3 , 7 + 3 , 10 @ @ package net . minecraftforge . common ; <nl> import java . lang . reflect . Constructor ; <nl> import java . util . * ; <nl> <nl> + import cpw . mods . fml . common . FMLCommonHandler ; <nl> import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . common . Mod ; <nl> + import cpw . mods . fml . common . ModContainer ; <nl> <nl> import net . minecraft . src . * ; <nl> import net . minecraftforge . common . ForgeHooks . GrassEntry ; <nl> @ @ - 199 , 4 + 202 , 42 @ @ public class MinecraftForge <nl> { <nl> return " Minecraft Forge " + ForgeVersion . getVersion ( ) ; <nl> } <nl> + <nl> + / * * <nl> + * Force a chunk to remain loaded by the supplied mod <nl> + * <nl> + * @ param chunk the chunk to keep loaded <nl> + * @ param world the world holding the chunk <nl> + * @ param mod the mod ( either { @ link Mod } or { @ link BaseMod } ) that wishes to force the load <nl> + * / <nl> + public static void forceChunkLoaded ( ChunkCoordIntPair chunk , World world , Object mod ) <nl> + { <nl> + ModContainer mc = FMLCommonHandler . instance ( ) . findContainerFor ( mod ) ; <nl> + if ( mc = = null ) <nl> + { <nl> + FMLLog . warning ( " Attempt to force chunk load for a non - existent mod % s " , mod . getClass ( ) . getName ( ) ) ; <nl> + return ; <nl> + } <nl> + String modId = mc . getModId ( ) ; <nl> + world . getPersistentChunks ( ) . put ( chunk , modId ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Stop forcing the chunk to remain loaded by the supplied mod ( other mods may still <nl> + * keep the chunk loaded , however ) <nl> + * @ param chunk the chunk to keep loaded <nl> + * @ param world the world holding the chunk <nl> + * @ param mod the mod ( either { @ link Mod } or { @ link BaseMod } ) that wishes to unforce the load <nl> + * / <nl> + public static void unforceChunkLoaded ( ChunkCoordIntPair chunk , World world , Object mod ) <nl> + { <nl> + ModContainer mc = FMLCommonHandler . instance ( ) . findContainerFor ( mod ) ; <nl> + if ( mc = = null ) <nl> + { <nl> + FMLLog . warning ( " Attempt to unforce chunk load for a non - existent mod % s " , mod . getClass ( ) . getName ( ) ) ; <nl> + return ; <nl> + } <nl> + String modId = mc . getModId ( ) ; <nl> + world . getPersistentChunks ( ) . remove ( chunk , modId ) ; <nl> + } <nl> } <nl> diff - - git a / patches / common / net / minecraft / src / ChunkProviderServer . java . patch b / patches / common / net / minecraft / src / ChunkProviderServer . java . patch <nl> new file mode 100644 <nl> index 0000000 . . dd1190a <nl> - - - / dev / null <nl> + + + b / patches / common / net / minecraft / src / ChunkProviderServer . java . patch <nl> @ @ - 0 , 0 + 1 , 14 @ @ <nl> + - - - . . / src _ base / common / net / minecraft / src / ChunkProviderServer . java <nl> + + + + . . / src _ work / common / net / minecraft / src / ChunkProviderServer . java <nl> + @ @ - 274 , 6 + 274 , 11 @ @ <nl> + { <nl> + if ( ! this . currentServer . canNotSave ) <nl> + { <nl> + + for ( ChunkCoordIntPair forced : currentServer . persistentChunks . keySet ( ) ) <nl> + + { <nl> + + this . chunksToUnload . remove ( ChunkCoordIntPair . chunkXZ2Int ( forced . chunkXPos , forced . chunkZPos ) ) ; <nl> + + } <nl> + + <nl> + for ( int var1 = 0 ; var1 < 100 ; + + var1 ) <nl> + { <nl> + if ( ! this . chunksToUnload . isEmpty ( ) ) <nl> diff - - git a / patches / common / net / minecraft / src / World . java . patch b / patches / common / net / minecraft / src / World . java . patch <nl> index a2f80ae . . 1281acb 100644 <nl> - - - a / patches / common / net / minecraft / src / World . java . patch <nl> + + + b / patches / common / net / minecraft / src / World . java . patch <nl> @ @ - 4 , 6 + 4 , 10 @ @ <nl> import java . util . Random ; <nl> import java . util . Set ; <nl> <nl> + + import com . google . common . collect . ArrayListMultimap ; <nl> + + import com . google . common . collect . ListMultimap ; <nl> + + <nl> + + import net . minecraftforge . common . ForgeHooks ; <nl> + import net . minecraftforge . common . MinecraftForge ; <nl> + import net . minecraftforge . common . ForgeDirection ; <nl> + import net . minecraftforge . event . entity . EntityEvent ; <nl> @ @ - 23 , 6 + 27 , 12 @ @ <nl> / * * <nl> * boolean ; if true updates scheduled by scheduleBlockUpdate happen immediately <nl> * / <nl> + @ @ - 128 , 6 + 145 , 7 @ @ <nl> + * / <nl> + public boolean isRemote ; <nl> + <nl> + + protected ListMultimap < ChunkCoordIntPair , String > persistentChunks ; <nl> + / * * <nl> @ @ - 132 , 6 + 146 , 11 @ @ <nl> * Gets the biome for a given set of x / z coordinates <nl> * / <nl> @ @ - 47 , 6 + 57 , 9 @ @ <nl> <nl> this . calculateInitialSkylight ( ) ; <nl> this . calculateInitialWeather ( ) ; <nl> + + <nl> + + persistentChunks = ForgeHooks . loadPersistentChunkData ( this . worldInfo ) ; <nl> + + <nl> + MinecraftForge . EVENT _ BUS . post ( new WorldEvent . Load ( this ) ) ; <nl> } <nl> <nl> @ @ - 226 , 9 + 239 , 11 @ @ <nl> @ @ - 1974 , 8 + 2030 , 14 @ @ <nl> int var3 = MathHelper . floor _ double ( par1Entity . posX ) ; <nl> int var4 = MathHelper . floor _ double ( par1Entity . posZ ) ; <nl> - byte var5 = 32 ; <nl> + - byte var5 = 32 ; <nl> - <nl> - if ( ! par2 | | this . checkChunksExist ( var3 - var5 , 0 , var4 - var5 , var3 + var5 , 0 , var4 + var5 ) ) <nl> + + boolean isForced = persistentChunks . containsKey ( new ChunkCoordIntPair ( var3 > > 4 , var4 > > 4 ) ) ; <nl> + + byte var5 = isForced ? ( byte ) 0 : 32 ; <nl> + boolean canUpdate = ! par2 | | this . checkChunksExist ( var3 - var5 , 0 , var4 - var5 , var3 + var5 , 0 , var4 + var5 ) ; <nl> + if ( ! canUpdate ) <nl> + { <nl> @ @ - 659 , 4 + 674 , 9 @ @ <nl> + <nl> + return block . isBlockSolidOnSide ( this , X , Y , Z , side ) ; <nl> + } <nl> + + <nl> + + public ListMultimap < ChunkCoordIntPair , String > getPersistentChunks ( ) <nl> + + { <nl> + + return persistentChunks ; <nl> + + } <nl> } <nl> diff - - git a / patches / common / net / minecraft / src / WorldInfo . java . patch b / patches / common / net / minecraft / src / WorldInfo . java . patch <nl> new file mode 100644 <nl> index 0000000 . . 2edcb48 <nl> - - - / dev / null <nl> + + + b / patches / common / net / minecraft / src / WorldInfo . java . patch <nl> @ @ - 0 , 0 + 1 , 38 @ @ <nl> + - - - . . / src _ base / common / net / minecraft / src / WorldInfo . java <nl> + + + + . . / src _ work / common / net / minecraft / src / WorldInfo . java <nl> + @ @ - 1 , 5 + 1 , 6 @ @ <nl> + package net . minecraft . src ; <nl> + <nl> + + import net . minecraftforge . common . ForgeHooks ; <nl> + import cpw . mods . fml . common . Side ; <nl> + import cpw . mods . fml . common . asm . SideOnly ; <nl> + <nl> + @ @ - 59 , 6 + 60 , 8 @ @ <nl> + private boolean hardcore ; <nl> + private boolean allowCommands ; <nl> + private boolean initialized ; <nl> + + <nl> + + public NBTTagCompound forgeWorldData ; <nl> + <nl> + protected WorldInfo ( ) <nl> + { <nl> + @ @ - 139 , 6 + 142 , 10 @ @ <nl> + { <nl> + this . playerTag = par1NBTTagCompound . getCompoundTag ( " Player " ) ; <nl> + this . dimension = this . playerTag . getInteger ( " Dimension " ) ; <nl> + + } <nl> + + if ( par1NBTTagCompound . hasKey ( " ForgeData " ) ) <nl> + + { <nl> + + this . forgeWorldData = par1NBTTagCompound . getCompoundTag ( " ForgeData " ) ; <nl> + } <nl> + } <nl> + <nl> + @ @ - 228 , 6 + 235 , 8 @ @ <nl> + { <nl> + par1NBTTagCompound . setCompoundTag ( " Player " , par2NBTTagCompound ) ; <nl> + } <nl> + + <nl> + + par1NBTTagCompound . setCompoundTag ( " ForgeData " , forgeWorldData ) ; <nl> + } <nl> + <nl> + / * * <nl> diff - - git a / patches / common / net / minecraft / src / WorldServer . java . patch b / patches / common / net / minecraft / src / WorldServer . java . patch <nl> index 41ac8ec . . 7a8e0e7 100644 <nl> - - - a / patches / common / net / minecraft / src / WorldServer . java . patch <nl> + + + b / patches / common / net / minecraft / src / WorldServer . java . patch <nl> @ @ - 50 , 6 + 50 , 26 @ @ <nl> { <nl> this . updateLCG = this . updateLCG * 3 + 1013904223 ; <nl> var8 = this . updateLCG > > 2 ; <nl> + @ @ - 362 , 7 + 367 , 8 @ @ <nl> + public void scheduleBlockUpdate ( int par1 , int par2 , int par3 , int par4 , int par5 ) <nl> + { <nl> + NextTickListEntry var6 = new NextTickListEntry ( par1 , par2 , par3 , par4 ) ; <nl> + - byte var7 = 8 ; <nl> + + boolean isForced = persistentChunks . containsKey ( new ChunkCoordIntPair ( var6 . xCoord > > 4 , var6 . zCoord > > 4 ) ) ; <nl> + + byte var7 = isForced ? ( byte ) 0 : 8 ; <nl> + <nl> + if ( this . scheduledUpdatesAreImmediate ) <nl> + { <nl> + @ @ - 462 , 7 + 468 , 8 @ @ <nl> + <nl> + this . pendingTickListEntries . remove ( var4 ) ; <nl> + this . field _ 73064 _ N . remove ( var4 ) ; <nl> + - byte var5 = 8 ; <nl> + + boolean isForced = persistentChunks . containsKey ( new ChunkCoordIntPair ( var4 . xCoord > > 4 , var4 . zCoord > > 4 ) ) ; <nl> + + byte var5 = isForced ? ( byte ) 0 : 8 ; <nl> + <nl> + if ( this . checkChunksExist ( var4 . xCoord - var5 , var4 . yCoord - var5 , var4 . zCoord - var5 , var4 . xCoord + var5 , var4 . yCoord + var5 , var4 . zCoord + var5 ) ) <nl> + { <nl> @ @ - 559 , 15 + 562 , 27 @ @ <nl> public List getAllTileEntityInBox ( int par1 , int par2 , int par3 , int par4 , int par5 , int par6 ) <nl> { <nl> @ @ - 117 , 6 + 137 , 15 @ @ <nl> <nl> for ( int var2 = 0 ; var2 < 10 ; + + var2 ) <nl> { <nl> + @ @ - 702 , 6 + 721 , 8 @ @ <nl> + par2IProgressUpdate . displayProgressMessage ( " Saving level " ) ; <nl> + } <nl> + <nl> + + ForgeHooks . dumpPersistentChunks ( worldInfo , persistentChunks ) ; <nl> + + <nl> + this . saveLevel ( ) ; <nl> + <nl> + if ( par2IProgressUpdate ! = null ) <nl> @ @ - 713 , 6 + 733 , 7 @ @ <nl> } <nl>

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / BiomeManager . java b / src / main / java / net / minecraftforge / common / BiomeManager . java 
 index ee584e2 . . 1b45176 100644 
 - - - a / src / main / java / net / minecraftforge / common / BiomeManager . java 
 + + + b / src / main / java / net / minecraftforge / common / BiomeManager . java 
 @ @ - 175 , 7 + 175 , 7 @ @ public class BiomeManager 
 if ( t . name ( ) . equals ( name ) ) return t ; 
 } 
 
 - BiomeType ret = EnumHelper . addEnum ( BiomeType . class , name , BiomeType . class ) ; 
 + BiomeType ret = EnumHelper . addEnum ( BiomeType . class , name , new Class [ 0 ] , new Object [ 0 ] ) ; 
 
 if ( ret . ordinal ( ) > = biomes . length ) 
 { 
 diff - - git a / src / main / java / net / minecraftforge / common / EnumPlantType . java b / src / main / java / net / minecraftforge / common / EnumPlantType . java 
 index 3622e6c . . 648d3dc 100644 
 - - - a / src / main / java / net / minecraftforge / common / EnumPlantType . java 
 + + + b / src / main / java / net / minecraftforge / common / EnumPlantType . java 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package net . minecraftforge . common ; 
 
 + import net . minecraftforge . common . util . EnumHelper ; 
 + 
 public enum EnumPlantType 
 { 
 Plains , 
 @ @ - 8 , 5 + 10 , 27 @ @ public enum EnumPlantType 
 Cave , 
 Water , 
 Nether , 
 - Crop 
 - } 
 \ No newline at end of file 
 + Crop ; 
 + 
 + / * * 
 + * Getting a custom { @ link EnumPlantType } , or an existing one if it has the same name as that one . Your plant should implement { @ link IPlantable } 
 + * and return this custom type in { @ link IPlantable # getPlantType ( net . minecraft . world . IBlockAccess , net . minecraft . util . BlockPos ) } . 
 + * 
 + * < p > If your new plant grows on blocks like any one of them above , never create a new { @ link EnumPlantType } . 
 + * This enumeration is only functioning in 
 + * { @ link net . minecraft . block . Block # canSustainPlant ( net . minecraft . world . IBlockAccess , net . minecraft . util . BlockPos , net . minecraft . util . EnumFacing , IPlantable ) } , 
 + * which you are supposed to override this function in your new block and create a new plant type to grow on that block . 
 + * 
 + * < p > You can create an instance of your plant type in your API and let your / others mods access it . It will be faster than calling this method . 
 + * @ param name the name of the type of plant , you had better follow the style above 
 + * @ return the acquired { @ EnumPlantType } , a new one if not found . 
 + * / 
 + public static EnumPlantType getPlantType ( String name ) 
 + { 
 + for ( EnumPlantType t : values ( ) ) 
 + { 
 + if ( t . name ( ) . equalsIgnoreCase ( name ) ) return t ; 
 + } 
 + return EnumHelper . addEnum ( EnumPlantType . class , name , new Class [ 0 ] , new Object [ 0 ] ) ; 
 + } 
 + } 
 diff - - git a / src / test / java / net / minecraftforge / debug / EnumPlantTypeTest . java b / src / test / java / net / minecraftforge / debug / EnumPlantTypeTest . java 
 new file mode 100644 
 index 0000000 . . 2f7e7aa 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / debug / EnumPlantTypeTest . java 
 @ @ - 0 , 0 + 1 , 49 @ @ 
 + package net . minecraftforge . debug ; 
 + 
 + import net . minecraftforge . common . BiomeManager . BiomeType ; 
 + import net . minecraftforge . common . EnumPlantType ; 
 + import net . minecraftforge . fml . common . Mod ; 
 + import net . minecraftforge . fml . common . event . FMLInitializationEvent ; 
 + import org . apache . logging . log4j . Logger ; 
 + import org . apache . logging . log4j . LogManager ; 
 + 
 + @ Mod ( modid = " enumplanttypetest " ) 
 + public class EnumPlantTypeTest 
 + { 
 + 	 private static Logger LOGGER = LogManager . getLogger ( ) ; 
 + 	 
 + 	 @ Mod . EventHandler 
 + 	 public void onInit ( FMLInitializationEvent event ) 
 + 	 { 
 + 	 	 BiomeType biomeType = null ; 
 + 	 	 try 
 + 	 	 { 
 + 	 	 	 biomeType = BiomeType . getType ( " FAKE " ) ; 
 + 	 	 } 
 + 	 	 catch ( NullPointerException npe ) 
 + 	 	 { 
 + 	 	 	 LOGGER . warn ( " EnumHelper in BiomeType is working incorrectly ! " , npe ) ; 
 + 	 	 } 
 + 	 	 finally 
 + 	 	 { 
 + 	 	 if ( biomeType = = null | | ! biomeType . name ( ) . equals ( " FAKE " ) ) 
 + 	 	 	 LOGGER . warn ( " EnumHelper in BiomeType is working incorrectly ! " ) ; 
 + 	 	 } 
 + 	 EnumPlantType plantType = null ; 
 + 	 if ( plantType = = null | | ! plantType . name ( ) . equals ( " FAKE " ) ) 
 + 	 	 ; 
 + 	 try 
 + 	 	 { 
 + 	 	 plantType = EnumPlantType . getPlantType ( " FAKE " ) ; 
 + 	 	 } 
 + 	 	 catch ( NullPointerException npe ) 
 + 	 	 { 
 + 	 	 	 LOGGER . warn ( " EnumHelper in EnumPlantType is working incorrectly ! " , npe ) ; 
 + 	 	 } 
 + 	 	 finally 
 + 	 	 { 
 + 	 	 if ( plantType = = null | | ! plantType . name ( ) . equals ( " FAKE " ) ) 
 + 	 	 	 LOGGER . warn ( " EnumHelper in EnumPlantType is working incorrectly ! " ) ; 
 + 	 	 } 
 + 	 } 
 + }

NEAREST DIFF:
diff - - git a / common / net / minecraftforge / common / ForgeHooks . java b / common / net / minecraftforge / common / ForgeHooks . java 
 index 05ca957 . . 49ba9c7 100644 
 - - - a / common / net / minecraftforge / common / ForgeHooks . java 
 + + + b / common / net / minecraftforge / common / ForgeHooks . java 
 @ @ - 1 , 8 + 1 , 13 @ @ 
 package net . minecraftforge . common ; 
 
 import java . util . * ; 
 + import java . util . Map . Entry ; 
 + 
 + import com . google . common . collect . ArrayListMultimap ; 
 + import com . google . common . collect . ListMultimap ; 
 
 import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . common . Loader ; 
 
 import net . minecraft . src . * ; 
 import net . minecraftforge . event . entity . item . ItemTossEvent ; 
 @ @ - 354 , 4 + 359 , 55 @ @ public class ForgeHooks 
 player . joinEntityItemWithWorld ( event . entityItem ) ; 
 return event . entityItem ; 
 } 
 + public static void dumpPersistentChunks ( WorldInfo worldInfo , ListMultimap < ChunkCoordIntPair , String > persistentChunks ) 
 + { 
 + worldInfo . forgeWorldData = new NBTTagCompound ( ) ; 
 + 
 + NBTTagList chunkDataList = new NBTTagList ( ) ; 
 + for ( Entry < ChunkCoordIntPair , Collection < String > > entry : persistentChunks . asMap ( ) . entrySet ( ) ) 
 + { 
 + NBTTagCompound dataList = new NBTTagCompound ( ) ; 
 + dataList . setIntArray ( " Chunk " , new int [ ] { entry . getKey ( ) . chunkXPos , entry . getKey ( ) . chunkZPos } ) ; 
 + NBTTagList modList = new NBTTagList ( ) ; 
 + for ( String modId : entry . getValue ( ) ) 
 + { 
 + modList . appendTag ( new NBTTagString ( modId , " " ) ) ; 
 + } 
 + dataList . setTag ( " Mods " , modList ) ; 
 + chunkDataList . appendTag ( dataList ) ; 
 + } 
 + worldInfo . forgeWorldData . setTag ( " PersistentChunks " , chunkDataList ) ; 
 + } 
 + 
 + public static ListMultimap < ChunkCoordIntPair , String > loadPersistentChunkData ( WorldInfo worldInfo ) 
 + { 
 + ArrayListMultimap < ChunkCoordIntPair , String > chunkList = ArrayListMultimap . < ChunkCoordIntPair , String > create ( ) ; 
 + 
 + if ( worldInfo = = null | | worldInfo . forgeWorldData = = null ) 
 + { 
 + return chunkList ; 
 + } 
 + 
 + NBTTagList chunkDataList = worldInfo . forgeWorldData . getTagList ( " PersistentChunks " ) ; 
 + for ( int i = 0 ; i < chunkDataList . tagCount ( ) ; i + + ) 
 + { 
 + NBTTagCompound dataList = ( NBTTagCompound ) chunkDataList . tagAt ( i ) ; 
 + int [ ] ccpairint = dataList . getIntArray ( " Chunk " ) ; 
 + ChunkCoordIntPair ccpair = new ChunkCoordIntPair ( ccpairint [ 0 ] , ccpairint [ 1 ] ) ; 
 + NBTTagList modList = dataList . getTagList ( " Mods " ) ; 
 + for ( int j = 0 ; j < modList . tagCount ( ) ; j + + ) 
 + { 
 + String modId = modList . tagAt ( j ) . getName ( ) ; 
 + if ( Loader . isModLoaded ( modId ) ) 
 + { 
 + chunkList . put ( ccpair , modId ) ; 
 + } 
 + else 
 + { 
 + FMLLog . warning ( " The mod % s is not present - it ' s chunks will not be persisted any longer " , modId ) ; 
 + } 
 + } 
 + } 
 + return chunkList ; 
 + } 
 } 
 diff - - git a / common / net / minecraftforge / common / MinecraftForge . java b / common / net / minecraftforge / common / MinecraftForge . java 
 index fe1dc83 . . 46c1388 100644 
 - - - a / common / net / minecraftforge / common / MinecraftForge . java 
 + + + b / common / net / minecraftforge / common / MinecraftForge . java 
 @ @ - 3 , 7 + 3 , 10 @ @ package net . minecraftforge . common ; 
 import java . lang . reflect . Constructor ; 
 import java . util . * ; 
 
 + import cpw . mods . fml . common . FMLCommonHandler ; 
 import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . common . Mod ; 
 + import cpw . mods . fml . common . ModContainer ; 
 
 import net . minecraft . src . * ; 
 import net . minecraftforge . common . ForgeHooks . GrassEntry ; 
 @ @ - 199 , 4 + 202 , 42 @ @ public class MinecraftForge 
 { 
 return " Minecraft Forge " + ForgeVersion . getVersion ( ) ; 
 } 
 + 
 + / * * 
 + * Force a chunk to remain loaded by the supplied mod 
 + * 
 + * @ param chunk the chunk to keep loaded 
 + * @ param world the world holding the chunk 
 + * @ param mod the mod ( either { @ link Mod } or { @ link BaseMod } ) that wishes to force the load 
 + * / 
 + public static void forceChunkLoaded ( ChunkCoordIntPair chunk , World world , Object mod ) 
 + { 
 + ModContainer mc = FMLCommonHandler . instance ( ) . findContainerFor ( mod ) ; 
 + if ( mc = = null ) 
 + { 
 + FMLLog . warning ( " Attempt to force chunk load for a non - existent mod % s " , mod . getClass ( ) . getName ( ) ) ; 
 + return ; 
 + } 
 + String modId = mc . getModId ( ) ; 
 + world . getPersistentChunks ( ) . put ( chunk , modId ) ; 
 + } 
 + 
 + / * * 
 + * Stop forcing the chunk to remain loaded by the supplied mod ( other mods may still 
 + * keep the chunk loaded , however ) 
 + * @ param chunk the chunk to keep loaded 
 + * @ param world the world holding the chunk 
 + * @ param mod the mod ( either { @ link Mod } or { @ link BaseMod } ) that wishes to unforce the load 
 + * / 
 + public static void unforceChunkLoaded ( ChunkCoordIntPair chunk , World world , Object mod ) 
 + { 
 + ModContainer mc = FMLCommonHandler . instance ( ) . findContainerFor ( mod ) ; 
 + if ( mc = = null ) 
 + { 
 + FMLLog . warning ( " Attempt to unforce chunk load for a non - existent mod % s " , mod . getClass ( ) . getName ( ) ) ; 
 + return ; 
 + } 
 + String modId = mc . getModId ( ) ; 
 + world . getPersistentChunks ( ) . remove ( chunk , modId ) ; 
 + } 
 } 
 diff - - git a / patches / common / net / minecraft / src / ChunkProviderServer . java . patch b / patches / common / net / minecraft / src / ChunkProviderServer . java . patch 
 new file mode 100644 
 index 0000000 . . dd1190a 
 - - - / dev / null 
 + + + b / patches / common / net / minecraft / src / ChunkProviderServer . java . patch 
 @ @ - 0 , 0 + 1 , 14 @ @ 
 + - - - . . / src _ base / common / net / minecraft / src / ChunkProviderServer . java 
 + + + + . . / src _ work / common / net / minecraft / src / ChunkProviderServer . java 
 + @ @ - 274 , 6 + 274 , 11 @ @ 
 + { 
 + if ( ! this . currentServer . canNotSave ) 
 + { 
 + + for ( ChunkCoordIntPair forced : currentServer . persistentChunks . keySet ( ) ) 
 + + { 
 + + this . chunksToUnload . remove ( ChunkCoordIntPair . chunkXZ2Int ( forced . chunkXPos , forced . chunkZPos ) ) ; 
 + + } 
 + + 
 + for ( int var1 = 0 ; var1 < 100 ; + + var1 ) 
 + { 
 + if ( ! this . chunksToUnload . isEmpty ( ) ) 
 diff - - git a / patches / common / net / minecraft / src / World . java . patch b / patches / common / net / minecraft / src / World . java . patch 
 index a2f80ae . . 1281acb 100644 
 - - - a / patches / common / net / minecraft / src / World . java . patch 
 + + + b / patches / common / net / minecraft / src / World . java . patch 
 @ @ - 4 , 6 + 4 , 10 @ @ 
 import java . util . Random ; 
 import java . util . Set ; 
 
 + + import com . google . common . collect . ArrayListMultimap ; 
 + + import com . google . common . collect . ListMultimap ; 
 + + 
 + + import net . minecraftforge . common . ForgeHooks ; 
 + import net . minecraftforge . common . MinecraftForge ; 
 + import net . minecraftforge . common . ForgeDirection ; 
 + import net . minecraftforge . event . entity . EntityEvent ; 
 @ @ - 23 , 6 + 27 , 12 @ @ 
 / * * 
 * boolean ; if true updates scheduled by scheduleBlockUpdate happen immediately 
 * / 
 + @ @ - 128 , 6 + 145 , 7 @ @ 
 + * / 
 + public boolean isRemote ; 
 + 
 + + protected ListMultimap < ChunkCoordIntPair , String > persistentChunks ; 
 + / * * 
 @ @ - 132 , 6 + 146 , 11 @ @ 
 * Gets the biome for a given set of x / z coordinates 
 * / 
 @ @ - 47 , 6 + 57 , 9 @ @ 
 
 this . calculateInitialSkylight ( ) ; 
 this . calculateInitialWeather ( ) ; 
 + + 
 + + persistentChunks = ForgeHooks . loadPersistentChunkData ( this . worldInfo ) ; 
 + + 
 + MinecraftForge . EVENT _ BUS . post ( new WorldEvent . Load ( this ) ) ; 
 } 
 
 @ @ - 226 , 9 + 239 , 11 @ @ 
 @ @ - 1974 , 8 + 2030 , 14 @ @ 
 int var3 = MathHelper . floor _ double ( par1Entity . posX ) ; 
 int var4 = MathHelper . floor _ double ( par1Entity . posZ ) ; 
 - byte var5 = 32 ; 
 + - byte var5 = 32 ; 
 - 
 - if ( ! par2 | | this . checkChunksExist ( var3 - var5 , 0 , var4 - var5 , var3 + var5 , 0 , var4 + var5 ) ) 
 + + boolean isForced = persistentChunks . containsKey ( new ChunkCoordIntPair ( var3 > > 4 , var4 > > 4 ) ) ; 
 + + byte var5 = isForced ? ( byte ) 0 : 32 ; 
 + boolean canUpdate = ! par2 | | this . checkChunksExist ( var3 - var5 , 0 , var4 - var5 , var3 + var5 , 0 , var4 + var5 ) ; 
 + if ( ! canUpdate ) 
 + { 
 @ @ - 659 , 4 + 674 , 9 @ @ 
 + 
 + return block . isBlockSolidOnSide ( this , X , Y , Z , side ) ; 
 + } 
 + + 
 + + public ListMultimap < ChunkCoordIntPair , String > getPersistentChunks ( ) 
 + + { 
 + + return persistentChunks ; 
 + + } 
 } 
 diff - - git a / patches / common / net / minecraft / src / WorldInfo . java . patch b / patches / common / net / minecraft / src / WorldInfo . java . patch 
 new file mode 100644 
 index 0000000 . . 2edcb48 
 - - - / dev / null 
 + + + b / patches / common / net / minecraft / src / WorldInfo . java . patch 
 @ @ - 0 , 0 + 1 , 38 @ @ 
 + - - - . . / src _ base / common / net / minecraft / src / WorldInfo . java 
 + + + + . . / src _ work / common / net / minecraft / src / WorldInfo . java 
 + @ @ - 1 , 5 + 1 , 6 @ @ 
 + package net . minecraft . src ; 
 + 
 + + import net . minecraftforge . common . ForgeHooks ; 
 + import cpw . mods . fml . common . Side ; 
 + import cpw . mods . fml . common . asm . SideOnly ; 
 + 
 + @ @ - 59 , 6 + 60 , 8 @ @ 
 + private boolean hardcore ; 
 + private boolean allowCommands ; 
 + private boolean initialized ; 
 + + 
 + + public NBTTagCompound forgeWorldData ; 
 + 
 + protected WorldInfo ( ) 
 + { 
 + @ @ - 139 , 6 + 142 , 10 @ @ 
 + { 
 + this . playerTag = par1NBTTagCompound . getCompoundTag ( " Player " ) ; 
 + this . dimension = this . playerTag . getInteger ( " Dimension " ) ; 
 + + } 
 + + if ( par1NBTTagCompound . hasKey ( " ForgeData " ) ) 
 + + { 
 + + this . forgeWorldData = par1NBTTagCompound . getCompoundTag ( " ForgeData " ) ; 
 + } 
 + } 
 + 
 + @ @ - 228 , 6 + 235 , 8 @ @ 
 + { 
 + par1NBTTagCompound . setCompoundTag ( " Player " , par2NBTTagCompound ) ; 
 + } 
 + + 
 + + par1NBTTagCompound . setCompoundTag ( " ForgeData " , forgeWorldData ) ; 
 + } 
 + 
 + / * * 
 diff - - git a / patches / common / net / minecraft / src / WorldServer . java . patch b / patches / common / net / minecraft / src / WorldServer . java . patch 
 index 41ac8ec . . 7a8e0e7 100644 
 - - - a / patches / common / net / minecraft / src / WorldServer . java . patch 
 + + + b / patches / common / net / minecraft / src / WorldServer . java . patch 
 @ @ - 50 , 6 + 50 , 26 @ @ 
 { 
 this . updateLCG = this . updateLCG * 3 + 1013904223 ; 
 var8 = this . updateLCG > > 2 ; 
 + @ @ - 362 , 7 + 367 , 8 @ @ 
 + public void scheduleBlockUpdate ( int par1 , int par2 , int par3 , int par4 , int par5 ) 
 + { 
 + NextTickListEntry var6 = new NextTickListEntry ( par1 , par2 , par3 , par4 ) ; 
 + - byte var7 = 8 ; 
 + + boolean isForced = persistentChunks . containsKey ( new ChunkCoordIntPair ( var6 . xCoord > > 4 , var6 . zCoord > > 4 ) ) ; 
 + + byte var7 = isForced ? ( byte ) 0 : 8 ; 
 + 
 + if ( this . scheduledUpdatesAreImmediate ) 
 + { 
 + @ @ - 462 , 7 + 468 , 8 @ @ 
 + 
 + this . pendingTickListEntries . remove ( var4 ) ; 
 + this . field _ 73064 _ N . remove ( var4 ) ; 
 + - byte var5 = 8 ; 
 + + boolean isForced = persistentChunks . containsKey ( new ChunkCoordIntPair ( var4 . xCoord > > 4 , var4 . zCoord > > 4 ) ) ; 
 + + byte var5 = isForced ? ( byte ) 0 : 8 ; 
 + 
 + if ( this . checkChunksExist ( var4 . xCoord - var5 , var4 . yCoord - var5 , var4 . zCoord - var5 , var4 . xCoord + var5 , var4 . yCoord + var5 , var4 . zCoord + var5 ) ) 
 + { 
 @ @ - 559 , 15 + 562 , 27 @ @ 
 public List getAllTileEntityInBox ( int par1 , int par2 , int par3 , int par4 , int par5 , int par6 ) 
 { 
 @ @ - 117 , 6 + 137 , 15 @ @ 
 
 for ( int var2 = 0 ; var2 < 10 ; + + var2 ) 
 { 
 + @ @ - 702 , 6 + 721 , 8 @ @ 
 + par2IProgressUpdate . displayProgressMessage ( " Saving level " ) ; 
 + } 
 + 
 + + ForgeHooks . dumpPersistentChunks ( worldInfo , persistentChunks ) ; 
 + + 
 + this . saveLevel ( ) ; 
 + 
 + if ( par2IProgressUpdate ! = null ) 
 @ @ - 713 , 6 + 733 , 7 @ @ 
 } 

