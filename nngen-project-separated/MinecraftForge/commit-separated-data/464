BLEU SCORE: 0.006679009843017162

TEST MSG: Add methods to write IForgeRegistryEntry to ByteBuf
GENERATED MSG: More tests . Substitutions now work , and a fix is included . * sigh * Closes too many bugs to count .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / network / ByteBufUtils . java b / src / main / java / net / minecraftforge / fml / common / network / ByteBufUtils . java <nl> index 6773061 . . 27d2e1b 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / ByteBufUtils . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / ByteBufUtils . java <nl> @ @ - 20 , 9 + 20 , 19 @ @ <nl> package net . minecraftforge . fml . common . network ; <nl> <nl> import java . io . IOException ; <nl> + import java . util . Collection ; <nl> + import java . util . Iterator ; <nl> + import java . util . List ; <nl> + <nl> import net . minecraft . item . ItemStack ; <nl> import net . minecraft . nbt . NBTTagCompound ; <nl> import net . minecraft . network . PacketBuffer ; <nl> + import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . fml . common . registry . FMLControlledNamespacedRegistry ; <nl> + import net . minecraftforge . fml . common . registry . GameRegistry ; <nl> + import net . minecraftforge . fml . common . registry . IForgeRegistry ; <nl> + import net . minecraftforge . fml . common . registry . IForgeRegistryEntry ; <nl> + import net . minecraftforge . fml . common . registry . PersistentRegistryManager ; <nl> import org . apache . commons . lang3 . Validate ; <nl> <nl> import com . google . common . base . Charsets ; <nl> @ @ - 31 , 6 + 41 , 9 @ @ import com . google . common . base . Throwables ; <nl> import io . netty . buffer . ByteBuf ; <nl> <nl> import javax . annotation . Nullable ; <nl> + import javax . annotation . Nonnull ; <nl> + <nl> + import com . google . common . collect . ImmutableList ; <nl> <nl> / * * <nl> * Utilities for interacting with { @ link ByteBuf } . <nl> @ @ - 219 , 6 + 232 , 109 @ @ public class ByteBufUtils { <nl> } <nl> } <nl> <nl> + / * * <nl> + * Write a registry entry to the stream . The serialized format is not specified and must not be relied upon . <nl> + * Do not use this to write to a file , it is used for client - server communication only . <nl> + * @ param out the buffer to write to <nl> + * @ param entry the registry entry <nl> + * / <nl> + public static < T extends IForgeRegistryEntry < T > > void writeRegistryEntry ( @ Nonnull ByteBuf out , @ Nonnull T entry ) <nl> + { <nl> + FMLControlledNamespacedRegistry < T > registry = ( FMLControlledNamespacedRegistry < T > ) GameRegistry . findRegistry ( entry . getRegistryType ( ) ) ; <nl> + writeUTF8String ( out , PersistentRegistryManager . getRegistryRegistryName ( registry ) . toString ( ) ) ; <nl> + writeVarInt ( out , registry . getId ( entry ) , 5 ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Read a registry entry from the stream . The same format as in { @ link # writeRegistryEntry ( ByteBuf , IForgeRegistryEntry ) } is used . <nl> + * @ param in the buffer to read from <nl> + * @ param registry the registry the entry belongs to <nl> + * @ return the read registry entry <nl> + * / <nl> + @ Nonnull <nl> + public static < T extends IForgeRegistryEntry < T > > T readRegistryEntry ( @ Nonnull ByteBuf in , @ Nonnull IForgeRegistry < T > registry ) <nl> + { <nl> + String registryName = readUTF8String ( in ) ; <nl> + int id = readVarInt ( in , 5 ) ; <nl> + ResourceLocation expectedRegistryName = PersistentRegistryManager . getRegistryRegistryName ( registry ) ; <nl> + if ( ! expectedRegistryName . toString ( ) . equals ( registryName ) ) <nl> + { <nl> + throw new IllegalArgumentException ( " Registry mismatch : " + registryName + " ! = " + expectedRegistryName ) ; <nl> + } <nl> + T thing = ( ( FMLControlledNamespacedRegistry < T > ) registry ) . getRaw ( id ) ; <nl> + if ( thing = = null ) <nl> + { <nl> + throw new IllegalArgumentException ( " Unknown ID " + id + " for registry " + expectedRegistryName + " received . " ) ; <nl> + } <nl> + return thing ; <nl> + } <nl> + <nl> + / * * <nl> + * Write multiple registry entries from the same registry to the stream . The serialized format may be more compact than using <nl> + * { @ link # writeRegistryEntry ( ByteBuf , IForgeRegistryEntry ) } multiple times . <nl> + * @ param out the buffer to write to <nl> + * @ param entries the entries to write <nl> + * / <nl> + public static < T extends IForgeRegistryEntry < T > > void writeRegistryEntries ( @ Nonnull ByteBuf out , @ Nonnull Collection < T > entries ) <nl> + { <nl> + writeVarInt ( out , entries . size ( ) , 5 ) ; <nl> + <nl> + Iterator < T > it = entries . iterator ( ) ; <nl> + if ( it . hasNext ( ) ) <nl> + { <nl> + T first = it . next ( ) ; <nl> + FMLControlledNamespacedRegistry < T > registry = ( FMLControlledNamespacedRegistry < T > ) GameRegistry . findRegistry ( first . getRegistryType ( ) ) ; <nl> + writeUTF8String ( out , PersistentRegistryManager . getRegistryRegistryName ( registry ) . toString ( ) ) ; <nl> + writeVarInt ( out , registry . getId ( first ) , 5 ) ; <nl> + while ( it . hasNext ( ) ) { <nl> + int id = registry . getId ( it . next ( ) ) ; <nl> + if ( id = = - 1 ) { <nl> + throw new IllegalArgumentException ( " Unregistered IForgeRegistryEntry in collection " + entries + " . " ) ; <nl> + } <nl> + writeVarInt ( out , id , 5 ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Read multiple registry entries from the same registries from the stream . The list of entries must have been written by <nl> + * { @ link # writeRegistryEntries ( ByteBuf , Collection ) } . <nl> + * @ param in the buffer to read from <nl> + * @ param registry the registry the entries belong to <nl> + * @ return the immutable list of entries <nl> + * / <nl> + @ Nonnull <nl> + public static < T extends IForgeRegistryEntry < T > > List < T > readRegistryEntries ( @ Nonnull ByteBuf in , @ Nonnull IForgeRegistry < T > registry ) <nl> + { <nl> + int size = readVarInt ( in , 5 ) ; <nl> + if ( size = = 0 ) <nl> + { <nl> + return ImmutableList . of ( ) ; <nl> + } <nl> + else <nl> + { <nl> + String registryName = readUTF8String ( in ) ; <nl> + ResourceLocation expectedRegistryName = PersistentRegistryManager . getRegistryRegistryName ( registry ) ; <nl> + if ( ! expectedRegistryName . toString ( ) . equals ( registryName ) ) <nl> + { <nl> + throw new IllegalArgumentException ( " Registry mismatch : " + registryName + " ! = " + expectedRegistryName ) ; <nl> + } <nl> + <nl> + ImmutableList . Builder < T > b = ImmutableList . builder ( ) ; <nl> + for ( int i = 0 ; i < size ; i + + ) <nl> + { <nl> + int id = readVarInt ( in , 5 ) ; <nl> + T thing = ( ( FMLControlledNamespacedRegistry < T > ) registry ) . getRaw ( id ) ; <nl> + if ( thing = = null ) <nl> + { <nl> + throw new IllegalArgumentException ( " Unknown ID " + id + " for registry " + expectedRegistryName + " received . " ) ; <nl> + } <nl> + b . add ( thing ) ; <nl> + } <nl> + return b . build ( ) ; <nl> + } <nl> + } <nl> + <nl> public static String getContentDump ( ByteBuf buffer ) <nl> { <nl> int currentLength = buffer . readableBytes ( ) ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / IForgeRegistryEntry . java b / src / main / java / net / minecraftforge / fml / common / registry / IForgeRegistryEntry . java <nl> index e135e4c . . 8214618 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / IForgeRegistryEntry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / IForgeRegistryEntry . java <nl> @ @ - 59 , 7 + 59 , 7 @ @ public interface IForgeRegistryEntry < V > <nl> @ Nullable <nl> ResourceLocation getRegistryName ( ) ; <nl> <nl> - Class < ? super V > getRegistryType ( ) ; <nl> + Class < V > getRegistryType ( ) ; <nl> <nl> / / Default implementation , modders who make extra items SHOULD extend this instead of Object . <nl> / / We have to do this until we get default implementations in Java 8 . <nl> @ @ - 100 , 6 + 100 , 6 @ @ public interface IForgeRegistryEntry < V > <nl> } <nl> <nl> @ Override <nl> - public final Class < ? super T > getRegistryType ( ) { return token . getRawType ( ) ; } ; <nl> + public final Class < T > getRegistryType ( ) { return ( Class < T > ) token . getRawType ( ) ; } ; <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> index ddd578b . . 12a4fd6 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java <nl> @ @ - 236 , 6 + 236 , 9 @ @ public class PersistentRegistryManager <nl> return PersistentRegistry . ACTIVE . getRegistry ( registryType ) ; <nl> } <nl> <nl> + public static ResourceLocation getRegistryRegistryName ( IForgeRegistry < ? > registry ) { <nl> + return PersistentRegistry . ACTIVE . registries . inverse ( ) . get ( registry ) ; <nl> + } <nl> <nl> public static List < String > injectSnapshot ( GameDataSnapshot snapshot , boolean injectFrozenData , boolean isLocalWorld ) <nl> { <nl> diff - - git a / src / test / java / net / minecraftforge / debug / ObjectHolderTest . java b / src / test / java / net / minecraftforge / debug / ObjectHolderTest . java <nl> index 8d7b5db . . eb0adfa 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / ObjectHolderTest . java <nl> + + + b / src / test / java / net / minecraftforge / debug / ObjectHolderTest . java <nl> @ @ - 93 , 7 + 93 , 7 @ @ class CustomRegistryEntry implements ICustomRegistryEntry <nl> } <nl> <nl> @ Override <nl> - public Class < ? super ICustomRegistryEntry > getRegistryType ( ) <nl> + public Class < ICustomRegistryEntry > getRegistryType ( ) <nl> { <nl> return ICustomRegistryEntry . class ; <nl> }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / LoadController . java b / src / main / java / net / minecraftforge / fml / common / LoadController . java <nl> index 99df669 . . 7422eec 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / LoadController . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / LoadController . java <nl> @ @ - 199 , 6 + 199 , 10 @ @ public class LoadController <nl> return activeContainer ! = null ? activeContainer : findActiveContainerFromStack ( ) ; <nl> } <nl> <nl> + void forceActiveContainer ( ModContainer container ) <nl> + { <nl> + activeContainer = container ; <nl> + } <nl> @ Subscribe <nl> public void propogateStateMessage ( FMLEvent stateEvent ) <nl> { <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / Loader . java b / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> index 982c389 . . 82bcd17 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / Loader . java <nl> @ @ - 38 , 6 + 38 , 7 @ @ import net . minecraftforge . common . capabilities . CapabilityManager ; <nl> import net . minecraftforge . fml . common . LoaderState . ModState ; <nl> import net . minecraftforge . fml . common . ModContainer . Disableable ; <nl> import net . minecraftforge . fml . common . ProgressManager . ProgressBar ; <nl> + import net . minecraftforge . fml . common . discovery . ASMDataTable ; <nl> import net . minecraftforge . fml . common . discovery . ModDiscoverer ; <nl> import net . minecraftforge . fml . common . event . FMLInterModComms ; <nl> import net . minecraftforge . fml . common . event . FMLLoadEvent ; <nl> @ @ - 489 , 10 + 490 , 23 @ @ public class Loader <nl> } <nl> <nl> / * * <nl> + * Used to setup a testharness with a single dummy mod instance for use with various testing hooks <nl> + * @ param dummycontainer A dummy container that will be returned as " active " for all queries <nl> + * / <nl> + public void setupTestHarness ( ModContainer dummycontainer ) <nl> + { <nl> + modController = new LoadController ( this ) ; <nl> + mods = Lists . newArrayList ( dummycontainer ) ; <nl> + modController . transition ( LoaderState . LOADING , false ) ; <nl> + modController . transition ( LoaderState . CONSTRUCTING , false ) ; <nl> + ObjectHolderRegistry . INSTANCE . findObjectHolders ( new ASMDataTable ( ) ) ; <nl> + modController . forceActiveContainer ( dummycontainer ) ; <nl> + } <nl> + / * * <nl> * Called from the hook to start mod loading . We trigger the <nl> * { @ link # identifyMods ( ) } and Constructing , Preinitalization , and Initalization phases here . Finally , <nl> * the mod list is frozen completely and is consider immutable from then on . <nl> - * @ param injectedModContainers <nl> + * @ param injectedModContainers containers to inject <nl> * / <nl> public void loadMods ( List < String > injectedModContainers ) <nl> { <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> index c6c2d4b . . 5ccad59 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> @ @ - 66 , 6 + 66 , 10 @ @ public class FMLControlledNamespacedRegistry < I extends IForgeRegistryEntry < I > > e <nl> * / <nl> private final BiMap < ResourceLocation , I > persistentSubstitutions = HashBiMap . create ( ) ; <nl> / * * <nl> + * Substitution originals - these are the originals that are being substituted <nl> + * / <nl> + private final BiMap < ResourceLocation , I > substitutionOriginals = HashBiMap . create ( ) ; <nl> + / * * <nl> * This is the current active substitution set for a particular world . It will change as worlds come and go . <nl> * / <nl> private final BiMap < ResourceLocation , I > activeSubstitutions = HashBiMap . create ( ) ; <nl> @ @ - 602 , 6 + 606 , 11 @ @ public class FMLControlledNamespacedRegistry < I extends IForgeRegistryEntry < I > > e <nl> I sub = getPersistentSubstitutions ( ) . get ( nameToReplace ) ; <nl> getExistingDelegate ( original ) . changeReference ( sub ) ; <nl> activeSubstitutions . put ( nameToReplace , sub ) ; <nl> + int id = getIDForObjectBypass ( original ) ; <nl> + / / force the new object into the existing map <nl> + addObjectRaw ( id , nameToReplace , sub ) ; <nl> + / / Track the original in the substitution originals collection <nl> + substitutionOriginals . put ( nameToReplace , original ) ; <nl> return original ; <nl> } <nl> return null ; <nl> @ @ - 747 , 7 + 756 , 11 @ @ public class FMLControlledNamespacedRegistry < I extends IForgeRegistryEntry < I > > e <nl> remappedIds . put ( itemName , new Integer [ ] { currId , newId } ) ; <nl> } <nl> I obj = currentRegistry . getRaw ( itemName ) ; <nl> - <nl> + / / If we have an object in the originals set , we use that for initial adding - substitute activation will readd the substitute if neceessary later <nl> + if ( currentRegistry . substitutionOriginals . containsKey ( itemName ) ) <nl> + { <nl> + obj = currentRegistry . substitutionOriginals . get ( itemName ) ; <nl> + } <nl> add ( newId , itemName , obj ) ; <nl> } <nl> } <nl> diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java b / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java <nl> index cc4fbb0 . . 8302867 100644 <nl> - - - a / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java <nl> + + + b / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java <nl> @ @ - 13 , 9 + 13 , 8 @ @ import org . junit . runners . JUnit4 ; <nl> import org . junit . runners . model . InitializationError ; <nl> <nl> / * * <nl> - * Uses { @ code ResettingClassLoader } to load the test class , meaning the <nl> - * { @ code Quarantine } annotation can be used to ensure certain classes are <nl> - * loaded separately . <nl> + * Uses { @ code ResettingClassLoader } to load the test class . Minecraft and Forge <nl> + * classes are loaded using the separate class loader . <nl> * <nl> * Use of a separate class loader allows classes to be reloaded for each test <nl> * class , which is handy when you ' re testing frameworks that make use of static <nl> diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / RegistryTestSuite . java b / src / test / java / net / minecraftforge / fml / common / registry / RegistryTestSuite . java <nl> new file mode 100644 <nl> index 0000000 . . d3512ae <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / fml / common / registry / RegistryTestSuite . java <nl> @ @ - 0 , 0 + 1 , 13 @ @ <nl> + package net . minecraftforge . fml . common . registry ; <nl> + <nl> + import org . junit . runner . RunWith ; <nl> + import org . junit . runners . Suite ; <nl> + <nl> + / * * <nl> + * Run the full suite of tests <nl> + * / <nl> + @ RunWith ( Suite . class ) <nl> + @ Suite . SuiteClasses ( { VanillaRegistryTests . class , FreezingTests . class , SubstitutionTests . class } ) <nl> + public class RegistryTestSuite <nl> + { <nl> + } <nl> diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionTests . java b / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionTests . java <nl> new file mode 100644 <nl> index 0000000 . . 76c663a <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionTests . java <nl> @ @ - 0 , 0 + 1 , 75 @ @ <nl> + package net . minecraftforge . fml . common . registry ; <nl> + <nl> + import net . minecraft . block . Block ; <nl> + import net . minecraft . block . BlockDirt ; <nl> + import net . minecraft . init . Blocks ; <nl> + import net . minecraft . init . Bootstrap ; <nl> + import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . fml . common . DummyModContainer ; <nl> + import net . minecraftforge . fml . common . Loader ; <nl> + import net . minecraftforge . fml . common . ModMetadata ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertNotEquals ; <nl> + <nl> + / * * <nl> + * Substitution test harness - tests that substitutions behave correctly <nl> + * / <nl> + @ RunWith ( ForgeTestRunner . class ) <nl> + public class SubstitutionTests <nl> + { <nl> + private ResourceLocation myDirt = new ResourceLocation ( " minecraft : dirt " ) ; <nl> + private BlockDirt toSub = new BlockDirt ( ) { <nl> + <nl> + } ; <nl> + <nl> + @ BeforeClass <nl> + public static void setup ( ) <nl> + { <nl> + Loader . instance ( ) ; <nl> + Bootstrap . register ( ) ; <nl> + Loader . instance ( ) . setupTestHarness ( new DummyModContainer ( new ModMetadata ( ) { { <nl> + modId = " test " ; <nl> + } } ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSubstitution ( ) throws Exception <nl> + { <nl> + GameRegistry . addSubstitutionAlias ( " minecraft : dirt " , GameRegistry . Type . BLOCK , toSub ) ; <nl> + PersistentRegistryManager . freezeData ( ) ; <nl> + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; <nl> + <nl> + final FMLControlledNamespacedRegistry < Block > blockRegistry = ( FMLControlledNamespacedRegistry < Block > ) PersistentRegistryManager . findRegistryByType ( Block . class ) ; <nl> + <nl> + / / TEST 1 : Does my substitute take effect ? The substitute should be found in the registry <nl> + Block fnd = blockRegistry . getValue ( myDirt ) ; <nl> + Block currDirt = Blocks . DIRT ; <nl> + assertEquals ( " Got my dirt substitute - Blocks " , toSub , currDirt ) ; <nl> + assertEquals ( " Got my dirt substitute - Blocks and registry " , currDirt , fnd ) ; <nl> + assertEquals ( " Got my dirt substitute - registry " , toSub , fnd ) ; <nl> + <nl> + / / TEST 2 : Does the substitute get removed when told by remote operation ? The substitute should NOT be found in the registry <nl> + final PersistentRegistryManager . GameDataSnapshot snapshot = PersistentRegistryManager . takeSnapshot ( ) ; <nl> + snapshot . entries . get ( PersistentRegistryManager . BLOCKS ) . substitutions . clear ( ) ; <nl> + PersistentRegistryManager . injectSnapshot ( snapshot , false , false ) ; <nl> + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; <nl> + fnd = blockRegistry . getValue ( myDirt ) ; <nl> + currDirt = Blocks . DIRT ; <nl> + assertNotEquals ( " Got my dirt substitute - Blocks " , toSub , currDirt ) ; <nl> + assertEquals ( " Got my dirt substitute - Blocks and registry " , currDirt , fnd ) ; <nl> + assertNotEquals ( " Got my dirt substitute - registry " , toSub , fnd ) ; <nl> + <nl> + / / TEST 3 : Does the substitute get restored when reverting to frozen state ? The substitute should be found in the registry again <nl> + PersistentRegistryManager . revertToFrozen ( ) ; <nl> + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; <nl> + fnd = blockRegistry . getValue ( myDirt ) ; <nl> + currDirt = Blocks . DIRT ; <nl> + assertEquals ( " Got my dirt substitute - Blocks " , toSub , currDirt ) ; <nl> + assertEquals ( " Got my dirt substitute - Blocks and registry " , currDirt , fnd ) ; <nl> + assertEquals ( " Got my dirt substitute - registry " , toSub , fnd ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / network / ByteBufUtils . java b / src / main / java / net / minecraftforge / fml / common / network / ByteBufUtils . java 
 index 6773061 . . 27d2e1b 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / ByteBufUtils . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / ByteBufUtils . java 
 @ @ - 20 , 9 + 20 , 19 @ @ 
 package net . minecraftforge . fml . common . network ; 
 
 import java . io . IOException ; 
 + import java . util . Collection ; 
 + import java . util . Iterator ; 
 + import java . util . List ; 
 + 
 import net . minecraft . item . ItemStack ; 
 import net . minecraft . nbt . NBTTagCompound ; 
 import net . minecraft . network . PacketBuffer ; 
 + import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . fml . common . registry . FMLControlledNamespacedRegistry ; 
 + import net . minecraftforge . fml . common . registry . GameRegistry ; 
 + import net . minecraftforge . fml . common . registry . IForgeRegistry ; 
 + import net . minecraftforge . fml . common . registry . IForgeRegistryEntry ; 
 + import net . minecraftforge . fml . common . registry . PersistentRegistryManager ; 
 import org . apache . commons . lang3 . Validate ; 
 
 import com . google . common . base . Charsets ; 
 @ @ - 31 , 6 + 41 , 9 @ @ import com . google . common . base . Throwables ; 
 import io . netty . buffer . ByteBuf ; 
 
 import javax . annotation . Nullable ; 
 + import javax . annotation . Nonnull ; 
 + 
 + import com . google . common . collect . ImmutableList ; 
 
 / * * 
 * Utilities for interacting with { @ link ByteBuf } . 
 @ @ - 219 , 6 + 232 , 109 @ @ public class ByteBufUtils { 
 } 
 } 
 
 + / * * 
 + * Write a registry entry to the stream . The serialized format is not specified and must not be relied upon . 
 + * Do not use this to write to a file , it is used for client - server communication only . 
 + * @ param out the buffer to write to 
 + * @ param entry the registry entry 
 + * / 
 + public static < T extends IForgeRegistryEntry < T > > void writeRegistryEntry ( @ Nonnull ByteBuf out , @ Nonnull T entry ) 
 + { 
 + FMLControlledNamespacedRegistry < T > registry = ( FMLControlledNamespacedRegistry < T > ) GameRegistry . findRegistry ( entry . getRegistryType ( ) ) ; 
 + writeUTF8String ( out , PersistentRegistryManager . getRegistryRegistryName ( registry ) . toString ( ) ) ; 
 + writeVarInt ( out , registry . getId ( entry ) , 5 ) ; 
 + } 
 + 
 + / * * 
 + * Read a registry entry from the stream . The same format as in { @ link # writeRegistryEntry ( ByteBuf , IForgeRegistryEntry ) } is used . 
 + * @ param in the buffer to read from 
 + * @ param registry the registry the entry belongs to 
 + * @ return the read registry entry 
 + * / 
 + @ Nonnull 
 + public static < T extends IForgeRegistryEntry < T > > T readRegistryEntry ( @ Nonnull ByteBuf in , @ Nonnull IForgeRegistry < T > registry ) 
 + { 
 + String registryName = readUTF8String ( in ) ; 
 + int id = readVarInt ( in , 5 ) ; 
 + ResourceLocation expectedRegistryName = PersistentRegistryManager . getRegistryRegistryName ( registry ) ; 
 + if ( ! expectedRegistryName . toString ( ) . equals ( registryName ) ) 
 + { 
 + throw new IllegalArgumentException ( " Registry mismatch : " + registryName + " ! = " + expectedRegistryName ) ; 
 + } 
 + T thing = ( ( FMLControlledNamespacedRegistry < T > ) registry ) . getRaw ( id ) ; 
 + if ( thing = = null ) 
 + { 
 + throw new IllegalArgumentException ( " Unknown ID " + id + " for registry " + expectedRegistryName + " received . " ) ; 
 + } 
 + return thing ; 
 + } 
 + 
 + / * * 
 + * Write multiple registry entries from the same registry to the stream . The serialized format may be more compact than using 
 + * { @ link # writeRegistryEntry ( ByteBuf , IForgeRegistryEntry ) } multiple times . 
 + * @ param out the buffer to write to 
 + * @ param entries the entries to write 
 + * / 
 + public static < T extends IForgeRegistryEntry < T > > void writeRegistryEntries ( @ Nonnull ByteBuf out , @ Nonnull Collection < T > entries ) 
 + { 
 + writeVarInt ( out , entries . size ( ) , 5 ) ; 
 + 
 + Iterator < T > it = entries . iterator ( ) ; 
 + if ( it . hasNext ( ) ) 
 + { 
 + T first = it . next ( ) ; 
 + FMLControlledNamespacedRegistry < T > registry = ( FMLControlledNamespacedRegistry < T > ) GameRegistry . findRegistry ( first . getRegistryType ( ) ) ; 
 + writeUTF8String ( out , PersistentRegistryManager . getRegistryRegistryName ( registry ) . toString ( ) ) ; 
 + writeVarInt ( out , registry . getId ( first ) , 5 ) ; 
 + while ( it . hasNext ( ) ) { 
 + int id = registry . getId ( it . next ( ) ) ; 
 + if ( id = = - 1 ) { 
 + throw new IllegalArgumentException ( " Unregistered IForgeRegistryEntry in collection " + entries + " . " ) ; 
 + } 
 + writeVarInt ( out , id , 5 ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Read multiple registry entries from the same registries from the stream . The list of entries must have been written by 
 + * { @ link # writeRegistryEntries ( ByteBuf , Collection ) } . 
 + * @ param in the buffer to read from 
 + * @ param registry the registry the entries belong to 
 + * @ return the immutable list of entries 
 + * / 
 + @ Nonnull 
 + public static < T extends IForgeRegistryEntry < T > > List < T > readRegistryEntries ( @ Nonnull ByteBuf in , @ Nonnull IForgeRegistry < T > registry ) 
 + { 
 + int size = readVarInt ( in , 5 ) ; 
 + if ( size = = 0 ) 
 + { 
 + return ImmutableList . of ( ) ; 
 + } 
 + else 
 + { 
 + String registryName = readUTF8String ( in ) ; 
 + ResourceLocation expectedRegistryName = PersistentRegistryManager . getRegistryRegistryName ( registry ) ; 
 + if ( ! expectedRegistryName . toString ( ) . equals ( registryName ) ) 
 + { 
 + throw new IllegalArgumentException ( " Registry mismatch : " + registryName + " ! = " + expectedRegistryName ) ; 
 + } 
 + 
 + ImmutableList . Builder < T > b = ImmutableList . builder ( ) ; 
 + for ( int i = 0 ; i < size ; i + + ) 
 + { 
 + int id = readVarInt ( in , 5 ) ; 
 + T thing = ( ( FMLControlledNamespacedRegistry < T > ) registry ) . getRaw ( id ) ; 
 + if ( thing = = null ) 
 + { 
 + throw new IllegalArgumentException ( " Unknown ID " + id + " for registry " + expectedRegistryName + " received . " ) ; 
 + } 
 + b . add ( thing ) ; 
 + } 
 + return b . build ( ) ; 
 + } 
 + } 
 + 
 public static String getContentDump ( ByteBuf buffer ) 
 { 
 int currentLength = buffer . readableBytes ( ) ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / IForgeRegistryEntry . java b / src / main / java / net / minecraftforge / fml / common / registry / IForgeRegistryEntry . java 
 index e135e4c . . 8214618 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / IForgeRegistryEntry . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / IForgeRegistryEntry . java 
 @ @ - 59 , 7 + 59 , 7 @ @ public interface IForgeRegistryEntry < V > 
 @ Nullable 
 ResourceLocation getRegistryName ( ) ; 
 
 - Class < ? super V > getRegistryType ( ) ; 
 + Class < V > getRegistryType ( ) ; 
 
 / / Default implementation , modders who make extra items SHOULD extend this instead of Object . 
 / / We have to do this until we get default implementations in Java 8 . 
 @ @ - 100 , 6 + 100 , 6 @ @ public interface IForgeRegistryEntry < V > 
 } 
 
 @ Override 
 - public final Class < ? super T > getRegistryType ( ) { return token . getRawType ( ) ; } ; 
 + public final Class < T > getRegistryType ( ) { return ( Class < T > ) token . getRawType ( ) ; } ; 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 index ddd578b . . 12a4fd6 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / PersistentRegistryManager . java 
 @ @ - 236 , 6 + 236 , 9 @ @ public class PersistentRegistryManager 
 return PersistentRegistry . ACTIVE . getRegistry ( registryType ) ; 
 } 
 
 + public static ResourceLocation getRegistryRegistryName ( IForgeRegistry < ? > registry ) { 
 + return PersistentRegistry . ACTIVE . registries . inverse ( ) . get ( registry ) ; 
 + } 
 
 public static List < String > injectSnapshot ( GameDataSnapshot snapshot , boolean injectFrozenData , boolean isLocalWorld ) 
 { 
 diff - - git a / src / test / java / net / minecraftforge / debug / ObjectHolderTest . java b / src / test / java / net / minecraftforge / debug / ObjectHolderTest . java 
 index 8d7b5db . . eb0adfa 100644 
 - - - a / src / test / java / net / minecraftforge / debug / ObjectHolderTest . java 
 + + + b / src / test / java / net / minecraftforge / debug / ObjectHolderTest . java 
 @ @ - 93 , 7 + 93 , 7 @ @ class CustomRegistryEntry implements ICustomRegistryEntry 
 } 
 
 @ Override 
 - public Class < ? super ICustomRegistryEntry > getRegistryType ( ) 
 + public Class < ICustomRegistryEntry > getRegistryType ( ) 
 { 
 return ICustomRegistryEntry . class ; 
 }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / LoadController . java b / src / main / java / net / minecraftforge / fml / common / LoadController . java 
 index 99df669 . . 7422eec 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / LoadController . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / LoadController . java 
 @ @ - 199 , 6 + 199 , 10 @ @ public class LoadController 
 return activeContainer ! = null ? activeContainer : findActiveContainerFromStack ( ) ; 
 } 
 
 + void forceActiveContainer ( ModContainer container ) 
 + { 
 + activeContainer = container ; 
 + } 
 @ Subscribe 
 public void propogateStateMessage ( FMLEvent stateEvent ) 
 { 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / Loader . java b / src / main / java / net / minecraftforge / fml / common / Loader . java 
 index 982c389 . . 82bcd17 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / Loader . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / Loader . java 
 @ @ - 38 , 6 + 38 , 7 @ @ import net . minecraftforge . common . capabilities . CapabilityManager ; 
 import net . minecraftforge . fml . common . LoaderState . ModState ; 
 import net . minecraftforge . fml . common . ModContainer . Disableable ; 
 import net . minecraftforge . fml . common . ProgressManager . ProgressBar ; 
 + import net . minecraftforge . fml . common . discovery . ASMDataTable ; 
 import net . minecraftforge . fml . common . discovery . ModDiscoverer ; 
 import net . minecraftforge . fml . common . event . FMLInterModComms ; 
 import net . minecraftforge . fml . common . event . FMLLoadEvent ; 
 @ @ - 489 , 10 + 490 , 23 @ @ public class Loader 
 } 
 
 / * * 
 + * Used to setup a testharness with a single dummy mod instance for use with various testing hooks 
 + * @ param dummycontainer A dummy container that will be returned as " active " for all queries 
 + * / 
 + public void setupTestHarness ( ModContainer dummycontainer ) 
 + { 
 + modController = new LoadController ( this ) ; 
 + mods = Lists . newArrayList ( dummycontainer ) ; 
 + modController . transition ( LoaderState . LOADING , false ) ; 
 + modController . transition ( LoaderState . CONSTRUCTING , false ) ; 
 + ObjectHolderRegistry . INSTANCE . findObjectHolders ( new ASMDataTable ( ) ) ; 
 + modController . forceActiveContainer ( dummycontainer ) ; 
 + } 
 + / * * 
 * Called from the hook to start mod loading . We trigger the 
 * { @ link # identifyMods ( ) } and Constructing , Preinitalization , and Initalization phases here . Finally , 
 * the mod list is frozen completely and is consider immutable from then on . 
 - * @ param injectedModContainers 
 + * @ param injectedModContainers containers to inject 
 * / 
 public void loadMods ( List < String > injectedModContainers ) 
 { 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 index c6c2d4b . . 5ccad59 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / registry / FMLControlledNamespacedRegistry . java 
 @ @ - 66 , 6 + 66 , 10 @ @ public class FMLControlledNamespacedRegistry < I extends IForgeRegistryEntry < I > > e 
 * / 
 private final BiMap < ResourceLocation , I > persistentSubstitutions = HashBiMap . create ( ) ; 
 / * * 
 + * Substitution originals - these are the originals that are being substituted 
 + * / 
 + private final BiMap < ResourceLocation , I > substitutionOriginals = HashBiMap . create ( ) ; 
 + / * * 
 * This is the current active substitution set for a particular world . It will change as worlds come and go . 
 * / 
 private final BiMap < ResourceLocation , I > activeSubstitutions = HashBiMap . create ( ) ; 
 @ @ - 602 , 6 + 606 , 11 @ @ public class FMLControlledNamespacedRegistry < I extends IForgeRegistryEntry < I > > e 
 I sub = getPersistentSubstitutions ( ) . get ( nameToReplace ) ; 
 getExistingDelegate ( original ) . changeReference ( sub ) ; 
 activeSubstitutions . put ( nameToReplace , sub ) ; 
 + int id = getIDForObjectBypass ( original ) ; 
 + / / force the new object into the existing map 
 + addObjectRaw ( id , nameToReplace , sub ) ; 
 + / / Track the original in the substitution originals collection 
 + substitutionOriginals . put ( nameToReplace , original ) ; 
 return original ; 
 } 
 return null ; 
 @ @ - 747 , 7 + 756 , 11 @ @ public class FMLControlledNamespacedRegistry < I extends IForgeRegistryEntry < I > > e 
 remappedIds . put ( itemName , new Integer [ ] { currId , newId } ) ; 
 } 
 I obj = currentRegistry . getRaw ( itemName ) ; 
 - 
 + / / If we have an object in the originals set , we use that for initial adding - substitute activation will readd the substitute if neceessary later 
 + if ( currentRegistry . substitutionOriginals . containsKey ( itemName ) ) 
 + { 
 + obj = currentRegistry . substitutionOriginals . get ( itemName ) ; 
 + } 
 add ( newId , itemName , obj ) ; 
 } 
 } 
 diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java b / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java 
 index cc4fbb0 . . 8302867 100644 
 - - - a / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java 
 + + + b / src / test / java / net / minecraftforge / fml / common / registry / ForgeTestRunner . java 
 @ @ - 13 , 9 + 13 , 8 @ @ import org . junit . runners . JUnit4 ; 
 import org . junit . runners . model . InitializationError ; 
 
 / * * 
 - * Uses { @ code ResettingClassLoader } to load the test class , meaning the 
 - * { @ code Quarantine } annotation can be used to ensure certain classes are 
 - * loaded separately . 
 + * Uses { @ code ResettingClassLoader } to load the test class . Minecraft and Forge 
 + * classes are loaded using the separate class loader . 
 * 
 * Use of a separate class loader allows classes to be reloaded for each test 
 * class , which is handy when you ' re testing frameworks that make use of static 
 diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / RegistryTestSuite . java b / src / test / java / net / minecraftforge / fml / common / registry / RegistryTestSuite . java 
 new file mode 100644 
 index 0000000 . . d3512ae 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / fml / common / registry / RegistryTestSuite . java 
 @ @ - 0 , 0 + 1 , 13 @ @ 
 + package net . minecraftforge . fml . common . registry ; 
 + 
 + import org . junit . runner . RunWith ; 
 + import org . junit . runners . Suite ; 
 + 
 + / * * 
 + * Run the full suite of tests 
 + * / 
 + @ RunWith ( Suite . class ) 
 + @ Suite . SuiteClasses ( { VanillaRegistryTests . class , FreezingTests . class , SubstitutionTests . class } ) 
 + public class RegistryTestSuite 
 + { 
 + } 
 diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionTests . java b / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionTests . java 
 new file mode 100644 
 index 0000000 . . 76c663a 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionTests . java 
 @ @ - 0 , 0 + 1 , 75 @ @ 
 + package net . minecraftforge . fml . common . registry ; 
 + 
 + import net . minecraft . block . Block ; 
 + import net . minecraft . block . BlockDirt ; 
 + import net . minecraft . init . Blocks ; 
 + import net . minecraft . init . Bootstrap ; 
 + import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . fml . common . DummyModContainer ; 
 + import net . minecraftforge . fml . common . Loader ; 
 + import net . minecraftforge . fml . common . ModMetadata ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertNotEquals ; 
 + 
 + / * * 
 + * Substitution test harness - tests that substitutions behave correctly 
 + * / 
 + @ RunWith ( ForgeTestRunner . class ) 
 + public class SubstitutionTests 
 + { 
 + private ResourceLocation myDirt = new ResourceLocation ( " minecraft : dirt " ) ; 
 + private BlockDirt toSub = new BlockDirt ( ) { 
 + 
 + } ; 
 + 
 + @ BeforeClass 
 + public static void setup ( ) 
 + { 
 + Loader . instance ( ) ; 
 + Bootstrap . register ( ) ; 
 + Loader . instance ( ) . setupTestHarness ( new DummyModContainer ( new ModMetadata ( ) { { 
 + modId = " test " ; 
 + } } ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testSubstitution ( ) throws Exception 
 + { 
 + GameRegistry . addSubstitutionAlias ( " minecraft : dirt " , GameRegistry . Type . BLOCK , toSub ) ; 
 + PersistentRegistryManager . freezeData ( ) ; 
 + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; 
 + 
 + final FMLControlledNamespacedRegistry < Block > blockRegistry = ( FMLControlledNamespacedRegistry < Block > ) PersistentRegistryManager . findRegistryByType ( Block . class ) ; 
 + 
 + / / TEST 1 : Does my substitute take effect ? The substitute should be found in the registry 
 + Block fnd = blockRegistry . getValue ( myDirt ) ; 
 + Block currDirt = Blocks . DIRT ; 
 + assertEquals ( " Got my dirt substitute - Blocks " , toSub , currDirt ) ; 
 + assertEquals ( " Got my dirt substitute - Blocks and registry " , currDirt , fnd ) ; 
 + assertEquals ( " Got my dirt substitute - registry " , toSub , fnd ) ; 
 + 
 + / / TEST 2 : Does the substitute get removed when told by remote operation ? The substitute should NOT be found in the registry 
 + final PersistentRegistryManager . GameDataSnapshot snapshot = PersistentRegistryManager . takeSnapshot ( ) ; 
 + snapshot . entries . get ( PersistentRegistryManager . BLOCKS ) . substitutions . clear ( ) ; 
 + PersistentRegistryManager . injectSnapshot ( snapshot , false , false ) ; 
 + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; 
 + fnd = blockRegistry . getValue ( myDirt ) ; 
 + currDirt = Blocks . DIRT ; 
 + assertNotEquals ( " Got my dirt substitute - Blocks " , toSub , currDirt ) ; 
 + assertEquals ( " Got my dirt substitute - Blocks and registry " , currDirt , fnd ) ; 
 + assertNotEquals ( " Got my dirt substitute - registry " , toSub , fnd ) ; 
 + 
 + / / TEST 3 : Does the substitute get restored when reverting to frozen state ? The substitute should be found in the registry again 
 + PersistentRegistryManager . revertToFrozen ( ) ; 
 + ObjectHolderRegistry . INSTANCE . applyObjectHolders ( ) ; 
 + fnd = blockRegistry . getValue ( myDirt ) ; 
 + currDirt = Blocks . DIRT ; 
 + assertEquals ( " Got my dirt substitute - Blocks " , toSub , currDirt ) ; 
 + assertEquals ( " Got my dirt substitute - Blocks and registry " , currDirt , fnd ) ; 
 + assertEquals ( " Got my dirt substitute - registry " , toSub , fnd ) ; 
 + } 
 + }
