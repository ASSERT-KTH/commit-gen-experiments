BLEU SCORE: 0.09535414040914189

TEST MSG: Simplify custom item rendering by removing GL emissivity hacks
GENERATED MSG: Support diffuse lighting flag in item rendering

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / ForgeHooksClient . java b / src / main / java / net / minecraftforge / client / ForgeHooksClient . java <nl> index 732607d . . 5dc2e81 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / ForgeHooksClient . java <nl> + + + b / src / main / java / net / minecraftforge / client / ForgeHooksClient . java <nl> @ @ - 625 , 22 + 625 , 16 @ @ public class ForgeHooksClient <nl> List < BakedQuad > segment = new ArrayList < > ( ) ; <nl> <nl> / / Lighting of the current segment <nl> - int segmentBlockLight = - 1 ; <nl> - int segmentSkyLight = - 1 ; <nl> - / / Coloring of the current segment <nl> - int segmentColorMultiplier = color ; <nl> + int segmentBlockLight = 0 ; <nl> + int segmentSkyLight = 0 ; <nl> / / Diffuse lighting state <nl> boolean segmentShading = true ; <nl> / / State changed by the current segment <nl> boolean segmentLightingDirty = false ; <nl> - boolean segmentColorDirty = false ; <nl> boolean segmentShadingDirty = false ; <nl> / / If the current segment contains lighting data <nl> boolean hasLighting = false ; <nl> <nl> - / / Tint index cache to avoid unnecessary IItemColor lookups <nl> - int prevTintIndex = - 1 ; <nl> - <nl> for ( int i = 0 ; i < allquads . size ( ) ; i + + ) <nl> { <nl> BakedQuad q = allquads . get ( i ) ; <nl> @ @ - 660 , 62 + 654 , 40 @ @ public class ForgeHooksClient <nl> } <nl> } <nl> <nl> - int colorMultiplier = segmentColorMultiplier ; <nl> - <nl> - / / If there is no color override , and this quad is tinted , we need to apply IItemColor <nl> - if ( color = = 0xFFFFFFFF & & q . hasTintIndex ( ) ) <nl> - { <nl> - int tintIndex = q . getTintIndex ( ) ; <nl> - <nl> - if ( prevTintIndex ! = tintIndex ) <nl> - { <nl> - colorMultiplier = getColorMultiplier ( stack , tintIndex ) ; <nl> - } <nl> - prevTintIndex = tintIndex ; <nl> - } <nl> - else <nl> - { <nl> - colorMultiplier = color ; <nl> - prevTintIndex = - 1 ; <nl> - } <nl> - <nl> boolean shade = q . shouldApplyDiffuseLighting ( ) ; <nl> <nl> boolean lightingDirty = segmentBlockLight ! = bl | | segmentSkyLight ! = sl ; <nl> - boolean colorDirty = hasLighting & & segmentColorMultiplier ! = colorMultiplier ; <nl> boolean shadeDirty = shade ! = segmentShading ; <nl> <nl> / / If lighting or color data has changed , draw the segment and flush it <nl> - if ( lightingDirty | | colorDirty | | shadeDirty ) <nl> + if ( lightingDirty | | shadeDirty ) <nl> { <nl> if ( i > 0 ) / / Make sure this isn ' t the first quad being processed <nl> { <nl> - drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < i ) , segmentColorDirty , segmentShadingDirty ) ; <nl> + drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < i ) , segmentShadingDirty ) ; <nl> } <nl> segmentBlockLight = bl ; <nl> segmentSkyLight = sl ; <nl> - segmentColorMultiplier = colorMultiplier ; <nl> segmentShading = shade ; <nl> segmentLightingDirty = lightingDirty ; <nl> - segmentColorDirty = colorDirty ; <nl> segmentShadingDirty = shadeDirty ; <nl> - hasLighting = segmentBlockLight > 0 | | segmentSkyLight > 0 ; <nl> + hasLighting = segmentBlockLight > 0 | | segmentSkyLight > 0 | | ! segmentShading ; <nl> } <nl> <nl> segment . add ( q ) ; <nl> } <nl> <nl> - drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < allquads . size ( ) ) , segmentColorDirty , segmentShadingDirty ) ; <nl> + drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < allquads . size ( ) ) , segmentShadingDirty ) ; <nl> <nl> / / Clean up render state if necessary <nl> if ( hasLighting ) <nl> { <nl> - OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE1 , OpenGlHelper . lastBrightnessX , OpenGlHelper . lastBrightnessY ) ; <nl> - GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( 0 , 0 , 0 , 1 ) ) ; <nl> + OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE0 , OpenGlHelper . lastBrightnessX , OpenGlHelper . lastBrightnessY ) ; <nl> + GlStateManager . enableLighting ( ) ; <nl> } <nl> } <nl> <nl> - private static void drawSegment ( ItemRenderer ri , int baseColor , ItemStack stack , List < BakedQuad > segment , int bl , int sl , int tintColor , boolean shade , boolean updateLighting , boolean updateColor , boolean updateShading ) <nl> + private static void drawSegment ( ItemRenderer ri , int baseColor , ItemStack stack , List < BakedQuad > segment , int bl , int sl , boolean shade , boolean updateLighting , boolean updateShading ) <nl> { <nl> BufferBuilder bufferbuilder = Tessellator . getInstance ( ) . getBuffer ( ) ; <nl> bufferbuilder . begin ( GL11 . GL _ QUADS , DefaultVertexFormats . ITEM ) ; <nl> @ @ - 723 , 31 + 695 , 25 @ @ public class ForgeHooksClient <nl> float lastBl = OpenGlHelper . lastBrightnessX ; <nl> float lastSl = OpenGlHelper . lastBrightnessY ; <nl> <nl> - if ( updateLighting | | updateColor | | updateShading ) <nl> + if ( updateShading ) <nl> { <nl> - if ( ! shade ) <nl> + if ( shade ) <nl> { <nl> - / / When diffuse lighting is off , set the emissive buffer to " disable " the GL lighting effects and emulate the block rendering <nl> - float emissive = Math . max ( bl , sl ) / 240f ; <nl> - <nl> - float r = ( tintColor > > > 16 & 0xff ) / 255f ; <nl> - float g = ( tintColor > > > 8 & 0xff ) / 255f ; <nl> - float b = ( tintColor & 0xff ) / 255f ; <nl> - <nl> - GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( emissive * r , emissive * g , emissive * b , 1 ) ) ; <nl> + / / ( Re - ) enable lighting for normal look with shading <nl> + GlStateManager . enableLighting ( ) ; <nl> } <nl> else <nl> { <nl> - / / Otherwise leave it as - is ( or reset it ) so that normal lighting effects take hold <nl> - / / Color will be set instead by downstream RenderItem # renderQuads <nl> - GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( 0 , 0 , 0 , 1 ) ) ; <nl> - } <nl> - <nl> - if ( updateLighting ) <nl> - { <nl> - OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE1 , Math . max ( bl , lastBl ) , Math . max ( sl , lastSl ) ) ; <nl> + / / Disable lighting to simulate a lack of diffuse lighting <nl> + GlStateManager . disableLighting ( ) ; <nl> } <nl> } <nl> + <nl> + if ( updateLighting ) <nl> + { <nl> + / / Force lightmap coords to simulate synthetic lighting <nl> + OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE0 , Math . max ( bl , lastBl ) , Math . max ( sl , lastSl ) ) ; <nl> + } <nl> <nl> ri . renderQuads ( bufferbuilder , segment , baseColor , stack ) ; <nl> Tessellator . getInstance ( ) . draw ( ) ; <nl> @ @ - 759 , 18 + 725 , 6 @ @ public class ForgeHooksClient <nl> segment . clear ( ) ; <nl> } <nl> <nl> - private static int getColorMultiplier ( ItemStack stack , int tintIndex ) <nl> - { <nl> - if ( tintIndex = = - 1 | | stack . isEmpty ( ) ) return 0xFFFFFFFF ; <nl> - <nl> - int colorMultiplier = Minecraft . getInstance ( ) . getItemColors ( ) . getColor ( stack , tintIndex ) ; <nl> - <nl> - / / Always full opacity <nl> - colorMultiplier | = 0xff < < 24 ; / / - 16777216 <nl> - <nl> - return colorMultiplier ; <nl> - } <nl> - <nl> / * * <nl> * internal , relies on fixed format of FaceBakery <nl> * /
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / ForgeHooksClient . java b / src / main / java / net / minecraftforge / client / ForgeHooksClient . java <nl> index 1586cc3 . . 732607d 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / ForgeHooksClient . java <nl> + + + b / src / main / java / net / minecraftforge / client / ForgeHooksClient . java <nl> @ @ - 629 , 9 + 629 , 12 @ @ public class ForgeHooksClient <nl> int segmentSkyLight = - 1 ; <nl> / / Coloring of the current segment <nl> int segmentColorMultiplier = color ; <nl> + / / Diffuse lighting state <nl> + boolean segmentShading = true ; <nl> / / State changed by the current segment <nl> boolean segmentLightingDirty = false ; <nl> boolean segmentColorDirty = false ; <nl> + boolean segmentShadingDirty = false ; <nl> / / If the current segment contains lighting data <nl> boolean hasLighting = false ; <nl> <nl> @ @ - 676 , 28 + 679 , 33 @ @ public class ForgeHooksClient <nl> prevTintIndex = - 1 ; <nl> } <nl> <nl> + boolean shade = q . shouldApplyDiffuseLighting ( ) ; <nl> + <nl> boolean lightingDirty = segmentBlockLight ! = bl | | segmentSkyLight ! = sl ; <nl> boolean colorDirty = hasLighting & & segmentColorMultiplier ! = colorMultiplier ; <nl> + boolean shadeDirty = shade ! = segmentShading ; <nl> <nl> / / If lighting or color data has changed , draw the segment and flush it <nl> - if ( lightingDirty | | colorDirty ) <nl> + if ( lightingDirty | | colorDirty | | shadeDirty ) <nl> { <nl> if ( i > 0 ) / / Make sure this isn ' t the first quad being processed <nl> { <nl> - drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < i ) , segmentColorDirty ) ; <nl> + drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < i ) , segmentColorDirty , segmentShadingDirty ) ; <nl> } <nl> segmentBlockLight = bl ; <nl> segmentSkyLight = sl ; <nl> segmentColorMultiplier = colorMultiplier ; <nl> + segmentShading = shade ; <nl> segmentLightingDirty = lightingDirty ; <nl> segmentColorDirty = colorDirty ; <nl> + segmentShadingDirty = shadeDirty ; <nl> hasLighting = segmentBlockLight > 0 | | segmentSkyLight > 0 ; <nl> } <nl> <nl> segment . add ( q ) ; <nl> } <nl> <nl> - drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < allquads . size ( ) ) , segmentColorDirty ) ; <nl> + drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < allquads . size ( ) ) , segmentColorDirty , segmentShadingDirty ) ; <nl> <nl> / / Clean up render state if necessary <nl> if ( hasLighting ) <nl> @ @ - 707 , 7 + 715 , 7 @ @ public class ForgeHooksClient <nl> } <nl> } <nl> <nl> - private static void drawSegment ( ItemRenderer ri , int baseColor , ItemStack stack , List < BakedQuad > segment , int bl , int sl , int tintColor , boolean updateLighting , boolean updateColor ) <nl> + private static void drawSegment ( ItemRenderer ri , int baseColor , ItemStack stack , List < BakedQuad > segment , int bl , int sl , int tintColor , boolean shade , boolean updateLighting , boolean updateColor , boolean updateShading ) <nl> { <nl> BufferBuilder bufferbuilder = Tessellator . getInstance ( ) . getBuffer ( ) ; <nl> bufferbuilder . begin ( GL11 . GL _ QUADS , DefaultVertexFormats . ITEM ) ; <nl> @ @ - 715 , 16 + 723 , 26 @ @ public class ForgeHooksClient <nl> float lastBl = OpenGlHelper . lastBrightnessX ; <nl> float lastSl = OpenGlHelper . lastBrightnessY ; <nl> <nl> - if ( updateLighting | | updateColor ) <nl> + if ( updateLighting | | updateColor | | updateShading ) <nl> { <nl> - float emissive = Math . max ( bl , sl ) / 240f ; <nl> - <nl> - float r = ( tintColor > > > 16 & 0xff ) / 255f ; <nl> - float g = ( tintColor > > > 8 & 0xff ) / 255f ; <nl> - float b = ( tintColor & 0xff ) / 255f ; <nl> - <nl> - GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( emissive * r , emissive * g , emissive * b , 1 ) ) ; <nl> - <nl> + if ( ! shade ) <nl> + { <nl> + / / When diffuse lighting is off , set the emissive buffer to " disable " the GL lighting effects and emulate the block rendering <nl> + float emissive = Math . max ( bl , sl ) / 240f ; <nl> + <nl> + float r = ( tintColor > > > 16 & 0xff ) / 255f ; <nl> + float g = ( tintColor > > > 8 & 0xff ) / 255f ; <nl> + float b = ( tintColor & 0xff ) / 255f ; <nl> + <nl> + GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( emissive * r , emissive * g , emissive * b , 1 ) ) ; <nl> + } <nl> + else <nl> + { <nl> + / / Otherwise leave it as - is ( or reset it ) so that normal lighting effects take hold <nl> + / / Color will be set instead by downstream RenderItem # renderQuads <nl> + GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( 0 , 0 , 0 , 1 ) ) ; <nl> + } <nl> + <nl> if ( updateLighting ) <nl> { <nl> OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE1 , Math . max ( bl , lastBl ) , Math . max ( sl , lastSl ) ) ;

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / ForgeHooksClient . java b / src / main / java / net / minecraftforge / client / ForgeHooksClient . java 
 index 732607d . . 5dc2e81 100644 
 - - - a / src / main / java / net / minecraftforge / client / ForgeHooksClient . java 
 + + + b / src / main / java / net / minecraftforge / client / ForgeHooksClient . java 
 @ @ - 625 , 22 + 625 , 16 @ @ public class ForgeHooksClient 
 List < BakedQuad > segment = new ArrayList < > ( ) ; 
 
 / / Lighting of the current segment 
 - int segmentBlockLight = - 1 ; 
 - int segmentSkyLight = - 1 ; 
 - / / Coloring of the current segment 
 - int segmentColorMultiplier = color ; 
 + int segmentBlockLight = 0 ; 
 + int segmentSkyLight = 0 ; 
 / / Diffuse lighting state 
 boolean segmentShading = true ; 
 / / State changed by the current segment 
 boolean segmentLightingDirty = false ; 
 - boolean segmentColorDirty = false ; 
 boolean segmentShadingDirty = false ; 
 / / If the current segment contains lighting data 
 boolean hasLighting = false ; 
 
 - / / Tint index cache to avoid unnecessary IItemColor lookups 
 - int prevTintIndex = - 1 ; 
 - 
 for ( int i = 0 ; i < allquads . size ( ) ; i + + ) 
 { 
 BakedQuad q = allquads . get ( i ) ; 
 @ @ - 660 , 62 + 654 , 40 @ @ public class ForgeHooksClient 
 } 
 } 
 
 - int colorMultiplier = segmentColorMultiplier ; 
 - 
 - / / If there is no color override , and this quad is tinted , we need to apply IItemColor 
 - if ( color = = 0xFFFFFFFF & & q . hasTintIndex ( ) ) 
 - { 
 - int tintIndex = q . getTintIndex ( ) ; 
 - 
 - if ( prevTintIndex ! = tintIndex ) 
 - { 
 - colorMultiplier = getColorMultiplier ( stack , tintIndex ) ; 
 - } 
 - prevTintIndex = tintIndex ; 
 - } 
 - else 
 - { 
 - colorMultiplier = color ; 
 - prevTintIndex = - 1 ; 
 - } 
 - 
 boolean shade = q . shouldApplyDiffuseLighting ( ) ; 
 
 boolean lightingDirty = segmentBlockLight ! = bl | | segmentSkyLight ! = sl ; 
 - boolean colorDirty = hasLighting & & segmentColorMultiplier ! = colorMultiplier ; 
 boolean shadeDirty = shade ! = segmentShading ; 
 
 / / If lighting or color data has changed , draw the segment and flush it 
 - if ( lightingDirty | | colorDirty | | shadeDirty ) 
 + if ( lightingDirty | | shadeDirty ) 
 { 
 if ( i > 0 ) / / Make sure this isn ' t the first quad being processed 
 { 
 - drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < i ) , segmentColorDirty , segmentShadingDirty ) ; 
 + drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < i ) , segmentShadingDirty ) ; 
 } 
 segmentBlockLight = bl ; 
 segmentSkyLight = sl ; 
 - segmentColorMultiplier = colorMultiplier ; 
 segmentShading = shade ; 
 segmentLightingDirty = lightingDirty ; 
 - segmentColorDirty = colorDirty ; 
 segmentShadingDirty = shadeDirty ; 
 - hasLighting = segmentBlockLight > 0 | | segmentSkyLight > 0 ; 
 + hasLighting = segmentBlockLight > 0 | | segmentSkyLight > 0 | | ! segmentShading ; 
 } 
 
 segment . add ( q ) ; 
 } 
 
 - drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < allquads . size ( ) ) , segmentColorDirty , segmentShadingDirty ) ; 
 + drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < allquads . size ( ) ) , segmentShadingDirty ) ; 
 
 / / Clean up render state if necessary 
 if ( hasLighting ) 
 { 
 - OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE1 , OpenGlHelper . lastBrightnessX , OpenGlHelper . lastBrightnessY ) ; 
 - GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( 0 , 0 , 0 , 1 ) ) ; 
 + OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE0 , OpenGlHelper . lastBrightnessX , OpenGlHelper . lastBrightnessY ) ; 
 + GlStateManager . enableLighting ( ) ; 
 } 
 } 
 
 - private static void drawSegment ( ItemRenderer ri , int baseColor , ItemStack stack , List < BakedQuad > segment , int bl , int sl , int tintColor , boolean shade , boolean updateLighting , boolean updateColor , boolean updateShading ) 
 + private static void drawSegment ( ItemRenderer ri , int baseColor , ItemStack stack , List < BakedQuad > segment , int bl , int sl , boolean shade , boolean updateLighting , boolean updateShading ) 
 { 
 BufferBuilder bufferbuilder = Tessellator . getInstance ( ) . getBuffer ( ) ; 
 bufferbuilder . begin ( GL11 . GL _ QUADS , DefaultVertexFormats . ITEM ) ; 
 @ @ - 723 , 31 + 695 , 25 @ @ public class ForgeHooksClient 
 float lastBl = OpenGlHelper . lastBrightnessX ; 
 float lastSl = OpenGlHelper . lastBrightnessY ; 
 
 - if ( updateLighting | | updateColor | | updateShading ) 
 + if ( updateShading ) 
 { 
 - if ( ! shade ) 
 + if ( shade ) 
 { 
 - / / When diffuse lighting is off , set the emissive buffer to " disable " the GL lighting effects and emulate the block rendering 
 - float emissive = Math . max ( bl , sl ) / 240f ; 
 - 
 - float r = ( tintColor > > > 16 & 0xff ) / 255f ; 
 - float g = ( tintColor > > > 8 & 0xff ) / 255f ; 
 - float b = ( tintColor & 0xff ) / 255f ; 
 - 
 - GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( emissive * r , emissive * g , emissive * b , 1 ) ) ; 
 + / / ( Re - ) enable lighting for normal look with shading 
 + GlStateManager . enableLighting ( ) ; 
 } 
 else 
 { 
 - / / Otherwise leave it as - is ( or reset it ) so that normal lighting effects take hold 
 - / / Color will be set instead by downstream RenderItem # renderQuads 
 - GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( 0 , 0 , 0 , 1 ) ) ; 
 - } 
 - 
 - if ( updateLighting ) 
 - { 
 - OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE1 , Math . max ( bl , lastBl ) , Math . max ( sl , lastSl ) ) ; 
 + / / Disable lighting to simulate a lack of diffuse lighting 
 + GlStateManager . disableLighting ( ) ; 
 } 
 } 
 + 
 + if ( updateLighting ) 
 + { 
 + / / Force lightmap coords to simulate synthetic lighting 
 + OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE0 , Math . max ( bl , lastBl ) , Math . max ( sl , lastSl ) ) ; 
 + } 
 
 ri . renderQuads ( bufferbuilder , segment , baseColor , stack ) ; 
 Tessellator . getInstance ( ) . draw ( ) ; 
 @ @ - 759 , 18 + 725 , 6 @ @ public class ForgeHooksClient 
 segment . clear ( ) ; 
 } 
 
 - private static int getColorMultiplier ( ItemStack stack , int tintIndex ) 
 - { 
 - if ( tintIndex = = - 1 | | stack . isEmpty ( ) ) return 0xFFFFFFFF ; 
 - 
 - int colorMultiplier = Minecraft . getInstance ( ) . getItemColors ( ) . getColor ( stack , tintIndex ) ; 
 - 
 - / / Always full opacity 
 - colorMultiplier | = 0xff < < 24 ; / / - 16777216 
 - 
 - return colorMultiplier ; 
 - } 
 - 
 / * * 
 * internal , relies on fixed format of FaceBakery 
 * /

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / ForgeHooksClient . java b / src / main / java / net / minecraftforge / client / ForgeHooksClient . java 
 index 1586cc3 . . 732607d 100644 
 - - - a / src / main / java / net / minecraftforge / client / ForgeHooksClient . java 
 + + + b / src / main / java / net / minecraftforge / client / ForgeHooksClient . java 
 @ @ - 629 , 9 + 629 , 12 @ @ public class ForgeHooksClient 
 int segmentSkyLight = - 1 ; 
 / / Coloring of the current segment 
 int segmentColorMultiplier = color ; 
 + / / Diffuse lighting state 
 + boolean segmentShading = true ; 
 / / State changed by the current segment 
 boolean segmentLightingDirty = false ; 
 boolean segmentColorDirty = false ; 
 + boolean segmentShadingDirty = false ; 
 / / If the current segment contains lighting data 
 boolean hasLighting = false ; 
 
 @ @ - 676 , 28 + 679 , 33 @ @ public class ForgeHooksClient 
 prevTintIndex = - 1 ; 
 } 
 
 + boolean shade = q . shouldApplyDiffuseLighting ( ) ; 
 + 
 boolean lightingDirty = segmentBlockLight ! = bl | | segmentSkyLight ! = sl ; 
 boolean colorDirty = hasLighting & & segmentColorMultiplier ! = colorMultiplier ; 
 + boolean shadeDirty = shade ! = segmentShading ; 
 
 / / If lighting or color data has changed , draw the segment and flush it 
 - if ( lightingDirty | | colorDirty ) 
 + if ( lightingDirty | | colorDirty | | shadeDirty ) 
 { 
 if ( i > 0 ) / / Make sure this isn ' t the first quad being processed 
 { 
 - drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < i ) , segmentColorDirty ) ; 
 + drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < i ) , segmentColorDirty , segmentShadingDirty ) ; 
 } 
 segmentBlockLight = bl ; 
 segmentSkyLight = sl ; 
 segmentColorMultiplier = colorMultiplier ; 
 + segmentShading = shade ; 
 segmentLightingDirty = lightingDirty ; 
 segmentColorDirty = colorDirty ; 
 + segmentShadingDirty = shadeDirty ; 
 hasLighting = segmentBlockLight > 0 | | segmentSkyLight > 0 ; 
 } 
 
 segment . add ( q ) ; 
 } 
 
 - drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < allquads . size ( ) ) , segmentColorDirty ) ; 
 + drawSegment ( ri , color , stack , segment , segmentBlockLight , segmentSkyLight , segmentColorMultiplier , segmentShading , segmentLightingDirty & & ( hasLighting | | segment . size ( ) < allquads . size ( ) ) , segmentColorDirty , segmentShadingDirty ) ; 
 
 / / Clean up render state if necessary 
 if ( hasLighting ) 
 @ @ - 707 , 7 + 715 , 7 @ @ public class ForgeHooksClient 
 } 
 } 
 
 - private static void drawSegment ( ItemRenderer ri , int baseColor , ItemStack stack , List < BakedQuad > segment , int bl , int sl , int tintColor , boolean updateLighting , boolean updateColor ) 
 + private static void drawSegment ( ItemRenderer ri , int baseColor , ItemStack stack , List < BakedQuad > segment , int bl , int sl , int tintColor , boolean shade , boolean updateLighting , boolean updateColor , boolean updateShading ) 
 { 
 BufferBuilder bufferbuilder = Tessellator . getInstance ( ) . getBuffer ( ) ; 
 bufferbuilder . begin ( GL11 . GL _ QUADS , DefaultVertexFormats . ITEM ) ; 
 @ @ - 715 , 16 + 723 , 26 @ @ public class ForgeHooksClient 
 float lastBl = OpenGlHelper . lastBrightnessX ; 
 float lastSl = OpenGlHelper . lastBrightnessY ; 
 
 - if ( updateLighting | | updateColor ) 
 + if ( updateLighting | | updateColor | | updateShading ) 
 { 
 - float emissive = Math . max ( bl , sl ) / 240f ; 
 - 
 - float r = ( tintColor > > > 16 & 0xff ) / 255f ; 
 - float g = ( tintColor > > > 8 & 0xff ) / 255f ; 
 - float b = ( tintColor & 0xff ) / 255f ; 
 - 
 - GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( emissive * r , emissive * g , emissive * b , 1 ) ) ; 
 - 
 + if ( ! shade ) 
 + { 
 + / / When diffuse lighting is off , set the emissive buffer to " disable " the GL lighting effects and emulate the block rendering 
 + float emissive = Math . max ( bl , sl ) / 240f ; 
 + 
 + float r = ( tintColor > > > 16 & 0xff ) / 255f ; 
 + float g = ( tintColor > > > 8 & 0xff ) / 255f ; 
 + float b = ( tintColor & 0xff ) / 255f ; 
 + 
 + GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( emissive * r , emissive * g , emissive * b , 1 ) ) ; 
 + } 
 + else 
 + { 
 + / / Otherwise leave it as - is ( or reset it ) so that normal lighting effects take hold 
 + / / Color will be set instead by downstream RenderItem # renderQuads 
 + GL11 . glMaterialfv ( GL11 . GL _ FRONT _ AND _ BACK , GL11 . GL _ EMISSION , RenderHelper . setColorBuffer ( 0 , 0 , 0 , 1 ) ) ; 
 + } 
 + 
 if ( updateLighting ) 
 { 
 OpenGlHelper . glMultiTexCoord2f ( OpenGlHelper . GL _ TEXTURE1 , Math . max ( bl , lastBl ) , Math . max ( sl , lastSl ) ) ;
