BLEU SCORE: 0.033864985683445356

TEST MSG: Net Handshake phase 1 . Validates pairings on client and server .
GENERATED MSG: A much more straightforward networking system .

TEST DIFF (one line): diff - - git a / build . gradle b / build . gradle <nl> index e250d69 . . 00f06c1 100644 <nl> - - - a / build . gradle <nl> + + + b / build . gradle <nl> @ @ - 87 , 6 + 87 , 7 @ @ project ( ' : forge ' ) { <nl> target : ' fmldevserver ' <nl> ] <nl> } <nl> + mcVersion = ' 1 . 13 ' <nl> } <nl> applyPatches { <nl> canonicalizeAccess true <nl> diff - - git a / patches / minecraft / net / minecraft / item / Item . java . patch b / patches / minecraft / net / minecraft / item / Item . java . patch <nl> index 736b9ea . . 775a125 100644 <nl> - - - a / patches / minecraft / net / minecraft / item / Item . java . patch <nl> + + + b / patches / minecraft / net / minecraft / item / Item . java . patch <nl> @ @ - 60 , 7 + 60 , 7 @ @ <nl> float f7 = f2 * f4 ; <nl> - double d3 = 5 . 0D ; <nl> - Vec3d vec3d1 = vec3d . add ( ( double ) f6 * 5 . 0D , ( double ) f5 * 5 . 0D , ( double ) f7 * 5 . 0D ) ; <nl> - + double d3 = playerIn . getEntityAttribute ( EntityPlayer . REACH _ DISTANCE ) . getAttributeValue ( ) ; <nl> + + double d3 = 6 ; <nl> + Vec3d vec3d1 = vec3d . add ( ( double ) f6 * d3 , ( double ) f5 * d3 , ( double ) f7 * d3 ) ; <nl> return worldIn . func _ 200259 _ a ( vec3d , vec3d1 , useLiquids ? RayTraceFluidMode . SOURCE _ ONLY : RayTraceFluidMode . NEVER , false , false ) ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessage . java b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessage . java <nl> new file mode 100644 <nl> index 0000000 . . 41f14c0 <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessage . java <nl> @ @ - 0 , 0 + 1 , 89 @ @ <nl> + package net . minecraftforge . fml . network ; <nl> + <nl> + import net . minecraft . nbt . INBTBase ; <nl> + import net . minecraft . nbt . NBTTagCompound ; <nl> + import net . minecraft . nbt . NBTTagList ; <nl> + import net . minecraft . nbt . NBTTagString ; <nl> + import net . minecraft . network . PacketBuffer ; <nl> + import net . minecraftforge . fml . ModList ; <nl> + import net . minecraftforge . fml . loading . moddiscovery . ModInfo ; <nl> + <nl> + import java . util . List ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + class FMLHandshakeMessage <nl> + { <nl> + / / Login index sequence number <nl> + private int index ; <nl> + void setPacketIndexSequence ( int i ) <nl> + { <nl> + this . index = i ; <nl> + } <nl> + <nl> + int getPacketIndexSequence ( ) <nl> + { <nl> + return index ; <nl> + } <nl> + <nl> + / * * <nl> + * Server to client " list of mods " . Always first handshake message . <nl> + * / <nl> + static class S2CModList extends FMLHandshakeMessage <nl> + { <nl> + private NBTTagList channels ; <nl> + private List < String > modList ; <nl> + <nl> + S2CModList ( ) { <nl> + this . modList = ModList . get ( ) . getMods ( ) . stream ( ) . map ( ModInfo : : getModId ) . collect ( Collectors . toList ( ) ) ; <nl> + } <nl> + <nl> + S2CModList ( NBTTagCompound nbtTagCompound ) <nl> + { <nl> + this . modList = nbtTagCompound . getTagList ( " modlist " , 8 ) . stream ( ) . map ( INBTBase : : getString ) . collect ( Collectors . toList ( ) ) ; <nl> + this . channels = nbtTagCompound . getTagList ( " channels " , 10 ) ; <nl> + } <nl> + <nl> + static S2CModList decode ( PacketBuffer packetBuffer ) <nl> + { <nl> + final NBTTagCompound nbtTagCompound = packetBuffer . readCompoundTag ( ) ; <nl> + return new S2CModList ( nbtTagCompound ) ; <nl> + } <nl> + <nl> + void encode ( PacketBuffer packetBuffer ) <nl> + { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setTag ( " modlist " , modList . stream ( ) . map ( NBTTagString : : new ) . collect ( Collectors . toCollection ( NBTTagList : : new ) ) ) ; <nl> + tag . setTag ( " channels " , NetworkRegistry . buildChannelVersions ( ) ) ; <nl> + packetBuffer . writeCompoundTag ( tag ) ; <nl> + } <nl> + <nl> + String getModList ( ) { <nl> + return String . join ( " , " , modList ) ; <nl> + } <nl> + <nl> + NBTTagList getChannels ( ) { <nl> + return this . channels ; <nl> + } <nl> + } <nl> + <nl> + static class C2SModListReply extends S2CModList <nl> + { <nl> + C2SModListReply ( ) { <nl> + super ( ) ; <nl> + } <nl> + <nl> + C2SModListReply ( final NBTTagCompound buffer ) { <nl> + super ( buffer ) ; <nl> + } <nl> + <nl> + static C2SModListReply decode ( PacketBuffer buffer ) <nl> + { <nl> + return new C2SModListReply ( buffer . readCompoundTag ( ) ) ; <nl> + } <nl> + <nl> + public void encode ( PacketBuffer buffer ) <nl> + { <nl> + super . encode ( buffer ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLNetworking . java b / src / main / java / net / minecraftforge / fml / network / FMLNetworking . java <nl> index 4c5a509 . . 90d86d9 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / FMLNetworking . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / FMLNetworking . java <nl> @ @ - 1 , 14 + 1 , 9 @ @ <nl> package net . minecraftforge . fml . network ; <nl> <nl> import io . netty . util . AttributeKey ; <nl> - import net . minecraft . nbt . INBTBase ; <nl> - import net . minecraft . nbt . NBTTagCompound ; <nl> - import net . minecraft . nbt . NBTTagList ; <nl> - import net . minecraft . nbt . NBTTagString ; <nl> import net . minecraft . network . NetworkManager ; <nl> - import net . minecraft . network . PacketBuffer ; <nl> - import net . minecraftforge . fml . ModList ; <nl> - import net . minecraftforge . fml . loading . moddiscovery . ModInfo ; <nl> + import net . minecraft . util . text . ITextComponent ; <nl> + import net . minecraft . util . text . TextComponentString ; <nl> import net . minecraftforge . fml . network . simple . SimpleChannel ; <nl> import org . apache . logging . log4j . LogManager ; <nl> import org . apache . logging . log4j . Logger ; <nl> @ @ - 19 , 7 + 14 , 6 @ @ import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . List ; <nl> import java . util . function . Supplier ; <nl> - import java . util . stream . Collectors ; <nl> <nl> public class FMLNetworking <nl> { <nl> @ @ - 49 , 24 + 43 , 24 @ @ public class FMLNetworking <nl> <nl> public static class FMLHandshake { <nl> private static SimpleChannel channel ; <nl> - private static List < Supplier < HandshakeMessage > > messages = Arrays . asList ( HandshakeMessage . S2CModList : : new ) ; <nl> - private List < HandshakeMessage > sentMessages = new ArrayList < > ( ) ; <nl> + private static List < Supplier < FMLHandshakeMessage > > messages = Arrays . asList ( FMLHandshakeMessage . S2CModList : : new ) ; <nl> + private List < FMLHandshakeMessage > sentMessages = new ArrayList < > ( ) ; <nl> static { <nl> channel = NetworkRegistry . ChannelBuilder . named ( NetworkHooks . FMLHANDSHAKE ) . <nl> clientAcceptedVersions ( a - > true ) . <nl> serverAcceptedVersions ( a - > true ) . <nl> networkProtocolVersion ( ( ) - > NetworkHooks . NETVERSION ) . <nl> simpleChannel ( ) ; <nl> - channel . messageBuilder ( HandshakeMessage . S2CModList . class , 1 ) . <nl> - decoder ( HandshakeMessage . S2CModList : : decode ) . <nl> - encoder ( HandshakeMessage . S2CModList : : encode ) . <nl> - loginIndex ( HandshakeMessage . S2CModList : : setPacketIndexSequence ) . <nl> + channel . messageBuilder ( FMLHandshakeMessage . S2CModList . class , 1 ) . <nl> + decoder ( FMLHandshakeMessage . S2CModList : : decode ) . <nl> + encoder ( FMLHandshakeMessage . S2CModList : : encode ) . <nl> + loginIndex ( FMLHandshakeMessage : : getPacketIndexSequence , FMLHandshakeMessage : : setPacketIndexSequence ) . <nl> consumer ( ( m , c ) - > getHandshake ( c ) . handleServerModListOnClient ( m , c ) ) . <nl> add ( ) ; <nl> - channel . messageBuilder ( HandshakeMessage . C2SModListReply . class , 2 ) . <nl> - loginIndex ( HandshakeMessage : : setPacketIndexSequence ) . <nl> - decoder ( HandshakeMessage . C2SModListReply : : decode ) . <nl> - encoder ( HandshakeMessage . C2SModListReply : : encode ) . <nl> + channel . messageBuilder ( FMLHandshakeMessage . C2SModListReply . class , 2 ) . <nl> + loginIndex ( FMLHandshakeMessage : : getPacketIndexSequence , FMLHandshakeMessage : : setPacketIndexSequence ) . <nl> + decoder ( FMLHandshakeMessage . C2SModListReply : : decode ) . <nl> + encoder ( FMLHandshakeMessage . C2SModListReply : : encode ) . <nl> consumer ( ( m , c ) - > getHandshake ( c ) . handleClientModListOnServer ( m , c ) ) . <nl> add ( ) ; <nl> } <nl> @ @ - 82 , 30 + 76 , 63 @ @ public class FMLNetworking <nl> this . manager = networkManager ; <nl> } <nl> <nl> - public void handleServerModListOnClient ( HandshakeMessage . S2CModList serverModList , Supplier < NetworkEvent . Context > c ) <nl> + private void handleServerModListOnClient ( FMLHandshakeMessage . S2CModList serverModList , Supplier < NetworkEvent . Context > c ) <nl> { <nl> - LOGGER . debug ( FMLHSMARKER , " Received S2CModList packet with index { } " , serverModList . getPacketIndexSequence ( ) ) ; <nl> + LOGGER . debug ( FMLHSMARKER , " Logging into server with mod list [ { } ] " , serverModList . getModList ( ) ) ; <nl> + boolean accepted = NetworkRegistry . validateClientChannels ( serverModList . getChannels ( ) ) ; <nl> c . get ( ) . setPacketHandled ( true ) ; <nl> - final HandshakeMessage . C2SModListReply reply = new HandshakeMessage . C2SModListReply ( ) ; <nl> - channel . sendLogin ( reply , c . get ( ) . getNetworkManager ( ) , c . get ( ) . getDirection ( ) . reply ( ) , reply . getPacketIndexSequence ( ) ) ; <nl> + if ( ! accepted ) { <nl> + LOGGER . error ( FMLHSMARKER , " Terminating connection with server , mismatched mod list " ) ; <nl> + c . get ( ) . getNetworkManager ( ) . closeChannel ( new TextComponentString ( " Connection closed - mismatched mod channel list " ) ) ; <nl> + return ; <nl> + } <nl> + final FMLHandshakeMessage . C2SModListReply reply = new FMLHandshakeMessage . C2SModListReply ( ) ; <nl> + reply . setPacketIndexSequence ( serverModList . getPacketIndexSequence ( ) ) ; <nl> + channel . reply ( reply , c . get ( ) ) ; <nl> LOGGER . debug ( FMLHSMARKER , " Sent C2SModListReply packet with index { } " , reply . getPacketIndexSequence ( ) ) ; <nl> } <nl> <nl> - private void handleClientModListOnServer ( HandshakeMessage . C2SModListReply m , Supplier < NetworkEvent . Context > c ) <nl> + private void handleClientModListOnServer ( FMLHandshakeMessage . C2SModListReply clientModList , Supplier < NetworkEvent . Context > c ) <nl> { <nl> - LOGGER . debug ( FMLHSMARKER , " Received C2SModListReply with index { } " , m . getPacketIndexSequence ( ) ) ; <nl> - final HandshakeMessage message = this . sentMessages . stream ( ) . filter ( ob - > ob . getPacketIndexSequence ( ) = = m . getPacketIndexSequence ( ) ) . findFirst ( ) . orElseThrow ( ( ) - > new RuntimeException ( " Unexpected reply from client " ) ) ; <nl> + LOGGER . debug ( FMLHSMARKER , " Received client connection with modlist [ { } ] " , clientModList . getModList ( ) ) ; <nl> + final FMLHandshakeMessage message = this . sentMessages . stream ( ) . filter ( ob - > ob . getPacketIndexSequence ( ) = = clientModList . getPacketIndexSequence ( ) ) . findFirst ( ) . orElseThrow ( ( ) - > new RuntimeException ( " Unexpected reply from client " ) ) ; <nl> boolean removed = this . sentMessages . remove ( message ) ; <nl> + boolean accepted = NetworkRegistry . validateServerChannels ( clientModList . getChannels ( ) ) ; <nl> c . get ( ) . setPacketHandled ( true ) ; <nl> + if ( ! accepted ) { <nl> + LOGGER . error ( FMLHSMARKER , " Terminating connection with client , mismatched mod list " ) ; <nl> + c . get ( ) . getNetworkManager ( ) . closeChannel ( new TextComponentString ( " Connection closed - mismatched mod channel list " ) ) ; <nl> + return ; <nl> + } <nl> LOGGER . debug ( FMLHSMARKER , " Cleared original message { } " , removed ) ; <nl> } <nl> <nl> + / * * <nl> + * Design of handshake . <nl> + * <nl> + * After { @ link net . minecraft . server . network . NetHandlerLoginServer } enters the { @ link net . minecraft . server . network . NetHandlerLoginServer . LoginState # NEGOTIATING } <nl> + * state , this will be ticked once per server tick . <nl> + * <nl> + * FML will send packets , from Server to Client , from the messages queue until the queue is drained . Each message <nl> + * will be indexed , and placed into the " pending acknowledgement " queue . <nl> + * <nl> + * The client should send an acknowledgement for every packet that has a positive index , containing <nl> + * that index ( and maybe other data as well ) . <nl> + * <nl> + * As indexed packets are received at the server , they will be removed from the " pending acknowledgement " queue . <nl> + * <nl> + * Once the pending queue is drained , this method returns true - indicating that login processing can proceed to <nl> + * the next step . <nl> + * <nl> + * @ return true if there is no more need to tick this login connection . <nl> + * / <nl> public boolean tickServer ( ) <nl> { <nl> if ( packetPosition < messages . size ( ) ) { <nl> - final HandshakeMessage message = messages . get ( packetPosition ) . get ( ) ; <nl> + final FMLHandshakeMessage message = messages . get ( packetPosition ) . get ( ) ; <nl> + message . setPacketIndexSequence ( packetPosition ) ; <nl> LOGGER . debug ( FMLHSMARKER , " Sending ticking packet { } index { } " , message . getClass ( ) . getName ( ) , message . getPacketIndexSequence ( ) ) ; <nl> - channel . sendLogin ( message , this . manager , this . direction , packetPosition ) ; <nl> + channel . sendTo ( message , this . manager , this . direction ) ; <nl> sentMessages . add ( message ) ; <nl> packetPosition + + ; <nl> } <nl> @ @ - 121 , 57 + 148 , 4 @ @ public class FMLNetworking <nl> } <nl> <nl> <nl> - static class HandshakeMessage <nl> - { <nl> - private int index ; <nl> - public void setPacketIndexSequence ( int i ) <nl> - { <nl> - this . index = i ; <nl> - } <nl> - <nl> - public int getPacketIndexSequence ( ) <nl> - { <nl> - return index ; <nl> - } <nl> - <nl> - static class S2CModList extends HandshakeMessage <nl> - { <nl> - private List < String > modList ; <nl> - <nl> - S2CModList ( ) { <nl> - this . modList = ModList . get ( ) . getMods ( ) . stream ( ) . map ( ModInfo : : getModId ) . collect ( Collectors . toList ( ) ) ; <nl> - } <nl> - <nl> - S2CModList ( NBTTagCompound nbtTagCompound ) <nl> - { <nl> - this . modList = nbtTagCompound . getTagList ( " list " , 8 ) . stream ( ) . map ( INBTBase : : getString ) . collect ( Collectors . toList ( ) ) ; <nl> - } <nl> - <nl> - public static S2CModList decode ( PacketBuffer packetBuffer ) <nl> - { <nl> - final NBTTagCompound nbtTagCompound = packetBuffer . readCompoundTag ( ) ; <nl> - return new S2CModList ( nbtTagCompound ) ; <nl> - } <nl> - <nl> - public void encode ( PacketBuffer packetBuffer ) <nl> - { <nl> - NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> - tag . setTag ( " list " , modList . stream ( ) . map ( NBTTagString : : new ) . collect ( Collectors . toCollection ( NBTTagList : : new ) ) ) ; <nl> - packetBuffer . writeCompoundTag ( tag ) ; <nl> - } <nl> - } <nl> - <nl> - static class C2SModListReply extends HandshakeMessage <nl> - { <nl> - public static C2SModListReply decode ( PacketBuffer buffer ) <nl> - { <nl> - return new C2SModListReply ( ) ; <nl> - } <nl> - <nl> - public void encode ( PacketBuffer buffer ) <nl> - { <nl> - <nl> - } <nl> - } <nl> - } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkDirection . java b / src / main / java / net / minecraftforge / fml / network / NetworkDirection . java <nl> index bf55c75 . . 20a7a65 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkDirection . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkDirection . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import net . minecraft . network . play . server . SPacketCustomPayload ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . fml . LogicalSide ; <nl> import net . minecraftforge . fml . UnsafeHacks ; <nl> + import org . apache . commons . lang3 . tuple . Pair ; <nl> <nl> import java . util . function . BiFunction ; <nl> import java . util . function . Function ; <nl> @ @ - 84 , 12 + 85 , 12 @ @ public enum NetworkDirection <nl> } <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> - public < T extends Packet < ? > > ICustomPacket < T > buildPacket ( PacketBuffer packetBuffer , ResourceLocation channelName , int index ) <nl> + public < T extends Packet < ? > > ICustomPacket < T > buildPacket ( Pair < PacketBuffer , Integer > packetData , ResourceLocation channelName ) <nl> { <nl> ICustomPacket < T > packet = ( ICustomPacket < T > ) UnsafeHacks . newInstance ( getPacketClass ( ) ) ; <nl> packet . setName ( channelName ) ; <nl> - packet . setData ( packetBuffer ) ; <nl> - packet . setIndex ( index ) ; <nl> + packet . setData ( packetData . getLeft ( ) ) ; <nl> + packet . setIndex ( packetData . getRight ( ) ) ; <nl> return packet ; <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java b / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java <nl> index 5c129be . . ae48e42 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java <nl> @ @ - 32 , 10 + 32 , 13 @ @ public class NetworkEvent extends Event <nl> { <nl> private final PacketBuffer payload ; <nl> private final Supplier < Context > source ; <nl> - private NetworkEvent ( ICustomPacket < ? > payload , Supplier < Context > source ) <nl> + private final int loginIndex ; <nl> + <nl> + private NetworkEvent ( final ICustomPacket < ? > payload , final Supplier < Context > source ) <nl> { <nl> this . payload = payload . getData ( ) ; <nl> this . source = source ; <nl> + this . loginIndex = payload . getIndex ( ) ; <nl> } <nl> <nl> public PacketBuffer getPayload ( ) <nl> @ @ - 48 , 9 + 51 , 13 @ @ public class NetworkEvent extends Event <nl> return source ; <nl> } <nl> <nl> - public static class ServerCustomPayloadEvent extends NetworkEvent <nl> + public int getLoginIndex ( ) <nl> { <nl> + return loginIndex ; <nl> + } <nl> <nl> + public static class ServerCustomPayloadEvent extends NetworkEvent <nl> + { <nl> ServerCustomPayloadEvent ( final ICustomPacket < ? > payload , final Supplier < Context > source ) { <nl> super ( payload , source ) ; <nl> } <nl> @ @ - 61 , 39 + 68 , 20 @ @ public class NetworkEvent extends Event <nl> super ( payload , source ) ; <nl> } <nl> } <nl> - public static class ServerCustomPayloadLoginEvent extends ServerCustomPayloadEvent implements ILoginIndex { <nl> - private final int index ; <nl> - <nl> + public static class ServerCustomPayloadLoginEvent extends ServerCustomPayloadEvent { <nl> ServerCustomPayloadLoginEvent ( ICustomPacket < ? > payload , Supplier < Context > source ) <nl> { <nl> super ( payload , source ) ; <nl> - this . index = payload . getIndex ( ) ; <nl> - } <nl> - <nl> - public int getIndex ( ) <nl> - { <nl> - return index ; <nl> } <nl> } <nl> <nl> - public static class ClientCustomPayloadLoginEvent extends ClientCustomPayloadEvent implements ILoginIndex { <nl> - private final int index ; <nl> - <nl> + public static class ClientCustomPayloadLoginEvent extends ClientCustomPayloadEvent { <nl> ClientCustomPayloadLoginEvent ( ICustomPacket < ? > payload , Supplier < Context > source ) <nl> { <nl> super ( payload , source ) ; <nl> - this . index = payload . getIndex ( ) ; <nl> - } <nl> - <nl> - public int getIndex ( ) <nl> - { <nl> - return index ; <nl> } <nl> } <nl> <nl> - public interface ILoginIndex { <nl> - int getIndex ( ) ; <nl> - } <nl> / * * <nl> * Context for { @ link NetworkEvent } <nl> * / <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java b / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java <nl> index f71cc23 . . b8efef7 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ <nl> <nl> package net . minecraftforge . fml . network ; <nl> <nl> + import net . minecraft . nbt . INBTBase ; <nl> import net . minecraft . network . NetworkManager ; <nl> import net . minecraft . network . PacketBuffer ; <nl> import net . minecraft . util . ResourceLocation ; <nl> @ @ - 38 , 7 + 39 , 7 @ @ public class NetworkInstance <nl> } <nl> <nl> private final ResourceLocation channelName ; <nl> - private final Supplier < String > networkProtocolVersion ; <nl> + private final String networkProtocolVersion ; <nl> private final Predicate < String > clientAcceptedVersions ; <nl> private final Predicate < String > serverAcceptedVersions ; <nl> private final IEventBus networkEventBus ; <nl> @ @ - 46 , 7 + 47 , 7 @ @ public class NetworkInstance <nl> NetworkInstance ( ResourceLocation channelName , Supplier < String > networkProtocolVersion , Predicate < String > clientAcceptedVersions , Predicate < String > serverAcceptedVersions ) <nl> { <nl> this . channelName = channelName ; <nl> - this . networkProtocolVersion = networkProtocolVersion ; <nl> + this . networkProtocolVersion = networkProtocolVersion . get ( ) ; <nl> this . clientAcceptedVersions = clientAcceptedVersions ; <nl> this . serverAcceptedVersions = serverAcceptedVersions ; <nl> this . networkEventBus = IEventBus . create ( this : : handleError ) ; <nl> @ @ - 78 , 4 + 79 , 15 @ @ public class NetworkInstance <nl> } <nl> <nl> <nl> + String getNetworkProtocolVersion ( ) { <nl> + return networkProtocolVersion ; <nl> + } <nl> + <nl> + boolean tryServerVersionOnClient ( final String serverVersion ) { <nl> + return this . clientAcceptedVersions . test ( serverVersion ) ; <nl> + } <nl> + <nl> + boolean tryClientVersionOnServer ( final String clientVersion ) { <nl> + return this . serverAcceptedVersions . test ( clientVersion ) ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> index 4629fba . . 7439119 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> @ @ - 19 , 10 + 19 , 12 @ @ <nl> <nl> package net . minecraftforge . fml . network ; <nl> <nl> - import io . netty . util . AttributeKey ; <nl> + import net . minecraft . nbt . NBTTagCompound ; <nl> + import net . minecraft . nbt . NBTTagList ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . fml . network . event . EventNetworkChannel ; <nl> import net . minecraftforge . fml . network . simple . SimpleChannel ; <nl> + import org . apache . commons . lang3 . tuple . Pair ; <nl> import org . apache . logging . log4j . LogManager ; <nl> import org . apache . logging . log4j . Logger ; <nl> import org . apache . logging . log4j . Marker ; <nl> @ @ - 35 , 6 + 37 , 7 @ @ import java . util . Map ; <nl> import java . util . Optional ; <nl> import java . util . function . Predicate ; <nl> import java . util . function . Supplier ; <nl> + import java . util . stream . Collectors ; <nl> <nl> public class NetworkRegistry <nl> { <nl> @ @ - 71 , 6 + 74 , 53 @ @ public class NetworkRegistry <nl> return Optional . ofNullable ( instances . get ( resourceLocation ) ) ; <nl> } <nl> <nl> + static NBTTagList buildChannelVersions ( ) { <nl> + return instances . entrySet ( ) . stream ( ) . map ( e - > { <nl> + final NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setString ( " name " , e . getKey ( ) . toString ( ) ) ; <nl> + tag . setString ( " version " , e . getValue ( ) . getNetworkProtocolVersion ( ) ) ; <nl> + return tag ; <nl> + } ) . collect ( Collectors . toCollection ( NBTTagList : : new ) ) ; <nl> + } <nl> + <nl> + static boolean validateClientChannels ( final NBTTagList channels ) { <nl> + final List < Pair < ResourceLocation , Boolean > > results = channels . stream ( ) . map ( t - > { <nl> + NBTTagCompound tag = ( NBTTagCompound ) t ; <nl> + final ResourceLocation rl = new ResourceLocation ( tag . getString ( " name " ) ) ; <nl> + final String serverVersion = tag . getString ( " version " ) ; <nl> + boolean test = instances . get ( rl ) . tryServerVersionOnClient ( serverVersion ) ; <nl> + LOGGER . debug ( NETREGISTRY , " Channel { } : Client version test of ' ' { } ' ' from server : { } " , rl , serverVersion , test ) ; <nl> + return Pair . of ( rl , test ) ; <nl> + } ) . filter ( p - > ! p . getRight ( ) ) . collect ( Collectors . toList ( ) ) ; <nl> + <nl> + if ( ! results . isEmpty ( ) ) { <nl> + LOGGER . error ( NETREGISTRY , " Channels [ { } ] rejected their server side version number " , <nl> + results . stream ( ) . map ( Pair : : getLeft ) . map ( Object : : toString ) . collect ( Collectors . joining ( " , " ) ) ) ; <nl> + return false ; <nl> + } <nl> + LOGGER . debug ( NETREGISTRY , " Accepting channel list from server " ) ; <nl> + return true ; <nl> + } <nl> + <nl> + static boolean validateServerChannels ( final NBTTagList channels ) { <nl> + final List < Pair < ResourceLocation , Boolean > > results = channels . stream ( ) . map ( t - > { <nl> + NBTTagCompound tag = ( NBTTagCompound ) t ; <nl> + final ResourceLocation rl = new ResourceLocation ( tag . getString ( " name " ) ) ; <nl> + final String clientVersion = tag . getString ( " version " ) ; <nl> + boolean test = instances . get ( rl ) . tryClientVersionOnServer ( clientVersion ) ; <nl> + LOGGER . debug ( NETREGISTRY , " Channel { } : Server version test of ' ' { } ' ' from client : { } " , rl , clientVersion , test ) ; <nl> + return Pair . of ( rl , test ) ; <nl> + } ) . filter ( p - > ! p . getRight ( ) ) . collect ( Collectors . toList ( ) ) ; <nl> + <nl> + if ( ! results . isEmpty ( ) ) { <nl> + LOGGER . error ( NETREGISTRY , " Channels [ { } ] rejected their client side version number " , <nl> + results . stream ( ) . map ( Pair : : getLeft ) . map ( Object : : toString ) . collect ( Collectors . joining ( " , " ) ) ) ; <nl> + return false ; <nl> + } <nl> + LOGGER . debug ( NETREGISTRY , " Accepting channel list from client " ) ; <nl> + return true ; <nl> + } <nl> + <nl> public static class ChannelBuilder { <nl> private ResourceLocation channelName ; <nl> private Supplier < String > networkProtocolVersion ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java b / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java <nl> index 1a78543 . . 9bcfa9d 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java <nl> @ @ - 21 , 9 + 21 , 7 @ @ package net . minecraftforge . fml . network . simple ; <nl> <nl> import it . unimi . dsi . fastutil . objects . Object2ObjectArrayMap ; <nl> import it . unimi . dsi . fastutil . shorts . Short2ObjectArrayMap ; <nl> - import net . minecraft . network . Packet ; <nl> import net . minecraft . network . PacketBuffer ; <nl> - import net . minecraftforge . fml . network . ICustomPacket ; <nl> import net . minecraftforge . fml . network . NetworkEvent ; <nl> import org . apache . logging . log4j . LogManager ; <nl> import org . apache . logging . log4j . Logger ; <nl> @ @ - 32 , 7 + 30 , 6 @ @ import org . apache . logging . log4j . MarkerManager ; <nl> <nl> import java . util . Optional ; <nl> import java . util . function . BiConsumer ; <nl> - import java . util . function . BiFunction ; <nl> import java . util . function . Function ; <nl> import java . util . function . Supplier ; <nl> <nl> @ @ - 40 , 69 + 37 , 86 @ @ public class IndexedMessageCodec <nl> { <nl> private static final Logger LOGGER = LogManager . getLogger ( ) ; <nl> private static final Marker SIMPLENET = MarkerManager . getMarker ( " SIMPLENET " ) ; <nl> - private final Short2ObjectArrayMap < CodecIndex < ? > > indicies = new Short2ObjectArrayMap < > ( ) ; <nl> - private final Object2ObjectArrayMap < Class < ? > , CodecIndex < ? > > types = new Object2ObjectArrayMap < > ( ) ; <nl> + private final Short2ObjectArrayMap < MessageHandler < ? > > indicies = new Short2ObjectArrayMap < > ( ) ; <nl> + private final Object2ObjectArrayMap < Class < ? > , MessageHandler < ? > > types = new Object2ObjectArrayMap < > ( ) ; <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + public < MSG > MessageHandler < MSG > findMessageType ( final MSG msgToReply ) { <nl> + return ( MessageHandler < MSG > ) types . get ( msgToReply . getClass ( ) ) ; <nl> + } <nl> <nl> @ SuppressWarnings ( " OptionalUsedAsFieldOrParameterType " ) <nl> - public class CodecIndex < MSG > <nl> + class MessageHandler < MSG > <nl> { <nl> - <nl> private final Optional < BiConsumer < MSG , PacketBuffer > > encoder ; <nl> private final Optional < Function < PacketBuffer , MSG > > decoder ; <nl> private final int index ; <nl> private final BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ; <nl> private final Class < MSG > messageType ; <nl> - private Optional < BiConsumer < MSG , Integer > > loginIndexFunction ; <nl> + private Optional < BiConsumer < MSG , Integer > > loginIndexSetter ; <nl> + private Optional < Function < MSG , Integer > > loginIndexGetter ; <nl> <nl> - public CodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) <nl> + public MessageHandler ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) <nl> { <nl> this . index = index ; <nl> this . messageType = messageType ; <nl> this . encoder = Optional . ofNullable ( encoder ) ; <nl> this . decoder = Optional . ofNullable ( decoder ) ; <nl> this . messageConsumer = messageConsumer ; <nl> - this . loginIndexFunction = Optional . empty ( ) ; <nl> + this . loginIndexGetter = Optional . empty ( ) ; <nl> + this . loginIndexSetter = Optional . empty ( ) ; <nl> indicies . put ( ( short ) ( index & 0xff ) , this ) ; <nl> types . put ( messageType , this ) ; <nl> } <nl> <nl> - public void setLoginIndexFunction ( BiConsumer < MSG , Integer > loginIndexFunction ) <nl> + void setLoginIndexSetter ( BiConsumer < MSG , Integer > loginIndexSetter ) <nl> { <nl> - this . loginIndexFunction = Optional . of ( loginIndexFunction ) ; <nl> + this . loginIndexSetter = Optional . of ( loginIndexSetter ) ; <nl> } <nl> <nl> - public Optional < BiConsumer < MSG , Integer > > getLoginIndexFunction ( ) { <nl> - return this . loginIndexFunction ; <nl> + Optional < BiConsumer < MSG , Integer > > getLoginIndexSetter ( ) { <nl> + return this . loginIndexSetter ; <nl> + } <nl> + <nl> + void setLoginIndexGetter ( Function < MSG , Integer > loginIndexGetter ) { <nl> + this . loginIndexGetter = Optional . of ( loginIndexGetter ) ; <nl> + } <nl> + <nl> + public Optional < Function < MSG , Integer > > getLoginIndexGetter ( ) { <nl> + return this . loginIndexGetter ; <nl> } <nl> - } <nl> - private static < M > void tryDecode ( PacketBuffer payload , Supplier < NetworkEvent . Context > context , CodecIndex < M > codec ) <nl> - { <nl> - codec . decoder . map ( d - > d . apply ( payload ) ) . ifPresent ( m - > codec . messageConsumer . accept ( m , context ) ) ; <nl> } <nl> <nl> - private static < M > void tryDecode ( PacketBuffer payload , Supplier < NetworkEvent . Context > context , int payloadIndex , CodecIndex < M > codec ) <nl> + private static < M > void tryDecode ( PacketBuffer payload , Supplier < NetworkEvent . Context > context , int payloadIndex , MessageHandler < M > codec ) <nl> { <nl> codec . decoder . map ( d - > d . apply ( payload ) ) . <nl> - map ( p - > { codec . getLoginIndexFunction ( ) . ifPresent ( f - > f . accept ( p , payloadIndex ) ) ; return p ; } ) . <nl> - ifPresent ( m - > codec . messageConsumer . accept ( m , context ) ) ; <nl> + map ( p - > { <nl> + / / Only run the loginIndex function for payloadIndexed packets ( login ) <nl> + if ( payloadIndex ! = Integer . MIN _ VALUE ) <nl> + { <nl> + codec . getLoginIndexSetter ( ) . ifPresent ( f - > f . accept ( p , payloadIndex ) ) ; <nl> + } <nl> + return p ; <nl> + } ) . ifPresent ( m - > codec . messageConsumer . accept ( m , context ) ) ; <nl> } <nl> <nl> - private static < M > void tryEncode ( PacketBuffer target , M message , CodecIndex < M > codec ) { <nl> + private static < M > int tryEncode ( PacketBuffer target , M message , MessageHandler < M > codec ) { <nl> codec . encoder . ifPresent ( encoder - > { <nl> target . writeByte ( codec . index & 0xff ) ; <nl> encoder . accept ( message , target ) ; <nl> } ) ; <nl> + return codec . loginIndexGetter . orElse ( m - > Integer . MIN _ VALUE ) . apply ( message ) ; <nl> } <nl> <nl> - public < MSG > void build ( MSG message , PacketBuffer target ) <nl> + public < MSG > int build ( MSG message , PacketBuffer target ) <nl> { <nl> @ SuppressWarnings ( " unchecked " ) <nl> - CodecIndex < MSG > codecIndex = ( CodecIndex < MSG > ) types . get ( message . getClass ( ) ) ; <nl> - if ( codecIndex = = null ) { <nl> + MessageHandler < MSG > messageHandler = ( MessageHandler < MSG > ) types . get ( message . getClass ( ) ) ; <nl> + if ( messageHandler = = null ) { <nl> LOGGER . error ( SIMPLENET , " Received invalid message { } " , message . getClass ( ) . getName ( ) ) ; <nl> throw new IllegalArgumentException ( " Invalid message " + message . getClass ( ) . getName ( ) ) ; <nl> } <nl> - tryEncode ( target , message , codecIndex ) ; <nl> + return tryEncode ( target , message , messageHandler ) ; <nl> } <nl> <nl> void consume ( PacketBuffer payload , int payloadIndex , Supplier < NetworkEvent . Context > context ) { <nl> @ @ - 111 , 30 + 125 , 15 @ @ public class IndexedMessageCodec <nl> return ; <nl> } <nl> short discriminator = payload . readUnsignedByte ( ) ; <nl> - final CodecIndex < ? > codecIndex = indicies . get ( discriminator ) ; <nl> - if ( codecIndex = = null ) { <nl> - LOGGER . error ( SIMPLENET , " Received invalid discriminator byte { } " , discriminator ) ; <nl> - return ; <nl> - } <nl> - tryDecode ( payload , context , payloadIndex , codecIndex ) ; <nl> - } <nl> - <nl> - void consume ( PacketBuffer payload , Supplier < NetworkEvent . Context > context ) { <nl> - / / no data in empty payload <nl> - if ( payload = = null ) { <nl> - LOGGER . error ( SIMPLENET , " Received empty payload " ) ; <nl> - return ; <nl> - } <nl> - short discriminator = payload . readUnsignedByte ( ) ; <nl> - final CodecIndex < ? > codecIndex = indicies . get ( discriminator ) ; <nl> - if ( codecIndex = = null ) { <nl> + final MessageHandler < ? > messageHandler = indicies . get ( discriminator ) ; <nl> + if ( messageHandler = = null ) { <nl> LOGGER . error ( SIMPLENET , " Received invalid discriminator byte { } " , discriminator ) ; <nl> return ; <nl> } <nl> - tryDecode ( payload , context , codecIndex ) ; <nl> + tryDecode ( payload , context , payloadIndex , messageHandler ) ; <nl> } <nl> <nl> - < MSG > CodecIndex < MSG > addCodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { <nl> - return new CodecIndex < > ( index , messageType , encoder , decoder , messageConsumer ) ; <nl> + < MSG > MessageHandler < MSG > addCodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { <nl> + return new MessageHandler < > ( index , messageType , encoder , decoder , messageConsumer ) ; <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> index 984e8b7 . . f413dab 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> @ @ - 24 , 18 + 24 , 14 @ @ import net . minecraft . client . Minecraft ; <nl> import net . minecraft . network . NetworkManager ; <nl> import net . minecraft . network . Packet ; <nl> import net . minecraft . network . PacketBuffer ; <nl> - import net . minecraft . network . play . client . CPacketCustomPayload ; <nl> import net . minecraftforge . fml . network . ICustomPacket ; <nl> import net . minecraftforge . fml . network . NetworkDirection ; <nl> import net . minecraftforge . fml . network . NetworkEvent ; <nl> import net . minecraftforge . fml . network . NetworkInstance ; <nl> + import org . apache . commons . lang3 . tuple . Pair ; <nl> <nl> import java . util . function . BiConsumer ; <nl> - import java . util . function . BinaryOperator ; <nl> import java . util . function . Function ; <nl> - import java . util . function . IntBinaryOperator ; <nl> - import java . util . function . IntConsumer ; <nl> - import java . util . function . IntFunction ; <nl> import java . util . function . Supplier ; <nl> <nl> public class SimpleChannel <nl> @ @ - 52 , 42 + 48 , 38 @ @ public class SimpleChannel <nl> <nl> private void networkEventListener ( final NetworkEvent networkEvent ) <nl> { <nl> - if ( networkEvent instanceof NetworkEvent . ILoginIndex ) <nl> - { <nl> - this . indexedCodec . consume ( networkEvent . getPayload ( ) , ( ( NetworkEvent . ILoginIndex ) networkEvent ) . getIndex ( ) , networkEvent . getSource ( ) ) ; <nl> - } <nl> - else <nl> - { <nl> - this . indexedCodec . consume ( networkEvent . getPayload ( ) , networkEvent . getSource ( ) ) ; <nl> - } <nl> + this . indexedCodec . consume ( networkEvent . getPayload ( ) , networkEvent . getLoginIndex ( ) , networkEvent . getSource ( ) ) ; <nl> } <nl> <nl> - public < MSG > void encodeMessage ( MSG message , final PacketBuffer target ) { <nl> - this . indexedCodec . build ( message , target ) ; <nl> + public < MSG > int encodeMessage ( MSG message , final PacketBuffer target ) { <nl> + return this . indexedCodec . build ( message , target ) ; <nl> } <nl> - public < MSG > IndexedMessageCodec . CodecIndex < MSG > registerMessage ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { <nl> + public < MSG > IndexedMessageCodec . MessageHandler < MSG > registerMessage ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { <nl> return this . indexedCodec . addCodecIndex ( index , messageType , encoder , decoder , messageConsumer ) ; <nl> } <nl> <nl> - private < MSG > PacketBuffer toBuffer ( MSG msg ) { <nl> + private < MSG > Pair < PacketBuffer , Integer > toBuffer ( MSG msg ) { <nl> final PacketBuffer bufIn = new PacketBuffer ( Unpooled . buffer ( ) ) ; <nl> - encodeMessage ( msg , bufIn ) ; <nl> - return bufIn ; <nl> + int index = encodeMessage ( msg , bufIn ) ; <nl> + return Pair . of ( bufIn , index ) ; <nl> } <nl> + <nl> public < MSG > void sendToServer ( MSG message ) <nl> { <nl> sendTo ( message , Minecraft . getMinecraft ( ) . getConnection ( ) . getNetworkManager ( ) , NetworkDirection . PLAY _ TO _ SERVER ) ; <nl> } <nl> <nl> - public < MSG > void sendTo ( MSG message , NetworkManager manager , NetworkDirection direction ) { <nl> - ICustomPacket < Packet < ? > > payload = direction . buildPacket ( toBuffer ( message ) , instance . getChannelName ( ) , - 1 ) ; <nl> + public < MSG > void sendTo ( MSG message , NetworkManager manager , NetworkDirection direction ) <nl> + { <nl> + ICustomPacket < Packet < ? > > payload = direction . buildPacket ( toBuffer ( message ) , instance . getChannelName ( ) ) ; <nl> manager . sendPacket ( payload . getThis ( ) ) ; <nl> } <nl> <nl> - public < MSG > void sendLogin ( MSG message , NetworkManager manager , NetworkDirection direction , int packetIndex ) { <nl> - ICustomPacket < Packet < ? > > payload = direction . buildPacket ( toBuffer ( message ) , instance . getChannelName ( ) , packetIndex ) ; <nl> - manager . sendPacket ( payload . getThis ( ) ) ; <nl> + public < MSG > void reply ( MSG msgToReply , NetworkEvent . Context context ) <nl> + { <nl> + sendTo ( msgToReply , context . getNetworkManager ( ) , context . getDirection ( ) . reply ( ) ) ; <nl> } <nl> + <nl> public < M > MessageBuilder < M > messageBuilder ( final Class < M > type , int id ) { <nl> return MessageBuilder . forType ( this , type , id ) ; <nl> } <nl> @ @ - 99 , 7 + 91 , 8 @ @ public class SimpleChannel <nl> private BiConsumer < MSG , PacketBuffer > encoder ; <nl> private Function < PacketBuffer , MSG > decoder ; <nl> private BiConsumer < MSG , Supplier < NetworkEvent . Context > > consumer ; <nl> - private BiConsumer < MSG , Integer > loginIndexFunction ; <nl> + private Function < MSG , Integer > loginIndexGetter ; <nl> + private BiConsumer < MSG , Integer > loginIndexSetter ; <nl> <nl> private static < MSG > MessageBuilder < MSG > forType ( final SimpleChannel channel , final Class < MSG > type , int id ) { <nl> MessageBuilder < MSG > builder = new MessageBuilder < > ( ) ; <nl> @ @ - 119 , 8 + 112 , 9 @ @ public class SimpleChannel <nl> return this ; <nl> } <nl> <nl> - public MessageBuilder < MSG > loginIndex ( BiConsumer < MSG , Integer > loginIndexFunction ) { <nl> - this . loginIndexFunction = loginIndexFunction ; <nl> + public MessageBuilder < MSG > loginIndex ( Function < MSG , Integer > loginIndexGetter , BiConsumer < MSG , Integer > loginIndexSetter ) { <nl> + this . loginIndexGetter = loginIndexGetter ; <nl> + this . loginIndexSetter = loginIndexSetter ; <nl> return this ; <nl> } <nl> public MessageBuilder < MSG > consumer ( BiConsumer < MSG , Supplier < NetworkEvent . Context > > consumer ) { <nl> @ @ - 129 , 9 + 123 , 12 @ @ public class SimpleChannel <nl> } <nl> <nl> public void add ( ) { <nl> - final IndexedMessageCodec . CodecIndex < MSG > message = this . channel . registerMessage ( this . id , this . type , this . encoder , this . decoder , this . consumer ) ; <nl> - if ( this . loginIndexFunction ! = null ) { <nl> - message . setLoginIndexFunction ( this . loginIndexFunction ) ; <nl> + final IndexedMessageCodec . MessageHandler < MSG > message = this . channel . registerMessage ( this . id , this . type , this . encoder , this . decoder , this . consumer ) ; <nl> + if ( this . loginIndexSetter ! = null ) { <nl> + message . setLoginIndexSetter ( this . loginIndexSetter ) ; <nl> + } <nl> + if ( this . loginIndexGetter ! = null ) { <nl> + message . setLoginIndexGetter ( this . loginIndexGetter ) ; <nl> } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / UsernameCache . java b / src / main / java / net / minecraftforge / common / UsernameCache . java <nl> index 704cce3 . . bc86da5 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / UsernameCache . java <nl> + + + b / src / main / java / net / minecraftforge / common / UsernameCache . java <nl> @ @ - 19 , 28 + 19 , 32 @ @ <nl> <nl> package net . minecraftforge . common ; <nl> <nl> - import static com . google . common . base . Preconditions . checkNotNull ; <nl> - <nl> - import java . io . File ; <nl> + import java . io . BufferedReader ; <nl> + import java . io . BufferedWriter ; <nl> import java . io . IOException ; <nl> import java . lang . reflect . Type ; <nl> - import java . nio . charset . Charset ; <nl> - import java . nio . charset . StandardCharsets ; <nl> + import java . nio . file . Files ; <nl> + import java . nio . file . Path ; <nl> + import java . util . HashMap ; <nl> import java . util . Map ; <nl> + import java . util . Objects ; <nl> import java . util . UUID ; <nl> <nl> import javax . annotation . Nullable ; <nl> <nl> + import com . google . common . base . Charsets ; <nl> + import net . minecraft . world . storage . ThreadedFileIOBase ; <nl> + import net . minecraftforge . fml . loading . FMLLoader ; <nl> import org . apache . logging . log4j . LogManager ; <nl> import org . apache . logging . log4j . Logger ; <nl> <nl> import com . google . common . collect . ImmutableMap ; <nl> - import com . google . common . collect . Maps ; <nl> - import com . google . common . io . Files ; <nl> import com . google . common . reflect . TypeToken ; <nl> import com . google . gson . Gson ; <nl> import com . google . gson . GsonBuilder ; <nl> import com . google . gson . JsonSyntaxException ; <nl> + import org . apache . logging . log4j . Marker ; <nl> + import org . apache . logging . log4j . MarkerManager ; <nl> <nl> / * * <nl> * Caches player ' s last known usernames <nl> @ @ - 52 , 19 + 56 , 18 @ @ import com . google . gson . JsonSyntaxException ; <nl> * / <nl> public final class UsernameCache { <nl> <nl> - private static Map < UUID , String > map = Maps . newHashMap ( ) ; <nl> - <nl> - private static final Charset charset = StandardCharsets . UTF _ 8 ; <nl> + private static Map < UUID , String > map = new HashMap < > ( ) ; <nl> <nl> - private static final File saveFile = new File ( / * The minecraft dir * / ( File ) FMLInjectionData . data ( ) [ 6 ] , " usernamecache . json " ) ; <nl> + private static final Path saveFile = FMLLoader . getGamePath ( ) . resolve ( " usernamecache . json " ) ; <nl> private static final Gson gson = new GsonBuilder ( ) . setPrettyPrinting ( ) . create ( ) ; <nl> <nl> - private static final Logger log = LogManager . getLogger ( ForgeVersion . MOD _ ID + " . UsernameCache " ) ; <nl> + private static final Logger LOGGER = LogManager . getLogger ( UsernameCache . class ) ; <nl> + private static final Marker USRCACHE = MarkerManager . getMarker ( " USERNAMECACHE " ) ; <nl> <nl> private UsernameCache ( ) { } <nl> <nl> / * * <nl> - * Set a player ' s current username <nl> + * Set a player ' s current usernamee <nl> * <nl> * @ param uuid <nl> * the player ' s { @ link java . util . UUID UUID } <nl> @ @ - 73 , 8 + 76 , 8 @ @ public final class UsernameCache { <nl> * / <nl> protected static void setUsername ( UUID uuid , String username ) <nl> { <nl> - checkNotNull ( uuid ) ; <nl> - checkNotNull ( username ) ; <nl> + Objects . requireNonNull ( uuid ) ; <nl> + Objects . requireNonNull ( username ) ; <nl> <nl> if ( username . equals ( map . get ( uuid ) ) ) return ; <nl> <nl> @ @ - 91 , 7 + 94 , 7 @ @ public final class UsernameCache { <nl> * / <nl> protected static boolean removeUsername ( UUID uuid ) <nl> { <nl> - checkNotNull ( uuid ) ; <nl> + Objects . requireNonNull ( uuid ) ; <nl> <nl> if ( map . remove ( uuid ) ! = null ) <nl> { <nl> @ @ - 115 , 7 + 118 , 7 @ @ public final class UsernameCache { <nl> @ Nullable <nl> public static String getLastKnownUsername ( UUID uuid ) <nl> { <nl> - checkNotNull ( uuid ) ; <nl> + Objects . requireNonNull ( uuid ) ; <nl> return map . get ( uuid ) ; <nl> } <nl> <nl> @ @ - 128 , 7 + 131 , 7 @ @ public final class UsernameCache { <nl> * / <nl> public static boolean containsUUID ( UUID uuid ) <nl> { <nl> - checkNotNull ( uuid ) ; <nl> + Objects . requireNonNull ( uuid ) ; <nl> return map . containsKey ( uuid ) ; <nl> } <nl> <nl> @ @ - 155 , 32 + 158 , 31 @ @ public final class UsernameCache { <nl> * / <nl> protected static void load ( ) <nl> { <nl> - if ( ! saveFile . exists ( ) ) return ; <nl> - <nl> - try <nl> - { <nl> - <nl> - String json = Files . toString ( saveFile , charset ) ; <nl> - Type type = new TypeToken < Map < UUID , String > > ( ) { private static final long serialVersionUID = 1L ; } . getType ( ) ; <nl> + if ( ! Files . exists ( saveFile ) ) return ; <nl> <nl> - map = gson . fromJson ( json , type ) ; <nl> - } <nl> - catch ( JsonSyntaxException e ) <nl> + try ( final BufferedReader reader = Files . newBufferedReader ( saveFile , Charsets . UTF _ 8 ) ) <nl> { <nl> - log . error ( " Could not parse username cache file as valid json , deleting file " , e ) ; <nl> - saveFile . delete ( ) ; <nl> + Type type = new TypeToken < Map < UUID , String > > ( ) { } . getType ( ) ; <nl> + map = gson . fromJson ( reader , type ) ; <nl> } <nl> - catch ( IOException e ) <nl> + catch ( JsonSyntaxException | IOException e ) <nl> { <nl> - log . error ( " Failed to read username cache file from disk , deleting file " , e ) ; <nl> - saveFile . delete ( ) ; <nl> + LOGGER . error ( USRCACHE , " Could not parse username cache file as valid json , deleting file { } " , saveFile , e ) ; <nl> + try <nl> + { <nl> + Files . delete ( saveFile ) ; <nl> + } <nl> + catch ( IOException e1 ) <nl> + { <nl> + LOGGER . error ( USRCACHE , " Could not delete file { } " , saveFile . toString ( ) ) ; <nl> + } <nl> } <nl> finally <nl> { <nl> / / Can sometimes occur when the json file is malformed <nl> if ( map = = null ) <nl> { <nl> - map = Maps . newHashMap ( ) ; <nl> + map = new HashMap < > ( ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / ModContainer . java b / src / main / java / net / minecraftforge / fml / ModContainer . java <nl> index 0a28de4 . . 4e88162 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / ModContainer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / ModContainer . java <nl> @ @ - 20 , 7 + 20 , 6 @ @ <nl> package net . minecraftforge . fml ; <nl> <nl> import net . minecraftforge . fml . language . IModInfo ; <nl> - import net . minecraftforge . fml . network . Networking ; <nl> <nl> import java . util . ArrayList ; <nl> import java . util . HashMap ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / IMessageHandler . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / IMessageHandler . java <nl> index fae8ecf . . 962f5a3 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / IMessageHandler . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / IMessageHandler . java <nl> @ @ - 20 , 10 + 20 , 10 @ @ <nl> package net . minecraftforge . fml . common . network . simpleimpl ; <nl> <nl> <nl> - import net . minecraftforge . fml . network . simple . MessageContext ; <nl> + import net . minecraftforge . fml . network . NetworkEvent ; <nl> <nl> / * * <nl> - * A message handler based on { @ link IMessage } . Implement and override { @ link # onMessage ( IMessage , MessageContext ) } to <nl> + * A message handler based on { @ link IMessage } . Implement and override { @ link # onMessage ( IMessage , NetworkEvent . Context ) } to <nl> * process your packet . Supply the class to { @ link SimpleNetworkWrapper # registerMessage ( Class , Class , int , Side ) } <nl> * to register both the message type and it ' s associated handler . <nl> * <nl> @ @ - 41 , 5 + 41 , 5 @ @ public interface IMessageHandler < REQ extends IMessage , REPLY extends IMessage > { <nl> * @ param message The message <nl> * @ return an optional return message <nl> * / <nl> - REPLY onMessage ( REQ message , MessageContext ctx ) ; <nl> + REPLY onMessage ( REQ message , NetworkEvent . Context ctx ) ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java <nl> index f57d8ec . . 9da6a43 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java <nl> @ @ - 20 , 7 + 20 , 7 @ @ <nl> package net . minecraftforge . fml . common . network . simpleimpl ; <nl> <nl> import net . minecraftforge . api . distmarker . Dist ; <nl> - import net . minecraftforge . fml . network . simple . MessageContext ; <nl> + import net . minecraftforge . fml . network . NetworkEvent ; <nl> <nl> import net . minecraft . network . INetHandler ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> @ @ - 52 , 7 + 52 , 7 @ @ public class SimpleChannelHandlerWrapper < REQ extends IMessage , REPLY extends IMe <nl> protected void channelRead0 ( ChannelHandlerContext ctx , REQ msg ) throws Exception <nl> { <nl> INetHandler iNetHandler = ctx . channel ( ) . attr ( NetworkRegistry . NET _ HANDLER ) . get ( ) ; <nl> - MessageContext context = new MessageContext ( iNetHandler , side ) ; <nl> + NetworkEvent . Context context = new NetworkEvent . Context ( iNetHandler , side ) ; <nl> REPLY result = messageHandler . onMessage ( msg , context ) ; <nl> if ( result ! = null ) <nl> { <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> index 3772a8c . . 2ee7152 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java <nl> @ @ - 80 , 14 + 80 , 14 @ @ import net . minecraftforge . fml . common . network . NetworkRegistry . TargetPoint ; <nl> * } <nl> * / / Message1Handler expects input of type Message1 and returns type Message2 <nl> * public Message1Handler implements IMessageHandler < Message1 , Message2 > { <nl> - * public Message2 onMessage ( Message1 message , MessageContext ctx ) { <nl> + * public Message2 onMessage ( Message1 message , Context ctx ) { <nl> * / / do something and generate reply message <nl> * return aMessage2Object ; <nl> * } <nl> * } <nl> * / / Message2Handler expects input of type Message2 and returns no message ( IMessage ) <nl> * public Message2Handler implements IMessageHandler < Message2 , IMessage > { <nl> - * public IMessage onMessage ( Message2 message , MessageContext ctx ) { <nl> + * public IMessage onMessage ( Message2 message , Context ctx ) { <nl> * / / handle the message 2 response message at the other end <nl> * / / no reply for this message - return null <nl> * return null ; <nl> diff - - git a / src / main / java / net / minecraftforge / fml / loading / FMLLoader . java b / src / main / java / net / minecraftforge / fml / loading / FMLLoader . java <nl> index e821ad2 . . 7b1893e 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / loading / FMLLoader . java <nl> + + + b / src / main / java / net / minecraftforge / fml / loading / FMLLoader . java <nl> @ @ - 57 , 6 + 57 , 7 @ @ public class FMLLoader <nl> private static LoadingModList loadingModList ; <nl> private static ClassLoader launchClassLoader ; <nl> private static RuntimeDistCleaner runtimeDistCleaner ; <nl> + private static Path gamePath ; <nl> <nl> static void onInitialLoad ( IEnvironment environment , Set < String > otherServices ) throws IncompatibleEnvironmentException <nl> { <nl> @ @ - 124 , 6 + 125 , 7 @ @ public class FMLLoader <nl> fmlLog . error ( CORE , " Incompatible Launch handler found - type { } , cannot continue " , launchHandler . get ( ) . getClass ( ) . getName ( ) ) ; <nl> throw new RuntimeException ( " Incompatible launch handler found " ) ; <nl> } <nl> + gamePath = environment . getProperty ( IEnvironment . Keys . GAMEDIR . get ( ) ) . orElse ( Paths . get ( " . " ) . toAbsolutePath ( ) ) ; <nl> <nl> FMLCommonLaunchHandler commonLaunchHandler = ( FMLCommonLaunchHandler ) launchHandler . get ( ) ; <nl> commonLaunchHandler . setup ( environment ) ; <nl> @ @ - 192 , 4 + 194 , 9 @ @ public class FMLLoader <nl> { <nl> return launchClassLoader ; <nl> } <nl> + <nl> + public static Path getGamePath ( ) <nl> + { <nl> + return gamePath ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / Network . java b / src / main / java / net / minecraftforge / fml / network / Network . java <nl> new file mode 100644 <nl> index 0000000 . . 43d77dc <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / network / Network . java <nl> @ @ - 0 , 0 + 1 , 45 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2018 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . fml . network ; <nl> + <nl> + import net . minecraft . network . PacketBuffer ; <nl> + <nl> + import java . util . function . BiFunction ; <nl> + import java . util . function . Supplier ; <nl> + <nl> + public enum Network <nl> + { <nl> + PLAYSERVER ( NetworkEvent . ClientCustomPayloadEvent : : new ) , <nl> + PLAYCLIENT ( NetworkEvent . ServerCustomPayloadEvent : : new ) , <nl> + LOGINSERVER ( NetworkEvent . ClientCustomPayloadEvent : : new ) , <nl> + LOGINCLIENT ( NetworkEvent . ServerCustomPayloadEvent : : new ) ; <nl> + <nl> + private final BiFunction < PacketBuffer , Supplier < NetworkEvent . Context > , NetworkEvent > eventSupplier ; <nl> + <nl> + Network ( BiFunction < PacketBuffer , Supplier < NetworkEvent . Context > , NetworkEvent > eventSupplier ) <nl> + { <nl> + this . eventSupplier = eventSupplier ; <nl> + } <nl> + <nl> + public NetworkEvent getEvent ( final PacketBuffer buffer , final Supplier < NetworkEvent . Context > manager ) { <nl> + return this . eventSupplier . apply ( buffer , manager ) ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java b / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java <nl> new file mode 100644 <nl> index 0000000 . . 0948d4c <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java <nl> @ @ - 0 , 0 + 1 , 101 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2018 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . fml . network ; <nl> + <nl> + import net . minecraft . client . network . NetHandlerPlayClient ; <nl> + import net . minecraft . network . INetHandler ; <nl> + import net . minecraft . network . NetHandlerPlayServer ; <nl> + import net . minecraft . network . NetworkManager ; <nl> + import net . minecraft . network . PacketBuffer ; <nl> + import net . minecraftforge . eventbus . api . Event ; <nl> + <nl> + import java . util . function . Supplier ; <nl> + <nl> + public class NetworkEvent extends Event <nl> + { <nl> + private final PacketBuffer payload ; <nl> + private final Supplier < Context > source ; <nl> + <nl> + private NetworkEvent ( PacketBuffer payload , Supplier < Context > source ) <nl> + { <nl> + this . payload = payload ; <nl> + this . source = source ; <nl> + } <nl> + <nl> + public PacketBuffer getPayload ( ) <nl> + { <nl> + return payload ; <nl> + } <nl> + <nl> + public Supplier < Context > getSource ( ) <nl> + { <nl> + return source ; <nl> + } <nl> + <nl> + public static class ServerCustomPayloadEvent extends NetworkEvent <nl> + { <nl> + ServerCustomPayloadEvent ( final PacketBuffer payload , final Supplier < Context > source ) { <nl> + super ( payload , source ) ; <nl> + } <nl> + } <nl> + public static class ClientCustomPayloadEvent extends NetworkEvent <nl> + { <nl> + ClientCustomPayloadEvent ( final PacketBuffer payload , final Supplier < Context > source ) { <nl> + super ( payload , source ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Context for { @ link NetworkEvent } <nl> + * / <nl> + public static class Context <nl> + { <nl> + / * * <nl> + * The { @ link INetHandler } for this message . It could be a client or server handler , depending <nl> + * on the { @ link # side } received . <nl> + * / <nl> + private final INetHandler netHandler ; <nl> + <nl> + / * * <nl> + * The { @ link Network } this message has been received on <nl> + * / <nl> + private final Network side ; <nl> + <nl> + Context ( NetworkManager netHandler , Network side ) <nl> + { <nl> + this . netHandler = netHandler . getNetHandler ( ) ; <nl> + this . side = side ; <nl> + } <nl> + <nl> + public Network getSide ( ) { <nl> + return side ; <nl> + } <nl> + <nl> + public NetHandlerPlayServer getServerHandler ( ) <nl> + { <nl> + return ( NetHandlerPlayServer ) netHandler ; <nl> + } <nl> + <nl> + public NetHandlerPlayClient getClientHandler ( ) <nl> + { <nl> + return ( NetHandlerPlayClient ) netHandler ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> index ae7c877 . . 40503d3 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java <nl> @ @ - 27 , 7 + 27 , 6 @ @ import net . minecraft . network . handshake . client . C00Handshake ; <nl> import net . minecraft . network . play . client . CPacketCustomPayload ; <nl> import net . minecraft . network . play . server . SPacketCustomPayload ; <nl> import net . minecraft . util . ResourceLocation ; <nl> - import net . minecraftforge . fml . LogicalSide ; <nl> import net . minecraftforge . fml . common . registry . EntityRegistry ; <nl> <nl> import java . util . Objects ; <nl> @ @ - 63 , 22 + 62 , 22 @ @ public class NetworkHooks <nl> <nl> public static void onServerCustomPayload ( final SPacketCustomPayload packet , final NetworkManager manager ) { <nl> NetworkRegistry . findTarget ( new ResourceLocation ( packet . getChannelName ( ) ) ) . <nl> - ifPresent ( ni - > ni . dispatch ( NetworkInstance . NetworkSide . PLAYSERVER , packet . getBufferData ( ) , manager ) ) ; <nl> + ifPresent ( ni - > ni . dispatch ( Network . PLAYSERVER , packet . getBufferData ( ) , manager ) ) ; <nl> } <nl> <nl> public static void onClientCustomPayload ( final CPacketCustomPayload packet , final NetworkManager manager ) { <nl> NetworkRegistry . findTarget ( new ResourceLocation ( packet . getChannelName ( ) ) ) . <nl> - ifPresent ( ni - > ni . dispatch ( NetworkInstance . NetworkSide . PLAYCLIENT , packet . getBufferData ( ) , manager ) ) ; <nl> + ifPresent ( ni - > ni . dispatch ( Network . PLAYCLIENT , packet . getBufferData ( ) , manager ) ) ; <nl> } <nl> <nl> public static void onServerLoginCustomPayload ( final SPacketCustomPayload packet , final NetworkManager manager ) { <nl> NetworkRegistry . findTarget ( new ResourceLocation ( packet . getChannelName ( ) ) ) . <nl> - ifPresent ( ni - > ni . dispatch ( NetworkInstance . NetworkSide . LOGINSERVER , packet . getBufferData ( ) , manager ) ) ; <nl> + ifPresent ( ni - > ni . dispatch ( Network . LOGINSERVER , packet . getBufferData ( ) , manager ) ) ; <nl> } <nl> <nl> public static void onClientLoginCustomPayload ( final CPacketCustomPayload packet , final NetworkManager manager ) { <nl> NetworkRegistry . findTarget ( new ResourceLocation ( packet . getChannelName ( ) ) ) . <nl> - ifPresent ( ni - > ni . dispatch ( NetworkInstance . NetworkSide . LOGINCLIENT , packet . getBufferData ( ) , manager ) ) ; <nl> + ifPresent ( ni - > ni . dispatch ( Network . LOGINCLIENT , packet . getBufferData ( ) , manager ) ) ; <nl> } <nl> <nl> public static void registerServerChannel ( NetworkManager manager , C00Handshake packet ) <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java b / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java <nl> index a2eb043 . . ad4dbeb 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java <nl> @ @ - 26 , 7 + 26 , 6 @ @ import net . minecraftforge . eventbus . api . Event ; <nl> import net . minecraftforge . eventbus . api . IEventBus ; <nl> import net . minecraftforge . eventbus . api . IEventListener ; <nl> <nl> - import java . util . function . BiFunction ; <nl> import java . util . function . Consumer ; <nl> import java . util . function . Predicate ; <nl> import java . util . function . Supplier ; <nl> @ @ - 38 , 24 + 37 , 6 @ @ public class NetworkInstance <nl> return channelName . toString ( ) ; <nl> } <nl> <nl> - public enum NetworkSide { <nl> - PLAYSERVER ( NetworkEvent . ServerCustomPayloadEvent : : new ) , <nl> - PLAYCLIENT ( NetworkEvent . ClientCustomPayloadEvent : : new ) , <nl> - LOGINSERVER ( NetworkEvent . ServerCustomPayloadEvent : : new ) , <nl> - LOGINCLIENT ( NetworkEvent . ClientCustomPayloadEvent : : new ) ; <nl> - <nl> - private final BiFunction < PacketBuffer , NetworkManager , NetworkEvent > eventSupplier ; <nl> - <nl> - NetworkSide ( BiFunction < PacketBuffer , NetworkManager , NetworkEvent > eventSupplier ) <nl> - { <nl> - this . eventSupplier = eventSupplier ; <nl> - } <nl> - <nl> - public NetworkEvent getEvent ( final PacketBuffer buffer , final NetworkManager manager ) { <nl> - return this . eventSupplier . apply ( buffer , manager ) ; <nl> - } <nl> - <nl> - } <nl> private final ResourceLocation channelName ; <nl> private final Supplier < String > networkProtocolVersion ; <nl> private final Predicate < String > clientAcceptedVersions ; <nl> @ @ - 76 , 9 + 57 , 9 @ @ public class NetworkInstance <nl> <nl> } <nl> <nl> - public < T extends NetworkEvent > void addListener ( Consumer < T > serverEventListener ) <nl> + public < T extends NetworkEvent > void addListener ( Consumer < T > eventListener ) <nl> { <nl> - this . networkEventBus . addListener ( serverEventListener ) ; <nl> + this . networkEventBus . addListener ( eventListener ) ; <nl> } <nl> <nl> public void registerObject ( final Object object ) { <nl> @ @ - 89 , 41 + 70 , 10 @ @ public class NetworkInstance <nl> this . networkEventBus . unregister ( object ) ; <nl> } <nl> <nl> - void dispatch ( final NetworkSide side , final PacketBuffer bufferData , final NetworkManager manager ) <nl> + void dispatch ( final Network side , final PacketBuffer bufferData , final NetworkManager manager ) <nl> { <nl> - this . networkEventBus . post ( side . getEvent ( bufferData , manager ) ) ; <nl> + this . networkEventBus . post ( side . getEvent ( bufferData , ( ) - > new NetworkEvent . Context ( manager , side ) ) ) ; <nl> } <nl> <nl> <nl> - public static class NetworkEvent extends Event { <nl> - private final PacketBuffer payload ; <nl> - private final NetworkManager source ; <nl> - <nl> - private NetworkEvent ( PacketBuffer payload , NetworkManager source ) <nl> - { <nl> - this . payload = payload ; <nl> - this . source = source ; <nl> - } <nl> - <nl> - public PacketBuffer getPayload ( ) <nl> - { <nl> - return payload ; <nl> - } <nl> - <nl> - public NetworkManager getSource ( ) <nl> - { <nl> - return source ; <nl> - } <nl> - <nl> - public static class ServerCustomPayloadEvent extends NetworkEvent { <nl> - ServerCustomPayloadEvent ( final PacketBuffer payload , final NetworkManager source ) { <nl> - super ( payload , source ) ; <nl> - } <nl> - } <nl> - public static class ClientCustomPayloadEvent extends NetworkEvent { <nl> - ClientCustomPayloadEvent ( final PacketBuffer payload , final NetworkManager source ) { <nl> - super ( payload , source ) ; <nl> - } <nl> - } <nl> - } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> index 947393e . . 5fd89e2 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ package net . minecraftforge . fml . network ; <nl> <nl> import io . netty . util . AttributeKey ; <nl> import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . fml . network . event . EventNetworkChannel ; <nl> import net . minecraftforge . fml . network . simple . SimpleChannel ; <nl> import org . apache . logging . log4j . LogManager ; <nl> import org . apache . logging . log4j . Logger ; <nl> @ @ - 50 , 13 + 51 , 21 @ @ public class NetworkRegistry <nl> <nl> <nl> public static SimpleChannel newSimpleChannel ( final ResourceLocation name , Supplier < String > networkProtocolVersion , Predicate < String > clientAcceptedVersions , Predicate < String > serverAcceptedVersions ) { <nl> + return new SimpleChannel ( createInstance ( name , networkProtocolVersion , clientAcceptedVersions , serverAcceptedVersions ) ) ; <nl> + } <nl> + <nl> + public static EventNetworkChannel newEventChannel ( final ResourceLocation name , Supplier < String > networkProtocolVersion , Predicate < String > clientAcceptedVersions , Predicate < String > serverAcceptedVersions ) { <nl> + return new EventNetworkChannel ( createInstance ( name , networkProtocolVersion , clientAcceptedVersions , serverAcceptedVersions ) ) ; <nl> + } <nl> + private static NetworkInstance createInstance ( ResourceLocation name , Supplier < String > networkProtocolVersion , Predicate < String > clientAcceptedVersions , Predicate < String > serverAcceptedVersions ) <nl> + { <nl> final NetworkInstance networkInstance = new NetworkInstance ( name , networkProtocolVersion , clientAcceptedVersions , serverAcceptedVersions ) ; <nl> if ( instances . containsKey ( name ) ) { <nl> LOGGER . error ( NETREGISTRY , " Network channel { } already registered . " , name ) ; <nl> throw new IllegalArgumentException ( " Network Channel { " + name + " } already registered " ) ; <nl> } <nl> instances . put ( name , networkInstance ) ; <nl> - return new SimpleChannel ( networkInstance ) ; <nl> + return networkInstance ; <nl> } <nl> <nl> static Optional < NetworkInstance > findTarget ( ResourceLocation resourceLocation ) <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / Networking . java b / src / main / java / net / minecraftforge / fml / network / Networking . java <nl> deleted file mode 100644 <nl> index 54d67df . . 0000000 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / Networking . java <nl> + + + / dev / null <nl> @ @ - 1 , 25 + 0 , 0 @ @ <nl> - / * <nl> - * Minecraft Forge <nl> - * Copyright ( c ) 2018 . <nl> - * <nl> - * This library is free software ; you can redistribute it and / or <nl> - * modify it under the terms of the GNU Lesser General Public <nl> - * License as published by the Free Software Foundation version 2 . 1 <nl> - * of the License . <nl> - * <nl> - * This library is distributed in the hope that it will be useful , <nl> - * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> - * <nl> - * You should have received a copy of the GNU Lesser General Public <nl> - * License along with this library ; if not , write to the Free Software <nl> - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> - * / <nl> - <nl> - package net . minecraftforge . fml . network ; <nl> - <nl> - public class Networking <nl> - { <nl> - public enum Type { SIMPLE , EVENT , NONE } <nl> - } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / event / EventNetworkChannel . java b / src / main / java / net / minecraftforge / fml / network / event / EventNetworkChannel . java <nl> new file mode 100644 <nl> index 0000000 . . de7cb88 <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / fml / network / event / EventNetworkChannel . java <nl> @ @ - 0 , 0 + 1 , 50 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2018 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . fml . network . event ; <nl> + <nl> + import net . minecraftforge . fml . network . NetworkEvent ; <nl> + import net . minecraftforge . fml . network . NetworkInstance ; <nl> + <nl> + import java . util . function . Consumer ; <nl> + <nl> + public class EventNetworkChannel <nl> + { <nl> + private final NetworkInstance instance ; <nl> + <nl> + public EventNetworkChannel ( NetworkInstance instance ) <nl> + { <nl> + this . instance = instance ; <nl> + } <nl> + <nl> + public < T extends NetworkEvent > void addListener ( Consumer < T > eventListener ) <nl> + { <nl> + instance . addListener ( eventListener ) ; <nl> + } <nl> + <nl> + public void registerObject ( Object object ) <nl> + { <nl> + instance . registerObject ( object ) ; <nl> + } <nl> + <nl> + public void unregisterObject ( Object object ) <nl> + { <nl> + instance . unregisterObject ( object ) ; <nl> + } <nl> + } <nl> \ No newline at end of file <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java b / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java <nl> index 865afbb . . 1a08fb1 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ package net . minecraftforge . fml . network . simple ; <nl> import it . unimi . dsi . fastutil . objects . Object2ObjectArrayMap ; <nl> import it . unimi . dsi . fastutil . shorts . Short2ObjectArrayMap ; <nl> import net . minecraft . network . PacketBuffer ; <nl> + import net . minecraftforge . fml . network . NetworkEvent ; <nl> import org . apache . logging . log4j . LogManager ; <nl> import org . apache . logging . log4j . Logger ; <nl> import org . apache . logging . log4j . Marker ; <nl> @ @ - 46 , 9 + 47 , 9 @ @ public class IndexedMessageCodec <nl> private final Optional < BiConsumer < MSG , PacketBuffer > > encoder ; <nl> private final Optional < Function < PacketBuffer , MSG > > decoder ; <nl> private final int index ; <nl> - private final BiConsumer < MSG , Supplier < MessageContext > > messageConsumer ; <nl> + private final BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ; <nl> private final Class < MSG > messageType ; <nl> - public CodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < MessageContext > > messageConsumer ) <nl> + public CodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) <nl> { <nl> this . index = index ; <nl> this . messageType = messageType ; <nl> @ @ - 61 , 13 + 62 , 16 @ @ public class IndexedMessageCodec <nl> <nl> <nl> } <nl> - private static < M > void tryDecode ( PacketBuffer payload , Supplier < MessageContext > context , CodecIndex < M > codec ) <nl> + private static < M > void tryDecode ( PacketBuffer payload , Supplier < NetworkEvent . Context > context , CodecIndex < M > codec ) <nl> { <nl> codec . decoder . map ( d - > d . apply ( payload ) ) . ifPresent ( m - > codec . messageConsumer . accept ( m , context ) ) ; <nl> } <nl> <nl> private static < M > void tryEncode ( PacketBuffer target , M message , CodecIndex < M > codec ) { <nl> - codec . encoder . ifPresent ( c - > c . accept ( message , target ) ) ; <nl> + codec . encoder . ifPresent ( encoder - > { <nl> + target . writeByte ( codec . index & 0xff ) ; <nl> + encoder . accept ( message , target ) ; <nl> + } ) ; <nl> } <nl> public < MSG > void build ( MSG message , PacketBuffer target ) <nl> { <nl> @ @ - 80 , 7 + 84 , 7 @ @ public class IndexedMessageCodec <nl> tryEncode ( target , message , codecIndex ) ; <nl> } <nl> <nl> - void consume ( final PacketBuffer payload , Supplier < MessageContext > context ) { <nl> + void consume ( final PacketBuffer payload , Supplier < NetworkEvent . Context > context ) { <nl> short discriminator = payload . readUnsignedByte ( ) ; <nl> final CodecIndex < ? > codecIndex = indicies . get ( discriminator ) ; <nl> if ( codecIndex = = null ) { <nl> @ @ - 90 , 7 + 94 , 7 @ @ public class IndexedMessageCodec <nl> tryDecode ( payload , context , codecIndex ) ; <nl> } <nl> <nl> - < MSG > void addCodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < MessageContext > > messageConsumer ) { <nl> + < MSG > void addCodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { <nl> new CodecIndex < > ( index , messageType , encoder , decoder , messageConsumer ) ; <nl> } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / MessageContext . java b / src / main / java / net / minecraftforge / fml / network / simple / MessageContext . java <nl> deleted file mode 100644 <nl> index b22f1bd . . 0000000 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / simple / MessageContext . java <nl> + + + / dev / null <nl> @ @ - 1 , 70 + 0 , 0 @ @ <nl> - / * <nl> - * Minecraft Forge <nl> - * Copyright ( c ) 2016 - 2018 . <nl> - * <nl> - * This library is free software ; you can redistribute it and / or <nl> - * modify it under the terms of the GNU Lesser General Public <nl> - * License as published by the Free Software Foundation version 2 . 1 <nl> - * of the License . <nl> - * <nl> - * This library is distributed in the hope that it will be useful , <nl> - * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> - * <nl> - * You should have received a copy of the GNU Lesser General Public <nl> - * License along with this library ; if not , write to the Free Software <nl> - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> - * / <nl> - <nl> - package net . minecraftforge . fml . network . simple ; <nl> - <nl> - import net . minecraft . client . network . NetHandlerPlayClient ; <nl> - import net . minecraft . network . INetHandler ; <nl> - import net . minecraft . network . NetHandlerPlayServer ; <nl> - import net . minecraft . network . NetworkManager ; <nl> - import net . minecraftforge . api . distmarker . Dist ; <nl> - import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; <nl> - import net . minecraftforge . fml . network . NetworkInstance ; <nl> - <nl> - / * * <nl> - * Context for the { @ link IMessageHandler } <nl> - * <nl> - * @ author cpw <nl> - * <nl> - * / <nl> - public class MessageContext { <nl> - / * * <nl> - * The { @ link INetHandler } for this message . It could be a client or server handler , depending <nl> - * on the { @ link # side } received . <nl> - * / <nl> - private final INetHandler netHandler ; <nl> - <nl> - / * * <nl> - * The { @ link NetworkInstance . NetworkSide } this message has been received on <nl> - * / <nl> - private final NetworkInstance . NetworkSide side ; <nl> - / * * <nl> - * @ param netHandler <nl> - * @ param side <nl> - * / <nl> - MessageContext ( NetworkManager netHandler , NetworkInstance . NetworkSide side ) <nl> - { <nl> - this . netHandler = netHandler . getNetHandler ( ) ; <nl> - this . side = side ; <nl> - } <nl> - <nl> - public NetworkInstance . NetworkSide getSide ( ) { <nl> - return side ; <nl> - } <nl> - <nl> - public NetHandlerPlayServer getServerHandler ( ) <nl> - { <nl> - return ( NetHandlerPlayServer ) netHandler ; <nl> - } <nl> - <nl> - public NetHandlerPlayClient getClientHandler ( ) <nl> - { <nl> - return ( NetHandlerPlayClient ) netHandler ; <nl> - } <nl> - } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> index d483da8 . . 79dfc62 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> + + + b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java <nl> @ @ - 19 , 12 + 19 , 11 @ @ <nl> <nl> package net . minecraftforge . fml . network . simple ; <nl> <nl> - import io . netty . buffer . ByteBuf ; <nl> import io . netty . buffer . Unpooled ; <nl> import net . minecraft . client . Minecraft ; <nl> - import net . minecraft . network . NetworkManager ; <nl> import net . minecraft . network . PacketBuffer ; <nl> import net . minecraft . network . play . client . CPacketCustomPayload ; <nl> + import net . minecraftforge . fml . network . NetworkEvent ; <nl> import net . minecraftforge . fml . network . NetworkInstance ; <nl> <nl> import java . util . function . BiConsumer ; <nl> @ @ - 40 , 24 + 39 , 18 @ @ public class SimpleChannel <nl> { <nl> this . instance = instance ; <nl> this . indexedCodec = new IndexedMessageCodec ( ) ; <nl> - instance . addListener ( this : : serverEventListener ) ; <nl> - instance . addListener ( this : : clientEventListener ) ; <nl> + instance . addListener ( this : : networkEventListener ) ; <nl> } <nl> <nl> - private void clientEventListener ( final NetworkInstance . NetworkEvent . ClientCustomPayloadEvent clientCustomPayloadEvent ) <nl> + private void networkEventListener ( final NetworkEvent networkEvent ) <nl> { <nl> - } <nl> - <nl> - private void serverEventListener ( final NetworkInstance . NetworkEvent . ServerCustomPayloadEvent serverCustomPayloadEvent ) <nl> - { <nl> - this . indexedCodec . consume ( serverCustomPayloadEvent . getPayload ( ) , <nl> - ( ) - > new MessageContext ( serverCustomPayloadEvent . getSource ( ) , NetworkInstance . NetworkSide . PLAYSERVER ) ) ; <nl> + this . indexedCodec . consume ( networkEvent . getPayload ( ) , networkEvent . getSource ( ) ) ; <nl> } <nl> <nl> public < MSG > void encodeMessage ( MSG message , final PacketBuffer target ) { <nl> this . indexedCodec . build ( message , target ) ; <nl> } <nl> - public < MSG > void registerMessage ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < MessageContext > > messageConsumer ) { <nl> + public < MSG > void registerMessage ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { <nl> this . indexedCodec . addCodecIndex ( index , messageType , encoder , decoder , messageConsumer ) ; <nl> } <nl> <nl> diff - - git a / src / test / java / net / minecraftforge / debug / item / MapDataTest . java b / src / test / java / net / minecraftforge / debug / item / MapDataTest . java <nl> index e0b5150 . . 45a213d 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / item / MapDataTest . java <nl> + + + b / src / test / java / net / minecraftforge / debug / item / MapDataTest . java <nl> @ @ - 51 , 7 + 51 , 7 @ @ import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> import net . minecraftforge . eventbus . api . SubscribeEvent ; <nl> import net . minecraftforge . fml . common . network . simpleimpl . IMessage ; <nl> import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; <nl> - import net . minecraftforge . fml . network . simple . MessageContext ; <nl> + import net . minecraftforge . fml . network . NetworkEvent ; <nl> import net . minecraftforge . fml . common . network . simpleimpl . SimpleNetworkWrapper ; <nl> import net . minecraftforge . fml . common . registry . GameRegistry ; <nl> <nl> @ @ - 237 , 7 + 237 , 7 @ @ public class MapDataTest <nl> { <nl> @ Nullable <nl> @ Override <nl> - public IMessage onMessage ( CustomMapPacket message , MessageContext ctx ) <nl> + public IMessage onMessage ( CustomMapPacket message , NetworkEvent . Context ctx ) <nl> { <nl> / / Like NetHandlerPlayClient . handleMaps but using our custom type <nl> Minecraft . getMinecraft ( ) . addScheduledTask ( new Runnable ( ) { <nl> diff - - git a / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler1 . java b / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler1 . java <nl> index 9dfff55 . . cdb360f 100644 <nl> - - - a / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler1 . java <nl> + + + b / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler1 . java <nl> @ @ - 20 , 12 + 20 , 12 @ @ <nl> package net . minecraftforge . fml . test . simplenet ; <nl> <nl> import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; <nl> - import net . minecraftforge . fml . network . simple . MessageContext ; <nl> + import net . minecraftforge . fml . network . NetworkEvent ; <nl> <nl> public class SimpleNetHandler1 implements IMessageHandler < SimpleNetTestMessage1 , SimpleNetTestMessage2 > <nl> { <nl> @ Override <nl> - public SimpleNetTestMessage2 onMessage ( SimpleNetTestMessage1 message , MessageContext context ) <nl> + public SimpleNetTestMessage2 onMessage ( SimpleNetTestMessage1 message , NetworkEvent . Context context ) <nl> { <nl> return null ; <nl> } <nl> diff - - git a / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler2 . java b / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler2 . java <nl> index 804e640 . . edbc3d2 100644 <nl> - - - a / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler2 . java <nl> + + + b / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler2 . java <nl> @ @ - 20 , 12 + 20 , 12 @ @ <nl> package net . minecraftforge . fml . test . simplenet ; <nl> <nl> import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; <nl> - import net . minecraftforge . fml . network . simple . MessageContext ; <nl> + import net . minecraftforge . fml . network . NetworkEvent ; <nl> <nl> public class SimpleNetHandler2 implements IMessageHandler < SimpleNetTestMessage2 , SimpleNetTestMessage1 > <nl> { <nl> @ Override <nl> - public SimpleNetTestMessage1 onMessage ( SimpleNetTestMessage2 message , MessageContext context ) <nl> + public SimpleNetTestMessage1 onMessage ( SimpleNetTestMessage2 message , NetworkEvent . Context context ) <nl> { <nl> return null ; <nl> }

TEST DIFF:
diff - - git a / build . gradle b / build . gradle 
 index e250d69 . . 00f06c1 100644 
 - - - a / build . gradle 
 + + + b / build . gradle 
 @ @ - 87 , 6 + 87 , 7 @ @ project ( ' : forge ' ) { 
 target : ' fmldevserver ' 
 ] 
 } 
 + mcVersion = ' 1 . 13 ' 
 } 
 applyPatches { 
 canonicalizeAccess true 
 diff - - git a / patches / minecraft / net / minecraft / item / Item . java . patch b / patches / minecraft / net / minecraft / item / Item . java . patch 
 index 736b9ea . . 775a125 100644 
 - - - a / patches / minecraft / net / minecraft / item / Item . java . patch 
 + + + b / patches / minecraft / net / minecraft / item / Item . java . patch 
 @ @ - 60 , 7 + 60 , 7 @ @ 
 float f7 = f2 * f4 ; 
 - double d3 = 5 . 0D ; 
 - Vec3d vec3d1 = vec3d . add ( ( double ) f6 * 5 . 0D , ( double ) f5 * 5 . 0D , ( double ) f7 * 5 . 0D ) ; 
 - + double d3 = playerIn . getEntityAttribute ( EntityPlayer . REACH _ DISTANCE ) . getAttributeValue ( ) ; 
 + + double d3 = 6 ; 
 + Vec3d vec3d1 = vec3d . add ( ( double ) f6 * d3 , ( double ) f5 * d3 , ( double ) f7 * d3 ) ; 
 return worldIn . func _ 200259 _ a ( vec3d , vec3d1 , useLiquids ? RayTraceFluidMode . SOURCE _ ONLY : RayTraceFluidMode . NEVER , false , false ) ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessage . java b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessage . java 
 new file mode 100644 
 index 0000000 . . 41f14c0 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / network / FMLHandshakeMessage . java 
 @ @ - 0 , 0 + 1 , 89 @ @ 
 + package net . minecraftforge . fml . network ; 
 + 
 + import net . minecraft . nbt . INBTBase ; 
 + import net . minecraft . nbt . NBTTagCompound ; 
 + import net . minecraft . nbt . NBTTagList ; 
 + import net . minecraft . nbt . NBTTagString ; 
 + import net . minecraft . network . PacketBuffer ; 
 + import net . minecraftforge . fml . ModList ; 
 + import net . minecraftforge . fml . loading . moddiscovery . ModInfo ; 
 + 
 + import java . util . List ; 
 + import java . util . stream . Collectors ; 
 + 
 + class FMLHandshakeMessage 
 + { 
 + / / Login index sequence number 
 + private int index ; 
 + void setPacketIndexSequence ( int i ) 
 + { 
 + this . index = i ; 
 + } 
 + 
 + int getPacketIndexSequence ( ) 
 + { 
 + return index ; 
 + } 
 + 
 + / * * 
 + * Server to client " list of mods " . Always first handshake message . 
 + * / 
 + static class S2CModList extends FMLHandshakeMessage 
 + { 
 + private NBTTagList channels ; 
 + private List < String > modList ; 
 + 
 + S2CModList ( ) { 
 + this . modList = ModList . get ( ) . getMods ( ) . stream ( ) . map ( ModInfo : : getModId ) . collect ( Collectors . toList ( ) ) ; 
 + } 
 + 
 + S2CModList ( NBTTagCompound nbtTagCompound ) 
 + { 
 + this . modList = nbtTagCompound . getTagList ( " modlist " , 8 ) . stream ( ) . map ( INBTBase : : getString ) . collect ( Collectors . toList ( ) ) ; 
 + this . channels = nbtTagCompound . getTagList ( " channels " , 10 ) ; 
 + } 
 + 
 + static S2CModList decode ( PacketBuffer packetBuffer ) 
 + { 
 + final NBTTagCompound nbtTagCompound = packetBuffer . readCompoundTag ( ) ; 
 + return new S2CModList ( nbtTagCompound ) ; 
 + } 
 + 
 + void encode ( PacketBuffer packetBuffer ) 
 + { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setTag ( " modlist " , modList . stream ( ) . map ( NBTTagString : : new ) . collect ( Collectors . toCollection ( NBTTagList : : new ) ) ) ; 
 + tag . setTag ( " channels " , NetworkRegistry . buildChannelVersions ( ) ) ; 
 + packetBuffer . writeCompoundTag ( tag ) ; 
 + } 
 + 
 + String getModList ( ) { 
 + return String . join ( " , " , modList ) ; 
 + } 
 + 
 + NBTTagList getChannels ( ) { 
 + return this . channels ; 
 + } 
 + } 
 + 
 + static class C2SModListReply extends S2CModList 
 + { 
 + C2SModListReply ( ) { 
 + super ( ) ; 
 + } 
 + 
 + C2SModListReply ( final NBTTagCompound buffer ) { 
 + super ( buffer ) ; 
 + } 
 + 
 + static C2SModListReply decode ( PacketBuffer buffer ) 
 + { 
 + return new C2SModListReply ( buffer . readCompoundTag ( ) ) ; 
 + } 
 + 
 + public void encode ( PacketBuffer buffer ) 
 + { 
 + super . encode ( buffer ) ; 
 + } 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / FMLNetworking . java b / src / main / java / net / minecraftforge / fml / network / FMLNetworking . java 
 index 4c5a509 . . 90d86d9 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / FMLNetworking . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / FMLNetworking . java 
 @ @ - 1 , 14 + 1 , 9 @ @ 
 package net . minecraftforge . fml . network ; 
 
 import io . netty . util . AttributeKey ; 
 - import net . minecraft . nbt . INBTBase ; 
 - import net . minecraft . nbt . NBTTagCompound ; 
 - import net . minecraft . nbt . NBTTagList ; 
 - import net . minecraft . nbt . NBTTagString ; 
 import net . minecraft . network . NetworkManager ; 
 - import net . minecraft . network . PacketBuffer ; 
 - import net . minecraftforge . fml . ModList ; 
 - import net . minecraftforge . fml . loading . moddiscovery . ModInfo ; 
 + import net . minecraft . util . text . ITextComponent ; 
 + import net . minecraft . util . text . TextComponentString ; 
 import net . minecraftforge . fml . network . simple . SimpleChannel ; 
 import org . apache . logging . log4j . LogManager ; 
 import org . apache . logging . log4j . Logger ; 
 @ @ - 19 , 7 + 14 , 6 @ @ import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . List ; 
 import java . util . function . Supplier ; 
 - import java . util . stream . Collectors ; 
 
 public class FMLNetworking 
 { 
 @ @ - 49 , 24 + 43 , 24 @ @ public class FMLNetworking 
 
 public static class FMLHandshake { 
 private static SimpleChannel channel ; 
 - private static List < Supplier < HandshakeMessage > > messages = Arrays . asList ( HandshakeMessage . S2CModList : : new ) ; 
 - private List < HandshakeMessage > sentMessages = new ArrayList < > ( ) ; 
 + private static List < Supplier < FMLHandshakeMessage > > messages = Arrays . asList ( FMLHandshakeMessage . S2CModList : : new ) ; 
 + private List < FMLHandshakeMessage > sentMessages = new ArrayList < > ( ) ; 
 static { 
 channel = NetworkRegistry . ChannelBuilder . named ( NetworkHooks . FMLHANDSHAKE ) . 
 clientAcceptedVersions ( a - > true ) . 
 serverAcceptedVersions ( a - > true ) . 
 networkProtocolVersion ( ( ) - > NetworkHooks . NETVERSION ) . 
 simpleChannel ( ) ; 
 - channel . messageBuilder ( HandshakeMessage . S2CModList . class , 1 ) . 
 - decoder ( HandshakeMessage . S2CModList : : decode ) . 
 - encoder ( HandshakeMessage . S2CModList : : encode ) . 
 - loginIndex ( HandshakeMessage . S2CModList : : setPacketIndexSequence ) . 
 + channel . messageBuilder ( FMLHandshakeMessage . S2CModList . class , 1 ) . 
 + decoder ( FMLHandshakeMessage . S2CModList : : decode ) . 
 + encoder ( FMLHandshakeMessage . S2CModList : : encode ) . 
 + loginIndex ( FMLHandshakeMessage : : getPacketIndexSequence , FMLHandshakeMessage : : setPacketIndexSequence ) . 
 consumer ( ( m , c ) - > getHandshake ( c ) . handleServerModListOnClient ( m , c ) ) . 
 add ( ) ; 
 - channel . messageBuilder ( HandshakeMessage . C2SModListReply . class , 2 ) . 
 - loginIndex ( HandshakeMessage : : setPacketIndexSequence ) . 
 - decoder ( HandshakeMessage . C2SModListReply : : decode ) . 
 - encoder ( HandshakeMessage . C2SModListReply : : encode ) . 
 + channel . messageBuilder ( FMLHandshakeMessage . C2SModListReply . class , 2 ) . 
 + loginIndex ( FMLHandshakeMessage : : getPacketIndexSequence , FMLHandshakeMessage : : setPacketIndexSequence ) . 
 + decoder ( FMLHandshakeMessage . C2SModListReply : : decode ) . 
 + encoder ( FMLHandshakeMessage . C2SModListReply : : encode ) . 
 consumer ( ( m , c ) - > getHandshake ( c ) . handleClientModListOnServer ( m , c ) ) . 
 add ( ) ; 
 } 
 @ @ - 82 , 30 + 76 , 63 @ @ public class FMLNetworking 
 this . manager = networkManager ; 
 } 
 
 - public void handleServerModListOnClient ( HandshakeMessage . S2CModList serverModList , Supplier < NetworkEvent . Context > c ) 
 + private void handleServerModListOnClient ( FMLHandshakeMessage . S2CModList serverModList , Supplier < NetworkEvent . Context > c ) 
 { 
 - LOGGER . debug ( FMLHSMARKER , " Received S2CModList packet with index { } " , serverModList . getPacketIndexSequence ( ) ) ; 
 + LOGGER . debug ( FMLHSMARKER , " Logging into server with mod list [ { } ] " , serverModList . getModList ( ) ) ; 
 + boolean accepted = NetworkRegistry . validateClientChannels ( serverModList . getChannels ( ) ) ; 
 c . get ( ) . setPacketHandled ( true ) ; 
 - final HandshakeMessage . C2SModListReply reply = new HandshakeMessage . C2SModListReply ( ) ; 
 - channel . sendLogin ( reply , c . get ( ) . getNetworkManager ( ) , c . get ( ) . getDirection ( ) . reply ( ) , reply . getPacketIndexSequence ( ) ) ; 
 + if ( ! accepted ) { 
 + LOGGER . error ( FMLHSMARKER , " Terminating connection with server , mismatched mod list " ) ; 
 + c . get ( ) . getNetworkManager ( ) . closeChannel ( new TextComponentString ( " Connection closed - mismatched mod channel list " ) ) ; 
 + return ; 
 + } 
 + final FMLHandshakeMessage . C2SModListReply reply = new FMLHandshakeMessage . C2SModListReply ( ) ; 
 + reply . setPacketIndexSequence ( serverModList . getPacketIndexSequence ( ) ) ; 
 + channel . reply ( reply , c . get ( ) ) ; 
 LOGGER . debug ( FMLHSMARKER , " Sent C2SModListReply packet with index { } " , reply . getPacketIndexSequence ( ) ) ; 
 } 
 
 - private void handleClientModListOnServer ( HandshakeMessage . C2SModListReply m , Supplier < NetworkEvent . Context > c ) 
 + private void handleClientModListOnServer ( FMLHandshakeMessage . C2SModListReply clientModList , Supplier < NetworkEvent . Context > c ) 
 { 
 - LOGGER . debug ( FMLHSMARKER , " Received C2SModListReply with index { } " , m . getPacketIndexSequence ( ) ) ; 
 - final HandshakeMessage message = this . sentMessages . stream ( ) . filter ( ob - > ob . getPacketIndexSequence ( ) = = m . getPacketIndexSequence ( ) ) . findFirst ( ) . orElseThrow ( ( ) - > new RuntimeException ( " Unexpected reply from client " ) ) ; 
 + LOGGER . debug ( FMLHSMARKER , " Received client connection with modlist [ { } ] " , clientModList . getModList ( ) ) ; 
 + final FMLHandshakeMessage message = this . sentMessages . stream ( ) . filter ( ob - > ob . getPacketIndexSequence ( ) = = clientModList . getPacketIndexSequence ( ) ) . findFirst ( ) . orElseThrow ( ( ) - > new RuntimeException ( " Unexpected reply from client " ) ) ; 
 boolean removed = this . sentMessages . remove ( message ) ; 
 + boolean accepted = NetworkRegistry . validateServerChannels ( clientModList . getChannels ( ) ) ; 
 c . get ( ) . setPacketHandled ( true ) ; 
 + if ( ! accepted ) { 
 + LOGGER . error ( FMLHSMARKER , " Terminating connection with client , mismatched mod list " ) ; 
 + c . get ( ) . getNetworkManager ( ) . closeChannel ( new TextComponentString ( " Connection closed - mismatched mod channel list " ) ) ; 
 + return ; 
 + } 
 LOGGER . debug ( FMLHSMARKER , " Cleared original message { } " , removed ) ; 
 } 
 
 + / * * 
 + * Design of handshake . 
 + * 
 + * After { @ link net . minecraft . server . network . NetHandlerLoginServer } enters the { @ link net . minecraft . server . network . NetHandlerLoginServer . LoginState # NEGOTIATING } 
 + * state , this will be ticked once per server tick . 
 + * 
 + * FML will send packets , from Server to Client , from the messages queue until the queue is drained . Each message 
 + * will be indexed , and placed into the " pending acknowledgement " queue . 
 + * 
 + * The client should send an acknowledgement for every packet that has a positive index , containing 
 + * that index ( and maybe other data as well ) . 
 + * 
 + * As indexed packets are received at the server , they will be removed from the " pending acknowledgement " queue . 
 + * 
 + * Once the pending queue is drained , this method returns true - indicating that login processing can proceed to 
 + * the next step . 
 + * 
 + * @ return true if there is no more need to tick this login connection . 
 + * / 
 public boolean tickServer ( ) 
 { 
 if ( packetPosition < messages . size ( ) ) { 
 - final HandshakeMessage message = messages . get ( packetPosition ) . get ( ) ; 
 + final FMLHandshakeMessage message = messages . get ( packetPosition ) . get ( ) ; 
 + message . setPacketIndexSequence ( packetPosition ) ; 
 LOGGER . debug ( FMLHSMARKER , " Sending ticking packet { } index { } " , message . getClass ( ) . getName ( ) , message . getPacketIndexSequence ( ) ) ; 
 - channel . sendLogin ( message , this . manager , this . direction , packetPosition ) ; 
 + channel . sendTo ( message , this . manager , this . direction ) ; 
 sentMessages . add ( message ) ; 
 packetPosition + + ; 
 } 
 @ @ - 121 , 57 + 148 , 4 @ @ public class FMLNetworking 
 } 
 
 
 - static class HandshakeMessage 
 - { 
 - private int index ; 
 - public void setPacketIndexSequence ( int i ) 
 - { 
 - this . index = i ; 
 - } 
 - 
 - public int getPacketIndexSequence ( ) 
 - { 
 - return index ; 
 - } 
 - 
 - static class S2CModList extends HandshakeMessage 
 - { 
 - private List < String > modList ; 
 - 
 - S2CModList ( ) { 
 - this . modList = ModList . get ( ) . getMods ( ) . stream ( ) . map ( ModInfo : : getModId ) . collect ( Collectors . toList ( ) ) ; 
 - } 
 - 
 - S2CModList ( NBTTagCompound nbtTagCompound ) 
 - { 
 - this . modList = nbtTagCompound . getTagList ( " list " , 8 ) . stream ( ) . map ( INBTBase : : getString ) . collect ( Collectors . toList ( ) ) ; 
 - } 
 - 
 - public static S2CModList decode ( PacketBuffer packetBuffer ) 
 - { 
 - final NBTTagCompound nbtTagCompound = packetBuffer . readCompoundTag ( ) ; 
 - return new S2CModList ( nbtTagCompound ) ; 
 - } 
 - 
 - public void encode ( PacketBuffer packetBuffer ) 
 - { 
 - NBTTagCompound tag = new NBTTagCompound ( ) ; 
 - tag . setTag ( " list " , modList . stream ( ) . map ( NBTTagString : : new ) . collect ( Collectors . toCollection ( NBTTagList : : new ) ) ) ; 
 - packetBuffer . writeCompoundTag ( tag ) ; 
 - } 
 - } 
 - 
 - static class C2SModListReply extends HandshakeMessage 
 - { 
 - public static C2SModListReply decode ( PacketBuffer buffer ) 
 - { 
 - return new C2SModListReply ( ) ; 
 - } 
 - 
 - public void encode ( PacketBuffer buffer ) 
 - { 
 - 
 - } 
 - } 
 - } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkDirection . java b / src / main / java / net / minecraftforge / fml / network / NetworkDirection . java 
 index bf55c75 . . 20a7a65 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkDirection . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkDirection . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import net . minecraft . network . play . server . SPacketCustomPayload ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . fml . LogicalSide ; 
 import net . minecraftforge . fml . UnsafeHacks ; 
 + import org . apache . commons . lang3 . tuple . Pair ; 
 
 import java . util . function . BiFunction ; 
 import java . util . function . Function ; 
 @ @ - 84 , 12 + 85 , 12 @ @ public enum NetworkDirection 
 } 
 
 @ SuppressWarnings ( " unchecked " ) 
 - public < T extends Packet < ? > > ICustomPacket < T > buildPacket ( PacketBuffer packetBuffer , ResourceLocation channelName , int index ) 
 + public < T extends Packet < ? > > ICustomPacket < T > buildPacket ( Pair < PacketBuffer , Integer > packetData , ResourceLocation channelName ) 
 { 
 ICustomPacket < T > packet = ( ICustomPacket < T > ) UnsafeHacks . newInstance ( getPacketClass ( ) ) ; 
 packet . setName ( channelName ) ; 
 - packet . setData ( packetBuffer ) ; 
 - packet . setIndex ( index ) ; 
 + packet . setData ( packetData . getLeft ( ) ) ; 
 + packet . setIndex ( packetData . getRight ( ) ) ; 
 return packet ; 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java b / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java 
 index 5c129be . . ae48e42 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java 
 @ @ - 32 , 10 + 32 , 13 @ @ public class NetworkEvent extends Event 
 { 
 private final PacketBuffer payload ; 
 private final Supplier < Context > source ; 
 - private NetworkEvent ( ICustomPacket < ? > payload , Supplier < Context > source ) 
 + private final int loginIndex ; 
 + 
 + private NetworkEvent ( final ICustomPacket < ? > payload , final Supplier < Context > source ) 
 { 
 this . payload = payload . getData ( ) ; 
 this . source = source ; 
 + this . loginIndex = payload . getIndex ( ) ; 
 } 
 
 public PacketBuffer getPayload ( ) 
 @ @ - 48 , 9 + 51 , 13 @ @ public class NetworkEvent extends Event 
 return source ; 
 } 
 
 - public static class ServerCustomPayloadEvent extends NetworkEvent 
 + public int getLoginIndex ( ) 
 { 
 + return loginIndex ; 
 + } 
 
 + public static class ServerCustomPayloadEvent extends NetworkEvent 
 + { 
 ServerCustomPayloadEvent ( final ICustomPacket < ? > payload , final Supplier < Context > source ) { 
 super ( payload , source ) ; 
 } 
 @ @ - 61 , 39 + 68 , 20 @ @ public class NetworkEvent extends Event 
 super ( payload , source ) ; 
 } 
 } 
 - public static class ServerCustomPayloadLoginEvent extends ServerCustomPayloadEvent implements ILoginIndex { 
 - private final int index ; 
 - 
 + public static class ServerCustomPayloadLoginEvent extends ServerCustomPayloadEvent { 
 ServerCustomPayloadLoginEvent ( ICustomPacket < ? > payload , Supplier < Context > source ) 
 { 
 super ( payload , source ) ; 
 - this . index = payload . getIndex ( ) ; 
 - } 
 - 
 - public int getIndex ( ) 
 - { 
 - return index ; 
 } 
 } 
 
 - public static class ClientCustomPayloadLoginEvent extends ClientCustomPayloadEvent implements ILoginIndex { 
 - private final int index ; 
 - 
 + public static class ClientCustomPayloadLoginEvent extends ClientCustomPayloadEvent { 
 ClientCustomPayloadLoginEvent ( ICustomPacket < ? > payload , Supplier < Context > source ) 
 { 
 super ( payload , source ) ; 
 - this . index = payload . getIndex ( ) ; 
 - } 
 - 
 - public int getIndex ( ) 
 - { 
 - return index ; 
 } 
 } 
 
 - public interface ILoginIndex { 
 - int getIndex ( ) ; 
 - } 
 / * * 
 * Context for { @ link NetworkEvent } 
 * / 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java b / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java 
 index f71cc23 . . b8efef7 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java 
 @ @ - 19 , 6 + 19 , 7 @ @ 
 
 package net . minecraftforge . fml . network ; 
 
 + import net . minecraft . nbt . INBTBase ; 
 import net . minecraft . network . NetworkManager ; 
 import net . minecraft . network . PacketBuffer ; 
 import net . minecraft . util . ResourceLocation ; 
 @ @ - 38 , 7 + 39 , 7 @ @ public class NetworkInstance 
 } 
 
 private final ResourceLocation channelName ; 
 - private final Supplier < String > networkProtocolVersion ; 
 + private final String networkProtocolVersion ; 
 private final Predicate < String > clientAcceptedVersions ; 
 private final Predicate < String > serverAcceptedVersions ; 
 private final IEventBus networkEventBus ; 
 @ @ - 46 , 7 + 47 , 7 @ @ public class NetworkInstance 
 NetworkInstance ( ResourceLocation channelName , Supplier < String > networkProtocolVersion , Predicate < String > clientAcceptedVersions , Predicate < String > serverAcceptedVersions ) 
 { 
 this . channelName = channelName ; 
 - this . networkProtocolVersion = networkProtocolVersion ; 
 + this . networkProtocolVersion = networkProtocolVersion . get ( ) ; 
 this . clientAcceptedVersions = clientAcceptedVersions ; 
 this . serverAcceptedVersions = serverAcceptedVersions ; 
 this . networkEventBus = IEventBus . create ( this : : handleError ) ; 
 @ @ - 78 , 4 + 79 , 15 @ @ public class NetworkInstance 
 } 
 
 
 + String getNetworkProtocolVersion ( ) { 
 + return networkProtocolVersion ; 
 + } 
 + 
 + boolean tryServerVersionOnClient ( final String serverVersion ) { 
 + return this . clientAcceptedVersions . test ( serverVersion ) ; 
 + } 
 + 
 + boolean tryClientVersionOnServer ( final String clientVersion ) { 
 + return this . serverAcceptedVersions . test ( clientVersion ) ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 index 4629fba . . 7439119 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 @ @ - 19 , 10 + 19 , 12 @ @ 
 
 package net . minecraftforge . fml . network ; 
 
 - import io . netty . util . AttributeKey ; 
 + import net . minecraft . nbt . NBTTagCompound ; 
 + import net . minecraft . nbt . NBTTagList ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . fml . network . event . EventNetworkChannel ; 
 import net . minecraftforge . fml . network . simple . SimpleChannel ; 
 + import org . apache . commons . lang3 . tuple . Pair ; 
 import org . apache . logging . log4j . LogManager ; 
 import org . apache . logging . log4j . Logger ; 
 import org . apache . logging . log4j . Marker ; 
 @ @ - 35 , 6 + 37 , 7 @ @ import java . util . Map ; 
 import java . util . Optional ; 
 import java . util . function . Predicate ; 
 import java . util . function . Supplier ; 
 + import java . util . stream . Collectors ; 
 
 public class NetworkRegistry 
 { 
 @ @ - 71 , 6 + 74 , 53 @ @ public class NetworkRegistry 
 return Optional . ofNullable ( instances . get ( resourceLocation ) ) ; 
 } 
 
 + static NBTTagList buildChannelVersions ( ) { 
 + return instances . entrySet ( ) . stream ( ) . map ( e - > { 
 + final NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setString ( " name " , e . getKey ( ) . toString ( ) ) ; 
 + tag . setString ( " version " , e . getValue ( ) . getNetworkProtocolVersion ( ) ) ; 
 + return tag ; 
 + } ) . collect ( Collectors . toCollection ( NBTTagList : : new ) ) ; 
 + } 
 + 
 + static boolean validateClientChannels ( final NBTTagList channels ) { 
 + final List < Pair < ResourceLocation , Boolean > > results = channels . stream ( ) . map ( t - > { 
 + NBTTagCompound tag = ( NBTTagCompound ) t ; 
 + final ResourceLocation rl = new ResourceLocation ( tag . getString ( " name " ) ) ; 
 + final String serverVersion = tag . getString ( " version " ) ; 
 + boolean test = instances . get ( rl ) . tryServerVersionOnClient ( serverVersion ) ; 
 + LOGGER . debug ( NETREGISTRY , " Channel { } : Client version test of ' ' { } ' ' from server : { } " , rl , serverVersion , test ) ; 
 + return Pair . of ( rl , test ) ; 
 + } ) . filter ( p - > ! p . getRight ( ) ) . collect ( Collectors . toList ( ) ) ; 
 + 
 + if ( ! results . isEmpty ( ) ) { 
 + LOGGER . error ( NETREGISTRY , " Channels [ { } ] rejected their server side version number " , 
 + results . stream ( ) . map ( Pair : : getLeft ) . map ( Object : : toString ) . collect ( Collectors . joining ( " , " ) ) ) ; 
 + return false ; 
 + } 
 + LOGGER . debug ( NETREGISTRY , " Accepting channel list from server " ) ; 
 + return true ; 
 + } 
 + 
 + static boolean validateServerChannels ( final NBTTagList channels ) { 
 + final List < Pair < ResourceLocation , Boolean > > results = channels . stream ( ) . map ( t - > { 
 + NBTTagCompound tag = ( NBTTagCompound ) t ; 
 + final ResourceLocation rl = new ResourceLocation ( tag . getString ( " name " ) ) ; 
 + final String clientVersion = tag . getString ( " version " ) ; 
 + boolean test = instances . get ( rl ) . tryClientVersionOnServer ( clientVersion ) ; 
 + LOGGER . debug ( NETREGISTRY , " Channel { } : Server version test of ' ' { } ' ' from client : { } " , rl , clientVersion , test ) ; 
 + return Pair . of ( rl , test ) ; 
 + } ) . filter ( p - > ! p . getRight ( ) ) . collect ( Collectors . toList ( ) ) ; 
 + 
 + if ( ! results . isEmpty ( ) ) { 
 + LOGGER . error ( NETREGISTRY , " Channels [ { } ] rejected their client side version number " , 
 + results . stream ( ) . map ( Pair : : getLeft ) . map ( Object : : toString ) . collect ( Collectors . joining ( " , " ) ) ) ; 
 + return false ; 
 + } 
 + LOGGER . debug ( NETREGISTRY , " Accepting channel list from client " ) ; 
 + return true ; 
 + } 
 + 
 public static class ChannelBuilder { 
 private ResourceLocation channelName ; 
 private Supplier < String > networkProtocolVersion ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java b / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java 
 index 1a78543 . . 9bcfa9d 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java 
 @ @ - 21 , 9 + 21 , 7 @ @ package net . minecraftforge . fml . network . simple ; 
 
 import it . unimi . dsi . fastutil . objects . Object2ObjectArrayMap ; 
 import it . unimi . dsi . fastutil . shorts . Short2ObjectArrayMap ; 
 - import net . minecraft . network . Packet ; 
 import net . minecraft . network . PacketBuffer ; 
 - import net . minecraftforge . fml . network . ICustomPacket ; 
 import net . minecraftforge . fml . network . NetworkEvent ; 
 import org . apache . logging . log4j . LogManager ; 
 import org . apache . logging . log4j . Logger ; 
 @ @ - 32 , 7 + 30 , 6 @ @ import org . apache . logging . log4j . MarkerManager ; 
 
 import java . util . Optional ; 
 import java . util . function . BiConsumer ; 
 - import java . util . function . BiFunction ; 
 import java . util . function . Function ; 
 import java . util . function . Supplier ; 
 
 @ @ - 40 , 69 + 37 , 86 @ @ public class IndexedMessageCodec 
 { 
 private static final Logger LOGGER = LogManager . getLogger ( ) ; 
 private static final Marker SIMPLENET = MarkerManager . getMarker ( " SIMPLENET " ) ; 
 - private final Short2ObjectArrayMap < CodecIndex < ? > > indicies = new Short2ObjectArrayMap < > ( ) ; 
 - private final Object2ObjectArrayMap < Class < ? > , CodecIndex < ? > > types = new Object2ObjectArrayMap < > ( ) ; 
 + private final Short2ObjectArrayMap < MessageHandler < ? > > indicies = new Short2ObjectArrayMap < > ( ) ; 
 + private final Object2ObjectArrayMap < Class < ? > , MessageHandler < ? > > types = new Object2ObjectArrayMap < > ( ) ; 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + public < MSG > MessageHandler < MSG > findMessageType ( final MSG msgToReply ) { 
 + return ( MessageHandler < MSG > ) types . get ( msgToReply . getClass ( ) ) ; 
 + } 
 
 @ SuppressWarnings ( " OptionalUsedAsFieldOrParameterType " ) 
 - public class CodecIndex < MSG > 
 + class MessageHandler < MSG > 
 { 
 - 
 private final Optional < BiConsumer < MSG , PacketBuffer > > encoder ; 
 private final Optional < Function < PacketBuffer , MSG > > decoder ; 
 private final int index ; 
 private final BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ; 
 private final Class < MSG > messageType ; 
 - private Optional < BiConsumer < MSG , Integer > > loginIndexFunction ; 
 + private Optional < BiConsumer < MSG , Integer > > loginIndexSetter ; 
 + private Optional < Function < MSG , Integer > > loginIndexGetter ; 
 
 - public CodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) 
 + public MessageHandler ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) 
 { 
 this . index = index ; 
 this . messageType = messageType ; 
 this . encoder = Optional . ofNullable ( encoder ) ; 
 this . decoder = Optional . ofNullable ( decoder ) ; 
 this . messageConsumer = messageConsumer ; 
 - this . loginIndexFunction = Optional . empty ( ) ; 
 + this . loginIndexGetter = Optional . empty ( ) ; 
 + this . loginIndexSetter = Optional . empty ( ) ; 
 indicies . put ( ( short ) ( index & 0xff ) , this ) ; 
 types . put ( messageType , this ) ; 
 } 
 
 - public void setLoginIndexFunction ( BiConsumer < MSG , Integer > loginIndexFunction ) 
 + void setLoginIndexSetter ( BiConsumer < MSG , Integer > loginIndexSetter ) 
 { 
 - this . loginIndexFunction = Optional . of ( loginIndexFunction ) ; 
 + this . loginIndexSetter = Optional . of ( loginIndexSetter ) ; 
 } 
 
 - public Optional < BiConsumer < MSG , Integer > > getLoginIndexFunction ( ) { 
 - return this . loginIndexFunction ; 
 + Optional < BiConsumer < MSG , Integer > > getLoginIndexSetter ( ) { 
 + return this . loginIndexSetter ; 
 + } 
 + 
 + void setLoginIndexGetter ( Function < MSG , Integer > loginIndexGetter ) { 
 + this . loginIndexGetter = Optional . of ( loginIndexGetter ) ; 
 + } 
 + 
 + public Optional < Function < MSG , Integer > > getLoginIndexGetter ( ) { 
 + return this . loginIndexGetter ; 
 } 
 - } 
 - private static < M > void tryDecode ( PacketBuffer payload , Supplier < NetworkEvent . Context > context , CodecIndex < M > codec ) 
 - { 
 - codec . decoder . map ( d - > d . apply ( payload ) ) . ifPresent ( m - > codec . messageConsumer . accept ( m , context ) ) ; 
 } 
 
 - private static < M > void tryDecode ( PacketBuffer payload , Supplier < NetworkEvent . Context > context , int payloadIndex , CodecIndex < M > codec ) 
 + private static < M > void tryDecode ( PacketBuffer payload , Supplier < NetworkEvent . Context > context , int payloadIndex , MessageHandler < M > codec ) 
 { 
 codec . decoder . map ( d - > d . apply ( payload ) ) . 
 - map ( p - > { codec . getLoginIndexFunction ( ) . ifPresent ( f - > f . accept ( p , payloadIndex ) ) ; return p ; } ) . 
 - ifPresent ( m - > codec . messageConsumer . accept ( m , context ) ) ; 
 + map ( p - > { 
 + / / Only run the loginIndex function for payloadIndexed packets ( login ) 
 + if ( payloadIndex ! = Integer . MIN _ VALUE ) 
 + { 
 + codec . getLoginIndexSetter ( ) . ifPresent ( f - > f . accept ( p , payloadIndex ) ) ; 
 + } 
 + return p ; 
 + } ) . ifPresent ( m - > codec . messageConsumer . accept ( m , context ) ) ; 
 } 
 
 - private static < M > void tryEncode ( PacketBuffer target , M message , CodecIndex < M > codec ) { 
 + private static < M > int tryEncode ( PacketBuffer target , M message , MessageHandler < M > codec ) { 
 codec . encoder . ifPresent ( encoder - > { 
 target . writeByte ( codec . index & 0xff ) ; 
 encoder . accept ( message , target ) ; 
 } ) ; 
 + return codec . loginIndexGetter . orElse ( m - > Integer . MIN _ VALUE ) . apply ( message ) ; 
 } 
 
 - public < MSG > void build ( MSG message , PacketBuffer target ) 
 + public < MSG > int build ( MSG message , PacketBuffer target ) 
 { 
 @ SuppressWarnings ( " unchecked " ) 
 - CodecIndex < MSG > codecIndex = ( CodecIndex < MSG > ) types . get ( message . getClass ( ) ) ; 
 - if ( codecIndex = = null ) { 
 + MessageHandler < MSG > messageHandler = ( MessageHandler < MSG > ) types . get ( message . getClass ( ) ) ; 
 + if ( messageHandler = = null ) { 
 LOGGER . error ( SIMPLENET , " Received invalid message { } " , message . getClass ( ) . getName ( ) ) ; 
 throw new IllegalArgumentException ( " Invalid message " + message . getClass ( ) . getName ( ) ) ; 
 } 
 - tryEncode ( target , message , codecIndex ) ; 
 + return tryEncode ( target , message , messageHandler ) ; 
 } 
 
 void consume ( PacketBuffer payload , int payloadIndex , Supplier < NetworkEvent . Context > context ) { 
 @ @ - 111 , 30 + 125 , 15 @ @ public class IndexedMessageCodec 
 return ; 
 } 
 short discriminator = payload . readUnsignedByte ( ) ; 
 - final CodecIndex < ? > codecIndex = indicies . get ( discriminator ) ; 
 - if ( codecIndex = = null ) { 
 - LOGGER . error ( SIMPLENET , " Received invalid discriminator byte { } " , discriminator ) ; 
 - return ; 
 - } 
 - tryDecode ( payload , context , payloadIndex , codecIndex ) ; 
 - } 
 - 
 - void consume ( PacketBuffer payload , Supplier < NetworkEvent . Context > context ) { 
 - / / no data in empty payload 
 - if ( payload = = null ) { 
 - LOGGER . error ( SIMPLENET , " Received empty payload " ) ; 
 - return ; 
 - } 
 - short discriminator = payload . readUnsignedByte ( ) ; 
 - final CodecIndex < ? > codecIndex = indicies . get ( discriminator ) ; 
 - if ( codecIndex = = null ) { 
 + final MessageHandler < ? > messageHandler = indicies . get ( discriminator ) ; 
 + if ( messageHandler = = null ) { 
 LOGGER . error ( SIMPLENET , " Received invalid discriminator byte { } " , discriminator ) ; 
 return ; 
 } 
 - tryDecode ( payload , context , codecIndex ) ; 
 + tryDecode ( payload , context , payloadIndex , messageHandler ) ; 
 } 
 
 - < MSG > CodecIndex < MSG > addCodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { 
 - return new CodecIndex < > ( index , messageType , encoder , decoder , messageConsumer ) ; 
 + < MSG > MessageHandler < MSG > addCodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { 
 + return new MessageHandler < > ( index , messageType , encoder , decoder , messageConsumer ) ; 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 index 984e8b7 . . f413dab 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 @ @ - 24 , 18 + 24 , 14 @ @ import net . minecraft . client . Minecraft ; 
 import net . minecraft . network . NetworkManager ; 
 import net . minecraft . network . Packet ; 
 import net . minecraft . network . PacketBuffer ; 
 - import net . minecraft . network . play . client . CPacketCustomPayload ; 
 import net . minecraftforge . fml . network . ICustomPacket ; 
 import net . minecraftforge . fml . network . NetworkDirection ; 
 import net . minecraftforge . fml . network . NetworkEvent ; 
 import net . minecraftforge . fml . network . NetworkInstance ; 
 + import org . apache . commons . lang3 . tuple . Pair ; 
 
 import java . util . function . BiConsumer ; 
 - import java . util . function . BinaryOperator ; 
 import java . util . function . Function ; 
 - import java . util . function . IntBinaryOperator ; 
 - import java . util . function . IntConsumer ; 
 - import java . util . function . IntFunction ; 
 import java . util . function . Supplier ; 
 
 public class SimpleChannel 
 @ @ - 52 , 42 + 48 , 38 @ @ public class SimpleChannel 
 
 private void networkEventListener ( final NetworkEvent networkEvent ) 
 { 
 - if ( networkEvent instanceof NetworkEvent . ILoginIndex ) 
 - { 
 - this . indexedCodec . consume ( networkEvent . getPayload ( ) , ( ( NetworkEvent . ILoginIndex ) networkEvent ) . getIndex ( ) , networkEvent . getSource ( ) ) ; 
 - } 
 - else 
 - { 
 - this . indexedCodec . consume ( networkEvent . getPayload ( ) , networkEvent . getSource ( ) ) ; 
 - } 
 + this . indexedCodec . consume ( networkEvent . getPayload ( ) , networkEvent . getLoginIndex ( ) , networkEvent . getSource ( ) ) ; 
 } 
 
 - public < MSG > void encodeMessage ( MSG message , final PacketBuffer target ) { 
 - this . indexedCodec . build ( message , target ) ; 
 + public < MSG > int encodeMessage ( MSG message , final PacketBuffer target ) { 
 + return this . indexedCodec . build ( message , target ) ; 
 } 
 - public < MSG > IndexedMessageCodec . CodecIndex < MSG > registerMessage ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { 
 + public < MSG > IndexedMessageCodec . MessageHandler < MSG > registerMessage ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { 
 return this . indexedCodec . addCodecIndex ( index , messageType , encoder , decoder , messageConsumer ) ; 
 } 
 
 - private < MSG > PacketBuffer toBuffer ( MSG msg ) { 
 + private < MSG > Pair < PacketBuffer , Integer > toBuffer ( MSG msg ) { 
 final PacketBuffer bufIn = new PacketBuffer ( Unpooled . buffer ( ) ) ; 
 - encodeMessage ( msg , bufIn ) ; 
 - return bufIn ; 
 + int index = encodeMessage ( msg , bufIn ) ; 
 + return Pair . of ( bufIn , index ) ; 
 } 
 + 
 public < MSG > void sendToServer ( MSG message ) 
 { 
 sendTo ( message , Minecraft . getMinecraft ( ) . getConnection ( ) . getNetworkManager ( ) , NetworkDirection . PLAY _ TO _ SERVER ) ; 
 } 
 
 - public < MSG > void sendTo ( MSG message , NetworkManager manager , NetworkDirection direction ) { 
 - ICustomPacket < Packet < ? > > payload = direction . buildPacket ( toBuffer ( message ) , instance . getChannelName ( ) , - 1 ) ; 
 + public < MSG > void sendTo ( MSG message , NetworkManager manager , NetworkDirection direction ) 
 + { 
 + ICustomPacket < Packet < ? > > payload = direction . buildPacket ( toBuffer ( message ) , instance . getChannelName ( ) ) ; 
 manager . sendPacket ( payload . getThis ( ) ) ; 
 } 
 
 - public < MSG > void sendLogin ( MSG message , NetworkManager manager , NetworkDirection direction , int packetIndex ) { 
 - ICustomPacket < Packet < ? > > payload = direction . buildPacket ( toBuffer ( message ) , instance . getChannelName ( ) , packetIndex ) ; 
 - manager . sendPacket ( payload . getThis ( ) ) ; 
 + public < MSG > void reply ( MSG msgToReply , NetworkEvent . Context context ) 
 + { 
 + sendTo ( msgToReply , context . getNetworkManager ( ) , context . getDirection ( ) . reply ( ) ) ; 
 } 
 + 
 public < M > MessageBuilder < M > messageBuilder ( final Class < M > type , int id ) { 
 return MessageBuilder . forType ( this , type , id ) ; 
 } 
 @ @ - 99 , 7 + 91 , 8 @ @ public class SimpleChannel 
 private BiConsumer < MSG , PacketBuffer > encoder ; 
 private Function < PacketBuffer , MSG > decoder ; 
 private BiConsumer < MSG , Supplier < NetworkEvent . Context > > consumer ; 
 - private BiConsumer < MSG , Integer > loginIndexFunction ; 
 + private Function < MSG , Integer > loginIndexGetter ; 
 + private BiConsumer < MSG , Integer > loginIndexSetter ; 
 
 private static < MSG > MessageBuilder < MSG > forType ( final SimpleChannel channel , final Class < MSG > type , int id ) { 
 MessageBuilder < MSG > builder = new MessageBuilder < > ( ) ; 
 @ @ - 119 , 8 + 112 , 9 @ @ public class SimpleChannel 
 return this ; 
 } 
 
 - public MessageBuilder < MSG > loginIndex ( BiConsumer < MSG , Integer > loginIndexFunction ) { 
 - this . loginIndexFunction = loginIndexFunction ; 
 + public MessageBuilder < MSG > loginIndex ( Function < MSG , Integer > loginIndexGetter , BiConsumer < MSG , Integer > loginIndexSetter ) { 
 + this . loginIndexGetter = loginIndexGetter ; 
 + this . loginIndexSetter = loginIndexSetter ; 
 return this ; 
 } 
 public MessageBuilder < MSG > consumer ( BiConsumer < MSG , Supplier < NetworkEvent . Context > > consumer ) { 
 @ @ - 129 , 9 + 123 , 12 @ @ public class SimpleChannel 
 } 
 
 public void add ( ) { 
 - final IndexedMessageCodec . CodecIndex < MSG > message = this . channel . registerMessage ( this . id , this . type , this . encoder , this . decoder , this . consumer ) ; 
 - if ( this . loginIndexFunction ! = null ) { 
 - message . setLoginIndexFunction ( this . loginIndexFunction ) ; 
 + final IndexedMessageCodec . MessageHandler < MSG > message = this . channel . registerMessage ( this . id , this . type , this . encoder , this . decoder , this . consumer ) ; 
 + if ( this . loginIndexSetter ! = null ) { 
 + message . setLoginIndexSetter ( this . loginIndexSetter ) ; 
 + } 
 + if ( this . loginIndexGetter ! = null ) { 
 + message . setLoginIndexGetter ( this . loginIndexGetter ) ; 
 } 
 } 
 }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / UsernameCache . java b / src / main / java / net / minecraftforge / common / UsernameCache . java 
 index 704cce3 . . bc86da5 100644 
 - - - a / src / main / java / net / minecraftforge / common / UsernameCache . java 
 + + + b / src / main / java / net / minecraftforge / common / UsernameCache . java 
 @ @ - 19 , 28 + 19 , 32 @ @ 
 
 package net . minecraftforge . common ; 
 
 - import static com . google . common . base . Preconditions . checkNotNull ; 
 - 
 - import java . io . File ; 
 + import java . io . BufferedReader ; 
 + import java . io . BufferedWriter ; 
 import java . io . IOException ; 
 import java . lang . reflect . Type ; 
 - import java . nio . charset . Charset ; 
 - import java . nio . charset . StandardCharsets ; 
 + import java . nio . file . Files ; 
 + import java . nio . file . Path ; 
 + import java . util . HashMap ; 
 import java . util . Map ; 
 + import java . util . Objects ; 
 import java . util . UUID ; 
 
 import javax . annotation . Nullable ; 
 
 + import com . google . common . base . Charsets ; 
 + import net . minecraft . world . storage . ThreadedFileIOBase ; 
 + import net . minecraftforge . fml . loading . FMLLoader ; 
 import org . apache . logging . log4j . LogManager ; 
 import org . apache . logging . log4j . Logger ; 
 
 import com . google . common . collect . ImmutableMap ; 
 - import com . google . common . collect . Maps ; 
 - import com . google . common . io . Files ; 
 import com . google . common . reflect . TypeToken ; 
 import com . google . gson . Gson ; 
 import com . google . gson . GsonBuilder ; 
 import com . google . gson . JsonSyntaxException ; 
 + import org . apache . logging . log4j . Marker ; 
 + import org . apache . logging . log4j . MarkerManager ; 
 
 / * * 
 * Caches player ' s last known usernames 
 @ @ - 52 , 19 + 56 , 18 @ @ import com . google . gson . JsonSyntaxException ; 
 * / 
 public final class UsernameCache { 
 
 - private static Map < UUID , String > map = Maps . newHashMap ( ) ; 
 - 
 - private static final Charset charset = StandardCharsets . UTF _ 8 ; 
 + private static Map < UUID , String > map = new HashMap < > ( ) ; 
 
 - private static final File saveFile = new File ( / * The minecraft dir * / ( File ) FMLInjectionData . data ( ) [ 6 ] , " usernamecache . json " ) ; 
 + private static final Path saveFile = FMLLoader . getGamePath ( ) . resolve ( " usernamecache . json " ) ; 
 private static final Gson gson = new GsonBuilder ( ) . setPrettyPrinting ( ) . create ( ) ; 
 
 - private static final Logger log = LogManager . getLogger ( ForgeVersion . MOD _ ID + " . UsernameCache " ) ; 
 + private static final Logger LOGGER = LogManager . getLogger ( UsernameCache . class ) ; 
 + private static final Marker USRCACHE = MarkerManager . getMarker ( " USERNAMECACHE " ) ; 
 
 private UsernameCache ( ) { } 
 
 / * * 
 - * Set a player ' s current username 
 + * Set a player ' s current usernamee 
 * 
 * @ param uuid 
 * the player ' s { @ link java . util . UUID UUID } 
 @ @ - 73 , 8 + 76 , 8 @ @ public final class UsernameCache { 
 * / 
 protected static void setUsername ( UUID uuid , String username ) 
 { 
 - checkNotNull ( uuid ) ; 
 - checkNotNull ( username ) ; 
 + Objects . requireNonNull ( uuid ) ; 
 + Objects . requireNonNull ( username ) ; 
 
 if ( username . equals ( map . get ( uuid ) ) ) return ; 
 
 @ @ - 91 , 7 + 94 , 7 @ @ public final class UsernameCache { 
 * / 
 protected static boolean removeUsername ( UUID uuid ) 
 { 
 - checkNotNull ( uuid ) ; 
 + Objects . requireNonNull ( uuid ) ; 
 
 if ( map . remove ( uuid ) ! = null ) 
 { 
 @ @ - 115 , 7 + 118 , 7 @ @ public final class UsernameCache { 
 @ Nullable 
 public static String getLastKnownUsername ( UUID uuid ) 
 { 
 - checkNotNull ( uuid ) ; 
 + Objects . requireNonNull ( uuid ) ; 
 return map . get ( uuid ) ; 
 } 
 
 @ @ - 128 , 7 + 131 , 7 @ @ public final class UsernameCache { 
 * / 
 public static boolean containsUUID ( UUID uuid ) 
 { 
 - checkNotNull ( uuid ) ; 
 + Objects . requireNonNull ( uuid ) ; 
 return map . containsKey ( uuid ) ; 
 } 
 
 @ @ - 155 , 32 + 158 , 31 @ @ public final class UsernameCache { 
 * / 
 protected static void load ( ) 
 { 
 - if ( ! saveFile . exists ( ) ) return ; 
 - 
 - try 
 - { 
 - 
 - String json = Files . toString ( saveFile , charset ) ; 
 - Type type = new TypeToken < Map < UUID , String > > ( ) { private static final long serialVersionUID = 1L ; } . getType ( ) ; 
 + if ( ! Files . exists ( saveFile ) ) return ; 
 
 - map = gson . fromJson ( json , type ) ; 
 - } 
 - catch ( JsonSyntaxException e ) 
 + try ( final BufferedReader reader = Files . newBufferedReader ( saveFile , Charsets . UTF _ 8 ) ) 
 { 
 - log . error ( " Could not parse username cache file as valid json , deleting file " , e ) ; 
 - saveFile . delete ( ) ; 
 + Type type = new TypeToken < Map < UUID , String > > ( ) { } . getType ( ) ; 
 + map = gson . fromJson ( reader , type ) ; 
 } 
 - catch ( IOException e ) 
 + catch ( JsonSyntaxException | IOException e ) 
 { 
 - log . error ( " Failed to read username cache file from disk , deleting file " , e ) ; 
 - saveFile . delete ( ) ; 
 + LOGGER . error ( USRCACHE , " Could not parse username cache file as valid json , deleting file { } " , saveFile , e ) ; 
 + try 
 + { 
 + Files . delete ( saveFile ) ; 
 + } 
 + catch ( IOException e1 ) 
 + { 
 + LOGGER . error ( USRCACHE , " Could not delete file { } " , saveFile . toString ( ) ) ; 
 + } 
 } 
 finally 
 { 
 / / Can sometimes occur when the json file is malformed 
 if ( map = = null ) 
 { 
 - map = Maps . newHashMap ( ) ; 
 + map = new HashMap < > ( ) ; 
 } 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / ModContainer . java b / src / main / java / net / minecraftforge / fml / ModContainer . java 
 index 0a28de4 . . 4e88162 100644 
 - - - a / src / main / java / net / minecraftforge / fml / ModContainer . java 
 + + + b / src / main / java / net / minecraftforge / fml / ModContainer . java 
 @ @ - 20 , 7 + 20 , 6 @ @ 
 package net . minecraftforge . fml ; 
 
 import net . minecraftforge . fml . language . IModInfo ; 
 - import net . minecraftforge . fml . network . Networking ; 
 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / IMessageHandler . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / IMessageHandler . java 
 index fae8ecf . . 962f5a3 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / IMessageHandler . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / IMessageHandler . java 
 @ @ - 20 , 10 + 20 , 10 @ @ 
 package net . minecraftforge . fml . common . network . simpleimpl ; 
 
 
 - import net . minecraftforge . fml . network . simple . MessageContext ; 
 + import net . minecraftforge . fml . network . NetworkEvent ; 
 
 / * * 
 - * A message handler based on { @ link IMessage } . Implement and override { @ link # onMessage ( IMessage , MessageContext ) } to 
 + * A message handler based on { @ link IMessage } . Implement and override { @ link # onMessage ( IMessage , NetworkEvent . Context ) } to 
 * process your packet . Supply the class to { @ link SimpleNetworkWrapper # registerMessage ( Class , Class , int , Side ) } 
 * to register both the message type and it ' s associated handler . 
 * 
 @ @ - 41 , 5 + 41 , 5 @ @ public interface IMessageHandler < REQ extends IMessage , REPLY extends IMessage > { 
 * @ param message The message 
 * @ return an optional return message 
 * / 
 - REPLY onMessage ( REQ message , MessageContext ctx ) ; 
 + REPLY onMessage ( REQ message , NetworkEvent . Context ctx ) ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java 
 index f57d8ec . . 9da6a43 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleChannelHandlerWrapper . java 
 @ @ - 20 , 7 + 20 , 7 @ @ 
 package net . minecraftforge . fml . common . network . simpleimpl ; 
 
 import net . minecraftforge . api . distmarker . Dist ; 
 - import net . minecraftforge . fml . network . simple . MessageContext ; 
 + import net . minecraftforge . fml . network . NetworkEvent ; 
 
 import net . minecraft . network . INetHandler ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 @ @ - 52 , 7 + 52 , 7 @ @ public class SimpleChannelHandlerWrapper < REQ extends IMessage , REPLY extends IMe 
 protected void channelRead0 ( ChannelHandlerContext ctx , REQ msg ) throws Exception 
 { 
 INetHandler iNetHandler = ctx . channel ( ) . attr ( NetworkRegistry . NET _ HANDLER ) . get ( ) ; 
 - MessageContext context = new MessageContext ( iNetHandler , side ) ; 
 + NetworkEvent . Context context = new NetworkEvent . Context ( iNetHandler , side ) ; 
 REPLY result = messageHandler . onMessage ( msg , context ) ; 
 if ( result ! = null ) 
 { 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 index 3772a8c . . 2ee7152 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / simpleimpl / SimpleNetworkWrapper . java 
 @ @ - 80 , 14 + 80 , 14 @ @ import net . minecraftforge . fml . common . network . NetworkRegistry . TargetPoint ; 
 * } 
 * / / Message1Handler expects input of type Message1 and returns type Message2 
 * public Message1Handler implements IMessageHandler < Message1 , Message2 > { 
 - * public Message2 onMessage ( Message1 message , MessageContext ctx ) { 
 + * public Message2 onMessage ( Message1 message , Context ctx ) { 
 * / / do something and generate reply message 
 * return aMessage2Object ; 
 * } 
 * } 
 * / / Message2Handler expects input of type Message2 and returns no message ( IMessage ) 
 * public Message2Handler implements IMessageHandler < Message2 , IMessage > { 
 - * public IMessage onMessage ( Message2 message , MessageContext ctx ) { 
 + * public IMessage onMessage ( Message2 message , Context ctx ) { 
 * / / handle the message 2 response message at the other end 
 * / / no reply for this message - return null 
 * return null ; 
 diff - - git a / src / main / java / net / minecraftforge / fml / loading / FMLLoader . java b / src / main / java / net / minecraftforge / fml / loading / FMLLoader . java 
 index e821ad2 . . 7b1893e 100644 
 - - - a / src / main / java / net / minecraftforge / fml / loading / FMLLoader . java 
 + + + b / src / main / java / net / minecraftforge / fml / loading / FMLLoader . java 
 @ @ - 57 , 6 + 57 , 7 @ @ public class FMLLoader 
 private static LoadingModList loadingModList ; 
 private static ClassLoader launchClassLoader ; 
 private static RuntimeDistCleaner runtimeDistCleaner ; 
 + private static Path gamePath ; 
 
 static void onInitialLoad ( IEnvironment environment , Set < String > otherServices ) throws IncompatibleEnvironmentException 
 { 
 @ @ - 124 , 6 + 125 , 7 @ @ public class FMLLoader 
 fmlLog . error ( CORE , " Incompatible Launch handler found - type { } , cannot continue " , launchHandler . get ( ) . getClass ( ) . getName ( ) ) ; 
 throw new RuntimeException ( " Incompatible launch handler found " ) ; 
 } 
 + gamePath = environment . getProperty ( IEnvironment . Keys . GAMEDIR . get ( ) ) . orElse ( Paths . get ( " . " ) . toAbsolutePath ( ) ) ; 
 
 FMLCommonLaunchHandler commonLaunchHandler = ( FMLCommonLaunchHandler ) launchHandler . get ( ) ; 
 commonLaunchHandler . setup ( environment ) ; 
 @ @ - 192 , 4 + 194 , 9 @ @ public class FMLLoader 
 { 
 return launchClassLoader ; 
 } 
 + 
 + public static Path getGamePath ( ) 
 + { 
 + return gamePath ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / Network . java b / src / main / java / net / minecraftforge / fml / network / Network . java 
 new file mode 100644 
 index 0000000 . . 43d77dc 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / network / Network . java 
 @ @ - 0 , 0 + 1 , 45 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2018 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . fml . network ; 
 + 
 + import net . minecraft . network . PacketBuffer ; 
 + 
 + import java . util . function . BiFunction ; 
 + import java . util . function . Supplier ; 
 + 
 + public enum Network 
 + { 
 + PLAYSERVER ( NetworkEvent . ClientCustomPayloadEvent : : new ) , 
 + PLAYCLIENT ( NetworkEvent . ServerCustomPayloadEvent : : new ) , 
 + LOGINSERVER ( NetworkEvent . ClientCustomPayloadEvent : : new ) , 
 + LOGINCLIENT ( NetworkEvent . ServerCustomPayloadEvent : : new ) ; 
 + 
 + private final BiFunction < PacketBuffer , Supplier < NetworkEvent . Context > , NetworkEvent > eventSupplier ; 
 + 
 + Network ( BiFunction < PacketBuffer , Supplier < NetworkEvent . Context > , NetworkEvent > eventSupplier ) 
 + { 
 + this . eventSupplier = eventSupplier ; 
 + } 
 + 
 + public NetworkEvent getEvent ( final PacketBuffer buffer , final Supplier < NetworkEvent . Context > manager ) { 
 + return this . eventSupplier . apply ( buffer , manager ) ; 
 + } 
 + 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java b / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java 
 new file mode 100644 
 index 0000000 . . 0948d4c 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkEvent . java 
 @ @ - 0 , 0 + 1 , 101 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2018 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . fml . network ; 
 + 
 + import net . minecraft . client . network . NetHandlerPlayClient ; 
 + import net . minecraft . network . INetHandler ; 
 + import net . minecraft . network . NetHandlerPlayServer ; 
 + import net . minecraft . network . NetworkManager ; 
 + import net . minecraft . network . PacketBuffer ; 
 + import net . minecraftforge . eventbus . api . Event ; 
 + 
 + import java . util . function . Supplier ; 
 + 
 + public class NetworkEvent extends Event 
 + { 
 + private final PacketBuffer payload ; 
 + private final Supplier < Context > source ; 
 + 
 + private NetworkEvent ( PacketBuffer payload , Supplier < Context > source ) 
 + { 
 + this . payload = payload ; 
 + this . source = source ; 
 + } 
 + 
 + public PacketBuffer getPayload ( ) 
 + { 
 + return payload ; 
 + } 
 + 
 + public Supplier < Context > getSource ( ) 
 + { 
 + return source ; 
 + } 
 + 
 + public static class ServerCustomPayloadEvent extends NetworkEvent 
 + { 
 + ServerCustomPayloadEvent ( final PacketBuffer payload , final Supplier < Context > source ) { 
 + super ( payload , source ) ; 
 + } 
 + } 
 + public static class ClientCustomPayloadEvent extends NetworkEvent 
 + { 
 + ClientCustomPayloadEvent ( final PacketBuffer payload , final Supplier < Context > source ) { 
 + super ( payload , source ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Context for { @ link NetworkEvent } 
 + * / 
 + public static class Context 
 + { 
 + / * * 
 + * The { @ link INetHandler } for this message . It could be a client or server handler , depending 
 + * on the { @ link # side } received . 
 + * / 
 + private final INetHandler netHandler ; 
 + 
 + / * * 
 + * The { @ link Network } this message has been received on 
 + * / 
 + private final Network side ; 
 + 
 + Context ( NetworkManager netHandler , Network side ) 
 + { 
 + this . netHandler = netHandler . getNetHandler ( ) ; 
 + this . side = side ; 
 + } 
 + 
 + public Network getSide ( ) { 
 + return side ; 
 + } 
 + 
 + public NetHandlerPlayServer getServerHandler ( ) 
 + { 
 + return ( NetHandlerPlayServer ) netHandler ; 
 + } 
 + 
 + public NetHandlerPlayClient getClientHandler ( ) 
 + { 
 + return ( NetHandlerPlayClient ) netHandler ; 
 + } 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 index ae7c877 . . 40503d3 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkHooks . java 
 @ @ - 27 , 7 + 27 , 6 @ @ import net . minecraft . network . handshake . client . C00Handshake ; 
 import net . minecraft . network . play . client . CPacketCustomPayload ; 
 import net . minecraft . network . play . server . SPacketCustomPayload ; 
 import net . minecraft . util . ResourceLocation ; 
 - import net . minecraftforge . fml . LogicalSide ; 
 import net . minecraftforge . fml . common . registry . EntityRegistry ; 
 
 import java . util . Objects ; 
 @ @ - 63 , 22 + 62 , 22 @ @ public class NetworkHooks 
 
 public static void onServerCustomPayload ( final SPacketCustomPayload packet , final NetworkManager manager ) { 
 NetworkRegistry . findTarget ( new ResourceLocation ( packet . getChannelName ( ) ) ) . 
 - ifPresent ( ni - > ni . dispatch ( NetworkInstance . NetworkSide . PLAYSERVER , packet . getBufferData ( ) , manager ) ) ; 
 + ifPresent ( ni - > ni . dispatch ( Network . PLAYSERVER , packet . getBufferData ( ) , manager ) ) ; 
 } 
 
 public static void onClientCustomPayload ( final CPacketCustomPayload packet , final NetworkManager manager ) { 
 NetworkRegistry . findTarget ( new ResourceLocation ( packet . getChannelName ( ) ) ) . 
 - ifPresent ( ni - > ni . dispatch ( NetworkInstance . NetworkSide . PLAYCLIENT , packet . getBufferData ( ) , manager ) ) ; 
 + ifPresent ( ni - > ni . dispatch ( Network . PLAYCLIENT , packet . getBufferData ( ) , manager ) ) ; 
 } 
 
 public static void onServerLoginCustomPayload ( final SPacketCustomPayload packet , final NetworkManager manager ) { 
 NetworkRegistry . findTarget ( new ResourceLocation ( packet . getChannelName ( ) ) ) . 
 - ifPresent ( ni - > ni . dispatch ( NetworkInstance . NetworkSide . LOGINSERVER , packet . getBufferData ( ) , manager ) ) ; 
 + ifPresent ( ni - > ni . dispatch ( Network . LOGINSERVER , packet . getBufferData ( ) , manager ) ) ; 
 } 
 
 public static void onClientLoginCustomPayload ( final CPacketCustomPayload packet , final NetworkManager manager ) { 
 NetworkRegistry . findTarget ( new ResourceLocation ( packet . getChannelName ( ) ) ) . 
 - ifPresent ( ni - > ni . dispatch ( NetworkInstance . NetworkSide . LOGINCLIENT , packet . getBufferData ( ) , manager ) ) ; 
 + ifPresent ( ni - > ni . dispatch ( Network . LOGINCLIENT , packet . getBufferData ( ) , manager ) ) ; 
 } 
 
 public static void registerServerChannel ( NetworkManager manager , C00Handshake packet ) 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java b / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java 
 index a2eb043 . . ad4dbeb 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkInstance . java 
 @ @ - 26 , 7 + 26 , 6 @ @ import net . minecraftforge . eventbus . api . Event ; 
 import net . minecraftforge . eventbus . api . IEventBus ; 
 import net . minecraftforge . eventbus . api . IEventListener ; 
 
 - import java . util . function . BiFunction ; 
 import java . util . function . Consumer ; 
 import java . util . function . Predicate ; 
 import java . util . function . Supplier ; 
 @ @ - 38 , 24 + 37 , 6 @ @ public class NetworkInstance 
 return channelName . toString ( ) ; 
 } 
 
 - public enum NetworkSide { 
 - PLAYSERVER ( NetworkEvent . ServerCustomPayloadEvent : : new ) , 
 - PLAYCLIENT ( NetworkEvent . ClientCustomPayloadEvent : : new ) , 
 - LOGINSERVER ( NetworkEvent . ServerCustomPayloadEvent : : new ) , 
 - LOGINCLIENT ( NetworkEvent . ClientCustomPayloadEvent : : new ) ; 
 - 
 - private final BiFunction < PacketBuffer , NetworkManager , NetworkEvent > eventSupplier ; 
 - 
 - NetworkSide ( BiFunction < PacketBuffer , NetworkManager , NetworkEvent > eventSupplier ) 
 - { 
 - this . eventSupplier = eventSupplier ; 
 - } 
 - 
 - public NetworkEvent getEvent ( final PacketBuffer buffer , final NetworkManager manager ) { 
 - return this . eventSupplier . apply ( buffer , manager ) ; 
 - } 
 - 
 - } 
 private final ResourceLocation channelName ; 
 private final Supplier < String > networkProtocolVersion ; 
 private final Predicate < String > clientAcceptedVersions ; 
 @ @ - 76 , 9 + 57 , 9 @ @ public class NetworkInstance 
 
 } 
 
 - public < T extends NetworkEvent > void addListener ( Consumer < T > serverEventListener ) 
 + public < T extends NetworkEvent > void addListener ( Consumer < T > eventListener ) 
 { 
 - this . networkEventBus . addListener ( serverEventListener ) ; 
 + this . networkEventBus . addListener ( eventListener ) ; 
 } 
 
 public void registerObject ( final Object object ) { 
 @ @ - 89 , 41 + 70 , 10 @ @ public class NetworkInstance 
 this . networkEventBus . unregister ( object ) ; 
 } 
 
 - void dispatch ( final NetworkSide side , final PacketBuffer bufferData , final NetworkManager manager ) 
 + void dispatch ( final Network side , final PacketBuffer bufferData , final NetworkManager manager ) 
 { 
 - this . networkEventBus . post ( side . getEvent ( bufferData , manager ) ) ; 
 + this . networkEventBus . post ( side . getEvent ( bufferData , ( ) - > new NetworkEvent . Context ( manager , side ) ) ) ; 
 } 
 
 
 - public static class NetworkEvent extends Event { 
 - private final PacketBuffer payload ; 
 - private final NetworkManager source ; 
 - 
 - private NetworkEvent ( PacketBuffer payload , NetworkManager source ) 
 - { 
 - this . payload = payload ; 
 - this . source = source ; 
 - } 
 - 
 - public PacketBuffer getPayload ( ) 
 - { 
 - return payload ; 
 - } 
 - 
 - public NetworkManager getSource ( ) 
 - { 
 - return source ; 
 - } 
 - 
 - public static class ServerCustomPayloadEvent extends NetworkEvent { 
 - ServerCustomPayloadEvent ( final PacketBuffer payload , final NetworkManager source ) { 
 - super ( payload , source ) ; 
 - } 
 - } 
 - public static class ClientCustomPayloadEvent extends NetworkEvent { 
 - ClientCustomPayloadEvent ( final PacketBuffer payload , final NetworkManager source ) { 
 - super ( payload , source ) ; 
 - } 
 - } 
 - } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 index 947393e . . 5fd89e2 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / NetworkRegistry . java 
 @ @ - 21 , 6 + 21 , 7 @ @ package net . minecraftforge . fml . network ; 
 
 import io . netty . util . AttributeKey ; 
 import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . fml . network . event . EventNetworkChannel ; 
 import net . minecraftforge . fml . network . simple . SimpleChannel ; 
 import org . apache . logging . log4j . LogManager ; 
 import org . apache . logging . log4j . Logger ; 
 @ @ - 50 , 13 + 51 , 21 @ @ public class NetworkRegistry 
 
 
 public static SimpleChannel newSimpleChannel ( final ResourceLocation name , Supplier < String > networkProtocolVersion , Predicate < String > clientAcceptedVersions , Predicate < String > serverAcceptedVersions ) { 
 + return new SimpleChannel ( createInstance ( name , networkProtocolVersion , clientAcceptedVersions , serverAcceptedVersions ) ) ; 
 + } 
 + 
 + public static EventNetworkChannel newEventChannel ( final ResourceLocation name , Supplier < String > networkProtocolVersion , Predicate < String > clientAcceptedVersions , Predicate < String > serverAcceptedVersions ) { 
 + return new EventNetworkChannel ( createInstance ( name , networkProtocolVersion , clientAcceptedVersions , serverAcceptedVersions ) ) ; 
 + } 
 + private static NetworkInstance createInstance ( ResourceLocation name , Supplier < String > networkProtocolVersion , Predicate < String > clientAcceptedVersions , Predicate < String > serverAcceptedVersions ) 
 + { 
 final NetworkInstance networkInstance = new NetworkInstance ( name , networkProtocolVersion , clientAcceptedVersions , serverAcceptedVersions ) ; 
 if ( instances . containsKey ( name ) ) { 
 LOGGER . error ( NETREGISTRY , " Network channel { } already registered . " , name ) ; 
 throw new IllegalArgumentException ( " Network Channel { " + name + " } already registered " ) ; 
 } 
 instances . put ( name , networkInstance ) ; 
 - return new SimpleChannel ( networkInstance ) ; 
 + return networkInstance ; 
 } 
 
 static Optional < NetworkInstance > findTarget ( ResourceLocation resourceLocation ) 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / Networking . java b / src / main / java / net / minecraftforge / fml / network / Networking . java 
 deleted file mode 100644 
 index 54d67df . . 0000000 
 - - - a / src / main / java / net / minecraftforge / fml / network / Networking . java 
 + + + / dev / null 
 @ @ - 1 , 25 + 0 , 0 @ @ 
 - / * 
 - * Minecraft Forge 
 - * Copyright ( c ) 2018 . 
 - * 
 - * This library is free software ; you can redistribute it and / or 
 - * modify it under the terms of the GNU Lesser General Public 
 - * License as published by the Free Software Foundation version 2 . 1 
 - * of the License . 
 - * 
 - * This library is distributed in the hope that it will be useful , 
 - * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 - * 
 - * You should have received a copy of the GNU Lesser General Public 
 - * License along with this library ; if not , write to the Free Software 
 - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 - * / 
 - 
 - package net . minecraftforge . fml . network ; 
 - 
 - public class Networking 
 - { 
 - public enum Type { SIMPLE , EVENT , NONE } 
 - } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / event / EventNetworkChannel . java b / src / main / java / net / minecraftforge / fml / network / event / EventNetworkChannel . java 
 new file mode 100644 
 index 0000000 . . de7cb88 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / fml / network / event / EventNetworkChannel . java 
 @ @ - 0 , 0 + 1 , 50 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2018 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . fml . network . event ; 
 + 
 + import net . minecraftforge . fml . network . NetworkEvent ; 
 + import net . minecraftforge . fml . network . NetworkInstance ; 
 + 
 + import java . util . function . Consumer ; 
 + 
 + public class EventNetworkChannel 
 + { 
 + private final NetworkInstance instance ; 
 + 
 + public EventNetworkChannel ( NetworkInstance instance ) 
 + { 
 + this . instance = instance ; 
 + } 
 + 
 + public < T extends NetworkEvent > void addListener ( Consumer < T > eventListener ) 
 + { 
 + instance . addListener ( eventListener ) ; 
 + } 
 + 
 + public void registerObject ( Object object ) 
 + { 
 + instance . registerObject ( object ) ; 
 + } 
 + 
 + public void unregisterObject ( Object object ) 
 + { 
 + instance . unregisterObject ( object ) ; 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java b / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java 
 index 865afbb . . 1a08fb1 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / simple / IndexedMessageCodec . java 
 @ @ - 22 , 6 + 22 , 7 @ @ package net . minecraftforge . fml . network . simple ; 
 import it . unimi . dsi . fastutil . objects . Object2ObjectArrayMap ; 
 import it . unimi . dsi . fastutil . shorts . Short2ObjectArrayMap ; 
 import net . minecraft . network . PacketBuffer ; 
 + import net . minecraftforge . fml . network . NetworkEvent ; 
 import org . apache . logging . log4j . LogManager ; 
 import org . apache . logging . log4j . Logger ; 
 import org . apache . logging . log4j . Marker ; 
 @ @ - 46 , 9 + 47 , 9 @ @ public class IndexedMessageCodec 
 private final Optional < BiConsumer < MSG , PacketBuffer > > encoder ; 
 private final Optional < Function < PacketBuffer , MSG > > decoder ; 
 private final int index ; 
 - private final BiConsumer < MSG , Supplier < MessageContext > > messageConsumer ; 
 + private final BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ; 
 private final Class < MSG > messageType ; 
 - public CodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < MessageContext > > messageConsumer ) 
 + public CodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) 
 { 
 this . index = index ; 
 this . messageType = messageType ; 
 @ @ - 61 , 13 + 62 , 16 @ @ public class IndexedMessageCodec 
 
 
 } 
 - private static < M > void tryDecode ( PacketBuffer payload , Supplier < MessageContext > context , CodecIndex < M > codec ) 
 + private static < M > void tryDecode ( PacketBuffer payload , Supplier < NetworkEvent . Context > context , CodecIndex < M > codec ) 
 { 
 codec . decoder . map ( d - > d . apply ( payload ) ) . ifPresent ( m - > codec . messageConsumer . accept ( m , context ) ) ; 
 } 
 
 private static < M > void tryEncode ( PacketBuffer target , M message , CodecIndex < M > codec ) { 
 - codec . encoder . ifPresent ( c - > c . accept ( message , target ) ) ; 
 + codec . encoder . ifPresent ( encoder - > { 
 + target . writeByte ( codec . index & 0xff ) ; 
 + encoder . accept ( message , target ) ; 
 + } ) ; 
 } 
 public < MSG > void build ( MSG message , PacketBuffer target ) 
 { 
 @ @ - 80 , 7 + 84 , 7 @ @ public class IndexedMessageCodec 
 tryEncode ( target , message , codecIndex ) ; 
 } 
 
 - void consume ( final PacketBuffer payload , Supplier < MessageContext > context ) { 
 + void consume ( final PacketBuffer payload , Supplier < NetworkEvent . Context > context ) { 
 short discriminator = payload . readUnsignedByte ( ) ; 
 final CodecIndex < ? > codecIndex = indicies . get ( discriminator ) ; 
 if ( codecIndex = = null ) { 
 @ @ - 90 , 7 + 94 , 7 @ @ public class IndexedMessageCodec 
 tryDecode ( payload , context , codecIndex ) ; 
 } 
 
 - < MSG > void addCodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < MessageContext > > messageConsumer ) { 
 + < MSG > void addCodecIndex ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { 
 new CodecIndex < > ( index , messageType , encoder , decoder , messageConsumer ) ; 
 } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / MessageContext . java b / src / main / java / net / minecraftforge / fml / network / simple / MessageContext . java 
 deleted file mode 100644 
 index b22f1bd . . 0000000 
 - - - a / src / main / java / net / minecraftforge / fml / network / simple / MessageContext . java 
 + + + / dev / null 
 @ @ - 1 , 70 + 0 , 0 @ @ 
 - / * 
 - * Minecraft Forge 
 - * Copyright ( c ) 2016 - 2018 . 
 - * 
 - * This library is free software ; you can redistribute it and / or 
 - * modify it under the terms of the GNU Lesser General Public 
 - * License as published by the Free Software Foundation version 2 . 1 
 - * of the License . 
 - * 
 - * This library is distributed in the hope that it will be useful , 
 - * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 - * 
 - * You should have received a copy of the GNU Lesser General Public 
 - * License along with this library ; if not , write to the Free Software 
 - * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 - * / 
 - 
 - package net . minecraftforge . fml . network . simple ; 
 - 
 - import net . minecraft . client . network . NetHandlerPlayClient ; 
 - import net . minecraft . network . INetHandler ; 
 - import net . minecraft . network . NetHandlerPlayServer ; 
 - import net . minecraft . network . NetworkManager ; 
 - import net . minecraftforge . api . distmarker . Dist ; 
 - import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; 
 - import net . minecraftforge . fml . network . NetworkInstance ; 
 - 
 - / * * 
 - * Context for the { @ link IMessageHandler } 
 - * 
 - * @ author cpw 
 - * 
 - * / 
 - public class MessageContext { 
 - / * * 
 - * The { @ link INetHandler } for this message . It could be a client or server handler , depending 
 - * on the { @ link # side } received . 
 - * / 
 - private final INetHandler netHandler ; 
 - 
 - / * * 
 - * The { @ link NetworkInstance . NetworkSide } this message has been received on 
 - * / 
 - private final NetworkInstance . NetworkSide side ; 
 - / * * 
 - * @ param netHandler 
 - * @ param side 
 - * / 
 - MessageContext ( NetworkManager netHandler , NetworkInstance . NetworkSide side ) 
 - { 
 - this . netHandler = netHandler . getNetHandler ( ) ; 
 - this . side = side ; 
 - } 
 - 
 - public NetworkInstance . NetworkSide getSide ( ) { 
 - return side ; 
 - } 
 - 
 - public NetHandlerPlayServer getServerHandler ( ) 
 - { 
 - return ( NetHandlerPlayServer ) netHandler ; 
 - } 
 - 
 - public NetHandlerPlayClient getClientHandler ( ) 
 - { 
 - return ( NetHandlerPlayClient ) netHandler ; 
 - } 
 - } 
 diff - - git a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 index d483da8 . . 79dfc62 100644 
 - - - a / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 + + + b / src / main / java / net / minecraftforge / fml / network / simple / SimpleChannel . java 
 @ @ - 19 , 12 + 19 , 11 @ @ 
 
 package net . minecraftforge . fml . network . simple ; 
 
 - import io . netty . buffer . ByteBuf ; 
 import io . netty . buffer . Unpooled ; 
 import net . minecraft . client . Minecraft ; 
 - import net . minecraft . network . NetworkManager ; 
 import net . minecraft . network . PacketBuffer ; 
 import net . minecraft . network . play . client . CPacketCustomPayload ; 
 + import net . minecraftforge . fml . network . NetworkEvent ; 
 import net . minecraftforge . fml . network . NetworkInstance ; 
 
 import java . util . function . BiConsumer ; 
 @ @ - 40 , 24 + 39 , 18 @ @ public class SimpleChannel 
 { 
 this . instance = instance ; 
 this . indexedCodec = new IndexedMessageCodec ( ) ; 
 - instance . addListener ( this : : serverEventListener ) ; 
 - instance . addListener ( this : : clientEventListener ) ; 
 + instance . addListener ( this : : networkEventListener ) ; 
 } 
 
 - private void clientEventListener ( final NetworkInstance . NetworkEvent . ClientCustomPayloadEvent clientCustomPayloadEvent ) 
 + private void networkEventListener ( final NetworkEvent networkEvent ) 
 { 
 - } 
 - 
 - private void serverEventListener ( final NetworkInstance . NetworkEvent . ServerCustomPayloadEvent serverCustomPayloadEvent ) 
 - { 
 - this . indexedCodec . consume ( serverCustomPayloadEvent . getPayload ( ) , 
 - ( ) - > new MessageContext ( serverCustomPayloadEvent . getSource ( ) , NetworkInstance . NetworkSide . PLAYSERVER ) ) ; 
 + this . indexedCodec . consume ( networkEvent . getPayload ( ) , networkEvent . getSource ( ) ) ; 
 } 
 
 public < MSG > void encodeMessage ( MSG message , final PacketBuffer target ) { 
 this . indexedCodec . build ( message , target ) ; 
 } 
 - public < MSG > void registerMessage ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < MessageContext > > messageConsumer ) { 
 + public < MSG > void registerMessage ( int index , Class < MSG > messageType , BiConsumer < MSG , PacketBuffer > encoder , Function < PacketBuffer , MSG > decoder , BiConsumer < MSG , Supplier < NetworkEvent . Context > > messageConsumer ) { 
 this . indexedCodec . addCodecIndex ( index , messageType , encoder , decoder , messageConsumer ) ; 
 } 
 
 diff - - git a / src / test / java / net / minecraftforge / debug / item / MapDataTest . java b / src / test / java / net / minecraftforge / debug / item / MapDataTest . java 
 index e0b5150 . . 45a213d 100644 
 - - - a / src / test / java / net / minecraftforge / debug / item / MapDataTest . java 
 + + + b / src / test / java / net / minecraftforge / debug / item / MapDataTest . java 
 @ @ - 51 , 7 + 51 , 7 @ @ import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 import net . minecraftforge . eventbus . api . SubscribeEvent ; 
 import net . minecraftforge . fml . common . network . simpleimpl . IMessage ; 
 import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; 
 - import net . minecraftforge . fml . network . simple . MessageContext ; 
 + import net . minecraftforge . fml . network . NetworkEvent ; 
 import net . minecraftforge . fml . common . network . simpleimpl . SimpleNetworkWrapper ; 
 import net . minecraftforge . fml . common . registry . GameRegistry ; 
 
 @ @ - 237 , 7 + 237 , 7 @ @ public class MapDataTest 
 { 
 @ Nullable 
 @ Override 
 - public IMessage onMessage ( CustomMapPacket message , MessageContext ctx ) 
 + public IMessage onMessage ( CustomMapPacket message , NetworkEvent . Context ctx ) 
 { 
 / / Like NetHandlerPlayClient . handleMaps but using our custom type 
 Minecraft . getMinecraft ( ) . addScheduledTask ( new Runnable ( ) { 
 diff - - git a / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler1 . java b / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler1 . java 
 index 9dfff55 . . cdb360f 100644 
 - - - a / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler1 . java 
 + + + b / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler1 . java 
 @ @ - 20 , 12 + 20 , 12 @ @ 
 package net . minecraftforge . fml . test . simplenet ; 
 
 import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; 
 - import net . minecraftforge . fml . network . simple . MessageContext ; 
 + import net . minecraftforge . fml . network . NetworkEvent ; 
 
 public class SimpleNetHandler1 implements IMessageHandler < SimpleNetTestMessage1 , SimpleNetTestMessage2 > 
 { 
 @ Override 
 - public SimpleNetTestMessage2 onMessage ( SimpleNetTestMessage1 message , MessageContext context ) 
 + public SimpleNetTestMessage2 onMessage ( SimpleNetTestMessage1 message , NetworkEvent . Context context ) 
 { 
 return null ; 
 } 
 diff - - git a / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler2 . java b / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler2 . java 
 index 804e640 . . edbc3d2 100644 
 - - - a / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler2 . java 
 + + + b / src / test / java / net / minecraftforge / fml / test / simplenet / SimpleNetHandler2 . java 
 @ @ - 20 , 12 + 20 , 12 @ @ 
 package net . minecraftforge . fml . test . simplenet ; 
 
 import net . minecraftforge . fml . common . network . simpleimpl . IMessageHandler ; 
 - import net . minecraftforge . fml . network . simple . MessageContext ; 
 + import net . minecraftforge . fml . network . NetworkEvent ; 
 
 public class SimpleNetHandler2 implements IMessageHandler < SimpleNetTestMessage2 , SimpleNetTestMessage1 > 
 { 
 @ Override 
 - public SimpleNetTestMessage1 onMessage ( SimpleNetTestMessage2 message , MessageContext context ) 
 + public SimpleNetTestMessage1 onMessage ( SimpleNetTestMessage2 message , NetworkEvent . Context context ) 
 { 
 return null ; 
 }
