BLEU SCORE: 0.007855246784369017

TEST MSG: Derp .
GENERATED MSG: Fix dependency resolution for models with custom data / textures .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> index 865d402 . . ca65794 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> @ @ - 330 , 7 + 330 , 7 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> } <nl> <nl> - private IModel getVariantModel ( ModelResourceLocation location ) <nl> + IModel getVariantModel ( ModelResourceLocation location ) <nl> { <nl> loadVariants ( ImmutableList . of ( location ) ) ; <nl> IModel model = stateModels . get ( location ) ; <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / MultiModelState . java b / src / main / java / net / minecraftforge / client / model / MultiModelState . java <nl> new file mode 100644 <nl> index 0000000 . . 15e9dff <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / client / model / MultiModelState . java <nl> @ @ - 0 , 0 + 1 , 128 @ @ <nl> + package net . minecraftforge . client . model ; <nl> + <nl> + import org . apache . commons . lang3 . tuple . Pair ; <nl> + <nl> + import com . google . common . base . Objects ; <nl> + import com . google . common . base . Optional ; <nl> + import com . google . common . collect . ImmutableList ; <nl> + import com . google . common . collect . ImmutableMap ; <nl> + <nl> + public class MultiModelState implements IModelState <nl> + { <nl> + private final ImmutableMap < MultiModelPart , ? extends IModelState > states ; <nl> + <nl> + public < M extends IModel , S extends IModelState > MultiModelState ( ImmutableList < Pair < M , S > > states ) <nl> + { <nl> + ImmutableMap . Builder < MultiModelPart , S > builder = ImmutableMap . builder ( ) ; <nl> + for ( int i = 0 ; i < states . size ( ) ; i + + ) <nl> + { <nl> + Pair < M , S > pair = states . get ( i ) ; <nl> + builder . put ( new MultiModelPart ( pair . getLeft ( ) , i ) , pair . getRight ( ) ) ; <nl> + } <nl> + this . states = builder . build ( ) ; <nl> + } <nl> + <nl> + public static IModelState getPartState ( IModelState state , IModel model , int index ) <nl> + { <nl> + if ( state . apply ( Optional . of ( new MultiModelPart ( model , index ) ) ) . isPresent ( ) ) <nl> + { <nl> + return new PartState ( state , model , index ) ; <nl> + } <nl> + return state ; <nl> + } <nl> + <nl> + public Optional < TRSRTransformation > apply ( Optional < ? extends IModelPart > part ) <nl> + { <nl> + if ( part . isPresent ( ) ) <nl> + { <nl> + if ( part . get ( ) instanceof MultiModelPart ) <nl> + { <nl> + MultiModelPart key = ( MultiModelPart ) part . get ( ) ; <nl> + if ( states . containsKey ( key ) ) <nl> + { <nl> + return Optional . of ( states . get ( key ) . apply ( Optional . < IModelPart > absent ( ) ) . or ( TRSRTransformation . identity ( ) ) ) ; <nl> + } <nl> + } <nl> + else if ( part . get ( ) instanceof PartPart ) <nl> + { <nl> + PartPart partPart = ( PartPart ) part . get ( ) ; <nl> + MultiModelPart key = new MultiModelPart ( partPart . model , partPart . index ) ; <nl> + if ( states . containsKey ( key ) ) <nl> + { <nl> + return states . get ( key ) . apply ( partPart . part ) ; <nl> + } <nl> + } <nl> + } <nl> + return Optional . absent ( ) ; <nl> + } <nl> + <nl> + private static class PartState implements IModelState <nl> + { <nl> + private final IModelState state ; <nl> + private final IModel model ; <nl> + private final int index ; <nl> + <nl> + public PartState ( IModelState state , IModel model , int index ) <nl> + { <nl> + this . state = state ; <nl> + this . model = model ; <nl> + this . index = index ; <nl> + } <nl> + <nl> + public Optional < TRSRTransformation > apply ( Optional < ? extends IModelPart > part ) <nl> + { <nl> + Optional < TRSRTransformation > normal = state . apply ( part ) ; <nl> + Optional < TRSRTransformation > multi = state . apply ( Optional . of ( new PartPart ( model , index , part ) ) ) ; <nl> + if ( normal . isPresent ( ) & & multi . isPresent ( ) ) <nl> + { <nl> + return Optional . of ( normal . get ( ) . compose ( multi . get ( ) ) ) ; <nl> + } <nl> + return normal . or ( multi ) ; <nl> + } <nl> + } <nl> + <nl> + private static class MultiModelPart implements IModelPart <nl> + { <nl> + private final IModel model ; <nl> + private final int index ; <nl> + <nl> + public MultiModelPart ( IModel model , int index ) <nl> + { <nl> + this . model = model ; <nl> + this . index = index ; <nl> + } <nl> + <nl> + @ Override <nl> + public int hashCode ( ) <nl> + { <nl> + return Objects . hashCode ( model , index ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean equals ( Object obj ) <nl> + { <nl> + if ( this = = obj ) <nl> + return true ; <nl> + if ( obj = = null ) <nl> + return false ; <nl> + if ( getClass ( ) ! = obj . getClass ( ) ) <nl> + return false ; <nl> + MultiModelPart other = ( MultiModelPart ) obj ; <nl> + return Objects . equal ( this . model , other . model ) & & this . index = = other . index ; <nl> + } <nl> + } <nl> + <nl> + private static class PartPart implements IModelPart <nl> + { <nl> + private final IModel model ; <nl> + private final int index ; <nl> + private final Optional < ? extends IModelPart > part ; <nl> + <nl> + public PartPart ( IModel model , int index , Optional < ? extends IModelPart > part ) <nl> + { <nl> + this . model = model ; <nl> + this . index = index ; <nl> + this . part = part ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> index f0b4850 . . b4c8dc5 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> @ @ - 225 , 18 + 225 , 7 @ @ public class ModelLoader extends ModelBakery <nl> try <nl> { <nl> IModel model = ModelLoaderRegistry . getModel ( location ) ; <nl> - for ( ResourceLocation dep : model . getDependencies ( ) ) <nl> - { <nl> - if ( dep instanceof ModelResourceLocation ) <nl> - { <nl> - loadVariants ( ImmutableList . of ( ( ModelResourceLocation ) dep ) ) ; <nl> - } <nl> - else <nl> - { <nl> - getModel ( dep ) ; <nl> - } <nl> - } <nl> - textures . addAll ( model . getTextures ( ) ) ; <nl> + resolveDependencies ( model ) ; <nl> } <nl> finally <nl> { <nl> @ @ - 244 , 6 + 233 , 22 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> } <nl> <nl> + private void resolveDependencies ( IModel model ) throws IOException <nl> + { <nl> + for ( ResourceLocation dep : model . getDependencies ( ) ) <nl> + { <nl> + if ( dep instanceof ModelResourceLocation ) <nl> + { <nl> + loadVariants ( ImmutableList . of ( ( ModelResourceLocation ) dep ) ) ; <nl> + } <nl> + else <nl> + { <nl> + getModel ( dep ) ; <nl> + } <nl> + } <nl> + textures . addAll ( model . getTextures ( ) ) ; <nl> + } <nl> + <nl> private class VanillaModelWrapper implements IRetexturableModel <nl> { <nl> private final ResourceLocation location ; <nl> @ @ - 563 , 6 + 568 , 14 @ @ public class ModelLoader extends ModelBakery <nl> if ( v instanceof ISmartVariant ) <nl> { <nl> model = ( ( ISmartVariant ) v ) . process ( model , ModelLoader . this ) ; <nl> + try <nl> + { <nl> + resolveDependencies ( model ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + FMLLog . getLogger ( ) . error ( " Exception resolving indirect dependencies for model " + loc , e ) ; <nl> + } <nl> textures . addAll ( model . getTextures ( ) ) ; / / Kick this , just in case . <nl> } <nl>

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 index 865d402 . . ca65794 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 @ @ - 330 , 7 + 330 , 7 @ @ public class ModelLoader extends ModelBakery 
 } 
 } 
 
 - private IModel getVariantModel ( ModelResourceLocation location ) 
 + IModel getVariantModel ( ModelResourceLocation location ) 
 { 
 loadVariants ( ImmutableList . of ( location ) ) ; 
 IModel model = stateModels . get ( location ) ; 
 diff - - git a / src / main / java / net / minecraftforge / client / model / MultiModelState . java b / src / main / java / net / minecraftforge / client / model / MultiModelState . java 
 new file mode 100644 
 index 0000000 . . 15e9dff 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / client / model / MultiModelState . java 
 @ @ - 0 , 0 + 1 , 128 @ @ 
 + package net . minecraftforge . client . model ; 
 + 
 + import org . apache . commons . lang3 . tuple . Pair ; 
 + 
 + import com . google . common . base . Objects ; 
 + import com . google . common . base . Optional ; 
 + import com . google . common . collect . ImmutableList ; 
 + import com . google . common . collect . ImmutableMap ; 
 + 
 + public class MultiModelState implements IModelState 
 + { 
 + private final ImmutableMap < MultiModelPart , ? extends IModelState > states ; 
 + 
 + public < M extends IModel , S extends IModelState > MultiModelState ( ImmutableList < Pair < M , S > > states ) 
 + { 
 + ImmutableMap . Builder < MultiModelPart , S > builder = ImmutableMap . builder ( ) ; 
 + for ( int i = 0 ; i < states . size ( ) ; i + + ) 
 + { 
 + Pair < M , S > pair = states . get ( i ) ; 
 + builder . put ( new MultiModelPart ( pair . getLeft ( ) , i ) , pair . getRight ( ) ) ; 
 + } 
 + this . states = builder . build ( ) ; 
 + } 
 + 
 + public static IModelState getPartState ( IModelState state , IModel model , int index ) 
 + { 
 + if ( state . apply ( Optional . of ( new MultiModelPart ( model , index ) ) ) . isPresent ( ) ) 
 + { 
 + return new PartState ( state , model , index ) ; 
 + } 
 + return state ; 
 + } 
 + 
 + public Optional < TRSRTransformation > apply ( Optional < ? extends IModelPart > part ) 
 + { 
 + if ( part . isPresent ( ) ) 
 + { 
 + if ( part . get ( ) instanceof MultiModelPart ) 
 + { 
 + MultiModelPart key = ( MultiModelPart ) part . get ( ) ; 
 + if ( states . containsKey ( key ) ) 
 + { 
 + return Optional . of ( states . get ( key ) . apply ( Optional . < IModelPart > absent ( ) ) . or ( TRSRTransformation . identity ( ) ) ) ; 
 + } 
 + } 
 + else if ( part . get ( ) instanceof PartPart ) 
 + { 
 + PartPart partPart = ( PartPart ) part . get ( ) ; 
 + MultiModelPart key = new MultiModelPart ( partPart . model , partPart . index ) ; 
 + if ( states . containsKey ( key ) ) 
 + { 
 + return states . get ( key ) . apply ( partPart . part ) ; 
 + } 
 + } 
 + } 
 + return Optional . absent ( ) ; 
 + } 
 + 
 + private static class PartState implements IModelState 
 + { 
 + private final IModelState state ; 
 + private final IModel model ; 
 + private final int index ; 
 + 
 + public PartState ( IModelState state , IModel model , int index ) 
 + { 
 + this . state = state ; 
 + this . model = model ; 
 + this . index = index ; 
 + } 
 + 
 + public Optional < TRSRTransformation > apply ( Optional < ? extends IModelPart > part ) 
 + { 
 + Optional < TRSRTransformation > normal = state . apply ( part ) ; 
 + Optional < TRSRTransformation > multi = state . apply ( Optional . of ( new PartPart ( model , index , part ) ) ) ; 
 + if ( normal . isPresent ( ) & & multi . isPresent ( ) ) 
 + { 
 + return Optional . of ( normal . get ( ) . compose ( multi . get ( ) ) ) ; 
 + } 
 + return normal . or ( multi ) ; 
 + } 
 + } 
 + 
 + private static class MultiModelPart implements IModelPart 
 + { 
 + private final IModel model ; 
 + private final int index ; 
 + 
 + public MultiModelPart ( IModel model , int index ) 
 + { 
 + this . model = model ; 
 + this . index = index ; 
 + } 
 + 
 + @ Override 
 + public int hashCode ( ) 
 + { 
 + return Objects . hashCode ( model , index ) ; 
 + } 
 + 
 + @ Override 
 + public boolean equals ( Object obj ) 
 + { 
 + if ( this = = obj ) 
 + return true ; 
 + if ( obj = = null ) 
 + return false ; 
 + if ( getClass ( ) ! = obj . getClass ( ) ) 
 + return false ; 
 + MultiModelPart other = ( MultiModelPart ) obj ; 
 + return Objects . equal ( this . model , other . model ) & & this . index = = other . index ; 
 + } 
 + } 
 + 
 + private static class PartPart implements IModelPart 
 + { 
 + private final IModel model ; 
 + private final int index ; 
 + private final Optional < ? extends IModelPart > part ; 
 + 
 + public PartPart ( IModel model , int index , Optional < ? extends IModelPart > part ) 
 + { 
 + this . model = model ; 
 + this . index = index ; 
 + this . part = part ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 index f0b4850 . . b4c8dc5 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 @ @ - 225 , 18 + 225 , 7 @ @ public class ModelLoader extends ModelBakery 
 try 
 { 
 IModel model = ModelLoaderRegistry . getModel ( location ) ; 
 - for ( ResourceLocation dep : model . getDependencies ( ) ) 
 - { 
 - if ( dep instanceof ModelResourceLocation ) 
 - { 
 - loadVariants ( ImmutableList . of ( ( ModelResourceLocation ) dep ) ) ; 
 - } 
 - else 
 - { 
 - getModel ( dep ) ; 
 - } 
 - } 
 - textures . addAll ( model . getTextures ( ) ) ; 
 + resolveDependencies ( model ) ; 
 } 
 finally 
 { 
 @ @ - 244 , 6 + 233 , 22 @ @ public class ModelLoader extends ModelBakery 
 } 
 } 
 
 + private void resolveDependencies ( IModel model ) throws IOException 
 + { 
 + for ( ResourceLocation dep : model . getDependencies ( ) ) 
 + { 
 + if ( dep instanceof ModelResourceLocation ) 
 + { 
 + loadVariants ( ImmutableList . of ( ( ModelResourceLocation ) dep ) ) ; 
 + } 
 + else 
 + { 
 + getModel ( dep ) ; 
 + } 
 + } 
 + textures . addAll ( model . getTextures ( ) ) ; 
 + } 
 + 
 private class VanillaModelWrapper implements IRetexturableModel 
 { 
 private final ResourceLocation location ; 
 @ @ - 563 , 6 + 568 , 14 @ @ public class ModelLoader extends ModelBakery 
 if ( v instanceof ISmartVariant ) 
 { 
 model = ( ( ISmartVariant ) v ) . process ( model , ModelLoader . this ) ; 
 + try 
 + { 
 + resolveDependencies ( model ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + FMLLog . getLogger ( ) . error ( " Exception resolving indirect dependencies for model " + loc , e ) ; 
 + } 
 textures . addAll ( model . getTextures ( ) ) ; / / Kick this , just in case . 
 } 

