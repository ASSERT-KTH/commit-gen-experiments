BLEU SCORE: 0.007866467405572666

TEST MSG: Rework EventSubscriptionTransformer to bake @ Cancelable and @ HasResult values , should increase EventBus performance even more by removing logic from Event constructors .
GENERATED MSG: Commit the start of some pluggable transformers

TEST DIFF (one line): diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / asm / transformers / EventSubscriptionTransformer . java b / fml / src / main / java / net / minecraftforge / fml / common / asm / transformers / EventSubscriptionTransformer . java <nl> index 86a9f11 . . 6f2c117 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / asm / transformers / EventSubscriptionTransformer . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / asm / transformers / EventSubscriptionTransformer . java <nl> @ @ - 17 , 7 + 17 , 10 @ @ import static org . objectweb . asm . Opcodes . INVOKESPECIAL ; <nl> import static org . objectweb . asm . Opcodes . NEW ; <nl> import static org . objectweb . asm . Opcodes . PUTSTATIC ; <nl> import static org . objectweb . asm . Opcodes . RETURN ; <nl> + import static org . objectweb . asm . Opcodes . IRETURN ; <nl> + import static org . objectweb . asm . Opcodes . ICONST _ 1 ; <nl> import static org . objectweb . asm . Type . VOID _ TYPE ; <nl> + import static org . objectweb . asm . Type . BOOLEAN _ TYPE ; <nl> import static org . objectweb . asm . Type . getMethodDescriptor ; <nl> <nl> import java . util . List ; <nl> @ @ - 28 , 6 + 31 , 7 @ @ import net . minecraftforge . fml . common . eventhandler . Event ; <nl> import org . objectweb . asm . ClassReader ; <nl> import org . objectweb . asm . ClassWriter ; <nl> import org . objectweb . asm . Type ; <nl> + import org . objectweb . asm . tree . AnnotationNode ; <nl> import org . objectweb . asm . tree . ClassNode ; <nl> import org . objectweb . asm . tree . FieldInsnNode ; <nl> import org . objectweb . asm . tree . FieldNode ; <nl> @ @ - 81 , 56 + 85 , 87 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> <nl> private boolean buildEvents ( ClassNode classNode ) throws Exception <nl> { <nl> + / / Yes , this recursively loads classes until we get this base class . THIS IS NOT A ISSUE . Coremods should handle re - entry just fine . <nl> + / / If they do not this a COREMOD issue NOT a Forge / LaunchWrapper issue . <nl> Class < ? > parent = this . getClass ( ) . getClassLoader ( ) . loadClass ( classNode . superName . replace ( ' / ' , ' . ' ) ) ; <nl> if ( ! Event . class . isAssignableFrom ( parent ) ) <nl> { <nl> return false ; <nl> } <nl> <nl> - boolean hasSetup = false ; <nl> - boolean hasGetListenerList = false ; <nl> - boolean hasDefaultCtr = false ; <nl> + / / Class < ? > listenerListClazz = Class . forName ( " net . minecraftforge . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; <nl> + Type tList = Type . getType ( " Lnet / minecraftforge / fml / common / eventhandler / ListenerList ; " ) ; <nl> <nl> - Class < ? > listenerListClazz = Class . forName ( " net . minecraftforge . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; <nl> - Type tList = Type . getType ( listenerListClazz ) ; <nl> + boolean edited = false ; <nl> + boolean hasSetup = false ; <nl> + boolean hasGetListenerList = false ; <nl> + boolean hasDefaultCtr = false ; <nl> + boolean hasCancelable = false ; <nl> + boolean hasResult = false ; <nl> + String voidDesc = Type . getMethodDescriptor ( VOID _ TYPE ) ; <nl> + String boolDesc = Type . getMethodDescriptor ( BOOLEAN _ TYPE ) ; <nl> + String listDesc = tList . getDescriptor ( ) ; <nl> + String listDescM = Type . getMethodDescriptor ( tList ) ; <nl> <nl> for ( MethodNode method : ( List < MethodNode > ) classNode . methods ) <nl> { <nl> - if ( method . name . equals ( " setup " ) & & <nl> - method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) & & <nl> - ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) <nl> - { <nl> - hasSetup = true ; <nl> - } <nl> - if ( method . name . equals ( " getListenerList " ) & & <nl> - method . desc . equals ( Type . getMethodDescriptor ( tList ) ) & & <nl> - ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) <nl> + if ( method . name . equals ( " setup " ) & & method . desc . equals ( voidDesc ) & & ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) hasSetup = true ; <nl> + if ( ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) <nl> + { <nl> + if ( method . name . equals ( " getListenerList " ) & & method . desc . equals ( listDescM ) ) hasGetListenerList = true ; <nl> + if ( method . name . equals ( " isCancelable " ) & & method . desc . equals ( boolDesc ) ) hasCancelable = true ; <nl> + if ( method . name . equals ( " hasResult " ) & & method . desc . equals ( boolDesc ) ) hasResult = true ; <nl> + } <nl> + if ( method . name . equals ( " < init > " ) & & method . desc . equals ( voidDesc ) ) hasDefaultCtr = true ; <nl> + } <nl> + <nl> + if ( classNode . visibleAnnotations ! = null ) <nl> + { <nl> + for ( AnnotationNode node : classNode . visibleAnnotations ) <nl> + { <nl> + if ( ! hasResult & & node . desc . equals ( " Lnet / minecraftforge / fml / common / eventhandler / Event $ HasResult ; " ) ) <nl> { <nl> - hasGetListenerList = true ; <nl> + / * Add : <nl> + * public boolean hasResult ( ) <nl> + * { <nl> + * return true ; <nl> + * } <nl> + * / <nl> + MethodNode method = new MethodNode ( ACC _ PUBLIC , " hasResult " , boolDesc , null , null ) ; <nl> + method . instructions . add ( new InsnNode ( ICONST _ 1 ) ) ; <nl> + method . instructions . add ( new InsnNode ( IRETURN ) ) ; <nl> + classNode . methods . add ( method ) ; <nl> + edited = true ; <nl> } <nl> - if ( method . name . equals ( " < init > " ) & & <nl> - method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) ) <nl> + else if ( ! hasCancelable & & node . desc . equals ( " Lnet / minecraftforge / fml / common / eventhandler / Cancelable ; " ) ) <nl> { <nl> - hasDefaultCtr = true ; <nl> + / * Add : <nl> + * public boolean isCancelable ( ) <nl> + * { <nl> + * return true ; <nl> + * } <nl> + * / <nl> + MethodNode method = new MethodNode ( ACC _ PUBLIC , " isCancelable " , boolDesc , null , null ) ; <nl> + method . instructions . add ( new InsnNode ( ICONST _ 1 ) ) ; <nl> + method . instructions . add ( new InsnNode ( IRETURN ) ) ; <nl> + classNode . methods . add ( method ) ; <nl> + edited = true ; <nl> } <nl> + } <nl> } <nl> <nl> if ( hasSetup ) <nl> { <nl> - if ( ! hasGetListenerList ) <nl> - { <nl> - throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; <nl> - } <nl> - else <nl> - { <nl> - return false ; <nl> - } <nl> + if ( ! hasGetListenerList ) <nl> + throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; <nl> + else <nl> + return edited ; <nl> } <nl> <nl> Type tSuper = Type . getType ( classNode . superName ) ; <nl> <nl> / / Add private static ListenerList LISTENER _ LIST <nl> - classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , tList . getDescriptor ( ) , null , null ) ) ; <nl> + classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , listDesc , null , null ) ) ; <nl> <nl> / * Add : <nl> * public < init > ( ) <nl> @ @ - 138 , 12 + 173 , 12 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> * super ( ) ; <nl> * } <nl> * / <nl> - MethodNode method = new MethodNode ( ASM5 , ACC _ PUBLIC , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; <nl> - method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , false ) ) ; <nl> - method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> if ( ! hasDefaultCtr ) <nl> { <nl> + MethodNode method = new MethodNode ( ACC _ PUBLIC , " < init > " , voidDesc , null , null ) ; <nl> + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , voidDesc , false ) ) ; <nl> + method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> classNode . methods . add ( method ) ; <nl> } <nl> <nl> @ @ - 158 , 10 + 193 , 10 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> * LISTENER _ LIST = new ListenerList ( super . getListenerList ( ) ) ; <nl> * } <nl> * / <nl> - method = new MethodNode ( ASM5 , ACC _ PROTECTED , " setup " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; <nl> + MethodNode method = new MethodNode ( ACC _ PROTECTED , " setup " , voidDesc , null , null ) ; <nl> method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , getMethodDescriptor ( VOID _ TYPE ) , false ) ) ; <nl> - method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , voidDesc , false ) ) ; <nl> + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; <nl> LabelNode initLisitener = new LabelNode ( ) ; <nl> method . instructions . add ( new JumpInsnNode ( IFNULL , initLisitener ) ) ; <nl> method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> @ @ - 170 , 9 + 205 , 9 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> method . instructions . add ( new TypeInsnNode ( NEW , tList . getInternalName ( ) ) ) ; <nl> method . instructions . add ( new InsnNode ( DUP ) ) ; <nl> method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; <nl> - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , getMethodDescriptor ( tList ) , false ) ) ; <nl> + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , listDescM , false ) ) ; <nl> method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tList . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE , tList ) , false ) ) ; <nl> - method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; <nl> method . instructions . add ( new InsnNode ( RETURN ) ) ; <nl> classNode . methods . add ( method ) ; <nl> <nl> @ @ - 182 , 8 + 217 , 8 @ @ public class EventSubscriptionTransformer implements IClassTransformer <nl> * return this . LISTENER _ LIST ; <nl> * } <nl> * / <nl> - method = new MethodNode ( ASM5 , ACC _ PUBLIC , " getListenerList " , getMethodDescriptor ( tList ) , null , null ) ; <nl> - method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; <nl> + method = new MethodNode ( ACC _ PUBLIC , " getListenerList " , listDescM , null , null ) ; <nl> + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; <nl> method . instructions . add ( new InsnNode ( ARETURN ) ) ; <nl> classNode . methods . add ( method ) ; <nl> return true ; <nl> diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / eventhandler / Event . java b / fml / src / main / java / net / minecraftforge / fml / common / eventhandler / Event . java <nl> index a1a60df . . e02f9f6 100644 <nl> - - - a / fml / src / main / java / net / minecraftforge / fml / common / eventhandler / Event . java <nl> + + + b / fml / src / main / java / net / minecraftforge / fml / common / eventhandler / Event . java <nl> @ @ - 32 , 9 + 32 , 7 @ @ public class Event <nl> } <nl> <nl> private boolean isCanceled = false ; <nl> - private final boolean isCancelable ; <nl> private Result result = Result . DEFAULT ; <nl> - private final boolean hasResult ; <nl> private static ListenerList listeners = new ListenerList ( ) ; <nl> private EventPriority phase = null ; <nl> <nl> @ @ - 43 , 48 + 41 , 18 @ @ public class Event <nl> public Event ( ) <nl> { <nl> setup ( ) ; <nl> - isCancelable = hasAnnotation ( Cancelable . class ) ; <nl> - hasResult = hasAnnotation ( HasResult . class ) ; <nl> - } <nl> - <nl> - private boolean hasAnnotation ( Class < ? extends Annotation > annotation ) <nl> - { <nl> - Class < ? > me = this . getClass ( ) ; <nl> - Map < Class < ? > , Boolean > list = annotationMap . get ( me ) ; <nl> - if ( list = = null ) <nl> - { <nl> - list = new ConcurrentHashMap < Class < ? > , Boolean > ( ) ; <nl> - annotationMap . put ( me , list ) ; <nl> - } <nl> - <nl> - Boolean cached = list . get ( annotation ) ; <nl> - if ( cached ! = null ) <nl> - { <nl> - return cached ; <nl> - } <nl> - <nl> - Class < ? > cls = me ; <nl> - while ( cls ! = Event . class ) <nl> - { <nl> - if ( cls . isAnnotationPresent ( annotation ) ) <nl> - { <nl> - list . put ( annotation , true ) ; <nl> - return true ; <nl> - } <nl> - cls = cls . getSuperclass ( ) ; <nl> - } <nl> - <nl> - list . put ( annotation , false ) ; <nl> - return false ; <nl> } <nl> <nl> / * * <nl> * Determine if this function is cancelable at all . <nl> * @ return If access to setCanceled should be allowed <nl> + * <nl> + * Note : <nl> + * Events with the Cancelable annotation will have this method automatically added to return true . <nl> * / <nl> public boolean isCancelable ( ) <nl> { <nl> - return isCancelable ; <nl> + return false ; <nl> } <nl> <nl> / * * <nl> @ @ - 115 , 10 + 83 , 13 @ @ public class Event <nl> <nl> / * * <nl> * Determines if this event expects a significant result value . <nl> + * <nl> + * Note : <nl> + * Events with the HasResult annotation will have this method automatically added to return true . <nl> * / <nl> public boolean hasResult ( ) <nl> { <nl> - return hasResult ; <nl> + return false ; <nl> } <nl> <nl> / * *
NEAREST DIFF (one line): diff - - git a / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java <nl> new file mode 100644 <nl> index 0000000 . . 760284e <nl> - - - / dev / null <nl> + + + b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java <nl> @ @ - 0 , 0 + 1 , 357 @ @ <nl> + package cpw . mods . fml . common . asm . transformers ; <nl> + <nl> + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; <nl> + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; <nl> + <nl> + import java . io . BufferedInputStream ; <nl> + import java . io . BufferedOutputStream ; <nl> + import java . io . BufferedReader ; <nl> + import java . io . ByteArrayOutputStream ; <nl> + import java . io . File ; <nl> + import java . io . FileInputStream ; <nl> + import java . io . FileNotFoundException ; <nl> + import java . io . FileOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStream ; <nl> + import java . io . InputStreamReader ; <nl> + import java . net . URL ; <nl> + import java . text . SimpleDateFormat ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collection ; <nl> + import java . util . Date ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + import java . util . zip . ZipEntry ; <nl> + import java . util . zip . ZipInputStream ; <nl> + import java . util . zip . ZipOutputStream ; <nl> + <nl> + import org . objectweb . asm . ClassReader ; <nl> + import org . objectweb . asm . ClassWriter ; <nl> + import org . objectweb . asm . Type ; <nl> + import org . objectweb . asm . tree . ClassNode ; <nl> + import org . objectweb . asm . tree . FieldNode ; <nl> + import org . objectweb . asm . tree . MethodNode ; <nl> + <nl> + import com . google . common . base . CharMatcher ; <nl> + import com . google . common . base . Charsets ; <nl> + import com . google . common . base . Splitter ; <nl> + import com . google . common . base . Strings ; <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> + import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Multimap ; <nl> + import com . google . common . io . LineProcessor ; <nl> + import com . google . common . io . Resources ; <nl> + <nl> + import cpw . mods . fml . relauncher . IClassTransformer ; <nl> + <nl> + public class AccessTransformer implements IClassTransformer <nl> + { <nl> + private class Modifier <nl> + { <nl> + public String name = " " ; <nl> + public String desc = " " ; <nl> + public int oldAccess = 0 ; <nl> + public int newAccess = 0 ; <nl> + public int targetAccess = 0 ; <nl> + <nl> + private void setTargetAccess ( String name ) <nl> + { <nl> + if ( name . equalsIgnoreCase ( " public " ) ) targetAccess = ACC _ PUBLIC ; <nl> + else if ( name . equalsIgnoreCase ( " private " ) ) targetAccess = ACC _ PRIVATE ; <nl> + else if ( name . equalsIgnoreCase ( " protected " ) ) targetAccess = ACC _ PROTECTED ; <nl> + } <nl> + } <nl> + <nl> + private Multimap < String , Modifier > modifiers = ArrayListMultimap . create ( ) ; <nl> + <nl> + public AccessTransformer ( ) throws IOException <nl> + { <nl> + this ( " / rules . csv " ) ; <nl> + } <nl> + protected AccessTransformer ( String rulesFile ) throws IOException <nl> + { <nl> + readMapFile ( rulesFile ) ; <nl> + } <nl> + <nl> + private void readMapFile ( String rulesFile ) throws IOException <nl> + { <nl> + URL rulesResource = Resources . getResource ( rulesFile ) ; <nl> + Resources . readLines ( rulesResource , Charsets . UTF _ 8 , new LineProcessor < Void > ( ) <nl> + { <nl> + @ Override <nl> + public Void getResult ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean processLine ( String input ) throws IOException <nl> + { <nl> + String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; <nl> + if ( line . length ( ) = = 0 ) <nl> + { <nl> + return true ; <nl> + } <nl> + List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; <nl> + if ( parts . size ( ) > 2 | | parts . get ( 1 ) . indexOf ( ' . ' ) = = - 1 ) <nl> + { <nl> + throw new RuntimeException ( " Invalid config file line " + input ) ; <nl> + } <nl> + Modifier m = new Modifier ( ) ; <nl> + m . setTargetAccess ( parts . get ( 0 ) ) ; <nl> + List < String > descriptor = Lists . newArrayList ( Splitter . on ( " . " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; <nl> + List < String > method = Lists . newArrayList ( Splitter . on ( CharMatcher . anyOf ( " ( ) " ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( descriptor . get ( 1 ) ) ) ; <nl> + if ( method . size ( ) = = 2 ) <nl> + { <nl> + m . desc = method . get ( 1 ) ; <nl> + } <nl> + m . name = method . get ( 0 ) ; <nl> + modifiers . put ( descriptor . get ( 0 ) , m ) ; <nl> + return true ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + @ Override <nl> + public byte [ ] transform ( String name , byte [ ] bytes ) <nl> + { <nl> + if ( ! modifiers . containsKey ( name ) ) { return bytes ; } <nl> + <nl> + ClassNode classNode = new ClassNode ( ) ; <nl> + ClassReader classReader = new ClassReader ( bytes ) ; <nl> + classReader . accept ( classNode , 0 ) ; <nl> + <nl> + Collection < Modifier > mods = modifiers . get ( name ) ; <nl> + for ( Modifier m : mods ) <nl> + { <nl> + if ( m . desc . isEmpty ( ) ) <nl> + { <nl> + for ( FieldNode n : ( List < FieldNode > ) classNode . fields ) <nl> + { <nl> + if ( n . name . equals ( m . name ) ) <nl> + { <nl> + n . access = getFixedAccess ( n . access , m ) ; <nl> + System . out . println ( String . format ( " Field : % s . % s % s - > % s " , name , m . name , Integer . toBinaryString ( m . oldAccess ) , <nl> + Integer . toBinaryString ( m . newAccess ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + else <nl> + { <nl> + for ( MethodNode n : ( List < MethodNode > ) classNode . methods ) <nl> + { <nl> + if ( n . name . equals ( m . name ) & & n . desc . equals ( m . desc ) ) <nl> + { <nl> + n . access = getFixedAccess ( n . access , m ) ; <nl> + System . out . println ( String . format ( " Method : % s . % s % s % s - > % s " , name , m . name , m . desc , toBinary ( m . oldAccess ) , toBinary ( m . newAccess ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; <nl> + classNode . accept ( writer ) ; <nl> + return writer . toByteArray ( ) ; <nl> + } <nl> + <nl> + private String toBinary ( int num ) <nl> + { <nl> + return String . format ( " % 16s " , Integer . toBinaryString ( num ) ) . replace ( ' ' , ' 0 ' ) ; <nl> + } <nl> + <nl> + private int getFixedAccess ( int access , Modifier target ) <nl> + { <nl> + target . oldAccess = access ; <nl> + int t = target . targetAccess ; <nl> + int ret = ( access & ~ 7 ) ; <nl> + <nl> + switch ( access & 7 ) <nl> + { <nl> + case ACC _ PRIVATE : <nl> + ret | = t ; <nl> + break ; <nl> + case 0 : / / default <nl> + ret | = ( t ! = ACC _ PRIVATE ? t : 0 / * default * / ) ; <nl> + break ; <nl> + case ACC _ PROTECTED : <nl> + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / ? t : ACC _ PROTECTED ) ; <nl> + break ; <nl> + case ACC _ PUBLIC : <nl> + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / & & t ! = ACC _ PROTECTED ? t : ACC _ PUBLIC ) ; <nl> + break ; <nl> + default : <nl> + throw new RuntimeException ( " The fuck ? " ) ; <nl> + } <nl> + target . newAccess = ret ; <nl> + return ret ; <nl> + } <nl> + <nl> + public static void main ( String [ ] args ) <nl> + { <nl> + if ( args . length < 2 ) <nl> + { <nl> + System . out . println ( " Usage : AccessTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; <nl> + return ; <nl> + } <nl> + <nl> + boolean hasTransformer = false ; <nl> + AccessTransformer [ ] trans = new AccessTransformer [ args . length - 1 ] ; <nl> + for ( int x = 1 ; x < args . length ; x + + ) <nl> + { <nl> + try <nl> + { <nl> + trans [ x - 1 ] = new AccessTransformer ( args [ x ] ) ; <nl> + hasTransformer = true ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + if ( ! hasTransformer ) <nl> + { <nl> + System . out . println ( " Culd not find a valid transformer to perform " ) ; <nl> + return ; <nl> + } <nl> + <nl> + File orig = new File ( args [ 0 ] ) ; <nl> + File temp = new File ( args [ 0 ] + " . ATBack " ) ; <nl> + if ( ! orig . exists ( ) & & ! temp . exists ( ) ) <nl> + { <nl> + System . out . println ( " Could not find target jar : " + orig ) ; <nl> + return ; <nl> + } <nl> + <nl> + if ( temp . exists ( ) ) <nl> + { <nl> + if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) <nl> + { <nl> + System . out . println ( " Could not backup existing file : " + orig ) ; <nl> + return ; <nl> + } <nl> + if ( ! temp . renameTo ( orig ) ) <nl> + { <nl> + System . out . println ( " Could not restore backup from previous run : " + temp ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + if ( ! orig . renameTo ( temp ) ) <nl> + { <nl> + System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; <nl> + return ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + processJar ( temp , orig , trans ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + private static void processJar ( File inFile , File outFile , AccessTransformer [ ] transformers ) throws IOException <nl> + { <nl> + ZipInputStream inJar = null ; <nl> + ZipOutputStream outJar = null ; <nl> + <nl> + try <nl> + { <nl> + try <nl> + { <nl> + inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; <nl> + } <nl> + catch ( FileNotFoundException e ) <nl> + { <nl> + throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; <nl> + } <nl> + <nl> + ZipEntry entry ; <nl> + while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) <nl> + { <nl> + if ( entry . isDirectory ( ) ) <nl> + { <nl> + outJar . putNextEntry ( entry ) ; <nl> + continue ; <nl> + } <nl> + <nl> + byte [ ] data = new byte [ 4096 ] ; <nl> + ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; <nl> + <nl> + int len ; <nl> + do <nl> + { <nl> + len = inJar . read ( data ) ; <nl> + if ( len > 0 ) <nl> + { <nl> + entryBuffer . write ( data , 0 , len ) ; <nl> + } <nl> + } <nl> + while ( len ! = - 1 ) ; <nl> + <nl> + byte [ ] entryData = entryBuffer . toByteArray ( ) ; <nl> + <nl> + String entryName = entry . getName ( ) ; <nl> + <nl> + if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) <nl> + { <nl> + ClassNode cls = new ClassNode ( ) ; <nl> + ClassReader rdr = new ClassReader ( entryData ) ; <nl> + rdr . accept ( cls , 0 ) ; <nl> + String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; <nl> + <nl> + for ( AccessTransformer trans : transformers ) <nl> + { <nl> + entryData = trans . transform ( name , entryData ) ; <nl> + } <nl> + } <nl> + <nl> + ZipEntry newEntry = new ZipEntry ( entryName ) ; <nl> + outJar . putNextEntry ( newEntry ) ; <nl> + outJar . write ( entryData ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + if ( outJar ! = null ) <nl> + { <nl> + try <nl> + { <nl> + outJar . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + } <nl> + } <nl> + <nl> + if ( inJar ! = null ) <nl> + { <nl> + try <nl> + { <nl> + inJar . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> \ No newline at end of file

TEST DIFF:
diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / asm / transformers / EventSubscriptionTransformer . java b / fml / src / main / java / net / minecraftforge / fml / common / asm / transformers / EventSubscriptionTransformer . java 
 index 86a9f11 . . 6f2c117 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / asm / transformers / EventSubscriptionTransformer . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / asm / transformers / EventSubscriptionTransformer . java 
 @ @ - 17 , 7 + 17 , 10 @ @ import static org . objectweb . asm . Opcodes . INVOKESPECIAL ; 
 import static org . objectweb . asm . Opcodes . NEW ; 
 import static org . objectweb . asm . Opcodes . PUTSTATIC ; 
 import static org . objectweb . asm . Opcodes . RETURN ; 
 + import static org . objectweb . asm . Opcodes . IRETURN ; 
 + import static org . objectweb . asm . Opcodes . ICONST _ 1 ; 
 import static org . objectweb . asm . Type . VOID _ TYPE ; 
 + import static org . objectweb . asm . Type . BOOLEAN _ TYPE ; 
 import static org . objectweb . asm . Type . getMethodDescriptor ; 
 
 import java . util . List ; 
 @ @ - 28 , 6 + 31 , 7 @ @ import net . minecraftforge . fml . common . eventhandler . Event ; 
 import org . objectweb . asm . ClassReader ; 
 import org . objectweb . asm . ClassWriter ; 
 import org . objectweb . asm . Type ; 
 + import org . objectweb . asm . tree . AnnotationNode ; 
 import org . objectweb . asm . tree . ClassNode ; 
 import org . objectweb . asm . tree . FieldInsnNode ; 
 import org . objectweb . asm . tree . FieldNode ; 
 @ @ - 81 , 56 + 85 , 87 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 
 private boolean buildEvents ( ClassNode classNode ) throws Exception 
 { 
 + / / Yes , this recursively loads classes until we get this base class . THIS IS NOT A ISSUE . Coremods should handle re - entry just fine . 
 + / / If they do not this a COREMOD issue NOT a Forge / LaunchWrapper issue . 
 Class < ? > parent = this . getClass ( ) . getClassLoader ( ) . loadClass ( classNode . superName . replace ( ' / ' , ' . ' ) ) ; 
 if ( ! Event . class . isAssignableFrom ( parent ) ) 
 { 
 return false ; 
 } 
 
 - boolean hasSetup = false ; 
 - boolean hasGetListenerList = false ; 
 - boolean hasDefaultCtr = false ; 
 + / / Class < ? > listenerListClazz = Class . forName ( " net . minecraftforge . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; 
 + Type tList = Type . getType ( " Lnet / minecraftforge / fml / common / eventhandler / ListenerList ; " ) ; 
 
 - Class < ? > listenerListClazz = Class . forName ( " net . minecraftforge . fml . common . eventhandler . ListenerList " , false , getClass ( ) . getClassLoader ( ) ) ; 
 - Type tList = Type . getType ( listenerListClazz ) ; 
 + boolean edited = false ; 
 + boolean hasSetup = false ; 
 + boolean hasGetListenerList = false ; 
 + boolean hasDefaultCtr = false ; 
 + boolean hasCancelable = false ; 
 + boolean hasResult = false ; 
 + String voidDesc = Type . getMethodDescriptor ( VOID _ TYPE ) ; 
 + String boolDesc = Type . getMethodDescriptor ( BOOLEAN _ TYPE ) ; 
 + String listDesc = tList . getDescriptor ( ) ; 
 + String listDescM = Type . getMethodDescriptor ( tList ) ; 
 
 for ( MethodNode method : ( List < MethodNode > ) classNode . methods ) 
 { 
 - if ( method . name . equals ( " setup " ) & & 
 - method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) & & 
 - ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) 
 - { 
 - hasSetup = true ; 
 - } 
 - if ( method . name . equals ( " getListenerList " ) & & 
 - method . desc . equals ( Type . getMethodDescriptor ( tList ) ) & & 
 - ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) 
 + if ( method . name . equals ( " setup " ) & & method . desc . equals ( voidDesc ) & & ( method . access & ACC _ PROTECTED ) = = ACC _ PROTECTED ) hasSetup = true ; 
 + if ( ( method . access & ACC _ PUBLIC ) = = ACC _ PUBLIC ) 
 + { 
 + if ( method . name . equals ( " getListenerList " ) & & method . desc . equals ( listDescM ) ) hasGetListenerList = true ; 
 + if ( method . name . equals ( " isCancelable " ) & & method . desc . equals ( boolDesc ) ) hasCancelable = true ; 
 + if ( method . name . equals ( " hasResult " ) & & method . desc . equals ( boolDesc ) ) hasResult = true ; 
 + } 
 + if ( method . name . equals ( " < init > " ) & & method . desc . equals ( voidDesc ) ) hasDefaultCtr = true ; 
 + } 
 + 
 + if ( classNode . visibleAnnotations ! = null ) 
 + { 
 + for ( AnnotationNode node : classNode . visibleAnnotations ) 
 + { 
 + if ( ! hasResult & & node . desc . equals ( " Lnet / minecraftforge / fml / common / eventhandler / Event $ HasResult ; " ) ) 
 { 
 - hasGetListenerList = true ; 
 + / * Add : 
 + * public boolean hasResult ( ) 
 + * { 
 + * return true ; 
 + * } 
 + * / 
 + MethodNode method = new MethodNode ( ACC _ PUBLIC , " hasResult " , boolDesc , null , null ) ; 
 + method . instructions . add ( new InsnNode ( ICONST _ 1 ) ) ; 
 + method . instructions . add ( new InsnNode ( IRETURN ) ) ; 
 + classNode . methods . add ( method ) ; 
 + edited = true ; 
 } 
 - if ( method . name . equals ( " < init > " ) & & 
 - method . desc . equals ( Type . getMethodDescriptor ( VOID _ TYPE ) ) ) 
 + else if ( ! hasCancelable & & node . desc . equals ( " Lnet / minecraftforge / fml / common / eventhandler / Cancelable ; " ) ) 
 { 
 - hasDefaultCtr = true ; 
 + / * Add : 
 + * public boolean isCancelable ( ) 
 + * { 
 + * return true ; 
 + * } 
 + * / 
 + MethodNode method = new MethodNode ( ACC _ PUBLIC , " isCancelable " , boolDesc , null , null ) ; 
 + method . instructions . add ( new InsnNode ( ICONST _ 1 ) ) ; 
 + method . instructions . add ( new InsnNode ( IRETURN ) ) ; 
 + classNode . methods . add ( method ) ; 
 + edited = true ; 
 } 
 + } 
 } 
 
 if ( hasSetup ) 
 { 
 - if ( ! hasGetListenerList ) 
 - { 
 - throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; 
 - } 
 - else 
 - { 
 - return false ; 
 - } 
 + if ( ! hasGetListenerList ) 
 + throw new RuntimeException ( " Event class defines setup ( ) but does not define getListenerList ! " + classNode . name ) ; 
 + else 
 + return edited ; 
 } 
 
 Type tSuper = Type . getType ( classNode . superName ) ; 
 
 / / Add private static ListenerList LISTENER _ LIST 
 - classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , tList . getDescriptor ( ) , null , null ) ) ; 
 + classNode . fields . add ( new FieldNode ( ACC _ PRIVATE | ACC _ STATIC , " LISTENER _ LIST " , listDesc , null , null ) ) ; 
 
 / * Add : 
 * public < init > ( ) 
 @ @ - 138 , 12 + 173 , 12 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 * super ( ) ; 
 * } 
 * / 
 - MethodNode method = new MethodNode ( ASM5 , ACC _ PUBLIC , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; 
 - method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE ) , false ) ) ; 
 - method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 if ( ! hasDefaultCtr ) 
 { 
 + MethodNode method = new MethodNode ( ACC _ PUBLIC , " < init > " , voidDesc , null , null ) ; 
 + method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " < init > " , voidDesc , false ) ) ; 
 + method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 classNode . methods . add ( method ) ; 
 } 
 
 @ @ - 158 , 10 + 193 , 10 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 * LISTENER _ LIST = new ListenerList ( super . getListenerList ( ) ) ; 
 * } 
 * / 
 - method = new MethodNode ( ASM5 , ACC _ PROTECTED , " setup " , getMethodDescriptor ( VOID _ TYPE ) , null , null ) ; 
 + MethodNode method = new MethodNode ( ACC _ PROTECTED , " setup " , voidDesc , null , null ) ; 
 method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , getMethodDescriptor ( VOID _ TYPE ) , false ) ) ; 
 - method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " setup " , voidDesc , false ) ) ; 
 + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; 
 LabelNode initLisitener = new LabelNode ( ) ; 
 method . instructions . add ( new JumpInsnNode ( IFNULL , initLisitener ) ) ; 
 method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 @ @ - 170 , 9 + 205 , 9 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 method . instructions . add ( new TypeInsnNode ( NEW , tList . getInternalName ( ) ) ) ; 
 method . instructions . add ( new InsnNode ( DUP ) ) ; 
 method . instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; 
 - method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , getMethodDescriptor ( tList ) , false ) ) ; 
 + method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tSuper . getInternalName ( ) , " getListenerList " , listDescM , false ) ) ; 
 method . instructions . add ( new MethodInsnNode ( INVOKESPECIAL , tList . getInternalName ( ) , " < init > " , getMethodDescriptor ( VOID _ TYPE , tList ) , false ) ) ; 
 - method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + method . instructions . add ( new FieldInsnNode ( PUTSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; 
 method . instructions . add ( new InsnNode ( RETURN ) ) ; 
 classNode . methods . add ( method ) ; 
 
 @ @ - 182 , 8 + 217 , 8 @ @ public class EventSubscriptionTransformer implements IClassTransformer 
 * return this . LISTENER _ LIST ; 
 * } 
 * / 
 - method = new MethodNode ( ASM5 , ACC _ PUBLIC , " getListenerList " , getMethodDescriptor ( tList ) , null , null ) ; 
 - method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , tList . getDescriptor ( ) ) ) ; 
 + method = new MethodNode ( ACC _ PUBLIC , " getListenerList " , listDescM , null , null ) ; 
 + method . instructions . add ( new FieldInsnNode ( GETSTATIC , classNode . name , " LISTENER _ LIST " , listDesc ) ) ; 
 method . instructions . add ( new InsnNode ( ARETURN ) ) ; 
 classNode . methods . add ( method ) ; 
 return true ; 
 diff - - git a / fml / src / main / java / net / minecraftforge / fml / common / eventhandler / Event . java b / fml / src / main / java / net / minecraftforge / fml / common / eventhandler / Event . java 
 index a1a60df . . e02f9f6 100644 
 - - - a / fml / src / main / java / net / minecraftforge / fml / common / eventhandler / Event . java 
 + + + b / fml / src / main / java / net / minecraftforge / fml / common / eventhandler / Event . java 
 @ @ - 32 , 9 + 32 , 7 @ @ public class Event 
 } 
 
 private boolean isCanceled = false ; 
 - private final boolean isCancelable ; 
 private Result result = Result . DEFAULT ; 
 - private final boolean hasResult ; 
 private static ListenerList listeners = new ListenerList ( ) ; 
 private EventPriority phase = null ; 
 
 @ @ - 43 , 48 + 41 , 18 @ @ public class Event 
 public Event ( ) 
 { 
 setup ( ) ; 
 - isCancelable = hasAnnotation ( Cancelable . class ) ; 
 - hasResult = hasAnnotation ( HasResult . class ) ; 
 - } 
 - 
 - private boolean hasAnnotation ( Class < ? extends Annotation > annotation ) 
 - { 
 - Class < ? > me = this . getClass ( ) ; 
 - Map < Class < ? > , Boolean > list = annotationMap . get ( me ) ; 
 - if ( list = = null ) 
 - { 
 - list = new ConcurrentHashMap < Class < ? > , Boolean > ( ) ; 
 - annotationMap . put ( me , list ) ; 
 - } 
 - 
 - Boolean cached = list . get ( annotation ) ; 
 - if ( cached ! = null ) 
 - { 
 - return cached ; 
 - } 
 - 
 - Class < ? > cls = me ; 
 - while ( cls ! = Event . class ) 
 - { 
 - if ( cls . isAnnotationPresent ( annotation ) ) 
 - { 
 - list . put ( annotation , true ) ; 
 - return true ; 
 - } 
 - cls = cls . getSuperclass ( ) ; 
 - } 
 - 
 - list . put ( annotation , false ) ; 
 - return false ; 
 } 
 
 / * * 
 * Determine if this function is cancelable at all . 
 * @ return If access to setCanceled should be allowed 
 + * 
 + * Note : 
 + * Events with the Cancelable annotation will have this method automatically added to return true . 
 * / 
 public boolean isCancelable ( ) 
 { 
 - return isCancelable ; 
 + return false ; 
 } 
 
 / * * 
 @ @ - 115 , 10 + 83 , 13 @ @ public class Event 
 
 / * * 
 * Determines if this event expects a significant result value . 
 + * 
 + * Note : 
 + * Events with the HasResult annotation will have this method automatically added to return true . 
 * / 
 public boolean hasResult ( ) 
 { 
 - return hasResult ; 
 + return false ; 
 } 
 
 / * *

NEAREST DIFF:
diff - - git a / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java 
 new file mode 100644 
 index 0000000 . . 760284e 
 - - - / dev / null 
 + + + b / fml / transformers / cpw / mods / fml / common / asm / transformers / AccessTransformer . java 
 @ @ - 0 , 0 + 1 , 357 @ @ 
 + package cpw . mods . fml . common . asm . transformers ; 
 + 
 + import static org . objectweb . asm . Opcodes . ACC _ PRIVATE ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PROTECTED ; 
 + import static org . objectweb . asm . Opcodes . ACC _ PUBLIC ; 
 + 
 + import java . io . BufferedInputStream ; 
 + import java . io . BufferedOutputStream ; 
 + import java . io . BufferedReader ; 
 + import java . io . ByteArrayOutputStream ; 
 + import java . io . File ; 
 + import java . io . FileInputStream ; 
 + import java . io . FileNotFoundException ; 
 + import java . io . FileOutputStream ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . io . InputStreamReader ; 
 + import java . net . URL ; 
 + import java . text . SimpleDateFormat ; 
 + import java . util . ArrayList ; 
 + import java . util . Collection ; 
 + import java . util . Date ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + import java . util . zip . ZipEntry ; 
 + import java . util . zip . ZipInputStream ; 
 + import java . util . zip . ZipOutputStream ; 
 + 
 + import org . objectweb . asm . ClassReader ; 
 + import org . objectweb . asm . ClassWriter ; 
 + import org . objectweb . asm . Type ; 
 + import org . objectweb . asm . tree . ClassNode ; 
 + import org . objectweb . asm . tree . FieldNode ; 
 + import org . objectweb . asm . tree . MethodNode ; 
 + 
 + import com . google . common . base . CharMatcher ; 
 + import com . google . common . base . Charsets ; 
 + import com . google . common . base . Splitter ; 
 + import com . google . common . base . Strings ; 
 + import com . google . common . collect . ArrayListMultimap ; 
 + import com . google . common . collect . Iterables ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Multimap ; 
 + import com . google . common . io . LineProcessor ; 
 + import com . google . common . io . Resources ; 
 + 
 + import cpw . mods . fml . relauncher . IClassTransformer ; 
 + 
 + public class AccessTransformer implements IClassTransformer 
 + { 
 + private class Modifier 
 + { 
 + public String name = " " ; 
 + public String desc = " " ; 
 + public int oldAccess = 0 ; 
 + public int newAccess = 0 ; 
 + public int targetAccess = 0 ; 
 + 
 + private void setTargetAccess ( String name ) 
 + { 
 + if ( name . equalsIgnoreCase ( " public " ) ) targetAccess = ACC _ PUBLIC ; 
 + else if ( name . equalsIgnoreCase ( " private " ) ) targetAccess = ACC _ PRIVATE ; 
 + else if ( name . equalsIgnoreCase ( " protected " ) ) targetAccess = ACC _ PROTECTED ; 
 + } 
 + } 
 + 
 + private Multimap < String , Modifier > modifiers = ArrayListMultimap . create ( ) ; 
 + 
 + public AccessTransformer ( ) throws IOException 
 + { 
 + this ( " / rules . csv " ) ; 
 + } 
 + protected AccessTransformer ( String rulesFile ) throws IOException 
 + { 
 + readMapFile ( rulesFile ) ; 
 + } 
 + 
 + private void readMapFile ( String rulesFile ) throws IOException 
 + { 
 + URL rulesResource = Resources . getResource ( rulesFile ) ; 
 + Resources . readLines ( rulesResource , Charsets . UTF _ 8 , new LineProcessor < Void > ( ) 
 + { 
 + @ Override 
 + public Void getResult ( ) 
 + { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public boolean processLine ( String input ) throws IOException 
 + { 
 + String line = Iterables . getFirst ( Splitter . on ( ' # ' ) . limit ( 2 ) . split ( input ) , " " ) . trim ( ) ; 
 + if ( line . length ( ) = = 0 ) 
 + { 
 + return true ; 
 + } 
 + List < String > parts = Lists . newArrayList ( Splitter . on ( " " ) . trimResults ( ) . split ( line ) ) ; 
 + if ( parts . size ( ) > 2 | | parts . get ( 1 ) . indexOf ( ' . ' ) = = - 1 ) 
 + { 
 + throw new RuntimeException ( " Invalid config file line " + input ) ; 
 + } 
 + Modifier m = new Modifier ( ) ; 
 + m . setTargetAccess ( parts . get ( 0 ) ) ; 
 + List < String > descriptor = Lists . newArrayList ( Splitter . on ( " . " ) . trimResults ( ) . split ( parts . get ( 1 ) ) ) ; 
 + List < String > method = Lists . newArrayList ( Splitter . on ( CharMatcher . anyOf ( " ( ) " ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( descriptor . get ( 1 ) ) ) ; 
 + if ( method . size ( ) = = 2 ) 
 + { 
 + m . desc = method . get ( 1 ) ; 
 + } 
 + m . name = method . get ( 0 ) ; 
 + modifiers . put ( descriptor . get ( 0 ) , m ) ; 
 + return true ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + @ Override 
 + public byte [ ] transform ( String name , byte [ ] bytes ) 
 + { 
 + if ( ! modifiers . containsKey ( name ) ) { return bytes ; } 
 + 
 + ClassNode classNode = new ClassNode ( ) ; 
 + ClassReader classReader = new ClassReader ( bytes ) ; 
 + classReader . accept ( classNode , 0 ) ; 
 + 
 + Collection < Modifier > mods = modifiers . get ( name ) ; 
 + for ( Modifier m : mods ) 
 + { 
 + if ( m . desc . isEmpty ( ) ) 
 + { 
 + for ( FieldNode n : ( List < FieldNode > ) classNode . fields ) 
 + { 
 + if ( n . name . equals ( m . name ) ) 
 + { 
 + n . access = getFixedAccess ( n . access , m ) ; 
 + System . out . println ( String . format ( " Field : % s . % s % s - > % s " , name , m . name , Integer . toBinaryString ( m . oldAccess ) , 
 + Integer . toBinaryString ( m . newAccess ) ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + else 
 + { 
 + for ( MethodNode n : ( List < MethodNode > ) classNode . methods ) 
 + { 
 + if ( n . name . equals ( m . name ) & & n . desc . equals ( m . desc ) ) 
 + { 
 + n . access = getFixedAccess ( n . access , m ) ; 
 + System . out . println ( String . format ( " Method : % s . % s % s % s - > % s " , name , m . name , m . desc , toBinary ( m . oldAccess ) , toBinary ( m . newAccess ) ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE _ MAXS ) ; 
 + classNode . accept ( writer ) ; 
 + return writer . toByteArray ( ) ; 
 + } 
 + 
 + private String toBinary ( int num ) 
 + { 
 + return String . format ( " % 16s " , Integer . toBinaryString ( num ) ) . replace ( ' ' , ' 0 ' ) ; 
 + } 
 + 
 + private int getFixedAccess ( int access , Modifier target ) 
 + { 
 + target . oldAccess = access ; 
 + int t = target . targetAccess ; 
 + int ret = ( access & ~ 7 ) ; 
 + 
 + switch ( access & 7 ) 
 + { 
 + case ACC _ PRIVATE : 
 + ret | = t ; 
 + break ; 
 + case 0 : / / default 
 + ret | = ( t ! = ACC _ PRIVATE ? t : 0 / * default * / ) ; 
 + break ; 
 + case ACC _ PROTECTED : 
 + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / ? t : ACC _ PROTECTED ) ; 
 + break ; 
 + case ACC _ PUBLIC : 
 + ret | = ( t ! = ACC _ PRIVATE & & t ! = 0 / * default * / & & t ! = ACC _ PROTECTED ? t : ACC _ PUBLIC ) ; 
 + break ; 
 + default : 
 + throw new RuntimeException ( " The fuck ? " ) ; 
 + } 
 + target . newAccess = ret ; 
 + return ret ; 
 + } 
 + 
 + public static void main ( String [ ] args ) 
 + { 
 + if ( args . length < 2 ) 
 + { 
 + System . out . println ( " Usage : AccessTransformer < JarPath > < MapFile > [ MapFile2 ] . . . " ) ; 
 + return ; 
 + } 
 + 
 + boolean hasTransformer = false ; 
 + AccessTransformer [ ] trans = new AccessTransformer [ args . length - 1 ] ; 
 + for ( int x = 1 ; x < args . length ; x + + ) 
 + { 
 + try 
 + { 
 + trans [ x - 1 ] = new AccessTransformer ( args [ x ] ) ; 
 + hasTransformer = true ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + System . out . println ( " Could not read Transformer Map : " + args [ x ] ) ; 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + if ( ! hasTransformer ) 
 + { 
 + System . out . println ( " Culd not find a valid transformer to perform " ) ; 
 + return ; 
 + } 
 + 
 + File orig = new File ( args [ 0 ] ) ; 
 + File temp = new File ( args [ 0 ] + " . ATBack " ) ; 
 + if ( ! orig . exists ( ) & & ! temp . exists ( ) ) 
 + { 
 + System . out . println ( " Could not find target jar : " + orig ) ; 
 + return ; 
 + } 
 + 
 + if ( temp . exists ( ) ) 
 + { 
 + if ( orig . exists ( ) & & ! orig . renameTo ( new File ( args [ 0 ] + ( new SimpleDateFormat ( " . yyyy . MM . dd . HHmmss " ) ) . format ( new Date ( ) ) ) ) ) 
 + { 
 + System . out . println ( " Could not backup existing file : " + orig ) ; 
 + return ; 
 + } 
 + if ( ! temp . renameTo ( orig ) ) 
 + { 
 + System . out . println ( " Could not restore backup from previous run : " + temp ) ; 
 + return ; 
 + } 
 + } 
 + 
 + if ( ! orig . renameTo ( temp ) ) 
 + { 
 + System . out . println ( " Could not rename file : " + orig + " - > " + temp ) ; 
 + return ; 
 + } 
 + 
 + try 
 + { 
 + processJar ( temp , orig , trans ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + private static void processJar ( File inFile , File outFile , AccessTransformer [ ] transformers ) throws IOException 
 + { 
 + ZipInputStream inJar = null ; 
 + ZipOutputStream outJar = null ; 
 + 
 + try 
 + { 
 + try 
 + { 
 + inJar = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new FileNotFoundException ( " Could not open input file : " + e . getMessage ( ) ) ; 
 + } 
 + 
 + try 
 + { 
 + outJar = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; 
 + } 
 + catch ( FileNotFoundException e ) 
 + { 
 + throw new FileNotFoundException ( " Could not open output file : " + e . getMessage ( ) ) ; 
 + } 
 + 
 + ZipEntry entry ; 
 + while ( ( entry = inJar . getNextEntry ( ) ) ! = null ) 
 + { 
 + if ( entry . isDirectory ( ) ) 
 + { 
 + outJar . putNextEntry ( entry ) ; 
 + continue ; 
 + } 
 + 
 + byte [ ] data = new byte [ 4096 ] ; 
 + ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream ( ) ; 
 + 
 + int len ; 
 + do 
 + { 
 + len = inJar . read ( data ) ; 
 + if ( len > 0 ) 
 + { 
 + entryBuffer . write ( data , 0 , len ) ; 
 + } 
 + } 
 + while ( len ! = - 1 ) ; 
 + 
 + byte [ ] entryData = entryBuffer . toByteArray ( ) ; 
 + 
 + String entryName = entry . getName ( ) ; 
 + 
 + if ( entryName . endsWith ( " . class " ) & & ! entryName . startsWith ( " . " ) ) 
 + { 
 + ClassNode cls = new ClassNode ( ) ; 
 + ClassReader rdr = new ClassReader ( entryData ) ; 
 + rdr . accept ( cls , 0 ) ; 
 + String name = cls . name . replace ( ' / ' , ' . ' ) . replace ( ' \ \ ' , ' . ' ) ; 
 + 
 + for ( AccessTransformer trans : transformers ) 
 + { 
 + entryData = trans . transform ( name , entryData ) ; 
 + } 
 + } 
 + 
 + ZipEntry newEntry = new ZipEntry ( entryName ) ; 
 + outJar . putNextEntry ( newEntry ) ; 
 + outJar . write ( entryData ) ; 
 + } 
 + } 
 + finally 
 + { 
 + if ( outJar ! = null ) 
 + { 
 + try 
 + { 
 + outJar . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + } 
 + } 
 + 
 + if ( inJar ! = null ) 
 + { 
 + try 
 + { 
 + inJar . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + } 
 + } 
 + } 
 + } 
 + } 
 \ No newline at end of file
