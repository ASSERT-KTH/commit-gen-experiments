BLEU SCORE: 0.041961149062965476

TEST MSG: Fixes parameter inconsistency in IFieldWrapper ( Fixes # 4325 )
GENERATED MSG: Fix arrays in map values for config system

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / config / ConfigManager . java b / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> index c1d6a8f . . 30a8c56 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> @ @ - 220 , 8 + 220 , 12 @ @ public class ConfigManager <nl> { <nl> if ( ! Modifier . isPublic ( f . getModifiers ( ) ) ) <nl> continue ; <nl> + <nl> + / / Only the root class may have static fields . Otherwise category tree nodes of the same type would share the <nl> + / / contained value messing up the sync <nl> if ( Modifier . isStatic ( f . getModifiers ( ) ) ! = ( instance = = null ) ) <nl> continue ; <nl> + <nl> if ( f . isAnnotationPresent ( Config . Ignore . class ) ) <nl> continue ; <nl> <nl> @ @ - 230 , 7 + 234 , 7 @ @ public class ConfigManager <nl> if ( ca ! = null ) <nl> comment = NEW _ LINE . join ( ca . value ( ) ) ; <nl> <nl> - String langKey = modid + " . " + ( category . isEmpty ( ) ? " " : category + " . " ) + f . getName ( ) . toLowerCase ( Locale . ENGLISH ) ; <nl> + String langKey = modid + " . " + ( category . isEmpty ( ) ? " " : category + Configuration . CATEGORY _ SPLITTER ) + f . getName ( ) . toLowerCase ( Locale . ENGLISH ) ; <nl> LangKey la = f . getAnnotation ( LangKey . class ) ; <nl> if ( la ! = null ) <nl> langKey = la . value ( ) ; <nl> @ @ - 238 , 7 + 242 , 7 @ @ public class ConfigManager <nl> boolean requiresMcRestart = f . isAnnotationPresent ( Config . RequiresMcRestart . class ) ; <nl> boolean requiresWorldRestart = f . isAnnotationPresent ( Config . RequiresWorldRestart . class ) ; <nl> <nl> - if ( FieldWrapper . hasWrapperFor ( f ) ) / / Access the field <nl> + if ( FieldWrapper . hasWrapperFor ( f ) ) / / Wrappers exist for primitives , enums , maps and arrays <nl> { <nl> if ( Strings . isNullOrEmpty ( category ) ) <nl> throw new RuntimeException ( " An empty category may not contain anything but objects representing categories ! " ) ; <nl> @ @ - 248 , 9 + 252 , 9 @ @ public class ConfigManager <nl> ITypeAdapter adapt = wrapper . getTypeAdapter ( ) ; <nl> Property . Type propType = adapt . getType ( ) ; <nl> <nl> - for ( String key : wrapper . getKeys ( ) ) <nl> + for ( String key : wrapper . getKeys ( ) ) / / Iterate the fully qualified property names the field provides <nl> { <nl> - String suffix = StringUtils . replaceOnce ( key , wrapper . getCategory ( ) + " . " , " " ) ; <nl> + String suffix = StringUtils . replaceOnce ( key , wrapper . getCategory ( ) + Configuration . CATEGORY _ SPLITTER , " " ) ; <nl> <nl> boolean existed = exists ( cfg , wrapper . getCategory ( ) , suffix ) ; <nl> if ( ! existed | | loading ) / / Creates keys in category specified by the wrapper if new ones are programaticaly added <nl> @ @ - 263 , 7 + 267 , 7 @ @ public class ConfigManager <nl> else <nl> wrapper . setValue ( key , adapt . getValue ( property ) ) ; <nl> } <nl> - else / / If the key is not new , sync according to shoudlReadFromVar ( ) <nl> + else / / If the key is not new , sync according to shouldReadFromVar ( ) <nl> { <nl> Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; <nl> Object propVal = adapt . getValue ( property ) ; <nl> @ @ - 278 , 31 + 282 , 32 @ @ public class ConfigManager <nl> <nl> ConfigCategory confCat = cfg . getCategory ( wrapper . getCategory ( ) ) ; <nl> <nl> - for ( Property property : confCat . getOrderedValues ( ) ) / / Are new keys in the Configuration object ? <nl> + for ( Property property : confCat . getOrderedValues ( ) ) / / Iterate the properties to check for new data from the config side <nl> { <nl> - if ( ! wrapper . handlesKey ( property . getName ( ) ) ) <nl> + String key = confCat . getQualifiedName ( ) + Configuration . CATEGORY _ SPLITTER + property . getName ( ) ; <nl> + if ( ! wrapper . handlesKey ( key ) ) <nl> continue ; <nl> <nl> - if ( loading | | ! wrapper . hasKey ( property . getName ( ) ) ) <nl> + if ( loading | | ! wrapper . hasKey ( key ) ) <nl> { <nl> Object value = wrapper . getTypeAdapter ( ) . getValue ( property ) ; <nl> - wrapper . setValue ( confCat . getName ( ) + " . " + property . getName ( ) , value ) ; <nl> + wrapper . setValue ( key , value ) ; <nl> } <nl> } <nl> <nl> - if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . <nl> + if ( loading ) <nl> wrapper . setupConfiguration ( cfg , comment , langKey , requiresMcRestart , requiresWorldRestart ) ; <nl> <nl> } <nl> - catch ( Exception e ) / / If anything goes wrong , add the errored field and class . <nl> + catch ( Exception e ) <nl> { <nl> String format = " Error syncing field ' % s ' of class ' % s ' ! " ; <nl> String error = String . format ( format , f . getName ( ) , cls . getName ( ) ) ; <nl> throw new RuntimeException ( error , e ) ; <nl> } <nl> } <nl> - else if ( f . getType ( ) . getSuperclass ( ) ! = null & & f . getType ( ) . getSuperclass ( ) . equals ( Object . class ) ) / / Descend the object tree <nl> - { <nl> + else if ( f . getType ( ) . getSuperclass ( ) ! = null & & f . getType ( ) . getSuperclass ( ) . equals ( Object . class ) ) <nl> + { / / If the field extends Object directly , descend the object tree and access the objects members <nl> Object newInstance = null ; <nl> try <nl> { <nl> @ @ - 310 , 11 + 315 , 11 @ @ public class ConfigManager <nl> } <nl> catch ( IllegalAccessException e ) <nl> { <nl> - / / This should never happen . Previous checks should eliminate this . <nl> throw new RuntimeException ( e ) ; <nl> } <nl> <nl> - String sub = ( category . isEmpty ( ) ? " " : category + " . " ) + getName ( f ) . toLowerCase ( Locale . ENGLISH ) ; <nl> + / / Setup the sub category with its respective name , comment , language key , etc . <nl> + String sub = ( category . isEmpty ( ) ? " " : category + Configuration . CATEGORY _ SPLITTER ) + getName ( f ) . toLowerCase ( Locale . ENGLISH ) ; <nl> ConfigCategory confCat = cfg . getCategory ( sub ) ; <nl> confCat . setComment ( comment ) ; <nl> confCat . setLanguageKey ( langKey ) ; <nl> diff - - git a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> index 3ce39d2 . . 25c4515 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> @ @ - 4 , 12 + 4 , 9 @ @ import java . lang . reflect . Field ; <nl> import java . lang . reflect . GenericArrayType ; <nl> import java . lang . reflect . ParameterizedType ; <nl> import java . lang . reflect . Type ; <nl> - import java . util . Iterator ; <nl> - import java . util . List ; <nl> - import java . util . Map ; <nl> + import java . util . * ; <nl> import java . util . Map . Entry ; <nl> import java . util . regex . Pattern ; <nl> - import java . util . Set ; <nl> <nl> import com . google . common . collect . Lists ; <nl> <nl> @ @ - 68 , 6 + 65 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> { <nl> private Map < String , Object > theMap = null ; <nl> private Type mType ; <nl> + private final String baseName ; <nl> ITypeAdapter adapter ; <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> @ @ - 75 , 6 + 73 , 8 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> { <nl> super ( category , field , instance ) ; <nl> <nl> + this . baseName = ( this . category = = null ) ? " " : ( this . category + " . " ) + this . name . toLowerCase ( Locale . ENGLISH ) + " . " ; <nl> + <nl> try <nl> { <nl> theMap = ( Map < String , Object > ) field . get ( instance ) ; <nl> @ @ - 123 , 7 + 123 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> Iterator < String > it = keys . iterator ( ) ; <nl> for ( int i = 0 ; i < keyArray . length ; i + + ) <nl> { <nl> - keyArray [ i ] = category + " . " + name + " . " + it . next ( ) ; <nl> + keyArray [ i ] = this . baseName + it . next ( ) ; <nl> } <nl> <nl> return keyArray ; <nl> @ @ - 132 , 28 + 132 , 27 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> @ Override <nl> public Object getValue ( String key ) <nl> { <nl> - return theMap . get ( StringUtils . replaceOnce ( key , category + " . " + name + " . " , " " ) ) ; <nl> + return theMap . get ( getSuffix ( key ) ) ; <nl> } <nl> <nl> @ Override <nl> public void setValue ( String key , Object value ) <nl> { <nl> - String suffix = StringUtils . replaceOnce ( key , category + " . " + name + " . " , " " ) ; <nl> - theMap . put ( suffix , value ) ; <nl> + theMap . put ( getSuffix ( key ) , value ) ; <nl> } <nl> <nl> @ Override <nl> - public boolean hasKey ( String name ) <nl> + public boolean hasKey ( String key ) <nl> { <nl> - return theMap . containsKey ( name ) ; <nl> + return theMap . containsKey ( getSuffix ( key ) ) ; <nl> } <nl> <nl> @ Override <nl> - public boolean handlesKey ( String name ) <nl> + public boolean handlesKey ( String key ) <nl> { <nl> - if ( name = = null ) <nl> + if ( key = = null ) <nl> return false ; <nl> - return name . startsWith ( category + " . " + name + " . " ) ; <nl> + return key . startsWith ( this . baseName ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 169 , 7 + 168 , 17 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> @ Override <nl> public String getCategory ( ) <nl> { <nl> - return category + " . " + name ; <nl> + return ( this . category = = null ) ? " " : ( this . category + " . " ) + this . name . toLowerCase ( Locale . ENGLISH ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Removes the { @ code this . baseName } prefix from the key <nl> + * @ param key the key to be edited <nl> + * @ return the keys suffix <nl> + * / <nl> + private String getSuffix ( String key ) <nl> + { <nl> + return StringUtils . replaceOnce ( key , this . baseName , " " ) ; <nl> } <nl> <nl> } <nl> @ @ - 336 , 15 + 345 , 15 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> } <nl> <nl> @ Override <nl> - public boolean hasKey ( String name ) <nl> + public boolean hasKey ( String key ) <nl> { <nl> - return ( this . category + " . " + this . name ) . equals ( name ) ; <nl> + return ( this . category + " . " + this . name ) . equals ( key ) ; <nl> } <nl> <nl> @ Override <nl> - public boolean handlesKey ( String name ) <nl> + public boolean handlesKey ( String key ) <nl> { <nl> - return hasKey ( name ) ; <nl> + return hasKey ( key ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 361 , 7 + 370 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> @ Override <nl> public String getCategory ( ) <nl> { <nl> - return category ; <nl> + return this . category ; <nl> } <nl> <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / common / config / IFieldWrapper . java b / src / main / java / net / minecraftforge / common / config / IFieldWrapper . java <nl> index 4706575 . . b74e393 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / IFieldWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / IFieldWrapper . java <nl> @ @ - 2 , 6 + 2 , 8 @ @ package net . minecraftforge . common . config ; <nl> <nl> / * * <nl> * The objects are expected to get their wrapped field , the owning class , instance and category string on initialization . <nl> + * In general : The key is the fully qualified property name , where each subcategory is appended with a dot . <nl> + * i . e : general . map . isPresent <nl> * / <nl> public interface IFieldWrapper <nl> { <nl> @ @ - 12 , 24 + 14 , 46 @ @ public interface IFieldWrapper <nl> ITypeAdapter getTypeAdapter ( ) ; <nl> <nl> / * * <nl> - * @ param field the field about which to retrieve information <nl> - * @ param instance The instance whose field shall be queried . <nl> - * @ return a list of keys handled by this field <nl> + * @ return a list of fully qualified property keys handled by this field <nl> * / <nl> String [ ] getKeys ( ) ; <nl> - <nl> + <nl> + / * * <nl> + * @ param key the fully qualified property key <nl> + * @ return the value the wrapped field associates with the given key <nl> + * / <nl> Object getValue ( String key ) ; <nl> - <nl> + <nl> + / * * <nl> + * @ param key the fully qualified property key <nl> + * @ param value the target value of the property associated with the key <nl> + * / <nl> void setValue ( String key , Object value ) ; <nl> - <nl> - boolean hasKey ( String name ) ; <nl> - <nl> - boolean handlesKey ( String name ) ; <nl> - <nl> + <nl> + / * * <nl> + * @ param key a fully qualified property key <nl> + * @ return true if the wrapped field contains a property associated with the given key <nl> + * / <nl> + boolean hasKey ( String key ) ; <nl> + <nl> + / * * <nl> + * @ param key a fully qualified property key <nl> + * @ return true if the wrapped field can save information associated with the given key , false otherwise <nl> + * / <nl> + boolean handlesKey ( String key ) ; <nl> + <nl> + / * * <nl> + * @ param cfg The configuration object holding the properties <nl> + * @ param desc The properties description <nl> + * @ param langKey The languageKey of the property , used in GUI <nl> + * @ param reqMCRestart True , if a change in this property requires a restart of Minecraft <nl> + * @ param reqWorldRestart True , if the world needs to be reloaded after changes to this property <nl> + * / <nl> void setupConfiguration ( Configuration cfg , String desc , String langKey , boolean reqMCRestart , boolean reqWorldRestart ) ; <nl> <nl> / * * <nl> - * @ return the category name in which the entries should be saved . <nl> + * i . e . general . map in the example above <nl> + * @ return the category name in which the entries should be saved . This includes the parent categories <nl> * / <nl> String getCategory ( ) ; <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / common / config / ITypeAdapter . java b / src / main / java / net / minecraftforge / common / config / ITypeAdapter . java <nl> index ed157a1 . . c5644fc 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / ITypeAdapter . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / ITypeAdapter . java <nl> @ @ - 20 , 15 + 20 , 33 @ @ package net . minecraftforge . common . config ; <nl> <nl> import net . minecraftforge . common . config . Property . Type ; <nl> <nl> + / * * <nl> + * Abstracts the types of properties away . Higher level logic must prevent invalid data types . <nl> + * / <nl> interface ITypeAdapter <nl> { <nl> + / * * <nl> + * Assigns the default value to the property <nl> + * @ param property the property whose default value will be assigned <nl> + * @ param value the default value <nl> + * / <nl> void setDefaultValue ( Property property , Object value ) ; <nl> - 	 <nl> + <nl> + / * * <nl> + * Sets the properties value . <nl> + * @ param property the property whose value will be set <nl> + * @ param value the set value <nl> + * / <nl> 	 void setValue ( Property property , Object value ) ; <nl> <nl> + / * * <nl> + * Retrieves the properties value <nl> + * @ param prop the property whose value will be retrieved <nl> + * @ return the properties value <nl> + * / <nl> 	 Object getValue ( Property prop ) ; <nl> <nl> Type getType ( ) ; <nl> - <nl> + <nl> boolean isArrayAdapter ( ) ; <nl> } <nl> diff - - git a / src / test / java / net / minecraftforge / debug / mod / ConfigAnnotationTest . java b / src / test / java / net / minecraftforge / debug / mod / ConfigAnnotationTest . java <nl> index d62f579 . . 56cb7c6 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / mod / ConfigAnnotationTest . java <nl> + + + b / src / test / java / net / minecraftforge / debug / mod / ConfigAnnotationTest . java <nl> @ @ - 37 , 6 + 37 , 7 @ @ import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; <nl> import org . apache . logging . log4j . Logger ; <nl> <nl> + import java . util . Arrays ; <nl> import java . util . HashMap ; <nl> import java . util . Map ; <nl> <nl> @ @ - 56 , 11 + 57 , 22 @ @ public class ConfigAnnotationTest <nl> @ Mod . EventHandler <nl> public void init ( FMLInitializationEvent event ) <nl> { <nl> + logger . info ( " Starting config modification test . " ) ; <nl> + logger . debug ( " Starting simple variable change test . " ) ; <nl> logger . debug ( " Old : { } " , CONFIG _ TYPES . bool ) ; <nl> CONFIG _ TYPES . bool = ! CONFIG _ TYPES . bool ; <nl> logger . debug ( " New : { } " , CONFIG _ TYPES . bool ) ; <nl> ConfigManager . sync ( MODID , Type . INSTANCE ) ; <nl> logger . debug ( " After sync : { } " , CONFIG _ TYPES . bool ) ; <nl> + <nl> + logger . debug ( " Starting map key addition test . " ) ; <nl> + logger . debug ( " Old map keys : { } " , Arrays . deepToString ( ROOT _ CONFIG _ TEST . mapTest . keySet ( ) . toArray ( ) ) ) ; <nl> + String key = " " + System . currentTimeMillis ( ) ; <nl> + logger . debug ( " Adding key : { } " , key ) ; <nl> + ROOT _ CONFIG _ TEST . mapTest . put ( key , Math . PI ) ; <nl> + ConfigManager . sync ( MODID , Type . INSTANCE ) ; <nl> + logger . debug ( " Keys after sync : { } " , Arrays . deepToString ( ROOT _ CONFIG _ TEST . mapTest . keySet ( ) . toArray ( ) ) ) ; <nl> + logger . debug ( " Synced . Check config gui to verify the key was added properly " ) ; <nl> } <nl> <nl> @ SubscribeEvent <nl> @ @ - 72 , 8 + 84 , 19 @ @ public class ConfigAnnotationTest <nl> } <nl> } <nl> <nl> + @ Config ( modid = MODID , type = Type . INSTANCE ) <nl> + public static class ROOT _ CONFIG _ TEST { <nl> + public static HashMap < String , Double > mapTest = new HashMap < > ( ) ; <nl> + <nl> + static { <nl> + mapTest . put ( " foobar " , 2 . 0 ) ; <nl> + mapTest . put ( " foobaz " , 100 . 5 ) ; <nl> + mapTest . put ( " barbaz " , Double . MAX _ VALUE ) ; <nl> + } <nl> + } <nl> + <nl> @ LangKey ( " config _ test . config . types " ) <nl> - @ Config ( modid = MODID , type = Type . INSTANCE , name = MODID + " _ types " ) <nl> + @ Config ( modid = MODID , type = Type . INSTANCE , name = MODID + " _ types " , category = " types " ) <nl> public static class CONFIG _ TYPES <nl> { <nl> public static boolean bool = false ; <nl> @ @ - 117 , 7 + 140 , 7 @ @ public class ConfigAnnotationTest <nl> } <nl> <nl> @ LangKey ( " config _ test . config . annotations " ) <nl> - @ Config ( modid = MODID ) <nl> + @ Config ( modid = MODID , category = " annotations " ) <nl> public static class CONFIG _ ANNOTATIONS <nl> { <nl> @ RangeDouble ( min = - 10 . 5 , max = 100 . 5 ) <nl> @ @ - 140 , 7 + 163 , 7 @ @ public class ConfigAnnotationTest <nl> } <nl> <nl> @ LangKey ( " config _ test . config . subcats " ) <nl> - @ Config ( modid = MODID , name = MODID + " _ subcats " , category = " " ) <nl> + @ Config ( modid = MODID , name = MODID + " _ subcats " , category = " subcats " ) <nl> public static class CONFIG _ SUBCATS <nl> { <nl> / / public static String THIS _ WILL _ ERROR = " DUH " ; <nl> @ @ - 176 , 7 + 199 , 7 @ @ public class ConfigAnnotationTest <nl> } <nl> <nl> @ LangKey ( " config _ test . config . maps " ) <nl> - @ Config ( modid = MODID , name = MODID + " _ map " ) <nl> + @ Config ( modid = MODID , name = MODID + " _ map " , category = " maps " ) <nl> public static class CONFIG _ MAP <nl> { <nl> @ Name ( " map " )
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / config / ConfigManager . java b / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> index fe2062e . . 34f2712 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> @ @ - 50 , 6 + 50 , 7 @ @ public class ConfigManager <nl> { <nl> private static Map < String , Multimap < Config . Type , ASMData > > asm _ data = Maps . newHashMap ( ) ; <nl> static Map < Class < ? > , ITypeAdapter > ADAPTERS = Maps . newHashMap ( ) ; <nl> + static Map < Class < ? > , Class < ? > > ARRAY _ REMAP = Maps . newHashMap ( ) ; <nl> private static Map < String , Configuration > CONFIGS = Maps . newHashMap ( ) ; <nl> private static Map < String , Set < Class < ? > > > MOD _ CONFIG _ CLASSES = Maps . newHashMap ( ) ; <nl> <nl> @ @ - 85 , 6 + 86 , 16 @ @ public class ConfigManager <nl> register ( Integer [ ] . class , TypeAdapters . IntA ) ; <nl> register ( String . class , TypeAdapters . Str ) ; <nl> register ( String [ ] . class , TypeAdapters . StrA ) ; <nl> + <nl> + <nl> + ARRAY _ REMAP . put ( Boolean . class , Boolean [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Float . class , Float [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Double . class , Double [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Byte . class , Byte [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Character . class , Character [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Short . class , Short [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Integer . class , Integer [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( String . class , String [ ] . class ) ; <nl> } <nl> private static void register ( Class < ? > cls , ITypeAdapter adpt ) <nl> { <nl> @ @ - 110 , 7 + 121 , 7 @ @ public class ConfigManager <nl> map . put ( type , target ) ; <nl> } <nl> } <nl> - <nl> + <nl> / * * <nl> * Bounces to sync ( ) . <nl> * TODO : remove <nl> @ @ - 123 , 13 + 134 , 13 @ @ public class ConfigManager <nl> / * * <nl> * Synchronizes configuration data between the file on disk , the { @ code Configuration } object and the annotated <nl> * mod classes containing the configuration variables . <nl> - * <nl> + * <nl> * When first called , this method will try to load the configuration from disk . If this fails , because the file <nl> * does not exist , it will be created with default values derived from the mods config classes variable default values <nl> * and comments and ranges , as well as configuration names based on the appropriate annotations found in { @ code @ Config } . <nl> - * <nl> + * <nl> * Note , that this method is being called by the { @ link FMLModContaier } , so the mod needn ' t call it in init ( ) . <nl> - * <nl> + * <nl> * If this method is called after the initial load , it will check whether the values in the Configuration object differ <nl> * from the values in the corresponding variables . If they differ , it will either overwrite the variables if the Configuration <nl> * object is marked as changed ( e . g . if it was changed with the ConfigGui ) or otherwise overwrite the Configuration object ' s values . <nl> @ @ - 152 , 11 + 163 , 11 @ @ public class ConfigManager <nl> try <nl> { <nl> Class < ? > cls = Class . forName ( targ . getClassName ( ) , true , mcl ) ; <nl> - <nl> + <nl> if ( MOD _ CONFIG _ CLASSES . get ( modid ) = = null ) <nl> MOD _ CONFIG _ CLASSES . put ( modid , Sets . < Class < ? > > newHashSet ( ) ) ; <nl> MOD _ CONFIG _ CLASSES . get ( modid ) . add ( cls ) ; <nl> - <nl> + <nl> String name = ( String ) targ . getAnnotationInfo ( ) . get ( " name " ) ; <nl> if ( name = = null ) <nl> name = modid ; <nl> @ @ - 188 , 7 + 199 , 7 @ @ public class ConfigManager <nl> } <nl> } <nl> } <nl> - <nl> + <nl> public static Class < ? > [ ] getModConfigClasses ( String modid ) <nl> { <nl> return MOD _ CONFIG _ CLASSES . get ( modid ) . toArray ( new Class < ? > [ 0 ] ) ; <nl> @ @ - 204 , 7 + 215 , 7 @ @ public class ConfigManager <nl> File configFile = new File ( configDir , name + " . cfg " ) ; <nl> return CONFIGS . get ( configFile . getAbsolutePath ( ) ) ; <nl> } <nl> - <nl> + <nl> private static void sync ( Configuration cfg , Class < ? > cls , String modid , String category , boolean loading , Object instance ) <nl> { <nl> for ( Field f : cls . getDeclaredFields ( ) ) <nl> @ @ - 213 , 7 + 224 , 7 @ @ public class ConfigManager <nl> continue ; <nl> if ( Modifier . isStatic ( f . getModifiers ( ) ) ! = ( instance = = null ) ) <nl> continue ; <nl> - <nl> + <nl> String comment = null ; <nl> Comment ca = f . getAnnotation ( Comment . class ) ; <nl> if ( ca ! = null ) <nl> @ @ - 223 , 7 + 234 , 7 @ @ public class ConfigManager <nl> LangKey la = f . getAnnotation ( LangKey . class ) ; <nl> if ( la ! = null ) <nl> langKey = la . value ( ) ; <nl> - <nl> + <nl> boolean requiresMcRestart = f . isAnnotationPresent ( Config . RequiresMcRestart . class ) ; <nl> boolean requiresWorldRestart = f . isAnnotationPresent ( Config . RequiresWorldRestart . class ) ; <nl> <nl> @ @ - 236 , 16 + 247 , 16 @ @ public class ConfigManager <nl> IFieldWrapper wrapper = FieldWrapper . get ( instance , f , category ) ; <nl> ITypeAdapter adapt = wrapper . getTypeAdapter ( ) ; <nl> Property . Type propType = adapt . getType ( ) ; <nl> - <nl> + <nl> for ( String key : wrapper . getKeys ( ) ) <nl> { <nl> String suffix = key . replaceFirst ( wrapper . getCategory ( ) + " . " , " " ) ; <nl> - <nl> + <nl> boolean existed = exists ( cfg , wrapper . getCategory ( ) , suffix ) ; <nl> if ( ! existed | | loading ) / / Creates keys in category specified by the wrapper if new ones are programaticaly added <nl> { <nl> Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; <nl> - <nl> + <nl> adapt . setDefaultValue ( property , wrapper . getValue ( key ) ) ; <nl> if ( ! existed ) <nl> adapt . setValue ( property , wrapper . getValue ( key ) ) ; <nl> @ @ - 253 , 7 + 264 , 7 @ @ public class ConfigManager <nl> wrapper . setValue ( key , adapt . getValue ( property ) ) ; <nl> } <nl> else / / If the key is not new , sync according to shoudlReadFromVar ( ) <nl> - { <nl> + { <nl> Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; <nl> Object propVal = adapt . getValue ( property ) ; <nl> Object mapVal = wrapper . getValue ( key ) ; <nl> @ @ - 263 , 25 + 274 , 25 @ @ public class ConfigManager <nl> wrapper . setValue ( key , propVal ) ; <nl> } <nl> } <nl> - <nl> + <nl> <nl> ConfigCategory confCat = cfg . getCategory ( wrapper . getCategory ( ) ) ; <nl> - <nl> + <nl> for ( Property property : confCat . getOrderedValues ( ) ) / / Are new keys in the Configuration object ? <nl> { <nl> if ( ! wrapper . handlesKey ( property . getName ( ) ) ) <nl> continue ; <nl> - <nl> + <nl> if ( loading | | ! wrapper . hasKey ( property . getName ( ) ) ) <nl> - { <nl> + { <nl> Object value = wrapper . getTypeAdapter ( ) . getValue ( property ) ; <nl> wrapper . setValue ( confCat . getName ( ) + " . " + property . getName ( ) , value ) ; <nl> } <nl> } <nl> - <nl> - if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . <nl> + <nl> + if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . <nl> wrapper . setupConfiguration ( cfg , comment , langKey , requiresMcRestart , requiresWorldRestart ) ; <nl> - <nl> + <nl> } <nl> catch ( Exception e ) / / If anything goes wrong , add the errored field and class . <nl> { <nl> @ @ - 289 , 9 + 300 , 9 @ @ public class ConfigManager <nl> String error = String . format ( format , f . getName ( ) , cls . getName ( ) ) ; <nl> throw new RuntimeException ( error , e ) ; <nl> } <nl> - } <nl> + } <nl> else if ( f . getType ( ) . getSuperclass ( ) ! = null & & f . getType ( ) . getSuperclass ( ) . equals ( Object . class ) ) / / Descend the object tree <nl> - { <nl> + { <nl> Object newInstance = null ; <nl> try <nl> { <nl> @ @ - 302 , 14 + 313 , 14 @ @ public class ConfigManager <nl> / / This should never happen . Previous checks should eliminate this . <nl> Throwables . propagate ( e ) ; <nl> } <nl> - <nl> + <nl> String sub = ( category . isEmpty ( ) ? " " : category + " . " ) + getName ( f ) . toLowerCase ( Locale . ENGLISH ) ; <nl> ConfigCategory confCat = cfg . getCategory ( sub ) ; <nl> confCat . setComment ( comment ) ; <nl> confCat . setLanguageKey ( langKey ) ; <nl> confCat . setRequiresMcRestart ( requiresMcRestart ) ; <nl> confCat . setRequiresWorldRestart ( requiresWorldRestart ) ; <nl> - <nl> + <nl> sync ( cfg , f . getType ( ) , modid , sub , loading , newInstance ) ; <nl> } <nl> else <nl> @ @ - 323 , 7 + 334 , 7 @ @ public class ConfigManager <nl> <nl> static final Joiner NEW _ LINE = Joiner . on ( ' \ n ' ) ; <nl> static final Joiner PIPE = Joiner . on ( ' | ' ) ; <nl> - <nl> + <nl> private static Property property ( Configuration cfg , String category , String property , Property . Type type , boolean isList ) <nl> { <nl> Property prop = cfg . getCategory ( category ) . get ( property ) ; <nl> @ @ - 337 , 12 + 348 , 12 @ @ public class ConfigManager <nl> } <nl> return prop ; <nl> } <nl> - <nl> + <nl> private static boolean exists ( Configuration cfg , String category , String property ) <nl> { <nl> return cfg . hasCategory ( category ) & & cfg . getCategory ( category ) . containsKey ( property ) ; <nl> } <nl> - <nl> + <nl> private static boolean shouldReadFromVar ( Property property , Object propValue , Object fieldValue ) <nl> { <nl> if ( ! propValue . equals ( fieldValue ) ) <nl> diff - - git a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> index 19272c5 . . 35fcfb4 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> @ @ - 1 , 6 + 1 , 7 @ @ <nl> package net . minecraftforge . common . config ; <nl> <nl> import java . lang . reflect . Field ; <nl> + import java . lang . reflect . GenericArrayType ; <nl> import java . lang . reflect . ParameterizedType ; <nl> import java . lang . reflect . Type ; <nl> import java . util . Iterator ; <nl> @ @ - 67 , 6 + 68 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> { <nl> private Map < String , Object > theMap = null ; <nl> private Type mType ; <nl> + ITypeAdapter adapter ; <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> private MapWrapper ( String category , Field field , Object instance ) <nl> @ @ - 90 , 18 + 92 , 25 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> ParameterizedType type = ( ParameterizedType ) field . getGenericType ( ) ; <nl> mType = type . getActualTypeArguments ( ) [ 1 ] ; <nl> <nl> - if ( ADAPTERS . get ( mType ) = = null & & ! Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) <nl> + this . adapter = ADAPTERS . get ( mType ) ; <nl> + if ( this . adapter = = null & & mType instanceof GenericArrayType ) <nl> + { <nl> + this . adapter = ADAPTERS . get ( ARRAY _ REMAP . get ( ( ( GenericArrayType ) mType ) . getGenericComponentType ( ) ) ) ; / / J6 seems to have issues , Need to find a better way to translate this . We don ' t have access to array depth . <nl> + } <nl> + <nl> + if ( mType instanceof Class & & Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) <nl> + { <nl> + this . adapter = TypeAdapters . Str ; <nl> + } <nl> + <nl> + if ( this . adapter = = null ) <nl> throw new IllegalArgumentException ( String . format ( " The map ' % s ' of class ' % s ' has target values which are neither primitive nor an enum ! " , <nl> field . getName ( ) , field . getDeclaringClass ( ) . getCanonicalName ( ) ) ) ; <nl> - <nl> } <nl> <nl> @ Override <nl> public ITypeAdapter getTypeAdapter ( ) <nl> { <nl> - ITypeAdapter adapter = ADAPTERS . get ( mType ) ; <nl> - if ( adapter = = null & & Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) <nl> - adapter = TypeAdapters . Str ; <nl> return adapter ; <nl> } <nl> <nl> diff - - git a / src / test / java / net / minecraftforge / debug / ConfigTest . java b / src / test / java / net / minecraftforge / debug / ConfigTest . java <nl> index db6f5c1 . . fcd6c5a 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / ConfigTest . java <nl> + + + b / src / test / java / net / minecraftforge / debug / ConfigTest . java <nl> @ @ - 25 , 12 + 25 , 12 @ @ import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; <nl> public class ConfigTest <nl> { <nl> public static final String MODID = " config _ test " ; <nl> - <nl> + <nl> @ Mod . EventHandler <nl> public void preInit ( FMLPreInitializationEvent event ) { <nl> MinecraftForge . EVENT _ BUS . register ( this ) ; <nl> } <nl> - <nl> + <nl> @ Mod . EventHandler <nl> public void init ( FMLInitializationEvent event ) { <nl> System . out . println ( " Old : " + CONFIG _ TYPES . bool ) ; <nl> @ @ - 39 , 7 + 39 , 7 @ @ public class ConfigTest <nl> ConfigManager . sync ( MODID , Type . INSTANCE ) ; <nl> System . out . println ( " After sync : " + CONFIG _ TYPES . bool ) ; <nl> } <nl> - <nl> + <nl> @ SubscribeEvent <nl> public void onConfigChangedEvent ( OnConfigChangedEvent event ) { <nl> if ( event . getModID ( ) . equals ( MODID ) ) <nl> @ @ - 134 , 7 + 134 , 7 @ @ public class ConfigTest <nl> } <nl> } <nl> } <nl> - <nl> + <nl> @ LangKey ( " config _ test . config . maps " ) <nl> @ Config ( modid = MODID , name = MODID + " _ map " ) <nl> public static class CONFIG _ MAP <nl> @ @ - 142 , 8 + 142 , 8 @ @ public class ConfigTest <nl> @ Name ( " map " ) <nl> @ RequiresMcRestart <nl> public static Map < String , Integer [ ] > theMap ; <nl> - <nl> - static <nl> + <nl> + static <nl> { <nl> theMap = Maps . newHashMap ( ) ; <nl> for ( int i = 0 ; i < 7 ; i + + )

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / config / ConfigManager . java b / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 index c1d6a8f . . 30a8c56 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 + + + b / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 @ @ - 220 , 8 + 220 , 12 @ @ public class ConfigManager 
 { 
 if ( ! Modifier . isPublic ( f . getModifiers ( ) ) ) 
 continue ; 
 + 
 + / / Only the root class may have static fields . Otherwise category tree nodes of the same type would share the 
 + / / contained value messing up the sync 
 if ( Modifier . isStatic ( f . getModifiers ( ) ) ! = ( instance = = null ) ) 
 continue ; 
 + 
 if ( f . isAnnotationPresent ( Config . Ignore . class ) ) 
 continue ; 
 
 @ @ - 230 , 7 + 234 , 7 @ @ public class ConfigManager 
 if ( ca ! = null ) 
 comment = NEW _ LINE . join ( ca . value ( ) ) ; 
 
 - String langKey = modid + " . " + ( category . isEmpty ( ) ? " " : category + " . " ) + f . getName ( ) . toLowerCase ( Locale . ENGLISH ) ; 
 + String langKey = modid + " . " + ( category . isEmpty ( ) ? " " : category + Configuration . CATEGORY _ SPLITTER ) + f . getName ( ) . toLowerCase ( Locale . ENGLISH ) ; 
 LangKey la = f . getAnnotation ( LangKey . class ) ; 
 if ( la ! = null ) 
 langKey = la . value ( ) ; 
 @ @ - 238 , 7 + 242 , 7 @ @ public class ConfigManager 
 boolean requiresMcRestart = f . isAnnotationPresent ( Config . RequiresMcRestart . class ) ; 
 boolean requiresWorldRestart = f . isAnnotationPresent ( Config . RequiresWorldRestart . class ) ; 
 
 - if ( FieldWrapper . hasWrapperFor ( f ) ) / / Access the field 
 + if ( FieldWrapper . hasWrapperFor ( f ) ) / / Wrappers exist for primitives , enums , maps and arrays 
 { 
 if ( Strings . isNullOrEmpty ( category ) ) 
 throw new RuntimeException ( " An empty category may not contain anything but objects representing categories ! " ) ; 
 @ @ - 248 , 9 + 252 , 9 @ @ public class ConfigManager 
 ITypeAdapter adapt = wrapper . getTypeAdapter ( ) ; 
 Property . Type propType = adapt . getType ( ) ; 
 
 - for ( String key : wrapper . getKeys ( ) ) 
 + for ( String key : wrapper . getKeys ( ) ) / / Iterate the fully qualified property names the field provides 
 { 
 - String suffix = StringUtils . replaceOnce ( key , wrapper . getCategory ( ) + " . " , " " ) ; 
 + String suffix = StringUtils . replaceOnce ( key , wrapper . getCategory ( ) + Configuration . CATEGORY _ SPLITTER , " " ) ; 
 
 boolean existed = exists ( cfg , wrapper . getCategory ( ) , suffix ) ; 
 if ( ! existed | | loading ) / / Creates keys in category specified by the wrapper if new ones are programaticaly added 
 @ @ - 263 , 7 + 267 , 7 @ @ public class ConfigManager 
 else 
 wrapper . setValue ( key , adapt . getValue ( property ) ) ; 
 } 
 - else / / If the key is not new , sync according to shoudlReadFromVar ( ) 
 + else / / If the key is not new , sync according to shouldReadFromVar ( ) 
 { 
 Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; 
 Object propVal = adapt . getValue ( property ) ; 
 @ @ - 278 , 31 + 282 , 32 @ @ public class ConfigManager 
 
 ConfigCategory confCat = cfg . getCategory ( wrapper . getCategory ( ) ) ; 
 
 - for ( Property property : confCat . getOrderedValues ( ) ) / / Are new keys in the Configuration object ? 
 + for ( Property property : confCat . getOrderedValues ( ) ) / / Iterate the properties to check for new data from the config side 
 { 
 - if ( ! wrapper . handlesKey ( property . getName ( ) ) ) 
 + String key = confCat . getQualifiedName ( ) + Configuration . CATEGORY _ SPLITTER + property . getName ( ) ; 
 + if ( ! wrapper . handlesKey ( key ) ) 
 continue ; 
 
 - if ( loading | | ! wrapper . hasKey ( property . getName ( ) ) ) 
 + if ( loading | | ! wrapper . hasKey ( key ) ) 
 { 
 Object value = wrapper . getTypeAdapter ( ) . getValue ( property ) ; 
 - wrapper . setValue ( confCat . getName ( ) + " . " + property . getName ( ) , value ) ; 
 + wrapper . setValue ( key , value ) ; 
 } 
 } 
 
 - if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . 
 + if ( loading ) 
 wrapper . setupConfiguration ( cfg , comment , langKey , requiresMcRestart , requiresWorldRestart ) ; 
 
 } 
 - catch ( Exception e ) / / If anything goes wrong , add the errored field and class . 
 + catch ( Exception e ) 
 { 
 String format = " Error syncing field ' % s ' of class ' % s ' ! " ; 
 String error = String . format ( format , f . getName ( ) , cls . getName ( ) ) ; 
 throw new RuntimeException ( error , e ) ; 
 } 
 } 
 - else if ( f . getType ( ) . getSuperclass ( ) ! = null & & f . getType ( ) . getSuperclass ( ) . equals ( Object . class ) ) / / Descend the object tree 
 - { 
 + else if ( f . getType ( ) . getSuperclass ( ) ! = null & & f . getType ( ) . getSuperclass ( ) . equals ( Object . class ) ) 
 + { / / If the field extends Object directly , descend the object tree and access the objects members 
 Object newInstance = null ; 
 try 
 { 
 @ @ - 310 , 11 + 315 , 11 @ @ public class ConfigManager 
 } 
 catch ( IllegalAccessException e ) 
 { 
 - / / This should never happen . Previous checks should eliminate this . 
 throw new RuntimeException ( e ) ; 
 } 
 
 - String sub = ( category . isEmpty ( ) ? " " : category + " . " ) + getName ( f ) . toLowerCase ( Locale . ENGLISH ) ; 
 + / / Setup the sub category with its respective name , comment , language key , etc . 
 + String sub = ( category . isEmpty ( ) ? " " : category + Configuration . CATEGORY _ SPLITTER ) + getName ( f ) . toLowerCase ( Locale . ENGLISH ) ; 
 ConfigCategory confCat = cfg . getCategory ( sub ) ; 
 confCat . setComment ( comment ) ; 
 confCat . setLanguageKey ( langKey ) ; 
 diff - - git a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 index 3ce39d2 . . 25c4515 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 + + + b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 @ @ - 4 , 12 + 4 , 9 @ @ import java . lang . reflect . Field ; 
 import java . lang . reflect . GenericArrayType ; 
 import java . lang . reflect . ParameterizedType ; 
 import java . lang . reflect . Type ; 
 - import java . util . Iterator ; 
 - import java . util . List ; 
 - import java . util . Map ; 
 + import java . util . * ; 
 import java . util . Map . Entry ; 
 import java . util . regex . Pattern ; 
 - import java . util . Set ; 
 
 import com . google . common . collect . Lists ; 
 
 @ @ - 68 , 6 + 65 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 { 
 private Map < String , Object > theMap = null ; 
 private Type mType ; 
 + private final String baseName ; 
 ITypeAdapter adapter ; 
 
 @ SuppressWarnings ( " unchecked " ) 
 @ @ - 75 , 6 + 73 , 8 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 { 
 super ( category , field , instance ) ; 
 
 + this . baseName = ( this . category = = null ) ? " " : ( this . category + " . " ) + this . name . toLowerCase ( Locale . ENGLISH ) + " . " ; 
 + 
 try 
 { 
 theMap = ( Map < String , Object > ) field . get ( instance ) ; 
 @ @ - 123 , 7 + 123 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 Iterator < String > it = keys . iterator ( ) ; 
 for ( int i = 0 ; i < keyArray . length ; i + + ) 
 { 
 - keyArray [ i ] = category + " . " + name + " . " + it . next ( ) ; 
 + keyArray [ i ] = this . baseName + it . next ( ) ; 
 } 
 
 return keyArray ; 
 @ @ - 132 , 28 + 132 , 27 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 @ Override 
 public Object getValue ( String key ) 
 { 
 - return theMap . get ( StringUtils . replaceOnce ( key , category + " . " + name + " . " , " " ) ) ; 
 + return theMap . get ( getSuffix ( key ) ) ; 
 } 
 
 @ Override 
 public void setValue ( String key , Object value ) 
 { 
 - String suffix = StringUtils . replaceOnce ( key , category + " . " + name + " . " , " " ) ; 
 - theMap . put ( suffix , value ) ; 
 + theMap . put ( getSuffix ( key ) , value ) ; 
 } 
 
 @ Override 
 - public boolean hasKey ( String name ) 
 + public boolean hasKey ( String key ) 
 { 
 - return theMap . containsKey ( name ) ; 
 + return theMap . containsKey ( getSuffix ( key ) ) ; 
 } 
 
 @ Override 
 - public boolean handlesKey ( String name ) 
 + public boolean handlesKey ( String key ) 
 { 
 - if ( name = = null ) 
 + if ( key = = null ) 
 return false ; 
 - return name . startsWith ( category + " . " + name + " . " ) ; 
 + return key . startsWith ( this . baseName ) ; 
 } 
 
 @ Override 
 @ @ - 169 , 7 + 168 , 17 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 @ Override 
 public String getCategory ( ) 
 { 
 - return category + " . " + name ; 
 + return ( this . category = = null ) ? " " : ( this . category + " . " ) + this . name . toLowerCase ( Locale . ENGLISH ) ; 
 + } 
 + 
 + / * * 
 + * Removes the { @ code this . baseName } prefix from the key 
 + * @ param key the key to be edited 
 + * @ return the keys suffix 
 + * / 
 + private String getSuffix ( String key ) 
 + { 
 + return StringUtils . replaceOnce ( key , this . baseName , " " ) ; 
 } 
 
 } 
 @ @ - 336 , 15 + 345 , 15 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 } 
 
 @ Override 
 - public boolean hasKey ( String name ) 
 + public boolean hasKey ( String key ) 
 { 
 - return ( this . category + " . " + this . name ) . equals ( name ) ; 
 + return ( this . category + " . " + this . name ) . equals ( key ) ; 
 } 
 
 @ Override 
 - public boolean handlesKey ( String name ) 
 + public boolean handlesKey ( String key ) 
 { 
 - return hasKey ( name ) ; 
 + return hasKey ( key ) ; 
 } 
 
 @ Override 
 @ @ - 361 , 7 + 370 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 @ Override 
 public String getCategory ( ) 
 { 
 - return category ; 
 + return this . category ; 
 } 
 
 } 
 diff - - git a / src / main / java / net / minecraftforge / common / config / IFieldWrapper . java b / src / main / java / net / minecraftforge / common / config / IFieldWrapper . java 
 index 4706575 . . b74e393 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / IFieldWrapper . java 
 + + + b / src / main / java / net / minecraftforge / common / config / IFieldWrapper . java 
 @ @ - 2 , 6 + 2 , 8 @ @ package net . minecraftforge . common . config ; 
 
 / * * 
 * The objects are expected to get their wrapped field , the owning class , instance and category string on initialization . 
 + * In general : The key is the fully qualified property name , where each subcategory is appended with a dot . 
 + * i . e : general . map . isPresent 
 * / 
 public interface IFieldWrapper 
 { 
 @ @ - 12 , 24 + 14 , 46 @ @ public interface IFieldWrapper 
 ITypeAdapter getTypeAdapter ( ) ; 
 
 / * * 
 - * @ param field the field about which to retrieve information 
 - * @ param instance The instance whose field shall be queried . 
 - * @ return a list of keys handled by this field 
 + * @ return a list of fully qualified property keys handled by this field 
 * / 
 String [ ] getKeys ( ) ; 
 - 
 + 
 + / * * 
 + * @ param key the fully qualified property key 
 + * @ return the value the wrapped field associates with the given key 
 + * / 
 Object getValue ( String key ) ; 
 - 
 + 
 + / * * 
 + * @ param key the fully qualified property key 
 + * @ param value the target value of the property associated with the key 
 + * / 
 void setValue ( String key , Object value ) ; 
 - 
 - boolean hasKey ( String name ) ; 
 - 
 - boolean handlesKey ( String name ) ; 
 - 
 + 
 + / * * 
 + * @ param key a fully qualified property key 
 + * @ return true if the wrapped field contains a property associated with the given key 
 + * / 
 + boolean hasKey ( String key ) ; 
 + 
 + / * * 
 + * @ param key a fully qualified property key 
 + * @ return true if the wrapped field can save information associated with the given key , false otherwise 
 + * / 
 + boolean handlesKey ( String key ) ; 
 + 
 + / * * 
 + * @ param cfg The configuration object holding the properties 
 + * @ param desc The properties description 
 + * @ param langKey The languageKey of the property , used in GUI 
 + * @ param reqMCRestart True , if a change in this property requires a restart of Minecraft 
 + * @ param reqWorldRestart True , if the world needs to be reloaded after changes to this property 
 + * / 
 void setupConfiguration ( Configuration cfg , String desc , String langKey , boolean reqMCRestart , boolean reqWorldRestart ) ; 
 
 / * * 
 - * @ return the category name in which the entries should be saved . 
 + * i . e . general . map in the example above 
 + * @ return the category name in which the entries should be saved . This includes the parent categories 
 * / 
 String getCategory ( ) ; 
 } 
 diff - - git a / src / main / java / net / minecraftforge / common / config / ITypeAdapter . java b / src / main / java / net / minecraftforge / common / config / ITypeAdapter . java 
 index ed157a1 . . c5644fc 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / ITypeAdapter . java 
 + + + b / src / main / java / net / minecraftforge / common / config / ITypeAdapter . java 
 @ @ - 20 , 15 + 20 , 33 @ @ package net . minecraftforge . common . config ; 
 
 import net . minecraftforge . common . config . Property . Type ; 
 
 + / * * 
 + * Abstracts the types of properties away . Higher level logic must prevent invalid data types . 
 + * / 
 interface ITypeAdapter 
 { 
 + / * * 
 + * Assigns the default value to the property 
 + * @ param property the property whose default value will be assigned 
 + * @ param value the default value 
 + * / 
 void setDefaultValue ( Property property , Object value ) ; 
 - 	 
 + 
 + / * * 
 + * Sets the properties value . 
 + * @ param property the property whose value will be set 
 + * @ param value the set value 
 + * / 
 	 void setValue ( Property property , Object value ) ; 
 
 + / * * 
 + * Retrieves the properties value 
 + * @ param prop the property whose value will be retrieved 
 + * @ return the properties value 
 + * / 
 	 Object getValue ( Property prop ) ; 
 
 Type getType ( ) ; 
 - 
 + 
 boolean isArrayAdapter ( ) ; 
 } 
 diff - - git a / src / test / java / net / minecraftforge / debug / mod / ConfigAnnotationTest . java b / src / test / java / net / minecraftforge / debug / mod / ConfigAnnotationTest . java 
 index d62f579 . . 56cb7c6 100644 
 - - - a / src / test / java / net / minecraftforge / debug / mod / ConfigAnnotationTest . java 
 + + + b / src / test / java / net / minecraftforge / debug / mod / ConfigAnnotationTest . java 
 @ @ - 37 , 6 + 37 , 7 @ @ import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; 
 import org . apache . logging . log4j . Logger ; 
 
 + import java . util . Arrays ; 
 import java . util . HashMap ; 
 import java . util . Map ; 
 
 @ @ - 56 , 11 + 57 , 22 @ @ public class ConfigAnnotationTest 
 @ Mod . EventHandler 
 public void init ( FMLInitializationEvent event ) 
 { 
 + logger . info ( " Starting config modification test . " ) ; 
 + logger . debug ( " Starting simple variable change test . " ) ; 
 logger . debug ( " Old : { } " , CONFIG _ TYPES . bool ) ; 
 CONFIG _ TYPES . bool = ! CONFIG _ TYPES . bool ; 
 logger . debug ( " New : { } " , CONFIG _ TYPES . bool ) ; 
 ConfigManager . sync ( MODID , Type . INSTANCE ) ; 
 logger . debug ( " After sync : { } " , CONFIG _ TYPES . bool ) ; 
 + 
 + logger . debug ( " Starting map key addition test . " ) ; 
 + logger . debug ( " Old map keys : { } " , Arrays . deepToString ( ROOT _ CONFIG _ TEST . mapTest . keySet ( ) . toArray ( ) ) ) ; 
 + String key = " " + System . currentTimeMillis ( ) ; 
 + logger . debug ( " Adding key : { } " , key ) ; 
 + ROOT _ CONFIG _ TEST . mapTest . put ( key , Math . PI ) ; 
 + ConfigManager . sync ( MODID , Type . INSTANCE ) ; 
 + logger . debug ( " Keys after sync : { } " , Arrays . deepToString ( ROOT _ CONFIG _ TEST . mapTest . keySet ( ) . toArray ( ) ) ) ; 
 + logger . debug ( " Synced . Check config gui to verify the key was added properly " ) ; 
 } 
 
 @ SubscribeEvent 
 @ @ - 72 , 8 + 84 , 19 @ @ public class ConfigAnnotationTest 
 } 
 } 
 
 + @ Config ( modid = MODID , type = Type . INSTANCE ) 
 + public static class ROOT _ CONFIG _ TEST { 
 + public static HashMap < String , Double > mapTest = new HashMap < > ( ) ; 
 + 
 + static { 
 + mapTest . put ( " foobar " , 2 . 0 ) ; 
 + mapTest . put ( " foobaz " , 100 . 5 ) ; 
 + mapTest . put ( " barbaz " , Double . MAX _ VALUE ) ; 
 + } 
 + } 
 + 
 @ LangKey ( " config _ test . config . types " ) 
 - @ Config ( modid = MODID , type = Type . INSTANCE , name = MODID + " _ types " ) 
 + @ Config ( modid = MODID , type = Type . INSTANCE , name = MODID + " _ types " , category = " types " ) 
 public static class CONFIG _ TYPES 
 { 
 public static boolean bool = false ; 
 @ @ - 117 , 7 + 140 , 7 @ @ public class ConfigAnnotationTest 
 } 
 
 @ LangKey ( " config _ test . config . annotations " ) 
 - @ Config ( modid = MODID ) 
 + @ Config ( modid = MODID , category = " annotations " ) 
 public static class CONFIG _ ANNOTATIONS 
 { 
 @ RangeDouble ( min = - 10 . 5 , max = 100 . 5 ) 
 @ @ - 140 , 7 + 163 , 7 @ @ public class ConfigAnnotationTest 
 } 
 
 @ LangKey ( " config _ test . config . subcats " ) 
 - @ Config ( modid = MODID , name = MODID + " _ subcats " , category = " " ) 
 + @ Config ( modid = MODID , name = MODID + " _ subcats " , category = " subcats " ) 
 public static class CONFIG _ SUBCATS 
 { 
 / / public static String THIS _ WILL _ ERROR = " DUH " ; 
 @ @ - 176 , 7 + 199 , 7 @ @ public class ConfigAnnotationTest 
 } 
 
 @ LangKey ( " config _ test . config . maps " ) 
 - @ Config ( modid = MODID , name = MODID + " _ map " ) 
 + @ Config ( modid = MODID , name = MODID + " _ map " , category = " maps " ) 
 public static class CONFIG _ MAP 
 { 
 @ Name ( " map " )

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / config / ConfigManager . java b / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 index fe2062e . . 34f2712 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 + + + b / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 @ @ - 50 , 6 + 50 , 7 @ @ public class ConfigManager 
 { 
 private static Map < String , Multimap < Config . Type , ASMData > > asm _ data = Maps . newHashMap ( ) ; 
 static Map < Class < ? > , ITypeAdapter > ADAPTERS = Maps . newHashMap ( ) ; 
 + static Map < Class < ? > , Class < ? > > ARRAY _ REMAP = Maps . newHashMap ( ) ; 
 private static Map < String , Configuration > CONFIGS = Maps . newHashMap ( ) ; 
 private static Map < String , Set < Class < ? > > > MOD _ CONFIG _ CLASSES = Maps . newHashMap ( ) ; 
 
 @ @ - 85 , 6 + 86 , 16 @ @ public class ConfigManager 
 register ( Integer [ ] . class , TypeAdapters . IntA ) ; 
 register ( String . class , TypeAdapters . Str ) ; 
 register ( String [ ] . class , TypeAdapters . StrA ) ; 
 + 
 + 
 + ARRAY _ REMAP . put ( Boolean . class , Boolean [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Float . class , Float [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Double . class , Double [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Byte . class , Byte [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Character . class , Character [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Short . class , Short [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Integer . class , Integer [ ] . class ) ; 
 + ARRAY _ REMAP . put ( String . class , String [ ] . class ) ; 
 } 
 private static void register ( Class < ? > cls , ITypeAdapter adpt ) 
 { 
 @ @ - 110 , 7 + 121 , 7 @ @ public class ConfigManager 
 map . put ( type , target ) ; 
 } 
 } 
 - 
 + 
 / * * 
 * Bounces to sync ( ) . 
 * TODO : remove 
 @ @ - 123 , 13 + 134 , 13 @ @ public class ConfigManager 
 / * * 
 * Synchronizes configuration data between the file on disk , the { @ code Configuration } object and the annotated 
 * mod classes containing the configuration variables . 
 - * 
 + * 
 * When first called , this method will try to load the configuration from disk . If this fails , because the file 
 * does not exist , it will be created with default values derived from the mods config classes variable default values 
 * and comments and ranges , as well as configuration names based on the appropriate annotations found in { @ code @ Config } . 
 - * 
 + * 
 * Note , that this method is being called by the { @ link FMLModContaier } , so the mod needn ' t call it in init ( ) . 
 - * 
 + * 
 * If this method is called after the initial load , it will check whether the values in the Configuration object differ 
 * from the values in the corresponding variables . If they differ , it will either overwrite the variables if the Configuration 
 * object is marked as changed ( e . g . if it was changed with the ConfigGui ) or otherwise overwrite the Configuration object ' s values . 
 @ @ - 152 , 11 + 163 , 11 @ @ public class ConfigManager 
 try 
 { 
 Class < ? > cls = Class . forName ( targ . getClassName ( ) , true , mcl ) ; 
 - 
 + 
 if ( MOD _ CONFIG _ CLASSES . get ( modid ) = = null ) 
 MOD _ CONFIG _ CLASSES . put ( modid , Sets . < Class < ? > > newHashSet ( ) ) ; 
 MOD _ CONFIG _ CLASSES . get ( modid ) . add ( cls ) ; 
 - 
 + 
 String name = ( String ) targ . getAnnotationInfo ( ) . get ( " name " ) ; 
 if ( name = = null ) 
 name = modid ; 
 @ @ - 188 , 7 + 199 , 7 @ @ public class ConfigManager 
 } 
 } 
 } 
 - 
 + 
 public static Class < ? > [ ] getModConfigClasses ( String modid ) 
 { 
 return MOD _ CONFIG _ CLASSES . get ( modid ) . toArray ( new Class < ? > [ 0 ] ) ; 
 @ @ - 204 , 7 + 215 , 7 @ @ public class ConfigManager 
 File configFile = new File ( configDir , name + " . cfg " ) ; 
 return CONFIGS . get ( configFile . getAbsolutePath ( ) ) ; 
 } 
 - 
 + 
 private static void sync ( Configuration cfg , Class < ? > cls , String modid , String category , boolean loading , Object instance ) 
 { 
 for ( Field f : cls . getDeclaredFields ( ) ) 
 @ @ - 213 , 7 + 224 , 7 @ @ public class ConfigManager 
 continue ; 
 if ( Modifier . isStatic ( f . getModifiers ( ) ) ! = ( instance = = null ) ) 
 continue ; 
 - 
 + 
 String comment = null ; 
 Comment ca = f . getAnnotation ( Comment . class ) ; 
 if ( ca ! = null ) 
 @ @ - 223 , 7 + 234 , 7 @ @ public class ConfigManager 
 LangKey la = f . getAnnotation ( LangKey . class ) ; 
 if ( la ! = null ) 
 langKey = la . value ( ) ; 
 - 
 + 
 boolean requiresMcRestart = f . isAnnotationPresent ( Config . RequiresMcRestart . class ) ; 
 boolean requiresWorldRestart = f . isAnnotationPresent ( Config . RequiresWorldRestart . class ) ; 
 
 @ @ - 236 , 16 + 247 , 16 @ @ public class ConfigManager 
 IFieldWrapper wrapper = FieldWrapper . get ( instance , f , category ) ; 
 ITypeAdapter adapt = wrapper . getTypeAdapter ( ) ; 
 Property . Type propType = adapt . getType ( ) ; 
 - 
 + 
 for ( String key : wrapper . getKeys ( ) ) 
 { 
 String suffix = key . replaceFirst ( wrapper . getCategory ( ) + " . " , " " ) ; 
 - 
 + 
 boolean existed = exists ( cfg , wrapper . getCategory ( ) , suffix ) ; 
 if ( ! existed | | loading ) / / Creates keys in category specified by the wrapper if new ones are programaticaly added 
 { 
 Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; 
 - 
 + 
 adapt . setDefaultValue ( property , wrapper . getValue ( key ) ) ; 
 if ( ! existed ) 
 adapt . setValue ( property , wrapper . getValue ( key ) ) ; 
 @ @ - 253 , 7 + 264 , 7 @ @ public class ConfigManager 
 wrapper . setValue ( key , adapt . getValue ( property ) ) ; 
 } 
 else / / If the key is not new , sync according to shoudlReadFromVar ( ) 
 - { 
 + { 
 Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; 
 Object propVal = adapt . getValue ( property ) ; 
 Object mapVal = wrapper . getValue ( key ) ; 
 @ @ - 263 , 25 + 274 , 25 @ @ public class ConfigManager 
 wrapper . setValue ( key , propVal ) ; 
 } 
 } 
 - 
 + 
 
 ConfigCategory confCat = cfg . getCategory ( wrapper . getCategory ( ) ) ; 
 - 
 + 
 for ( Property property : confCat . getOrderedValues ( ) ) / / Are new keys in the Configuration object ? 
 { 
 if ( ! wrapper . handlesKey ( property . getName ( ) ) ) 
 continue ; 
 - 
 + 
 if ( loading | | ! wrapper . hasKey ( property . getName ( ) ) ) 
 - { 
 + { 
 Object value = wrapper . getTypeAdapter ( ) . getValue ( property ) ; 
 wrapper . setValue ( confCat . getName ( ) + " . " + property . getName ( ) , value ) ; 
 } 
 } 
 - 
 - if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . 
 + 
 + if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . 
 wrapper . setupConfiguration ( cfg , comment , langKey , requiresMcRestart , requiresWorldRestart ) ; 
 - 
 + 
 } 
 catch ( Exception e ) / / If anything goes wrong , add the errored field and class . 
 { 
 @ @ - 289 , 9 + 300 , 9 @ @ public class ConfigManager 
 String error = String . format ( format , f . getName ( ) , cls . getName ( ) ) ; 
 throw new RuntimeException ( error , e ) ; 
 } 
 - } 
 + } 
 else if ( f . getType ( ) . getSuperclass ( ) ! = null & & f . getType ( ) . getSuperclass ( ) . equals ( Object . class ) ) / / Descend the object tree 
 - { 
 + { 
 Object newInstance = null ; 
 try 
 { 
 @ @ - 302 , 14 + 313 , 14 @ @ public class ConfigManager 
 / / This should never happen . Previous checks should eliminate this . 
 Throwables . propagate ( e ) ; 
 } 
 - 
 + 
 String sub = ( category . isEmpty ( ) ? " " : category + " . " ) + getName ( f ) . toLowerCase ( Locale . ENGLISH ) ; 
 ConfigCategory confCat = cfg . getCategory ( sub ) ; 
 confCat . setComment ( comment ) ; 
 confCat . setLanguageKey ( langKey ) ; 
 confCat . setRequiresMcRestart ( requiresMcRestart ) ; 
 confCat . setRequiresWorldRestart ( requiresWorldRestart ) ; 
 - 
 + 
 sync ( cfg , f . getType ( ) , modid , sub , loading , newInstance ) ; 
 } 
 else 
 @ @ - 323 , 7 + 334 , 7 @ @ public class ConfigManager 
 
 static final Joiner NEW _ LINE = Joiner . on ( ' \ n ' ) ; 
 static final Joiner PIPE = Joiner . on ( ' | ' ) ; 
 - 
 + 
 private static Property property ( Configuration cfg , String category , String property , Property . Type type , boolean isList ) 
 { 
 Property prop = cfg . getCategory ( category ) . get ( property ) ; 
 @ @ - 337 , 12 + 348 , 12 @ @ public class ConfigManager 
 } 
 return prop ; 
 } 
 - 
 + 
 private static boolean exists ( Configuration cfg , String category , String property ) 
 { 
 return cfg . hasCategory ( category ) & & cfg . getCategory ( category ) . containsKey ( property ) ; 
 } 
 - 
 + 
 private static boolean shouldReadFromVar ( Property property , Object propValue , Object fieldValue ) 
 { 
 if ( ! propValue . equals ( fieldValue ) ) 
 diff - - git a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 index 19272c5 . . 35fcfb4 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 + + + b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package net . minecraftforge . common . config ; 
 
 import java . lang . reflect . Field ; 
 + import java . lang . reflect . GenericArrayType ; 
 import java . lang . reflect . ParameterizedType ; 
 import java . lang . reflect . Type ; 
 import java . util . Iterator ; 
 @ @ - 67 , 6 + 68 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 { 
 private Map < String , Object > theMap = null ; 
 private Type mType ; 
 + ITypeAdapter adapter ; 
 
 @ SuppressWarnings ( " unchecked " ) 
 private MapWrapper ( String category , Field field , Object instance ) 
 @ @ - 90 , 18 + 92 , 25 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 ParameterizedType type = ( ParameterizedType ) field . getGenericType ( ) ; 
 mType = type . getActualTypeArguments ( ) [ 1 ] ; 
 
 - if ( ADAPTERS . get ( mType ) = = null & & ! Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) 
 + this . adapter = ADAPTERS . get ( mType ) ; 
 + if ( this . adapter = = null & & mType instanceof GenericArrayType ) 
 + { 
 + this . adapter = ADAPTERS . get ( ARRAY _ REMAP . get ( ( ( GenericArrayType ) mType ) . getGenericComponentType ( ) ) ) ; / / J6 seems to have issues , Need to find a better way to translate this . We don ' t have access to array depth . 
 + } 
 + 
 + if ( mType instanceof Class & & Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) 
 + { 
 + this . adapter = TypeAdapters . Str ; 
 + } 
 + 
 + if ( this . adapter = = null ) 
 throw new IllegalArgumentException ( String . format ( " The map ' % s ' of class ' % s ' has target values which are neither primitive nor an enum ! " , 
 field . getName ( ) , field . getDeclaringClass ( ) . getCanonicalName ( ) ) ) ; 
 - 
 } 
 
 @ Override 
 public ITypeAdapter getTypeAdapter ( ) 
 { 
 - ITypeAdapter adapter = ADAPTERS . get ( mType ) ; 
 - if ( adapter = = null & & Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) 
 - adapter = TypeAdapters . Str ; 
 return adapter ; 
 } 
 
 diff - - git a / src / test / java / net / minecraftforge / debug / ConfigTest . java b / src / test / java / net / minecraftforge / debug / ConfigTest . java 
 index db6f5c1 . . fcd6c5a 100644 
 - - - a / src / test / java / net / minecraftforge / debug / ConfigTest . java 
 + + + b / src / test / java / net / minecraftforge / debug / ConfigTest . java 
 @ @ - 25 , 12 + 25 , 12 @ @ import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; 
 public class ConfigTest 
 { 
 public static final String MODID = " config _ test " ; 
 - 
 + 
 @ Mod . EventHandler 
 public void preInit ( FMLPreInitializationEvent event ) { 
 MinecraftForge . EVENT _ BUS . register ( this ) ; 
 } 
 - 
 + 
 @ Mod . EventHandler 
 public void init ( FMLInitializationEvent event ) { 
 System . out . println ( " Old : " + CONFIG _ TYPES . bool ) ; 
 @ @ - 39 , 7 + 39 , 7 @ @ public class ConfigTest 
 ConfigManager . sync ( MODID , Type . INSTANCE ) ; 
 System . out . println ( " After sync : " + CONFIG _ TYPES . bool ) ; 
 } 
 - 
 + 
 @ SubscribeEvent 
 public void onConfigChangedEvent ( OnConfigChangedEvent event ) { 
 if ( event . getModID ( ) . equals ( MODID ) ) 
 @ @ - 134 , 7 + 134 , 7 @ @ public class ConfigTest 
 } 
 } 
 } 
 - 
 + 
 @ LangKey ( " config _ test . config . maps " ) 
 @ Config ( modid = MODID , name = MODID + " _ map " ) 
 public static class CONFIG _ MAP 
 @ @ - 142 , 8 + 142 , 8 @ @ public class ConfigTest 
 @ Name ( " map " ) 
 @ RequiresMcRestart 
 public static Map < String , Integer [ ] > theMap ; 
 - 
 - static 
 + 
 + static 
 { 
 theMap = Maps . newHashMap ( ) ; 
 for ( int i = 0 ; i < 7 ; i + + )
