BLEU SCORE: 0.02931251013275449

TEST MSG: Reintroduce ObfuscationReflestionHelper closes # 5373
GENERATED MSG: Got the relauncher downloading and injecting library files

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / client / ClientHooks . java b / src / main / java / net / minecraftforge / fml / client / ClientHooks . java <nl> index f260125 . . c3a268a 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / client / ClientHooks . java <nl> + + + b / src / main / java / net / minecraftforge / fml / client / ClientHooks . java <nl> @ @ - 58 , 10 + 58 , 12 @ @ import net . minecraft . network . ServerStatusResponse ; <nl> import net . minecraft . resources . AbstractResourcePack ; <nl> import net . minecraft . resources . FallbackResourceManager ; <nl> import net . minecraft . resources . IResourcePack ; <nl> + import net . minecraft . resources . SimpleReloadableResourceManager ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraft . world . storage . WorldSummary ; <nl> import net . minecraftforge . fml . StartupQuery ; <nl> import net . minecraftforge . fml . client . gui . GuiAccessDenied ; <nl> + import net . minecraftforge . fml . common . ObfuscationReflectionHelper ; <nl> import net . minecraftforge . forgespi . language . IModInfo ; <nl> import net . minecraftforge . fml . packs . ModFileResourcePack ; <nl> import net . minecraftforge . registries . GameData ; <nl> @ @ - 233 , 7 + 235 , 7 @ @ public class ClientHooks <nl> / / We can ' t handle many unicode points in the splash renderer <nl> return DISALLOWED _ CHAR _ MATCHER . removeFrom ( net . minecraft . util . StringUtils . stripControlCodes ( message ) ) ; <nl> } <nl> - <nl> + <nl> private static SetMultimap < String , ResourceLocation > missingTextures = HashMultimap . create ( ) ; <nl> private static Set < String > badTextureDomains = Sets . newHashSet ( ) ; <nl> private static Table < String , String , Set < ResourceLocation > > brokenTextures = HashBasedTable . create ( ) ; <nl> @ @ - 265 , 7 + 267 , 7 @ @ public class ClientHooks <nl> Logger logger = LogManager . getLogger ( " FML . TEXTURE _ ERRORS " ) ; <nl> logger . error ( Strings . repeat ( " + = " , 25 ) ) ; <nl> logger . error ( " The following texture errors were found . " ) ; <nl> - Map < String , FallbackResourceManager > resManagers = null ; / / TODO ObfuscationReflectionHelper . getPrivateValue ( SimpleReloadableResourceManager . class , ( SimpleReloadableResourceManager ) Minecraft . getMinecraft ( ) . getResourceManager ( ) , " field _ 110548 " + " _ a " ) ; <nl> + Map < String , FallbackResourceManager > resManagers = ObfuscationReflectionHelper . getPrivateValue ( SimpleReloadableResourceManager . class , ( SimpleReloadableResourceManager ) Minecraft . getInstance ( ) . getResourceManager ( ) , " field _ 199014 " + " _ c " ) ; <nl> for ( String resourceDomain : badTextureDomains ) <nl> { <nl> Set < ResourceLocation > missing = missingTextures . get ( resourceDomain ) ; <nl> @ @ - 280 , 7 + 282 , 7 @ @ public class ClientHooks <nl> } <nl> else <nl> { <nl> - List < IResourcePack > resPacks = null ; / / ObfuscationReflectionHelper . getPrivateValue ( FallbackResourceManager . class , fallbackResourceManager , " field _ 110540 " + " _ a " ) ; <nl> + List < IResourcePack > resPacks = fallbackResourceManager . resourcePacks ; <nl> logger . error ( " domain { } has { } location { } : " , resourceDomain , resPacks . size ( ) , resPacks . size ( ) ! = 1 ? " s " : " " ) ; <nl> for ( IResourcePack resPack : resPacks ) <nl> { <nl> @ @ - 291 , 9 + 293 , 7 @ @ public class ClientHooks <nl> } <nl> else if ( resPack instanceof AbstractResourcePack ) <nl> { <nl> - AbstractResourcePack resourcePack = ( AbstractResourcePack ) resPack ; <nl> - File resPath = null ; / / TODO bfuscationReflectionHelper . getPrivateValue ( AbstractResourcePack . class , resourcePack , " field _ 110597 " + " _ b " ) ; <nl> - logger . error ( " resource pack at path { } " , resPath . getPath ( ) ) ; <nl> + logger . error ( " resource pack at path { } " , ( ( AbstractResourcePack ) resPack ) . file . getPath ( ) ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / src / main / java / net / minecraftforge / fml / client / TextureTracker . java b / src / main / java / net / minecraftforge / fml / client / TextureTracker . java <nl> index aa61010 . . 89dd3ce 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / client / TextureTracker . java <nl> + + + b / src / main / java / net / minecraftforge / fml / client / TextureTracker . java <nl> @ @ - 52 , 84 + 52 , 4 @ @ public class TextureTracker <nl> } <nl> badType . add ( resourceLocation ) ; <nl> } <nl> - <nl> - public static void logMissingTextureErrors ( ) <nl> - { <nl> - / * <nl> - if ( missingTextures . isEmpty ( ) & & brokenTextures . isEmpty ( ) ) <nl> - { <nl> - return ; <nl> - } <nl> - Logger logger = LogManager . getLogger ( " TEXTURE ERRORS " ) ; <nl> - logger . error ( Strings . repeat ( " + = " , 25 ) ) ; <nl> - logger . error ( " The following texture errors were found . " ) ; <nl> - Map < String , FallbackResourceManager > resManagers = ObfuscationReflectionHelper . getPrivateValue ( SimpleReloadableResourceManager . class , ( SimpleReloadableResourceManager ) Minecraft . getMinecraft ( ) . getResourceManager ( ) , " domainResourceManagers " , " field _ 110548 " + " _ a " ) ; <nl> - for ( String resourceDomain : badTextureDomains ) <nl> - { <nl> - Set < ResourceLocation > missing = missingTextures . get ( resourceDomain ) ; <nl> - logger . error ( Strings . repeat ( " = " , 50 ) ) ; <nl> - logger . error ( " DOMAIN { } " , resourceDomain ) ; <nl> - logger . error ( Strings . repeat ( " - " , 50 ) ) ; <nl> - logger . error ( " domain { } is missing { } texture { } " , resourceDomain , missing . size ( ) , missing . size ( ) ! = 1 ? " s " : " " ) ; <nl> - FallbackResourceManager fallbackResourceManager = resManagers . get ( resourceDomain ) ; <nl> - if ( fallbackResourceManager = = null ) <nl> - { <nl> - logger . error ( " domain { } is missing a resource manager - it is probably a side - effect of automatic texture processing " , resourceDomain ) ; <nl> - } <nl> - else <nl> - { <nl> - List < IResourcePack > resPacks = ObfuscationReflectionHelper . getPrivateValue ( FallbackResourceManager . class , fallbackResourceManager , " resourcePacks " , " field _ 110540 " + " _ a " ) ; <nl> - logger . error ( " domain { } has { } location { } : " , resourceDomain , resPacks . size ( ) , resPacks . size ( ) ! = 1 ? " s " : " " ) ; <nl> - for ( IResourcePack resPack : resPacks ) <nl> - { <nl> - if ( resPack instanceof FMLContainerHolder ) { <nl> - FMLContainerHolder containerHolder = ( FMLContainerHolder ) resPack ; <nl> - ModContainer fmlContainer = containerHolder . getFMLContainer ( ) ; <nl> - logger . error ( " mod { } resources at { } " , fmlContainer . getModId ( ) , fmlContainer . getSource ( ) . getPath ( ) ) ; <nl> - } <nl> - else if ( resPack instanceof AbstractResourcePack ) <nl> - { <nl> - AbstractResourcePack resourcePack = ( AbstractResourcePack ) resPack ; <nl> - File resPath = ObfuscationReflectionHelper . getPrivateValue ( AbstractResourcePack . class , resourcePack , " resourcePackFile " , " field _ 110597 " + " _ b " ) ; <nl> - logger . error ( " resource pack at path { } " , resPath . getPath ( ) ) ; <nl> - } <nl> - else <nl> - { <nl> - logger . error ( " unknown resourcepack type { } : { } " , resPack . getClass ( ) . getName ( ) , resPack . getPackName ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> - logger . error ( Strings . repeat ( " - " , 25 ) ) ; <nl> - if ( missingTextures . containsKey ( resourceDomain ) ) { <nl> - logger . error ( " The missing resources for domain { } are : " , resourceDomain ) ; <nl> - for ( ResourceLocation rl : missing ) { <nl> - logger . error ( " { } " , rl . getResourcePath ( ) ) ; <nl> - } <nl> - logger . error ( Strings . repeat ( " - " , 25 ) ) ; <nl> - } <nl> - if ( ! brokenTextures . containsRow ( resourceDomain ) ) <nl> - { <nl> - logger . error ( " No other errors exist for domain { } " , resourceDomain ) ; <nl> - } <nl> - else <nl> - { <nl> - logger . error ( " The following other errors were reported for domain { } : " , resourceDomain ) ; <nl> - Map < String , Set < ResourceLocation > > resourceErrs = brokenTextures . row ( resourceDomain ) ; <nl> - for ( String error : resourceErrs . keySet ( ) ) <nl> - { <nl> - logger . error ( Strings . repeat ( " - " , 25 ) ) ; <nl> - logger . error ( " Problem : { } " , error ) ; <nl> - for ( ResourceLocation rl : resourceErrs . get ( error ) ) <nl> - { <nl> - logger . error ( " { } " , rl . getResourcePath ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> - logger . error ( Strings . repeat ( " = " , 50 ) ) ; <nl> - } <nl> - logger . error ( Strings . repeat ( " + = " , 25 ) ) ; <nl> - * / <nl> - } <nl> - <nl> - <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / ObfuscationReflectionHelper . java b / src / main / java / net / minecraftforge / fml / common / ObfuscationReflectionHelper . java <nl> index a4730d3 . . b0773e4 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / ObfuscationReflectionHelper . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / ObfuscationReflectionHelper . java <nl> @ @ - 18 , 62 + 18 , 98 @ @ <nl> * / <nl> <nl> package net . minecraftforge . fml . common ; <nl> - / * TODO ReflectionHelper <nl> - import java . util . Arrays ; <nl> + import java . io . BufferedReader ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStreamReader ; <nl> + import java . lang . reflect . Constructor ; <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . Method ; <nl> + import java . net . URL ; <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + import java . util . StringJoiner ; <nl> <nl> - import net . minecraftforge . fml . common . asm . deobf . FMLDeobfuscatingRemapper ; <nl> - import net . minecraftforge . fml . relauncher . ReflectionHelper ; <nl> - import net . minecraftforge . fml . relauncher . ReflectionHelper . UnableToAccessFieldException ; <nl> - import net . minecraftforge . fml . relauncher . ReflectionHelper . UnableToFindFieldException ; <nl> + import javax . annotation . Nonnull ; <nl> + <nl> + import org . apache . logging . log4j . LogManager ; <nl> + import org . apache . logging . log4j . Logger ; <nl> + import org . apache . logging . log4j . Marker ; <nl> + import org . apache . logging . log4j . MarkerManager ; <nl> + <nl> + import com . google . common . base . Preconditions ; <nl> <nl> / * * <nl> * Some reflection helper code . <nl> + * This may not work properly in Java9 with their new more restrictive reflection management . <nl> + * As such , if issues are encountered , please report them and we can see what we can do to expand <nl> + * the compatibility . <nl> + * <nl> + * In other cases , AccessTransformers may be used . <nl> * <nl> - * @ author cpw <nl> + * All field names should be passed in as SRG names , and this will automatically resolve if MCP mappings are detected . <nl> * <nl> - * / <nl> + * / <nl> + @ SuppressWarnings ( { " serial " , " unchecked " } ) <nl> public class ObfuscationReflectionHelper <nl> { <nl> + private static final Logger LOGGER = LogManager . getLogger ( ) ; <nl> + private static final Marker REFLECTION = MarkerManager . getMarker ( " REFLECTION " ) ; <nl> + private static final Map < String , String > map = new HashMap < > ( ) ; <nl> + private static boolean loaded = false ; <nl> + <nl> + <nl> + <nl> + public static String [ ] remapNames ( String . . . names ) <nl> + { <nl> + loadMappings ( ) ; <nl> + if ( map . isEmpty ( ) ) <nl> + return names ; <nl> + <nl> + String [ ] mappedNames = new String [ names . length ] ; <nl> + int i = 0 ; <nl> + for ( String name : names ) <nl> + mappedNames [ i + + ] = map . getOrDefault ( name , name ) ; <nl> + return mappedNames ; <nl> + } <nl> + <nl> + public static String remapName ( String name ) <nl> + { <nl> + loadMappings ( ) ; <nl> + if ( map . isEmpty ( ) ) <nl> + return name ; <nl> + return map . getOrDefault ( name , name ) ; <nl> + } <nl> + <nl> public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , int fieldIndex ) <nl> { <nl> try <nl> { <nl> - return ReflectionHelper . getPrivateValue ( classToAccess , instance , fieldIndex ) ; <nl> + Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; <nl> + f . setAccessible ( true ) ; <nl> + return ( T ) f . get ( instance ) ; <nl> } <nl> - catch ( UnableToAccessFieldException e ) <nl> + catch ( Exception e ) <nl> { <nl> - LOGGER . error ( " There was a problem getting field index { } from { } " , classToAccess . getName ( ) , e ) ; <nl> - throw e ; <nl> + LOGGER . error ( REFLECTION , " There was a problem getting field index { } from { } " , classToAccess . getName ( ) , e ) ; <nl> + throw new UnableToAccessFieldException ( e ) ; <nl> } <nl> } <nl> <nl> - public static String [ ] remapFieldNames ( String className , String . . . fieldNames ) <nl> - { <nl> - String internalClassName = FMLDeobfuscatingRemapper . INSTANCE . unmap ( className . replace ( ' . ' , ' / ' ) ) ; <nl> - String [ ] mappedNames = new String [ fieldNames . length ] ; <nl> - int i = 0 ; <nl> - for ( String fName : fieldNames ) <nl> - { <nl> - mappedNames [ i + + ] = FMLDeobfuscatingRemapper . INSTANCE . mapFieldName ( internalClassName , fName , null ) ; <nl> - } <nl> - return mappedNames ; <nl> - } <nl> - <nl> - public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String . . . fieldNames ) <nl> + public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String fieldName ) <nl> { <nl> try <nl> { <nl> - return ReflectionHelper . getPrivateValue ( classToAccess , instance , remapFieldNames ( classToAccess . getName ( ) , fieldNames ) ) ; <nl> + return ( T ) findField ( classToAccess , remapName ( fieldName ) ) . get ( instance ) ; <nl> } <nl> catch ( UnableToFindFieldException e ) <nl> { <nl> - LOGGER . error ( " Unable to locate any field { } on type { } " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) , e ) ; <nl> + LOGGER . error ( " Unable to locate field { } ( { } ) on type { } " , fieldName , remapName ( fieldName ) , classToAccess . getName ( ) , e ) ; <nl> throw e ; <nl> } <nl> - catch ( UnableToAccessFieldException e ) <nl> + catch ( IllegalAccessException e ) <nl> { <nl> - LOGGER . error ( " Unable to access any field { } on type { } " , classToAccess . getName ( ) , e ) ; <nl> - throw e ; <nl> + LOGGER . error ( " Unable to access field { } ( { } ) on type { } " , fieldName , remapName ( fieldName ) , classToAccess . getName ( ) , e ) ; <nl> + throw new UnableToAccessFieldException ( e ) ; <nl> } <nl> } <nl> <nl> @ @ - 81 , 31 + 117 , 181 @ @ public class ObfuscationReflectionHelper <nl> { <nl> try <nl> { <nl> - ReflectionHelper . setPrivateValue ( classToAccess , instance , value , fieldIndex ) ; <nl> + Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; <nl> + f . setAccessible ( true ) ; <nl> + f . set ( instance , value ) ; <nl> } <nl> - catch ( UnableToAccessFieldException e ) <nl> + catch ( IllegalAccessException e ) <nl> { <nl> LOGGER . error ( " There was a problem setting field index { } on type { } " , classToAccess . getName ( ) , e ) ; <nl> - throw e ; <nl> + throw new UnableToAccessFieldException ( e ) ; <nl> } <nl> } <nl> <nl> - public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , String . . . fieldNames ) <nl> + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , String fieldName ) <nl> { <nl> try <nl> { <nl> - ReflectionHelper . setPrivateValue ( classToAccess , instance , value , remapFieldNames ( classToAccess . getName ( ) , fieldNames ) ) ; <nl> + findField ( classToAccess , remapName ( fieldName ) ) . set ( instance , value ) ; <nl> } <nl> catch ( UnableToFindFieldException e ) <nl> { <nl> LOGGER . error ( " Unable to locate any field { } on type { } " , classToAccess . getName ( ) , e ) ; <nl> throw e ; <nl> } <nl> - catch ( UnableToAccessFieldException e ) <nl> + catch ( IllegalAccessException e ) <nl> { <nl> LOGGER . error ( " Unable to set any field { } on type { } " , classToAccess . getName ( ) , e ) ; <nl> - throw e ; <nl> + throw new UnableToAccessFieldException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Finds a method with the specified name and parameters in the given class and makes it accessible . <nl> + * Note : for performance , store the returned value and avoid calling this repeatedly . <nl> + * < p > <nl> + * Throws an exception if the method is not found . <nl> + * <nl> + * @ param clazz The class to find the method on . <nl> + * @ param methodName The name of the method to find ( used in developer environments , i . e . " getWorldTime " ) . <nl> + * @ param methodObfName The obfuscated name of the method to find ( used in obfuscated environments , i . e . " func _ 72820 _ D " ) . <nl> + * If the name you are looking for is on a class that is never obfuscated , this should be null . <nl> + * @ param parameterTypes The parameter types of the method to find . <nl> + * @ return The method with the specified name and parameters in the given class . <nl> + * / <nl> + @ Nonnull <nl> + public static Method findMethod ( @ Nonnull Class < ? > clazz , @ Nonnull String methodName , Class < ? > . . . parameterTypes ) <nl> + { <nl> + Preconditions . checkNotNull ( clazz ) ; <nl> + Preconditions . checkNotNull ( methodName ) ; <nl> + Preconditions . checkArgument ( methodName . isEmpty ( ) , " Method name cannot be empty " ) ; <nl> + <nl> + try <nl> + { <nl> + Method m = clazz . getDeclaredMethod ( remapName ( methodName ) , parameterTypes ) ; <nl> + m . setAccessible ( true ) ; <nl> + return m ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new UnableToFindMethodException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Finds a constructor in the specified class that has matching parameter types . <nl> + * <nl> + * @ param klass The class to find the constructor in <nl> + * @ param parameterTypes The parameter types of the constructor . <nl> + * @ param < T > The type <nl> + * @ return The constructor <nl> + * @ throws NullPointerException if { @ code klass } is null <nl> + * @ throws NullPointerException if { @ code parameterTypes } is null <nl> + * @ throws UnknownConstructorException if the constructor could not be found <nl> + * / <nl> + @ Nonnull <nl> + public static < T > Constructor < T > findConstructor ( @ Nonnull final Class < T > klass , @ Nonnull final Class < ? > . . . parameterTypes ) <nl> + { <nl> + Preconditions . checkNotNull ( klass , " class " ) ; <nl> + Preconditions . checkNotNull ( parameterTypes , " parameter types " ) ; <nl> + <nl> + try <nl> + { <nl> + Constructor < T > constructor = klass . getDeclaredConstructor ( parameterTypes ) ; <nl> + constructor . setAccessible ( true ) ; <nl> + return constructor ; <nl> + } <nl> + catch ( final NoSuchMethodException e ) <nl> + { <nl> + final StringBuilder desc = new StringBuilder ( ) ; <nl> + desc . append ( klass . getSimpleName ( ) ) ; <nl> + <nl> + StringJoiner joiner = new StringJoiner ( " , " , " ( " , " ) " ) ; <nl> + for ( Class < ? > type : parameterTypes ) <nl> + { <nl> + joiner . add ( type . getSimpleName ( ) ) ; <nl> + } <nl> + desc . append ( joiner ) ; <nl> + <nl> + throw new UnknownConstructorException ( " Could not find constructor ' " + desc . toString ( ) + " ' in " + klass ) ; <nl> + } <nl> + } <nl> + <nl> + private static Field findField ( Class < ? > clazz , String name ) <nl> + { <nl> + try <nl> + { <nl> + Field f = clazz . getDeclaredField ( name ) ; <nl> + f . setAccessible ( true ) ; <nl> + return f ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new UnableToFindFieldException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + private static void loadMappings ( ) <nl> + { <nl> + if ( loaded ) <nl> + return ; <nl> + <nl> + synchronized ( map ) / / Just in case ? <nl> + { <nl> + if ( loaded ) / / Incase something else loaded while we were here , jump out <nl> + return ; <nl> + for ( String file : new String [ ] { " fields . csv " , " methods . csv " } ) <nl> + { <nl> + URL path = ClassLoader . getSystemResource ( file ) ; / / We EXPLICITLY go throught the SystemClassLoader here because this is dev - time only . And will be on the root classpath . <nl> + if ( path = = null ) <nl> + continue ; <nl> + <nl> + int count = map . size ( ) ; <nl> + LOGGER . info ( REFLECTION , " Loading Mappings : { } " , path ) ; <nl> + try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( path . openStream ( ) ) ) ) <nl> + { <nl> + reader . lines ( ) . skip ( 1 ) . map ( e - > e . split ( " , " ) ) . forEach ( e - > map . put ( e [ 0 ] , e [ 1 ] ) ) ; <nl> + } <nl> + catch ( IOException e1 ) <nl> + { <nl> + LOGGER . error ( REFLECTION , " Error reading mappings " , e1 ) ; <nl> + } <nl> + LOGGER . info ( REFLECTION , " Loaded { } entries " , map . size ( ) - count ) ; <nl> + } <nl> + loaded = true ; <nl> + } <nl> + } <nl> + <nl> + / / Add SRG names to these exception ? <nl> + public static class UnableToAccessFieldException extends RuntimeException <nl> + { <nl> + private UnableToAccessFieldException ( Exception e ) <nl> + { <nl> + super ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public static class UnableToFindFieldException extends RuntimeException <nl> + { <nl> + private UnableToFindFieldException ( Exception e ) <nl> + { <nl> + super ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public static class UnableToFindMethodException extends RuntimeException <nl> + { <nl> + public UnableToFindMethodException ( Throwable failed ) <nl> + { <nl> + super ( failed ) ; <nl> + } <nl> + } <nl> + <nl> + public static class UnknownConstructorException extends RuntimeException <nl> + { <nl> + public UnknownConstructorException ( final String message ) <nl> + { <nl> + super ( message ) ; <nl> } <nl> } <nl> } <nl> - * / <nl> diff - - git a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> index a88cbfa . . 54ab813 100644 <nl> - - - a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import java . util . Map . Entry ; <nl> <nl> import javax . annotation . Nonnull ; <nl> import net . minecraftforge . fml . ModThreadContext ; <nl> + import net . minecraftforge . fml . common . ObfuscationReflectionHelper ; <nl> import net . minecraftforge . fml . loading . AdvancedLogMessageAdapter ; <nl> import org . apache . commons . lang3 . Validate ; <nl> <nl> @ @ - 427 , 7 + 428 , 7 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> { <nl> try <nl> { <nl> - / / ReflectionHelper . findMethod ( BitSet . class , " trimToSize " , null ) . invoke ( this . availabilityMap ) ; <nl> + ObfuscationReflectionHelper . findMethod ( BitSet . class , " trimToSize " ) . invoke ( this . availabilityMap ) ; <nl> } <nl> catch ( Exception e ) <nl> {
NEAREST DIFF (one line): diff - - git a / fml / build . xml b / fml / build . xml <nl> index 587bb5a . . eff4015 100644 <nl> - - - a / fml / build . xml <nl> + + + b / fml / build . xml <nl> @ @ - 266 , 14 + 266 , 17 @ @ <nl> < target name = " repatch " depends = " buildenvsetup " > <nl> < echo > Moving old patched sources at $ { mcp . home } / src - work out of the way < / echo > <nl> < move todir = " $ { mcp . home } / src - work $ { timestamp } " failonerror = " false " verbose = " true " > <nl> - < fileset dir = " $ { mcp . home } / src - work " / > <nl> + < fileset dir = " $ { patch . mcp . srcdir } " / > <nl> < / move > <nl> < delete dir = " $ { mcp . srcdir } " / > <nl> < copy todir = " $ { mcp . srcdir } " > <nl> - < fileset dir = " $ { mcp . home } / src - base " / > <nl> + < fileset dir = " $ { clean . mcp . srcdir } " / > <nl> < / copy > <nl> + <nl> + < antcall target = " cleanargo " / > <nl> + <nl> < antcall target = " patch " / > <nl> - < copy todir = " $ { mcp . home } / src - work " > <nl> + < copy todir = " $ { patch . mcp . srcdir } " > <nl> < fileset dir = " $ { mcp . srcdir } " / > <nl> < / copy > <nl> < / target > <nl> diff - - git a / fml / client / cpw / mods / fml / client / FMLClientHandler . java b / fml / client / cpw / mods / fml / client / FMLClientHandler . java <nl> index 4ce2275 . . eea61f0 100644 <nl> - - - a / fml / client / cpw / mods / fml / client / FMLClientHandler . java <nl> + + + b / fml / client / cpw / mods / fml / client / FMLClientHandler . java <nl> @ @ - 88 , 13 + 88 , 13 @ @ import cpw . mods . fml . common . Loader ; <nl> import cpw . mods . fml . common . ModContainer ; <nl> import cpw . mods . fml . common . ModMetadata ; <nl> import cpw . mods . fml . common . ProxyInjector ; <nl> - import cpw . mods . fml . common . ReflectionHelper ; <nl> import cpw . mods . fml . common . Side ; <nl> import cpw . mods . fml . common . TickType ; <nl> import cpw . mods . fml . common . modloader . ModLoaderHelper ; <nl> import cpw . mods . fml . common . modloader . ModLoaderModContainer ; <nl> import cpw . mods . fml . common . modloader . ModProperty ; <nl> import cpw . mods . fml . common . registry . FMLRegistry ; <nl> + import cpw . mods . fml . common . ReflectionHelper ; <nl> <nl> <nl> / * * <nl> diff - - git a / fml / client / net / minecraft / src / ModLoader . java b / fml / client / net / minecraft / src / ModLoader . java <nl> index 91be235 . . 502caeb 100644 <nl> - - - a / fml / client / net / minecraft / src / ModLoader . java <nl> + + + b / fml / client / net / minecraft / src / ModLoader . java <nl> @ @ - 26 , 10 + 26 , 10 @ @ import cpw . mods . fml . client . FMLClientHandler ; <nl> import cpw . mods . fml . client . SpriteHelper ; <nl> import cpw . mods . fml . common . FMLCommonHandler ; <nl> import cpw . mods . fml . common . Loader ; <nl> - import cpw . mods . fml . common . ReflectionHelper ; <nl> import cpw . mods . fml . common . modloader . ModLoaderHelper ; <nl> import cpw . mods . fml . common . modloader . ModLoaderModContainer ; <nl> import cpw . mods . fml . common . registry . FMLRegistry ; <nl> + import cpw . mods . fml . common . ReflectionHelper ; <nl> <nl> public class ModLoader <nl> { <nl> @ @ - 733 , 7 + 733 , 7 @ @ public class ModLoader <nl> * / <nl> public static < T , E > void setPrivateValue ( Class < ? super T > instanceclass , T instance , int fieldindex , E value ) <nl> { <nl> - ReflectionHelper . setPrivateValue ( instanceclass , instance , fieldindex , value ) ; <nl> + ReflectionHelper . setPrivateValue ( instanceclass , instance , value , fieldindex ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 747 , 7 + 747 , 7 @ @ public class ModLoader <nl> * / <nl> public static < T , E > void setPrivateValue ( Class < ? super T > instanceclass , T instance , String field , E value ) <nl> { <nl> - ReflectionHelper . setPrivateValue ( instanceclass , instance , field , value ) ; <nl> + ReflectionHelper . setPrivateValue ( instanceclass , instance , value , field ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / fml / common / cpw / mods / fml / common / ReflectionHelper . java b / fml / common / cpw / mods / fml / common / ReflectionHelper . java <nl> index 30bc523 . . 251da11 100644 <nl> - - - a / fml / common / cpw / mods / fml / common / ReflectionHelper . java <nl> + + + b / fml / common / cpw / mods / fml / common / ReflectionHelper . java <nl> @ @ - 14 , 9 + 14 , 15 @ @ package cpw . mods . fml . common ; <nl> <nl> import java . lang . reflect . Field ; <nl> import java . lang . reflect . Method ; <nl> + import java . util . Arrays ; <nl> + import java . util . logging . Level ; <nl> + <nl> + import cpw . mods . fml . common . FMLCommonHandler ; <nl> + import cpw . mods . fml . relauncher . ReflectionHelper . UnableToAccessFieldException ; <nl> + import cpw . mods . fml . relauncher . ReflectionHelper . UnableToFindFieldException ; <nl> / * * <nl> * Some reflection helper code . <nl> - * <nl> + * <nl> * @ author cpw <nl> * <nl> * / <nl> @ @ - 29 , 73 + 35 , 79 @ @ public class ReflectionHelper <nl> { <nl> try <nl> { <nl> - Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; <nl> - f . setAccessible ( true ) ; <nl> - return ( T ) f . get ( instance ) ; <nl> + return cpw . mods . fml . relauncher . ReflectionHelper . getPrivateValue ( classToAccess , instance , fieldIndex ) ; <nl> } <nl> - catch ( Exception e ) <nl> + catch ( UnableToAccessFieldException e ) <nl> { <nl> - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . severe ( String . format ( " There was a problem getting field % d from % s " , fieldIndex , classToAccess . getName ( ) ) ) ; <nl> - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . throwing ( " ReflectionHelper " , " getPrivateValue " , e ) ; <nl> - throw new RuntimeException ( e ) ; <nl> + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " There was a problem getting field index % d from % s " , fieldIndex , classToAccess . getName ( ) ) , e ) ; <nl> + throw e ; <nl> } <nl> } <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> - public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String fieldName ) <nl> + public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String . . . fieldNames ) <nl> { <nl> try <nl> { <nl> - Field f = classToAccess . getDeclaredField ( fieldName ) ; <nl> - f . setAccessible ( true ) ; <nl> - return ( T ) f . get ( instance ) ; <nl> + return cpw . mods . fml . relauncher . ReflectionHelper . getPrivateValue ( classToAccess , instance , fieldNames ) ; <nl> + } <nl> + catch ( UnableToFindFieldException e ) <nl> + { <nl> + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " Unable to locate any field % s on type % s " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) ) , e ) ; <nl> + throw e ; <nl> } <nl> - catch ( Exception e ) <nl> + catch ( UnableToAccessFieldException e ) <nl> { <nl> - if ( ( fieldName . length ( ) > 3 & & ! obfuscation ) | | ( fieldName . length ( ) < = 3 & & obfuscation ) ) { <nl> - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . severe ( String . format ( " There was a problem getting field % s from % s " , fieldName , classToAccess . getName ( ) ) ) ; <nl> - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . throwing ( " ReflectionHelper " , " getPrivateValue " , e ) ; <nl> - } <nl> - throw new RuntimeException ( e ) ; <nl> + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " Unable to access any field % s on type % s " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) ) , e ) ; <nl> + throw e ; <nl> } <nl> } <nl> <nl> + @ Deprecated <nl> public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , int fieldIndex , E value ) <nl> { <nl> + setPrivateValue ( classToAccess , instance , value , fieldIndex ) ; <nl> + } <nl> + <nl> + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , int fieldIndex ) <nl> + { <nl> try <nl> { <nl> - Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; <nl> - f . setAccessible ( true ) ; <nl> - f . set ( instance , value ) ; <nl> + cpw . mods . fml . relauncher . ReflectionHelper . setPrivateValue ( classToAccess , instance , value , fieldIndex ) ; <nl> } <nl> - catch ( Exception e ) <nl> + catch ( UnableToAccessFieldException e ) <nl> { <nl> - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . severe ( String . format ( " There was a problem setting field % d from % s " , fieldIndex , classToAccess . getName ( ) ) ) ; <nl> - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . throwing ( " ReflectionHelper " , " getPrivateValue " , e ) ; <nl> - throw new RuntimeException ( e ) ; <nl> + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " There was a problem setting field index % d on type % s " , fieldIndex , classToAccess . getName ( ) ) ) ; <nl> + throw e ; <nl> } <nl> } <nl> <nl> + @ Deprecated <nl> public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , String fieldName , E value ) <nl> { <nl> + setPrivateValue ( classToAccess , instance , value , fieldName ) ; <nl> + } <nl> + <nl> + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , String . . . fieldNames ) <nl> + { <nl> try <nl> { <nl> - Field f = classToAccess . getDeclaredField ( fieldName ) ; <nl> - f . setAccessible ( true ) ; <nl> - f . set ( instance , value ) ; <nl> + cpw . mods . fml . relauncher . ReflectionHelper . setPrivateValue ( classToAccess , instance , value , fieldNames ) ; <nl> + } <nl> + catch ( UnableToFindFieldException e ) <nl> + { <nl> + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " Unable to locate any field % s on type % s " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) ) , e ) ; <nl> + throw e ; <nl> } <nl> - catch ( Exception e ) <nl> + catch ( UnableToAccessFieldException e ) <nl> { <nl> - if ( ( fieldName . length ( ) > 3 & & ! obfuscation ) | | ( fieldName . length ( ) < = 3 & & obfuscation ) ) { <nl> - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . severe ( String . format ( " There was a problem setting field % s from % s " , fieldName , classToAccess . getName ( ) ) ) ; <nl> - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . throwing ( " ReflectionHelper " , " getPrivateValue " , e ) ; <nl> - } <nl> - throw new RuntimeException ( e ) ; <nl> + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " Unable to set any field % s on type % s " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) ) , e ) ; <nl> + throw e ; <nl> } <nl> } <nl> <nl> / * * <nl> - * <nl> + * <nl> * / <nl> public static void detectObfuscation ( Class < ? > clazz ) <nl> { <nl> diff - - git a / fml / common / cpw / mods / fml / relauncher / FMLEmbeddingRelauncher . java b / fml / common / cpw / mods / fml / relauncher / FMLEmbeddingRelauncher . java <nl> index d924f81 . . f905984 100644 <nl> - - - a / fml / common / cpw / mods / fml / relauncher / FMLEmbeddingRelauncher . java <nl> + + + b / fml / common / cpw / mods / fml / relauncher / FMLEmbeddingRelauncher . java <nl> @ @ - 1 , 17 + 1 , 18 @ @ <nl> package cpw . mods . fml . relauncher ; <nl> <nl> + import java . io . File ; <nl> import java . lang . reflect . Field ; <nl> import java . lang . reflect . InvocationTargetException ; <nl> + import java . lang . reflect . Method ; <nl> import java . net . URLClassLoader ; <nl> + import java . util . Arrays ; <nl> <nl> - import net . minecraft . client . Minecraft ; <nl> import net . minecraft . src . WorldSettings ; <nl> <nl> public class FMLEmbeddingRelauncher <nl> { <nl> private static FMLEmbeddingRelauncher INSTANCE ; <nl> private RelaunchClassLoader clientLoader ; <nl> - private RelaunchClassLoader serverLoader ; <nl> <nl> public static void relaunch ( ArgsWrapper wrap ) <nl> { <nl> @ @ - 24 , 25 + 25 , 36 @ @ public class FMLEmbeddingRelauncher <nl> URLClassLoader ucl = ( URLClassLoader ) getClass ( ) . getClassLoader ( ) ; <nl> <nl> clientLoader = new RelaunchClassLoader ( ucl . getURLs ( ) ) ; <nl> - serverLoader = new RelaunchClassLoader ( ucl . getURLs ( ) ) ; <nl> } <nl> <nl> private void relaunchClient ( ArgsWrapper wrap ) <nl> { <nl> + Class < ? super Object > mcMaster = ReflectionHelper . getClass ( getClass ( ) . getClassLoader ( ) , " net . minecraft . client . Minecraft " ) ; <nl> + / / We force minecraft to setup it ' s homedir very early on so we can inject stuff into it <nl> + Method setupHome = ReflectionHelper . findMethod ( mcMaster , null , new String [ ] { " func _ 6240 _ b " , " getMinecraftDir " , " b " } ) ; <nl> try <nl> { <nl> - Class < ? > original = Class . forName ( " net . minecraft . client . Minecraft " , false , getClass ( ) . getClassLoader ( ) ) ; <nl> - Field origDir = original . getDeclaredField ( " field _ 6275 _ Z " ) ; <nl> - origDir . setAccessible ( true ) ; <nl> - Class client = Class . forName ( " net . minecraft . client . Minecraft " , false , clientLoader ) ; <nl> - Field homeDir = client . getDeclaredField ( " field _ 6275 _ Z " ) ; <nl> - homeDir . setAccessible ( true ) ; <nl> - homeDir . set ( null , origDir . get ( null ) ) ; <nl> - client . getMethod ( " fmlReentry " , ArgsWrapper . class ) . invoke ( null , wrap ) ; <nl> + setupHome . invoke ( null ) ; <nl> } <nl> catch ( Exception e ) <nl> { <nl> - e . printStackTrace ( ) ; <nl> + / / Hmmm <nl> + } <nl> + File minecraftHome = ReflectionHelper . getPrivateValue ( mcMaster , null , " field _ 6275 _ Z " , " ap " , " minecraftDir " ) ; <nl> + <nl> + RelaunchLibraryManager . handleLaunch ( minecraftHome , clientLoader ) ; <nl> + <nl> + / / Now we re - inject the home into the " new " minecraft under our control <nl> + Class < ? super Object > client = ReflectionHelper . getClass ( clientLoader , " net . minecraft . client . Minecraft " ) ; <nl> + ReflectionHelper . setPrivateValue ( client , null , minecraftHome , " field _ 6275 _ Z " , " ap " , " minecraftDir " ) ; <nl> + <nl> + try <nl> + { <nl> + ReflectionHelper . findMethod ( client , null , new String [ ] { " fmlReentry " } , ArgsWrapper . class ) . invoke ( null , wrap ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + / / Hmmm <nl> } <nl> } <nl> } <nl> diff - - git a / fml / common / cpw / mods / fml / relauncher / ReflectionHelper . java b / fml / common / cpw / mods / fml / relauncher / ReflectionHelper . java <nl> new file mode 100644 <nl> index 0000000 . . f441197 <nl> - - - / dev / null <nl> + + + b / fml / common / cpw / mods / fml / relauncher / ReflectionHelper . java <nl> @ @ - 0 , 0 + 1 , 183 @ @ <nl> + / * <nl> + * The FML Forge Mod Loader suite . Copyright ( C ) 2012 cpw <nl> + * <nl> + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free <nl> + * Software Foundation ; either version 2 . 1 of the License , or any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR <nl> + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 <nl> + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package cpw . mods . fml . relauncher ; <nl> + <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . Method ; <nl> + <nl> + import cpw . mods . fml . common . FMLCommonHandler ; <nl> + / * * <nl> + * Some reflection helper code . <nl> + * <nl> + * @ author cpw <nl> + * <nl> + * / <nl> + public class ReflectionHelper <nl> + { <nl> + public static class UnableToFindMethodException extends RuntimeException <nl> + { <nl> + private String [ ] methodNames ; <nl> + <nl> + public UnableToFindMethodException ( String [ ] methodNames , Exception failed ) <nl> + { <nl> + super ( failed ) ; <nl> + this . methodNames = methodNames ; <nl> + } <nl> + <nl> + } <nl> + <nl> + public static class UnableToFindClassException extends RuntimeException <nl> + { <nl> + private String [ ] classNames ; <nl> + <nl> + public UnableToFindClassException ( String [ ] classNames , Exception err ) <nl> + { <nl> + super ( err ) ; <nl> + this . classNames = classNames ; <nl> + } <nl> + <nl> + } <nl> + <nl> + public static class UnableToAccessFieldException extends RuntimeException <nl> + { <nl> + <nl> + private String [ ] fieldNameList ; <nl> + <nl> + public UnableToAccessFieldException ( String [ ] fieldNames , Exception e ) <nl> + { <nl> + super ( e ) ; <nl> + this . fieldNameList = fieldNames ; <nl> + } <nl> + } <nl> + <nl> + public static class UnableToFindFieldException extends RuntimeException <nl> + { <nl> + private String [ ] fieldNameList ; <nl> + public UnableToFindFieldException ( String [ ] fieldNameList , Exception e ) <nl> + { <nl> + super ( e ) ; <nl> + this . fieldNameList = fieldNameList ; <nl> + } <nl> + } <nl> + <nl> + public static Field findField ( Class < ? > clazz , String . . . fieldNames ) <nl> + { <nl> + Exception failed = null ; <nl> + for ( String fieldName : fieldNames ) <nl> + { <nl> + try <nl> + { <nl> + Field f = clazz . getDeclaredField ( fieldName ) ; <nl> + f . setAccessible ( true ) ; <nl> + return f ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + failed = e ; <nl> + } <nl> + } <nl> + throw new UnableToFindFieldException ( fieldNames , failed ) ; <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , int fieldIndex ) <nl> + { <nl> + try <nl> + { <nl> + Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; <nl> + f . setAccessible ( true ) ; <nl> + return ( T ) f . get ( instance ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new UnableToAccessFieldException ( new String [ 0 ] , e ) ; <nl> + } <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String . . . fieldNames ) <nl> + { <nl> + try <nl> + { <nl> + return ( T ) findField ( classToAccess , fieldNames ) . get ( instance ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new UnableToAccessFieldException ( fieldNames , e ) ; <nl> + } <nl> + } <nl> + <nl> + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , int fieldIndex ) <nl> + { <nl> + try <nl> + { <nl> + Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; <nl> + f . setAccessible ( true ) ; <nl> + f . set ( instance , value ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new UnableToAccessFieldException ( new String [ 0 ] , e ) ; <nl> + } <nl> + } <nl> + <nl> + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , String . . . fieldNames ) <nl> + { <nl> + try <nl> + { <nl> + findField ( classToAccess , fieldNames ) . set ( instance , value ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new UnableToAccessFieldException ( fieldNames , e ) ; <nl> + } <nl> + } <nl> + <nl> + public static Class < ? super Object > getClass ( ClassLoader loader , String . . . classNames ) <nl> + { <nl> + Exception err = null ; <nl> + for ( String className : classNames ) <nl> + { <nl> + try <nl> + { <nl> + return ( Class < ? super Object > ) Class . forName ( className , false , loader ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + err = e ; <nl> + } <nl> + } <nl> + <nl> + throw new UnableToFindClassException ( classNames , err ) ; <nl> + } <nl> + <nl> + <nl> + public static < E > Method findMethod ( Class < ? super E > clazz , E instance , String [ ] methodNames , Class < ? > . . . methodTypes ) <nl> + { <nl> + Exception failed = null ; <nl> + for ( String methodName : methodNames ) <nl> + { <nl> + try <nl> + { <nl> + Method m = clazz . getDeclaredMethod ( methodName , methodTypes ) ; <nl> + m . setAccessible ( true ) ; <nl> + return m ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + failed = e ; <nl> + } <nl> + } <nl> + throw new UnableToFindMethodException ( methodNames , failed ) ; <nl> + } <nl> + } <nl> diff - - git a / fml / common / cpw / mods / fml / relauncher / RelaunchClassLoader . java b / fml / common / cpw / mods / fml / relauncher / RelaunchClassLoader . java <nl> index 5a4e720 . . 78546e9 100644 <nl> - - - a / fml / common / cpw / mods / fml / relauncher / RelaunchClassLoader . java <nl> + + + b / fml / common / cpw / mods / fml / relauncher / RelaunchClassLoader . java <nl> @ @ - 28 , 4 + 28 , 11 @ @ public class RelaunchClassLoader extends URLClassLoader <nl> return super . loadClass ( name ) ; <nl> } <nl> } <nl> + <nl> + @ Override <nl> + protected void addURL ( URL url ) <nl> + { <nl> + super . addURL ( url ) ; <nl> + System . out . println ( Arrays . toString ( getURLs ( ) ) ) ; <nl> + } <nl> } <nl> diff - - git a / fml / common / cpw / mods / fml / relauncher / RelaunchLibraryManager . java b / fml / common / cpw / mods / fml / relauncher / RelaunchLibraryManager . java <nl> new file mode 100644 <nl> index 0000000 . . 383e368 <nl> - - - / dev / null <nl> + + + b / fml / common / cpw / mods / fml / relauncher / RelaunchLibraryManager . java <nl> @ @ - 0 , 0 + 1 , 137 @ @ <nl> + package cpw . mods . fml . relauncher ; <nl> + <nl> + import java . awt . HeadlessException ; <nl> + import java . io . File ; <nl> + import java . io . FileInputStream ; <nl> + import java . io . FileNotFoundException ; <nl> + import java . io . FileOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStream ; <nl> + import java . math . BigInteger ; <nl> + import java . net . MalformedURLException ; <nl> + import java . net . URI ; <nl> + import java . net . URL ; <nl> + import java . net . URLConnection ; <nl> + import java . nio . MappedByteBuffer ; <nl> + import java . nio . channels . Channels ; <nl> + import java . nio . channels . FileChannel ; <nl> + import java . nio . channels . ReadableByteChannel ; <nl> + import java . nio . channels . FileChannel . MapMode ; <nl> + import java . security . MessageDigest ; <nl> + import java . security . NoSuchAlgorithmException ; <nl> + <nl> + import javax . swing . JOptionPane ; <nl> + <nl> + public class RelaunchLibraryManager <nl> + { <nl> + private static String [ ] libraries = { " argo - 2 . 25 . jar " , " guava - 12 . 0 . jar " , " asm - all - 4 . 0 . jar " } ; <nl> + private static String [ ] checksums = { " bb672829fde76cb163004752b86b0484bd0a7f4b " , " 5bc66dd95b79db1e437eb08adba124a3e4088dc0 " , " 98308890597acb64047f7e896638e0d98753ae82 " } ; <nl> + private static final String HEXES = " 0123456789abcdef " ; <nl> + public static void handleLaunch ( File mcDir , RelaunchClassLoader actualClassLoader ) <nl> + { <nl> + File libDir = new File ( mcDir , " lib " ) ; <nl> + try <nl> + { <nl> + libDir = libDir . getCanonicalFile ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( String . format ( " Unable to canonicalize the lib dir at % s " , mcDir . getName ( ) ) , e ) ; <nl> + } <nl> + if ( ! libDir . exists ( ) ) <nl> + { <nl> + libDir . mkdir ( ) ; <nl> + } <nl> + else if ( libDir . exists ( ) & & ! libDir . isDirectory ( ) ) <nl> + { <nl> + throw new RuntimeException ( String . format ( " Found a lib file in % s that ' s not a directory " , mcDir . getName ( ) ) ) ; <nl> + } <nl> + <nl> + for ( int i = 0 ; i < libraries . length ; i + + ) <nl> + { <nl> + String libName = libraries [ i ] ; <nl> + String checksum = checksums [ i ] ; <nl> + File libFile = new File ( libDir , libName ) ; <nl> + if ( ! libFile . exists ( ) ) <nl> + { <nl> + downloadFile ( libFile ) ; <nl> + } <nl> + <nl> + if ( libFile . exists ( ) & & ! libFile . isFile ( ) ) <nl> + { <nl> + throw new RuntimeException ( String . format ( " Found a file % s that is not a normal file " , libName ) ) ; <nl> + } <nl> + <nl> + String fileChecksum = generateChecksum ( libFile ) ; <nl> + if ( ! checksum . equals ( fileChecksum ) ) <nl> + { <nl> + throw new RuntimeException ( String . format ( " The file % s has an invalid checksum % s ( expecting % s ) " , libName , fileChecksum , checksum ) ) ; <nl> + } <nl> + try <nl> + { <nl> + actualClassLoader . addURL ( libFile . toURI ( ) . toURL ( ) ) ; <nl> + } <nl> + catch ( MalformedURLException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + <nl> + } <nl> + <nl> + } <nl> + <nl> + private static String generateChecksum ( File file ) <nl> + { <nl> + try <nl> + { <nl> + FileInputStream fis = new FileInputStream ( file ) ; <nl> + FileChannel chan = fis . getChannel ( ) ; <nl> + MessageDigest digest = MessageDigest . getInstance ( " SHA - 1 " ) ; <nl> + MappedByteBuffer mappedFile = chan . map ( MapMode . READ _ ONLY , 0 , file . length ( ) ) ; <nl> + digest . update ( mappedFile ) ; <nl> + chan . close ( ) ; <nl> + fis . close ( ) ; <nl> + byte [ ] chksum = digest . digest ( ) ; <nl> + final StringBuilder hex = new StringBuilder ( 2 * chksum . length ) ; <nl> + for ( final byte b : chksum ) { <nl> + hex . append ( HEXES . charAt ( ( b & 0xF0 ) > > 4 ) ) <nl> + . append ( HEXES . charAt ( ( b & 0x0F ) ) ) ; <nl> + } <nl> + return hex . toString ( ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + return null ; <nl> + } <nl> + } <nl> + private static void downloadFile ( File libFile ) <nl> + { <nl> + / / try <nl> + / / { <nl> + / / JOptionPane . showMessageDialog ( null , String . format ( " Downloading required FML library % s from github . com " , libName ) ) ; <nl> + / / } <nl> + / / catch ( HeadlessException he ) <nl> + / / { <nl> + / / / / Ignore <nl> + / / } <nl> + try <nl> + { <nl> + URL libDownload = new URL ( String . format ( " http : / / cloud . github . com / downloads / cpw / FML / % s " , libFile . getName ( ) ) ) ; <nl> + System . out . printf ( " Downloading % s . . " , libDownload . toString ( ) ) ; <nl> + InputStream urlConn = libDownload . openStream ( ) ; <nl> + ReadableByteChannel urlChannel = Channels . newChannel ( urlConn ) ; <nl> + FileOutputStream libFileStream = new FileOutputStream ( libFile ) ; <nl> + FileChannel libFileChannel = libFileStream . getChannel ( ) ; <nl> + libFileChannel . transferFrom ( urlChannel , 0 , 1 < < 24 ) ; <nl> + libFileChannel . close ( ) ; <nl> + libFileStream . close ( ) ; <nl> + urlChannel . close ( ) ; <nl> + urlConn . close ( ) ; <nl> + System . out . println ( " download successful " ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + <nl> + } <nl> + } <nl> + } <nl> diff - - git a / fml / eclipse / Clean - Client / . classpath b / fml / eclipse / Clean - Client / . classpath <nl> index 6bf817e . . 2660e24 100644 <nl> - - - a / fml / eclipse / Clean - Client / . classpath <nl> + + + b / fml / eclipse / Clean - Client / . classpath <nl> @ @ - 18 , 5 + 18 , 6 @ @ <nl> 	 	 < / attributes > <nl> 	 < / classpathentry > <nl> 	 < classpathentry kind = " lib " path = " jars / bin / minecraft . jar " / > <nl> + 	 < classpathentry kind = " lib " path = " / home / cpw / projects / FML / mcsnapshot / lib / argo - 2 . 25 . jar " / > <nl> 	 < classpathentry kind = " output " path = " bin " / > <nl> < / classpath > <nl> diff - - git a / fml / eclipse / FML - Client / . classpath b / fml / eclipse / FML - Client / . classpath <nl> index d750167 . . ea960b8 100644 <nl> - - - a / fml / eclipse / FML - Client / . classpath <nl> + + + b / fml / eclipse / FML - Client / . classpath <nl> @ @ - 1 , 7 + 1 , 7 @ @ <nl> < ? xml version = " 1 . 0 " encoding = " UTF - 8 " ? > <nl> < classpath > <nl> - 	 < classpathentry kind = " src " path = " src " / > <nl> 	 < classpathentry kind = " src " path = " common " / > <nl> + 	 < classpathentry kind = " src " path = " src " / > <nl> 	 < classpathentry kind = " src " path = " client " / > <nl> 	 < classpathentry kind = " con " path = " org . eclipse . jdt . launching . JRE _ CONTAINER / org . eclipse . jdt . internal . debug . ui . launcher . StandardVMType / JavaSE - 1 . 6 " / > <nl> 	 < classpathentry kind = " lib " path = " jars / bin / jinput . jar " >

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / client / ClientHooks . java b / src / main / java / net / minecraftforge / fml / client / ClientHooks . java 
 index f260125 . . c3a268a 100644 
 - - - a / src / main / java / net / minecraftforge / fml / client / ClientHooks . java 
 + + + b / src / main / java / net / minecraftforge / fml / client / ClientHooks . java 
 @ @ - 58 , 10 + 58 , 12 @ @ import net . minecraft . network . ServerStatusResponse ; 
 import net . minecraft . resources . AbstractResourcePack ; 
 import net . minecraft . resources . FallbackResourceManager ; 
 import net . minecraft . resources . IResourcePack ; 
 + import net . minecraft . resources . SimpleReloadableResourceManager ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraft . world . storage . WorldSummary ; 
 import net . minecraftforge . fml . StartupQuery ; 
 import net . minecraftforge . fml . client . gui . GuiAccessDenied ; 
 + import net . minecraftforge . fml . common . ObfuscationReflectionHelper ; 
 import net . minecraftforge . forgespi . language . IModInfo ; 
 import net . minecraftforge . fml . packs . ModFileResourcePack ; 
 import net . minecraftforge . registries . GameData ; 
 @ @ - 233 , 7 + 235 , 7 @ @ public class ClientHooks 
 / / We can ' t handle many unicode points in the splash renderer 
 return DISALLOWED _ CHAR _ MATCHER . removeFrom ( net . minecraft . util . StringUtils . stripControlCodes ( message ) ) ; 
 } 
 - 
 + 
 private static SetMultimap < String , ResourceLocation > missingTextures = HashMultimap . create ( ) ; 
 private static Set < String > badTextureDomains = Sets . newHashSet ( ) ; 
 private static Table < String , String , Set < ResourceLocation > > brokenTextures = HashBasedTable . create ( ) ; 
 @ @ - 265 , 7 + 267 , 7 @ @ public class ClientHooks 
 Logger logger = LogManager . getLogger ( " FML . TEXTURE _ ERRORS " ) ; 
 logger . error ( Strings . repeat ( " + = " , 25 ) ) ; 
 logger . error ( " The following texture errors were found . " ) ; 
 - Map < String , FallbackResourceManager > resManagers = null ; / / TODO ObfuscationReflectionHelper . getPrivateValue ( SimpleReloadableResourceManager . class , ( SimpleReloadableResourceManager ) Minecraft . getMinecraft ( ) . getResourceManager ( ) , " field _ 110548 " + " _ a " ) ; 
 + Map < String , FallbackResourceManager > resManagers = ObfuscationReflectionHelper . getPrivateValue ( SimpleReloadableResourceManager . class , ( SimpleReloadableResourceManager ) Minecraft . getInstance ( ) . getResourceManager ( ) , " field _ 199014 " + " _ c " ) ; 
 for ( String resourceDomain : badTextureDomains ) 
 { 
 Set < ResourceLocation > missing = missingTextures . get ( resourceDomain ) ; 
 @ @ - 280 , 7 + 282 , 7 @ @ public class ClientHooks 
 } 
 else 
 { 
 - List < IResourcePack > resPacks = null ; / / ObfuscationReflectionHelper . getPrivateValue ( FallbackResourceManager . class , fallbackResourceManager , " field _ 110540 " + " _ a " ) ; 
 + List < IResourcePack > resPacks = fallbackResourceManager . resourcePacks ; 
 logger . error ( " domain { } has { } location { } : " , resourceDomain , resPacks . size ( ) , resPacks . size ( ) ! = 1 ? " s " : " " ) ; 
 for ( IResourcePack resPack : resPacks ) 
 { 
 @ @ - 291 , 9 + 293 , 7 @ @ public class ClientHooks 
 } 
 else if ( resPack instanceof AbstractResourcePack ) 
 { 
 - AbstractResourcePack resourcePack = ( AbstractResourcePack ) resPack ; 
 - File resPath = null ; / / TODO bfuscationReflectionHelper . getPrivateValue ( AbstractResourcePack . class , resourcePack , " field _ 110597 " + " _ b " ) ; 
 - logger . error ( " resource pack at path { } " , resPath . getPath ( ) ) ; 
 + logger . error ( " resource pack at path { } " , ( ( AbstractResourcePack ) resPack ) . file . getPath ( ) ) ; 
 } 
 else 
 { 
 diff - - git a / src / main / java / net / minecraftforge / fml / client / TextureTracker . java b / src / main / java / net / minecraftforge / fml / client / TextureTracker . java 
 index aa61010 . . 89dd3ce 100644 
 - - - a / src / main / java / net / minecraftforge / fml / client / TextureTracker . java 
 + + + b / src / main / java / net / minecraftforge / fml / client / TextureTracker . java 
 @ @ - 52 , 84 + 52 , 4 @ @ public class TextureTracker 
 } 
 badType . add ( resourceLocation ) ; 
 } 
 - 
 - public static void logMissingTextureErrors ( ) 
 - { 
 - / * 
 - if ( missingTextures . isEmpty ( ) & & brokenTextures . isEmpty ( ) ) 
 - { 
 - return ; 
 - } 
 - Logger logger = LogManager . getLogger ( " TEXTURE ERRORS " ) ; 
 - logger . error ( Strings . repeat ( " + = " , 25 ) ) ; 
 - logger . error ( " The following texture errors were found . " ) ; 
 - Map < String , FallbackResourceManager > resManagers = ObfuscationReflectionHelper . getPrivateValue ( SimpleReloadableResourceManager . class , ( SimpleReloadableResourceManager ) Minecraft . getMinecraft ( ) . getResourceManager ( ) , " domainResourceManagers " , " field _ 110548 " + " _ a " ) ; 
 - for ( String resourceDomain : badTextureDomains ) 
 - { 
 - Set < ResourceLocation > missing = missingTextures . get ( resourceDomain ) ; 
 - logger . error ( Strings . repeat ( " = " , 50 ) ) ; 
 - logger . error ( " DOMAIN { } " , resourceDomain ) ; 
 - logger . error ( Strings . repeat ( " - " , 50 ) ) ; 
 - logger . error ( " domain { } is missing { } texture { } " , resourceDomain , missing . size ( ) , missing . size ( ) ! = 1 ? " s " : " " ) ; 
 - FallbackResourceManager fallbackResourceManager = resManagers . get ( resourceDomain ) ; 
 - if ( fallbackResourceManager = = null ) 
 - { 
 - logger . error ( " domain { } is missing a resource manager - it is probably a side - effect of automatic texture processing " , resourceDomain ) ; 
 - } 
 - else 
 - { 
 - List < IResourcePack > resPacks = ObfuscationReflectionHelper . getPrivateValue ( FallbackResourceManager . class , fallbackResourceManager , " resourcePacks " , " field _ 110540 " + " _ a " ) ; 
 - logger . error ( " domain { } has { } location { } : " , resourceDomain , resPacks . size ( ) , resPacks . size ( ) ! = 1 ? " s " : " " ) ; 
 - for ( IResourcePack resPack : resPacks ) 
 - { 
 - if ( resPack instanceof FMLContainerHolder ) { 
 - FMLContainerHolder containerHolder = ( FMLContainerHolder ) resPack ; 
 - ModContainer fmlContainer = containerHolder . getFMLContainer ( ) ; 
 - logger . error ( " mod { } resources at { } " , fmlContainer . getModId ( ) , fmlContainer . getSource ( ) . getPath ( ) ) ; 
 - } 
 - else if ( resPack instanceof AbstractResourcePack ) 
 - { 
 - AbstractResourcePack resourcePack = ( AbstractResourcePack ) resPack ; 
 - File resPath = ObfuscationReflectionHelper . getPrivateValue ( AbstractResourcePack . class , resourcePack , " resourcePackFile " , " field _ 110597 " + " _ b " ) ; 
 - logger . error ( " resource pack at path { } " , resPath . getPath ( ) ) ; 
 - } 
 - else 
 - { 
 - logger . error ( " unknown resourcepack type { } : { } " , resPack . getClass ( ) . getName ( ) , resPack . getPackName ( ) ) ; 
 - } 
 - } 
 - } 
 - logger . error ( Strings . repeat ( " - " , 25 ) ) ; 
 - if ( missingTextures . containsKey ( resourceDomain ) ) { 
 - logger . error ( " The missing resources for domain { } are : " , resourceDomain ) ; 
 - for ( ResourceLocation rl : missing ) { 
 - logger . error ( " { } " , rl . getResourcePath ( ) ) ; 
 - } 
 - logger . error ( Strings . repeat ( " - " , 25 ) ) ; 
 - } 
 - if ( ! brokenTextures . containsRow ( resourceDomain ) ) 
 - { 
 - logger . error ( " No other errors exist for domain { } " , resourceDomain ) ; 
 - } 
 - else 
 - { 
 - logger . error ( " The following other errors were reported for domain { } : " , resourceDomain ) ; 
 - Map < String , Set < ResourceLocation > > resourceErrs = brokenTextures . row ( resourceDomain ) ; 
 - for ( String error : resourceErrs . keySet ( ) ) 
 - { 
 - logger . error ( Strings . repeat ( " - " , 25 ) ) ; 
 - logger . error ( " Problem : { } " , error ) ; 
 - for ( ResourceLocation rl : resourceErrs . get ( error ) ) 
 - { 
 - logger . error ( " { } " , rl . getResourcePath ( ) ) ; 
 - } 
 - } 
 - } 
 - logger . error ( Strings . repeat ( " = " , 50 ) ) ; 
 - } 
 - logger . error ( Strings . repeat ( " + = " , 25 ) ) ; 
 - * / 
 - } 
 - 
 - 
 } 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / ObfuscationReflectionHelper . java b / src / main / java / net / minecraftforge / fml / common / ObfuscationReflectionHelper . java 
 index a4730d3 . . b0773e4 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / ObfuscationReflectionHelper . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / ObfuscationReflectionHelper . java 
 @ @ - 18 , 62 + 18 , 98 @ @ 
 * / 
 
 package net . minecraftforge . fml . common ; 
 - / * TODO ReflectionHelper 
 - import java . util . Arrays ; 
 + import java . io . BufferedReader ; 
 + import java . io . IOException ; 
 + import java . io . InputStreamReader ; 
 + import java . lang . reflect . Constructor ; 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . Method ; 
 + import java . net . URL ; 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + import java . util . StringJoiner ; 
 
 - import net . minecraftforge . fml . common . asm . deobf . FMLDeobfuscatingRemapper ; 
 - import net . minecraftforge . fml . relauncher . ReflectionHelper ; 
 - import net . minecraftforge . fml . relauncher . ReflectionHelper . UnableToAccessFieldException ; 
 - import net . minecraftforge . fml . relauncher . ReflectionHelper . UnableToFindFieldException ; 
 + import javax . annotation . Nonnull ; 
 + 
 + import org . apache . logging . log4j . LogManager ; 
 + import org . apache . logging . log4j . Logger ; 
 + import org . apache . logging . log4j . Marker ; 
 + import org . apache . logging . log4j . MarkerManager ; 
 + 
 + import com . google . common . base . Preconditions ; 
 
 / * * 
 * Some reflection helper code . 
 + * This may not work properly in Java9 with their new more restrictive reflection management . 
 + * As such , if issues are encountered , please report them and we can see what we can do to expand 
 + * the compatibility . 
 + * 
 + * In other cases , AccessTransformers may be used . 
 * 
 - * @ author cpw 
 + * All field names should be passed in as SRG names , and this will automatically resolve if MCP mappings are detected . 
 * 
 - * / 
 + * / 
 + @ SuppressWarnings ( { " serial " , " unchecked " } ) 
 public class ObfuscationReflectionHelper 
 { 
 + private static final Logger LOGGER = LogManager . getLogger ( ) ; 
 + private static final Marker REFLECTION = MarkerManager . getMarker ( " REFLECTION " ) ; 
 + private static final Map < String , String > map = new HashMap < > ( ) ; 
 + private static boolean loaded = false ; 
 + 
 + 
 + 
 + public static String [ ] remapNames ( String . . . names ) 
 + { 
 + loadMappings ( ) ; 
 + if ( map . isEmpty ( ) ) 
 + return names ; 
 + 
 + String [ ] mappedNames = new String [ names . length ] ; 
 + int i = 0 ; 
 + for ( String name : names ) 
 + mappedNames [ i + + ] = map . getOrDefault ( name , name ) ; 
 + return mappedNames ; 
 + } 
 + 
 + public static String remapName ( String name ) 
 + { 
 + loadMappings ( ) ; 
 + if ( map . isEmpty ( ) ) 
 + return name ; 
 + return map . getOrDefault ( name , name ) ; 
 + } 
 + 
 public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , int fieldIndex ) 
 { 
 try 
 { 
 - return ReflectionHelper . getPrivateValue ( classToAccess , instance , fieldIndex ) ; 
 + Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; 
 + f . setAccessible ( true ) ; 
 + return ( T ) f . get ( instance ) ; 
 } 
 - catch ( UnableToAccessFieldException e ) 
 + catch ( Exception e ) 
 { 
 - LOGGER . error ( " There was a problem getting field index { } from { } " , classToAccess . getName ( ) , e ) ; 
 - throw e ; 
 + LOGGER . error ( REFLECTION , " There was a problem getting field index { } from { } " , classToAccess . getName ( ) , e ) ; 
 + throw new UnableToAccessFieldException ( e ) ; 
 } 
 } 
 
 - public static String [ ] remapFieldNames ( String className , String . . . fieldNames ) 
 - { 
 - String internalClassName = FMLDeobfuscatingRemapper . INSTANCE . unmap ( className . replace ( ' . ' , ' / ' ) ) ; 
 - String [ ] mappedNames = new String [ fieldNames . length ] ; 
 - int i = 0 ; 
 - for ( String fName : fieldNames ) 
 - { 
 - mappedNames [ i + + ] = FMLDeobfuscatingRemapper . INSTANCE . mapFieldName ( internalClassName , fName , null ) ; 
 - } 
 - return mappedNames ; 
 - } 
 - 
 - public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String . . . fieldNames ) 
 + public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String fieldName ) 
 { 
 try 
 { 
 - return ReflectionHelper . getPrivateValue ( classToAccess , instance , remapFieldNames ( classToAccess . getName ( ) , fieldNames ) ) ; 
 + return ( T ) findField ( classToAccess , remapName ( fieldName ) ) . get ( instance ) ; 
 } 
 catch ( UnableToFindFieldException e ) 
 { 
 - LOGGER . error ( " Unable to locate any field { } on type { } " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) , e ) ; 
 + LOGGER . error ( " Unable to locate field { } ( { } ) on type { } " , fieldName , remapName ( fieldName ) , classToAccess . getName ( ) , e ) ; 
 throw e ; 
 } 
 - catch ( UnableToAccessFieldException e ) 
 + catch ( IllegalAccessException e ) 
 { 
 - LOGGER . error ( " Unable to access any field { } on type { } " , classToAccess . getName ( ) , e ) ; 
 - throw e ; 
 + LOGGER . error ( " Unable to access field { } ( { } ) on type { } " , fieldName , remapName ( fieldName ) , classToAccess . getName ( ) , e ) ; 
 + throw new UnableToAccessFieldException ( e ) ; 
 } 
 } 
 
 @ @ - 81 , 31 + 117 , 181 @ @ public class ObfuscationReflectionHelper 
 { 
 try 
 { 
 - ReflectionHelper . setPrivateValue ( classToAccess , instance , value , fieldIndex ) ; 
 + Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; 
 + f . setAccessible ( true ) ; 
 + f . set ( instance , value ) ; 
 } 
 - catch ( UnableToAccessFieldException e ) 
 + catch ( IllegalAccessException e ) 
 { 
 LOGGER . error ( " There was a problem setting field index { } on type { } " , classToAccess . getName ( ) , e ) ; 
 - throw e ; 
 + throw new UnableToAccessFieldException ( e ) ; 
 } 
 } 
 
 - public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , String . . . fieldNames ) 
 + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , String fieldName ) 
 { 
 try 
 { 
 - ReflectionHelper . setPrivateValue ( classToAccess , instance , value , remapFieldNames ( classToAccess . getName ( ) , fieldNames ) ) ; 
 + findField ( classToAccess , remapName ( fieldName ) ) . set ( instance , value ) ; 
 } 
 catch ( UnableToFindFieldException e ) 
 { 
 LOGGER . error ( " Unable to locate any field { } on type { } " , classToAccess . getName ( ) , e ) ; 
 throw e ; 
 } 
 - catch ( UnableToAccessFieldException e ) 
 + catch ( IllegalAccessException e ) 
 { 
 LOGGER . error ( " Unable to set any field { } on type { } " , classToAccess . getName ( ) , e ) ; 
 - throw e ; 
 + throw new UnableToAccessFieldException ( e ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Finds a method with the specified name and parameters in the given class and makes it accessible . 
 + * Note : for performance , store the returned value and avoid calling this repeatedly . 
 + * < p > 
 + * Throws an exception if the method is not found . 
 + * 
 + * @ param clazz The class to find the method on . 
 + * @ param methodName The name of the method to find ( used in developer environments , i . e . " getWorldTime " ) . 
 + * @ param methodObfName The obfuscated name of the method to find ( used in obfuscated environments , i . e . " func _ 72820 _ D " ) . 
 + * If the name you are looking for is on a class that is never obfuscated , this should be null . 
 + * @ param parameterTypes The parameter types of the method to find . 
 + * @ return The method with the specified name and parameters in the given class . 
 + * / 
 + @ Nonnull 
 + public static Method findMethod ( @ Nonnull Class < ? > clazz , @ Nonnull String methodName , Class < ? > . . . parameterTypes ) 
 + { 
 + Preconditions . checkNotNull ( clazz ) ; 
 + Preconditions . checkNotNull ( methodName ) ; 
 + Preconditions . checkArgument ( methodName . isEmpty ( ) , " Method name cannot be empty " ) ; 
 + 
 + try 
 + { 
 + Method m = clazz . getDeclaredMethod ( remapName ( methodName ) , parameterTypes ) ; 
 + m . setAccessible ( true ) ; 
 + return m ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new UnableToFindMethodException ( e ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Finds a constructor in the specified class that has matching parameter types . 
 + * 
 + * @ param klass The class to find the constructor in 
 + * @ param parameterTypes The parameter types of the constructor . 
 + * @ param < T > The type 
 + * @ return The constructor 
 + * @ throws NullPointerException if { @ code klass } is null 
 + * @ throws NullPointerException if { @ code parameterTypes } is null 
 + * @ throws UnknownConstructorException if the constructor could not be found 
 + * / 
 + @ Nonnull 
 + public static < T > Constructor < T > findConstructor ( @ Nonnull final Class < T > klass , @ Nonnull final Class < ? > . . . parameterTypes ) 
 + { 
 + Preconditions . checkNotNull ( klass , " class " ) ; 
 + Preconditions . checkNotNull ( parameterTypes , " parameter types " ) ; 
 + 
 + try 
 + { 
 + Constructor < T > constructor = klass . getDeclaredConstructor ( parameterTypes ) ; 
 + constructor . setAccessible ( true ) ; 
 + return constructor ; 
 + } 
 + catch ( final NoSuchMethodException e ) 
 + { 
 + final StringBuilder desc = new StringBuilder ( ) ; 
 + desc . append ( klass . getSimpleName ( ) ) ; 
 + 
 + StringJoiner joiner = new StringJoiner ( " , " , " ( " , " ) " ) ; 
 + for ( Class < ? > type : parameterTypes ) 
 + { 
 + joiner . add ( type . getSimpleName ( ) ) ; 
 + } 
 + desc . append ( joiner ) ; 
 + 
 + throw new UnknownConstructorException ( " Could not find constructor ' " + desc . toString ( ) + " ' in " + klass ) ; 
 + } 
 + } 
 + 
 + private static Field findField ( Class < ? > clazz , String name ) 
 + { 
 + try 
 + { 
 + Field f = clazz . getDeclaredField ( name ) ; 
 + f . setAccessible ( true ) ; 
 + return f ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new UnableToFindFieldException ( e ) ; 
 + } 
 + } 
 + 
 + private static void loadMappings ( ) 
 + { 
 + if ( loaded ) 
 + return ; 
 + 
 + synchronized ( map ) / / Just in case ? 
 + { 
 + if ( loaded ) / / Incase something else loaded while we were here , jump out 
 + return ; 
 + for ( String file : new String [ ] { " fields . csv " , " methods . csv " } ) 
 + { 
 + URL path = ClassLoader . getSystemResource ( file ) ; / / We EXPLICITLY go throught the SystemClassLoader here because this is dev - time only . And will be on the root classpath . 
 + if ( path = = null ) 
 + continue ; 
 + 
 + int count = map . size ( ) ; 
 + LOGGER . info ( REFLECTION , " Loading Mappings : { } " , path ) ; 
 + try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( path . openStream ( ) ) ) ) 
 + { 
 + reader . lines ( ) . skip ( 1 ) . map ( e - > e . split ( " , " ) ) . forEach ( e - > map . put ( e [ 0 ] , e [ 1 ] ) ) ; 
 + } 
 + catch ( IOException e1 ) 
 + { 
 + LOGGER . error ( REFLECTION , " Error reading mappings " , e1 ) ; 
 + } 
 + LOGGER . info ( REFLECTION , " Loaded { } entries " , map . size ( ) - count ) ; 
 + } 
 + loaded = true ; 
 + } 
 + } 
 + 
 + / / Add SRG names to these exception ? 
 + public static class UnableToAccessFieldException extends RuntimeException 
 + { 
 + private UnableToAccessFieldException ( Exception e ) 
 + { 
 + super ( e ) ; 
 + } 
 + } 
 + 
 + public static class UnableToFindFieldException extends RuntimeException 
 + { 
 + private UnableToFindFieldException ( Exception e ) 
 + { 
 + super ( e ) ; 
 + } 
 + } 
 + 
 + public static class UnableToFindMethodException extends RuntimeException 
 + { 
 + public UnableToFindMethodException ( Throwable failed ) 
 + { 
 + super ( failed ) ; 
 + } 
 + } 
 + 
 + public static class UnknownConstructorException extends RuntimeException 
 + { 
 + public UnknownConstructorException ( final String message ) 
 + { 
 + super ( message ) ; 
 } 
 } 
 } 
 - * / 
 diff - - git a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 index a88cbfa . . 54ab813 100644 
 - - - a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 + + + b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import java . util . Map . Entry ; 
 
 import javax . annotation . Nonnull ; 
 import net . minecraftforge . fml . ModThreadContext ; 
 + import net . minecraftforge . fml . common . ObfuscationReflectionHelper ; 
 import net . minecraftforge . fml . loading . AdvancedLogMessageAdapter ; 
 import org . apache . commons . lang3 . Validate ; 
 
 @ @ - 427 , 7 + 428 , 7 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 { 
 try 
 { 
 - / / ReflectionHelper . findMethod ( BitSet . class , " trimToSize " , null ) . invoke ( this . availabilityMap ) ; 
 + ObfuscationReflectionHelper . findMethod ( BitSet . class , " trimToSize " ) . invoke ( this . availabilityMap ) ; 
 } 
 catch ( Exception e ) 
 {

NEAREST DIFF:
diff - - git a / fml / build . xml b / fml / build . xml 
 index 587bb5a . . eff4015 100644 
 - - - a / fml / build . xml 
 + + + b / fml / build . xml 
 @ @ - 266 , 14 + 266 , 17 @ @ 
 < target name = " repatch " depends = " buildenvsetup " > 
 < echo > Moving old patched sources at $ { mcp . home } / src - work out of the way < / echo > 
 < move todir = " $ { mcp . home } / src - work $ { timestamp } " failonerror = " false " verbose = " true " > 
 - < fileset dir = " $ { mcp . home } / src - work " / > 
 + < fileset dir = " $ { patch . mcp . srcdir } " / > 
 < / move > 
 < delete dir = " $ { mcp . srcdir } " / > 
 < copy todir = " $ { mcp . srcdir } " > 
 - < fileset dir = " $ { mcp . home } / src - base " / > 
 + < fileset dir = " $ { clean . mcp . srcdir } " / > 
 < / copy > 
 + 
 + < antcall target = " cleanargo " / > 
 + 
 < antcall target = " patch " / > 
 - < copy todir = " $ { mcp . home } / src - work " > 
 + < copy todir = " $ { patch . mcp . srcdir } " > 
 < fileset dir = " $ { mcp . srcdir } " / > 
 < / copy > 
 < / target > 
 diff - - git a / fml / client / cpw / mods / fml / client / FMLClientHandler . java b / fml / client / cpw / mods / fml / client / FMLClientHandler . java 
 index 4ce2275 . . eea61f0 100644 
 - - - a / fml / client / cpw / mods / fml / client / FMLClientHandler . java 
 + + + b / fml / client / cpw / mods / fml / client / FMLClientHandler . java 
 @ @ - 88 , 13 + 88 , 13 @ @ import cpw . mods . fml . common . Loader ; 
 import cpw . mods . fml . common . ModContainer ; 
 import cpw . mods . fml . common . ModMetadata ; 
 import cpw . mods . fml . common . ProxyInjector ; 
 - import cpw . mods . fml . common . ReflectionHelper ; 
 import cpw . mods . fml . common . Side ; 
 import cpw . mods . fml . common . TickType ; 
 import cpw . mods . fml . common . modloader . ModLoaderHelper ; 
 import cpw . mods . fml . common . modloader . ModLoaderModContainer ; 
 import cpw . mods . fml . common . modloader . ModProperty ; 
 import cpw . mods . fml . common . registry . FMLRegistry ; 
 + import cpw . mods . fml . common . ReflectionHelper ; 
 
 
 / * * 
 diff - - git a / fml / client / net / minecraft / src / ModLoader . java b / fml / client / net / minecraft / src / ModLoader . java 
 index 91be235 . . 502caeb 100644 
 - - - a / fml / client / net / minecraft / src / ModLoader . java 
 + + + b / fml / client / net / minecraft / src / ModLoader . java 
 @ @ - 26 , 10 + 26 , 10 @ @ import cpw . mods . fml . client . FMLClientHandler ; 
 import cpw . mods . fml . client . SpriteHelper ; 
 import cpw . mods . fml . common . FMLCommonHandler ; 
 import cpw . mods . fml . common . Loader ; 
 - import cpw . mods . fml . common . ReflectionHelper ; 
 import cpw . mods . fml . common . modloader . ModLoaderHelper ; 
 import cpw . mods . fml . common . modloader . ModLoaderModContainer ; 
 import cpw . mods . fml . common . registry . FMLRegistry ; 
 + import cpw . mods . fml . common . ReflectionHelper ; 
 
 public class ModLoader 
 { 
 @ @ - 733 , 7 + 733 , 7 @ @ public class ModLoader 
 * / 
 public static < T , E > void setPrivateValue ( Class < ? super T > instanceclass , T instance , int fieldindex , E value ) 
 { 
 - ReflectionHelper . setPrivateValue ( instanceclass , instance , fieldindex , value ) ; 
 + ReflectionHelper . setPrivateValue ( instanceclass , instance , value , fieldindex ) ; 
 } 
 
 / * * 
 @ @ - 747 , 7 + 747 , 7 @ @ public class ModLoader 
 * / 
 public static < T , E > void setPrivateValue ( Class < ? super T > instanceclass , T instance , String field , E value ) 
 { 
 - ReflectionHelper . setPrivateValue ( instanceclass , instance , field , value ) ; 
 + ReflectionHelper . setPrivateValue ( instanceclass , instance , value , field ) ; 
 } 
 
 / * * 
 diff - - git a / fml / common / cpw / mods / fml / common / ReflectionHelper . java b / fml / common / cpw / mods / fml / common / ReflectionHelper . java 
 index 30bc523 . . 251da11 100644 
 - - - a / fml / common / cpw / mods / fml / common / ReflectionHelper . java 
 + + + b / fml / common / cpw / mods / fml / common / ReflectionHelper . java 
 @ @ - 14 , 9 + 14 , 15 @ @ package cpw . mods . fml . common ; 
 
 import java . lang . reflect . Field ; 
 import java . lang . reflect . Method ; 
 + import java . util . Arrays ; 
 + import java . util . logging . Level ; 
 + 
 + import cpw . mods . fml . common . FMLCommonHandler ; 
 + import cpw . mods . fml . relauncher . ReflectionHelper . UnableToAccessFieldException ; 
 + import cpw . mods . fml . relauncher . ReflectionHelper . UnableToFindFieldException ; 
 / * * 
 * Some reflection helper code . 
 - * 
 + * 
 * @ author cpw 
 * 
 * / 
 @ @ - 29 , 73 + 35 , 79 @ @ public class ReflectionHelper 
 { 
 try 
 { 
 - Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; 
 - f . setAccessible ( true ) ; 
 - return ( T ) f . get ( instance ) ; 
 + return cpw . mods . fml . relauncher . ReflectionHelper . getPrivateValue ( classToAccess , instance , fieldIndex ) ; 
 } 
 - catch ( Exception e ) 
 + catch ( UnableToAccessFieldException e ) 
 { 
 - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . severe ( String . format ( " There was a problem getting field % d from % s " , fieldIndex , classToAccess . getName ( ) ) ) ; 
 - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . throwing ( " ReflectionHelper " , " getPrivateValue " , e ) ; 
 - throw new RuntimeException ( e ) ; 
 + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " There was a problem getting field index % d from % s " , fieldIndex , classToAccess . getName ( ) ) , e ) ; 
 + throw e ; 
 } 
 } 
 
 @ SuppressWarnings ( " unchecked " ) 
 - public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String fieldName ) 
 + public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String . . . fieldNames ) 
 { 
 try 
 { 
 - Field f = classToAccess . getDeclaredField ( fieldName ) ; 
 - f . setAccessible ( true ) ; 
 - return ( T ) f . get ( instance ) ; 
 + return cpw . mods . fml . relauncher . ReflectionHelper . getPrivateValue ( classToAccess , instance , fieldNames ) ; 
 + } 
 + catch ( UnableToFindFieldException e ) 
 + { 
 + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " Unable to locate any field % s on type % s " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) ) , e ) ; 
 + throw e ; 
 } 
 - catch ( Exception e ) 
 + catch ( UnableToAccessFieldException e ) 
 { 
 - if ( ( fieldName . length ( ) > 3 & & ! obfuscation ) | | ( fieldName . length ( ) < = 3 & & obfuscation ) ) { 
 - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . severe ( String . format ( " There was a problem getting field % s from % s " , fieldName , classToAccess . getName ( ) ) ) ; 
 - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . throwing ( " ReflectionHelper " , " getPrivateValue " , e ) ; 
 - } 
 - throw new RuntimeException ( e ) ; 
 + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " Unable to access any field % s on type % s " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) ) , e ) ; 
 + throw e ; 
 } 
 } 
 
 + @ Deprecated 
 public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , int fieldIndex , E value ) 
 { 
 + setPrivateValue ( classToAccess , instance , value , fieldIndex ) ; 
 + } 
 + 
 + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , int fieldIndex ) 
 + { 
 try 
 { 
 - Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; 
 - f . setAccessible ( true ) ; 
 - f . set ( instance , value ) ; 
 + cpw . mods . fml . relauncher . ReflectionHelper . setPrivateValue ( classToAccess , instance , value , fieldIndex ) ; 
 } 
 - catch ( Exception e ) 
 + catch ( UnableToAccessFieldException e ) 
 { 
 - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . severe ( String . format ( " There was a problem setting field % d from % s " , fieldIndex , classToAccess . getName ( ) ) ) ; 
 - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . throwing ( " ReflectionHelper " , " getPrivateValue " , e ) ; 
 - throw new RuntimeException ( e ) ; 
 + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " There was a problem setting field index % d on type % s " , fieldIndex , classToAccess . getName ( ) ) ) ; 
 + throw e ; 
 } 
 } 
 
 + @ Deprecated 
 public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , String fieldName , E value ) 
 { 
 + setPrivateValue ( classToAccess , instance , value , fieldName ) ; 
 + } 
 + 
 + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , String . . . fieldNames ) 
 + { 
 try 
 { 
 - Field f = classToAccess . getDeclaredField ( fieldName ) ; 
 - f . setAccessible ( true ) ; 
 - f . set ( instance , value ) ; 
 + cpw . mods . fml . relauncher . ReflectionHelper . setPrivateValue ( classToAccess , instance , value , fieldNames ) ; 
 + } 
 + catch ( UnableToFindFieldException e ) 
 + { 
 + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " Unable to locate any field % s on type % s " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) ) , e ) ; 
 + throw e ; 
 } 
 - catch ( Exception e ) 
 + catch ( UnableToAccessFieldException e ) 
 { 
 - if ( ( fieldName . length ( ) > 3 & & ! obfuscation ) | | ( fieldName . length ( ) < = 3 & & obfuscation ) ) { 
 - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . severe ( String . format ( " There was a problem setting field % s from % s " , fieldName , classToAccess . getName ( ) ) ) ; 
 - FMLCommonHandler . instance ( ) . getFMLLogger ( ) . throwing ( " ReflectionHelper " , " getPrivateValue " , e ) ; 
 - } 
 - throw new RuntimeException ( e ) ; 
 + FMLCommonHandler . instance ( ) . getFMLLogger ( ) . log ( Level . SEVERE , String . format ( " Unable to set any field % s on type % s " , Arrays . toString ( fieldNames ) , classToAccess . getName ( ) ) , e ) ; 
 + throw e ; 
 } 
 } 
 
 / * * 
 - * 
 + * 
 * / 
 public static void detectObfuscation ( Class < ? > clazz ) 
 { 
 diff - - git a / fml / common / cpw / mods / fml / relauncher / FMLEmbeddingRelauncher . java b / fml / common / cpw / mods / fml / relauncher / FMLEmbeddingRelauncher . java 
 index d924f81 . . f905984 100644 
 - - - a / fml / common / cpw / mods / fml / relauncher / FMLEmbeddingRelauncher . java 
 + + + b / fml / common / cpw / mods / fml / relauncher / FMLEmbeddingRelauncher . java 
 @ @ - 1 , 17 + 1 , 18 @ @ 
 package cpw . mods . fml . relauncher ; 
 
 + import java . io . File ; 
 import java . lang . reflect . Field ; 
 import java . lang . reflect . InvocationTargetException ; 
 + import java . lang . reflect . Method ; 
 import java . net . URLClassLoader ; 
 + import java . util . Arrays ; 
 
 - import net . minecraft . client . Minecraft ; 
 import net . minecraft . src . WorldSettings ; 
 
 public class FMLEmbeddingRelauncher 
 { 
 private static FMLEmbeddingRelauncher INSTANCE ; 
 private RelaunchClassLoader clientLoader ; 
 - private RelaunchClassLoader serverLoader ; 
 
 public static void relaunch ( ArgsWrapper wrap ) 
 { 
 @ @ - 24 , 25 + 25 , 36 @ @ public class FMLEmbeddingRelauncher 
 URLClassLoader ucl = ( URLClassLoader ) getClass ( ) . getClassLoader ( ) ; 
 
 clientLoader = new RelaunchClassLoader ( ucl . getURLs ( ) ) ; 
 - serverLoader = new RelaunchClassLoader ( ucl . getURLs ( ) ) ; 
 } 
 
 private void relaunchClient ( ArgsWrapper wrap ) 
 { 
 + Class < ? super Object > mcMaster = ReflectionHelper . getClass ( getClass ( ) . getClassLoader ( ) , " net . minecraft . client . Minecraft " ) ; 
 + / / We force minecraft to setup it ' s homedir very early on so we can inject stuff into it 
 + Method setupHome = ReflectionHelper . findMethod ( mcMaster , null , new String [ ] { " func _ 6240 _ b " , " getMinecraftDir " , " b " } ) ; 
 try 
 { 
 - Class < ? > original = Class . forName ( " net . minecraft . client . Minecraft " , false , getClass ( ) . getClassLoader ( ) ) ; 
 - Field origDir = original . getDeclaredField ( " field _ 6275 _ Z " ) ; 
 - origDir . setAccessible ( true ) ; 
 - Class client = Class . forName ( " net . minecraft . client . Minecraft " , false , clientLoader ) ; 
 - Field homeDir = client . getDeclaredField ( " field _ 6275 _ Z " ) ; 
 - homeDir . setAccessible ( true ) ; 
 - homeDir . set ( null , origDir . get ( null ) ) ; 
 - client . getMethod ( " fmlReentry " , ArgsWrapper . class ) . invoke ( null , wrap ) ; 
 + setupHome . invoke ( null ) ; 
 } 
 catch ( Exception e ) 
 { 
 - e . printStackTrace ( ) ; 
 + / / Hmmm 
 + } 
 + File minecraftHome = ReflectionHelper . getPrivateValue ( mcMaster , null , " field _ 6275 _ Z " , " ap " , " minecraftDir " ) ; 
 + 
 + RelaunchLibraryManager . handleLaunch ( minecraftHome , clientLoader ) ; 
 + 
 + / / Now we re - inject the home into the " new " minecraft under our control 
 + Class < ? super Object > client = ReflectionHelper . getClass ( clientLoader , " net . minecraft . client . Minecraft " ) ; 
 + ReflectionHelper . setPrivateValue ( client , null , minecraftHome , " field _ 6275 _ Z " , " ap " , " minecraftDir " ) ; 
 + 
 + try 
 + { 
 + ReflectionHelper . findMethod ( client , null , new String [ ] { " fmlReentry " } , ArgsWrapper . class ) . invoke ( null , wrap ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + / / Hmmm 
 } 
 } 
 } 
 diff - - git a / fml / common / cpw / mods / fml / relauncher / ReflectionHelper . java b / fml / common / cpw / mods / fml / relauncher / ReflectionHelper . java 
 new file mode 100644 
 index 0000000 . . f441197 
 - - - / dev / null 
 + + + b / fml / common / cpw / mods / fml / relauncher / ReflectionHelper . java 
 @ @ - 0 , 0 + 1 , 183 @ @ 
 + / * 
 + * The FML Forge Mod Loader suite . Copyright ( C ) 2012 cpw 
 + * 
 + * This library is free software ; you can redistribute it and / or modify it under the terms of the GNU Lesser General Public License as published by the Free 
 + * Software Foundation ; either version 2 . 1 of the License , or any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , but WITHOUT ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 + * A PARTICULAR PURPOSE . See the GNU Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public License along with this library ; if not , write to the Free Software Foundation , Inc . , 51 
 + * Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package cpw . mods . fml . relauncher ; 
 + 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . Method ; 
 + 
 + import cpw . mods . fml . common . FMLCommonHandler ; 
 + / * * 
 + * Some reflection helper code . 
 + * 
 + * @ author cpw 
 + * 
 + * / 
 + public class ReflectionHelper 
 + { 
 + public static class UnableToFindMethodException extends RuntimeException 
 + { 
 + private String [ ] methodNames ; 
 + 
 + public UnableToFindMethodException ( String [ ] methodNames , Exception failed ) 
 + { 
 + super ( failed ) ; 
 + this . methodNames = methodNames ; 
 + } 
 + 
 + } 
 + 
 + public static class UnableToFindClassException extends RuntimeException 
 + { 
 + private String [ ] classNames ; 
 + 
 + public UnableToFindClassException ( String [ ] classNames , Exception err ) 
 + { 
 + super ( err ) ; 
 + this . classNames = classNames ; 
 + } 
 + 
 + } 
 + 
 + public static class UnableToAccessFieldException extends RuntimeException 
 + { 
 + 
 + private String [ ] fieldNameList ; 
 + 
 + public UnableToAccessFieldException ( String [ ] fieldNames , Exception e ) 
 + { 
 + super ( e ) ; 
 + this . fieldNameList = fieldNames ; 
 + } 
 + } 
 + 
 + public static class UnableToFindFieldException extends RuntimeException 
 + { 
 + private String [ ] fieldNameList ; 
 + public UnableToFindFieldException ( String [ ] fieldNameList , Exception e ) 
 + { 
 + super ( e ) ; 
 + this . fieldNameList = fieldNameList ; 
 + } 
 + } 
 + 
 + public static Field findField ( Class < ? > clazz , String . . . fieldNames ) 
 + { 
 + Exception failed = null ; 
 + for ( String fieldName : fieldNames ) 
 + { 
 + try 
 + { 
 + Field f = clazz . getDeclaredField ( fieldName ) ; 
 + f . setAccessible ( true ) ; 
 + return f ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + failed = e ; 
 + } 
 + } 
 + throw new UnableToFindFieldException ( fieldNames , failed ) ; 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , int fieldIndex ) 
 + { 
 + try 
 + { 
 + Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; 
 + f . setAccessible ( true ) ; 
 + return ( T ) f . get ( instance ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new UnableToAccessFieldException ( new String [ 0 ] , e ) ; 
 + } 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + public static < T , E > T getPrivateValue ( Class < ? super E > classToAccess , E instance , String . . . fieldNames ) 
 + { 
 + try 
 + { 
 + return ( T ) findField ( classToAccess , fieldNames ) . get ( instance ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new UnableToAccessFieldException ( fieldNames , e ) ; 
 + } 
 + } 
 + 
 + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , int fieldIndex ) 
 + { 
 + try 
 + { 
 + Field f = classToAccess . getDeclaredFields ( ) [ fieldIndex ] ; 
 + f . setAccessible ( true ) ; 
 + f . set ( instance , value ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new UnableToAccessFieldException ( new String [ 0 ] , e ) ; 
 + } 
 + } 
 + 
 + public static < T , E > void setPrivateValue ( Class < ? super T > classToAccess , T instance , E value , String . . . fieldNames ) 
 + { 
 + try 
 + { 
 + findField ( classToAccess , fieldNames ) . set ( instance , value ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new UnableToAccessFieldException ( fieldNames , e ) ; 
 + } 
 + } 
 + 
 + public static Class < ? super Object > getClass ( ClassLoader loader , String . . . classNames ) 
 + { 
 + Exception err = null ; 
 + for ( String className : classNames ) 
 + { 
 + try 
 + { 
 + return ( Class < ? super Object > ) Class . forName ( className , false , loader ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + err = e ; 
 + } 
 + } 
 + 
 + throw new UnableToFindClassException ( classNames , err ) ; 
 + } 
 + 
 + 
 + public static < E > Method findMethod ( Class < ? super E > clazz , E instance , String [ ] methodNames , Class < ? > . . . methodTypes ) 
 + { 
 + Exception failed = null ; 
 + for ( String methodName : methodNames ) 
 + { 
 + try 
 + { 
 + Method m = clazz . getDeclaredMethod ( methodName , methodTypes ) ; 
 + m . setAccessible ( true ) ; 
 + return m ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + failed = e ; 
 + } 
 + } 
 + throw new UnableToFindMethodException ( methodNames , failed ) ; 
 + } 
 + } 
 diff - - git a / fml / common / cpw / mods / fml / relauncher / RelaunchClassLoader . java b / fml / common / cpw / mods / fml / relauncher / RelaunchClassLoader . java 
 index 5a4e720 . . 78546e9 100644 
 - - - a / fml / common / cpw / mods / fml / relauncher / RelaunchClassLoader . java 
 + + + b / fml / common / cpw / mods / fml / relauncher / RelaunchClassLoader . java 
 @ @ - 28 , 4 + 28 , 11 @ @ public class RelaunchClassLoader extends URLClassLoader 
 return super . loadClass ( name ) ; 
 } 
 } 
 + 
 + @ Override 
 + protected void addURL ( URL url ) 
 + { 
 + super . addURL ( url ) ; 
 + System . out . println ( Arrays . toString ( getURLs ( ) ) ) ; 
 + } 
 } 
 diff - - git a / fml / common / cpw / mods / fml / relauncher / RelaunchLibraryManager . java b / fml / common / cpw / mods / fml / relauncher / RelaunchLibraryManager . java 
 new file mode 100644 
 index 0000000 . . 383e368 
 - - - / dev / null 
 + + + b / fml / common / cpw / mods / fml / relauncher / RelaunchLibraryManager . java 
 @ @ - 0 , 0 + 1 , 137 @ @ 
 + package cpw . mods . fml . relauncher ; 
 + 
 + import java . awt . HeadlessException ; 
 + import java . io . File ; 
 + import java . io . FileInputStream ; 
 + import java . io . FileNotFoundException ; 
 + import java . io . FileOutputStream ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . math . BigInteger ; 
 + import java . net . MalformedURLException ; 
 + import java . net . URI ; 
 + import java . net . URL ; 
 + import java . net . URLConnection ; 
 + import java . nio . MappedByteBuffer ; 
 + import java . nio . channels . Channels ; 
 + import java . nio . channels . FileChannel ; 
 + import java . nio . channels . ReadableByteChannel ; 
 + import java . nio . channels . FileChannel . MapMode ; 
 + import java . security . MessageDigest ; 
 + import java . security . NoSuchAlgorithmException ; 
 + 
 + import javax . swing . JOptionPane ; 
 + 
 + public class RelaunchLibraryManager 
 + { 
 + private static String [ ] libraries = { " argo - 2 . 25 . jar " , " guava - 12 . 0 . jar " , " asm - all - 4 . 0 . jar " } ; 
 + private static String [ ] checksums = { " bb672829fde76cb163004752b86b0484bd0a7f4b " , " 5bc66dd95b79db1e437eb08adba124a3e4088dc0 " , " 98308890597acb64047f7e896638e0d98753ae82 " } ; 
 + private static final String HEXES = " 0123456789abcdef " ; 
 + public static void handleLaunch ( File mcDir , RelaunchClassLoader actualClassLoader ) 
 + { 
 + File libDir = new File ( mcDir , " lib " ) ; 
 + try 
 + { 
 + libDir = libDir . getCanonicalFile ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( String . format ( " Unable to canonicalize the lib dir at % s " , mcDir . getName ( ) ) , e ) ; 
 + } 
 + if ( ! libDir . exists ( ) ) 
 + { 
 + libDir . mkdir ( ) ; 
 + } 
 + else if ( libDir . exists ( ) & & ! libDir . isDirectory ( ) ) 
 + { 
 + throw new RuntimeException ( String . format ( " Found a lib file in % s that ' s not a directory " , mcDir . getName ( ) ) ) ; 
 + } 
 + 
 + for ( int i = 0 ; i < libraries . length ; i + + ) 
 + { 
 + String libName = libraries [ i ] ; 
 + String checksum = checksums [ i ] ; 
 + File libFile = new File ( libDir , libName ) ; 
 + if ( ! libFile . exists ( ) ) 
 + { 
 + downloadFile ( libFile ) ; 
 + } 
 + 
 + if ( libFile . exists ( ) & & ! libFile . isFile ( ) ) 
 + { 
 + throw new RuntimeException ( String . format ( " Found a file % s that is not a normal file " , libName ) ) ; 
 + } 
 + 
 + String fileChecksum = generateChecksum ( libFile ) ; 
 + if ( ! checksum . equals ( fileChecksum ) ) 
 + { 
 + throw new RuntimeException ( String . format ( " The file % s has an invalid checksum % s ( expecting % s ) " , libName , fileChecksum , checksum ) ) ; 
 + } 
 + try 
 + { 
 + actualClassLoader . addURL ( libFile . toURI ( ) . toURL ( ) ) ; 
 + } 
 + catch ( MalformedURLException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + 
 + } 
 + 
 + } 
 + 
 + private static String generateChecksum ( File file ) 
 + { 
 + try 
 + { 
 + FileInputStream fis = new FileInputStream ( file ) ; 
 + FileChannel chan = fis . getChannel ( ) ; 
 + MessageDigest digest = MessageDigest . getInstance ( " SHA - 1 " ) ; 
 + MappedByteBuffer mappedFile = chan . map ( MapMode . READ _ ONLY , 0 , file . length ( ) ) ; 
 + digest . update ( mappedFile ) ; 
 + chan . close ( ) ; 
 + fis . close ( ) ; 
 + byte [ ] chksum = digest . digest ( ) ; 
 + final StringBuilder hex = new StringBuilder ( 2 * chksum . length ) ; 
 + for ( final byte b : chksum ) { 
 + hex . append ( HEXES . charAt ( ( b & 0xF0 ) > > 4 ) ) 
 + . append ( HEXES . charAt ( ( b & 0x0F ) ) ) ; 
 + } 
 + return hex . toString ( ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + return null ; 
 + } 
 + } 
 + private static void downloadFile ( File libFile ) 
 + { 
 + / / try 
 + / / { 
 + / / JOptionPane . showMessageDialog ( null , String . format ( " Downloading required FML library % s from github . com " , libName ) ) ; 
 + / / } 
 + / / catch ( HeadlessException he ) 
 + / / { 
 + / / / / Ignore 
 + / / } 
 + try 
 + { 
 + URL libDownload = new URL ( String . format ( " http : / / cloud . github . com / downloads / cpw / FML / % s " , libFile . getName ( ) ) ) ; 
 + System . out . printf ( " Downloading % s . . " , libDownload . toString ( ) ) ; 
 + InputStream urlConn = libDownload . openStream ( ) ; 
 + ReadableByteChannel urlChannel = Channels . newChannel ( urlConn ) ; 
 + FileOutputStream libFileStream = new FileOutputStream ( libFile ) ; 
 + FileChannel libFileChannel = libFileStream . getChannel ( ) ; 
 + libFileChannel . transferFrom ( urlChannel , 0 , 1 < < 24 ) ; 
 + libFileChannel . close ( ) ; 
 + libFileStream . close ( ) ; 
 + urlChannel . close ( ) ; 
 + urlConn . close ( ) ; 
 + System . out . println ( " download successful " ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + 
 + } 
 + } 
 + } 
 diff - - git a / fml / eclipse / Clean - Client / . classpath b / fml / eclipse / Clean - Client / . classpath 
 index 6bf817e . . 2660e24 100644 
 - - - a / fml / eclipse / Clean - Client / . classpath 
 + + + b / fml / eclipse / Clean - Client / . classpath 
 @ @ - 18 , 5 + 18 , 6 @ @ 
 	 	 < / attributes > 
 	 < / classpathentry > 
 	 < classpathentry kind = " lib " path = " jars / bin / minecraft . jar " / > 
 + 	 < classpathentry kind = " lib " path = " / home / cpw / projects / FML / mcsnapshot / lib / argo - 2 . 25 . jar " / > 
 	 < classpathentry kind = " output " path = " bin " / > 
 < / classpath > 
 diff - - git a / fml / eclipse / FML - Client / . classpath b / fml / eclipse / FML - Client / . classpath 
 index d750167 . . ea960b8 100644 
 - - - a / fml / eclipse / FML - Client / . classpath 
 + + + b / fml / eclipse / FML - Client / . classpath 
 @ @ - 1 , 7 + 1 , 7 @ @ 
 < ? xml version = " 1 . 0 " encoding = " UTF - 8 " ? > 
 < classpath > 
 - 	 < classpathentry kind = " src " path = " src " / > 
 	 < classpathentry kind = " src " path = " common " / > 
 + 	 < classpathentry kind = " src " path = " src " / > 
 	 < classpathentry kind = " src " path = " client " / > 
 	 < classpathentry kind = " con " path = " org . eclipse . jdt . launching . JRE _ CONTAINER / org . eclipse . jdt . internal . debug . ui . launcher . StandardVMType / JavaSE - 1 . 6 " / > 
 	 < classpathentry kind = " lib " path = " jars / bin / jinput . jar " >
