BLEU SCORE: 0.040583489434387374

TEST MSG: Implement override tracking and syncing .
GENERATED MSG: ItemStack swapping

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> index e62741a . . c400684 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java <nl> @ @ - 147 , 6 + 147 , 16 @ @ public final class FMLContainer extends DummyModContainer implements WorldAccess <nl> } <nl> data . setTag ( " aliases " , aliases ) ; <nl> <nl> + NBTTagList overrides = new NBTTagList ( ) ; <nl> + for ( Entry < ResourceLocation , String > entry : e . getValue ( ) . overrides . entrySet ( ) ) <nl> + { <nl> + NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> + tag . setString ( " K " , entry . getKey ( ) . toString ( ) ) ; <nl> + tag . setString ( " V " , entry . getValue ( ) . toString ( ) ) ; <nl> + aliases . appendTag ( tag ) ; <nl> + } <nl> + data . setTag ( " overrides " , overrides ) ; <nl> + <nl> int [ ] blocked = new int [ e . getValue ( ) . blocked . size ( ) ] ; <nl> int idx = 0 ; <nl> for ( Integer i : e . getValue ( ) . blocked ) <nl> diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java <nl> index efac5f2 . . 88f95a2 100644 <nl> - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java <nl> + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java <nl> @ @ - 184 , 12 + 184 , 14 @ @ public abstract class FMLHandshakeMessage { <nl> this . name = name ; <nl> this . ids = entry . ids ; <nl> this . dummied = entry . dummied ; <nl> + this . overrides = entry . overrides ; <nl> } <nl> <nl> private boolean hasMore ; <nl> private ResourceLocation name ; <nl> private Map < ResourceLocation , Integer > ids ; <nl> private Set < ResourceLocation > dummied ; <nl> + private Map < ResourceLocation , String > overrides ; <nl> <nl> @ Override <nl> public void fromBytes ( ByteBuf buffer ) <nl> @ @ - 206 , 13 + 208 , 20 @ @ public abstract class FMLHandshakeMessage { <nl> } <nl> <nl> length = ByteBufUtils . readVarInt ( buffer , 3 ) ; <nl> - <nl> dummied = Sets . newHashSet ( ) ; <nl> <nl> for ( int i = 0 ; i < length ; i + + ) <nl> { <nl> dummied . add ( new ResourceLocation ( ByteBufUtils . readUTF8String ( buffer ) ) ) ; <nl> } <nl> + <nl> + length = ByteBufUtils . readVarInt ( buffer , 3 ) ; <nl> + overrides = Maps . newHashMap ( ) ; <nl> + <nl> + for ( int i = 0 ; i < length ; i + + ) <nl> + { <nl> + overrides . put ( new ResourceLocation ( ByteBufUtils . readUTF8String ( buffer ) ) , ByteBufUtils . readUTF8String ( buffer ) ) ; <nl> + } <nl> } <nl> <nl> @ Override <nl> @ @ - 233 , 6 + 242 , 13 @ @ public abstract class FMLHandshakeMessage { <nl> { <nl> ByteBufUtils . writeUTF8String ( buffer , entry . toString ( ) ) ; <nl> } <nl> + <nl> + ByteBufUtils . writeVarInt ( buffer , overrides . size ( ) , 3 ) ; <nl> + for ( Entry < ResourceLocation , String > entry : overrides . entrySet ( ) ) <nl> + { <nl> + ByteBufUtils . writeUTF8String ( buffer , entry . getKey ( ) . toString ( ) ) ; <nl> + ByteBufUtils . writeUTF8String ( buffer , entry . getValue ( ) . toString ( ) ) ; <nl> + } <nl> } <nl> <nl> public Map < ResourceLocation , Integer > getIdMap ( ) <nl> diff - - git a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> index 89a5113 . . c0ed23e 100644 <nl> - - - a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java <nl> @ @ - 1 , 6 + 1 , 5 @ @ <nl> package net . minecraftforge . registries ; <nl> <nl> - import java . lang . ref . WeakReference ; <nl> import java . util . BitSet ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> @ @ - 25 , 11 + 24 , 14 @ @ import com . google . common . collect . Lists ; <nl> import com . google . common . collect . Maps ; <nl> import com . google . common . collect . Multimap ; <nl> import com . google . common . collect . Sets ; <nl> - <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . event . RegistryEvent ; <nl> import net . minecraftforge . event . RegistryEvent . MissingMappings ; <nl> + import net . minecraftforge . fml . common . FMLContainer ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> + import net . minecraftforge . fml . common . InjectedModContainer ; <nl> + import net . minecraftforge . fml . common . Loader ; <nl> + import net . minecraftforge . fml . common . ModContainer ; <nl> import net . minecraftforge . fml . relauncher . ReflectionHelper ; <nl> <nl> public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRegistryInternal < V > , IForgeRegistryModifiable < V > <nl> @ @ - 48 , 7 + 50 , 8 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> private final BitSet availabilityMap ; <nl> private final Set < ResourceLocation > dummies = Sets . newHashSet ( ) ; <nl> private final Set < Integer > blocked = Sets . newHashSet ( ) ; <nl> - private final Multimap < ResourceLocation , WeakReference < V > > overrides = ArrayListMultimap . create ( ) ; <nl> + private final Multimap < ResourceLocation , V > overrides = ArrayListMultimap . create ( ) ; <nl> + private final BiMap < OverrideOwner , V > override _ owners = HashBiMap . create ( ) ; <nl> private final DummyFactory < V > dummyFactory ; <nl> private final boolean isDelegated ; <nl> private final int min ; <nl> @ @ - 78 , 7 + 81 , 6 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> this . create . onCreate ( this , stage ) ; <nl> } <nl> <nl> - <nl> @ Override <nl> public void register ( V value ) <nl> { <nl> @ @ - 228 , 6 + 230 , 13 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> <nl> int add ( int id , V value ) <nl> { <nl> + ModContainer mc = Loader . instance ( ) . activeModContainer ( ) ; <nl> + String owner = mc = = null | | ( mc instanceof InjectedModContainer & & ( ( InjectedModContainer ) mc ) . wrappedContainer instanceof FMLContainer ) ? null : mc . getModId ( ) . toLowerCase ( ) ; <nl> + return add ( id , value , owner ) ; <nl> + } <nl> + <nl> + int add ( int id , V value , String owner ) <nl> + { <nl> ResourceLocation key = value = = null ? null : value . getRegistryName ( ) ; <nl> Preconditions . checkNotNull ( key , " Can ' t use a null - name for the registry , object % s . " , value ) ; <nl> Preconditions . checkNotNull ( value , " Can ' t add null - object to the registry , name % s . " , key ) ; <nl> @ @ - 249 , 7 + 258 , 12 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> { <nl> if ( ! this . allowOverrides ) <nl> throw new IllegalArgumentException ( String . format ( " The name % s has been registered twice , for % s and % s . " , key , getRaw ( key ) , value ) ) ; <nl> + if ( owner = = null ) <nl> + throw new IllegalStateException ( String . format ( " Could not determine owner for the override on % s . Value : % s " , key , value ) ) ; <nl> + this . override _ owners . put ( new OverrideOwner ( owner , key ) , value ) ; <nl> idToUse = this . getID ( oldEntry ) ; <nl> + if ( ! this . override _ owners . containsValue ( oldEntry ) ) <nl> + this . override _ owners . put ( new OverrideOwner ( key . getResourceDomain ( ) , key ) , oldEntry ) ; <nl> } <nl> <nl> Integer foundId = this . ids . inverse ( ) . get ( value ) ; / / Is this ever possible to trigger with otherThing being different ? <nl> @ @ - 278 , 7 + 292 , 7 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> getDelegate ( value ) . setName ( key ) ; <nl> if ( oldEntry ! = null ) <nl> { <nl> - this . overrides . put ( key , new WeakReference < V > ( oldEntry ) ) ; <nl> + this . overrides . put ( key , oldEntry ) ; <nl> if ( this . stage = = RegistryManager . ACTIVE ) <nl> getDelegate ( oldEntry ) . changeReference ( value ) ; <nl> } <nl> @ @ - 348 , 16 + 362 , 8 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> for ( V value : this ) <nl> getDelegate ( value ) . changeReference ( value ) ; <nl> <nl> - Iterator < Entry < ResourceLocation , WeakReference < V > > > itr = this . overrides . entries ( ) . iterator ( ) ; <nl> - while ( itr . hasNext ( ) ) <nl> - { <nl> - Entry < ResourceLocation , WeakReference < V > > next = itr . next ( ) ; <nl> - V value = next . getValue ( ) . get ( ) ; <nl> - if ( value = = null ) <nl> - itr . remove ( ) ; <nl> - else <nl> - getDelegate ( value ) . changeReference ( value ) ; <nl> - } <nl> + for ( V value : this . overrides . values ( ) ) <nl> + getDelegate ( value ) . changeReference ( value ) ; <nl> } <nl> <nl> V getDefault ( ) <nl> @ @ - 437 , 17 + 443 , 43 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> this . names . clear ( ) ; <nl> this . availabilityMap . clear ( 0 , this . availabilityMap . length ( ) ) ; <nl> this . defaultValue = null ; <nl> + this . override _ owners . clear ( ) ; <nl> + this . override _ owners . putAll ( from . override _ owners ) ; <nl> <nl> boolean errored = false ; <nl> <nl> for ( Entry < ResourceLocation , V > entry : from . names . entrySet ( ) ) <nl> { <nl> + List < V > overrides = Lists . newArrayList ( from . overrides . get ( entry . getKey ( ) ) ) ; <nl> int id = from . getID ( entry . getKey ( ) ) ; <nl> - int realId = add ( id , entry . getValue ( ) ) ; <nl> - if ( id ! = realId & & id ! = - 1 ) <nl> + if ( overrides . isEmpty ( ) ) <nl> { <nl> - FMLLog . warning ( " Registered object did not get ID it asked for . Name : { } Type : { } Expected : { } Got : { } " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , id , realId ) ; <nl> - errored = true ; <nl> + int realId = add ( id , entry . getValue ( ) ) ; <nl> + if ( id ! = realId & & id ! = - 1 ) <nl> + { <nl> + FMLLog . warning ( " Registered object did not get ID it asked for . Name : % s Type : % s Expected : % s Got : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , id , realId ) ; <nl> + errored = true ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + overrides . add ( entry . getValue ( ) ) ; <nl> + for ( V value : overrides ) <nl> + { <nl> + OverrideOwner owner = from . override _ owners . inverse ( ) . get ( value ) ; <nl> + if ( owner = = null ) <nl> + { <nl> + FMLLog . warning ( " Registered override did not have an associated owner object . Name : % s Type : % s Value : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , value ) ; <nl> + errored = true ; <nl> + continue ; <nl> + } <nl> + int realId = add ( id , value , owner . owner ) ; <nl> + if ( id ! = realId & & id ! = - 1 ) <nl> + { <nl> + FMLLog . warning ( " Registered object did not get ID it asked for . Name : % s Type : % s Expected : % s Got : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , id , realId ) ; <nl> + errored = true ; <nl> + } <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 540 , 11 + 572 , 11 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> <nl> Collections . sort ( ids ) ; <nl> <nl> - FMLLog . finer ( " Registry Name : { } " , name ) ; <nl> + FMLLog . finer ( " Registry Name : % s " , name ) ; <nl> ids . forEach ( id - > FMLLog . finer ( " Registry : % d % s % s " , id , getKey ( getValue ( id ) ) , getValue ( id ) ) ) ; <nl> } <nl> <nl> - public void loadIds ( Map < ResourceLocation , Integer > ids , Map < ResourceLocation , Integer > missing , Map < ResourceLocation , Integer [ ] > remapped , ForgeRegistry < V > old , ResourceLocation name ) <nl> + public void loadIds ( Map < ResourceLocation , Integer > ids , Map < ResourceLocation , String > overrides , Map < ResourceLocation , Integer > missing , Map < ResourceLocation , Integer [ ] > remapped , ForgeRegistry < V > old , ResourceLocation name ) <nl> { <nl> for ( Map . Entry < ResourceLocation , Integer > entry : ids . entrySet ( ) ) <nl> { <nl> @ @ - 566 , 12 + 598 , 35 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> V obj = old . getRaw ( itemName ) ; <nl> Preconditions . checkState ( obj ! = null , " objectKey has an ID but no object . Reflection / ASM hackery ? Registry bug ? " ) ; <nl> <nl> - / / Register all overrides so new registry has the full list so we can update delegates later <nl> - old . overrides . get ( obj . getRegistryName ( ) ) . stream ( ) <nl> - . filter ( e - > e . get ( ) ! = null ) <nl> - . forEach ( e - > add ( newId , e . get ( ) ) ) ; <nl> + String primaryName = null ; <nl> + if ( ! overrides . containsKey ( itemName ) & & old . overrides . containsKey ( itemName ) ) <nl> + { <nl> + obj = old . overrides . get ( itemName ) . iterator ( ) . next ( ) ; / / Get the first one in the list , Which should be the first one registered <nl> + primaryName = old . override _ owners . inverse ( ) . get ( obj ) . owner ; <nl> + } <nl> + else <nl> + primaryName = overrides . get ( itemName ) ; <nl> + <nl> + for ( V value : old . overrides . get ( itemName ) ) <nl> + { <nl> + OverrideOwner owner = old . override _ owners . inverse ( ) . get ( value ) ; <nl> + if ( owner = = null ) <nl> + { <nl> + FMLLog . warning ( " Registered override did not have an associated owner object . Name : % s Type : % s Value : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , value ) ; <nl> + continue ; <nl> + } <nl> + <nl> + if ( primaryName . equals ( owner . owner ) ) <nl> + continue ; <nl> + <nl> + int realId = add ( newId , value , owner . owner ) ; <nl> + if ( newId ! = realId ) <nl> + FMLLog . warning ( " Registered object did not get ID it asked for . Name : % s Type : % s Expected : % s Got : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , newId , realId ) ; <nl> + } <nl> <nl> - add ( newId , obj ) ; <nl> + int realId = add ( newId , obj , primaryName = = null ? itemName . getResourceDomain ( ) : primaryName ) ; <nl> + if ( realId ! = newId ) <nl> + FMLLog . warning ( " Registered object did not get ID it asked for . Name : % s Type : % s Expected : % s Got : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , newId , realId ) ; <nl> } <nl> } <nl> <nl> @ @ - 603 , 6 + 658 , 18 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> this . aliases . forEach ( ( from , to ) - > ret . aliases . put ( from , to ) ) ; <nl> this . blocked . forEach ( id - > ret . blocked . add ( id ) ) ; <nl> this . dummies . forEach ( name - > ret . dummied . add ( name ) ) ; <nl> + ret . overrides . putAll ( getOverrideOwners ( ) ) ; <nl> + return ret ; <nl> + } <nl> + <nl> + Map < ResourceLocation , String > getOverrideOwners ( ) <nl> + { <nl> + Map < ResourceLocation , String > ret = Maps . newHashMap ( ) ; <nl> + for ( ResourceLocation key : this . overrides . keySet ( ) ) <nl> + { <nl> + V obj = this . names . get ( key ) ; <nl> + ret . put ( key , this . override _ owners . inverse ( ) . get ( obj ) . owner ) ; <nl> + } <nl> return ret ; <nl> } <nl> <nl> @ @ - 612 , 6 + 679 , 7 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> public final Map < ResourceLocation , ResourceLocation > aliases = Maps . newHashMap ( ) ; <nl> public final Set < Integer > blocked = Sets . newHashSet ( ) ; <nl> public final Set < ResourceLocation > dummied = Sets . newHashSet ( ) ; <nl> + public final Map < ResourceLocation , String > overrides = Maps . newHashMap ( ) ; <nl> } <nl> <nl> public MissingMappings < ? > getMissingEvent ( ResourceLocation name , Map < ResourceLocation , Integer > map ) <nl> @ @ - 679 , 4 + 747 , 32 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe <nl> if ( failed . isEmpty ( ) & & ignored > 0 ) <nl> FMLLog . fine ( " There were % d missing mappings that have been ignored " , ignored ) ; <nl> } <nl> + <nl> + private static class OverrideOwner <nl> + { <nl> + final String owner ; <nl> + final ResourceLocation key ; <nl> + private OverrideOwner ( String owner , ResourceLocation key ) <nl> + { <nl> + this . owner = owner ; <nl> + this . key = key ; <nl> + } <nl> + <nl> + public boolean equals ( Object o ) <nl> + { <nl> + if ( this = = o ) <nl> + return true ; <nl> + <nl> + if ( ! ( o instanceof OverrideOwner ) ) <nl> + return false ; <nl> + <nl> + OverrideOwner oo = ( OverrideOwner ) o ; <nl> + return this . owner . equals ( oo . owner ) & & this . key . equals ( oo . key ) ; <nl> + } <nl> + <nl> + public int hashCode ( ) <nl> + { <nl> + return 31 * this . key . hashCode ( ) + this . owner . hashCode ( ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / registries / GameData . java b / src / main / java / net / minecraftforge / registries / GameData . java <nl> index 95cdd87 . . 6eac605 100644 <nl> - - - a / src / main / java / net / minecraftforge / registries / GameData . java <nl> + + + b / src / main / java / net / minecraftforge / registries / GameData . java <nl> @ @ - 230 , 6 + 230 , 7 @ @ public class GameData <nl> FMLLog . warning ( " Can ' t revert to frozen GameData state without freezing first . " ) ; <nl> return ; <nl> } <nl> + RegistryManager . ACTIVE . registries . forEach ( ( name , reg ) - > reg . resetDelegates ( ) ) ; <nl> <nl> FMLLog . fine ( " Reverting to frozen data state . " ) ; <nl> for ( Map . Entry < ResourceLocation , ForgeRegistry < ? extends IForgeRegistryEntry < ? > > > r : RegistryManager . ACTIVE . registries . entrySet ( ) ) <nl> @ @ - 626 , 7 + 627 , 7 @ @ public class GameData <nl> snap . blocked . forEach ( id - > _ new . block ( id ) ) ; <nl> / / Load current dummies BEFORE the snapshot is loaded so that add ( ) will remove from the list . <nl> snap . dummied . forEach ( key - > _ new . addDummy ( key ) ) ; <nl> - _ new . loadIds ( snap . ids , missing , remaps , active , name ) ; <nl> + _ new . loadIds ( snap . ids , snap . overrides , missing , remaps , active , name ) ; <nl> } <nl> <nl> / / Another bouncer for generic reasons <nl> @ @ - 645 , 7 + 646 , 7 @ @ public class GameData <nl> ForgeRegistry < T > newRegistry = STAGING . getRegistry ( name , RegistryManager . FROZEN ) ; <nl> Map < ResourceLocation , Integer > _ new = Maps . newHashMap ( ) ; <nl> frozen . getKeys ( ) . stream ( ) . filter ( key - > ! newRegistry . containsKey ( key ) ) . forEach ( key - > _ new . put ( key , frozen . getID ( key ) ) ) ; <nl> - newRegistry . loadIds ( _ new , Maps . newLinkedHashMap ( ) , remaps , frozen , name ) ; <nl> + newRegistry . loadIds ( _ new , frozen . getOverrideOwners ( ) , Maps . newLinkedHashMap ( ) , remaps , frozen , name ) ; <nl> } <nl> <nl> public static void fireCreateRegistryEvents ( ) <nl> diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionInjectionTest . java b / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionInjectionTest . java <nl> index e1b9058 . . 68b3a1f 100644 <nl> - - - a / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionInjectionTest . java <nl> + + + b / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionInjectionTest . java <nl> @ @ - 58 , 10 + 58 , 6 @ @ public class SubstitutionInjectionTest <nl> @ Test <nl> public void testSubstitutionInjection ( ) throws Exception <nl> { <nl> - / / TODO : Decide exactly how I want to deal with subs , this test doesn ' t really do anything right now <nl> - if ( true = = Boolean . valueOf ( " true " ) . booleanValue ( ) ) <nl> - return ; <nl> - <nl> final ForgeRegistry < Block > blockRegistry = ( ForgeRegistry < Block > ) RegistryManager . ACTIVE . getRegistry ( Block . class ) ; <nl> final ForgeRegistry < Item > itemRegistry = ( ForgeRegistry < Item > ) RegistryManager . ACTIVE . getRegistry ( Item . class ) ; <nl> <nl> @ @ - 111 , 7 + 107 , 7 @ @ public class SubstitutionInjectionTest <nl> assertEquals ( " ObjectHolder didn ' t apply - Blocks and registry " , currDirt , fnd ) ; <nl> assertEquals ( " Got my dirt substitute - registry " , vanilDirt , fnd ) ; <nl> dirtitem = ( ItemBlock ) itemRegistry . getValue ( MC _ DIRT ) ; <nl> - assertEquals ( " ItemBlock points at my block " , toSub , dirtitem . getBlock ( ) ) ; <nl> + assertEquals ( " ItemBlock points at my block " , vanilDirt , dirtitem . getBlock ( ) ) ; <nl> <nl> / / TEST 3 : Does the substitute get restored when reverting to frozen state ? The substitute should be found in the registry again <nl> GameData . revertToFrozen ( ) ; <nl> @ @ - 133 , 7 + 129 , 7 @ @ public class SubstitutionInjectionTest <nl> assertEquals ( " ObjectHolder didn ' t apply - Blocks and registry " , currDirt , fnd ) ; <nl> assertEquals ( " Got my dirt substitute - registry " , vanilDirt , fnd ) ; <nl> dirtitem = ( ItemBlock ) itemRegistry . getValue ( MC _ DIRT ) ; <nl> - assertEquals ( " ItemBlock points at my block " , toSub , dirtitem . getBlock ( ) ) ; <nl> + assertEquals ( " ItemBlock points at my block " , vanilDirt , dirtitem . getBlock ( ) ) ; <nl> <nl> / / TEST 3 repeat : Does the substitute get restored when reverting to frozen state ? The substitute should be found in the registry again <nl> GameData . revertToFrozen ( ) ;
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java b / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java <nl> index 03f8e58 . . 14c05ac 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java <nl> @ @ - 30 , 9 + 30 , 9 @ @ import net . minecraft . world . storage . WorldInfo ; <nl> <nl> import org . apache . logging . log4j . Level ; <nl> <nl> - import com . google . common . collect . BiMap ; <nl> - import com . google . common . collect . HashBiMap ; <nl> + import com . google . common . collect . ImmutableSet ; <nl> import com . google . common . collect . Maps ; <nl> + import com . google . common . collect . Sets ; <nl> import com . google . common . eventbus . EventBus ; <nl> import com . google . common . eventbus . Subscribe ; <nl> <nl> @ @ - 105 , 8 + 105 , 8 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> / / name < - > id mappings <nl> NBTTagList dataList = new NBTTagList ( ) ; <nl> FMLLog . fine ( " Gathering id map for writing to world save % s " , info . getWorldName ( ) ) ; <nl> - Map < String , Integer > itemList = GameData . buildItemDataList ( ) ; <nl> - for ( Entry < String , Integer > item : itemList . entrySet ( ) ) <nl> + GameData . GameDataSnapshot dataSnapshot = GameData . buildItemDataList ( ) ; <nl> + for ( Entry < String , Integer > item : dataSnapshot . idMap . entrySet ( ) ) <nl> { <nl> NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> tag . setString ( " K " , item . getKey ( ) ) ; <nl> @ @ - 126 , 15 + 126 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> blockAliasList . appendTag ( tag ) ; <nl> } <nl> fmlData . setTag ( " BlockAliases " , blockAliasList ) ; <nl> - NBTTagList blockPersistentAliasList = new NBTTagList ( ) ; <nl> - for ( Entry < String , String > entry : GameData . getBlockRegistry ( ) . getPersistentAliases ( ) . entrySet ( ) ) <nl> + NBTTagList blockSubstitutionsList = new NBTTagList ( ) ; <nl> + for ( String entry : dataSnapshot . blockSubstitutions ) <nl> { <nl> NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> - tag . setString ( " K " , entry . getKey ( ) ) ; <nl> - tag . setString ( " V " , entry . getValue ( ) ) ; <nl> - blockPersistentAliasList . appendTag ( tag ) ; <nl> + tag . setString ( " K " , entry ) ; <nl> + blockSubstitutionsList . appendTag ( tag ) ; <nl> } <nl> - fmlData . setTag ( " PersistentBlockAliases " , blockPersistentAliasList ) ; <nl> + fmlData . setTag ( " BlockSubstitutions " , blockSubstitutionsList ) ; <nl> / / item aliases <nl> NBTTagList itemAliasList = new NBTTagList ( ) ; <nl> for ( Entry < String , String > entry : GameData . getItemRegistry ( ) . getAliases ( ) . entrySet ( ) ) <nl> @ @ - 146 , 15 + 145 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> } <nl> fmlData . setTag ( " ItemAliases " , itemAliasList ) ; <nl> <nl> - NBTTagList itemPersistentAliasList = new NBTTagList ( ) ; <nl> - for ( Entry < String , String > entry : GameData . getItemRegistry ( ) . getPersistentAliases ( ) . entrySet ( ) ) <nl> + NBTTagList itemSubstitutionsList = new NBTTagList ( ) ; <nl> + for ( String entry : dataSnapshot . itemSubstitutions ) <nl> { <nl> NBTTagCompound tag = new NBTTagCompound ( ) ; <nl> - tag . setString ( " K " , entry . getKey ( ) ) ; <nl> - tag . setString ( " V " , entry . getValue ( ) ) ; <nl> - itemPersistentAliasList . appendTag ( tag ) ; <nl> + tag . setString ( " K " , entry ) ; <nl> + itemSubstitutionsList . appendTag ( tag ) ; <nl> } <nl> - fmlData . setTag ( " ItemPersistentAliases " , itemPersistentAliasList ) ; <nl> + fmlData . setTag ( " ItemSubstitutions " , itemSubstitutionsList ) ; <nl> return fmlData ; <nl> } <nl> <nl> @ @ - 209 , 7 + 207 , 7 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> dataList . put ( itemLabel , itemId ) ; <nl> } <nl> } <nl> - failedElements = GameData . injectWorldIDMap ( dataList , true , true ) ; <nl> + failedElements = GameData . injectWorldIDMap ( dataList , ImmutableSet . < String > of ( ) , ImmutableSet . < String > of ( ) , true , true ) ; <nl> <nl> } <nl> else if ( tag . hasKey ( " ItemData " ) ) <nl> @ @ - 245 , 14 + 243 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; <nl> blockAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; <nl> } <nl> - BiMap < String , String > blockPersistentAliases = HashBiMap . create ( ) ; <nl> - if ( tag . hasKey ( " BlockPersistentAliases " , 10 ) ) <nl> + Set < String > blockSubstitutions = Sets . newHashSet ( ) ; <nl> + if ( tag . hasKey ( " BlockSubstitutions " , 9 ) ) <nl> { <nl> - list = tag . getTagList ( " BlockPersistentAliases " , 10 ) ; <nl> + list = tag . getTagList ( " BlockSubstitutions " , 10 ) ; <nl> for ( int i = 0 ; i < list . tagCount ( ) ; i + + ) <nl> { <nl> NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; <nl> - blockPersistentAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; <nl> + blockSubstitutions . add ( dataTag . getString ( " K " ) ) ; <nl> } <nl> } <nl> / / item aliases <nl> @ @ - 264 , 17 + 262 , 17 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai <nl> itemAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; <nl> } <nl> <nl> - BiMap < String , String > itemPersistentAliases = HashBiMap . create ( ) ; <nl> - if ( tag . hasKey ( " ItemPersistentAliases " , 10 ) ) <nl> + Set < String > itemSubstitutions = Sets . newHashSet ( ) ; <nl> + if ( tag . hasKey ( " ItemSubstitutions " , 9 ) ) <nl> { <nl> - list = tag . getTagList ( " ItemPersistentAliases " , 10 ) ; <nl> + list = tag . getTagList ( " ItemSubstitutions " , 10 ) ; <nl> for ( int i = 0 ; i < list . tagCount ( ) ; i + + ) <nl> { <nl> NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; <nl> - itemPersistentAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; <nl> + itemSubstitutions . add ( dataTag . getString ( " K " ) ) ; <nl> } <nl> } <nl> - failedElements = GameData . injectWorldIDMap ( dataList , blockedIds , blockAliases , itemAliases , true , true ) ; <nl> + failedElements = GameData . injectWorldIDMap ( dataList , blockedIds , blockAliases , itemAliases , blockSubstitutions , itemSubstitutions , true , true ) ; <nl> } <nl> <nl> if ( failedElements ! = null & & ! failedElements . isEmpty ( ) ) <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / event / FMLMissingMappingsEvent . java b / fml / src / main / java / cpw / mods / fml / common / event / FMLMissingMappingsEvent . java <nl> index fdaac1d . . 94ea8e3 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / event / FMLMissingMappingsEvent . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / event / FMLMissingMappingsEvent . java <nl> @ @ - 32 , 7 + 32 , 28 @ @ public class FMLMissingMappingsEvent extends FMLEvent { <nl> * @ author cpw <nl> * <nl> * / <nl> - public static enum Action { DEFAULT , IGNORE , WARN , FAIL , REMAP } <nl> + public static enum Action { <nl> + / * * <nl> + * Take the default action <nl> + * / <nl> + DEFAULT , <nl> + / * * <nl> + * Ignore this missing mapping . This means the mapping will be abandoned <nl> + * / <nl> + IGNORE , <nl> + / * * <nl> + * Generate a warning but allow loading to continue <nl> + * / <nl> + WARN , <nl> + / * * <nl> + * Fail to load <nl> + * / <nl> + FAIL , <nl> + / * * <nl> + * Remap this name to a new name ( add a migration mapping ) <nl> + * / <nl> + REMAP <nl> + } <nl> public static class MissingMapping { <nl> public final GameRegistry . Type type ; <nl> public final String name ; <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> index d463939 . . 12ed5f3 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java <nl> @ @ - 85 , 7 + 85 , 7 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > <nl> public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) <nl> { <nl> FMLHandshakeMessage . ModIdData modIds = ( FMLHandshakeMessage . ModIdData ) msg ; <nl> - List < String > locallyMissing = GameData . injectWorldIDMap ( modIds . dataList ( ) , false , false ) ; <nl> + List < String > locallyMissing = GameData . injectWorldIDMap ( modIds . dataList ( ) , modIds . blockSubstitutions ( ) , modIds . itemSubstitutions ( ) , false , false ) ; <nl> if ( ! locallyMissing . isEmpty ( ) ) <nl> { <nl> NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> index 1c440fe . . d998703 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java <nl> @ @ - 13 , 11 + 13 , 13 @ @ import com . google . common . base . Charsets ; <nl> import com . google . common . base . Joiner ; <nl> import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Maps ; <nl> + import com . google . common . collect . Sets ; <nl> <nl> import cpw . mods . fml . common . ModContainer ; <nl> import cpw . mods . fml . common . network . ByteBufUtils ; <nl> import cpw . mods . fml . common . network . NetworkRegistry ; <nl> import cpw . mods . fml . common . network . internal . FMLProxyPacket ; <nl> + import cpw . mods . fml . common . registry . GameData ; <nl> <nl> public abstract class FMLHandshakeMessage { <nl> public static FMLProxyPacket makeCustomChannelRegistration ( Set < String > channels ) <nl> @ @ - 128 , 22 + 130 , 43 @ @ public abstract class FMLHandshakeMessage { <nl> <nl> } <nl> <nl> - public ModIdData ( Map < String , Integer > modIds ) <nl> + public ModIdData ( GameData . GameDataSnapshot snapshot ) <nl> { <nl> - this . modIds = modIds ; <nl> + this . modIds = snapshot . idMap ; <nl> + this . blockSubstitutions = snapshot . blockSubstitutions ; <nl> + this . itemSubstitutions = snapshot . itemSubstitutions ; <nl> } <nl> <nl> private Map < String , Integer > modIds ; <nl> + private Set < String > blockSubstitutions ; <nl> + private Set < String > itemSubstitutions ; <nl> @ Override <nl> public void fromBytes ( ByteBuf buffer ) <nl> { <nl> int length = ByteBufUtils . readVarInt ( buffer , 3 ) ; <nl> modIds = Maps . newHashMap ( ) ; <nl> + blockSubstitutions = Sets . newHashSet ( ) ; <nl> + itemSubstitutions = Sets . newHashSet ( ) ; <nl> <nl> for ( int i = 0 ; i < length ; i + + ) <nl> { <nl> modIds . put ( ByteBufUtils . readUTF8String ( buffer ) , ByteBufUtils . readVarInt ( buffer , 3 ) ) ; <nl> } <nl> + / / we don ' t have any more data to read <nl> + if ( ! buffer . isReadable ( ) ) <nl> + { <nl> + return ; <nl> + } <nl> + length = ByteBufUtils . readVarInt ( buffer , 3 ) ; <nl> + for ( int i = 0 ; i < length ; i + + ) <nl> + { <nl> + blockSubstitutions . add ( ByteBufUtils . readUTF8String ( buffer ) ) ; <nl> + } <nl> + length = ByteBufUtils . readVarInt ( buffer , 3 ) ; <nl> + for ( int i = 0 ; i < length ; i + + ) <nl> + { <nl> + itemSubstitutions . add ( ByteBufUtils . readUTF8String ( buffer ) ) ; <nl> + } <nl> } <nl> <nl> @ Override <nl> @ @ - 155 , 12 + 178 , 33 @ @ public abstract class FMLHandshakeMessage { <nl> ByteBufUtils . writeUTF8String ( buffer , entry . getKey ( ) ) ; <nl> ByteBufUtils . writeVarInt ( buffer , entry . getValue ( ) , 3 ) ; <nl> } <nl> + <nl> + ByteBufUtils . writeVarInt ( buffer , blockSubstitutions . size ( ) , 3 ) ; <nl> + for ( String entry : blockSubstitutions ) <nl> + { <nl> + ByteBufUtils . writeUTF8String ( buffer , entry ) ; <nl> + } <nl> + ByteBufUtils . writeVarInt ( buffer , blockSubstitutions . size ( ) , 3 ) ; <nl> + <nl> + for ( String entry : itemSubstitutions ) <nl> + { <nl> + ByteBufUtils . writeUTF8String ( buffer , entry ) ; <nl> + } <nl> } <nl> <nl> public Map < String , Integer > dataList ( ) <nl> { <nl> return modIds ; <nl> } <nl> + public Set < String > blockSubstitutions ( ) <nl> + { <nl> + return blockSubstitutions ; <nl> + } <nl> + public Set < String > itemSubstitutions ( ) <nl> + { <nl> + return itemSubstitutions ; <nl> + } <nl> + <nl> @ Override <nl> public String toString ( Class < ? extends Enum < ? > > side ) <nl> { <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java <nl> deleted file mode 100644 <nl> index aedd66b . . 0000000 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java <nl> + + + / dev / null <nl> @ @ - 1 , 9 + 0 , 0 @ @ <nl> - package cpw . mods . fml . common . registry ; <nl> - <nl> - public class ExistingAliasException extends Exception { <nl> - public ExistingAliasException ( String fromName , String toName ) { <nl> - } <nl> - <nl> - private static final long serialVersionUID = 1L ; <nl> - <nl> - } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ExistingSubstitutionException . java b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingSubstitutionException . java <nl> new file mode 100644 <nl> index 0000000 . . ec8f614 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingSubstitutionException . java <nl> @ @ - 0 , 0 + 1 , 9 @ @ <nl> + package cpw . mods . fml . common . registry ; <nl> + <nl> + public class ExistingSubstitutionException extends Exception { <nl> + public ExistingSubstitutionException ( String fromName , Object toReplace ) { <nl> + } <nl> + <nl> + private static final long serialVersionUID = 1L ; <nl> + <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> index 8503c51 . . ec4af98 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> @ @ - 15 , 7 + 15 , 6 @ @ import net . minecraft . util . RegistryNamespaced ; <nl> <nl> import com . google . common . collect . BiMap ; <nl> import com . google . common . collect . HashBiMap ; <nl> - import com . google . common . collect . ImmutableBiMap ; <nl> import com . google . common . collect . ImmutableMap ; <nl> <nl> import cpw . mods . fml . common . FMLLog ; <nl> @ @ - 31 , 7 + 30 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> / / aliases redirecting legacy names to the actual name , may need recursive application to find the final name . <nl> / / these need to be registry specific , it ' s possible to only have a loosely linked item for a block which may get renamed by itself . <nl> private final Map < String , String > aliases = new HashMap < String , String > ( ) ; <nl> - private BiMap < String , String > persistentAliases = HashBiMap . create ( ) ; <nl> + private BiMap < String , I > persistentSubstitutions ; <nl> + private BiMap < String , I > activeSubstitutions = HashBiMap . create ( ) ; <nl> <nl> FMLControlledNamespacedRegistry ( String optionalDefault , int maxIdValue , int minIdValue , Class < I > type , char discriminator ) <nl> { <nl> @ @ - 62 , 9 + 62 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> / / id - > obj lookup is inconsistent <nl> if ( getRaw ( id ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for id % d , name % s , doesn ' t yield the expected % s % s . " , id , name , type , obj ) ) ; <nl> / / name - > obj lookup is inconsistent <nl> - if ( getRaw ( name ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for name % s , id % d , doesn ' t yield the expected % s % s . " , name , id , type , obj ) ) ; <nl> + if ( ! ( activeSubstitutions . containsKey ( name ) | | activeSubstitutions . containsValue ( name ) ) & & getRaw ( name ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for name % s , id % d , doesn ' t yield the expected % s % s . " , name , id , type , obj ) ) ; <nl> / / name - > id lookup is inconsistent <nl> - if ( getId ( name ) ! = id ) throw new IllegalStateException ( String . format ( " Registry entry for name % s doesn ' t yield the expected id % d . " , name , id ) ) ; <nl> + if ( ! ( activeSubstitutions . containsKey ( name ) | | activeSubstitutions . containsValue ( name ) ) & & getId ( name ) ! = id ) throw new IllegalStateException ( String . format ( " Registry entry for name % s doesn ' t yield the expected id % d . " , name , id ) ) ; <nl> / / id isn ' t marked as unavailable <nl> if ( ! availabilityMap . get ( id ) ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , id % d , name % s , marked as empty . " , type , obj , id , name ) ) ; <nl> / / entry is blocked , thus should be empty <nl> @ @ - 235 , 9 + 235 , 6 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> * / <nl> public I getRaw ( String name ) <nl> { <nl> - String aliasName = persistentAliases . get ( name ) ; <nl> - name = aliasName ! = null ? aliasName : name ; <nl> - <nl> I ret = superType . cast ( super . getObject ( name ) ) ; <nl> <nl> if ( ret = = null ) / / no match , try aliases recursively <nl> @ @ - 322 , 10 + 319 , 6 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> return ImmutableMap . copyOf ( aliases ) ; <nl> } <nl> <nl> - public Map < String , String > getPersistentAliases ( ) <nl> - { <nl> - return ImmutableBiMap . copyOf ( persistentAliases ) ; <nl> - } <nl> / * * <nl> * Add the specified object to the registry . <nl> * <nl> @ @ - 345 , 7 + 338 , 10 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> { <nl> this . optionalDefaultObject = thing ; <nl> } <nl> - <nl> + if ( getPersistentSubstitutions ( ) . containsValue ( thing ) ) <nl> + { <nl> + throw new IllegalArgumentException ( String . format ( " The object % s ( % s ) cannot be added to the registry . It is already being used as a substitute for % s " , thing . getClass ( ) , name , getPersistentSubstitutions ( ) . inverse ( ) . get ( thing ) ) ) ; <nl> + } <nl> int idToUse = id ; <nl> if ( idToUse < 0 | | availabilityMap . get ( idToUse ) ) <nl> { <nl> @ @ - 365 , 7 + 361 , 7 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> { <nl> throw new IllegalArgumentException ( String . format ( " The name % s has been registered twice , for % s and % s . " , name , getRaw ( name ) , thing ) ) ; <nl> } <nl> - if ( getId ( thing ) > = 0 ) / / duplicate object <nl> + if ( getId ( thing ) > = 0 ) / / duplicate object - but only if it ' s not being substituted <nl> { <nl> int foundId = getId ( thing ) ; <nl> Object otherThing = getRaw ( foundId ) ; <nl> @ @ - 376 , 6 + 372 , 10 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> FMLLog . bigWarning ( " The object % s ( name % s ) is being added too late . " , thing , name ) ; <nl> } <nl> <nl> + if ( activeSubstitutions . containsKey ( name ) ) <nl> + { <nl> + thing = activeSubstitutions . get ( name ) ; <nl> + } <nl> addObjectRaw ( idToUse , name , thing ) ; <nl> <nl> FMLLog . finer ( " Registry add : % s % d % s ( req . id % d ) " , name , idToUse , thing , id ) ; <nl> @ @ - 394 , 7 + 394 , 13 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> <nl> for ( I thing : this . typeSafeIterable ( ) ) <nl> { <nl> - if ( ! registry . field _ 148758 _ b . containsKey ( thing ) ) ret . put ( getNameForObject ( thing ) , getId ( thing ) ) ; <nl> + if ( ! registry . field _ 148758 _ b . containsKey ( thing ) ) <nl> + { <nl> + if ( ! registry . activeSubstitutions . containsKey ( getNameForObject ( thing ) ) ) <nl> + { <nl> + ret . put ( getNameForObject ( thing ) , getId ( thing ) ) ; <nl> + } <nl> + } <nl> } <nl> <nl> return ret ; <nl> @ @ - 441 , 11 + 447 , 54 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> return GameData . buildDelegate ( thing , clazz ) ; <nl> } <nl> <nl> - public void addPersistentAlias ( String fromName , String toName ) throws ExistingAliasException { <nl> - if ( persistentAliases . containsKey ( fromName ) | | persistentAliases . containsKey ( toName ) | | persistentAliases . containsValue ( fromName ) | | persistentAliases . containsValue ( toName ) ) <nl> + void activateSubstitution ( String nameToReplace ) <nl> + { <nl> + if ( getPersistentSubstitutions ( ) . containsKey ( nameToReplace ) ) <nl> + { <nl> + activeSubstitutions . put ( nameToReplace , getPersistentSubstitutions ( ) . get ( nameToReplace ) ) ; <nl> + } <nl> + } <nl> + <nl> + public void addSubstitutionAlias ( String modId , String nameToReplace , Object toReplace ) throws ExistingSubstitutionException { <nl> + if ( getPersistentSubstitutions ( ) . containsKey ( nameToReplace ) | | getPersistentSubstitutions ( ) . containsValue ( toReplace ) ) <nl> + { <nl> + FMLLog . severe ( " The substitution of % s has already occured . You cannot duplicate substitutions " , nameToReplace ) ; <nl> + throw new ExistingSubstitutionException ( nameToReplace , toReplace ) ; <nl> + } <nl> + I replacement = superType . cast ( toReplace ) ; <nl> + I original = getRaw ( nameToReplace ) ; <nl> + if ( ! original . getClass ( ) . isAssignableFrom ( replacement . getClass ( ) ) ) <nl> + { <nl> + FMLLog . severe ( " The substitute % s for % s ( type % s ) is type incompatible . This won ' t work " , replacement . getClass ( ) . getName ( ) , nameToReplace , original . getClass ( ) . getName ( ) ) ; <nl> + throw new IncompatibleSubstitutionException ( nameToReplace , replacement , original ) ; <nl> + } <nl> + int existingId = getId ( replacement ) ; <nl> + if ( existingId ! = - 1 ) <nl> + { <nl> + FMLLog . severe ( " The substitute % s for % s is registered into the game independently . This won ' t work " , replacement . getClass ( ) . getName ( ) , nameToReplace ) ; <nl> + throw new IllegalArgumentException ( " The object substitution is already registered . This won ' t work " ) ; <nl> + } <nl> + getPersistentSubstitutions ( ) . put ( nameToReplace , replacement ) ; <nl> + } <nl> + <nl> + public void serializeSubstitutions ( Set < String > blockSubs ) <nl> + { <nl> + blockSubs . addAll ( activeSubstitutions . keySet ( ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int getIDForObject ( Object p _ 148757 _ 1 _ ) <nl> + { <nl> + <nl> + int id = super . getIDForObject ( p _ 148757 _ 1 _ ) ; <nl> + return id ; <nl> + } <nl> + private BiMap < String , I > getPersistentSubstitutions ( ) <nl> + { <nl> + if ( persistentSubstitutions = = null ) <nl> { <nl> - throw new ExistingAliasException ( fromName , toName ) ; <nl> + persistentSubstitutions = GameData . getMain ( ) . getPersistentSubstitutionMap ( superType ) ; <nl> } <nl> - persistentAliases . put ( fromName , toName ) ; <nl> + return persistentSubstitutions ; <nl> } <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> index 5394989 . . 816ab0e 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> @ @ - 34 , 11 + 34 , 14 @ @ import org . apache . logging . log4j . Level ; <nl> import com . google . common . base . Charsets ; <nl> import com . google . common . base . Joiner ; <nl> import com . google . common . base . Joiner . MapJoiner ; <nl> + import com . google . common . collect . BiMap ; <nl> import com . google . common . collect . HashBasedTable ; <nl> + import com . google . common . collect . HashBiMap ; <nl> import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . ImmutableListMultimap ; <nl> import com . google . common . collect . Lists ; <nl> import com . google . common . collect . Maps ; <nl> + import com . google . common . collect . Sets ; <nl> import com . google . common . collect . Table ; <nl> import com . google . common . io . Files ; <nl> <nl> @ @ - 112 , 12 + 115 , 27 @ @ public class GameData { <nl> <nl> / / internal from here <nl> <nl> - public static Map < String , Integer > buildItemDataList ( ) <nl> + public static class GameDataSnapshot { <nl> + public final Map < String , Integer > idMap ; <nl> + public final Set < String > blockSubstitutions ; <nl> + public final Set < String > itemSubstitutions ; <nl> + public GameDataSnapshot ( Map < String , Integer > idMap , Set < String > blockSubstitutions , Set < String > itemSubstitutions ) <nl> + { <nl> + this . idMap = idMap ; <nl> + this . blockSubstitutions = blockSubstitutions ; <nl> + this . itemSubstitutions = itemSubstitutions ; <nl> + } <nl> + } <nl> + public static GameDataSnapshot buildItemDataList ( ) <nl> { <nl> Map < String , Integer > idMapping = Maps . newHashMap ( ) ; <nl> getMain ( ) . iBlockRegistry . serializeInto ( idMapping ) ; <nl> getMain ( ) . iItemRegistry . serializeInto ( idMapping ) ; <nl> - return idMapping ; <nl> + Set < String > blockSubs = Sets . newHashSet ( ) ; <nl> + getMain ( ) . iBlockRegistry . serializeSubstitutions ( blockSubs ) ; <nl> + Set < String > itemSubs = Sets . newHashSet ( ) ; <nl> + getMain ( ) . iItemRegistry . serializeSubstitutions ( itemSubs ) ; <nl> + return new GameDataSnapshot ( idMapping , blockSubs , itemSubs ) ; <nl> } <nl> <nl> public static int [ ] getBlockedIds ( ) <nl> @ @ - 407 , 12 + 425 , 12 @ @ public class GameData { <nl> blockedIds . addAll ( newBlockedIds ) ; <nl> } <nl> <nl> - public static List < String > injectWorldIDMap ( Map < String , Integer > dataList , boolean injectFrozenData , boolean isLocalWorld ) <nl> + public static List < String > injectWorldIDMap ( Map < String , Integer > dataList , Set < String > blockSubstitutions , Set < String > itemSubstitutions , boolean injectFrozenData , boolean isLocalWorld ) <nl> { <nl> - return injectWorldIDMap ( dataList , new HashSet < Integer > ( ) , new HashMap < String , String > ( ) , new HashMap < String , String > ( ) , injectFrozenData , isLocalWorld ) ; <nl> + return injectWorldIDMap ( dataList , new HashSet < Integer > ( ) , new HashMap < String , String > ( ) , new HashMap < String , String > ( ) , blockSubstitutions , itemSubstitutions , injectFrozenData , isLocalWorld ) ; <nl> } <nl> <nl> - public static List < String > injectWorldIDMap ( Map < String , Integer > dataList , Set < Integer > blockedIds , Map < String , String > blockAliases , Map < String , String > itemAliases , boolean injectFrozenData , boolean isLocalWorld ) <nl> + public static List < String > injectWorldIDMap ( Map < String , Integer > dataList , Set < Integer > blockedIds , Map < String , String > blockAliases , Map < String , String > itemAliases , Set < String > blockSubstitutions , Set < String > itemSubstitutions , boolean injectFrozenData , boolean isLocalWorld ) <nl> { <nl> FMLLog . info ( " Injecting existing block and item data into this % s instance " , FMLCommonHandler . instance ( ) . getEffectiveSide ( ) . isServer ( ) ? " server " : " client " ) ; <nl> Map < String , Integer [ ] > remaps = Maps . newHashMap ( ) ; <nl> @ @ - 438 , 6 + 456 , 31 @ @ public class GameData { <nl> newData . iItemRegistry . addAlias ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> } <nl> <nl> + for ( String entry : blockSubstitutions ) <nl> + { <nl> + newData . iBlockRegistry . activateSubstitution ( entry ) ; <nl> + } <nl> + for ( String entry : itemSubstitutions ) <nl> + { <nl> + newData . iItemRegistry . activateSubstitution ( entry ) ; <nl> + } <nl> + if ( injectFrozenData ) <nl> + { <nl> + for ( String newBlockSubstitution : getMain ( ) . blockSubstitutions . keySet ( ) ) <nl> + { <nl> + if ( ! blockSubstitutions . contains ( newBlockSubstitution ) ) <nl> + { <nl> + newData . iBlockRegistry . activateSubstitution ( newBlockSubstitution ) ; <nl> + } <nl> + } <nl> + for ( String newItemSubstitution : getMain ( ) . itemSubstitutions . keySet ( ) ) <nl> + { <nl> + if ( ! itemSubstitutions . contains ( newItemSubstitution ) ) <nl> + { <nl> + newData . iItemRegistry . activateSubstitution ( newItemSubstitution ) ; <nl> + } <nl> + } <nl> + } <nl> / / process blocks and items in the world , blocks in the first pass , items in the second <nl> / / blocks need to be added first for proper ItemBlock handling <nl> for ( int pass = 0 ; pass < 2 ; pass + + ) <nl> @ @ - 479 , 10 + 522 , 11 @ @ public class GameData { <nl> <nl> if ( currId ! = newId ) <nl> { <nl> - throw new IllegalStateException ( String . format ( " Can ' t map % s % s to id % d , already occupied by % s , blocked % b , ItemBlock % b " , <nl> + throw new IllegalStateException ( String . format ( " Can ' t map % s % s to id % d ( seen at : % d ) , already occupied by % s , blocked % b , ItemBlock % b " , <nl> isBlock ? " block " : " item " , <nl> itemName , <nl> newId , <nl> + currId , <nl> isBlock ? newData . iBlockRegistry . getRaw ( newId ) : newData . iItemRegistry . getRaw ( newId ) , <nl> newData . blockedIds . contains ( newId ) , <nl> isBlock ? false : ( getMain ( ) . iItemRegistry . getRaw ( currId ) instanceof ItemBlock ) ) ) ; <nl> @ @ - 763 , 6 + 807 , 10 @ @ public class GameData { <nl> if ( item instanceof ItemBlock ) / / ItemBlock , adjust id and clear the slot already occupied by the corresponding block <nl> { <nl> Block block = ( ( ItemBlock ) item ) . field _ 150939 _ a ; <nl> + if ( idHint ! = - 1 & & getMain ( ) . blockSubstitutions . containsKey ( name ) ) <nl> + { <nl> + block = getMain ( ) . blockSubstitutions . get ( name ) ; <nl> + } <nl> int id = iBlockRegistry . getId ( block ) ; <nl> <nl> if ( id = = - 1 ) / / ItemBlock before its Block <nl> @ @ - 948 , 13 + 996 , 32 @ @ public class GameData { <nl> <nl> FMLLog . fine ( " Registry consistency check successful " ) ; <nl> } <nl> - <nl> - void registerPersistentAlias ( String fromName , String toName , GameRegistry . Type type ) throws ExistingAliasException <nl> + <nl> + void registerSubstitutionAlias ( String nameToSubstitute , Type type , Object toReplace ) throws ExistingSubstitutionException <nl> { <nl> - type . getRegistry ( ) . addPersistentAlias ( fromName , toName ) ; <nl> + type . getRegistry ( ) . addSubstitutionAlias ( Loader . instance ( ) . activeModContainer ( ) . getModId ( ) , nameToSubstitute , toReplace ) ; <nl> } <nl> static < T > RegistryDelegate < T > buildDelegate ( T referant , Class < T > type ) <nl> { <nl> return new RegistryDelegate . Delegate < T > ( referant , type ) ; <nl> } <nl> + <nl> + private BiMap < String , Item > itemSubstitutions = HashBiMap . create ( ) ; <nl> + private BiMap < String , Block > blockSubstitutions = HashBiMap . create ( ) ; <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + < T > BiMap < String , T > getPersistentSubstitutionMap ( Class < T > type ) <nl> + { <nl> + if ( type . equals ( Item . class ) ) <nl> + { <nl> + return ( BiMap < String , T > ) itemSubstitutions ; <nl> + } <nl> + else if ( type . equals ( Block . class ) ) <nl> + { <nl> + return ( BiMap < String , T > ) blockSubstitutions ; <nl> + } <nl> + else <nl> + { <nl> + throw new RuntimeException ( " WHAT ? " ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> index 6a26bb3 . . 093ef06 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java <nl> @ @ - 146 , 18 + 146 , 19 @ @ public class GameRegistry <nl> <nl> <nl> / * * <nl> - * Add a forced persistent alias for the block or item to another block or item . This will have <nl> - * the effect of using the substituted block or item instead of the original , whereever it is <nl> + * Add a forced persistent substitution alias for the block or item to another block or item . This will have <nl> + * the effect of using the substituted block or item instead of the original , where ever it is <nl> * referenced . <nl> - * <nl> - * @ param toName The name to link to ( this is the NEW block or item ) <nl> - * @ param fromName The name to link from ( this is the OLD block or item being substituted ) <nl> + * <nl> + * @ param nameToSubstitute The name to link to ( this is the NEW block or item ) <nl> * @ param type The type ( Block or Item ) <nl> - * @ throws ExistingAliasException if someone else has already registered an alias either from or to one of the names <nl> + * @ param object a NEW instance that is type compatible with the existing instance <nl> + * @ throws ExistingSubstitutionException if someone else has already registered an alias either from or to one of the names <nl> + * @ throws IncompatibleSubstitutionException if the substitution is incompatible <nl> * / <nl> - public static void addAlias ( String toName , String fromName , GameRegistry . Type type ) throws ExistingAliasException <nl> + public static void addSubstitutionAlias ( String nameToSubstitute , GameRegistry . Type type , Object object ) throws ExistingSubstitutionException <nl> { <nl> - GameData . getMain ( ) . registerPersistentAlias ( fromName , toName , type ) ; <nl> + GameData . getMain ( ) . registerSubstitutionAlias ( nameToSubstitute , type , object ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 406 , 7 + 407 , 7 @ @ public class GameRegistry <nl> } <nl> } <nl> <nl> - public static enum Type { <nl> + public static enum Type { <nl> BLOCK <nl> { <nl> @ Override <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / IncompatibleSubstitutionException . java b / fml / src / main / java / cpw / mods / fml / common / registry / IncompatibleSubstitutionException . java <nl> new file mode 100644 <nl> index 0000000 . . c4d2114 <nl> - - - / dev / null <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / IncompatibleSubstitutionException . java <nl> @ @ - 0 , 0 + 1 , 10 @ @ <nl> + package cpw . mods . fml . common . registry ; <nl> + <nl> + public class IncompatibleSubstitutionException extends RuntimeException { <nl> + public IncompatibleSubstitutionException ( String fromName , Object replacement , Object original ) <nl> + { <nl> + } <nl> + <nl> + private static final long serialVersionUID = 1L ; <nl> + <nl> + } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / RegistryDelegate . java b / fml / src / main / java / cpw / mods / fml / common / registry / RegistryDelegate . java <nl> index 8112286 . . 64db87a 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / RegistryDelegate . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / RegistryDelegate . java <nl> @ @ - 1 , 29 + 1 , 53 @ @ <nl> package cpw . mods . fml . common . registry ; <nl> <nl> + import com . google . common . base . Objects ; <nl> + <nl> <nl> / * * <nl> * A registry delegate for holding references to items or blocks <nl> - * <nl> + * These should be safe to use in things like lists though aliased items and blocks will not <nl> + * have object identity with respect to their delegate . <nl> + * <nl> * @ author cpw <nl> * <nl> * @ param < T > the type of thing we ' re holding onto <nl> * / <nl> public interface RegistryDelegate < T > { <nl> + / * * <nl> + * Get the referent pointed at by this delegate . This will be the currently active item or block , and will change <nl> + * as world saves come and go . Note that item . delegate . get ( ) may NOT be the same object as item , due to item and <nl> + * block substitution . <nl> + * <nl> + * @ return The referred object <nl> + * / <nl> T get ( ) ; <nl> + <nl> + / * * <nl> + * Get the name of this delegate . This is completely static after registration has completed and will never change . <nl> + * @ return The name <nl> + * / <nl> String name ( ) ; <nl> + <nl> + / * * <nl> + * Get the delegate type . It will be Item or Block . <nl> + * @ return The type of delegate <nl> + * / <nl> Class < T > type ( ) ; <nl> - <nl> + <nl> + / * <nl> + * This is the internal implementation class of the delegate . <nl> + * / <nl> final class Delegate < T > implements RegistryDelegate < T > <nl> { <nl> private T referant ; <nl> private String name ; <nl> private final Class < T > type ; <nl> - <nl> + <nl> public Delegate ( T referant , Class < T > type ) { <nl> this . referant = referant ; <nl> this . type = type ; <nl> } <nl> - <nl> + <nl> @ Override <nl> public T get ( ) { <nl> return referant ; <nl> @ @ - 34 , 19 + 58 , 37 @ @ public interface RegistryDelegate < T > { <nl> return name ; <nl> } <nl> <nl> + @ Override <nl> public Class < T > type ( ) <nl> { <nl> return this . type ; <nl> } <nl> - <nl> + <nl> void changeReference ( T newTarget ) <nl> { <nl> this . referant = newTarget ; <nl> } <nl> - <nl> + <nl> void setName ( String name ) <nl> { <nl> this . name = name ; <nl> } <nl> + <nl> + @ Override <nl> + public boolean equals ( Object obj ) <nl> + { <nl> + if ( obj instanceof Delegate ) <nl> + { <nl> + Delegate < ? > other = ( Delegate < ? > ) obj ; <nl> + return Objects . equal ( other . name , name ) ; <nl> + } <nl> + return false ; <nl> + } <nl> + <nl> + @ Override <nl> + public int hashCode ( ) <nl> + { <nl> + return Objects . hashCode ( name ) ; <nl> + } <nl> } <nl> }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 index e62741a . . c400684 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / FMLContainer . java 
 @ @ - 147 , 6 + 147 , 16 @ @ public final class FMLContainer extends DummyModContainer implements WorldAccess 
 } 
 data . setTag ( " aliases " , aliases ) ; 
 
 + NBTTagList overrides = new NBTTagList ( ) ; 
 + for ( Entry < ResourceLocation , String > entry : e . getValue ( ) . overrides . entrySet ( ) ) 
 + { 
 + NBTTagCompound tag = new NBTTagCompound ( ) ; 
 + tag . setString ( " K " , entry . getKey ( ) . toString ( ) ) ; 
 + tag . setString ( " V " , entry . getValue ( ) . toString ( ) ) ; 
 + aliases . appendTag ( tag ) ; 
 + } 
 + data . setTag ( " overrides " , overrides ) ; 
 + 
 int [ ] blocked = new int [ e . getValue ( ) . blocked . size ( ) ] ; 
 int idx = 0 ; 
 for ( Integer i : e . getValue ( ) . blocked ) 
 diff - - git a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java 
 index efac5f2 . . 88f95a2 100644 
 - - - a / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java 
 + + + b / src / main / java / net / minecraftforge / fml / common / network / handshake / FMLHandshakeMessage . java 
 @ @ - 184 , 12 + 184 , 14 @ @ public abstract class FMLHandshakeMessage { 
 this . name = name ; 
 this . ids = entry . ids ; 
 this . dummied = entry . dummied ; 
 + this . overrides = entry . overrides ; 
 } 
 
 private boolean hasMore ; 
 private ResourceLocation name ; 
 private Map < ResourceLocation , Integer > ids ; 
 private Set < ResourceLocation > dummied ; 
 + private Map < ResourceLocation , String > overrides ; 
 
 @ Override 
 public void fromBytes ( ByteBuf buffer ) 
 @ @ - 206 , 13 + 208 , 20 @ @ public abstract class FMLHandshakeMessage { 
 } 
 
 length = ByteBufUtils . readVarInt ( buffer , 3 ) ; 
 - 
 dummied = Sets . newHashSet ( ) ; 
 
 for ( int i = 0 ; i < length ; i + + ) 
 { 
 dummied . add ( new ResourceLocation ( ByteBufUtils . readUTF8String ( buffer ) ) ) ; 
 } 
 + 
 + length = ByteBufUtils . readVarInt ( buffer , 3 ) ; 
 + overrides = Maps . newHashMap ( ) ; 
 + 
 + for ( int i = 0 ; i < length ; i + + ) 
 + { 
 + overrides . put ( new ResourceLocation ( ByteBufUtils . readUTF8String ( buffer ) ) , ByteBufUtils . readUTF8String ( buffer ) ) ; 
 + } 
 } 
 
 @ Override 
 @ @ - 233 , 6 + 242 , 13 @ @ public abstract class FMLHandshakeMessage { 
 { 
 ByteBufUtils . writeUTF8String ( buffer , entry . toString ( ) ) ; 
 } 
 + 
 + ByteBufUtils . writeVarInt ( buffer , overrides . size ( ) , 3 ) ; 
 + for ( Entry < ResourceLocation , String > entry : overrides . entrySet ( ) ) 
 + { 
 + ByteBufUtils . writeUTF8String ( buffer , entry . getKey ( ) . toString ( ) ) ; 
 + ByteBufUtils . writeUTF8String ( buffer , entry . getValue ( ) . toString ( ) ) ; 
 + } 
 } 
 
 public Map < ResourceLocation , Integer > getIdMap ( ) 
 diff - - git a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 index 89a5113 . . c0ed23e 100644 
 - - - a / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 + + + b / src / main / java / net / minecraftforge / registries / ForgeRegistry . java 
 @ @ - 1 , 6 + 1 , 5 @ @ 
 package net . minecraftforge . registries ; 
 
 - import java . lang . ref . WeakReference ; 
 import java . util . BitSet ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 @ @ - 25 , 11 + 24 , 14 @ @ import com . google . common . collect . Lists ; 
 import com . google . common . collect . Maps ; 
 import com . google . common . collect . Multimap ; 
 import com . google . common . collect . Sets ; 
 - 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . event . RegistryEvent ; 
 import net . minecraftforge . event . RegistryEvent . MissingMappings ; 
 + import net . minecraftforge . fml . common . FMLContainer ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 + import net . minecraftforge . fml . common . InjectedModContainer ; 
 + import net . minecraftforge . fml . common . Loader ; 
 + import net . minecraftforge . fml . common . ModContainer ; 
 import net . minecraftforge . fml . relauncher . ReflectionHelper ; 
 
 public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRegistryInternal < V > , IForgeRegistryModifiable < V > 
 @ @ - 48 , 7 + 50 , 8 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 private final BitSet availabilityMap ; 
 private final Set < ResourceLocation > dummies = Sets . newHashSet ( ) ; 
 private final Set < Integer > blocked = Sets . newHashSet ( ) ; 
 - private final Multimap < ResourceLocation , WeakReference < V > > overrides = ArrayListMultimap . create ( ) ; 
 + private final Multimap < ResourceLocation , V > overrides = ArrayListMultimap . create ( ) ; 
 + private final BiMap < OverrideOwner , V > override _ owners = HashBiMap . create ( ) ; 
 private final DummyFactory < V > dummyFactory ; 
 private final boolean isDelegated ; 
 private final int min ; 
 @ @ - 78 , 7 + 81 , 6 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 this . create . onCreate ( this , stage ) ; 
 } 
 
 - 
 @ Override 
 public void register ( V value ) 
 { 
 @ @ - 228 , 6 + 230 , 13 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 
 int add ( int id , V value ) 
 { 
 + ModContainer mc = Loader . instance ( ) . activeModContainer ( ) ; 
 + String owner = mc = = null | | ( mc instanceof InjectedModContainer & & ( ( InjectedModContainer ) mc ) . wrappedContainer instanceof FMLContainer ) ? null : mc . getModId ( ) . toLowerCase ( ) ; 
 + return add ( id , value , owner ) ; 
 + } 
 + 
 + int add ( int id , V value , String owner ) 
 + { 
 ResourceLocation key = value = = null ? null : value . getRegistryName ( ) ; 
 Preconditions . checkNotNull ( key , " Can ' t use a null - name for the registry , object % s . " , value ) ; 
 Preconditions . checkNotNull ( value , " Can ' t add null - object to the registry , name % s . " , key ) ; 
 @ @ - 249 , 7 + 258 , 12 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 { 
 if ( ! this . allowOverrides ) 
 throw new IllegalArgumentException ( String . format ( " The name % s has been registered twice , for % s and % s . " , key , getRaw ( key ) , value ) ) ; 
 + if ( owner = = null ) 
 + throw new IllegalStateException ( String . format ( " Could not determine owner for the override on % s . Value : % s " , key , value ) ) ; 
 + this . override _ owners . put ( new OverrideOwner ( owner , key ) , value ) ; 
 idToUse = this . getID ( oldEntry ) ; 
 + if ( ! this . override _ owners . containsValue ( oldEntry ) ) 
 + this . override _ owners . put ( new OverrideOwner ( key . getResourceDomain ( ) , key ) , oldEntry ) ; 
 } 
 
 Integer foundId = this . ids . inverse ( ) . get ( value ) ; / / Is this ever possible to trigger with otherThing being different ? 
 @ @ - 278 , 7 + 292 , 7 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 getDelegate ( value ) . setName ( key ) ; 
 if ( oldEntry ! = null ) 
 { 
 - this . overrides . put ( key , new WeakReference < V > ( oldEntry ) ) ; 
 + this . overrides . put ( key , oldEntry ) ; 
 if ( this . stage = = RegistryManager . ACTIVE ) 
 getDelegate ( oldEntry ) . changeReference ( value ) ; 
 } 
 @ @ - 348 , 16 + 362 , 8 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 for ( V value : this ) 
 getDelegate ( value ) . changeReference ( value ) ; 
 
 - Iterator < Entry < ResourceLocation , WeakReference < V > > > itr = this . overrides . entries ( ) . iterator ( ) ; 
 - while ( itr . hasNext ( ) ) 
 - { 
 - Entry < ResourceLocation , WeakReference < V > > next = itr . next ( ) ; 
 - V value = next . getValue ( ) . get ( ) ; 
 - if ( value = = null ) 
 - itr . remove ( ) ; 
 - else 
 - getDelegate ( value ) . changeReference ( value ) ; 
 - } 
 + for ( V value : this . overrides . values ( ) ) 
 + getDelegate ( value ) . changeReference ( value ) ; 
 } 
 
 V getDefault ( ) 
 @ @ - 437 , 17 + 443 , 43 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 this . names . clear ( ) ; 
 this . availabilityMap . clear ( 0 , this . availabilityMap . length ( ) ) ; 
 this . defaultValue = null ; 
 + this . override _ owners . clear ( ) ; 
 + this . override _ owners . putAll ( from . override _ owners ) ; 
 
 boolean errored = false ; 
 
 for ( Entry < ResourceLocation , V > entry : from . names . entrySet ( ) ) 
 { 
 + List < V > overrides = Lists . newArrayList ( from . overrides . get ( entry . getKey ( ) ) ) ; 
 int id = from . getID ( entry . getKey ( ) ) ; 
 - int realId = add ( id , entry . getValue ( ) ) ; 
 - if ( id ! = realId & & id ! = - 1 ) 
 + if ( overrides . isEmpty ( ) ) 
 { 
 - FMLLog . warning ( " Registered object did not get ID it asked for . Name : { } Type : { } Expected : { } Got : { } " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , id , realId ) ; 
 - errored = true ; 
 + int realId = add ( id , entry . getValue ( ) ) ; 
 + if ( id ! = realId & & id ! = - 1 ) 
 + { 
 + FMLLog . warning ( " Registered object did not get ID it asked for . Name : % s Type : % s Expected : % s Got : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , id , realId ) ; 
 + errored = true ; 
 + } 
 + } 
 + else 
 + { 
 + overrides . add ( entry . getValue ( ) ) ; 
 + for ( V value : overrides ) 
 + { 
 + OverrideOwner owner = from . override _ owners . inverse ( ) . get ( value ) ; 
 + if ( owner = = null ) 
 + { 
 + FMLLog . warning ( " Registered override did not have an associated owner object . Name : % s Type : % s Value : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , value ) ; 
 + errored = true ; 
 + continue ; 
 + } 
 + int realId = add ( id , value , owner . owner ) ; 
 + if ( id ! = realId & & id ! = - 1 ) 
 + { 
 + FMLLog . warning ( " Registered object did not get ID it asked for . Name : % s Type : % s Expected : % s Got : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , id , realId ) ; 
 + errored = true ; 
 + } 
 + } 
 } 
 } 
 
 @ @ - 540 , 11 + 572 , 11 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 
 Collections . sort ( ids ) ; 
 
 - FMLLog . finer ( " Registry Name : { } " , name ) ; 
 + FMLLog . finer ( " Registry Name : % s " , name ) ; 
 ids . forEach ( id - > FMLLog . finer ( " Registry : % d % s % s " , id , getKey ( getValue ( id ) ) , getValue ( id ) ) ) ; 
 } 
 
 - public void loadIds ( Map < ResourceLocation , Integer > ids , Map < ResourceLocation , Integer > missing , Map < ResourceLocation , Integer [ ] > remapped , ForgeRegistry < V > old , ResourceLocation name ) 
 + public void loadIds ( Map < ResourceLocation , Integer > ids , Map < ResourceLocation , String > overrides , Map < ResourceLocation , Integer > missing , Map < ResourceLocation , Integer [ ] > remapped , ForgeRegistry < V > old , ResourceLocation name ) 
 { 
 for ( Map . Entry < ResourceLocation , Integer > entry : ids . entrySet ( ) ) 
 { 
 @ @ - 566 , 12 + 598 , 35 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 V obj = old . getRaw ( itemName ) ; 
 Preconditions . checkState ( obj ! = null , " objectKey has an ID but no object . Reflection / ASM hackery ? Registry bug ? " ) ; 
 
 - / / Register all overrides so new registry has the full list so we can update delegates later 
 - old . overrides . get ( obj . getRegistryName ( ) ) . stream ( ) 
 - . filter ( e - > e . get ( ) ! = null ) 
 - . forEach ( e - > add ( newId , e . get ( ) ) ) ; 
 + String primaryName = null ; 
 + if ( ! overrides . containsKey ( itemName ) & & old . overrides . containsKey ( itemName ) ) 
 + { 
 + obj = old . overrides . get ( itemName ) . iterator ( ) . next ( ) ; / / Get the first one in the list , Which should be the first one registered 
 + primaryName = old . override _ owners . inverse ( ) . get ( obj ) . owner ; 
 + } 
 + else 
 + primaryName = overrides . get ( itemName ) ; 
 + 
 + for ( V value : old . overrides . get ( itemName ) ) 
 + { 
 + OverrideOwner owner = old . override _ owners . inverse ( ) . get ( value ) ; 
 + if ( owner = = null ) 
 + { 
 + FMLLog . warning ( " Registered override did not have an associated owner object . Name : % s Type : % s Value : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , value ) ; 
 + continue ; 
 + } 
 + 
 + if ( primaryName . equals ( owner . owner ) ) 
 + continue ; 
 + 
 + int realId = add ( newId , value , owner . owner ) ; 
 + if ( newId ! = realId ) 
 + FMLLog . warning ( " Registered object did not get ID it asked for . Name : % s Type : % s Expected : % s Got : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , newId , realId ) ; 
 + } 
 
 - add ( newId , obj ) ; 
 + int realId = add ( newId , obj , primaryName = = null ? itemName . getResourceDomain ( ) : primaryName ) ; 
 + if ( realId ! = newId ) 
 + FMLLog . warning ( " Registered object did not get ID it asked for . Name : % s Type : % s Expected : % s Got : % s " , entry . getKey ( ) , this . getRegistrySuperType ( ) . getName ( ) , newId , realId ) ; 
 } 
 } 
 
 @ @ - 603 , 6 + 658 , 18 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 this . aliases . forEach ( ( from , to ) - > ret . aliases . put ( from , to ) ) ; 
 this . blocked . forEach ( id - > ret . blocked . add ( id ) ) ; 
 this . dummies . forEach ( name - > ret . dummied . add ( name ) ) ; 
 + ret . overrides . putAll ( getOverrideOwners ( ) ) ; 
 + return ret ; 
 + } 
 + 
 + Map < ResourceLocation , String > getOverrideOwners ( ) 
 + { 
 + Map < ResourceLocation , String > ret = Maps . newHashMap ( ) ; 
 + for ( ResourceLocation key : this . overrides . keySet ( ) ) 
 + { 
 + V obj = this . names . get ( key ) ; 
 + ret . put ( key , this . override _ owners . inverse ( ) . get ( obj ) . owner ) ; 
 + } 
 return ret ; 
 } 
 
 @ @ - 612 , 6 + 679 , 7 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 public final Map < ResourceLocation , ResourceLocation > aliases = Maps . newHashMap ( ) ; 
 public final Set < Integer > blocked = Sets . newHashSet ( ) ; 
 public final Set < ResourceLocation > dummied = Sets . newHashSet ( ) ; 
 + public final Map < ResourceLocation , String > overrides = Maps . newHashMap ( ) ; 
 } 
 
 public MissingMappings < ? > getMissingEvent ( ResourceLocation name , Map < ResourceLocation , Integer > map ) 
 @ @ - 679 , 4 + 747 , 32 @ @ public class ForgeRegistry < V extends IForgeRegistryEntry < V > > implements IForgeRe 
 if ( failed . isEmpty ( ) & & ignored > 0 ) 
 FMLLog . fine ( " There were % d missing mappings that have been ignored " , ignored ) ; 
 } 
 + 
 + private static class OverrideOwner 
 + { 
 + final String owner ; 
 + final ResourceLocation key ; 
 + private OverrideOwner ( String owner , ResourceLocation key ) 
 + { 
 + this . owner = owner ; 
 + this . key = key ; 
 + } 
 + 
 + public boolean equals ( Object o ) 
 + { 
 + if ( this = = o ) 
 + return true ; 
 + 
 + if ( ! ( o instanceof OverrideOwner ) ) 
 + return false ; 
 + 
 + OverrideOwner oo = ( OverrideOwner ) o ; 
 + return this . owner . equals ( oo . owner ) & & this . key . equals ( oo . key ) ; 
 + } 
 + 
 + public int hashCode ( ) 
 + { 
 + return 31 * this . key . hashCode ( ) + this . owner . hashCode ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / registries / GameData . java b / src / main / java / net / minecraftforge / registries / GameData . java 
 index 95cdd87 . . 6eac605 100644 
 - - - a / src / main / java / net / minecraftforge / registries / GameData . java 
 + + + b / src / main / java / net / minecraftforge / registries / GameData . java 
 @ @ - 230 , 6 + 230 , 7 @ @ public class GameData 
 FMLLog . warning ( " Can ' t revert to frozen GameData state without freezing first . " ) ; 
 return ; 
 } 
 + RegistryManager . ACTIVE . registries . forEach ( ( name , reg ) - > reg . resetDelegates ( ) ) ; 
 
 FMLLog . fine ( " Reverting to frozen data state . " ) ; 
 for ( Map . Entry < ResourceLocation , ForgeRegistry < ? extends IForgeRegistryEntry < ? > > > r : RegistryManager . ACTIVE . registries . entrySet ( ) ) 
 @ @ - 626 , 7 + 627 , 7 @ @ public class GameData 
 snap . blocked . forEach ( id - > _ new . block ( id ) ) ; 
 / / Load current dummies BEFORE the snapshot is loaded so that add ( ) will remove from the list . 
 snap . dummied . forEach ( key - > _ new . addDummy ( key ) ) ; 
 - _ new . loadIds ( snap . ids , missing , remaps , active , name ) ; 
 + _ new . loadIds ( snap . ids , snap . overrides , missing , remaps , active , name ) ; 
 } 
 
 / / Another bouncer for generic reasons 
 @ @ - 645 , 7 + 646 , 7 @ @ public class GameData 
 ForgeRegistry < T > newRegistry = STAGING . getRegistry ( name , RegistryManager . FROZEN ) ; 
 Map < ResourceLocation , Integer > _ new = Maps . newHashMap ( ) ; 
 frozen . getKeys ( ) . stream ( ) . filter ( key - > ! newRegistry . containsKey ( key ) ) . forEach ( key - > _ new . put ( key , frozen . getID ( key ) ) ) ; 
 - newRegistry . loadIds ( _ new , Maps . newLinkedHashMap ( ) , remaps , frozen , name ) ; 
 + newRegistry . loadIds ( _ new , frozen . getOverrideOwners ( ) , Maps . newLinkedHashMap ( ) , remaps , frozen , name ) ; 
 } 
 
 public static void fireCreateRegistryEvents ( ) 
 diff - - git a / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionInjectionTest . java b / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionInjectionTest . java 
 index e1b9058 . . 68b3a1f 100644 
 - - - a / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionInjectionTest . java 
 + + + b / src / test / java / net / minecraftforge / fml / common / registry / SubstitutionInjectionTest . java 
 @ @ - 58 , 10 + 58 , 6 @ @ public class SubstitutionInjectionTest 
 @ Test 
 public void testSubstitutionInjection ( ) throws Exception 
 { 
 - / / TODO : Decide exactly how I want to deal with subs , this test doesn ' t really do anything right now 
 - if ( true = = Boolean . valueOf ( " true " ) . booleanValue ( ) ) 
 - return ; 
 - 
 final ForgeRegistry < Block > blockRegistry = ( ForgeRegistry < Block > ) RegistryManager . ACTIVE . getRegistry ( Block . class ) ; 
 final ForgeRegistry < Item > itemRegistry = ( ForgeRegistry < Item > ) RegistryManager . ACTIVE . getRegistry ( Item . class ) ; 
 
 @ @ - 111 , 7 + 107 , 7 @ @ public class SubstitutionInjectionTest 
 assertEquals ( " ObjectHolder didn ' t apply - Blocks and registry " , currDirt , fnd ) ; 
 assertEquals ( " Got my dirt substitute - registry " , vanilDirt , fnd ) ; 
 dirtitem = ( ItemBlock ) itemRegistry . getValue ( MC _ DIRT ) ; 
 - assertEquals ( " ItemBlock points at my block " , toSub , dirtitem . getBlock ( ) ) ; 
 + assertEquals ( " ItemBlock points at my block " , vanilDirt , dirtitem . getBlock ( ) ) ; 
 
 / / TEST 3 : Does the substitute get restored when reverting to frozen state ? The substitute should be found in the registry again 
 GameData . revertToFrozen ( ) ; 
 @ @ - 133 , 7 + 129 , 7 @ @ public class SubstitutionInjectionTest 
 assertEquals ( " ObjectHolder didn ' t apply - Blocks and registry " , currDirt , fnd ) ; 
 assertEquals ( " Got my dirt substitute - registry " , vanilDirt , fnd ) ; 
 dirtitem = ( ItemBlock ) itemRegistry . getValue ( MC _ DIRT ) ; 
 - assertEquals ( " ItemBlock points at my block " , toSub , dirtitem . getBlock ( ) ) ; 
 + assertEquals ( " ItemBlock points at my block " , vanilDirt , dirtitem . getBlock ( ) ) ; 
 
 / / TEST 3 repeat : Does the substitute get restored when reverting to frozen state ? The substitute should be found in the registry again 
 GameData . revertToFrozen ( ) ;

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java b / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java 
 index 03f8e58 . . 14c05ac 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / FMLContainer . java 
 @ @ - 30 , 9 + 30 , 9 @ @ import net . minecraft . world . storage . WorldInfo ; 
 
 import org . apache . logging . log4j . Level ; 
 
 - import com . google . common . collect . BiMap ; 
 - import com . google . common . collect . HashBiMap ; 
 + import com . google . common . collect . ImmutableSet ; 
 import com . google . common . collect . Maps ; 
 + import com . google . common . collect . Sets ; 
 import com . google . common . eventbus . EventBus ; 
 import com . google . common . eventbus . Subscribe ; 
 
 @ @ - 105 , 8 + 105 , 8 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 / / name < - > id mappings 
 NBTTagList dataList = new NBTTagList ( ) ; 
 FMLLog . fine ( " Gathering id map for writing to world save % s " , info . getWorldName ( ) ) ; 
 - Map < String , Integer > itemList = GameData . buildItemDataList ( ) ; 
 - for ( Entry < String , Integer > item : itemList . entrySet ( ) ) 
 + GameData . GameDataSnapshot dataSnapshot = GameData . buildItemDataList ( ) ; 
 + for ( Entry < String , Integer > item : dataSnapshot . idMap . entrySet ( ) ) 
 { 
 NBTTagCompound tag = new NBTTagCompound ( ) ; 
 tag . setString ( " K " , item . getKey ( ) ) ; 
 @ @ - 126 , 15 + 126 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 blockAliasList . appendTag ( tag ) ; 
 } 
 fmlData . setTag ( " BlockAliases " , blockAliasList ) ; 
 - NBTTagList blockPersistentAliasList = new NBTTagList ( ) ; 
 - for ( Entry < String , String > entry : GameData . getBlockRegistry ( ) . getPersistentAliases ( ) . entrySet ( ) ) 
 + NBTTagList blockSubstitutionsList = new NBTTagList ( ) ; 
 + for ( String entry : dataSnapshot . blockSubstitutions ) 
 { 
 NBTTagCompound tag = new NBTTagCompound ( ) ; 
 - tag . setString ( " K " , entry . getKey ( ) ) ; 
 - tag . setString ( " V " , entry . getValue ( ) ) ; 
 - blockPersistentAliasList . appendTag ( tag ) ; 
 + tag . setString ( " K " , entry ) ; 
 + blockSubstitutionsList . appendTag ( tag ) ; 
 } 
 - fmlData . setTag ( " PersistentBlockAliases " , blockPersistentAliasList ) ; 
 + fmlData . setTag ( " BlockSubstitutions " , blockSubstitutionsList ) ; 
 / / item aliases 
 NBTTagList itemAliasList = new NBTTagList ( ) ; 
 for ( Entry < String , String > entry : GameData . getItemRegistry ( ) . getAliases ( ) . entrySet ( ) ) 
 @ @ - 146 , 15 + 145 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 } 
 fmlData . setTag ( " ItemAliases " , itemAliasList ) ; 
 
 - NBTTagList itemPersistentAliasList = new NBTTagList ( ) ; 
 - for ( Entry < String , String > entry : GameData . getItemRegistry ( ) . getPersistentAliases ( ) . entrySet ( ) ) 
 + NBTTagList itemSubstitutionsList = new NBTTagList ( ) ; 
 + for ( String entry : dataSnapshot . itemSubstitutions ) 
 { 
 NBTTagCompound tag = new NBTTagCompound ( ) ; 
 - tag . setString ( " K " , entry . getKey ( ) ) ; 
 - tag . setString ( " V " , entry . getValue ( ) ) ; 
 - itemPersistentAliasList . appendTag ( tag ) ; 
 + tag . setString ( " K " , entry ) ; 
 + itemSubstitutionsList . appendTag ( tag ) ; 
 } 
 - fmlData . setTag ( " ItemPersistentAliases " , itemPersistentAliasList ) ; 
 + fmlData . setTag ( " ItemSubstitutions " , itemSubstitutionsList ) ; 
 return fmlData ; 
 } 
 
 @ @ - 209 , 7 + 207 , 7 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 dataList . put ( itemLabel , itemId ) ; 
 } 
 } 
 - failedElements = GameData . injectWorldIDMap ( dataList , true , true ) ; 
 + failedElements = GameData . injectWorldIDMap ( dataList , ImmutableSet . < String > of ( ) , ImmutableSet . < String > of ( ) , true , true ) ; 
 
 } 
 else if ( tag . hasKey ( " ItemData " ) ) 
 @ @ - 245 , 14 + 243 , 14 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; 
 blockAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; 
 } 
 - BiMap < String , String > blockPersistentAliases = HashBiMap . create ( ) ; 
 - if ( tag . hasKey ( " BlockPersistentAliases " , 10 ) ) 
 + Set < String > blockSubstitutions = Sets . newHashSet ( ) ; 
 + if ( tag . hasKey ( " BlockSubstitutions " , 9 ) ) 
 { 
 - list = tag . getTagList ( " BlockPersistentAliases " , 10 ) ; 
 + list = tag . getTagList ( " BlockSubstitutions " , 10 ) ; 
 for ( int i = 0 ; i < list . tagCount ( ) ; i + + ) 
 { 
 NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; 
 - blockPersistentAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; 
 + blockSubstitutions . add ( dataTag . getString ( " K " ) ) ; 
 } 
 } 
 / / item aliases 
 @ @ - 264 , 17 + 262 , 17 @ @ public class FMLContainer extends DummyModContainer implements WorldAccessContai 
 itemAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; 
 } 
 
 - BiMap < String , String > itemPersistentAliases = HashBiMap . create ( ) ; 
 - if ( tag . hasKey ( " ItemPersistentAliases " , 10 ) ) 
 + Set < String > itemSubstitutions = Sets . newHashSet ( ) ; 
 + if ( tag . hasKey ( " ItemSubstitutions " , 9 ) ) 
 { 
 - list = tag . getTagList ( " ItemPersistentAliases " , 10 ) ; 
 + list = tag . getTagList ( " ItemSubstitutions " , 10 ) ; 
 for ( int i = 0 ; i < list . tagCount ( ) ; i + + ) 
 { 
 NBTTagCompound dataTag = list . getCompoundTagAt ( i ) ; 
 - itemPersistentAliases . put ( dataTag . getString ( " K " ) , dataTag . getString ( " V " ) ) ; 
 + itemSubstitutions . add ( dataTag . getString ( " K " ) ) ; 
 } 
 } 
 - failedElements = GameData . injectWorldIDMap ( dataList , blockedIds , blockAliases , itemAliases , true , true ) ; 
 + failedElements = GameData . injectWorldIDMap ( dataList , blockedIds , blockAliases , itemAliases , blockSubstitutions , itemSubstitutions , true , true ) ; 
 } 
 
 if ( failedElements ! = null & & ! failedElements . isEmpty ( ) ) 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / event / FMLMissingMappingsEvent . java b / fml / src / main / java / cpw / mods / fml / common / event / FMLMissingMappingsEvent . java 
 index fdaac1d . . 94ea8e3 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / event / FMLMissingMappingsEvent . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / event / FMLMissingMappingsEvent . java 
 @ @ - 32 , 7 + 32 , 28 @ @ public class FMLMissingMappingsEvent extends FMLEvent { 
 * @ author cpw 
 * 
 * / 
 - public static enum Action { DEFAULT , IGNORE , WARN , FAIL , REMAP } 
 + public static enum Action { 
 + / * * 
 + * Take the default action 
 + * / 
 + DEFAULT , 
 + / * * 
 + * Ignore this missing mapping . This means the mapping will be abandoned 
 + * / 
 + IGNORE , 
 + / * * 
 + * Generate a warning but allow loading to continue 
 + * / 
 + WARN , 
 + / * * 
 + * Fail to load 
 + * / 
 + FAIL , 
 + / * * 
 + * Remap this name to a new name ( add a migration mapping ) 
 + * / 
 + REMAP 
 + } 
 public static class MissingMapping { 
 public final GameRegistry . Type type ; 
 public final String name ; 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 index d463939 . . 12ed5f3 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeClientState . java 
 @ @ - 85 , 7 + 85 , 7 @ @ enum FMLHandshakeClientState implements IHandshakeState < FMLHandshakeClientState > 
 public FMLHandshakeClientState accept ( ChannelHandlerContext ctx , FMLHandshakeMessage msg ) 
 { 
 FMLHandshakeMessage . ModIdData modIds = ( FMLHandshakeMessage . ModIdData ) msg ; 
 - List < String > locallyMissing = GameData . injectWorldIDMap ( modIds . dataList ( ) , false , false ) ; 
 + List < String > locallyMissing = GameData . injectWorldIDMap ( modIds . dataList ( ) , modIds . blockSubstitutions ( ) , modIds . itemSubstitutions ( ) , false , false ) ; 
 if ( ! locallyMissing . isEmpty ( ) ) 
 { 
 NetworkDispatcher dispatcher = ctx . channel ( ) . attr ( NetworkDispatcher . FML _ DISPATCHER ) . get ( ) ; 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 index 1c440fe . . d998703 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / network / handshake / FMLHandshakeMessage . java 
 @ @ - 13 , 11 + 13 , 13 @ @ import com . google . common . base . Charsets ; 
 import com . google . common . base . Joiner ; 
 import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Maps ; 
 + import com . google . common . collect . Sets ; 
 
 import cpw . mods . fml . common . ModContainer ; 
 import cpw . mods . fml . common . network . ByteBufUtils ; 
 import cpw . mods . fml . common . network . NetworkRegistry ; 
 import cpw . mods . fml . common . network . internal . FMLProxyPacket ; 
 + import cpw . mods . fml . common . registry . GameData ; 
 
 public abstract class FMLHandshakeMessage { 
 public static FMLProxyPacket makeCustomChannelRegistration ( Set < String > channels ) 
 @ @ - 128 , 22 + 130 , 43 @ @ public abstract class FMLHandshakeMessage { 
 
 } 
 
 - public ModIdData ( Map < String , Integer > modIds ) 
 + public ModIdData ( GameData . GameDataSnapshot snapshot ) 
 { 
 - this . modIds = modIds ; 
 + this . modIds = snapshot . idMap ; 
 + this . blockSubstitutions = snapshot . blockSubstitutions ; 
 + this . itemSubstitutions = snapshot . itemSubstitutions ; 
 } 
 
 private Map < String , Integer > modIds ; 
 + private Set < String > blockSubstitutions ; 
 + private Set < String > itemSubstitutions ; 
 @ Override 
 public void fromBytes ( ByteBuf buffer ) 
 { 
 int length = ByteBufUtils . readVarInt ( buffer , 3 ) ; 
 modIds = Maps . newHashMap ( ) ; 
 + blockSubstitutions = Sets . newHashSet ( ) ; 
 + itemSubstitutions = Sets . newHashSet ( ) ; 
 
 for ( int i = 0 ; i < length ; i + + ) 
 { 
 modIds . put ( ByteBufUtils . readUTF8String ( buffer ) , ByteBufUtils . readVarInt ( buffer , 3 ) ) ; 
 } 
 + / / we don ' t have any more data to read 
 + if ( ! buffer . isReadable ( ) ) 
 + { 
 + return ; 
 + } 
 + length = ByteBufUtils . readVarInt ( buffer , 3 ) ; 
 + for ( int i = 0 ; i < length ; i + + ) 
 + { 
 + blockSubstitutions . add ( ByteBufUtils . readUTF8String ( buffer ) ) ; 
 + } 
 + length = ByteBufUtils . readVarInt ( buffer , 3 ) ; 
 + for ( int i = 0 ; i < length ; i + + ) 
 + { 
 + itemSubstitutions . add ( ByteBufUtils . readUTF8String ( buffer ) ) ; 
 + } 
 } 
 
 @ Override 
 @ @ - 155 , 12 + 178 , 33 @ @ public abstract class FMLHandshakeMessage { 
 ByteBufUtils . writeUTF8String ( buffer , entry . getKey ( ) ) ; 
 ByteBufUtils . writeVarInt ( buffer , entry . getValue ( ) , 3 ) ; 
 } 
 + 
 + ByteBufUtils . writeVarInt ( buffer , blockSubstitutions . size ( ) , 3 ) ; 
 + for ( String entry : blockSubstitutions ) 
 + { 
 + ByteBufUtils . writeUTF8String ( buffer , entry ) ; 
 + } 
 + ByteBufUtils . writeVarInt ( buffer , blockSubstitutions . size ( ) , 3 ) ; 
 + 
 + for ( String entry : itemSubstitutions ) 
 + { 
 + ByteBufUtils . writeUTF8String ( buffer , entry ) ; 
 + } 
 } 
 
 public Map < String , Integer > dataList ( ) 
 { 
 return modIds ; 
 } 
 + public Set < String > blockSubstitutions ( ) 
 + { 
 + return blockSubstitutions ; 
 + } 
 + public Set < String > itemSubstitutions ( ) 
 + { 
 + return itemSubstitutions ; 
 + } 
 + 
 @ Override 
 public String toString ( Class < ? extends Enum < ? > > side ) 
 { 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java 
 deleted file mode 100644 
 index aedd66b . . 0000000 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / ExistingAliasException . java 
 + + + / dev / null 
 @ @ - 1 , 9 + 0 , 0 @ @ 
 - package cpw . mods . fml . common . registry ; 
 - 
 - public class ExistingAliasException extends Exception { 
 - public ExistingAliasException ( String fromName , String toName ) { 
 - } 
 - 
 - private static final long serialVersionUID = 1L ; 
 - 
 - } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / ExistingSubstitutionException . java b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingSubstitutionException . java 
 new file mode 100644 
 index 0000000 . . ec8f614 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / ExistingSubstitutionException . java 
 @ @ - 0 , 0 + 1 , 9 @ @ 
 + package cpw . mods . fml . common . registry ; 
 + 
 + public class ExistingSubstitutionException extends Exception { 
 + public ExistingSubstitutionException ( String fromName , Object toReplace ) { 
 + } 
 + 
 + private static final long serialVersionUID = 1L ; 
 + 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 index 8503c51 . . ec4af98 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 @ @ - 15 , 7 + 15 , 6 @ @ import net . minecraft . util . RegistryNamespaced ; 
 
 import com . google . common . collect . BiMap ; 
 import com . google . common . collect . HashBiMap ; 
 - import com . google . common . collect . ImmutableBiMap ; 
 import com . google . common . collect . ImmutableMap ; 
 
 import cpw . mods . fml . common . FMLLog ; 
 @ @ - 31 , 7 + 30 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 / / aliases redirecting legacy names to the actual name , may need recursive application to find the final name . 
 / / these need to be registry specific , it ' s possible to only have a loosely linked item for a block which may get renamed by itself . 
 private final Map < String , String > aliases = new HashMap < String , String > ( ) ; 
 - private BiMap < String , String > persistentAliases = HashBiMap . create ( ) ; 
 + private BiMap < String , I > persistentSubstitutions ; 
 + private BiMap < String , I > activeSubstitutions = HashBiMap . create ( ) ; 
 
 FMLControlledNamespacedRegistry ( String optionalDefault , int maxIdValue , int minIdValue , Class < I > type , char discriminator ) 
 { 
 @ @ - 62 , 9 + 62 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 / / id - > obj lookup is inconsistent 
 if ( getRaw ( id ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for id % d , name % s , doesn ' t yield the expected % s % s . " , id , name , type , obj ) ) ; 
 / / name - > obj lookup is inconsistent 
 - if ( getRaw ( name ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for name % s , id % d , doesn ' t yield the expected % s % s . " , name , id , type , obj ) ) ; 
 + if ( ! ( activeSubstitutions . containsKey ( name ) | | activeSubstitutions . containsValue ( name ) ) & & getRaw ( name ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for name % s , id % d , doesn ' t yield the expected % s % s . " , name , id , type , obj ) ) ; 
 / / name - > id lookup is inconsistent 
 - if ( getId ( name ) ! = id ) throw new IllegalStateException ( String . format ( " Registry entry for name % s doesn ' t yield the expected id % d . " , name , id ) ) ; 
 + if ( ! ( activeSubstitutions . containsKey ( name ) | | activeSubstitutions . containsValue ( name ) ) & & getId ( name ) ! = id ) throw new IllegalStateException ( String . format ( " Registry entry for name % s doesn ' t yield the expected id % d . " , name , id ) ) ; 
 / / id isn ' t marked as unavailable 
 if ( ! availabilityMap . get ( id ) ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , id % d , name % s , marked as empty . " , type , obj , id , name ) ) ; 
 / / entry is blocked , thus should be empty 
 @ @ - 235 , 9 + 235 , 6 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 * / 
 public I getRaw ( String name ) 
 { 
 - String aliasName = persistentAliases . get ( name ) ; 
 - name = aliasName ! = null ? aliasName : name ; 
 - 
 I ret = superType . cast ( super . getObject ( name ) ) ; 
 
 if ( ret = = null ) / / no match , try aliases recursively 
 @ @ - 322 , 10 + 319 , 6 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 return ImmutableMap . copyOf ( aliases ) ; 
 } 
 
 - public Map < String , String > getPersistentAliases ( ) 
 - { 
 - return ImmutableBiMap . copyOf ( persistentAliases ) ; 
 - } 
 / * * 
 * Add the specified object to the registry . 
 * 
 @ @ - 345 , 7 + 338 , 10 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 { 
 this . optionalDefaultObject = thing ; 
 } 
 - 
 + if ( getPersistentSubstitutions ( ) . containsValue ( thing ) ) 
 + { 
 + throw new IllegalArgumentException ( String . format ( " The object % s ( % s ) cannot be added to the registry . It is already being used as a substitute for % s " , thing . getClass ( ) , name , getPersistentSubstitutions ( ) . inverse ( ) . get ( thing ) ) ) ; 
 + } 
 int idToUse = id ; 
 if ( idToUse < 0 | | availabilityMap . get ( idToUse ) ) 
 { 
 @ @ - 365 , 7 + 361 , 7 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 { 
 throw new IllegalArgumentException ( String . format ( " The name % s has been registered twice , for % s and % s . " , name , getRaw ( name ) , thing ) ) ; 
 } 
 - if ( getId ( thing ) > = 0 ) / / duplicate object 
 + if ( getId ( thing ) > = 0 ) / / duplicate object - but only if it ' s not being substituted 
 { 
 int foundId = getId ( thing ) ; 
 Object otherThing = getRaw ( foundId ) ; 
 @ @ - 376 , 6 + 372 , 10 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 FMLLog . bigWarning ( " The object % s ( name % s ) is being added too late . " , thing , name ) ; 
 } 
 
 + if ( activeSubstitutions . containsKey ( name ) ) 
 + { 
 + thing = activeSubstitutions . get ( name ) ; 
 + } 
 addObjectRaw ( idToUse , name , thing ) ; 
 
 FMLLog . finer ( " Registry add : % s % d % s ( req . id % d ) " , name , idToUse , thing , id ) ; 
 @ @ - 394 , 7 + 394 , 13 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 
 for ( I thing : this . typeSafeIterable ( ) ) 
 { 
 - if ( ! registry . field _ 148758 _ b . containsKey ( thing ) ) ret . put ( getNameForObject ( thing ) , getId ( thing ) ) ; 
 + if ( ! registry . field _ 148758 _ b . containsKey ( thing ) ) 
 + { 
 + if ( ! registry . activeSubstitutions . containsKey ( getNameForObject ( thing ) ) ) 
 + { 
 + ret . put ( getNameForObject ( thing ) , getId ( thing ) ) ; 
 + } 
 + } 
 } 
 
 return ret ; 
 @ @ - 441 , 11 + 447 , 54 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 return GameData . buildDelegate ( thing , clazz ) ; 
 } 
 
 - public void addPersistentAlias ( String fromName , String toName ) throws ExistingAliasException { 
 - if ( persistentAliases . containsKey ( fromName ) | | persistentAliases . containsKey ( toName ) | | persistentAliases . containsValue ( fromName ) | | persistentAliases . containsValue ( toName ) ) 
 + void activateSubstitution ( String nameToReplace ) 
 + { 
 + if ( getPersistentSubstitutions ( ) . containsKey ( nameToReplace ) ) 
 + { 
 + activeSubstitutions . put ( nameToReplace , getPersistentSubstitutions ( ) . get ( nameToReplace ) ) ; 
 + } 
 + } 
 + 
 + public void addSubstitutionAlias ( String modId , String nameToReplace , Object toReplace ) throws ExistingSubstitutionException { 
 + if ( getPersistentSubstitutions ( ) . containsKey ( nameToReplace ) | | getPersistentSubstitutions ( ) . containsValue ( toReplace ) ) 
 + { 
 + FMLLog . severe ( " The substitution of % s has already occured . You cannot duplicate substitutions " , nameToReplace ) ; 
 + throw new ExistingSubstitutionException ( nameToReplace , toReplace ) ; 
 + } 
 + I replacement = superType . cast ( toReplace ) ; 
 + I original = getRaw ( nameToReplace ) ; 
 + if ( ! original . getClass ( ) . isAssignableFrom ( replacement . getClass ( ) ) ) 
 + { 
 + FMLLog . severe ( " The substitute % s for % s ( type % s ) is type incompatible . This won ' t work " , replacement . getClass ( ) . getName ( ) , nameToReplace , original . getClass ( ) . getName ( ) ) ; 
 + throw new IncompatibleSubstitutionException ( nameToReplace , replacement , original ) ; 
 + } 
 + int existingId = getId ( replacement ) ; 
 + if ( existingId ! = - 1 ) 
 + { 
 + FMLLog . severe ( " The substitute % s for % s is registered into the game independently . This won ' t work " , replacement . getClass ( ) . getName ( ) , nameToReplace ) ; 
 + throw new IllegalArgumentException ( " The object substitution is already registered . This won ' t work " ) ; 
 + } 
 + getPersistentSubstitutions ( ) . put ( nameToReplace , replacement ) ; 
 + } 
 + 
 + public void serializeSubstitutions ( Set < String > blockSubs ) 
 + { 
 + blockSubs . addAll ( activeSubstitutions . keySet ( ) ) ; 
 + } 
 + 
 + @ Override 
 + public int getIDForObject ( Object p _ 148757 _ 1 _ ) 
 + { 
 + 
 + int id = super . getIDForObject ( p _ 148757 _ 1 _ ) ; 
 + return id ; 
 + } 
 + private BiMap < String , I > getPersistentSubstitutions ( ) 
 + { 
 + if ( persistentSubstitutions = = null ) 
 { 
 - throw new ExistingAliasException ( fromName , toName ) ; 
 + persistentSubstitutions = GameData . getMain ( ) . getPersistentSubstitutionMap ( superType ) ; 
 } 
 - persistentAliases . put ( fromName , toName ) ; 
 + return persistentSubstitutions ; 
 } 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 index 5394989 . . 816ab0e 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 @ @ - 34 , 11 + 34 , 14 @ @ import org . apache . logging . log4j . Level ; 
 import com . google . common . base . Charsets ; 
 import com . google . common . base . Joiner ; 
 import com . google . common . base . Joiner . MapJoiner ; 
 + import com . google . common . collect . BiMap ; 
 import com . google . common . collect . HashBasedTable ; 
 + import com . google . common . collect . HashBiMap ; 
 import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . ImmutableListMultimap ; 
 import com . google . common . collect . Lists ; 
 import com . google . common . collect . Maps ; 
 + import com . google . common . collect . Sets ; 
 import com . google . common . collect . Table ; 
 import com . google . common . io . Files ; 
 
 @ @ - 112 , 12 + 115 , 27 @ @ public class GameData { 
 
 / / internal from here 
 
 - public static Map < String , Integer > buildItemDataList ( ) 
 + public static class GameDataSnapshot { 
 + public final Map < String , Integer > idMap ; 
 + public final Set < String > blockSubstitutions ; 
 + public final Set < String > itemSubstitutions ; 
 + public GameDataSnapshot ( Map < String , Integer > idMap , Set < String > blockSubstitutions , Set < String > itemSubstitutions ) 
 + { 
 + this . idMap = idMap ; 
 + this . blockSubstitutions = blockSubstitutions ; 
 + this . itemSubstitutions = itemSubstitutions ; 
 + } 
 + } 
 + public static GameDataSnapshot buildItemDataList ( ) 
 { 
 Map < String , Integer > idMapping = Maps . newHashMap ( ) ; 
 getMain ( ) . iBlockRegistry . serializeInto ( idMapping ) ; 
 getMain ( ) . iItemRegistry . serializeInto ( idMapping ) ; 
 - return idMapping ; 
 + Set < String > blockSubs = Sets . newHashSet ( ) ; 
 + getMain ( ) . iBlockRegistry . serializeSubstitutions ( blockSubs ) ; 
 + Set < String > itemSubs = Sets . newHashSet ( ) ; 
 + getMain ( ) . iItemRegistry . serializeSubstitutions ( itemSubs ) ; 
 + return new GameDataSnapshot ( idMapping , blockSubs , itemSubs ) ; 
 } 
 
 public static int [ ] getBlockedIds ( ) 
 @ @ - 407 , 12 + 425 , 12 @ @ public class GameData { 
 blockedIds . addAll ( newBlockedIds ) ; 
 } 
 
 - public static List < String > injectWorldIDMap ( Map < String , Integer > dataList , boolean injectFrozenData , boolean isLocalWorld ) 
 + public static List < String > injectWorldIDMap ( Map < String , Integer > dataList , Set < String > blockSubstitutions , Set < String > itemSubstitutions , boolean injectFrozenData , boolean isLocalWorld ) 
 { 
 - return injectWorldIDMap ( dataList , new HashSet < Integer > ( ) , new HashMap < String , String > ( ) , new HashMap < String , String > ( ) , injectFrozenData , isLocalWorld ) ; 
 + return injectWorldIDMap ( dataList , new HashSet < Integer > ( ) , new HashMap < String , String > ( ) , new HashMap < String , String > ( ) , blockSubstitutions , itemSubstitutions , injectFrozenData , isLocalWorld ) ; 
 } 
 
 - public static List < String > injectWorldIDMap ( Map < String , Integer > dataList , Set < Integer > blockedIds , Map < String , String > blockAliases , Map < String , String > itemAliases , boolean injectFrozenData , boolean isLocalWorld ) 
 + public static List < String > injectWorldIDMap ( Map < String , Integer > dataList , Set < Integer > blockedIds , Map < String , String > blockAliases , Map < String , String > itemAliases , Set < String > blockSubstitutions , Set < String > itemSubstitutions , boolean injectFrozenData , boolean isLocalWorld ) 
 { 
 FMLLog . info ( " Injecting existing block and item data into this % s instance " , FMLCommonHandler . instance ( ) . getEffectiveSide ( ) . isServer ( ) ? " server " : " client " ) ; 
 Map < String , Integer [ ] > remaps = Maps . newHashMap ( ) ; 
 @ @ - 438 , 6 + 456 , 31 @ @ public class GameData { 
 newData . iItemRegistry . addAlias ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 } 
 
 + for ( String entry : blockSubstitutions ) 
 + { 
 + newData . iBlockRegistry . activateSubstitution ( entry ) ; 
 + } 
 + for ( String entry : itemSubstitutions ) 
 + { 
 + newData . iItemRegistry . activateSubstitution ( entry ) ; 
 + } 
 + if ( injectFrozenData ) 
 + { 
 + for ( String newBlockSubstitution : getMain ( ) . blockSubstitutions . keySet ( ) ) 
 + { 
 + if ( ! blockSubstitutions . contains ( newBlockSubstitution ) ) 
 + { 
 + newData . iBlockRegistry . activateSubstitution ( newBlockSubstitution ) ; 
 + } 
 + } 
 + for ( String newItemSubstitution : getMain ( ) . itemSubstitutions . keySet ( ) ) 
 + { 
 + if ( ! itemSubstitutions . contains ( newItemSubstitution ) ) 
 + { 
 + newData . iItemRegistry . activateSubstitution ( newItemSubstitution ) ; 
 + } 
 + } 
 + } 
 / / process blocks and items in the world , blocks in the first pass , items in the second 
 / / blocks need to be added first for proper ItemBlock handling 
 for ( int pass = 0 ; pass < 2 ; pass + + ) 
 @ @ - 479 , 10 + 522 , 11 @ @ public class GameData { 
 
 if ( currId ! = newId ) 
 { 
 - throw new IllegalStateException ( String . format ( " Can ' t map % s % s to id % d , already occupied by % s , blocked % b , ItemBlock % b " , 
 + throw new IllegalStateException ( String . format ( " Can ' t map % s % s to id % d ( seen at : % d ) , already occupied by % s , blocked % b , ItemBlock % b " , 
 isBlock ? " block " : " item " , 
 itemName , 
 newId , 
 + currId , 
 isBlock ? newData . iBlockRegistry . getRaw ( newId ) : newData . iItemRegistry . getRaw ( newId ) , 
 newData . blockedIds . contains ( newId ) , 
 isBlock ? false : ( getMain ( ) . iItemRegistry . getRaw ( currId ) instanceof ItemBlock ) ) ) ; 
 @ @ - 763 , 6 + 807 , 10 @ @ public class GameData { 
 if ( item instanceof ItemBlock ) / / ItemBlock , adjust id and clear the slot already occupied by the corresponding block 
 { 
 Block block = ( ( ItemBlock ) item ) . field _ 150939 _ a ; 
 + if ( idHint ! = - 1 & & getMain ( ) . blockSubstitutions . containsKey ( name ) ) 
 + { 
 + block = getMain ( ) . blockSubstitutions . get ( name ) ; 
 + } 
 int id = iBlockRegistry . getId ( block ) ; 
 
 if ( id = = - 1 ) / / ItemBlock before its Block 
 @ @ - 948 , 13 + 996 , 32 @ @ public class GameData { 
 
 FMLLog . fine ( " Registry consistency check successful " ) ; 
 } 
 - 
 - void registerPersistentAlias ( String fromName , String toName , GameRegistry . Type type ) throws ExistingAliasException 
 + 
 + void registerSubstitutionAlias ( String nameToSubstitute , Type type , Object toReplace ) throws ExistingSubstitutionException 
 { 
 - type . getRegistry ( ) . addPersistentAlias ( fromName , toName ) ; 
 + type . getRegistry ( ) . addSubstitutionAlias ( Loader . instance ( ) . activeModContainer ( ) . getModId ( ) , nameToSubstitute , toReplace ) ; 
 } 
 static < T > RegistryDelegate < T > buildDelegate ( T referant , Class < T > type ) 
 { 
 return new RegistryDelegate . Delegate < T > ( referant , type ) ; 
 } 
 + 
 + private BiMap < String , Item > itemSubstitutions = HashBiMap . create ( ) ; 
 + private BiMap < String , Block > blockSubstitutions = HashBiMap . create ( ) ; 
 + @ SuppressWarnings ( " unchecked " ) 
 + < T > BiMap < String , T > getPersistentSubstitutionMap ( Class < T > type ) 
 + { 
 + if ( type . equals ( Item . class ) ) 
 + { 
 + return ( BiMap < String , T > ) itemSubstitutions ; 
 + } 
 + else if ( type . equals ( Block . class ) ) 
 + { 
 + return ( BiMap < String , T > ) blockSubstitutions ; 
 + } 
 + else 
 + { 
 + throw new RuntimeException ( " WHAT ? " ) ; 
 + } 
 + } 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 index 6a26bb3 . . 093ef06 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameRegistry . java 
 @ @ - 146 , 18 + 146 , 19 @ @ public class GameRegistry 
 
 
 / * * 
 - * Add a forced persistent alias for the block or item to another block or item . This will have 
 - * the effect of using the substituted block or item instead of the original , whereever it is 
 + * Add a forced persistent substitution alias for the block or item to another block or item . This will have 
 + * the effect of using the substituted block or item instead of the original , where ever it is 
 * referenced . 
 - * 
 - * @ param toName The name to link to ( this is the NEW block or item ) 
 - * @ param fromName The name to link from ( this is the OLD block or item being substituted ) 
 + * 
 + * @ param nameToSubstitute The name to link to ( this is the NEW block or item ) 
 * @ param type The type ( Block or Item ) 
 - * @ throws ExistingAliasException if someone else has already registered an alias either from or to one of the names 
 + * @ param object a NEW instance that is type compatible with the existing instance 
 + * @ throws ExistingSubstitutionException if someone else has already registered an alias either from or to one of the names 
 + * @ throws IncompatibleSubstitutionException if the substitution is incompatible 
 * / 
 - public static void addAlias ( String toName , String fromName , GameRegistry . Type type ) throws ExistingAliasException 
 + public static void addSubstitutionAlias ( String nameToSubstitute , GameRegistry . Type type , Object object ) throws ExistingSubstitutionException 
 { 
 - GameData . getMain ( ) . registerPersistentAlias ( fromName , toName , type ) ; 
 + GameData . getMain ( ) . registerSubstitutionAlias ( nameToSubstitute , type , object ) ; 
 } 
 
 / * * 
 @ @ - 406 , 7 + 407 , 7 @ @ public class GameRegistry 
 } 
 } 
 
 - public static enum Type { 
 + public static enum Type { 
 BLOCK 
 { 
 @ Override 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / IncompatibleSubstitutionException . java b / fml / src / main / java / cpw / mods / fml / common / registry / IncompatibleSubstitutionException . java 
 new file mode 100644 
 index 0000000 . . c4d2114 
 - - - / dev / null 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / IncompatibleSubstitutionException . java 
 @ @ - 0 , 0 + 1 , 10 @ @ 
 + package cpw . mods . fml . common . registry ; 
 + 
 + public class IncompatibleSubstitutionException extends RuntimeException { 
 + public IncompatibleSubstitutionException ( String fromName , Object replacement , Object original ) 
 + { 
 + } 
 + 
 + private static final long serialVersionUID = 1L ; 
 + 
 + } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / RegistryDelegate . java b / fml / src / main / java / cpw / mods / fml / common / registry / RegistryDelegate . java 
 index 8112286 . . 64db87a 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / RegistryDelegate . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / RegistryDelegate . java 
 @ @ - 1 , 29 + 1 , 53 @ @ 
 package cpw . mods . fml . common . registry ; 
 
 + import com . google . common . base . Objects ; 
 + 
 
 / * * 
 * A registry delegate for holding references to items or blocks 
 - * 
 + * These should be safe to use in things like lists though aliased items and blocks will not 
 + * have object identity with respect to their delegate . 
 + * 
 * @ author cpw 
 * 
 * @ param < T > the type of thing we ' re holding onto 
 * / 
 public interface RegistryDelegate < T > { 
 + / * * 
 + * Get the referent pointed at by this delegate . This will be the currently active item or block , and will change 
 + * as world saves come and go . Note that item . delegate . get ( ) may NOT be the same object as item , due to item and 
 + * block substitution . 
 + * 
 + * @ return The referred object 
 + * / 
 T get ( ) ; 
 + 
 + / * * 
 + * Get the name of this delegate . This is completely static after registration has completed and will never change . 
 + * @ return The name 
 + * / 
 String name ( ) ; 
 + 
 + / * * 
 + * Get the delegate type . It will be Item or Block . 
 + * @ return The type of delegate 
 + * / 
 Class < T > type ( ) ; 
 - 
 + 
 + / * 
 + * This is the internal implementation class of the delegate . 
 + * / 
 final class Delegate < T > implements RegistryDelegate < T > 
 { 
 private T referant ; 
 private String name ; 
 private final Class < T > type ; 
 - 
 + 
 public Delegate ( T referant , Class < T > type ) { 
 this . referant = referant ; 
 this . type = type ; 
 } 
 - 
 + 
 @ Override 
 public T get ( ) { 
 return referant ; 
 @ @ - 34 , 19 + 58 , 37 @ @ public interface RegistryDelegate < T > { 
 return name ; 
 } 
 
 + @ Override 
 public Class < T > type ( ) 
 { 
 return this . type ; 
 } 
 - 
 + 
 void changeReference ( T newTarget ) 
 { 
 this . referant = newTarget ; 
 } 
 - 
 + 
 void setName ( String name ) 
 { 
 this . name = name ; 
 } 
 + 
 + @ Override 
 + public boolean equals ( Object obj ) 
 + { 
 + if ( obj instanceof Delegate ) 
 + { 
 + Delegate < ? > other = ( Delegate < ? > ) obj ; 
 + return Objects . equal ( other . name , name ) ; 
 + } 
 + return false ; 
 + } 
 + 
 + @ Override 
 + public int hashCode ( ) 
 + { 
 + return Objects . hashCode ( name ) ; 
 + } 
 } 
 }
