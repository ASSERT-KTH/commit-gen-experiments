BLEU SCORE: 6.527997854283348E-4

TEST MSG: Don ' t copy state from variant to multi - part model
GENERATED MSG: Model loader improvements : adding custom data / textures to models that don ' t need them doesn ' t cause a error now , since it ' s common to put those in the defaults section of the blockstate json ; you can get IModel associated with the variant now - using ModelLoaderRegistry . getModel ; MultiLayerModel should now respect transformations applied to it , and respect part transformations .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java b / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java <nl> index dffcc5b . . cda7c8b 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java <nl> @ @ - 200 , 10 + 200 , 6 @ @ public class BlockStateLoader <nl> return base ; <nl> } <nl> <nl> - / / Apply rotation of base model to sub - models . <nl> - / / If baseRot is non - null , then that rotation will be applied instead of the base model ' s rotation . <nl> - / / This is used to allow replacing base model with a sub - model when there is no base model for a variant . <nl> - IModelState baseTr = getState ( ) ; <nl> ImmutableMap . Builder < String , Pair < IModel , IModelState > > models = ImmutableMap . builder ( ) ; <nl> for ( Entry < String , SubModel > entry : parts . entrySet ( ) ) <nl> { <nl> @ @ - 224 , 7 + 220 , 7 @ @ public class BlockStateLoader <nl> models . put ( entry . getKey ( ) , Pair . of ( runModelHooks ( model , part . smooth , part . gui3d , part . uvLock , part . getTextures ( ) , part . getCustomData ( ) ) , part . getState ( ) ) ) ; <nl> } <nl> <nl> - return new MultiModel ( getModelLocation ( ) , hasBase ? base : null , baseTr , models . build ( ) ) ; <nl> + return new MultiModel ( getModelLocation ( ) , hasBase ? base : null , models . build ( ) ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / MultiModel . java b / src / main / java / net / minecraftforge / client / model / MultiModel . java <nl> index 455c028 . . 463b0b1 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / MultiModel . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / MultiModel . java <nl> @ @ - 227 , 20 + 227 , 32 @ @ public final class MultiModel implements IModel <nl> private final ResourceLocation location ; <nl> @ Nullable <nl> private final IModel base ; <nl> - private final IModelState baseState ; <nl> private final Map < String , Pair < IModel , IModelState > > parts ; <nl> <nl> + / / TODO 1 . 13 remove , kept for binary compatibility <nl> + @ Deprecated <nl> public MultiModel ( ResourceLocation location , @ Nullable IModel base , IModelState baseState , ImmutableMap < String , Pair < IModel , IModelState > > parts ) <nl> { <nl> + this ( location , base , parts ) ; <nl> + } <nl> + <nl> + public MultiModel ( ResourceLocation location , @ Nullable IModel base , ImmutableMap < String , Pair < IModel , IModelState > > parts ) <nl> + { <nl> this . location = location ; <nl> this . base = base ; <nl> - this . baseState = baseState ; <nl> this . parts = parts ; <nl> } <nl> <nl> + / / TODO 1 . 13 remove , kept for binary compatibility <nl> + @ Deprecated <nl> public MultiModel ( ResourceLocation location , IModel base , IModelState baseState , Map < String , Pair < IModel , IModelState > > parts ) <nl> { <nl> - this ( location , base , baseState , ImmutableMap . copyOf ( parts ) ) ; <nl> + this ( location , base , parts ) ; <nl> + } <nl> + <nl> + public MultiModel ( ResourceLocation location , IModel base , Map < String , Pair < IModel , IModelState > > parts ) <nl> + { <nl> + this ( location , base , ImmutableMap . copyOf ( parts ) ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 295 , 10 + 307 , 4 @ @ public final class MultiModel implements IModel <nl> } <nl> return new Baked ( location , true , bakedBase , mapBuilder . build ( ) ) ; <nl> } <nl> - <nl> - @ Override <nl> - public IModelState getDefaultState ( ) <nl> - { <nl> - return baseState ; <nl> - } <nl> }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java b / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java <nl> index 2559856 . . b6fb4f0 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java <nl> @ @ - 134 , 20 + 134 , 14 @ @ public class BlockStateLoader <nl> <nl> protected IModel runModelHooks ( IModel base , ImmutableMap < String , String > textureMap , ImmutableMap < String , String > customData ) <nl> { <nl> - if ( ! customData . isEmpty ( ) ) <nl> + if ( ! customData . isEmpty ( ) & & base instanceof IModelCustomData ) <nl> { <nl> - if ( base instanceof IModelCustomData ) <nl> - base = ( ( IModelCustomData ) base ) . process ( customData ) ; <nl> - else <nl> - throw new RuntimeException ( " Attempted to add custom data to a model that doesn ' t need it : " + base ) ; <nl> + base = ( ( IModelCustomData ) base ) . process ( customData ) ; <nl> } <nl> <nl> - if ( ! textureMap . isEmpty ( ) ) <nl> + if ( ! textureMap . isEmpty ( ) & & base instanceof IRetexturableModel ) <nl> { <nl> - if ( base instanceof IRetexturableModel ) <nl> - base = ( ( IRetexturableModel ) base ) . retexture ( textureMap ) ; <nl> - else <nl> - throw new RuntimeException ( " Attempted to retexture a non - retexturable model : " + base ) ; <nl> + base = ( ( IRetexturableModel ) base ) . retexture ( textureMap ) ; <nl> } <nl> <nl> return base ; <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / IModel . java b / src / main / java / net / minecraftforge / client / model / IModel . java <nl> index 3ac5470 . . 6a9e1c4 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / IModel . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / IModel . java <nl> @ @ - 17 , 6 + 17 , 7 @ @ public interface IModel <nl> / * <nl> * Returns all model locations that this model depends on . <nl> * Assume that returned collection is immutable . <nl> + * See ModelLoaderRegistry . getModel for dependency loading . <nl> * / <nl> Collection < ResourceLocation > getDependencies ( ) ; <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / MapModelState . java b / src / main / java / net / minecraftforge / client / model / MapModelState . java <nl> index 62d9391 . . 2f1469f 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / MapModelState . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / MapModelState . java <nl> @ @ - 8 , 6 + 8 , 7 @ @ import com . google . common . collect . ImmutableMap ; <nl> <nl> / * <nl> * Simple implementation of IModelState via a map and a default value . Provides a full state for each part . <nl> + * You probably don ' t want to use this . <nl> * / <nl> public class MapModelState implements IModelState <nl> { <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> index 9404ff5 . . 865d402 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java <nl> @ @ - 330 , 13 + 330 , 21 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> } <nl> <nl> + private IModel getVariantModel ( ModelResourceLocation location ) <nl> + { <nl> + loadVariants ( ImmutableList . of ( location ) ) ; <nl> + IModel model = stateModels . get ( location ) ; <nl> + if ( model = = null ) model = getMissingModel ( ) ; <nl> + return model ; <nl> + } <nl> + <nl> private void resolveDependencies ( IModel model ) throws IOException <nl> { <nl> for ( ResourceLocation dep : model . getDependencies ( ) ) <nl> { <nl> if ( dep instanceof ModelResourceLocation ) <nl> { <nl> - loadVariants ( ImmutableList . of ( ( ModelResourceLocation ) dep ) ) ; <nl> + getVariantModel ( ( ModelResourceLocation ) dep ) ; <nl> } <nl> else <nl> { <nl> @ @ - 598 , 37 + 606 , 6 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> } <nl> <nl> - / / Weighted models can contain multiple copies of 1 model with different rotations - this is to make it work with IModelState ( different copies will be different objects ) . <nl> - private static class WeightedPartWrapper implements IModel <nl> - { <nl> - private final IModel model ; <nl> - <nl> - public WeightedPartWrapper ( IModel model ) <nl> - { <nl> - this . model = model ; <nl> - } <nl> - <nl> - public Collection < ResourceLocation > getDependencies ( ) <nl> - { <nl> - return model . getDependencies ( ) ; <nl> - } <nl> - <nl> - public Collection < ResourceLocation > getTextures ( ) <nl> - { <nl> - return model . getTextures ( ) ; <nl> - } <nl> - <nl> - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> - { <nl> - return model . bake ( state , format , bakedTextureGetter ) ; <nl> - } <nl> - <nl> - public IModelState getDefaultState ( ) <nl> - { <nl> - return model . getDefaultState ( ) ; <nl> - } <nl> - } <nl> - <nl> private class WeightedRandomModel implements IModel <nl> { <nl> private final List < Variant > variants ; <nl> @ @ - 636 , 11 + 613 , 10 @ @ public class ModelLoader extends ModelBakery <nl> private final List < IModel > models = new ArrayList < IModel > ( ) ; <nl> private final IModelState defaultState ; <nl> <nl> - @ Deprecated @ SuppressWarnings ( " unused " ) public WeightedRandomModel ( Variants variants ) { this ( null , variants ) ; } / / Remove 1 . 9 <nl> public WeightedRandomModel ( ModelResourceLocation parent , Variants variants ) <nl> { <nl> this . variants = variants . getVariants ( ) ; <nl> - ImmutableMap . Builder < MapModelState . Wrapper , IModelState > builder = ImmutableMap . builder ( ) ; <nl> + ImmutableList . Builder < Pair < IModel , IModelState > > builder = ImmutableList . builder ( ) ; <nl> for ( Variant v : ( List < Variant > ) variants . getVariants ( ) ) <nl> { <nl> ResourceLocation loc = v . getModelLocation ( ) ; <nl> @ @ - 676 , 20 + 652 , 18 @ @ public class ModelLoader extends ModelBakery <nl> textures . addAll ( model . getTextures ( ) ) ; / / Kick this , just in case . <nl> } <nl> <nl> - model = new WeightedPartWrapper ( model ) ; <nl> models . add ( model ) ; <nl> - builder . put ( MapModelState . wrap ( model ) , v . getState ( ) ) ; <nl> + builder . add ( Pair . of ( model , v . getState ( ) ) ) ; <nl> } <nl> <nl> if ( models . size ( ) = = 0 ) / / If all variants are missing , add one with the missing model and default rotation . <nl> { <nl> IModel missing = getMissingModel ( ) ; <nl> models . add ( missing ) ; <nl> - builder . put ( MapModelState . wrap ( missing ) , TRSRTransformation . identity ( ) ) ; <nl> + builder . add ( Pair . < IModel , IModelState > of ( missing , TRSRTransformation . identity ( ) ) ) ; <nl> } <nl> <nl> - defaultState = new MapModelState ( builder . build ( ) ) ; <nl> - <nl> + defaultState = new MultiModelState ( builder . build ( ) ) ; <nl> } <nl> <nl> public Collection < ResourceLocation > getDependencies ( ) <nl> @ @ - 708 , 15 + 682 , 6 @ @ public class ModelLoader extends ModelBakery <nl> return state ; <nl> } <nl> <nl> - private IModelState getState ( IModelState state , IModel model ) <nl> - { <nl> - if ( state instanceof MapModelState ) <nl> - { <nl> - return ( ( MapModelState ) state ) . getState ( model ) ; <nl> - } <nl> - return state ; <nl> - } <nl> - <nl> public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> { <nl> if ( ! Attributes . moreSpecific ( format , Attributes . DEFAULT _ BAKED _ FORMAT ) ) <nl> @ @ - 727 , 14 + 692 , 14 @ @ public class ModelLoader extends ModelBakery <nl> { <nl> Variant v = variants . get ( 0 ) ; <nl> IModel model = models . get ( 0 ) ; <nl> - return model . bake ( addUV ( v . isUvLocked ( ) , getState ( state , model ) ) , format , bakedTextureGetter ) ; <nl> + return model . bake ( addUV ( v . isUvLocked ( ) , MultiModelState . getPartState ( state , model , 0 ) ) , format , bakedTextureGetter ) ; <nl> } <nl> WeightedBakedModel . Builder builder = new WeightedBakedModel . Builder ( ) ; <nl> for ( int i = 0 ; i < variants . size ( ) ; i + + ) <nl> { <nl> IModel model = models . get ( i ) ; <nl> Variant v = variants . get ( i ) ; <nl> - builder . add ( model . bake ( addUV ( v . isUvLocked ( ) , getState ( state , model ) ) , format , bakedTextureGetter ) , variants . get ( i ) . getWeight ( ) ) ; <nl> + builder . add ( model . bake ( addUV ( v . isUvLocked ( ) , MultiModelState . getPartState ( state , model , i ) ) , format , bakedTextureGetter ) , variants . get ( i ) . getWeight ( ) ) ; <nl> } <nl> return new FlexibleWeightedBakedModel ( builder . build ( ) , Attributes . DEFAULT _ BAKED _ FORMAT ) ; <nl> } <nl> @ @ - 747 , 14 + 712 , 11 @ @ public class ModelLoader extends ModelBakery <nl> <nl> private static class FlexibleWeightedBakedModel extends WeightedBakedModel implements IFlexibleBakedModel <nl> { <nl> - @ SuppressWarnings ( " unused " ) <nl> - private final WeightedBakedModel parent ; <nl> private final VertexFormat format ; <nl> <nl> public FlexibleWeightedBakedModel ( WeightedBakedModel parent , VertexFormat format ) <nl> { <nl> super ( parent . models ) ; <nl> - this . parent = parent ; <nl> this . format = format ; <nl> } <nl> <nl> @ @ - 764 , 12 + 726 , 6 @ @ public class ModelLoader extends ModelBakery <nl> } <nl> } <nl> <nl> - @ SuppressWarnings ( " unused " ) <nl> - private boolean isBuiltinModel ( ModelBlock model ) <nl> - { <nl> - return model = = MODEL _ GENERATED | | model = = MODEL _ COMPASS | | model = = MODEL _ CLOCK | | model = = MODEL _ ENTITY ; <nl> - } <nl> - <nl> public IModel getMissingModel ( ) <nl> { <nl> if ( missingModel = = null ) <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoaderRegistry . java b / src / main / java / net / minecraftforge / client / model / ModelLoaderRegistry . java <nl> index c500827 . . 09d43a8 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / ModelLoaderRegistry . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / ModelLoaderRegistry . java <nl> @ @ - 10 , 6 + 10 , 7 @ @ import net . minecraft . client . Minecraft ; <nl> import net . minecraft . client . resources . IReloadableResourceManager ; <nl> import net . minecraft . client . resources . IResourceManager ; <nl> import net . minecraft . client . resources . IResourceManagerReloadListener ; <nl> + import net . minecraft . client . resources . model . ModelResourceLocation ; <nl> import net . minecraft . util . ResourceLocation ; <nl> import net . minecraftforge . client . model . ModelLoader . VanillaLoader ; <nl> import net . minecraftforge . client . model . b3d . B3DLoader ; <nl> @ @ - 64 , 58 + 65 , 79 @ @ public class ModelLoaderRegistry <nl> return new ResourceLocation ( location . getResourceDomain ( ) , " models / " + location . getResourcePath ( ) ) ; <nl> } <nl> <nl> + / * * <nl> + * Primary method to get IModel instances . <nl> + * ResourceLocation argument will be passed directly to the custom model loaders , <nl> + * ModelResourceLocation argument will be loaded through the blockstate system . <nl> + * / <nl> public static IModel getModel ( ResourceLocation location ) throws IOException <nl> { <nl> - if ( cache . containsKey ( location ) ) return cache . get ( location ) ; <nl> - ResourceLocation actual = getActualLocation ( location ) ; <nl> - ICustomModelLoader accepted = null ; <nl> - for ( ICustomModelLoader loader : loaders ) <nl> + IModel model ; <nl> + if ( location instanceof ModelResourceLocation ) <nl> { <nl> - try <nl> + ModelLoader loader = ModelLoader . VanillaLoader . instance . getLoader ( ) ; <nl> + if ( loader ! = null ) <nl> { <nl> - if ( loader . accepts ( actual ) ) <nl> - { <nl> - if ( accepted ! = null ) <nl> - { <nl> - FMLLog . severe ( " 2 loaders ( % s and % s ) want to load the same model % s " , accepted , loader , location ) ; <nl> - throw new IllegalStateException ( " 2 loaders want to load the same model " ) ; <nl> - } <nl> - accepted = loader ; <nl> - } <nl> + model = loader . getVariantModel ( ( ModelResourceLocation ) location ) ; <nl> } <nl> - catch ( Exception e ) <nl> + else <nl> { <nl> - FMLLog . log ( Level . ERROR , e , " Exception checking if model % s can be loaded with loader % s , skipping " , location , loader ) ; <nl> + FMLLog . log ( Level . ERROR , " Loading model too early , skipping : % s " , location ) ; <nl> + model = getMissingModel ( ) ; <nl> } <nl> } <nl> - <nl> - / / no custom loaders found , try vanilla one <nl> - if ( accepted = = null ) <nl> - { <nl> - if ( VanillaLoader . instance . accepts ( actual ) ) accepted = VanillaLoader . instance ; <nl> - } <nl> - <nl> - IModel model ; <nl> - if ( accepted = = null ) <nl> - { <nl> - FMLLog . severe ( " no suitable loader found for the model % s , skipping " , location ) ; <nl> - model = getMissingModel ( ) ; <nl> - } <nl> else <nl> { <nl> - try <nl> + if ( cache . containsKey ( location ) ) return cache . get ( location ) ; <nl> + ResourceLocation actual = getActualLocation ( location ) ; <nl> + ICustomModelLoader accepted = null ; <nl> + for ( ICustomModelLoader loader : loaders ) <nl> { <nl> - model = accepted . loadModel ( actual ) ; <nl> + try <nl> + { <nl> + if ( loader . accepts ( actual ) ) <nl> + { <nl> + if ( accepted ! = null ) <nl> + { <nl> + FMLLog . severe ( " 2 loaders ( % s and % s ) want to load the same model % s " , accepted , loader , location ) ; <nl> + throw new IllegalStateException ( " 2 loaders want to load the same model " ) ; <nl> + } <nl> + accepted = loader ; <nl> + } <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + FMLLog . log ( Level . ERROR , e , " Exception checking if model % s can be loaded with loader % s , skipping " , location , loader ) ; <nl> + } <nl> } <nl> - catch ( IOException e ) <nl> + <nl> + / / no custom loaders found , try vanilla one <nl> + if ( accepted = = null ) <nl> { <nl> - throw e ; <nl> + if ( VanillaLoader . instance . accepts ( actual ) ) accepted = VanillaLoader . instance ; <nl> } <nl> - catch ( Exception e ) <nl> + <nl> + if ( accepted = = null ) <nl> { <nl> - FMLLog . log ( Level . ERROR , e , " Exception loading model % s with loader % s , skipping " , location , accepted ) ; <nl> + FMLLog . severe ( " no suitable loader found for the model % s , skipping " , location ) ; <nl> model = getMissingModel ( ) ; <nl> } <nl> + else <nl> + { <nl> + try <nl> + { <nl> + model = accepted . loadModel ( actual ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw e ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + FMLLog . log ( Level . ERROR , e , " Exception loading model % s with loader % s , skipping " , location , accepted ) ; <nl> + model = getMissingModel ( ) ; <nl> + } <nl> + } <nl> } <nl> cache . put ( location , model ) ; <nl> return model ; <nl> diff - - git a / src / main / java / net / minecraftforge / client / model / MultiLayerModel . java b / src / main / java / net / minecraftforge / client / model / MultiLayerModel . java <nl> index fa8eb1a . . 18a8eed 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / MultiLayerModel . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / MultiLayerModel . java <nl> @ @ - 1 , 5 + 1 , 6 @ @ <nl> package net . minecraftforge . client . model ; <nl> <nl> + import java . io . IOException ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> <nl> @ @ - 14 , 7 + 15 , 6 @ @ import net . minecraft . client . renderer . texture . TextureAtlasSprite ; <nl> import net . minecraft . client . renderer . vertex . VertexFormat ; <nl> import net . minecraft . client . resources . IResourceManager ; <nl> import net . minecraft . client . resources . model . IBakedModel ; <nl> - import net . minecraft . client . resources . model . ModelManager ; <nl> import net . minecraft . client . resources . model . ModelResourceLocation ; <nl> import net . minecraft . util . EnumFacing ; <nl> import net . minecraft . util . EnumWorldBlockLayer ; <nl> @ @ - 23 , 6 + 23 , 7 @ @ import net . minecraftforge . client . MinecraftForgeClient ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> <nl> import org . apache . commons . lang3 . tuple . Pair ; <nl> + import org . apache . logging . log4j . Level ; <nl> <nl> import com . google . common . base . Function ; <nl> import com . google . common . base . Optional ; <nl> @ @ - 54 , 10 + 55 , 36 @ @ public class MultiLayerModel implements IModelCustomData <nl> return ImmutableList . of ( ) ; <nl> } <nl> <nl> + private static ImmutableMap < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > buildModels ( ImmutableMap < Optional < EnumWorldBlockLayer > , ModelResourceLocation > models , IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> + { <nl> + ImmutableMap . Builder < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > builder = ImmutableMap . builder ( ) ; <nl> + for ( Optional < EnumWorldBlockLayer > key : models . keySet ( ) ) <nl> + { <nl> + IModel model ; <nl> + try <nl> + { <nl> + model = ModelLoaderRegistry . getModel ( models . get ( key ) ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + FMLLog . log ( Level . ERROR , e , " Couldn ' t load MultiLayerModel dependency : % s " , models . get ( key ) ) ; <nl> + model = ModelLoaderRegistry . getMissingModel ( ) ; <nl> + } <nl> + builder . put ( key , model . bake ( new ModelStateComposition ( state , model . getDefaultState ( ) ) , format , bakedTextureGetter ) ) ; <nl> + } <nl> + return builder . build ( ) ; <nl> + } <nl> + <nl> @ Override <nl> public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) <nl> { <nl> - return new MultiLayerBakedModel ( models , format , IPerspectiveAwareModel . MapWrapper . getTransforms ( state ) ) ; <nl> + IModel missing = ModelLoaderRegistry . getMissingModel ( ) ; <nl> + return new MultiLayerBakedModel ( <nl> + buildModels ( models , state , format , bakedTextureGetter ) , <nl> + missing . bake ( missing . getDefaultState ( ) , format , bakedTextureGetter ) , <nl> + format , <nl> + IPerspectiveAwareModel . MapWrapper . getTransforms ( state ) <nl> + ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 102 , 63 + 129 , 59 @ @ public class MultiLayerModel implements IModelCustomData <nl> <nl> public static class MultiLayerBakedModel implements IFlexibleBakedModel , ISmartBlockModel , IPerspectiveAwareModel <nl> { <nl> - private final ImmutableMap < Optional < EnumWorldBlockLayer > , ModelResourceLocation > models ; <nl> + private final ImmutableMap < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > models ; <nl> private final VertexFormat format ; <nl> private final ImmutableMap < TransformType , TRSRTransformation > cameraTransforms ; ; <nl> - private IBakedModel missing ; <nl> - private IBakedModel base ; <nl> - private ImmutableMap < EnumWorldBlockLayer , IBakedModel > bakedModels ; <nl> - private ImmutableMap < Optional < EnumFacing > , ImmutableList < BakedQuad > > quads ; <nl> + private final IFlexibleBakedModel base ; <nl> + private final IFlexibleBakedModel missing ; <nl> + private final ImmutableMap < Optional < EnumFacing > , ImmutableList < BakedQuad > > quads ; <nl> <nl> + private static final Function < ResourceLocation , TextureAtlasSprite > defaultTextureGetter = new Function < ResourceLocation , TextureAtlasSprite > ( ) <nl> + { <nl> + public TextureAtlasSprite apply ( ResourceLocation location ) <nl> + { <nl> + return Minecraft . getMinecraft ( ) . getTextureMapBlocks ( ) . getAtlasSprite ( location . toString ( ) ) ; <nl> + } <nl> + } ; <nl> + <nl> + @ Deprecated / / remove 1 . 9 <nl> public MultiLayerBakedModel ( ImmutableMap < Optional < EnumWorldBlockLayer > , ModelResourceLocation > models , VertexFormat format , ImmutableMap < TransformType , TRSRTransformation > cameraTransforms ) <nl> { <nl> - this . models = models ; <nl> - this . format = format ; <nl> - this . cameraTransforms = cameraTransforms ; <nl> + this ( <nl> + buildModels ( models , TRSRTransformation . identity ( ) , format , defaultTextureGetter ) , <nl> + ModelLoaderRegistry . getMissingModel ( ) . bake ( ModelLoaderRegistry . getMissingModel ( ) . getDefaultState ( ) , format , defaultTextureGetter ) , <nl> + format , <nl> + cameraTransforms <nl> + ) ; <nl> } <nl> <nl> - private void compute ( ) <nl> + public MultiLayerBakedModel ( ImmutableMap < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > models , IFlexibleBakedModel missing , VertexFormat format , ImmutableMap < TransformType , TRSRTransformation > cameraTransforms ) <nl> { <nl> - if ( base = = null ) <nl> + this . models = models ; <nl> + this . format = format ; <nl> + this . cameraTransforms = cameraTransforms ; <nl> + this . missing = missing ; <nl> + if ( models . containsKey ( Optional . absent ( ) ) ) <nl> { <nl> - ModelManager manager = Minecraft . getMinecraft ( ) . getBlockRendererDispatcher ( ) . getBlockModelShapes ( ) . getModelManager ( ) ; <nl> - missing = manager . getMissingModel ( ) ; <nl> - base = getModel ( manager , Optional . < EnumWorldBlockLayer > absent ( ) ) ; <nl> - <nl> - ImmutableMap . Builder < EnumWorldBlockLayer , IBakedModel > builder = ImmutableMap . builder ( ) ; <nl> - for ( EnumWorldBlockLayer layer : EnumWorldBlockLayer . values ( ) ) <nl> - { <nl> - if ( models . containsKey ( Optional . of ( layer ) ) ) <nl> - { <nl> - builder . put ( layer , getModel ( manager , Optional . of ( layer ) ) ) ; <nl> - } <nl> - } <nl> - bakedModels = builder . build ( ) ; <nl> - <nl> - ImmutableMap . Builder < Optional < EnumFacing > , ImmutableList < BakedQuad > > quadBuilder = ImmutableMap . builder ( ) ; <nl> - quadBuilder . put ( Optional . < EnumFacing > absent ( ) , buildQuads ( Optional . < EnumFacing > absent ( ) ) ) ; <nl> - for ( EnumFacing side : EnumFacing . values ( ) ) <nl> - { <nl> - quadBuilder . put ( Optional . of ( side ) , buildQuads ( Optional . of ( side ) ) ) ; <nl> - } <nl> - quads = quadBuilder . build ( ) ; <nl> + base = models . get ( Optional . absent ( ) ) ; <nl> } <nl> - } <nl> - <nl> - private IBakedModel getModel ( ModelManager manager , Optional < EnumWorldBlockLayer > layer ) <nl> - { <nl> - ModelResourceLocation loc = models . get ( layer ) ; <nl> - if ( loc = = null ) <nl> + else <nl> + { <nl> + base = missing ; <nl> + } <nl> + ImmutableMap . Builder < Optional < EnumFacing > , ImmutableList < BakedQuad > > quadBuilder = ImmutableMap . builder ( ) ; <nl> + quadBuilder . put ( Optional . < EnumFacing > absent ( ) , buildQuads ( models , Optional . < EnumFacing > absent ( ) ) ) ; <nl> + for ( EnumFacing side : EnumFacing . values ( ) ) <nl> { <nl> - loc = new ModelResourceLocation ( " builtin / missing " , " missing " ) ; <nl> + quadBuilder . put ( Optional . of ( side ) , buildQuads ( models , Optional . of ( side ) ) ) ; <nl> } <nl> - return manager . getModel ( loc ) ; <nl> + quads = quadBuilder . build ( ) ; <nl> } <nl> <nl> - private ImmutableList < BakedQuad > buildQuads ( Optional < EnumFacing > side ) <nl> + private static ImmutableList < BakedQuad > buildQuads ( ImmutableMap < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > models , Optional < EnumFacing > side ) <nl> { <nl> ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; <nl> - for ( IBakedModel model : bakedModels . values ( ) ) <nl> + for ( IBakedModel model : models . values ( ) ) <nl> { <nl> if ( side . isPresent ( ) ) <nl> { <nl> @ @ - 175 , 42 + 198 , 36 @ @ public class MultiLayerModel implements IModelCustomData <nl> @ Override <nl> public List < BakedQuad > getFaceQuads ( EnumFacing side ) <nl> { <nl> - compute ( ) ; <nl> return quads . get ( Optional . of ( side ) ) ; <nl> } <nl> <nl> @ Override <nl> public List < BakedQuad > getGeneralQuads ( ) <nl> { <nl> - compute ( ) ; <nl> return quads . get ( Optional . absent ( ) ) ; <nl> } <nl> <nl> @ Override <nl> public boolean isAmbientOcclusion ( ) <nl> { <nl> - compute ( ) ; <nl> return base . isAmbientOcclusion ( ) ; <nl> } <nl> <nl> @ Override <nl> public boolean isGui3d ( ) <nl> { <nl> - compute ( ) ; <nl> return base . isGui3d ( ) ; <nl> } <nl> <nl> @ Override <nl> public boolean isBuiltInRenderer ( ) <nl> { <nl> - compute ( ) ; <nl> return base . isBuiltInRenderer ( ) ; <nl> } <nl> <nl> @ Override <nl> public TextureAtlasSprite getParticleTexture ( ) <nl> { <nl> - compute ( ) ; <nl> return base . getParticleTexture ( ) ; <nl> } <nl> <nl> @ @ - 223 , 13 + 240 , 12 @ @ public class MultiLayerModel implements IModelCustomData <nl> @ Override <nl> public IBakedModel handleBlockState ( IBlockState state ) <nl> { <nl> - compute ( ) ; <nl> - EnumWorldBlockLayer layer = MinecraftForgeClient . getRenderLayer ( ) ; <nl> - if ( ! bakedModels . containsKey ( layer ) ) <nl> + Optional < EnumWorldBlockLayer > layer = Optional . of ( MinecraftForgeClient . getRenderLayer ( ) ) ; <nl> + if ( ! models . containsKey ( layer ) ) <nl> { <nl> return missing ; <nl> } <nl> - return bakedModels . get ( layer ) ; <nl> + return models . get ( layer ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / test / resources / assets / forgedebugmultilayermodel / blockstates / test _ layer _ block . json b / src / test / resources / assets / forgedebugmultilayermodel / blockstates / test _ layer _ block . json <nl> index 50a1efe . . 15a23f0 100644 <nl> - - - a / src / test / resources / assets / forgedebugmultilayermodel / blockstates / test _ layer _ block . json <nl> + + + b / src / test / resources / assets / forgedebugmultilayermodel / blockstates / test _ layer _ block . json <nl> @ @ - 4 , 15 + 4 , 20 @ @ <nl> " model " : " forge : multi - layer " , <nl> " custom " : { <nl> / / base is used for model properties - camera transforms , isGui3d , e . t . c . <nl> - " base " : " minecraft : stone _ slab # half = bottom " , <nl> + " base " : " forgedebugmultilayermodel : test _ layer _ block # aux " , <nl> / / per - layer models <nl> - " Solid " : " minecraft : stone _ slab # half = bottom " , <nl> + " Solid " : " forgedebugmultilayermodel : test _ layer _ block # aux " , <nl> " Translucent " : " minecraft : pink _ stained _ glass _ pane # east = true , north = false , south = false , west = true " <nl> } , <nl> " transform " : " forge : default - block " <nl> } , <nl> " variants " : { <nl> " normal " : [ { } ] , <nl> - " inventory " : [ { } ] <nl> + " inventory " : [ { } ] , <nl> + " aux " : [ { <nl> + " model " : " cube _ all " , <nl> + " textures " : { " all " : " blocks / slime " } , <nl> + " transform " : { " scale " : . 5 } <nl> + } ] <nl> } <nl> }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java b / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java 
 index dffcc5b . . cda7c8b 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java 
 @ @ - 200 , 10 + 200 , 6 @ @ public class BlockStateLoader 
 return base ; 
 } 
 
 - / / Apply rotation of base model to sub - models . 
 - / / If baseRot is non - null , then that rotation will be applied instead of the base model ' s rotation . 
 - / / This is used to allow replacing base model with a sub - model when there is no base model for a variant . 
 - IModelState baseTr = getState ( ) ; 
 ImmutableMap . Builder < String , Pair < IModel , IModelState > > models = ImmutableMap . builder ( ) ; 
 for ( Entry < String , SubModel > entry : parts . entrySet ( ) ) 
 { 
 @ @ - 224 , 7 + 220 , 7 @ @ public class BlockStateLoader 
 models . put ( entry . getKey ( ) , Pair . of ( runModelHooks ( model , part . smooth , part . gui3d , part . uvLock , part . getTextures ( ) , part . getCustomData ( ) ) , part . getState ( ) ) ) ; 
 } 
 
 - return new MultiModel ( getModelLocation ( ) , hasBase ? base : null , baseTr , models . build ( ) ) ; 
 + return new MultiModel ( getModelLocation ( ) , hasBase ? base : null , models . build ( ) ) ; 
 } 
 
 @ Override 
 diff - - git a / src / main / java / net / minecraftforge / client / model / MultiModel . java b / src / main / java / net / minecraftforge / client / model / MultiModel . java 
 index 455c028 . . 463b0b1 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / MultiModel . java 
 + + + b / src / main / java / net / minecraftforge / client / model / MultiModel . java 
 @ @ - 227 , 20 + 227 , 32 @ @ public final class MultiModel implements IModel 
 private final ResourceLocation location ; 
 @ Nullable 
 private final IModel base ; 
 - private final IModelState baseState ; 
 private final Map < String , Pair < IModel , IModelState > > parts ; 
 
 + / / TODO 1 . 13 remove , kept for binary compatibility 
 + @ Deprecated 
 public MultiModel ( ResourceLocation location , @ Nullable IModel base , IModelState baseState , ImmutableMap < String , Pair < IModel , IModelState > > parts ) 
 { 
 + this ( location , base , parts ) ; 
 + } 
 + 
 + public MultiModel ( ResourceLocation location , @ Nullable IModel base , ImmutableMap < String , Pair < IModel , IModelState > > parts ) 
 + { 
 this . location = location ; 
 this . base = base ; 
 - this . baseState = baseState ; 
 this . parts = parts ; 
 } 
 
 + / / TODO 1 . 13 remove , kept for binary compatibility 
 + @ Deprecated 
 public MultiModel ( ResourceLocation location , IModel base , IModelState baseState , Map < String , Pair < IModel , IModelState > > parts ) 
 { 
 - this ( location , base , baseState , ImmutableMap . copyOf ( parts ) ) ; 
 + this ( location , base , parts ) ; 
 + } 
 + 
 + public MultiModel ( ResourceLocation location , IModel base , Map < String , Pair < IModel , IModelState > > parts ) 
 + { 
 + this ( location , base , ImmutableMap . copyOf ( parts ) ) ; 
 } 
 
 @ Override 
 @ @ - 295 , 10 + 307 , 4 @ @ public final class MultiModel implements IModel 
 } 
 return new Baked ( location , true , bakedBase , mapBuilder . build ( ) ) ; 
 } 
 - 
 - @ Override 
 - public IModelState getDefaultState ( ) 
 - { 
 - return baseState ; 
 - } 
 }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java b / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java 
 index 2559856 . . b6fb4f0 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / BlockStateLoader . java 
 @ @ - 134 , 20 + 134 , 14 @ @ public class BlockStateLoader 
 
 protected IModel runModelHooks ( IModel base , ImmutableMap < String , String > textureMap , ImmutableMap < String , String > customData ) 
 { 
 - if ( ! customData . isEmpty ( ) ) 
 + if ( ! customData . isEmpty ( ) & & base instanceof IModelCustomData ) 
 { 
 - if ( base instanceof IModelCustomData ) 
 - base = ( ( IModelCustomData ) base ) . process ( customData ) ; 
 - else 
 - throw new RuntimeException ( " Attempted to add custom data to a model that doesn ' t need it : " + base ) ; 
 + base = ( ( IModelCustomData ) base ) . process ( customData ) ; 
 } 
 
 - if ( ! textureMap . isEmpty ( ) ) 
 + if ( ! textureMap . isEmpty ( ) & & base instanceof IRetexturableModel ) 
 { 
 - if ( base instanceof IRetexturableModel ) 
 - base = ( ( IRetexturableModel ) base ) . retexture ( textureMap ) ; 
 - else 
 - throw new RuntimeException ( " Attempted to retexture a non - retexturable model : " + base ) ; 
 + base = ( ( IRetexturableModel ) base ) . retexture ( textureMap ) ; 
 } 
 
 return base ; 
 diff - - git a / src / main / java / net / minecraftforge / client / model / IModel . java b / src / main / java / net / minecraftforge / client / model / IModel . java 
 index 3ac5470 . . 6a9e1c4 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / IModel . java 
 + + + b / src / main / java / net / minecraftforge / client / model / IModel . java 
 @ @ - 17 , 6 + 17 , 7 @ @ public interface IModel 
 / * 
 * Returns all model locations that this model depends on . 
 * Assume that returned collection is immutable . 
 + * See ModelLoaderRegistry . getModel for dependency loading . 
 * / 
 Collection < ResourceLocation > getDependencies ( ) ; 
 
 diff - - git a / src / main / java / net / minecraftforge / client / model / MapModelState . java b / src / main / java / net / minecraftforge / client / model / MapModelState . java 
 index 62d9391 . . 2f1469f 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / MapModelState . java 
 + + + b / src / main / java / net / minecraftforge / client / model / MapModelState . java 
 @ @ - 8 , 6 + 8 , 7 @ @ import com . google . common . collect . ImmutableMap ; 
 
 / * 
 * Simple implementation of IModelState via a map and a default value . Provides a full state for each part . 
 + * You probably don ' t want to use this . 
 * / 
 public class MapModelState implements IModelState 
 { 
 diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoader . java b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 index 9404ff5 . . 865d402 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 + + + b / src / main / java / net / minecraftforge / client / model / ModelLoader . java 
 @ @ - 330 , 13 + 330 , 21 @ @ public class ModelLoader extends ModelBakery 
 } 
 } 
 
 + private IModel getVariantModel ( ModelResourceLocation location ) 
 + { 
 + loadVariants ( ImmutableList . of ( location ) ) ; 
 + IModel model = stateModels . get ( location ) ; 
 + if ( model = = null ) model = getMissingModel ( ) ; 
 + return model ; 
 + } 
 + 
 private void resolveDependencies ( IModel model ) throws IOException 
 { 
 for ( ResourceLocation dep : model . getDependencies ( ) ) 
 { 
 if ( dep instanceof ModelResourceLocation ) 
 { 
 - loadVariants ( ImmutableList . of ( ( ModelResourceLocation ) dep ) ) ; 
 + getVariantModel ( ( ModelResourceLocation ) dep ) ; 
 } 
 else 
 { 
 @ @ - 598 , 37 + 606 , 6 @ @ public class ModelLoader extends ModelBakery 
 } 
 } 
 
 - / / Weighted models can contain multiple copies of 1 model with different rotations - this is to make it work with IModelState ( different copies will be different objects ) . 
 - private static class WeightedPartWrapper implements IModel 
 - { 
 - private final IModel model ; 
 - 
 - public WeightedPartWrapper ( IModel model ) 
 - { 
 - this . model = model ; 
 - } 
 - 
 - public Collection < ResourceLocation > getDependencies ( ) 
 - { 
 - return model . getDependencies ( ) ; 
 - } 
 - 
 - public Collection < ResourceLocation > getTextures ( ) 
 - { 
 - return model . getTextures ( ) ; 
 - } 
 - 
 - public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 - { 
 - return model . bake ( state , format , bakedTextureGetter ) ; 
 - } 
 - 
 - public IModelState getDefaultState ( ) 
 - { 
 - return model . getDefaultState ( ) ; 
 - } 
 - } 
 - 
 private class WeightedRandomModel implements IModel 
 { 
 private final List < Variant > variants ; 
 @ @ - 636 , 11 + 613 , 10 @ @ public class ModelLoader extends ModelBakery 
 private final List < IModel > models = new ArrayList < IModel > ( ) ; 
 private final IModelState defaultState ; 
 
 - @ Deprecated @ SuppressWarnings ( " unused " ) public WeightedRandomModel ( Variants variants ) { this ( null , variants ) ; } / / Remove 1 . 9 
 public WeightedRandomModel ( ModelResourceLocation parent , Variants variants ) 
 { 
 this . variants = variants . getVariants ( ) ; 
 - ImmutableMap . Builder < MapModelState . Wrapper , IModelState > builder = ImmutableMap . builder ( ) ; 
 + ImmutableList . Builder < Pair < IModel , IModelState > > builder = ImmutableList . builder ( ) ; 
 for ( Variant v : ( List < Variant > ) variants . getVariants ( ) ) 
 { 
 ResourceLocation loc = v . getModelLocation ( ) ; 
 @ @ - 676 , 20 + 652 , 18 @ @ public class ModelLoader extends ModelBakery 
 textures . addAll ( model . getTextures ( ) ) ; / / Kick this , just in case . 
 } 
 
 - model = new WeightedPartWrapper ( model ) ; 
 models . add ( model ) ; 
 - builder . put ( MapModelState . wrap ( model ) , v . getState ( ) ) ; 
 + builder . add ( Pair . of ( model , v . getState ( ) ) ) ; 
 } 
 
 if ( models . size ( ) = = 0 ) / / If all variants are missing , add one with the missing model and default rotation . 
 { 
 IModel missing = getMissingModel ( ) ; 
 models . add ( missing ) ; 
 - builder . put ( MapModelState . wrap ( missing ) , TRSRTransformation . identity ( ) ) ; 
 + builder . add ( Pair . < IModel , IModelState > of ( missing , TRSRTransformation . identity ( ) ) ) ; 
 } 
 
 - defaultState = new MapModelState ( builder . build ( ) ) ; 
 - 
 + defaultState = new MultiModelState ( builder . build ( ) ) ; 
 } 
 
 public Collection < ResourceLocation > getDependencies ( ) 
 @ @ - 708 , 15 + 682 , 6 @ @ public class ModelLoader extends ModelBakery 
 return state ; 
 } 
 
 - private IModelState getState ( IModelState state , IModel model ) 
 - { 
 - if ( state instanceof MapModelState ) 
 - { 
 - return ( ( MapModelState ) state ) . getState ( model ) ; 
 - } 
 - return state ; 
 - } 
 - 
 public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 { 
 if ( ! Attributes . moreSpecific ( format , Attributes . DEFAULT _ BAKED _ FORMAT ) ) 
 @ @ - 727 , 14 + 692 , 14 @ @ public class ModelLoader extends ModelBakery 
 { 
 Variant v = variants . get ( 0 ) ; 
 IModel model = models . get ( 0 ) ; 
 - return model . bake ( addUV ( v . isUvLocked ( ) , getState ( state , model ) ) , format , bakedTextureGetter ) ; 
 + return model . bake ( addUV ( v . isUvLocked ( ) , MultiModelState . getPartState ( state , model , 0 ) ) , format , bakedTextureGetter ) ; 
 } 
 WeightedBakedModel . Builder builder = new WeightedBakedModel . Builder ( ) ; 
 for ( int i = 0 ; i < variants . size ( ) ; i + + ) 
 { 
 IModel model = models . get ( i ) ; 
 Variant v = variants . get ( i ) ; 
 - builder . add ( model . bake ( addUV ( v . isUvLocked ( ) , getState ( state , model ) ) , format , bakedTextureGetter ) , variants . get ( i ) . getWeight ( ) ) ; 
 + builder . add ( model . bake ( addUV ( v . isUvLocked ( ) , MultiModelState . getPartState ( state , model , i ) ) , format , bakedTextureGetter ) , variants . get ( i ) . getWeight ( ) ) ; 
 } 
 return new FlexibleWeightedBakedModel ( builder . build ( ) , Attributes . DEFAULT _ BAKED _ FORMAT ) ; 
 } 
 @ @ - 747 , 14 + 712 , 11 @ @ public class ModelLoader extends ModelBakery 
 
 private static class FlexibleWeightedBakedModel extends WeightedBakedModel implements IFlexibleBakedModel 
 { 
 - @ SuppressWarnings ( " unused " ) 
 - private final WeightedBakedModel parent ; 
 private final VertexFormat format ; 
 
 public FlexibleWeightedBakedModel ( WeightedBakedModel parent , VertexFormat format ) 
 { 
 super ( parent . models ) ; 
 - this . parent = parent ; 
 this . format = format ; 
 } 
 
 @ @ - 764 , 12 + 726 , 6 @ @ public class ModelLoader extends ModelBakery 
 } 
 } 
 
 - @ SuppressWarnings ( " unused " ) 
 - private boolean isBuiltinModel ( ModelBlock model ) 
 - { 
 - return model = = MODEL _ GENERATED | | model = = MODEL _ COMPASS | | model = = MODEL _ CLOCK | | model = = MODEL _ ENTITY ; 
 - } 
 - 
 public IModel getMissingModel ( ) 
 { 
 if ( missingModel = = null ) 
 diff - - git a / src / main / java / net / minecraftforge / client / model / ModelLoaderRegistry . java b / src / main / java / net / minecraftforge / client / model / ModelLoaderRegistry . java 
 index c500827 . . 09d43a8 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / ModelLoaderRegistry . java 
 + + + b / src / main / java / net / minecraftforge / client / model / ModelLoaderRegistry . java 
 @ @ - 10 , 6 + 10 , 7 @ @ import net . minecraft . client . Minecraft ; 
 import net . minecraft . client . resources . IReloadableResourceManager ; 
 import net . minecraft . client . resources . IResourceManager ; 
 import net . minecraft . client . resources . IResourceManagerReloadListener ; 
 + import net . minecraft . client . resources . model . ModelResourceLocation ; 
 import net . minecraft . util . ResourceLocation ; 
 import net . minecraftforge . client . model . ModelLoader . VanillaLoader ; 
 import net . minecraftforge . client . model . b3d . B3DLoader ; 
 @ @ - 64 , 58 + 65 , 79 @ @ public class ModelLoaderRegistry 
 return new ResourceLocation ( location . getResourceDomain ( ) , " models / " + location . getResourcePath ( ) ) ; 
 } 
 
 + / * * 
 + * Primary method to get IModel instances . 
 + * ResourceLocation argument will be passed directly to the custom model loaders , 
 + * ModelResourceLocation argument will be loaded through the blockstate system . 
 + * / 
 public static IModel getModel ( ResourceLocation location ) throws IOException 
 { 
 - if ( cache . containsKey ( location ) ) return cache . get ( location ) ; 
 - ResourceLocation actual = getActualLocation ( location ) ; 
 - ICustomModelLoader accepted = null ; 
 - for ( ICustomModelLoader loader : loaders ) 
 + IModel model ; 
 + if ( location instanceof ModelResourceLocation ) 
 { 
 - try 
 + ModelLoader loader = ModelLoader . VanillaLoader . instance . getLoader ( ) ; 
 + if ( loader ! = null ) 
 { 
 - if ( loader . accepts ( actual ) ) 
 - { 
 - if ( accepted ! = null ) 
 - { 
 - FMLLog . severe ( " 2 loaders ( % s and % s ) want to load the same model % s " , accepted , loader , location ) ; 
 - throw new IllegalStateException ( " 2 loaders want to load the same model " ) ; 
 - } 
 - accepted = loader ; 
 - } 
 + model = loader . getVariantModel ( ( ModelResourceLocation ) location ) ; 
 } 
 - catch ( Exception e ) 
 + else 
 { 
 - FMLLog . log ( Level . ERROR , e , " Exception checking if model % s can be loaded with loader % s , skipping " , location , loader ) ; 
 + FMLLog . log ( Level . ERROR , " Loading model too early , skipping : % s " , location ) ; 
 + model = getMissingModel ( ) ; 
 } 
 } 
 - 
 - / / no custom loaders found , try vanilla one 
 - if ( accepted = = null ) 
 - { 
 - if ( VanillaLoader . instance . accepts ( actual ) ) accepted = VanillaLoader . instance ; 
 - } 
 - 
 - IModel model ; 
 - if ( accepted = = null ) 
 - { 
 - FMLLog . severe ( " no suitable loader found for the model % s , skipping " , location ) ; 
 - model = getMissingModel ( ) ; 
 - } 
 else 
 { 
 - try 
 + if ( cache . containsKey ( location ) ) return cache . get ( location ) ; 
 + ResourceLocation actual = getActualLocation ( location ) ; 
 + ICustomModelLoader accepted = null ; 
 + for ( ICustomModelLoader loader : loaders ) 
 { 
 - model = accepted . loadModel ( actual ) ; 
 + try 
 + { 
 + if ( loader . accepts ( actual ) ) 
 + { 
 + if ( accepted ! = null ) 
 + { 
 + FMLLog . severe ( " 2 loaders ( % s and % s ) want to load the same model % s " , accepted , loader , location ) ; 
 + throw new IllegalStateException ( " 2 loaders want to load the same model " ) ; 
 + } 
 + accepted = loader ; 
 + } 
 + } 
 + catch ( Exception e ) 
 + { 
 + FMLLog . log ( Level . ERROR , e , " Exception checking if model % s can be loaded with loader % s , skipping " , location , loader ) ; 
 + } 
 } 
 - catch ( IOException e ) 
 + 
 + / / no custom loaders found , try vanilla one 
 + if ( accepted = = null ) 
 { 
 - throw e ; 
 + if ( VanillaLoader . instance . accepts ( actual ) ) accepted = VanillaLoader . instance ; 
 } 
 - catch ( Exception e ) 
 + 
 + if ( accepted = = null ) 
 { 
 - FMLLog . log ( Level . ERROR , e , " Exception loading model % s with loader % s , skipping " , location , accepted ) ; 
 + FMLLog . severe ( " no suitable loader found for the model % s , skipping " , location ) ; 
 model = getMissingModel ( ) ; 
 } 
 + else 
 + { 
 + try 
 + { 
 + model = accepted . loadModel ( actual ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw e ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + FMLLog . log ( Level . ERROR , e , " Exception loading model % s with loader % s , skipping " , location , accepted ) ; 
 + model = getMissingModel ( ) ; 
 + } 
 + } 
 } 
 cache . put ( location , model ) ; 
 return model ; 
 diff - - git a / src / main / java / net / minecraftforge / client / model / MultiLayerModel . java b / src / main / java / net / minecraftforge / client / model / MultiLayerModel . java 
 index fa8eb1a . . 18a8eed 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / MultiLayerModel . java 
 + + + b / src / main / java / net / minecraftforge / client / model / MultiLayerModel . java 
 @ @ - 1 , 5 + 1 , 6 @ @ 
 package net . minecraftforge . client . model ; 
 
 + import java . io . IOException ; 
 import java . util . Collection ; 
 import java . util . List ; 
 
 @ @ - 14 , 7 + 15 , 6 @ @ import net . minecraft . client . renderer . texture . TextureAtlasSprite ; 
 import net . minecraft . client . renderer . vertex . VertexFormat ; 
 import net . minecraft . client . resources . IResourceManager ; 
 import net . minecraft . client . resources . model . IBakedModel ; 
 - import net . minecraft . client . resources . model . ModelManager ; 
 import net . minecraft . client . resources . model . ModelResourceLocation ; 
 import net . minecraft . util . EnumFacing ; 
 import net . minecraft . util . EnumWorldBlockLayer ; 
 @ @ - 23 , 6 + 23 , 7 @ @ import net . minecraftforge . client . MinecraftForgeClient ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 
 import org . apache . commons . lang3 . tuple . Pair ; 
 + import org . apache . logging . log4j . Level ; 
 
 import com . google . common . base . Function ; 
 import com . google . common . base . Optional ; 
 @ @ - 54 , 10 + 55 , 36 @ @ public class MultiLayerModel implements IModelCustomData 
 return ImmutableList . of ( ) ; 
 } 
 
 + private static ImmutableMap < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > buildModels ( ImmutableMap < Optional < EnumWorldBlockLayer > , ModelResourceLocation > models , IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 + { 
 + ImmutableMap . Builder < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > builder = ImmutableMap . builder ( ) ; 
 + for ( Optional < EnumWorldBlockLayer > key : models . keySet ( ) ) 
 + { 
 + IModel model ; 
 + try 
 + { 
 + model = ModelLoaderRegistry . getModel ( models . get ( key ) ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + FMLLog . log ( Level . ERROR , e , " Couldn ' t load MultiLayerModel dependency : % s " , models . get ( key ) ) ; 
 + model = ModelLoaderRegistry . getMissingModel ( ) ; 
 + } 
 + builder . put ( key , model . bake ( new ModelStateComposition ( state , model . getDefaultState ( ) ) , format , bakedTextureGetter ) ) ; 
 + } 
 + return builder . build ( ) ; 
 + } 
 + 
 @ Override 
 public IFlexibleBakedModel bake ( IModelState state , VertexFormat format , Function < ResourceLocation , TextureAtlasSprite > bakedTextureGetter ) 
 { 
 - return new MultiLayerBakedModel ( models , format , IPerspectiveAwareModel . MapWrapper . getTransforms ( state ) ) ; 
 + IModel missing = ModelLoaderRegistry . getMissingModel ( ) ; 
 + return new MultiLayerBakedModel ( 
 + buildModels ( models , state , format , bakedTextureGetter ) , 
 + missing . bake ( missing . getDefaultState ( ) , format , bakedTextureGetter ) , 
 + format , 
 + IPerspectiveAwareModel . MapWrapper . getTransforms ( state ) 
 + ) ; 
 } 
 
 @ Override 
 @ @ - 102 , 63 + 129 , 59 @ @ public class MultiLayerModel implements IModelCustomData 
 
 public static class MultiLayerBakedModel implements IFlexibleBakedModel , ISmartBlockModel , IPerspectiveAwareModel 
 { 
 - private final ImmutableMap < Optional < EnumWorldBlockLayer > , ModelResourceLocation > models ; 
 + private final ImmutableMap < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > models ; 
 private final VertexFormat format ; 
 private final ImmutableMap < TransformType , TRSRTransformation > cameraTransforms ; ; 
 - private IBakedModel missing ; 
 - private IBakedModel base ; 
 - private ImmutableMap < EnumWorldBlockLayer , IBakedModel > bakedModels ; 
 - private ImmutableMap < Optional < EnumFacing > , ImmutableList < BakedQuad > > quads ; 
 + private final IFlexibleBakedModel base ; 
 + private final IFlexibleBakedModel missing ; 
 + private final ImmutableMap < Optional < EnumFacing > , ImmutableList < BakedQuad > > quads ; 
 
 + private static final Function < ResourceLocation , TextureAtlasSprite > defaultTextureGetter = new Function < ResourceLocation , TextureAtlasSprite > ( ) 
 + { 
 + public TextureAtlasSprite apply ( ResourceLocation location ) 
 + { 
 + return Minecraft . getMinecraft ( ) . getTextureMapBlocks ( ) . getAtlasSprite ( location . toString ( ) ) ; 
 + } 
 + } ; 
 + 
 + @ Deprecated / / remove 1 . 9 
 public MultiLayerBakedModel ( ImmutableMap < Optional < EnumWorldBlockLayer > , ModelResourceLocation > models , VertexFormat format , ImmutableMap < TransformType , TRSRTransformation > cameraTransforms ) 
 { 
 - this . models = models ; 
 - this . format = format ; 
 - this . cameraTransforms = cameraTransforms ; 
 + this ( 
 + buildModels ( models , TRSRTransformation . identity ( ) , format , defaultTextureGetter ) , 
 + ModelLoaderRegistry . getMissingModel ( ) . bake ( ModelLoaderRegistry . getMissingModel ( ) . getDefaultState ( ) , format , defaultTextureGetter ) , 
 + format , 
 + cameraTransforms 
 + ) ; 
 } 
 
 - private void compute ( ) 
 + public MultiLayerBakedModel ( ImmutableMap < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > models , IFlexibleBakedModel missing , VertexFormat format , ImmutableMap < TransformType , TRSRTransformation > cameraTransforms ) 
 { 
 - if ( base = = null ) 
 + this . models = models ; 
 + this . format = format ; 
 + this . cameraTransforms = cameraTransforms ; 
 + this . missing = missing ; 
 + if ( models . containsKey ( Optional . absent ( ) ) ) 
 { 
 - ModelManager manager = Minecraft . getMinecraft ( ) . getBlockRendererDispatcher ( ) . getBlockModelShapes ( ) . getModelManager ( ) ; 
 - missing = manager . getMissingModel ( ) ; 
 - base = getModel ( manager , Optional . < EnumWorldBlockLayer > absent ( ) ) ; 
 - 
 - ImmutableMap . Builder < EnumWorldBlockLayer , IBakedModel > builder = ImmutableMap . builder ( ) ; 
 - for ( EnumWorldBlockLayer layer : EnumWorldBlockLayer . values ( ) ) 
 - { 
 - if ( models . containsKey ( Optional . of ( layer ) ) ) 
 - { 
 - builder . put ( layer , getModel ( manager , Optional . of ( layer ) ) ) ; 
 - } 
 - } 
 - bakedModels = builder . build ( ) ; 
 - 
 - ImmutableMap . Builder < Optional < EnumFacing > , ImmutableList < BakedQuad > > quadBuilder = ImmutableMap . builder ( ) ; 
 - quadBuilder . put ( Optional . < EnumFacing > absent ( ) , buildQuads ( Optional . < EnumFacing > absent ( ) ) ) ; 
 - for ( EnumFacing side : EnumFacing . values ( ) ) 
 - { 
 - quadBuilder . put ( Optional . of ( side ) , buildQuads ( Optional . of ( side ) ) ) ; 
 - } 
 - quads = quadBuilder . build ( ) ; 
 + base = models . get ( Optional . absent ( ) ) ; 
 } 
 - } 
 - 
 - private IBakedModel getModel ( ModelManager manager , Optional < EnumWorldBlockLayer > layer ) 
 - { 
 - ModelResourceLocation loc = models . get ( layer ) ; 
 - if ( loc = = null ) 
 + else 
 + { 
 + base = missing ; 
 + } 
 + ImmutableMap . Builder < Optional < EnumFacing > , ImmutableList < BakedQuad > > quadBuilder = ImmutableMap . builder ( ) ; 
 + quadBuilder . put ( Optional . < EnumFacing > absent ( ) , buildQuads ( models , Optional . < EnumFacing > absent ( ) ) ) ; 
 + for ( EnumFacing side : EnumFacing . values ( ) ) 
 { 
 - loc = new ModelResourceLocation ( " builtin / missing " , " missing " ) ; 
 + quadBuilder . put ( Optional . of ( side ) , buildQuads ( models , Optional . of ( side ) ) ) ; 
 } 
 - return manager . getModel ( loc ) ; 
 + quads = quadBuilder . build ( ) ; 
 } 
 
 - private ImmutableList < BakedQuad > buildQuads ( Optional < EnumFacing > side ) 
 + private static ImmutableList < BakedQuad > buildQuads ( ImmutableMap < Optional < EnumWorldBlockLayer > , IFlexibleBakedModel > models , Optional < EnumFacing > side ) 
 { 
 ImmutableList . Builder < BakedQuad > builder = ImmutableList . builder ( ) ; 
 - for ( IBakedModel model : bakedModels . values ( ) ) 
 + for ( IBakedModel model : models . values ( ) ) 
 { 
 if ( side . isPresent ( ) ) 
 { 
 @ @ - 175 , 42 + 198 , 36 @ @ public class MultiLayerModel implements IModelCustomData 
 @ Override 
 public List < BakedQuad > getFaceQuads ( EnumFacing side ) 
 { 
 - compute ( ) ; 
 return quads . get ( Optional . of ( side ) ) ; 
 } 
 
 @ Override 
 public List < BakedQuad > getGeneralQuads ( ) 
 { 
 - compute ( ) ; 
 return quads . get ( Optional . absent ( ) ) ; 
 } 
 
 @ Override 
 public boolean isAmbientOcclusion ( ) 
 { 
 - compute ( ) ; 
 return base . isAmbientOcclusion ( ) ; 
 } 
 
 @ Override 
 public boolean isGui3d ( ) 
 { 
 - compute ( ) ; 
 return base . isGui3d ( ) ; 
 } 
 
 @ Override 
 public boolean isBuiltInRenderer ( ) 
 { 
 - compute ( ) ; 
 return base . isBuiltInRenderer ( ) ; 
 } 
 
 @ Override 
 public TextureAtlasSprite getParticleTexture ( ) 
 { 
 - compute ( ) ; 
 return base . getParticleTexture ( ) ; 
 } 
 
 @ @ - 223 , 13 + 240 , 12 @ @ public class MultiLayerModel implements IModelCustomData 
 @ Override 
 public IBakedModel handleBlockState ( IBlockState state ) 
 { 
 - compute ( ) ; 
 - EnumWorldBlockLayer layer = MinecraftForgeClient . getRenderLayer ( ) ; 
 - if ( ! bakedModels . containsKey ( layer ) ) 
 + Optional < EnumWorldBlockLayer > layer = Optional . of ( MinecraftForgeClient . getRenderLayer ( ) ) ; 
 + if ( ! models . containsKey ( layer ) ) 
 { 
 return missing ; 
 } 
 - return bakedModels . get ( layer ) ; 
 + return models . get ( layer ) ; 
 } 
 
 @ Override 
 diff - - git a / src / test / resources / assets / forgedebugmultilayermodel / blockstates / test _ layer _ block . json b / src / test / resources / assets / forgedebugmultilayermodel / blockstates / test _ layer _ block . json 
 index 50a1efe . . 15a23f0 100644 
 - - - a / src / test / resources / assets / forgedebugmultilayermodel / blockstates / test _ layer _ block . json 
 + + + b / src / test / resources / assets / forgedebugmultilayermodel / blockstates / test _ layer _ block . json 
 @ @ - 4 , 15 + 4 , 20 @ @ 
 " model " : " forge : multi - layer " , 
 " custom " : { 
 / / base is used for model properties - camera transforms , isGui3d , e . t . c . 
 - " base " : " minecraft : stone _ slab # half = bottom " , 
 + " base " : " forgedebugmultilayermodel : test _ layer _ block # aux " , 
 / / per - layer models 
 - " Solid " : " minecraft : stone _ slab # half = bottom " , 
 + " Solid " : " forgedebugmultilayermodel : test _ layer _ block # aux " , 
 " Translucent " : " minecraft : pink _ stained _ glass _ pane # east = true , north = false , south = false , west = true " 
 } , 
 " transform " : " forge : default - block " 
 } , 
 " variants " : { 
 " normal " : [ { } ] , 
 - " inventory " : [ { } ] 
 + " inventory " : [ { } ] , 
 + " aux " : [ { 
 + " model " : " cube _ all " , 
 + " textures " : { " all " : " blocks / slime " } , 
 + " transform " : { " scale " : . 5 } 
 + } ] 
 } 
 }
