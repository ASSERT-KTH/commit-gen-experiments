BLEU SCORE: 0.03772691894380681

TEST MSG: EntityPlayer patch updated .
GENERATED MSG: Makes player - specific spawnpoints dimension aware

TEST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch b / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch <nl> new file mode 100644 <nl> index 0000000 . . 092bc3a <nl> - - - / dev / null <nl> + + + b / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch <nl> @ @ - 0 , 0 + 1 , 619 @ @ <nl> + - - - . . / src - base / minecraft / net / minecraft / entity / player / EntityPlayer . java <nl> + + + + . . / src - work / minecraft / net / minecraft / entity / player / EntityPlayer . java <nl> + @ @ - 80 , 6 + 80 , 11 @ @ <nl> + @ SuppressWarnings ( " incomplete - switch " ) <nl> + public abstract class EntityPlayer extends EntityLivingBase <nl> + { <nl> + + public static final String PERSISTED _ NBT _ TAG = " PlayerPersisted " ; <nl> + + private java . util . HashMap < Integer , BlockPos > spawnChunkMap = new java . util . HashMap < Integer , BlockPos > ( ) ; <nl> + + private java . util . HashMap < Integer , Boolean > spawnForcedMap = new java . util . HashMap < Integer , Boolean > ( ) ; <nl> + + public float eyeHeight = this . getDefaultEyeHeight ( ) ; <nl> + + <nl> + public InventoryPlayer inventory = new InventoryPlayer ( this ) ; <nl> + private InventoryEnderChest theInventoryEnderChest = new InventoryEnderChest ( ) ; <nl> + public Container inventoryContainer ; <nl> + @ @ - 176 , 7 + 181 , 8 @ @ <nl> + { <nl> + if ( this . itemInUse ! = null ) <nl> + { <nl> + - this . itemInUse . onPlayerStoppedUsing ( this . worldObj , this , this . itemInUseCount ) ; <nl> + + if ( ! net . minecraftforge . event . ForgeEventFactory . onUseItemStop ( this , itemInUse , this . itemInUseCount ) ) <nl> + + this . itemInUse . onPlayerStoppedUsing ( this . worldObj , this , this . itemInUseCount ) ; <nl> + } <nl> + <nl> + this . clearItemInUse ( ) ; <nl> + @ @ - 200 , 6 + 206 , 7 @ @ <nl> + <nl> + public void onUpdate ( ) <nl> + { <nl> + + net . minecraftforge . fml . common . FMLCommonHandler . instance ( ) . onPlayerPreTick ( this ) ; <nl> + this . noClip = this . isSpectator ( ) ; <nl> + <nl> + if ( this . isSpectator ( ) ) <nl> + @ @ - 213 , 6 + 220 , 14 @ @ <nl> + <nl> + if ( itemstack = = this . itemInUse ) <nl> + { <nl> + + itemInUseCount = net . minecraftforge . event . ForgeEventFactory . onItemUseTick ( this , itemInUse , itemInUseCount ) ; <nl> + + if ( itemInUseCount < = 0 ) <nl> + + { <nl> + + this . onItemUseFinish ( ) ; <nl> + + } <nl> + + else <nl> + + { / / Forge Keep unindented to lower patch <nl> + + itemInUse . getItem ( ) . onUsingTick ( itemInUse , this , itemInUseCount ) ; / / Forge Added <nl> + if ( this . itemInUseCount < = 25 & & this . itemInUseCount % 4 = = 0 ) <nl> + { <nl> + this . updateItemUse ( itemstack , 5 ) ; <nl> + @ @ - 222 , 6 + 237 , 7 @ @ <nl> + { <nl> + this . onItemUseFinish ( ) ; <nl> + } <nl> + + } <nl> + } <nl> + else <nl> + { <nl> + @ @ - 267 , 7 + 283 , 7 @ @ <nl> + <nl> + super . onUpdate ( ) ; <nl> + <nl> + - if ( ! this . worldObj . isRemote & & this . openContainer ! = null & & ! this . openContainer . canInteractWith ( this ) ) <nl> + + if ( ! this . worldObj . isRemote & & this . openContainer ! = null & & ! net . minecraftforge . common . ForgeHooks . canInteractWith ( this , this . openContainer ) ) <nl> + { <nl> + this . closeScreen ( ) ; <nl> + this . openContainer = this . inventoryContainer ; <nl> + @ @ - 344 , 6 + 360 , 7 @ @ <nl> + { <nl> + this . setPosition ( d3 , this . posY , d4 ) ; <nl> + } <nl> + + net . minecraftforge . fml . common . FMLCommonHandler . instance ( ) . onPlayerPostTick ( this ) ; <nl> + } <nl> + <nl> + public int getMaxInPortalTime ( ) <nl> + @ @ - 413 , 11 + 430 , 12 @ @ <nl> + int i = this . itemInUse . stackSize ; <nl> + ItemStack itemstack = this . itemInUse . onItemUseFinish ( this . worldObj , this ) ; <nl> + <nl> + + itemstack = net . minecraftforge . event . ForgeEventFactory . onItemUseFinish ( this , itemInUse , itemInUseCount , itemstack ) ; <nl> + if ( itemstack ! = this . itemInUse | | itemstack ! = null & & itemstack . stackSize ! = i ) <nl> + { <nl> + this . inventory . mainInventory [ this . inventory . currentItem ] = itemstack ; <nl> + <nl> + - if ( itemstack . stackSize = = 0 ) <nl> + + if ( itemstack ! = null & & itemstack . stackSize = = 0 ) <nl> + { <nl> + this . inventory . mainInventory [ this . inventory . currentItem ] = null ; <nl> + } <nl> + @ @ - 477 , 11 + 495 , 11 @ @ <nl> + this . cameraYaw = 0 . 0F ; <nl> + this . addMountedMovementStat ( this . posX - d0 , this . posY - d1 , this . posZ - d2 ) ; <nl> + <nl> + - if ( this . ridingEntity instanceof EntityPig ) <nl> + + if ( this . ridingEntity instanceof EntityLivingBase & & ( ( EntityLivingBase ) ridingEntity ) . shouldRiderFaceForward ( this ) ) <nl> + { <nl> + this . rotationPitch = f1 ; <nl> + this . rotationYaw = f ; <nl> + - this . renderYawOffset = ( ( EntityPig ) this . ridingEntity ) . renderYawOffset ; <nl> + + this . renderYawOffset = ( ( EntityLivingBase ) this . ridingEntity ) . renderYawOffset ; <nl> + } <nl> + } <nl> + } <nl> + @ @ - 611 , 11 + 629 , 15 @ @ <nl> + <nl> + public void onDeath ( DamageSource cause ) <nl> + { <nl> + + if ( net . minecraftforge . common . ForgeHooks . onLivingDeath ( this , cause ) ) return ; <nl> + super . onDeath ( cause ) ; <nl> + this . setSize ( 0 . 2F , 0 . 2F ) ; <nl> + this . setPosition ( this . posX , this . posY , this . posZ ) ; <nl> + this . motionY = 0 . 10000000149011612D ; <nl> + <nl> + + captureDrops = true ; <nl> + + capturedDrops . clear ( ) ; <nl> + + <nl> + if ( this . getName ( ) . equals ( " Notch " ) ) <nl> + { <nl> + this . dropItem ( new ItemStack ( Items . apple , 1 ) , true , false ) ; <nl> + @ @ - 626 , 6 + 648 , 9 @ @ <nl> + this . inventory . dropAllItems ( ) ; <nl> + } <nl> + <nl> + + captureDrops = false ; <nl> + + if ( ! worldObj . isRemote ) net . minecraftforge . event . ForgeEventFactory . onPlayerDrops ( this , cause , capturedDrops , recentlyHit > 0 ) ; <nl> + + <nl> + if ( cause ! = null ) <nl> + { <nl> + this . motionX = ( double ) ( - MathHelper . cos ( ( this . attackedAtYaw + this . rotationYaw ) * ( float ) Math . PI / 180 . 0F ) * 0 . 1F ) ; <nl> + @ @ - 708 , 12 + 733 , 25 @ @ <nl> + <nl> + public EntityItem dropOneItem ( boolean p _ 71040 _ 1 _ ) <nl> + { <nl> + - return this . dropItem ( this . inventory . decrStackSize ( this . inventory . currentItem , p _ 71040 _ 1 _ & & this . inventory . getCurrentItem ( ) ! = null ? this . inventory . getCurrentItem ( ) . stackSize : 1 ) , false , true ) ; <nl> + + ItemStack stack = inventory . getCurrentItem ( ) ; <nl> + + <nl> + + if ( stack = = null ) <nl> + + { <nl> + + return null ; <nl> + + } <nl> + + <nl> + + if ( stack . getItem ( ) . onDroppedByPlayer ( stack , this ) ) <nl> + + { <nl> + + int count = p _ 71040 _ 1 _ & & this . inventory . getCurrentItem ( ) ! = null ? this . inventory . getCurrentItem ( ) . stackSize : 1 ; <nl> + + return net . minecraftforge . common . ForgeHooks . onPlayerTossEvent ( this , inventory . decrStackSize ( inventory . currentItem , count ) , true ) ; <nl> + + } <nl> + + <nl> + + return null ; <nl> + } <nl> + <nl> + public EntityItem dropPlayerItemWithRandomChoice ( ItemStack itemStackIn , boolean unused ) <nl> + { <nl> + - return this . dropItem ( itemStackIn , false , false ) ; <nl> + + return net . minecraftforge . common . ForgeHooks . onPlayerTossEvent ( this , itemStackIn , false ) ; <nl> + } <nl> + <nl> + public EntityItem dropItem ( ItemStack droppedItem , boolean dropAround , boolean traceItem ) <nl> + @ @ - 771 , 13 + 809 , 25 @ @ <nl> + <nl> + public void joinEntityItemWithWorld ( EntityItem p _ 71012 _ 1 _ ) <nl> + { <nl> + + if ( captureDrops ) <nl> + + { <nl> + + capturedDrops . add ( p _ 71012 _ 1 _ ) ; <nl> + + return ; <nl> + + } <nl> + + <nl> + this . worldObj . spawnEntityInWorld ( p _ 71012 _ 1 _ ) ; <nl> + } <nl> + <nl> + + @ Deprecated / / Use location sensitive version below <nl> + public float getToolDigEfficiency ( Block p _ 180471 _ 1 _ ) <nl> + { <nl> + - float f = this . inventory . getStrVsBlock ( p _ 180471 _ 1 _ ) ; <nl> + + return getBreakSpeed ( p _ 180471 _ 1 _ . getDefaultState ( ) , new BlockPos ( 0 , - 1 , 0 ) ) ; <nl> + + } <nl> + <nl> + + public float getBreakSpeed ( IBlockState state , BlockPos pos ) <nl> + + { <nl> + + ItemStack stack = inventory . getCurrentItem ( ) ; <nl> + + float f = ( stack = = null ? 1 . 0F : stack . getItem ( ) . getDigSpeed ( stack , state ) ) ; <nl> + if ( f > 1 . 0F ) <nl> + { <nl> + int i = EnchantmentHelper . getEfficiencyModifier ( this ) ; <nl> + @ @ - 827 , 12 + 877 , 13 @ @ <nl> + f / = 5 . 0F ; <nl> + } <nl> + <nl> + - return f ; <nl> + + f = net . minecraftforge . event . ForgeEventFactory . getBreakSpeed ( this , state , f , pos ) ; <nl> + + return ( f < 0 ? 0 : f ) ; <nl> + } <nl> + <nl> + public boolean canHarvestBlock ( Block p _ 146099 _ 1 _ ) <nl> + { <nl> + - return this . inventory . func _ 146025 _ b ( p _ 146099 _ 1 _ ) ; <nl> + + return net . minecraftforge . event . ForgeEventFactory . doPlayerHarvestCheck ( this , p _ 146099 _ 1 _ , this . inventory . func _ 146025 _ b ( p _ 146099 _ 1 _ ) ) ; <nl> + } <nl> + <nl> + public void readEntityFromNBT ( NBTTagCompound tagCompund ) <nl> + @ @ - 868 , 6 + 919 , 16 @ @ <nl> + this . spawnForced = tagCompund . getBoolean ( " SpawnForced " ) ; <nl> + } <nl> + <nl> + + NBTTagList spawnlist = null ; <nl> + + spawnlist = tagCompund . getTagList ( " Spawns " , 10 ) ; <nl> + + for ( int i = 0 ; i < spawnlist . tagCount ( ) ; i + + ) <nl> + + { <nl> + + NBTTagCompound spawndata = ( NBTTagCompound ) spawnlist . getCompoundTagAt ( i ) ; <nl> + + int spawndim = spawndata . getInteger ( " Dim " ) ; <nl> + + this . spawnChunkMap . put ( spawndim , new BlockPos ( spawndata . getInteger ( " SpawnX " ) , spawndata . getInteger ( " SpawnY " ) , spawndata . getInteger ( " SpawnZ " ) ) ) ; <nl> + + this . spawnForcedMap . put ( spawndim , spawndata . getBoolean ( " SpawnForced " ) ) ; <nl> + + } <nl> + + <nl> + this . foodStats . readNBT ( tagCompund ) ; <nl> + this . capabilities . readCapabilitiesFromNBT ( tagCompund ) ; <nl> + <nl> + @ @ - 899 , 6 + 960 , 23 @ @ <nl> + tagCompound . setBoolean ( " SpawnForced " , this . spawnForced ) ; <nl> + } <nl> + <nl> + + NBTTagList spawnlist = new NBTTagList ( ) ; <nl> + + for ( java . util . Map . Entry < Integer , BlockPos > entry : this . spawnChunkMap . entrySet ( ) ) <nl> + + { <nl> + + BlockPos spawn = entry . getValue ( ) ; <nl> + + if ( spawn = = null ) continue ; <nl> + + Boolean forced = spawnForcedMap . get ( entry . getKey ( ) ) ; <nl> + + if ( forced = = null ) forced = false ; <nl> + + NBTTagCompound spawndata = new NBTTagCompound ( ) ; <nl> + + spawndata . setInteger ( " Dim " , entry . getKey ( ) ) ; <nl> + + spawndata . setInteger ( " SpawnX " , spawn . getX ( ) ) ; <nl> + + spawndata . setInteger ( " SpawnY " , spawn . getY ( ) ) ; <nl> + + spawndata . setInteger ( " SpawnZ " , spawn . getZ ( ) ) ; <nl> + + spawndata . setBoolean ( " SpawnForced " , forced ) ; <nl> + + spawnlist . appendTag ( spawndata ) ; <nl> + + } <nl> + + tagCompound . setTag ( " Spawns " , spawnlist ) ; <nl> + + <nl> + this . foodStats . writeNBT ( tagCompound ) ; <nl> + this . capabilities . writeCapabilitiesToNBT ( tagCompound ) ; <nl> + tagCompound . setTag ( " EnderItems " , this . theInventoryEnderChest . saveInventoryToNBT ( ) ) ; <nl> + @ @ - 912 , 6 + 990 , 7 @ @ <nl> + <nl> + public boolean attackEntityFrom ( DamageSource source , float amount ) <nl> + { <nl> + + if ( ! net . minecraftforge . common . ForgeHooks . onLivingAttack ( this , source , amount ) ) return false ; <nl> + if ( this . isEntityInvulnerable ( source ) ) <nl> + { <nl> + return false ; <nl> + @ @ - 1008 , 12 + 1087 , 15 @ @ <nl> + { <nl> + if ( ! this . isEntityInvulnerable ( damageSrc ) ) <nl> + { <nl> + + damageAmount = net . minecraftforge . common . ForgeHooks . onLivingHurt ( this , damageSrc , damageAmount ) ; <nl> + + if ( damageAmount < = 0 ) return ; <nl> + if ( ! damageSrc . isUnblockable ( ) & & this . isBlocking ( ) & & damageAmount > 0 . 0F ) <nl> + { <nl> + damageAmount = ( 1 . 0F + damageAmount ) * 0 . 5F ; <nl> + } <nl> + <nl> + - damageAmount = this . applyArmorCalculations ( damageSrc , damageAmount ) ; <nl> + + damageAmount = net . minecraftforge . common . ISpecialArmor . ArmorProperties . applyArmor ( this , inventory . armorInventory , damageSrc , damageAmount ) ; <nl> + + if ( damageAmount < = 0 ) return ; <nl> + damageAmount = this . applyPotionDamageCalculations ( damageSrc , damageAmount ) ; <nl> + float f = damageAmount ; <nl> + damageAmount = Math . max ( damageAmount - this . getAbsorptionAmount ( ) , 0 . 0F ) ; <nl> + @ @ - 1075 , 6 + 1157 , 7 @ @ <nl> + } <nl> + else <nl> + { <nl> + + if ( ! net . minecraftforge . event . ForgeEventFactory . canInteractWith ( this , p _ 70998 _ 1 _ ) ) return false ; <nl> + ItemStack itemstack = this . getCurrentEquippedItem ( ) ; <nl> + ItemStack itemstack1 = itemstack ! = null ? itemstack . copy ( ) : null ; <nl> + <nl> + @ @ - 1126 , 7 + 1209 , 9 @ @ <nl> + <nl> + public void destroyCurrentEquippedItem ( ) <nl> + { <nl> + + ItemStack orig = getCurrentEquippedItem ( ) ; <nl> + this . inventory . setInventorySlotContents ( this . inventory . currentItem , ( ItemStack ) null ) ; <nl> + + net . minecraftforge . event . ForgeEventFactory . onPlayerDestroyItem ( this , orig ) ; <nl> + } <nl> + <nl> + public double getYOffset ( ) <nl> + @ @ - 1136 , 6 + 1221 , 7 @ @ <nl> + <nl> + public void attackTargetEntityWithCurrentItem ( Entity targetEntity ) <nl> + { <nl> + + if ( ! net . minecraftforge . common . ForgeHooks . onPlayerAttackTarget ( this , targetEntity ) ) return ; <nl> + if ( targetEntity . canAttackWithItem ( ) ) <nl> + { <nl> + if ( ! targetEntity . hitByEntity ( this ) ) <nl> + @ @ - 1312 , 6 + 1398 , 8 @ @ <nl> + <nl> + public EntityPlayer . EnumStatus trySleep ( BlockPos bedLocation ) <nl> + { <nl> + + EntityPlayer . EnumStatus ret = net . minecraftforge . event . ForgeEventFactory . onPlayerSleepInBed ( this , bedLocation ) ; <nl> + + if ( ret ! = null ) return ret ; <nl> + if ( ! this . worldObj . isRemote ) <nl> + { <nl> + if ( this . isPlayerSleeping ( ) | | ! this . isEntityAlive ( ) ) <nl> + @ @ - 1353 , 7 + 1441 , 7 @ @ <nl> + <nl> + if ( this . worldObj . isBlockLoaded ( bedLocation ) ) <nl> + { <nl> + - EnumFacing enumfacing = ( EnumFacing ) this . worldObj . getBlockState ( bedLocation ) . getValue ( BlockDirectional . FACING ) ; <nl> + + EnumFacing enumfacing = this . worldObj . getBlockState ( bedLocation ) . getBlock ( ) . getBedDirection ( worldObj , bedLocation ) ; <nl> + float f = 0 . 5F ; <nl> + float f1 = 0 . 5F ; <nl> + <nl> + @ @ - 1416 , 13 + 1504 , 14 @ @ <nl> + <nl> + public void wakeUpPlayer ( boolean p _ 70999 _ 1 _ , boolean updateWorldFlag , boolean setSpawn ) <nl> + { <nl> + + net . minecraftforge . event . ForgeEventFactory . onPlayerWakeup ( this , p _ 70999 _ 1 _ , updateWorldFlag , setSpawn ) ; <nl> + this . setSize ( 0 . 6F , 1 . 8F ) ; <nl> + IBlockState iblockstate = this . worldObj . getBlockState ( this . playerLocation ) ; <nl> + <nl> + - if ( this . playerLocation ! = null & & iblockstate . getBlock ( ) = = Blocks . bed ) <nl> + + if ( this . playerLocation ! = null & & iblockstate . getBlock ( ) . isBed ( worldObj , playerLocation , this ) ) <nl> + { <nl> + - this . worldObj . setBlockState ( this . playerLocation , iblockstate . withProperty ( BlockBed . OCCUPIED , Boolean . valueOf ( false ) ) , 4 ) ; <nl> + - BlockPos blockpos = BlockBed . getSafeExitLocation ( this . worldObj , this . playerLocation , 0 ) ; <nl> + + iblockstate . getBlock ( ) . setBedOccupied ( worldObj , playerLocation , this , false ) ; <nl> + + BlockPos blockpos = iblockstate . getBlock ( ) . getBedSpawnPosition ( worldObj , playerLocation , this ) ; <nl> + <nl> + if ( blockpos = = null ) <nl> + { <nl> + @ @ - 1449 , 14 + 1538 , 14 @ @ <nl> + <nl> + private boolean isInBed ( ) <nl> + { <nl> + - return this . worldObj . getBlockState ( this . playerLocation ) . getBlock ( ) = = Blocks . bed ; <nl> + + return this . worldObj . getBlockState ( this . playerLocation ) . getBlock ( ) . isBed ( worldObj , playerLocation , this ) ; <nl> + } <nl> + <nl> + public static BlockPos getBedSpawnLocation ( World worldIn , BlockPos bedLocation , boolean forceSpawn ) <nl> + { <nl> + Block block = worldIn . getBlockState ( bedLocation ) . getBlock ( ) ; <nl> + <nl> + - if ( block ! = Blocks . bed ) <nl> + + if ( ! block . isBed ( worldIn , bedLocation , null ) ) <nl> + { <nl> + if ( ! forceSpawn ) <nl> + { <nl> + @ @ - 1471 , 7 + 1560 , 7 @ @ <nl> + } <nl> + else <nl> + { <nl> + - return BlockBed . getSafeExitLocation ( worldIn , bedLocation , 0 ) ; <nl> + + return worldIn . getBlockState ( bedLocation ) . getBlock ( ) . getBedSpawnPosition ( worldIn , bedLocation , null ) ; <nl> + } <nl> + } <nl> + <nl> + @ @ - 1480 , 7 + 1569 , 7 @ @ <nl> + { <nl> + if ( this . playerLocation ! = null ) <nl> + { <nl> + - EnumFacing enumfacing = ( EnumFacing ) this . worldObj . getBlockState ( this . playerLocation ) . getValue ( BlockDirectional . FACING ) ; <nl> + + EnumFacing enumfacing = this . worldObj . getBlockState ( this . playerLocation ) . getBlock ( ) . getBedDirection ( worldObj , playerLocation ) ; <nl> + <nl> + switch ( enumfacing ) <nl> + { <nl> + @ @ - 1520 , 16 + 1609 , 24 @ @ <nl> + <nl> + public BlockPos getBedLocation ( ) <nl> + { <nl> + - return this . spawnChunk ; <nl> + + return getBedLocation ( this . dimension ) ; <nl> + } <nl> + <nl> + + @ Deprecated / / Use dimension - sensitive version . <nl> + public boolean isSpawnForced ( ) <nl> + { <nl> + - return this . spawnForced ; <nl> + + return isSpawnForced ( this . dimension ) ; <nl> + } <nl> + <nl> + public void setSpawnPoint ( BlockPos pos , boolean forced ) <nl> + { <nl> + + if ( net . minecraftforge . event . ForgeEventFactory . onPlayerSpawnSet ( this , pos , forced ) ) return ; <nl> + + if ( this . dimension ! = 0 ) <nl> + + { <nl> + + setSpawnChunk ( pos , forced , this . dimension ) ; <nl> + + return ; <nl> + + } <nl> + + <nl> + if ( pos ! = null ) <nl> + { <nl> + this . spawnChunk = pos ; <nl> + @ @ - 1713 , 6 + 1810 , 10 @ @ <nl> + <nl> + super . fall ( distance , damageMultiplier ) ; <nl> + } <nl> + + else <nl> + + { <nl> + + net . minecraftforge . event . ForgeEventFactory . onPlayerFall ( this , distance , damageMultiplier ) ; <nl> + + } <nl> + } <nl> + <nl> + protected void resetHeight ( ) <nl> + @ @ - 1736 , 6 + 1837 , 7 @ @ <nl> + } <nl> + <nl> + EntityList . EntityEggInfo entitylist $ entityegginfo = ( EntityList . EntityEggInfo ) EntityList . entityEggs . get ( Integer . valueOf ( EntityList . getEntityID ( entityLivingIn ) ) ) ; <nl> + + if ( entitylist $ entityegginfo = = null ) entitylist $ entityegginfo = net . minecraftforge . fml . common . registry . EntityRegistry . getEggs ( ) . get ( EntityList . getEntityString ( entityLivingIn ) ) ; <nl> + <nl> + if ( entitylist $ entityegginfo ! = null ) <nl> + { <nl> + @ @ - 1848 , 6 + 1950 , 8 @ @ <nl> + { <nl> + if ( stack ! = this . itemInUse ) <nl> + { <nl> + + duration = net . minecraftforge . event . ForgeEventFactory . onItemUseStart ( this , stack , duration ) ; <nl> + + if ( duration < = 0 ) return ; <nl> + this . itemInUse = stack ; <nl> + this . itemInUseCount = duration ; <nl> + <nl> + @ @ - 1919 , 6 + 2023 , 10 @ @ <nl> + this . field _ 181016 _ an = oldPlayer . field _ 181016 _ an ; <nl> + this . field _ 181017 _ ao = oldPlayer . field _ 181017 _ ao ; <nl> + this . field _ 181018 _ ap = oldPlayer . field _ 181018 _ ap ; <nl> + + / / Copy and re - init ExtendedProperties when switching dimensions . <nl> + + this . extendedProperties = oldPlayer . extendedProperties ; <nl> + + for ( net . minecraftforge . common . IExtendedEntityProperties p : this . extendedProperties . values ( ) ) <nl> + + p . init ( this , this . worldObj ) ; <nl> + } <nl> + else if ( this . worldObj . getGameRules ( ) . getGameRuleBooleanValue ( " keepInventory " ) ) <nl> + { <nl> + @ @ - 1932 , 6 + 2040 , 18 @ @ <nl> + this . xpSeed = oldPlayer . xpSeed ; <nl> + this . theInventoryEnderChest = oldPlayer . theInventoryEnderChest ; <nl> + this . getDataWatcher ( ) . updateObject ( 10 , Byte . valueOf ( oldPlayer . getDataWatcher ( ) . getWatchableObjectByte ( 10 ) ) ) ; <nl> + + <nl> + + this . spawnChunkMap = oldPlayer . spawnChunkMap ; <nl> + + this . spawnForcedMap = oldPlayer . spawnForcedMap ; <nl> + + <nl> + + / / Copy over a section of the Entity Data from the old player . <nl> + + / / Allows mods to specify data that persists after players respawn . <nl> + + NBTTagCompound old = oldPlayer . getEntityData ( ) ; <nl> + + if ( old . hasKey ( PERSISTED _ NBT _ TAG ) ) <nl> + + { <nl> + + getEntityData ( ) . setTag ( PERSISTED _ NBT _ TAG , old . getCompoundTag ( PERSISTED _ NBT _ TAG ) ) ; <nl> + + } <nl> + + net . minecraftforge . event . ForgeEventFactory . onPlayerClone ( this , oldPlayer , ! respawnFromEnd ) ; <nl> + } <nl> + <nl> + protected boolean canTriggerWalking ( ) <nl> + @ @ - 1969 , 7 + 2089 , 14 @ @ <nl> + <nl> + public void setCurrentItemOrArmor ( int slotIn , ItemStack stack ) <nl> + { <nl> + - this . inventory . armorInventory [ slotIn ] = stack ; <nl> + + if ( slotIn = = 0 ) / / Forge : Fix issue in Player where it doen ' t take into account selected item <nl> + + { <nl> + + this . inventory . mainInventory [ this . inventory . currentItem ] = stack ; <nl> + + } <nl> + + else <nl> + + { <nl> + + this . inventory . armorInventory [ slotIn - 1 ] = stack ; <nl> + + } <nl> + } <nl> + <nl> + @ SideOnly ( Side . CLIENT ) <nl> + @ @ - 2014 , 7 + 2141 , 10 @ @ <nl> + <nl> + public IChatComponent getDisplayName ( ) <nl> + { <nl> + - IChatComponent ichatcomponent = new ChatComponentText ( ScorePlayerTeam . formatPlayerName ( this . getTeam ( ) , this . getName ( ) ) ) ; <nl> + + IChatComponent ichatcomponent = new ChatComponentText ( " " ) ; <nl> + + if ( ! prefixes . isEmpty ( ) ) for ( net . minecraft . util . IChatComponent prefix : prefixes ) ichatcomponent . appendSibling ( prefix ) ; <nl> + + ichatcomponent . appendSibling ( new ChatComponentText ( ScorePlayerTeam . formatPlayerName ( this . getTeam ( ) , this . getDisplayNameString ( ) ) ) ) ; <nl> + + if ( ! suffixes . isEmpty ( ) ) for ( net . minecraft . util . IChatComponent suffix : suffixes ) ichatcomponent . appendSibling ( suffix ) ; <nl> + ichatcomponent . getChatStyle ( ) . setChatClickEvent ( new ClickEvent ( ClickEvent . Action . SUGGEST _ COMMAND , " / msg " + this . getName ( ) + " " ) ) ; <nl> + ichatcomponent . getChatStyle ( ) . setChatHoverEvent ( this . func _ 174823 _ aP ( ) ) ; <nl> + ichatcomponent . getChatStyle ( ) . setInsertion ( this . getName ( ) ) ; <nl> + @ @ - 2023 , 7 + 2153 , 7 @ @ <nl> + <nl> + public float getEyeHeight ( ) <nl> + { <nl> + - float f = 1 . 62F ; <nl> + + float f = eyeHeight ; <nl> + <nl> + if ( this . isPlayerSleeping ( ) ) <nl> + { <nl> + @ @ - 2156 , 6 + 2286 , 136 @ @ <nl> + this . hasReducedDebug = reducedDebug ; <nl> + } <nl> + <nl> + + / * * <nl> + + * Opens a GUI with this player , uses FML ' s IGuiHandler system . <nl> + + * Allows for extension by modders . <nl> + + * <nl> + + * @ param mod The mod trying to open a GUI <nl> + + * @ param modGuiId GUI ID <nl> + + * @ param world Current World <nl> + + * @ param x Passed directly to IGuiHandler , data meaningless Typically world X position <nl> + + * @ param y Passed directly to IGuiHandler , data meaningless Typically world Y position <nl> + + * @ param z Passed directly to IGuiHandler , data meaningless Typically world Z position <nl> + + * / <nl> + + public void openGui ( Object mod , int modGuiId , World world , int x , int y , int z ) <nl> + + { <nl> + + net . minecraftforge . fml . common . network . internal . FMLNetworkHandler . openGui ( this , mod , modGuiId , world , x , y , z ) ; <nl> + + } <nl> + + <nl> + + <nl> + + / * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = FORGE START = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = * / <nl> + + / * * <nl> + + * A dimension aware version of getBedLocation . <nl> + + * @ param dimension The dimension to get the bed spawn for <nl> + + * @ return The player specific spawn location for the dimension . May be null . <nl> + + * / <nl> + + public BlockPos getBedLocation ( int dimension ) <nl> + + { <nl> + + return dimension = = 0 ? spawnChunk : spawnChunkMap . get ( dimension ) ; <nl> + + } <nl> + + <nl> + + / * * <nl> + + * A dimension aware version of isSpawnForced . <nl> + + * Noramally isSpawnForced is used to determine if the respawn system should check for a bed or not . <nl> + + * This just extends that to be dimension aware . <nl> + + * @ param dimension The dimension to get whether to check for a bed before spawning for <nl> + + * @ return The player specific spawn location for the dimension . May be null . <nl> + + * / <nl> + + public boolean isSpawnForced ( int dimension ) <nl> + + { <nl> + + if ( dimension = = 0 ) return this . spawnForced ; <nl> + + Boolean forced = this . spawnForcedMap . get ( dimension ) ; <nl> + + return forced = = null ? false : forced ; <nl> + + } <nl> + + <nl> + + / * * <nl> + + * A dimension aware version of setSpawnChunk . <nl> + + * This functions identically , but allows you to specify which dimension to affect , rather than affecting the player ' s current dimension . <nl> + + * @ param pos The spawn point to set as the player - specific spawn point for the dimension <nl> + + * @ param forced Whether or not the respawn code should check for a bed at this location ( true means it won ' t check for a bed ) <nl> + + * @ param dimension Which dimension to apply the player - specific respawn point to <nl> + + * / <nl> + + public void setSpawnChunk ( BlockPos pos , boolean forced , int dimension ) <nl> + + { <nl> + + if ( dimension = = 0 ) <nl> + + { <nl> + + if ( pos ! = null ) <nl> + + { <nl> + + spawnChunk = pos ; <nl> + + spawnForced = forced ; <nl> + + } <nl> + + else <nl> + + { <nl> + + spawnChunk = null ; <nl> + + spawnForced = false ; <nl> + + } <nl> + + return ; <nl> + + } <nl> + + <nl> + + if ( pos ! = null ) <nl> + + { <nl> + + spawnChunkMap . put ( dimension , pos ) ; <nl> + + spawnForcedMap . put ( dimension , forced ) ; <nl> + + } <nl> + + else <nl> + + { <nl> + + spawnChunkMap . remove ( dimension ) ; <nl> + + spawnForcedMap . remove ( dimension ) ; <nl> + + } <nl> + + } <nl> + + <nl> + + private String displayname ; <nl> + + <nl> + + / * * <nl> + + * Returns the default eye height of the player <nl> + + * @ return player default eye height <nl> + + * / <nl> + + public float getDefaultEyeHeight ( ) <nl> + + { <nl> + + return 1 . 62F ; <nl> + + } <nl> + + <nl> + + / * * <nl> + + * Get the currently computed display name , cached for efficiency . <nl> + + * @ return the current display name <nl> + + * / <nl> + + public String getDisplayNameString ( ) <nl> + + { <nl> + + if ( this . displayname = = null ) <nl> + + { <nl> + + this . displayname = net . minecraftforge . event . ForgeEventFactory . getPlayerDisplayName ( this , this . getName ( ) ) ; <nl> + + } <nl> + + return this . displayname ; <nl> + + } <nl> + + <nl> + + / * * <nl> + + * Force the displayed name to refresh <nl> + + * / <nl> + + public void refreshDisplayName ( ) <nl> + + { <nl> + + this . displayname = net . minecraftforge . event . ForgeEventFactory . getPlayerDisplayName ( this , this . getName ( ) ) ; <nl> + + } <nl> + + <nl> + + private final java . util . Collection < net . minecraft . util . IChatComponent > prefixes = new java . util . LinkedList < net . minecraft . util . IChatComponent > ( ) ; <nl> + + private final java . util . Collection < net . minecraft . util . IChatComponent > suffixes = new java . util . LinkedList < net . minecraft . util . IChatComponent > ( ) ; <nl> + + <nl> + + / * * <nl> + + * Add a prefix to the player ' s username in chat <nl> + + * @ param prefix The prefix <nl> + + * / <nl> + + public void addPrefix ( net . minecraft . util . IChatComponent prefix ) { prefixes . add ( prefix ) ; } <nl> + + <nl> + + / * * <nl> + + * Add a suffix to the player ' s username in chat <nl> + + * @ param suffix The suffix <nl> + + * / <nl> + + public void addSuffix ( net . minecraft . util . IChatComponent suffix ) { suffixes . add ( suffix ) ; } <nl> + + <nl> + + public java . util . Collection < net . minecraft . util . IChatComponent > getPrefixes ( ) { return this . prefixes ; } <nl> + + public java . util . Collection < net . minecraft . util . IChatComponent > getSuffixes ( ) { return this . suffixes ; } <nl> + + <nl> + + / * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = FORGE END = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = * / <nl> + + <nl> + public static enum EnumChatVisibility <nl> + { <nl> + FULL ( 0 , " options . chat . visibility . full " ) ,
NEAREST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch b / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch <nl> index 582b791 . . 7e9ccb2 100644 <nl> - - - a / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch <nl> + + + b / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch <nl> @ @ - 1 , 6 + 1 , 18 @ @ <nl> - - - . . / src _ base / minecraft / net / minecraft / entity / player / EntityPlayer . java <nl> + + + . . / src _ work / minecraft / net / minecraft / entity / player / EntityPlayer . java <nl> - @ @ - 68 , 8 + 68 , 21 @ @ <nl> + @ @ - 5 , 8 + 5 , 11 @ @ <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import cpw . mods . fml . relauncher . SideOnly ; <nl> + import java . util . Collection ; <nl> + + import java . util . HashMap ; <nl> + import java . util . Iterator ; <nl> + import java . util . List ; <nl> + + import java . util . Map . Entry ; <nl> + + <nl> + import net . minecraft . block . Block ; <nl> + import net . minecraft . block . BlockBed ; <nl> + import net . minecraft . block . material . Material ; <nl> + @ @ - 68 , 8 + 71 , 21 @ @ <nl> import net . minecraft . world . World ; <nl> import net . minecraft . world . chunk . IChunkProvider ; <nl> <nl> @ @ - 22 , 7 + 34 , 21 @ @ <nl> / * * Inventory of the player * / <nl> public InventoryPlayer inventory = new InventoryPlayer ( this ) ; <nl> private InventoryEnderChest theInventoryEnderChest = new InventoryEnderChest ( ) ; <nl> - @ @ - 269 , 6 + 282 , 7 @ @ <nl> + @ @ - 122 , 11 + 138 , 13 @ @ <nl> + * Holds the last coordinate to spawn based on last bed that the player sleep . <nl> + * / <nl> + private ChunkCoordinates spawnChunk ; <nl> + + private HashMap < Integer , ChunkCoordinates > spawnChunkMap = new HashMap < Integer , ChunkCoordinates > ( ) ; <nl> + <nl> + / * * <nl> + * Whether this player ' s spawn point is forced , preventing execution of bed checks . <nl> + * / <nl> + private boolean spawnForced ; <nl> + + private HashMap < Integer , Boolean > spawnForcedMap = new HashMap < Integer , Boolean > ( ) ; <nl> + <nl> + / * * Holds the coordinate of the player when enter a minecraft to ride . * / <nl> + private ChunkCoordinates startMinecartRidingCoordinate ; <nl> + @ @ - 269 , 6 + 287 , 7 @ @ <nl> <nl> if ( itemstack = = this . itemInUse ) <nl> { <nl> @ @ - 30 , 7 + 56 , 7 @ @ <nl> if ( this . itemInUseCount < = 25 & & this . itemInUseCount % 4 = = 0 ) <nl> { <nl> this . updateItemUse ( itemstack , 5 ) ; <nl> - @ @ - 539 , 11 + 553 , 11 @ @ <nl> + @ @ - 539 , 11 + 558 , 11 @ @ <nl> this . cameraYaw = 0 . 0F ; <nl> this . addMountedMovementStat ( this . posX - d0 , this . posY - d1 , this . posZ - d2 ) ; <nl> <nl> @ @ - 44 , 7 + 70 , 7 @ @ <nl> } <nl> } <nl> } <nl> - @ @ - 686 , 11 + 700 , 15 @ @ <nl> + @ @ - 686 , 11 + 705 , 15 @ @ <nl> * / <nl> public void onDeath ( DamageSource par1DamageSource ) <nl> { <nl> @ @ - 60 , 7 + 86 , 7 @ @ <nl> if ( this . username . equals ( " Notch " ) ) <nl> { <nl> this . dropPlayerItemWithRandomChoice ( new ItemStack ( Item . appleRed , 1 ) , true ) ; <nl> - @ @ - 699 , 6 + 717 , 20 @ @ <nl> + @ @ - 699 , 6 + 722 , 20 @ @ <nl> if ( ! this . worldObj . getGameRules ( ) . getGameRuleBooleanValue ( " keepInventory " ) ) <nl> { <nl> this . inventory . dropAllItems ( ) ; <nl> @ @ - 81 , 7 + 107 , 7 @ @ <nl> } <nl> <nl> if ( par1DamageSource ! = null ) <nl> - @ @ - 749 , 7 + 781 , 20 @ @ <nl> + @ @ - 749 , 7 + 786 , 20 @ @ <nl> * / <nl> public EntityItem dropOneItem ( boolean par1 ) <nl> { <nl> @ @ - 103 , 7 + 129 , 7 @ @ <nl> } <nl> <nl> / * * <nl> - @ @ - 758 , 7 + 803 , 7 @ @ <nl> + @ @ - 758 , 7 + 808 , 7 @ @ <nl> * / <nl> public EntityItem dropPlayerItem ( ItemStack par1ItemStack ) <nl> { <nl> @ @ - 112 , 7 + 138 , 7 @ @ <nl> } <nl> <nl> / * * <nl> - @ @ - 814 , 15 + 859 , 28 @ @ <nl> + @ @ - 814 , 15 + 864 , 28 @ @ <nl> * / <nl> public void joinEntityItemWithWorld ( EntityItem par1EntityItem ) <nl> { <nl> @ @ - 143 , 7 + 169 , 7 @ @ <nl> <nl> if ( f > 1 . 0F ) <nl> { <nl> - @ @ - 833 , 7 + 891 , 9 @ @ <nl> + @ @ - 833 , 7 + 896 , 9 @ @ <nl> { <nl> float f1 = ( float ) ( i * i + 1 ) ; <nl> <nl> @ @ - 154 , 7 + 180 , 7 @ @ <nl> { <nl> f + = f1 * 0 . 08F ; <nl> } <nl> - @ @ - 864 , 7 + 924 , 8 @ @ <nl> + @ @ - 864 , 7 + 929 , 8 @ @ <nl> f / = 5 . 0F ; <nl> } <nl> <nl> @ @ - 164 , 7 + 190 , 7 @ @ <nl> } <nl> <nl> / * * <nl> - @ @ - 872 , 7 + 933 , 7 @ @ <nl> + @ @ - 872 , 7 + 938 , 7 @ @ <nl> * / <nl> public boolean canHarvestBlock ( Block par1Block ) <nl> { <nl> @ @ - 173 , 7 + 199 , 44 @ @ <nl> } <nl> <nl> / * * <nl> - @ @ - 982 , 6 + 1043 , 7 @ @ <nl> + @ @ - 902 , 6 + 968 , 14 @ @ <nl> + this . spawnChunk = new ChunkCoordinates ( par1NBTTagCompound . getInteger ( " SpawnX " ) , par1NBTTagCompound . getInteger ( " SpawnY " ) , par1NBTTagCompound . getInteger ( " SpawnZ " ) ) ; <nl> + this . spawnForced = par1NBTTagCompound . getBoolean ( " SpawnForced " ) ; <nl> + } <nl> + + NBTTagList spawnlist = null ; <nl> + + spawnlist = par1NBTTagCompound . getTagList ( " Spawns " ) ; <nl> + + for ( int i = 0 ; i < spawnlist . tagCount ( ) ; + + i ) { <nl> + + NBTTagCompound spawndata = ( NBTTagCompound ) spawnlist . tagAt ( i ) ; <nl> + + int spawndim = spawndata . getInteger ( " Dim " ) ; <nl> + + this . spawnChunkMap . put ( spawndim , new ChunkCoordinates ( spawndata . getInteger ( " SpawnX " ) , spawndata . getInteger ( " SpawnY " ) , spawndata . getInteger ( " SpawnZ " ) ) ) ; <nl> + + this . spawnForcedMap . put ( spawndim , spawndata . getBoolean ( " SpawnForced " ) ) ; <nl> + + } <nl> + <nl> + this . foodStats . readNBT ( par1NBTTagCompound ) ; <nl> + this . capabilities . readCapabilitiesFromNBT ( par1NBTTagCompound ) ; <nl> + @ @ - 935 , 6 + 1009 , 21 @ @ <nl> + par1NBTTagCompound . setInteger ( " SpawnZ " , this . spawnChunk . posZ ) ; <nl> + par1NBTTagCompound . setBoolean ( " SpawnForced " , this . spawnForced ) ; <nl> + } <nl> + + NBTTagList spawnlist = new NBTTagList ( ) ; <nl> + + for ( Entry < Integer , ChunkCoordinates > entry : this . spawnChunkMap . entrySet ( ) ) { <nl> + + NBTTagCompound spawndata = new NBTTagCompound ( ) ; <nl> + + ChunkCoordinates spawn = entry . getValue ( ) ; <nl> + + if ( spawn = = null ) continue ; <nl> + + Boolean forced = spawnForcedMap . get ( entry . getKey ( ) ) ; <nl> + + if ( forced = = null ) forced = false ; <nl> + + spawndata . setInteger ( " Dim " , entry . getKey ( ) ) ; <nl> + + spawndata . setInteger ( " SpawnX " , spawn . posX ) ; <nl> + + spawndata . setInteger ( " SpawnY " , spawn . posY ) ; <nl> + + spawndata . setInteger ( " SpawnZ " , spawn . posZ ) ; <nl> + + spawndata . setBoolean ( " SpawnForced " , forced ) ; <nl> + + spawnlist . appendTag ( spawndata ) ; <nl> + + } <nl> + + par1NBTTagCompound . setTag ( " Spawns " , spawnlist ) ; <nl> + <nl> + this . foodStats . writeNBT ( par1NBTTagCompound ) ; <nl> + this . capabilities . writeCapabilitiesToNBT ( par1NBTTagCompound ) ; <nl> + @ @ - 982 , 6 + 1071 , 7 @ @ <nl> * / <nl> public boolean attackEntityFrom ( DamageSource par1DamageSource , float par2 ) <nl> { <nl> @ @ - 181 , 7 + 244 , 7 @ @ <nl> if ( this . isEntityInvulnerable ( ) ) <nl> { <nl> return false ; <nl> - @ @ - 1135 , 12 + 1197 , 15 @ @ <nl> + @ @ - 1135 , 12 + 1225 , 15 @ @ <nl> { <nl> if ( ! this . isEntityInvulnerable ( ) ) <nl> { <nl> @ @ - 198 , 7 + 261 , 7 @ @ <nl> par2 = this . applyPotionDamageCalculations ( par1DamageSource , par2 ) ; <nl> float f1 = par2 ; <nl> par2 = Math . max ( par2 - this . func _ 110139 _ bj ( ) , 0 . 0F ) ; <nl> - @ @ - 1190 , 6 + 1255 , 7 @ @ <nl> + @ @ - 1190 , 6 + 1283 , 7 @ @ <nl> <nl> public boolean interactWith ( Entity par1Entity ) <nl> { <nl> @ @ - 206 , 7 + 269 , 7 @ @ <nl> ItemStack itemstack = this . getCurrentEquippedItem ( ) ; <nl> ItemStack itemstack1 = itemstack ! = null ? itemstack . copy ( ) : null ; <nl> <nl> - @ @ - 1246 , 7 + 1312 , 9 @ @ <nl> + @ @ - 1246 , 7 + 1340 , 9 @ @ <nl> * / <nl> public void destroyCurrentEquippedItem ( ) <nl> { <nl> @ @ - 216 , 7 + 279 , 7 @ @ <nl> } <nl> <nl> / * * <nl> - @ @ - 1263 , 6 + 1331 , 15 @ @ <nl> + @ @ - 1263 , 6 + 1359 , 15 @ @ <nl> * / <nl> public void attackTargetEntityWithCurrentItem ( Entity par1Entity ) <nl> { <nl> @ @ - 232 , 7 + 295 , 7 @ @ <nl> if ( par1Entity . canAttackWithItem ( ) ) <nl> { <nl> if ( ! par1Entity . func _ 85031 _ j ( this ) ) <nl> - @ @ - 1421 , 6 + 1498 , 12 @ @ <nl> + @ @ - 1421 , 6 + 1526 , 12 @ @ <nl> * / <nl> public EnumStatus sleepInBedAt ( int par1 , int par2 , int par3 ) <nl> { <nl> @ @ - 245 , 7 + 308 , 7 @ @ <nl> if ( ! this . worldObj . isRemote ) <nl> { <nl> if ( this . isPlayerSleeping ( ) | | ! this . isEntityAlive ( ) ) <nl> - @ @ - 1465 , 6 + 1548 , 11 @ @ <nl> + @ @ - 1465 , 6 + 1576 , 11 @ @ <nl> { <nl> int l = this . worldObj . getBlockMetadata ( par1 , par2 , par3 ) ; <nl> int i1 = BlockBed . getDirection ( l ) ; <nl> @ @ - 257 , 7 + 320 , 7 @ @ <nl> float f = 0 . 5F ; <nl> float f1 = 0 . 5F ; <nl> <nl> - @ @ - 1535 , 10 + 1623 , 12 @ @ <nl> + @ @ - 1535 , 10 + 1651 , 12 @ @ <nl> ChunkCoordinates chunkcoordinates = this . playerLocation ; <nl> ChunkCoordinates chunkcoordinates1 = this . playerLocation ; <nl> <nl> @ @ - 274 , 7 + 337 , 7 @ @ <nl> <nl> if ( chunkcoordinates1 = = null ) <nl> { <nl> - @ @ - 1575 , 7 + 1665 , 9 @ @ <nl> + @ @ - 1575 , 7 + 1693 , 9 @ @ <nl> * / <nl> private boolean isInBed ( ) <nl> { <nl> @ @ - 285 , 7 + 348 , 7 @ @ <nl> } <nl> <nl> / * * <nl> - @ @ - 1590 , 9 + 1682 , 12 @ @ <nl> + @ @ - 1590 , 9 + 1710 , 12 @ @ <nl> ichunkprovider . loadChunk ( par1ChunkCoordinates . posX - 3 > > 4 , par1ChunkCoordinates . posZ + 3 > > 4 ) ; <nl> ichunkprovider . loadChunk ( par1ChunkCoordinates . posX + 3 > > 4 , par1ChunkCoordinates . posZ + 3 > > 4 ) ; <nl> <nl> @ @ - 301 , 7 + 364 , 7 @ @ <nl> return chunkcoordinates1 ; <nl> } <nl> else <nl> - @ @ - 1614 , 10 + 1709 , 13 @ @ <nl> + @ @ - 1614 , 10 + 1737 , 13 @ @ <nl> { <nl> if ( this . playerLocation ! = null ) <nl> { <nl> @ @ - 319 , 7 + 382 , 97 @ @ <nl> { <nl> case 0 : <nl> return 90 . 0F ; <nl> - @ @ - 1891 , 6 + 1989 , 10 @ @ <nl> + @ @ - 1683 , 14 + 1809 , 40 @ @ <nl> + / * * <nl> + * Returns the location of the bed the player will respawn at , or null if the player has not slept in a bed . <nl> + * / <nl> + + @ Deprecated <nl> + public ChunkCoordinates getBedLocation ( ) <nl> + { <nl> + - return this . spawnChunk ; <nl> + - } <nl> + - <nl> + + return getBedLocation ( this . dimension ) ; <nl> + + } <nl> + + <nl> + + @ Deprecated <nl> + public boolean isSpawnForced ( ) <nl> + { <nl> + - return this . spawnForced ; <nl> + + return isSpawnForced ( this . dimension ) ; <nl> + + } <nl> + + <nl> + + / * * <nl> + + * A dimension aware version of getBedLocation . <nl> + + * @ param dimension The dimension to get the bed spawn for <nl> + + * @ return The player specific spawn location for the dimension . May be null . <nl> + + * / <nl> + + public ChunkCoordinates getBedLocation ( int dimension ) { <nl> + + if ( dimension = = 0 ) return this . spawnChunk ; <nl> + + return this . spawnChunkMap . get ( dimension ) ; <nl> + + } <nl> + + <nl> + + / * * <nl> + + * A dimension aware version of isSpawnForced . <nl> + + * Noramally isSpawnForced is used to determine if the respawn system should check for a bed or not . <nl> + + * This just extends that to be dimension aware . <nl> + + * @ param dimension The dimension to get whether to check for a bed before spawning for <nl> + + * @ return The player specific spawn location for the dimension . May be null . <nl> + + * / <nl> + + public boolean isSpawnForced ( int dimension ) { <nl> + + if ( dimension = = 0 ) return this . spawnForced ; <nl> + + Boolean forced = this . spawnForcedMap . get ( dimension ) ; <nl> + + if ( forced = = null ) return false ; <nl> + + return forced ; <nl> + } <nl> + <nl> + / * * <nl> + @ @ - 1698 , 6 + 1850 , 10 @ @ <nl> + * / <nl> + public void setSpawnChunk ( ChunkCoordinates par1ChunkCoordinates , boolean par2 ) <nl> + { <nl> + + if ( this . dimension ! = 0 ) { <nl> + + setSpawnChunk ( par1ChunkCoordinates , par2 , this . dimension ) ; <nl> + + return ; <nl> + + } <nl> + if ( par1ChunkCoordinates ! = null ) <nl> + { <nl> + this . spawnChunk = new ChunkCoordinates ( par1ChunkCoordinates ) ; <nl> + @ @ - 1709 , 7 + 1865 , 32 @ @ <nl> + this . spawnForced = false ; <nl> + } <nl> + } <nl> + - <nl> + + / * * <nl> + + * A dimension aware version of setSpawnChunk . <nl> + + * This functions identically , but allows you to specify which dimension to affect , rather than affecting the player ' s current dimension . <nl> + + * @ param chunkCoordinates The spawn point to set as the player - specific spawn point for the dimension <nl> + + * @ param forced Whether or not the respawn code should check for a bed at this location ( true means it won ' t check for a bed ) <nl> + + * @ param dimension Which dimension to apply the player - specific respawn point to <nl> + + * / <nl> + + public void setSpawnChunk ( ChunkCoordinates chunkCoordinates , boolean forced , int dimension ) { <nl> + + if ( dimension = = 0 ) { <nl> + + if ( chunkCoordinates ! = null ) { <nl> + + this . spawnChunk = new ChunkCoordinates ( chunkCoordinates ) ; <nl> + + this . spawnForced = forced ; <nl> + + } else { <nl> + + this . spawnChunk = null ; <nl> + + this . spawnForced = false ; <nl> + + } <nl> + + return ; <nl> + + } <nl> + + if ( chunkCoordinates ! = null ) { <nl> + + this . spawnChunkMap . put ( dimension , new ChunkCoordinates ( chunkCoordinates ) ) ; <nl> + + this . spawnForcedMap . put ( dimension , forced ) ; <nl> + + } else { <nl> + + this . spawnChunkMap . remove ( dimension ) ; <nl> + + this . spawnForcedMap . remove ( dimension ) ; <nl> + + } <nl> + + } <nl> + / * * <nl> + * Will trigger the specified trigger . <nl> + * / <nl> + @ @ - 1891 , 6 + 2072 , 10 @ @ <nl> <nl> super . fall ( par1 ) ; <nl> } <nl> @ @ - 330 , 7 + 483 , 7 @ @ <nl> } <nl> <nl> / * * <nl> - @ @ - 1932 , 7 + 2034 , 7 @ @ <nl> + @ @ - 1932 , 7 + 2117 , 7 @ @ <nl> { <nl> if ( par1ItemStack . getItem ( ) . requiresMultipleRenderPasses ( ) ) <nl> { <nl> @ @ - 339 , 7 + 492 , 7 @ @ <nl> } <nl> <nl> if ( this . itemInUse ! = null & & par1ItemStack . itemID = = Item . bow . itemID ) <nl> - @ @ - 1954 , 6 + 2056 , 7 @ @ <nl> + @ @ - 1954 , 6 + 2139 , 7 @ @ <nl> return Item . bow . getItemIconForUseDuration ( 0 ) ; <nl> } <nl> } <nl> @ @ - 347 , 9 + 500 , 12 @ @ <nl> } <nl> <nl> return icon ; <nl> - @ @ - 2176 , 6 + 2279 , 14 @ @ <nl> + @ @ - 2175 , 7 + 2361 , 17 @ @ <nl> + this . setScore ( par1EntityPlayer . getScore ( ) ) ; <nl> } <nl> <nl> + + this . spawnChunkMap = par1EntityPlayer . spawnChunkMap ; <nl> + + this . spawnForcedMap = par1EntityPlayer . spawnForcedMap ; <nl> this . theInventoryEnderChest = par1EntityPlayer . theInventoryEnderChest ; <nl> + <nl> + / / Copy over a section of the Entity Data from the old player . <nl> @ @ - 362 , 7 + 518 , 7 @ @ <nl> } <nl> <nl> / * * <nl> - @ @ - 2239 , 7 + 2350 , 14 @ @ <nl> + @ @ - 2239 , 7 + 2435 , 14 @ @ <nl> * / <nl> public void setCurrentItemOrArmor ( int par1 , ItemStack par2ItemStack ) <nl> { <nl> diff - - git a / patches / minecraft / net / minecraft / server / management / ServerConfigurationManager . java . patch b / patches / minecraft / net / minecraft / server / management / ServerConfigurationManager . java . patch <nl> index 2fe38a1 . . 331f53f 100644 <nl> - - - a / patches / minecraft / net / minecraft / server / management / ServerConfigurationManager . java . patch <nl> + + + b / patches / minecraft / net / minecraft / server / management / ServerConfigurationManager . java . patch <nl> @ @ - 15 , 7 + 15 , 7 @ @ <nl> <nl> public abstract class ServerConfigurationManager <nl> { <nl> - @ @ - 387 , 6 + 391 , 16 @ @ <nl> + @ @ - 387 , 13 + 391 , 23 @ @ <nl> * / <nl> public EntityPlayerMP respawnPlayer ( EntityPlayerMP par1EntityPlayerMP , int par2 , boolean par3 ) <nl> { <nl> @ @ - 32 , 6 + 32 , 15 @ @ <nl> par1EntityPlayerMP . getServerForPlayer ( ) . getEntityTracker ( ) . removePlayerFromTrackers ( par1EntityPlayerMP ) ; <nl> par1EntityPlayerMP . getServerForPlayer ( ) . getEntityTracker ( ) . removeEntityFromAllTrackingPlayers ( par1EntityPlayerMP ) ; <nl> par1EntityPlayerMP . getServerForPlayer ( ) . getPlayerManager ( ) . removePlayer ( par1EntityPlayerMP ) ; <nl> + this . playerEntityList . remove ( par1EntityPlayerMP ) ; <nl> + this . mcServer . worldServerForDimension ( par1EntityPlayerMP . dimension ) . removePlayerEntityDangerously ( par1EntityPlayerMP ) ; <nl> + - ChunkCoordinates chunkcoordinates = par1EntityPlayerMP . getBedLocation ( ) ; <nl> + - boolean flag1 = par1EntityPlayerMP . isSpawnForced ( ) ; <nl> + + ChunkCoordinates chunkcoordinates = par1EntityPlayerMP . getBedLocation ( par2 ) ; <nl> + + boolean flag1 = par1EntityPlayerMP . isSpawnForced ( par2 ) ; <nl> + par1EntityPlayerMP . dimension = par2 ; <nl> + Object object ; <nl> + <nl> @ @ - 409 , 6 + 423 , 7 @ @ <nl> EntityPlayerMP entityplayermp1 = new EntityPlayerMP ( this . mcServer , this . mcServer . worldServerForDimension ( par1EntityPlayerMP . dimension ) , par1EntityPlayerMP . getCommandSenderName ( ) , ( ItemInWorldManager ) object ) ; <nl> entityplayermp1 . playerNetServerHandler = par1EntityPlayerMP . playerNetServerHandler ;

TEST DIFF:
diff - - git a / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch b / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch 
 new file mode 100644 
 index 0000000 . . 092bc3a 
 - - - / dev / null 
 + + + b / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch 
 @ @ - 0 , 0 + 1 , 619 @ @ 
 + - - - . . / src - base / minecraft / net / minecraft / entity / player / EntityPlayer . java 
 + + + + . . / src - work / minecraft / net / minecraft / entity / player / EntityPlayer . java 
 + @ @ - 80 , 6 + 80 , 11 @ @ 
 + @ SuppressWarnings ( " incomplete - switch " ) 
 + public abstract class EntityPlayer extends EntityLivingBase 
 + { 
 + + public static final String PERSISTED _ NBT _ TAG = " PlayerPersisted " ; 
 + + private java . util . HashMap < Integer , BlockPos > spawnChunkMap = new java . util . HashMap < Integer , BlockPos > ( ) ; 
 + + private java . util . HashMap < Integer , Boolean > spawnForcedMap = new java . util . HashMap < Integer , Boolean > ( ) ; 
 + + public float eyeHeight = this . getDefaultEyeHeight ( ) ; 
 + + 
 + public InventoryPlayer inventory = new InventoryPlayer ( this ) ; 
 + private InventoryEnderChest theInventoryEnderChest = new InventoryEnderChest ( ) ; 
 + public Container inventoryContainer ; 
 + @ @ - 176 , 7 + 181 , 8 @ @ 
 + { 
 + if ( this . itemInUse ! = null ) 
 + { 
 + - this . itemInUse . onPlayerStoppedUsing ( this . worldObj , this , this . itemInUseCount ) ; 
 + + if ( ! net . minecraftforge . event . ForgeEventFactory . onUseItemStop ( this , itemInUse , this . itemInUseCount ) ) 
 + + this . itemInUse . onPlayerStoppedUsing ( this . worldObj , this , this . itemInUseCount ) ; 
 + } 
 + 
 + this . clearItemInUse ( ) ; 
 + @ @ - 200 , 6 + 206 , 7 @ @ 
 + 
 + public void onUpdate ( ) 
 + { 
 + + net . minecraftforge . fml . common . FMLCommonHandler . instance ( ) . onPlayerPreTick ( this ) ; 
 + this . noClip = this . isSpectator ( ) ; 
 + 
 + if ( this . isSpectator ( ) ) 
 + @ @ - 213 , 6 + 220 , 14 @ @ 
 + 
 + if ( itemstack = = this . itemInUse ) 
 + { 
 + + itemInUseCount = net . minecraftforge . event . ForgeEventFactory . onItemUseTick ( this , itemInUse , itemInUseCount ) ; 
 + + if ( itemInUseCount < = 0 ) 
 + + { 
 + + this . onItemUseFinish ( ) ; 
 + + } 
 + + else 
 + + { / / Forge Keep unindented to lower patch 
 + + itemInUse . getItem ( ) . onUsingTick ( itemInUse , this , itemInUseCount ) ; / / Forge Added 
 + if ( this . itemInUseCount < = 25 & & this . itemInUseCount % 4 = = 0 ) 
 + { 
 + this . updateItemUse ( itemstack , 5 ) ; 
 + @ @ - 222 , 6 + 237 , 7 @ @ 
 + { 
 + this . onItemUseFinish ( ) ; 
 + } 
 + + } 
 + } 
 + else 
 + { 
 + @ @ - 267 , 7 + 283 , 7 @ @ 
 + 
 + super . onUpdate ( ) ; 
 + 
 + - if ( ! this . worldObj . isRemote & & this . openContainer ! = null & & ! this . openContainer . canInteractWith ( this ) ) 
 + + if ( ! this . worldObj . isRemote & & this . openContainer ! = null & & ! net . minecraftforge . common . ForgeHooks . canInteractWith ( this , this . openContainer ) ) 
 + { 
 + this . closeScreen ( ) ; 
 + this . openContainer = this . inventoryContainer ; 
 + @ @ - 344 , 6 + 360 , 7 @ @ 
 + { 
 + this . setPosition ( d3 , this . posY , d4 ) ; 
 + } 
 + + net . minecraftforge . fml . common . FMLCommonHandler . instance ( ) . onPlayerPostTick ( this ) ; 
 + } 
 + 
 + public int getMaxInPortalTime ( ) 
 + @ @ - 413 , 11 + 430 , 12 @ @ 
 + int i = this . itemInUse . stackSize ; 
 + ItemStack itemstack = this . itemInUse . onItemUseFinish ( this . worldObj , this ) ; 
 + 
 + + itemstack = net . minecraftforge . event . ForgeEventFactory . onItemUseFinish ( this , itemInUse , itemInUseCount , itemstack ) ; 
 + if ( itemstack ! = this . itemInUse | | itemstack ! = null & & itemstack . stackSize ! = i ) 
 + { 
 + this . inventory . mainInventory [ this . inventory . currentItem ] = itemstack ; 
 + 
 + - if ( itemstack . stackSize = = 0 ) 
 + + if ( itemstack ! = null & & itemstack . stackSize = = 0 ) 
 + { 
 + this . inventory . mainInventory [ this . inventory . currentItem ] = null ; 
 + } 
 + @ @ - 477 , 11 + 495 , 11 @ @ 
 + this . cameraYaw = 0 . 0F ; 
 + this . addMountedMovementStat ( this . posX - d0 , this . posY - d1 , this . posZ - d2 ) ; 
 + 
 + - if ( this . ridingEntity instanceof EntityPig ) 
 + + if ( this . ridingEntity instanceof EntityLivingBase & & ( ( EntityLivingBase ) ridingEntity ) . shouldRiderFaceForward ( this ) ) 
 + { 
 + this . rotationPitch = f1 ; 
 + this . rotationYaw = f ; 
 + - this . renderYawOffset = ( ( EntityPig ) this . ridingEntity ) . renderYawOffset ; 
 + + this . renderYawOffset = ( ( EntityLivingBase ) this . ridingEntity ) . renderYawOffset ; 
 + } 
 + } 
 + } 
 + @ @ - 611 , 11 + 629 , 15 @ @ 
 + 
 + public void onDeath ( DamageSource cause ) 
 + { 
 + + if ( net . minecraftforge . common . ForgeHooks . onLivingDeath ( this , cause ) ) return ; 
 + super . onDeath ( cause ) ; 
 + this . setSize ( 0 . 2F , 0 . 2F ) ; 
 + this . setPosition ( this . posX , this . posY , this . posZ ) ; 
 + this . motionY = 0 . 10000000149011612D ; 
 + 
 + + captureDrops = true ; 
 + + capturedDrops . clear ( ) ; 
 + + 
 + if ( this . getName ( ) . equals ( " Notch " ) ) 
 + { 
 + this . dropItem ( new ItemStack ( Items . apple , 1 ) , true , false ) ; 
 + @ @ - 626 , 6 + 648 , 9 @ @ 
 + this . inventory . dropAllItems ( ) ; 
 + } 
 + 
 + + captureDrops = false ; 
 + + if ( ! worldObj . isRemote ) net . minecraftforge . event . ForgeEventFactory . onPlayerDrops ( this , cause , capturedDrops , recentlyHit > 0 ) ; 
 + + 
 + if ( cause ! = null ) 
 + { 
 + this . motionX = ( double ) ( - MathHelper . cos ( ( this . attackedAtYaw + this . rotationYaw ) * ( float ) Math . PI / 180 . 0F ) * 0 . 1F ) ; 
 + @ @ - 708 , 12 + 733 , 25 @ @ 
 + 
 + public EntityItem dropOneItem ( boolean p _ 71040 _ 1 _ ) 
 + { 
 + - return this . dropItem ( this . inventory . decrStackSize ( this . inventory . currentItem , p _ 71040 _ 1 _ & & this . inventory . getCurrentItem ( ) ! = null ? this . inventory . getCurrentItem ( ) . stackSize : 1 ) , false , true ) ; 
 + + ItemStack stack = inventory . getCurrentItem ( ) ; 
 + + 
 + + if ( stack = = null ) 
 + + { 
 + + return null ; 
 + + } 
 + + 
 + + if ( stack . getItem ( ) . onDroppedByPlayer ( stack , this ) ) 
 + + { 
 + + int count = p _ 71040 _ 1 _ & & this . inventory . getCurrentItem ( ) ! = null ? this . inventory . getCurrentItem ( ) . stackSize : 1 ; 
 + + return net . minecraftforge . common . ForgeHooks . onPlayerTossEvent ( this , inventory . decrStackSize ( inventory . currentItem , count ) , true ) ; 
 + + } 
 + + 
 + + return null ; 
 + } 
 + 
 + public EntityItem dropPlayerItemWithRandomChoice ( ItemStack itemStackIn , boolean unused ) 
 + { 
 + - return this . dropItem ( itemStackIn , false , false ) ; 
 + + return net . minecraftforge . common . ForgeHooks . onPlayerTossEvent ( this , itemStackIn , false ) ; 
 + } 
 + 
 + public EntityItem dropItem ( ItemStack droppedItem , boolean dropAround , boolean traceItem ) 
 + @ @ - 771 , 13 + 809 , 25 @ @ 
 + 
 + public void joinEntityItemWithWorld ( EntityItem p _ 71012 _ 1 _ ) 
 + { 
 + + if ( captureDrops ) 
 + + { 
 + + capturedDrops . add ( p _ 71012 _ 1 _ ) ; 
 + + return ; 
 + + } 
 + + 
 + this . worldObj . spawnEntityInWorld ( p _ 71012 _ 1 _ ) ; 
 + } 
 + 
 + + @ Deprecated / / Use location sensitive version below 
 + public float getToolDigEfficiency ( Block p _ 180471 _ 1 _ ) 
 + { 
 + - float f = this . inventory . getStrVsBlock ( p _ 180471 _ 1 _ ) ; 
 + + return getBreakSpeed ( p _ 180471 _ 1 _ . getDefaultState ( ) , new BlockPos ( 0 , - 1 , 0 ) ) ; 
 + + } 
 + 
 + + public float getBreakSpeed ( IBlockState state , BlockPos pos ) 
 + + { 
 + + ItemStack stack = inventory . getCurrentItem ( ) ; 
 + + float f = ( stack = = null ? 1 . 0F : stack . getItem ( ) . getDigSpeed ( stack , state ) ) ; 
 + if ( f > 1 . 0F ) 
 + { 
 + int i = EnchantmentHelper . getEfficiencyModifier ( this ) ; 
 + @ @ - 827 , 12 + 877 , 13 @ @ 
 + f / = 5 . 0F ; 
 + } 
 + 
 + - return f ; 
 + + f = net . minecraftforge . event . ForgeEventFactory . getBreakSpeed ( this , state , f , pos ) ; 
 + + return ( f < 0 ? 0 : f ) ; 
 + } 
 + 
 + public boolean canHarvestBlock ( Block p _ 146099 _ 1 _ ) 
 + { 
 + - return this . inventory . func _ 146025 _ b ( p _ 146099 _ 1 _ ) ; 
 + + return net . minecraftforge . event . ForgeEventFactory . doPlayerHarvestCheck ( this , p _ 146099 _ 1 _ , this . inventory . func _ 146025 _ b ( p _ 146099 _ 1 _ ) ) ; 
 + } 
 + 
 + public void readEntityFromNBT ( NBTTagCompound tagCompund ) 
 + @ @ - 868 , 6 + 919 , 16 @ @ 
 + this . spawnForced = tagCompund . getBoolean ( " SpawnForced " ) ; 
 + } 
 + 
 + + NBTTagList spawnlist = null ; 
 + + spawnlist = tagCompund . getTagList ( " Spawns " , 10 ) ; 
 + + for ( int i = 0 ; i < spawnlist . tagCount ( ) ; i + + ) 
 + + { 
 + + NBTTagCompound spawndata = ( NBTTagCompound ) spawnlist . getCompoundTagAt ( i ) ; 
 + + int spawndim = spawndata . getInteger ( " Dim " ) ; 
 + + this . spawnChunkMap . put ( spawndim , new BlockPos ( spawndata . getInteger ( " SpawnX " ) , spawndata . getInteger ( " SpawnY " ) , spawndata . getInteger ( " SpawnZ " ) ) ) ; 
 + + this . spawnForcedMap . put ( spawndim , spawndata . getBoolean ( " SpawnForced " ) ) ; 
 + + } 
 + + 
 + this . foodStats . readNBT ( tagCompund ) ; 
 + this . capabilities . readCapabilitiesFromNBT ( tagCompund ) ; 
 + 
 + @ @ - 899 , 6 + 960 , 23 @ @ 
 + tagCompound . setBoolean ( " SpawnForced " , this . spawnForced ) ; 
 + } 
 + 
 + + NBTTagList spawnlist = new NBTTagList ( ) ; 
 + + for ( java . util . Map . Entry < Integer , BlockPos > entry : this . spawnChunkMap . entrySet ( ) ) 
 + + { 
 + + BlockPos spawn = entry . getValue ( ) ; 
 + + if ( spawn = = null ) continue ; 
 + + Boolean forced = spawnForcedMap . get ( entry . getKey ( ) ) ; 
 + + if ( forced = = null ) forced = false ; 
 + + NBTTagCompound spawndata = new NBTTagCompound ( ) ; 
 + + spawndata . setInteger ( " Dim " , entry . getKey ( ) ) ; 
 + + spawndata . setInteger ( " SpawnX " , spawn . getX ( ) ) ; 
 + + spawndata . setInteger ( " SpawnY " , spawn . getY ( ) ) ; 
 + + spawndata . setInteger ( " SpawnZ " , spawn . getZ ( ) ) ; 
 + + spawndata . setBoolean ( " SpawnForced " , forced ) ; 
 + + spawnlist . appendTag ( spawndata ) ; 
 + + } 
 + + tagCompound . setTag ( " Spawns " , spawnlist ) ; 
 + + 
 + this . foodStats . writeNBT ( tagCompound ) ; 
 + this . capabilities . writeCapabilitiesToNBT ( tagCompound ) ; 
 + tagCompound . setTag ( " EnderItems " , this . theInventoryEnderChest . saveInventoryToNBT ( ) ) ; 
 + @ @ - 912 , 6 + 990 , 7 @ @ 
 + 
 + public boolean attackEntityFrom ( DamageSource source , float amount ) 
 + { 
 + + if ( ! net . minecraftforge . common . ForgeHooks . onLivingAttack ( this , source , amount ) ) return false ; 
 + if ( this . isEntityInvulnerable ( source ) ) 
 + { 
 + return false ; 
 + @ @ - 1008 , 12 + 1087 , 15 @ @ 
 + { 
 + if ( ! this . isEntityInvulnerable ( damageSrc ) ) 
 + { 
 + + damageAmount = net . minecraftforge . common . ForgeHooks . onLivingHurt ( this , damageSrc , damageAmount ) ; 
 + + if ( damageAmount < = 0 ) return ; 
 + if ( ! damageSrc . isUnblockable ( ) & & this . isBlocking ( ) & & damageAmount > 0 . 0F ) 
 + { 
 + damageAmount = ( 1 . 0F + damageAmount ) * 0 . 5F ; 
 + } 
 + 
 + - damageAmount = this . applyArmorCalculations ( damageSrc , damageAmount ) ; 
 + + damageAmount = net . minecraftforge . common . ISpecialArmor . ArmorProperties . applyArmor ( this , inventory . armorInventory , damageSrc , damageAmount ) ; 
 + + if ( damageAmount < = 0 ) return ; 
 + damageAmount = this . applyPotionDamageCalculations ( damageSrc , damageAmount ) ; 
 + float f = damageAmount ; 
 + damageAmount = Math . max ( damageAmount - this . getAbsorptionAmount ( ) , 0 . 0F ) ; 
 + @ @ - 1075 , 6 + 1157 , 7 @ @ 
 + } 
 + else 
 + { 
 + + if ( ! net . minecraftforge . event . ForgeEventFactory . canInteractWith ( this , p _ 70998 _ 1 _ ) ) return false ; 
 + ItemStack itemstack = this . getCurrentEquippedItem ( ) ; 
 + ItemStack itemstack1 = itemstack ! = null ? itemstack . copy ( ) : null ; 
 + 
 + @ @ - 1126 , 7 + 1209 , 9 @ @ 
 + 
 + public void destroyCurrentEquippedItem ( ) 
 + { 
 + + ItemStack orig = getCurrentEquippedItem ( ) ; 
 + this . inventory . setInventorySlotContents ( this . inventory . currentItem , ( ItemStack ) null ) ; 
 + + net . minecraftforge . event . ForgeEventFactory . onPlayerDestroyItem ( this , orig ) ; 
 + } 
 + 
 + public double getYOffset ( ) 
 + @ @ - 1136 , 6 + 1221 , 7 @ @ 
 + 
 + public void attackTargetEntityWithCurrentItem ( Entity targetEntity ) 
 + { 
 + + if ( ! net . minecraftforge . common . ForgeHooks . onPlayerAttackTarget ( this , targetEntity ) ) return ; 
 + if ( targetEntity . canAttackWithItem ( ) ) 
 + { 
 + if ( ! targetEntity . hitByEntity ( this ) ) 
 + @ @ - 1312 , 6 + 1398 , 8 @ @ 
 + 
 + public EntityPlayer . EnumStatus trySleep ( BlockPos bedLocation ) 
 + { 
 + + EntityPlayer . EnumStatus ret = net . minecraftforge . event . ForgeEventFactory . onPlayerSleepInBed ( this , bedLocation ) ; 
 + + if ( ret ! = null ) return ret ; 
 + if ( ! this . worldObj . isRemote ) 
 + { 
 + if ( this . isPlayerSleeping ( ) | | ! this . isEntityAlive ( ) ) 
 + @ @ - 1353 , 7 + 1441 , 7 @ @ 
 + 
 + if ( this . worldObj . isBlockLoaded ( bedLocation ) ) 
 + { 
 + - EnumFacing enumfacing = ( EnumFacing ) this . worldObj . getBlockState ( bedLocation ) . getValue ( BlockDirectional . FACING ) ; 
 + + EnumFacing enumfacing = this . worldObj . getBlockState ( bedLocation ) . getBlock ( ) . getBedDirection ( worldObj , bedLocation ) ; 
 + float f = 0 . 5F ; 
 + float f1 = 0 . 5F ; 
 + 
 + @ @ - 1416 , 13 + 1504 , 14 @ @ 
 + 
 + public void wakeUpPlayer ( boolean p _ 70999 _ 1 _ , boolean updateWorldFlag , boolean setSpawn ) 
 + { 
 + + net . minecraftforge . event . ForgeEventFactory . onPlayerWakeup ( this , p _ 70999 _ 1 _ , updateWorldFlag , setSpawn ) ; 
 + this . setSize ( 0 . 6F , 1 . 8F ) ; 
 + IBlockState iblockstate = this . worldObj . getBlockState ( this . playerLocation ) ; 
 + 
 + - if ( this . playerLocation ! = null & & iblockstate . getBlock ( ) = = Blocks . bed ) 
 + + if ( this . playerLocation ! = null & & iblockstate . getBlock ( ) . isBed ( worldObj , playerLocation , this ) ) 
 + { 
 + - this . worldObj . setBlockState ( this . playerLocation , iblockstate . withProperty ( BlockBed . OCCUPIED , Boolean . valueOf ( false ) ) , 4 ) ; 
 + - BlockPos blockpos = BlockBed . getSafeExitLocation ( this . worldObj , this . playerLocation , 0 ) ; 
 + + iblockstate . getBlock ( ) . setBedOccupied ( worldObj , playerLocation , this , false ) ; 
 + + BlockPos blockpos = iblockstate . getBlock ( ) . getBedSpawnPosition ( worldObj , playerLocation , this ) ; 
 + 
 + if ( blockpos = = null ) 
 + { 
 + @ @ - 1449 , 14 + 1538 , 14 @ @ 
 + 
 + private boolean isInBed ( ) 
 + { 
 + - return this . worldObj . getBlockState ( this . playerLocation ) . getBlock ( ) = = Blocks . bed ; 
 + + return this . worldObj . getBlockState ( this . playerLocation ) . getBlock ( ) . isBed ( worldObj , playerLocation , this ) ; 
 + } 
 + 
 + public static BlockPos getBedSpawnLocation ( World worldIn , BlockPos bedLocation , boolean forceSpawn ) 
 + { 
 + Block block = worldIn . getBlockState ( bedLocation ) . getBlock ( ) ; 
 + 
 + - if ( block ! = Blocks . bed ) 
 + + if ( ! block . isBed ( worldIn , bedLocation , null ) ) 
 + { 
 + if ( ! forceSpawn ) 
 + { 
 + @ @ - 1471 , 7 + 1560 , 7 @ @ 
 + } 
 + else 
 + { 
 + - return BlockBed . getSafeExitLocation ( worldIn , bedLocation , 0 ) ; 
 + + return worldIn . getBlockState ( bedLocation ) . getBlock ( ) . getBedSpawnPosition ( worldIn , bedLocation , null ) ; 
 + } 
 + } 
 + 
 + @ @ - 1480 , 7 + 1569 , 7 @ @ 
 + { 
 + if ( this . playerLocation ! = null ) 
 + { 
 + - EnumFacing enumfacing = ( EnumFacing ) this . worldObj . getBlockState ( this . playerLocation ) . getValue ( BlockDirectional . FACING ) ; 
 + + EnumFacing enumfacing = this . worldObj . getBlockState ( this . playerLocation ) . getBlock ( ) . getBedDirection ( worldObj , playerLocation ) ; 
 + 
 + switch ( enumfacing ) 
 + { 
 + @ @ - 1520 , 16 + 1609 , 24 @ @ 
 + 
 + public BlockPos getBedLocation ( ) 
 + { 
 + - return this . spawnChunk ; 
 + + return getBedLocation ( this . dimension ) ; 
 + } 
 + 
 + + @ Deprecated / / Use dimension - sensitive version . 
 + public boolean isSpawnForced ( ) 
 + { 
 + - return this . spawnForced ; 
 + + return isSpawnForced ( this . dimension ) ; 
 + } 
 + 
 + public void setSpawnPoint ( BlockPos pos , boolean forced ) 
 + { 
 + + if ( net . minecraftforge . event . ForgeEventFactory . onPlayerSpawnSet ( this , pos , forced ) ) return ; 
 + + if ( this . dimension ! = 0 ) 
 + + { 
 + + setSpawnChunk ( pos , forced , this . dimension ) ; 
 + + return ; 
 + + } 
 + + 
 + if ( pos ! = null ) 
 + { 
 + this . spawnChunk = pos ; 
 + @ @ - 1713 , 6 + 1810 , 10 @ @ 
 + 
 + super . fall ( distance , damageMultiplier ) ; 
 + } 
 + + else 
 + + { 
 + + net . minecraftforge . event . ForgeEventFactory . onPlayerFall ( this , distance , damageMultiplier ) ; 
 + + } 
 + } 
 + 
 + protected void resetHeight ( ) 
 + @ @ - 1736 , 6 + 1837 , 7 @ @ 
 + } 
 + 
 + EntityList . EntityEggInfo entitylist $ entityegginfo = ( EntityList . EntityEggInfo ) EntityList . entityEggs . get ( Integer . valueOf ( EntityList . getEntityID ( entityLivingIn ) ) ) ; 
 + + if ( entitylist $ entityegginfo = = null ) entitylist $ entityegginfo = net . minecraftforge . fml . common . registry . EntityRegistry . getEggs ( ) . get ( EntityList . getEntityString ( entityLivingIn ) ) ; 
 + 
 + if ( entitylist $ entityegginfo ! = null ) 
 + { 
 + @ @ - 1848 , 6 + 1950 , 8 @ @ 
 + { 
 + if ( stack ! = this . itemInUse ) 
 + { 
 + + duration = net . minecraftforge . event . ForgeEventFactory . onItemUseStart ( this , stack , duration ) ; 
 + + if ( duration < = 0 ) return ; 
 + this . itemInUse = stack ; 
 + this . itemInUseCount = duration ; 
 + 
 + @ @ - 1919 , 6 + 2023 , 10 @ @ 
 + this . field _ 181016 _ an = oldPlayer . field _ 181016 _ an ; 
 + this . field _ 181017 _ ao = oldPlayer . field _ 181017 _ ao ; 
 + this . field _ 181018 _ ap = oldPlayer . field _ 181018 _ ap ; 
 + + / / Copy and re - init ExtendedProperties when switching dimensions . 
 + + this . extendedProperties = oldPlayer . extendedProperties ; 
 + + for ( net . minecraftforge . common . IExtendedEntityProperties p : this . extendedProperties . values ( ) ) 
 + + p . init ( this , this . worldObj ) ; 
 + } 
 + else if ( this . worldObj . getGameRules ( ) . getGameRuleBooleanValue ( " keepInventory " ) ) 
 + { 
 + @ @ - 1932 , 6 + 2040 , 18 @ @ 
 + this . xpSeed = oldPlayer . xpSeed ; 
 + this . theInventoryEnderChest = oldPlayer . theInventoryEnderChest ; 
 + this . getDataWatcher ( ) . updateObject ( 10 , Byte . valueOf ( oldPlayer . getDataWatcher ( ) . getWatchableObjectByte ( 10 ) ) ) ; 
 + + 
 + + this . spawnChunkMap = oldPlayer . spawnChunkMap ; 
 + + this . spawnForcedMap = oldPlayer . spawnForcedMap ; 
 + + 
 + + / / Copy over a section of the Entity Data from the old player . 
 + + / / Allows mods to specify data that persists after players respawn . 
 + + NBTTagCompound old = oldPlayer . getEntityData ( ) ; 
 + + if ( old . hasKey ( PERSISTED _ NBT _ TAG ) ) 
 + + { 
 + + getEntityData ( ) . setTag ( PERSISTED _ NBT _ TAG , old . getCompoundTag ( PERSISTED _ NBT _ TAG ) ) ; 
 + + } 
 + + net . minecraftforge . event . ForgeEventFactory . onPlayerClone ( this , oldPlayer , ! respawnFromEnd ) ; 
 + } 
 + 
 + protected boolean canTriggerWalking ( ) 
 + @ @ - 1969 , 7 + 2089 , 14 @ @ 
 + 
 + public void setCurrentItemOrArmor ( int slotIn , ItemStack stack ) 
 + { 
 + - this . inventory . armorInventory [ slotIn ] = stack ; 
 + + if ( slotIn = = 0 ) / / Forge : Fix issue in Player where it doen ' t take into account selected item 
 + + { 
 + + this . inventory . mainInventory [ this . inventory . currentItem ] = stack ; 
 + + } 
 + + else 
 + + { 
 + + this . inventory . armorInventory [ slotIn - 1 ] = stack ; 
 + + } 
 + } 
 + 
 + @ SideOnly ( Side . CLIENT ) 
 + @ @ - 2014 , 7 + 2141 , 10 @ @ 
 + 
 + public IChatComponent getDisplayName ( ) 
 + { 
 + - IChatComponent ichatcomponent = new ChatComponentText ( ScorePlayerTeam . formatPlayerName ( this . getTeam ( ) , this . getName ( ) ) ) ; 
 + + IChatComponent ichatcomponent = new ChatComponentText ( " " ) ; 
 + + if ( ! prefixes . isEmpty ( ) ) for ( net . minecraft . util . IChatComponent prefix : prefixes ) ichatcomponent . appendSibling ( prefix ) ; 
 + + ichatcomponent . appendSibling ( new ChatComponentText ( ScorePlayerTeam . formatPlayerName ( this . getTeam ( ) , this . getDisplayNameString ( ) ) ) ) ; 
 + + if ( ! suffixes . isEmpty ( ) ) for ( net . minecraft . util . IChatComponent suffix : suffixes ) ichatcomponent . appendSibling ( suffix ) ; 
 + ichatcomponent . getChatStyle ( ) . setChatClickEvent ( new ClickEvent ( ClickEvent . Action . SUGGEST _ COMMAND , " / msg " + this . getName ( ) + " " ) ) ; 
 + ichatcomponent . getChatStyle ( ) . setChatHoverEvent ( this . func _ 174823 _ aP ( ) ) ; 
 + ichatcomponent . getChatStyle ( ) . setInsertion ( this . getName ( ) ) ; 
 + @ @ - 2023 , 7 + 2153 , 7 @ @ 
 + 
 + public float getEyeHeight ( ) 
 + { 
 + - float f = 1 . 62F ; 
 + + float f = eyeHeight ; 
 + 
 + if ( this . isPlayerSleeping ( ) ) 
 + { 
 + @ @ - 2156 , 6 + 2286 , 136 @ @ 
 + this . hasReducedDebug = reducedDebug ; 
 + } 
 + 
 + + / * * 
 + + * Opens a GUI with this player , uses FML ' s IGuiHandler system . 
 + + * Allows for extension by modders . 
 + + * 
 + + * @ param mod The mod trying to open a GUI 
 + + * @ param modGuiId GUI ID 
 + + * @ param world Current World 
 + + * @ param x Passed directly to IGuiHandler , data meaningless Typically world X position 
 + + * @ param y Passed directly to IGuiHandler , data meaningless Typically world Y position 
 + + * @ param z Passed directly to IGuiHandler , data meaningless Typically world Z position 
 + + * / 
 + + public void openGui ( Object mod , int modGuiId , World world , int x , int y , int z ) 
 + + { 
 + + net . minecraftforge . fml . common . network . internal . FMLNetworkHandler . openGui ( this , mod , modGuiId , world , x , y , z ) ; 
 + + } 
 + + 
 + + 
 + + / * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = FORGE START = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = * / 
 + + / * * 
 + + * A dimension aware version of getBedLocation . 
 + + * @ param dimension The dimension to get the bed spawn for 
 + + * @ return The player specific spawn location for the dimension . May be null . 
 + + * / 
 + + public BlockPos getBedLocation ( int dimension ) 
 + + { 
 + + return dimension = = 0 ? spawnChunk : spawnChunkMap . get ( dimension ) ; 
 + + } 
 + + 
 + + / * * 
 + + * A dimension aware version of isSpawnForced . 
 + + * Noramally isSpawnForced is used to determine if the respawn system should check for a bed or not . 
 + + * This just extends that to be dimension aware . 
 + + * @ param dimension The dimension to get whether to check for a bed before spawning for 
 + + * @ return The player specific spawn location for the dimension . May be null . 
 + + * / 
 + + public boolean isSpawnForced ( int dimension ) 
 + + { 
 + + if ( dimension = = 0 ) return this . spawnForced ; 
 + + Boolean forced = this . spawnForcedMap . get ( dimension ) ; 
 + + return forced = = null ? false : forced ; 
 + + } 
 + + 
 + + / * * 
 + + * A dimension aware version of setSpawnChunk . 
 + + * This functions identically , but allows you to specify which dimension to affect , rather than affecting the player ' s current dimension . 
 + + * @ param pos The spawn point to set as the player - specific spawn point for the dimension 
 + + * @ param forced Whether or not the respawn code should check for a bed at this location ( true means it won ' t check for a bed ) 
 + + * @ param dimension Which dimension to apply the player - specific respawn point to 
 + + * / 
 + + public void setSpawnChunk ( BlockPos pos , boolean forced , int dimension ) 
 + + { 
 + + if ( dimension = = 0 ) 
 + + { 
 + + if ( pos ! = null ) 
 + + { 
 + + spawnChunk = pos ; 
 + + spawnForced = forced ; 
 + + } 
 + + else 
 + + { 
 + + spawnChunk = null ; 
 + + spawnForced = false ; 
 + + } 
 + + return ; 
 + + } 
 + + 
 + + if ( pos ! = null ) 
 + + { 
 + + spawnChunkMap . put ( dimension , pos ) ; 
 + + spawnForcedMap . put ( dimension , forced ) ; 
 + + } 
 + + else 
 + + { 
 + + spawnChunkMap . remove ( dimension ) ; 
 + + spawnForcedMap . remove ( dimension ) ; 
 + + } 
 + + } 
 + + 
 + + private String displayname ; 
 + + 
 + + / * * 
 + + * Returns the default eye height of the player 
 + + * @ return player default eye height 
 + + * / 
 + + public float getDefaultEyeHeight ( ) 
 + + { 
 + + return 1 . 62F ; 
 + + } 
 + + 
 + + / * * 
 + + * Get the currently computed display name , cached for efficiency . 
 + + * @ return the current display name 
 + + * / 
 + + public String getDisplayNameString ( ) 
 + + { 
 + + if ( this . displayname = = null ) 
 + + { 
 + + this . displayname = net . minecraftforge . event . ForgeEventFactory . getPlayerDisplayName ( this , this . getName ( ) ) ; 
 + + } 
 + + return this . displayname ; 
 + + } 
 + + 
 + + / * * 
 + + * Force the displayed name to refresh 
 + + * / 
 + + public void refreshDisplayName ( ) 
 + + { 
 + + this . displayname = net . minecraftforge . event . ForgeEventFactory . getPlayerDisplayName ( this , this . getName ( ) ) ; 
 + + } 
 + + 
 + + private final java . util . Collection < net . minecraft . util . IChatComponent > prefixes = new java . util . LinkedList < net . minecraft . util . IChatComponent > ( ) ; 
 + + private final java . util . Collection < net . minecraft . util . IChatComponent > suffixes = new java . util . LinkedList < net . minecraft . util . IChatComponent > ( ) ; 
 + + 
 + + / * * 
 + + * Add a prefix to the player ' s username in chat 
 + + * @ param prefix The prefix 
 + + * / 
 + + public void addPrefix ( net . minecraft . util . IChatComponent prefix ) { prefixes . add ( prefix ) ; } 
 + + 
 + + / * * 
 + + * Add a suffix to the player ' s username in chat 
 + + * @ param suffix The suffix 
 + + * / 
 + + public void addSuffix ( net . minecraft . util . IChatComponent suffix ) { suffixes . add ( suffix ) ; } 
 + + 
 + + public java . util . Collection < net . minecraft . util . IChatComponent > getPrefixes ( ) { return this . prefixes ; } 
 + + public java . util . Collection < net . minecraft . util . IChatComponent > getSuffixes ( ) { return this . suffixes ; } 
 + + 
 + + / * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = FORGE END = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = * / 
 + + 
 + public static enum EnumChatVisibility 
 + { 
 + FULL ( 0 , " options . chat . visibility . full " ) ,

NEAREST DIFF:
diff - - git a / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch b / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch 
 index 582b791 . . 7e9ccb2 100644 
 - - - a / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch 
 + + + b / patches / minecraft / net / minecraft / entity / player / EntityPlayer . java . patch 
 @ @ - 1 , 6 + 1 , 18 @ @ 
 - - - . . / src _ base / minecraft / net / minecraft / entity / player / EntityPlayer . java 
 + + + . . / src _ work / minecraft / net / minecraft / entity / player / EntityPlayer . java 
 - @ @ - 68 , 8 + 68 , 21 @ @ 
 + @ @ - 5 , 8 + 5 , 11 @ @ 
 + import cpw . mods . fml . relauncher . Side ; 
 + import cpw . mods . fml . relauncher . SideOnly ; 
 + import java . util . Collection ; 
 + + import java . util . HashMap ; 
 + import java . util . Iterator ; 
 + import java . util . List ; 
 + + import java . util . Map . Entry ; 
 + + 
 + import net . minecraft . block . Block ; 
 + import net . minecraft . block . BlockBed ; 
 + import net . minecraft . block . material . Material ; 
 + @ @ - 68 , 8 + 71 , 21 @ @ 
 import net . minecraft . world . World ; 
 import net . minecraft . world . chunk . IChunkProvider ; 
 
 @ @ - 22 , 7 + 34 , 21 @ @ 
 / * * Inventory of the player * / 
 public InventoryPlayer inventory = new InventoryPlayer ( this ) ; 
 private InventoryEnderChest theInventoryEnderChest = new InventoryEnderChest ( ) ; 
 - @ @ - 269 , 6 + 282 , 7 @ @ 
 + @ @ - 122 , 11 + 138 , 13 @ @ 
 + * Holds the last coordinate to spawn based on last bed that the player sleep . 
 + * / 
 + private ChunkCoordinates spawnChunk ; 
 + + private HashMap < Integer , ChunkCoordinates > spawnChunkMap = new HashMap < Integer , ChunkCoordinates > ( ) ; 
 + 
 + / * * 
 + * Whether this player ' s spawn point is forced , preventing execution of bed checks . 
 + * / 
 + private boolean spawnForced ; 
 + + private HashMap < Integer , Boolean > spawnForcedMap = new HashMap < Integer , Boolean > ( ) ; 
 + 
 + / * * Holds the coordinate of the player when enter a minecraft to ride . * / 
 + private ChunkCoordinates startMinecartRidingCoordinate ; 
 + @ @ - 269 , 6 + 287 , 7 @ @ 
 
 if ( itemstack = = this . itemInUse ) 
 { 
 @ @ - 30 , 7 + 56 , 7 @ @ 
 if ( this . itemInUseCount < = 25 & & this . itemInUseCount % 4 = = 0 ) 
 { 
 this . updateItemUse ( itemstack , 5 ) ; 
 - @ @ - 539 , 11 + 553 , 11 @ @ 
 + @ @ - 539 , 11 + 558 , 11 @ @ 
 this . cameraYaw = 0 . 0F ; 
 this . addMountedMovementStat ( this . posX - d0 , this . posY - d1 , this . posZ - d2 ) ; 
 
 @ @ - 44 , 7 + 70 , 7 @ @ 
 } 
 } 
 } 
 - @ @ - 686 , 11 + 700 , 15 @ @ 
 + @ @ - 686 , 11 + 705 , 15 @ @ 
 * / 
 public void onDeath ( DamageSource par1DamageSource ) 
 { 
 @ @ - 60 , 7 + 86 , 7 @ @ 
 if ( this . username . equals ( " Notch " ) ) 
 { 
 this . dropPlayerItemWithRandomChoice ( new ItemStack ( Item . appleRed , 1 ) , true ) ; 
 - @ @ - 699 , 6 + 717 , 20 @ @ 
 + @ @ - 699 , 6 + 722 , 20 @ @ 
 if ( ! this . worldObj . getGameRules ( ) . getGameRuleBooleanValue ( " keepInventory " ) ) 
 { 
 this . inventory . dropAllItems ( ) ; 
 @ @ - 81 , 7 + 107 , 7 @ @ 
 } 
 
 if ( par1DamageSource ! = null ) 
 - @ @ - 749 , 7 + 781 , 20 @ @ 
 + @ @ - 749 , 7 + 786 , 20 @ @ 
 * / 
 public EntityItem dropOneItem ( boolean par1 ) 
 { 
 @ @ - 103 , 7 + 129 , 7 @ @ 
 } 
 
 / * * 
 - @ @ - 758 , 7 + 803 , 7 @ @ 
 + @ @ - 758 , 7 + 808 , 7 @ @ 
 * / 
 public EntityItem dropPlayerItem ( ItemStack par1ItemStack ) 
 { 
 @ @ - 112 , 7 + 138 , 7 @ @ 
 } 
 
 / * * 
 - @ @ - 814 , 15 + 859 , 28 @ @ 
 + @ @ - 814 , 15 + 864 , 28 @ @ 
 * / 
 public void joinEntityItemWithWorld ( EntityItem par1EntityItem ) 
 { 
 @ @ - 143 , 7 + 169 , 7 @ @ 
 
 if ( f > 1 . 0F ) 
 { 
 - @ @ - 833 , 7 + 891 , 9 @ @ 
 + @ @ - 833 , 7 + 896 , 9 @ @ 
 { 
 float f1 = ( float ) ( i * i + 1 ) ; 
 
 @ @ - 154 , 7 + 180 , 7 @ @ 
 { 
 f + = f1 * 0 . 08F ; 
 } 
 - @ @ - 864 , 7 + 924 , 8 @ @ 
 + @ @ - 864 , 7 + 929 , 8 @ @ 
 f / = 5 . 0F ; 
 } 
 
 @ @ - 164 , 7 + 190 , 7 @ @ 
 } 
 
 / * * 
 - @ @ - 872 , 7 + 933 , 7 @ @ 
 + @ @ - 872 , 7 + 938 , 7 @ @ 
 * / 
 public boolean canHarvestBlock ( Block par1Block ) 
 { 
 @ @ - 173 , 7 + 199 , 44 @ @ 
 } 
 
 / * * 
 - @ @ - 982 , 6 + 1043 , 7 @ @ 
 + @ @ - 902 , 6 + 968 , 14 @ @ 
 + this . spawnChunk = new ChunkCoordinates ( par1NBTTagCompound . getInteger ( " SpawnX " ) , par1NBTTagCompound . getInteger ( " SpawnY " ) , par1NBTTagCompound . getInteger ( " SpawnZ " ) ) ; 
 + this . spawnForced = par1NBTTagCompound . getBoolean ( " SpawnForced " ) ; 
 + } 
 + + NBTTagList spawnlist = null ; 
 + + spawnlist = par1NBTTagCompound . getTagList ( " Spawns " ) ; 
 + + for ( int i = 0 ; i < spawnlist . tagCount ( ) ; + + i ) { 
 + + NBTTagCompound spawndata = ( NBTTagCompound ) spawnlist . tagAt ( i ) ; 
 + + int spawndim = spawndata . getInteger ( " Dim " ) ; 
 + + this . spawnChunkMap . put ( spawndim , new ChunkCoordinates ( spawndata . getInteger ( " SpawnX " ) , spawndata . getInteger ( " SpawnY " ) , spawndata . getInteger ( " SpawnZ " ) ) ) ; 
 + + this . spawnForcedMap . put ( spawndim , spawndata . getBoolean ( " SpawnForced " ) ) ; 
 + + } 
 + 
 + this . foodStats . readNBT ( par1NBTTagCompound ) ; 
 + this . capabilities . readCapabilitiesFromNBT ( par1NBTTagCompound ) ; 
 + @ @ - 935 , 6 + 1009 , 21 @ @ 
 + par1NBTTagCompound . setInteger ( " SpawnZ " , this . spawnChunk . posZ ) ; 
 + par1NBTTagCompound . setBoolean ( " SpawnForced " , this . spawnForced ) ; 
 + } 
 + + NBTTagList spawnlist = new NBTTagList ( ) ; 
 + + for ( Entry < Integer , ChunkCoordinates > entry : this . spawnChunkMap . entrySet ( ) ) { 
 + + NBTTagCompound spawndata = new NBTTagCompound ( ) ; 
 + + ChunkCoordinates spawn = entry . getValue ( ) ; 
 + + if ( spawn = = null ) continue ; 
 + + Boolean forced = spawnForcedMap . get ( entry . getKey ( ) ) ; 
 + + if ( forced = = null ) forced = false ; 
 + + spawndata . setInteger ( " Dim " , entry . getKey ( ) ) ; 
 + + spawndata . setInteger ( " SpawnX " , spawn . posX ) ; 
 + + spawndata . setInteger ( " SpawnY " , spawn . posY ) ; 
 + + spawndata . setInteger ( " SpawnZ " , spawn . posZ ) ; 
 + + spawndata . setBoolean ( " SpawnForced " , forced ) ; 
 + + spawnlist . appendTag ( spawndata ) ; 
 + + } 
 + + par1NBTTagCompound . setTag ( " Spawns " , spawnlist ) ; 
 + 
 + this . foodStats . writeNBT ( par1NBTTagCompound ) ; 
 + this . capabilities . writeCapabilitiesToNBT ( par1NBTTagCompound ) ; 
 + @ @ - 982 , 6 + 1071 , 7 @ @ 
 * / 
 public boolean attackEntityFrom ( DamageSource par1DamageSource , float par2 ) 
 { 
 @ @ - 181 , 7 + 244 , 7 @ @ 
 if ( this . isEntityInvulnerable ( ) ) 
 { 
 return false ; 
 - @ @ - 1135 , 12 + 1197 , 15 @ @ 
 + @ @ - 1135 , 12 + 1225 , 15 @ @ 
 { 
 if ( ! this . isEntityInvulnerable ( ) ) 
 { 
 @ @ - 198 , 7 + 261 , 7 @ @ 
 par2 = this . applyPotionDamageCalculations ( par1DamageSource , par2 ) ; 
 float f1 = par2 ; 
 par2 = Math . max ( par2 - this . func _ 110139 _ bj ( ) , 0 . 0F ) ; 
 - @ @ - 1190 , 6 + 1255 , 7 @ @ 
 + @ @ - 1190 , 6 + 1283 , 7 @ @ 
 
 public boolean interactWith ( Entity par1Entity ) 
 { 
 @ @ - 206 , 7 + 269 , 7 @ @ 
 ItemStack itemstack = this . getCurrentEquippedItem ( ) ; 
 ItemStack itemstack1 = itemstack ! = null ? itemstack . copy ( ) : null ; 
 
 - @ @ - 1246 , 7 + 1312 , 9 @ @ 
 + @ @ - 1246 , 7 + 1340 , 9 @ @ 
 * / 
 public void destroyCurrentEquippedItem ( ) 
 { 
 @ @ - 216 , 7 + 279 , 7 @ @ 
 } 
 
 / * * 
 - @ @ - 1263 , 6 + 1331 , 15 @ @ 
 + @ @ - 1263 , 6 + 1359 , 15 @ @ 
 * / 
 public void attackTargetEntityWithCurrentItem ( Entity par1Entity ) 
 { 
 @ @ - 232 , 7 + 295 , 7 @ @ 
 if ( par1Entity . canAttackWithItem ( ) ) 
 { 
 if ( ! par1Entity . func _ 85031 _ j ( this ) ) 
 - @ @ - 1421 , 6 + 1498 , 12 @ @ 
 + @ @ - 1421 , 6 + 1526 , 12 @ @ 
 * / 
 public EnumStatus sleepInBedAt ( int par1 , int par2 , int par3 ) 
 { 
 @ @ - 245 , 7 + 308 , 7 @ @ 
 if ( ! this . worldObj . isRemote ) 
 { 
 if ( this . isPlayerSleeping ( ) | | ! this . isEntityAlive ( ) ) 
 - @ @ - 1465 , 6 + 1548 , 11 @ @ 
 + @ @ - 1465 , 6 + 1576 , 11 @ @ 
 { 
 int l = this . worldObj . getBlockMetadata ( par1 , par2 , par3 ) ; 
 int i1 = BlockBed . getDirection ( l ) ; 
 @ @ - 257 , 7 + 320 , 7 @ @ 
 float f = 0 . 5F ; 
 float f1 = 0 . 5F ; 
 
 - @ @ - 1535 , 10 + 1623 , 12 @ @ 
 + @ @ - 1535 , 10 + 1651 , 12 @ @ 
 ChunkCoordinates chunkcoordinates = this . playerLocation ; 
 ChunkCoordinates chunkcoordinates1 = this . playerLocation ; 
 
 @ @ - 274 , 7 + 337 , 7 @ @ 
 
 if ( chunkcoordinates1 = = null ) 
 { 
 - @ @ - 1575 , 7 + 1665 , 9 @ @ 
 + @ @ - 1575 , 7 + 1693 , 9 @ @ 
 * / 
 private boolean isInBed ( ) 
 { 
 @ @ - 285 , 7 + 348 , 7 @ @ 
 } 
 
 / * * 
 - @ @ - 1590 , 9 + 1682 , 12 @ @ 
 + @ @ - 1590 , 9 + 1710 , 12 @ @ 
 ichunkprovider . loadChunk ( par1ChunkCoordinates . posX - 3 > > 4 , par1ChunkCoordinates . posZ + 3 > > 4 ) ; 
 ichunkprovider . loadChunk ( par1ChunkCoordinates . posX + 3 > > 4 , par1ChunkCoordinates . posZ + 3 > > 4 ) ; 
 
 @ @ - 301 , 7 + 364 , 7 @ @ 
 return chunkcoordinates1 ; 
 } 
 else 
 - @ @ - 1614 , 10 + 1709 , 13 @ @ 
 + @ @ - 1614 , 10 + 1737 , 13 @ @ 
 { 
 if ( this . playerLocation ! = null ) 
 { 
 @ @ - 319 , 7 + 382 , 97 @ @ 
 { 
 case 0 : 
 return 90 . 0F ; 
 - @ @ - 1891 , 6 + 1989 , 10 @ @ 
 + @ @ - 1683 , 14 + 1809 , 40 @ @ 
 + / * * 
 + * Returns the location of the bed the player will respawn at , or null if the player has not slept in a bed . 
 + * / 
 + + @ Deprecated 
 + public ChunkCoordinates getBedLocation ( ) 
 + { 
 + - return this . spawnChunk ; 
 + - } 
 + - 
 + + return getBedLocation ( this . dimension ) ; 
 + + } 
 + + 
 + + @ Deprecated 
 + public boolean isSpawnForced ( ) 
 + { 
 + - return this . spawnForced ; 
 + + return isSpawnForced ( this . dimension ) ; 
 + + } 
 + + 
 + + / * * 
 + + * A dimension aware version of getBedLocation . 
 + + * @ param dimension The dimension to get the bed spawn for 
 + + * @ return The player specific spawn location for the dimension . May be null . 
 + + * / 
 + + public ChunkCoordinates getBedLocation ( int dimension ) { 
 + + if ( dimension = = 0 ) return this . spawnChunk ; 
 + + return this . spawnChunkMap . get ( dimension ) ; 
 + + } 
 + + 
 + + / * * 
 + + * A dimension aware version of isSpawnForced . 
 + + * Noramally isSpawnForced is used to determine if the respawn system should check for a bed or not . 
 + + * This just extends that to be dimension aware . 
 + + * @ param dimension The dimension to get whether to check for a bed before spawning for 
 + + * @ return The player specific spawn location for the dimension . May be null . 
 + + * / 
 + + public boolean isSpawnForced ( int dimension ) { 
 + + if ( dimension = = 0 ) return this . spawnForced ; 
 + + Boolean forced = this . spawnForcedMap . get ( dimension ) ; 
 + + if ( forced = = null ) return false ; 
 + + return forced ; 
 + } 
 + 
 + / * * 
 + @ @ - 1698 , 6 + 1850 , 10 @ @ 
 + * / 
 + public void setSpawnChunk ( ChunkCoordinates par1ChunkCoordinates , boolean par2 ) 
 + { 
 + + if ( this . dimension ! = 0 ) { 
 + + setSpawnChunk ( par1ChunkCoordinates , par2 , this . dimension ) ; 
 + + return ; 
 + + } 
 + if ( par1ChunkCoordinates ! = null ) 
 + { 
 + this . spawnChunk = new ChunkCoordinates ( par1ChunkCoordinates ) ; 
 + @ @ - 1709 , 7 + 1865 , 32 @ @ 
 + this . spawnForced = false ; 
 + } 
 + } 
 + - 
 + + / * * 
 + + * A dimension aware version of setSpawnChunk . 
 + + * This functions identically , but allows you to specify which dimension to affect , rather than affecting the player ' s current dimension . 
 + + * @ param chunkCoordinates The spawn point to set as the player - specific spawn point for the dimension 
 + + * @ param forced Whether or not the respawn code should check for a bed at this location ( true means it won ' t check for a bed ) 
 + + * @ param dimension Which dimension to apply the player - specific respawn point to 
 + + * / 
 + + public void setSpawnChunk ( ChunkCoordinates chunkCoordinates , boolean forced , int dimension ) { 
 + + if ( dimension = = 0 ) { 
 + + if ( chunkCoordinates ! = null ) { 
 + + this . spawnChunk = new ChunkCoordinates ( chunkCoordinates ) ; 
 + + this . spawnForced = forced ; 
 + + } else { 
 + + this . spawnChunk = null ; 
 + + this . spawnForced = false ; 
 + + } 
 + + return ; 
 + + } 
 + + if ( chunkCoordinates ! = null ) { 
 + + this . spawnChunkMap . put ( dimension , new ChunkCoordinates ( chunkCoordinates ) ) ; 
 + + this . spawnForcedMap . put ( dimension , forced ) ; 
 + + } else { 
 + + this . spawnChunkMap . remove ( dimension ) ; 
 + + this . spawnForcedMap . remove ( dimension ) ; 
 + + } 
 + + } 
 + / * * 
 + * Will trigger the specified trigger . 
 + * / 
 + @ @ - 1891 , 6 + 2072 , 10 @ @ 
 
 super . fall ( par1 ) ; 
 } 
 @ @ - 330 , 7 + 483 , 7 @ @ 
 } 
 
 / * * 
 - @ @ - 1932 , 7 + 2034 , 7 @ @ 
 + @ @ - 1932 , 7 + 2117 , 7 @ @ 
 { 
 if ( par1ItemStack . getItem ( ) . requiresMultipleRenderPasses ( ) ) 
 { 
 @ @ - 339 , 7 + 492 , 7 @ @ 
 } 
 
 if ( this . itemInUse ! = null & & par1ItemStack . itemID = = Item . bow . itemID ) 
 - @ @ - 1954 , 6 + 2056 , 7 @ @ 
 + @ @ - 1954 , 6 + 2139 , 7 @ @ 
 return Item . bow . getItemIconForUseDuration ( 0 ) ; 
 } 
 } 
 @ @ - 347 , 9 + 500 , 12 @ @ 
 } 
 
 return icon ; 
 - @ @ - 2176 , 6 + 2279 , 14 @ @ 
 + @ @ - 2175 , 7 + 2361 , 17 @ @ 
 + this . setScore ( par1EntityPlayer . getScore ( ) ) ; 
 } 
 
 + + this . spawnChunkMap = par1EntityPlayer . spawnChunkMap ; 
 + + this . spawnForcedMap = par1EntityPlayer . spawnForcedMap ; 
 this . theInventoryEnderChest = par1EntityPlayer . theInventoryEnderChest ; 
 + 
 + / / Copy over a section of the Entity Data from the old player . 
 @ @ - 362 , 7 + 518 , 7 @ @ 
 } 
 
 / * * 
 - @ @ - 2239 , 7 + 2350 , 14 @ @ 
 + @ @ - 2239 , 7 + 2435 , 14 @ @ 
 * / 
 public void setCurrentItemOrArmor ( int par1 , ItemStack par2ItemStack ) 
 { 
 diff - - git a / patches / minecraft / net / minecraft / server / management / ServerConfigurationManager . java . patch b / patches / minecraft / net / minecraft / server / management / ServerConfigurationManager . java . patch 
 index 2fe38a1 . . 331f53f 100644 
 - - - a / patches / minecraft / net / minecraft / server / management / ServerConfigurationManager . java . patch 
 + + + b / patches / minecraft / net / minecraft / server / management / ServerConfigurationManager . java . patch 
 @ @ - 15 , 7 + 15 , 7 @ @ 
 
 public abstract class ServerConfigurationManager 
 { 
 - @ @ - 387 , 6 + 391 , 16 @ @ 
 + @ @ - 387 , 13 + 391 , 23 @ @ 
 * / 
 public EntityPlayerMP respawnPlayer ( EntityPlayerMP par1EntityPlayerMP , int par2 , boolean par3 ) 
 { 
 @ @ - 32 , 6 + 32 , 15 @ @ 
 par1EntityPlayerMP . getServerForPlayer ( ) . getEntityTracker ( ) . removePlayerFromTrackers ( par1EntityPlayerMP ) ; 
 par1EntityPlayerMP . getServerForPlayer ( ) . getEntityTracker ( ) . removeEntityFromAllTrackingPlayers ( par1EntityPlayerMP ) ; 
 par1EntityPlayerMP . getServerForPlayer ( ) . getPlayerManager ( ) . removePlayer ( par1EntityPlayerMP ) ; 
 + this . playerEntityList . remove ( par1EntityPlayerMP ) ; 
 + this . mcServer . worldServerForDimension ( par1EntityPlayerMP . dimension ) . removePlayerEntityDangerously ( par1EntityPlayerMP ) ; 
 + - ChunkCoordinates chunkcoordinates = par1EntityPlayerMP . getBedLocation ( ) ; 
 + - boolean flag1 = par1EntityPlayerMP . isSpawnForced ( ) ; 
 + + ChunkCoordinates chunkcoordinates = par1EntityPlayerMP . getBedLocation ( par2 ) ; 
 + + boolean flag1 = par1EntityPlayerMP . isSpawnForced ( par2 ) ; 
 + par1EntityPlayerMP . dimension = par2 ; 
 + Object object ; 
 + 
 @ @ - 409 , 6 + 423 , 7 @ @ 
 EntityPlayerMP entityplayermp1 = new EntityPlayerMP ( this . mcServer , this . mcServer . worldServerForDimension ( par1EntityPlayerMP . dimension ) , par1EntityPlayerMP . getCommandSenderName ( ) , ( ItemInWorldManager ) object ) ; 
 entityplayermp1 . playerNetServerHandler = par1EntityPlayerMP . playerNetServerHandler ;
