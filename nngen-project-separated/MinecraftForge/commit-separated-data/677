BLEU SCORE: 0.015996686545912898

TEST MSG: Make it easier to use FluidTanks that have input / output restrictions
GENERATED MSG: As agreed , liquid API from BuildCraft has been migrated to minecraft forge . There will be cleanups to follow ,

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / fluids / FluidTank . java b / src / main / java / net / minecraftforge / fluids / FluidTank . java <nl> index ba2975e . . 5641535 100644 <nl> - - - a / src / main / java / net / minecraftforge / fluids / FluidTank . java <nl> + + + b / src / main / java / net / minecraftforge / fluids / FluidTank . java <nl> @ @ - 122 , 7 + 122 , 21 @ @ public class FluidTank implements IFluidTank , IFluidHandler <nl> @ Override <nl> public int fill ( FluidStack resource , boolean doFill ) <nl> { <nl> - if ( resource = = null | | resource . amount < = 0 | | ! canFillFluidType ( resource ) ) <nl> + if ( ! canFillFluidType ( resource ) ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + <nl> + return fillInternal ( resource , doFill ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Use this method to bypass the restrictions from { @ link # canFillFluidType ( FluidStack ) } <nl> + * Meant for use by the owner of the tank when they have { @ link # canFill ( ) set to false } . <nl> + * / <nl> + public int fillInternal ( FluidStack resource , boolean doFill ) <nl> + { <nl> + if ( resource = = null | | resource . amount < = 0 ) <nl> { <nl> return 0 ; <nl> } <nl> @ @ - 183 , 17 + 197 , 43 @ @ public class FluidTank implements IFluidTank , IFluidHandler <nl> @ Override <nl> public FluidStack drain ( FluidStack resource , boolean doDrain ) <nl> { <nl> - if ( resource = = null | | ! resource . isFluidEqual ( getFluid ( ) ) ) <nl> + if ( ! canDrainFluidType ( getFluid ( ) ) ) <nl> { <nl> return null ; <nl> } <nl> - return drain ( resource . amount , doDrain ) ; <nl> + return drainInternal ( resource , doDrain ) ; <nl> } <nl> <nl> @ Override <nl> public FluidStack drain ( int maxDrain , boolean doDrain ) <nl> { <nl> - if ( fluid = = null | | maxDrain < = 0 | | ! canDrainFluidType ( fluid ) ) <nl> + if ( ! canDrainFluidType ( fluid ) ) <nl> + { <nl> + return null ; <nl> + } <nl> + return drainInternal ( maxDrain , doDrain ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Use this method to bypass the restrictions from { @ link # canDrainFluidType ( FluidStack ) } <nl> + * Meant for use by the owner of the tank when they have { @ link # canDrain ( ) } set to false } . <nl> + * / <nl> + public FluidStack drainInternal ( FluidStack resource , boolean doDrain ) <nl> + { <nl> + if ( resource = = null | | ! resource . isFluidEqual ( getFluid ( ) ) ) <nl> + { <nl> + return null ; <nl> + } <nl> + return drainInternal ( resource . amount , doDrain ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Use this method to bypass the restrictions from { @ link # canDrainFluidType ( FluidStack ) } <nl> + * Meant for use by the owner of the tank when they have { @ link # canDrain ( ) } set to false } . <nl> + * / <nl> + public FluidStack drainInternal ( int maxDrain , boolean doDrain ) <nl> + { <nl> + if ( fluid = = null | | maxDrain < = 0 ) <nl> { <nl> return null ; <nl> }
NEAREST DIFF (one line): diff - - git a / common / net / minecraftforge / common / ForgeDirection . java b / common / net / minecraftforge / common / ForgeDirection . java <nl> index 8f07d6b . . 948e7b6 100644 <nl> - - - a / common / net / minecraftforge / common / ForgeDirection . java <nl> + + + b / common / net / minecraftforge / common / ForgeDirection . java <nl> @ @ - 30 , 8 + 30 , 8 @ @ public enum ForgeDirection <nl> public final int offsetZ ; <nl> public final int flag ; <nl> public static final ForgeDirection [ ] VALID _ DIRECTIONS = { DOWN , UP , NORTH , SOUTH , WEST , EAST } ; <nl> - public static final int [ ] opposite = { 1 , 0 , 3 , 2 , 5 , 4 , 6 } ; <nl> - public static final int [ ] toLeft = { 0 , 1 , 5 , 4 , 3 , 2 , 6 } ; <nl> + public static final int [ ] OPPOSITES = { 1 , 0 , 3 , 2 , 5 , 4 , 6 } ; <nl> + public static final int [ ] TO _ LEFT = { 0 , 1 , 5 , 4 , 3 , 2 , 6 } ; <nl> <nl> private ForgeDirection ( int x , int y , int z ) <nl> { <nl> @ @ - 52 , 11 + 52 , 11 @ @ public enum ForgeDirection <nl> <nl> public ForgeDirection getOpposite ( ) <nl> { <nl> - return getOrientation ( opposite [ ordinal ( ) ] ) ; <nl> + return getOrientation ( OPPOSITES [ ordinal ( ) ] ) ; <nl> } <nl> <nl> public ForgeDirection getLeftRotation ( ) <nl> { <nl> - 	 return getOrientation ( toLeft [ ordinal ( ) ] ) ; <nl> + 	 return getOrientation ( TO _ LEFT [ ordinal ( ) ] ) ; <nl> } <nl> } <nl> diff - - git a / common / net / minecraftforge / liquids / ILiquid . java b / common / net / minecraftforge / liquids / ILiquid . java <nl> new file mode 100644 <nl> index 0000000 . . 3d33f3d <nl> - - - / dev / null <nl> + + + b / common / net / minecraftforge / liquids / ILiquid . java <nl> @ @ - 0 , 0 + 1 , 20 @ @ <nl> + / * * <nl> + * Copyright ( c ) SpaceToad , 2011 <nl> + * http : / / www . mod - buildcraft . com <nl> + * <nl> + * BuildCraft is distributed under the terms of the Minecraft Mod Public <nl> + * License 1 . 0 , or MMPL . Please check the contents of the license located in <nl> + * http : / / www . mod - buildcraft . com / MMPL - 1 . 0 . txt <nl> + * / <nl> + <nl> + package net . minecraftforge . liquids ; <nl> + <nl> + public interface ILiquid { <nl> + <nl> + 	 public int stillLiquidId ( ) ; <nl> + <nl> + 	 public boolean isMetaSensitive ( ) ; <nl> + <nl> + 	 public int stillLiquidMeta ( ) ; <nl> + <nl> + } <nl> diff - - git a / common / net / minecraftforge / liquids / ILiquidTank . java b / common / net / minecraftforge / liquids / ILiquidTank . java <nl> new file mode 100644 <nl> index 0000000 . . 562874c <nl> - - - / dev / null <nl> + + + b / common / net / minecraftforge / liquids / ILiquidTank . java <nl> @ @ - 0 , 0 + 1 , 27 @ @ <nl> + package net . minecraftforge . liquids ; <nl> + <nl> + public interface ILiquidTank { <nl> + <nl> + 	 / * * <nl> + 	 * @ return LiquidStack representing the liquid contained in the tank , null if empty . <nl> + 	 * / <nl> + 	 LiquidStack getLiquid ( ) ; <nl> + 	 void setLiquid ( LiquidStack liquid ) ; <nl> + 	 void setCapacity ( int capacity ) ; <nl> + 	 int getCapacity ( ) ; <nl> + <nl> + 	 / * * <nl> + 	 * <nl> + 	 * @ param resource <nl> + 	 * @ param doFill <nl> + 	 * @ return Amount of liquid used for filling . <nl> + 	 * / <nl> + 	 int fill ( LiquidStack resource , boolean doFill ) ; <nl> + 	 / * * <nl> + 	 * <nl> + 	 * @ param maxDrain <nl> + 	 * @ param doDrain <nl> + 	 * @ return Null if nothing was drained , otherwise a LiquidStack containing the drained . <nl> + 	 * / <nl> + 	 LiquidStack drain ( int maxDrain , boolean doDrain ) ; <nl> + } <nl> diff - - git a / common / net / minecraftforge / liquids / ITankContainer . java b / common / net / minecraftforge / liquids / ITankContainer . java <nl> new file mode 100644 <nl> index 0000000 . . 0f0d5b8 <nl> - - - / dev / null <nl> + + + b / common / net / minecraftforge / liquids / ITankContainer . java <nl> @ @ - 0 , 0 + 1 , 46 @ @ <nl> + package net . minecraftforge . liquids ; <nl> + <nl> + import net . minecraftforge . common . ForgeDirection ; <nl> + <nl> + public interface ITankContainer { <nl> + 	 <nl> + 	 / * * <nl> + 	 * Fills liquid into internal tanks , distribution is left to the ITankContainer . <nl> + 	 * @ param from Orientation the liquid is pumped in from . <nl> + 	 * @ param resource LiquidStack representing the maximum amount of liquid filled into the ITankContainer <nl> + 	 * @ param doFill If false filling will only be simulated . <nl> + 	 * @ return Amount of resource that was filled into internal tanks . <nl> + 	 * / <nl> + 	 int fill ( ForgeDirection from , LiquidStack resource , boolean doFill ) ; <nl> + 	 / * * <nl> + 	 * Fills liquid into the specified internal tank . <nl> + 	 * @ param from Orientation the liquid is pumped in from . <nl> + 	 * @ param resource LiquidStack representing the maximum amount of liquid filled into the ITankContainer <nl> + 	 * @ param doFill If false filling will only be simulated . <nl> + 	 * @ return Amount of resource that was filled into internal tanks . <nl> + 	 * / <nl> + 	 int fill ( int tankIndex , LiquidStack resource , boolean doFill ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Drains liquid out of internal tanks , distribution is left to the ITankContainer . <nl> + 	 * @ param from Orientation the liquid is drained to . <nl> + 	 * @ param maxDrain Maximum amount of liquid to drain . <nl> + 	 * @ param doDrain If false draining will only be simulated . <nl> + 	 * @ return LiquidStack representing the liquid and amount actually drained from the ITankContainer <nl> + 	 * / <nl> + 	 LiquidStack drain ( ForgeDirection from , int maxDrain , boolean doDrain ) ; <nl> + 	 / * * <nl> + 	 * Drains liquid out of the specified internal tank . <nl> + 	 * @ param from Orientation the liquid is drained to . <nl> + 	 * @ param maxDrain Maximum amount of liquid to drain . <nl> + 	 * @ param doDrain If false draining will only be simulated . <nl> + 	 * @ return LiquidStack representing the liquid and amount actually drained from the ITankContainer <nl> + 	 * / <nl> + 	 LiquidStack drain ( int tankIndex , int maxDrain , boolean doDrain ) ; <nl> + 	 <nl> + 	 / * * <nl> + 	 * @ return Array of { @ link LiquidTank } s contained in this ITankContainer <nl> + 	 * / <nl> + 	 ILiquidTank [ ] getTanks ( ) ; <nl> + 	 <nl> + } <nl> diff - - git a / common / net / minecraftforge / liquids / LiquidData . java b / common / net / minecraftforge / liquids / LiquidData . java <nl> new file mode 100644 <nl> index 0000000 . . feff1ec <nl> - - - / dev / null <nl> + + + b / common / net / minecraftforge / liquids / LiquidData . java <nl> @ @ - 0 , 0 + 1 , 45 @ @ <nl> + / * * <nl> + * Copyright ( c ) SpaceToad , 2011 <nl> + * http : / / www . mod - buildcraft . com <nl> + * <nl> + * BuildCraft is distributed under the terms of the Minecraft Mod Public <nl> + * License 1 . 0 , or MMPL . Please check the contents of the license located in <nl> + * http : / / www . mod - buildcraft . com / MMPL - 1 . 0 . txt <nl> + * / <nl> + <nl> + package net . minecraftforge . liquids ; <nl> + <nl> + import net . minecraft . src . Item ; <nl> + import net . minecraft . src . ItemStack ; <nl> + <nl> + public class LiquidData { <nl> + <nl> + 	 public final LiquidStack stillLiquid ; <nl> + 	 public final LiquidStack movingLiquid ; <nl> + <nl> + 	 public final ItemStack filled ; <nl> + 	 public final ItemStack container ; <nl> + <nl> + 	 public LiquidData ( int stillLiquidId , int movingLiquidId , Item filled ) { <nl> + 	 	 this ( new LiquidStack ( stillLiquidId , LiquidManager . BUCKET _ VOLUME ) , new LiquidStack ( movingLiquidId , LiquidManager . BUCKET _ VOLUME ) , new ItemStack ( filled , 1 ) , new ItemStack ( Item . bucketEmpty ) ) ; <nl> + 	 } <nl> + <nl> + 	 public LiquidData ( int stillLiquidId , int movingLiquidId , ItemStack filled ) { <nl> + 	 	 this ( new LiquidStack ( stillLiquidId , LiquidManager . BUCKET _ VOLUME ) , new LiquidStack ( movingLiquidId , LiquidManager . BUCKET _ VOLUME ) , filled , new ItemStack ( Item . bucketEmpty ) ) ; <nl> + 	 } <nl> + <nl> + 	 public LiquidData ( LiquidStack stillLiquid , ItemStack filled , ItemStack container ) { <nl> + 	 	 this ( stillLiquid , stillLiquid , filled , container ) ; <nl> + 	 } <nl> + 	 <nl> + 	 public LiquidData ( LiquidStack stillLiquid , LiquidStack movingLiquid , ItemStack filled , ItemStack container ) { <nl> + 	 	 this . stillLiquid = stillLiquid ; <nl> + 	 	 this . movingLiquid = movingLiquid ; <nl> + 	 	 this . filled = filled ; <nl> + 	 	 this . container = container ; <nl> + 	 	 <nl> + 	 	 if ( stillLiquid = = null | | filled = = null | | container = = null ) <nl> + 	 	 	 throw new RuntimeException ( " stillLiquid , filled , or container is null , this is an error " ) ; <nl> + 	 } <nl> + <nl> + } <nl> diff - - git a / common / net / minecraftforge / liquids / LiquidDictionary . java b / common / net / minecraftforge / liquids / LiquidDictionary . java <nl> new file mode 100644 <nl> index 0000000 . . cac8e90 <nl> - - - / dev / null <nl> + + + b / common / net / minecraftforge / liquids / LiquidDictionary . java <nl> @ @ - 0 , 0 + 1 , 57 @ @ <nl> + package net . minecraftforge . liquids ; <nl> + <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + <nl> + / * * <nl> + * When creating liquids you should register them with this class . <nl> + * <nl> + * @ author CovertJaguar < railcraft . wikispaces . com > <nl> + * / <nl> + public abstract class LiquidDictionary <nl> + { <nl> + <nl> + private static Map < String , LiquidStack > liquids = new HashMap < String , LiquidStack > ( ) ; <nl> + <nl> + / * * <nl> + * When creating liquids you should call this function . <nl> + * <nl> + * Upon passing it a name and liquid item it will return either <nl> + * a preexisting implementation of that liquid or the liquid passed in . <nl> + * <nl> + * <nl> + * @ param name the name of the liquid <nl> + * @ param liquid the liquid to use if one doesn ' t exist <nl> + * @ return <nl> + * / <nl> + public static LiquidStack getOrCreateLiquid ( String name , LiquidStack liquid ) <nl> + { <nl> + LiquidStack existing = liquids . get ( name ) ; <nl> + if ( existing ! = null ) { <nl> + return existing . copy ( ) ; <nl> + } <nl> + liquids . put ( name , liquid . copy ( ) ) ; <nl> + return liquid ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the liquid matching the name , <nl> + * if such a liquid exists . <nl> + * <nl> + * Can return null . <nl> + * <nl> + * @ param name the name of the liquid <nl> + * @ param amount the amout of liquid <nl> + * @ return <nl> + * / <nl> + public static LiquidStack getLiquid ( String name , int amount ) <nl> + { <nl> + LiquidStack liquid = liquids . get ( name ) ; <nl> + if ( liquid = = null ) <nl> + return null ; <nl> + <nl> + liquid = liquid . copy ( ) ; <nl> + liquid . amount = amount ; <nl> + return liquid ; <nl> + } <nl> + } <nl> diff - - git a / common / net / minecraftforge / liquids / LiquidManager . java b / common / net / minecraftforge / liquids / LiquidManager . java <nl> new file mode 100644 <nl> index 0000000 . . 1805a50 <nl> - - - / dev / null <nl> + + + b / common / net / minecraftforge / liquids / LiquidManager . java <nl> @ @ - 0 , 0 + 1 , 64 @ @ <nl> + package net . minecraftforge . liquids ; <nl> + <nl> + import java . util . LinkedList ; <nl> + <nl> + import net . minecraft . src . ItemStack ; <nl> + <nl> + public class LiquidManager { <nl> + 	 <nl> + 	 public static final int BUCKET _ VOLUME = 1000 ; <nl> + 	 public static LinkedList < LiquidData > liquids = new LinkedList < LiquidData > ( ) ; <nl> + 	 <nl> + 	 public static LiquidStack getLiquidForFilledItem ( ItemStack filledItem ) { <nl> + 	 	 if ( filledItem = = null ) <nl> + 	 	 	 return null ; <nl> + <nl> + 	 	 for ( LiquidData liquid : liquids ) <nl> + 	 	 	 if ( liquid . filled . isItemEqual ( filledItem ) ) <nl> + 	 	 	 	 return liquid . stillLiquid ; <nl> + <nl> + 	 	 return null ; <nl> + 	 } <nl> + 	 <nl> + 	 public static int getLiquidIDForFilledItem ( ItemStack filledItem ) { <nl> + 	 	 LiquidStack liquidForFilledItem = getLiquidForFilledItem ( filledItem ) ; <nl> + 	 	 <nl> + 	 	 if ( liquidForFilledItem = = null ) <nl> + 	 	 	 return 0 ; <nl> + 	 	 <nl> + 	 	 return liquidForFilledItem . itemID ; <nl> + 	 } <nl> + <nl> + 	 public static ItemStack getFilledItemForLiquid ( LiquidStack liquid ) { <nl> + 	 	 for ( LiquidData data : liquids ) <nl> + 	 	 	 if ( data . stillLiquid . isLiquidEqual ( liquid ) ) <nl> + 	 	 	 	 return data . filled . copy ( ) ; <nl> + <nl> + 	 	 return null ; <nl> + 	 } <nl> + 	 <nl> + 	 public static ItemStack fillLiquidContainer ( int liquidId , int quantity , ItemStack emptyContainer ) { <nl> + 	 	 return fillLiquidContainer ( new LiquidStack ( liquidId , quantity , 0 ) , emptyContainer ) ; <nl> + 	 } <nl> + 	 <nl> + 	 public static ItemStack fillLiquidContainer ( LiquidStack liquid , ItemStack emptyContainer ) { <nl> + 	 	 for ( LiquidData data : liquids ) <nl> + 	 	 	 if ( liquid . containsLiquid ( data . stillLiquid ) <nl> + 	 	 	 	 	 & & data . container . isItemEqual ( emptyContainer ) ) <nl> + 	 	 	 	 return data . filled . copy ( ) ; <nl> + return null ; <nl> + 	 } <nl> + <nl> + 	 public static boolean isLiquid ( ItemStack block ) { <nl> + 	 	 if ( block . itemID = = 0 ) <nl> + 	 	 	 return false ; <nl> + <nl> + 	 	 for ( LiquidData liquid : liquids ) <nl> + 	 	 	 if ( liquid . stillLiquid . isLiquidEqual ( block ) | | liquid . movingLiquid . isLiquidEqual ( block ) ) <nl> + 	 	 	 	 return true ; <nl> + <nl> + 	 	 return false ; <nl> + 	 } <nl> + <nl> + <nl> + } <nl> diff - - git a / common / net / minecraftforge / liquids / LiquidStack . java b / common / net / minecraftforge / liquids / LiquidStack . java <nl> new file mode 100644 <nl> index 0000000 . . 08a02c4 <nl> - - - / dev / null <nl> + + + b / common / net / minecraftforge / liquids / LiquidStack . java <nl> @ @ - 0 , 0 + 1 , 109 @ @ <nl> + package net . minecraftforge . liquids ; <nl> + <nl> + import net . minecraft . src . Block ; <nl> + import net . minecraft . src . Item ; <nl> + import net . minecraft . src . ItemStack ; <nl> + import net . minecraft . src . NBTTagCompound ; <nl> + <nl> + / * * <nl> + * ItemStack substitute for liquids <nl> + * @ author SirSengir <nl> + * / <nl> + public class LiquidStack { <nl> + 	 public int itemID ; <nl> + 	 public int amount ; <nl> + 	 public int itemMeta ; <nl> + <nl> + 	 private LiquidStack ( ) { <nl> + 	 } <nl> + <nl> + 	 public LiquidStack ( int itemID , int amount ) { <nl> + 	 	 this ( itemID , amount , 0 ) ; <nl> + 	 } <nl> + <nl> + 	 public LiquidStack ( Item item , int amount ) { <nl> + 	 	 this ( item . shiftedIndex , amount , 0 ) ; <nl> + 	 } <nl> + <nl> + 	 public LiquidStack ( Block block , int amount ) { <nl> + 	 	 this ( block . blockID , amount , 0 ) ; <nl> + 	 } <nl> + <nl> + 	 public LiquidStack ( int itemID , int amount , int itemDamage ) { <nl> + 	 	 this . itemID = itemID ; <nl> + 	 	 this . amount = amount ; <nl> + 	 	 this . itemMeta = itemDamage ; <nl> + 	 } <nl> + <nl> + 	 public NBTTagCompound writeToNBT ( NBTTagCompound nbttagcompound ) { <nl> + 	 	 nbttagcompound . setShort ( " Id " , ( short ) itemID ) ; <nl> + 	 	 nbttagcompound . setInteger ( " Amount " , amount ) ; <nl> + 	 	 nbttagcompound . setShort ( " Meta " , ( short ) itemMeta ) ; <nl> + 	 	 return nbttagcompound ; <nl> + 	 } <nl> + <nl> + 	 public void readFromNBT ( NBTTagCompound nbttagcompound ) { <nl> + 	 	 itemID = nbttagcompound . getShort ( " Id " ) ; <nl> + 	 	 amount = nbttagcompound . getInteger ( " Amount " ) ; <nl> + 	 	 itemMeta = nbttagcompound . getShort ( " Meta " ) ; <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * @ return A copy of this LiquidStack <nl> + 	 * / <nl> + 	 public LiquidStack copy ( ) { <nl> + 	 	 return new LiquidStack ( itemID , amount , itemMeta ) ; <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * @ param other <nl> + 	 * @ return true if this LiquidStack contains the same liquid as the one passed in . <nl> + 	 * / <nl> + 	 public boolean isLiquidEqual ( LiquidStack other ) { <nl> + 	 	 if ( other = = null ) <nl> + 	 	 	 return false ; <nl> + 	 	 <nl> + 	 	 return itemID = = other . itemID & & itemMeta = = other . itemMeta ; <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * @ param other <nl> + 	 * @ return true if this LiquidStack contains the other liquid ( liquids are equal and amount > = other . amount ) . <nl> + 	 * / <nl> + 	 public boolean containsLiquid ( LiquidStack other ) { <nl> + 	 	 if ( ! isLiquidEqual ( other ) ) <nl> + 	 	 	 return false ; <nl> + 	 	 <nl> + 	 	 return amount > = other . amount ; <nl> + 	 } <nl> + 	 <nl> + 	 / * * <nl> + 	 * @ param other ItemStack containing liquids . <nl> + 	 * @ return true if this LiquidStack contains the same liquid as the one passed in . <nl> + 	 * / <nl> + 	 public boolean isLiquidEqual ( ItemStack other ) { <nl> + 	 	 if ( other = = null ) <nl> + 	 	 	 return false ; <nl> + 	 	 <nl> + 	 	 return itemID = = other . itemID & & itemMeta = = other . getItemDamage ( ) ; <nl> + 	 } <nl> + 	 <nl> + 	 / * * <nl> + 	 * @ return ItemStack representation of this LiquidStack <nl> + 	 * / <nl> + 	 public ItemStack asItemStack ( ) { <nl> + 	 	 return new ItemStack ( itemID , 1 , itemMeta ) ; <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * Reads a liquid stack from the passed nbttagcompound and returns it . <nl> + 	 * <nl> + 	 * @ param nbttagcompound <nl> + 	 * @ return <nl> + 	 * / <nl> + 	 public static LiquidStack loadLiquidStackFromNBT ( NBTTagCompound nbttagcompound ) { <nl> + 	 	 LiquidStack liquidstack = new LiquidStack ( ) ; <nl> + 	 	 liquidstack . readFromNBT ( nbttagcompound ) ; <nl> + 	 	 return liquidstack . itemID = = 0 ? null : liquidstack ; <nl> + 	 } <nl> + } <nl> diff - - git a / common / net / minecraftforge / liquids / LiquidTank . java b / common / net / minecraftforge / liquids / LiquidTank . java <nl> new file mode 100644 <nl> index 0000000 . . 97e9c4e <nl> - - - / dev / null <nl> + + + b / common / net / minecraftforge / liquids / LiquidTank . java <nl> @ @ - 0 , 0 + 1 , 100 @ @ <nl> + package net . minecraftforge . liquids ; <nl> + <nl> + / * * <nl> + * Reference implementation of ILiquidTank . Use this or implement your own . <nl> + * / <nl> + public class LiquidTank implements ILiquidTank { <nl> + 	 private LiquidStack liquid ; <nl> + 	 private int capacity ; <nl> + 	 <nl> + 	 public LiquidTank ( int capacity ) { <nl> + 	 	 this ( null , capacity ) ; <nl> + 	 } <nl> + 	 <nl> + 	 public LiquidTank ( int liquidId , int quantity , int capacity ) { <nl> + 	 	 this ( new LiquidStack ( liquidId , quantity ) , capacity ) ; <nl> + 	 } <nl> + 	 public LiquidTank ( LiquidStack liquid , int capacity ) { <nl> + 	 	 this . liquid = liquid ; <nl> + 	 	 this . capacity = capacity ; <nl> + 	 } <nl> + 	 <nl> + 	 @ Override <nl> + 	 public LiquidStack getLiquid ( ) { <nl> + 	 	 return this . liquid ; <nl> + 	 } <nl> + 	 <nl> + 	 @ Override <nl> + 	 public void setLiquid ( LiquidStack liquid ) { <nl> + 	 	 this . liquid = liquid ; <nl> + 	 } <nl> + 	 <nl> + 	 @ Override <nl> + 	 public void setCapacity ( int capacity ) { <nl> + 	 	 this . capacity = capacity ; <nl> + 	 } <nl> + 	 <nl> + 	 @ Override <nl> + 	 public int getCapacity ( ) { <nl> + 	 	 return this . capacity ; <nl> + 	 } <nl> + 	 <nl> + 	 @ Override <nl> + 	 public int fill ( LiquidStack resource , boolean doFill ) { <nl> + 	 	 if ( resource = = null | | resource . itemID < = 0 ) <nl> + 	 	 	 return 0 ; <nl> + 	 	 <nl> + 	 	 if ( liquid = = null | | liquid . itemID < = 0 ) { <nl> + 	 	 	 if ( resource . amount < = capacity ) { <nl> + 	 	 	 	 if ( doFill ) <nl> + 	 	 	 	 	 this . liquid = resource . copy ( ) ; <nl> + 	 	 	 	 return resource . amount ; <nl> + 	 	 	 } else { <nl> + 	 	 	 	 if ( doFill ) { <nl> + 	 	 	 	 	 this . liquid = resource . copy ( ) ; <nl> + 	 	 	 	 	 this . liquid . amount = capacity ; <nl> + 	 	 	 	 } <nl> + 	 	 	 	 return capacity ; <nl> + 	 	 	 } <nl> + 	 	 } <nl> + 	 	 <nl> + 	 	 if ( ! liquid . isLiquidEqual ( resource ) ) <nl> + 	 	 	 return 0 ; <nl> + 	 	 <nl> + 	 	 int space = capacity - liquid . amount ; <nl> + 	 	 if ( resource . amount < = space ) { <nl> + 	 	 	 if ( doFill ) <nl> + 	 	 	 	 this . liquid . amount + = resource . amount ; <nl> + 	 	 	 return resource . amount ; <nl> + 	 	 } else { <nl> + <nl> + 	 	 	 if ( doFill ) <nl> + 	 	 	 	 this . liquid . amount = capacity ; <nl> + 	 	 	 return space ; <nl> + 	 	 } <nl> + <nl> + 	 } <nl> + 	 @ Override <nl> + 	 public LiquidStack drain ( int maxDrain , boolean doDrain ) { <nl> + 	 	 if ( liquid = = null | | liquid . itemID < = 0 ) <nl> + 	 	 	 return null ; <nl> + 	 	 if ( liquid . amount < = 0 ) <nl> + 	 	 	 return null ; <nl> + 	 	 <nl> + 	 	 int used = maxDrain ; <nl> + 	 	 if ( liquid . amount < used ) <nl> + 	 	 	 used = liquid . amount ; <nl> + 	 	 <nl> + 	 	 if ( doDrain ) { <nl> + 	 	 	 liquid . amount - = used ; <nl> + 	 	 } <nl> + 	 	 <nl> + 	 	 LiquidStack drained = new LiquidStack ( liquid . itemID , used , liquid . itemMeta ) ; <nl> + 	 	 <nl> + 	 	 / / Reset liquid if emptied <nl> + 	 	 if ( liquid . amount < = 0 ) <nl> + 	 	 	 liquid = null ; <nl> + 	 	 <nl> + 	 	 return drained ; <nl> + 	 } <nl> + } <nl> diff - - git a / eclipse / Forge - Client / . project b / eclipse / Forge - Client / . project <nl> index c182e8a . . a499d09 100644 <nl> - - - a / eclipse / Forge - Client / . project <nl> + + + b / eclipse / Forge - Client / . project <nl> @ @ - 78 , 7 + 78 , 7 @ @ <nl> 	 < variableList > <nl> 	 	 < variable > <nl> 	 	 	 < name > MCP _ LOC < / name > <nl> - 	 	 	 < value > $ % 7BPARENT - 2 - WORKSPACE _ LOC % 7D < / value > <nl> + 	 	 	 < value > $ % 7BPARENT - 3 - PROJECT _ LOC % 7D < / value > <nl> 	 	 < / variable > <nl> 	 < / variableList > <nl> < / projectDescription >

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / fluids / FluidTank . java b / src / main / java / net / minecraftforge / fluids / FluidTank . java 
 index ba2975e . . 5641535 100644 
 - - - a / src / main / java / net / minecraftforge / fluids / FluidTank . java 
 + + + b / src / main / java / net / minecraftforge / fluids / FluidTank . java 
 @ @ - 122 , 7 + 122 , 21 @ @ public class FluidTank implements IFluidTank , IFluidHandler 
 @ Override 
 public int fill ( FluidStack resource , boolean doFill ) 
 { 
 - if ( resource = = null | | resource . amount < = 0 | | ! canFillFluidType ( resource ) ) 
 + if ( ! canFillFluidType ( resource ) ) 
 + { 
 + return 0 ; 
 + } 
 + 
 + return fillInternal ( resource , doFill ) ; 
 + } 
 + 
 + / * * 
 + * Use this method to bypass the restrictions from { @ link # canFillFluidType ( FluidStack ) } 
 + * Meant for use by the owner of the tank when they have { @ link # canFill ( ) set to false } . 
 + * / 
 + public int fillInternal ( FluidStack resource , boolean doFill ) 
 + { 
 + if ( resource = = null | | resource . amount < = 0 ) 
 { 
 return 0 ; 
 } 
 @ @ - 183 , 17 + 197 , 43 @ @ public class FluidTank implements IFluidTank , IFluidHandler 
 @ Override 
 public FluidStack drain ( FluidStack resource , boolean doDrain ) 
 { 
 - if ( resource = = null | | ! resource . isFluidEqual ( getFluid ( ) ) ) 
 + if ( ! canDrainFluidType ( getFluid ( ) ) ) 
 { 
 return null ; 
 } 
 - return drain ( resource . amount , doDrain ) ; 
 + return drainInternal ( resource , doDrain ) ; 
 } 
 
 @ Override 
 public FluidStack drain ( int maxDrain , boolean doDrain ) 
 { 
 - if ( fluid = = null | | maxDrain < = 0 | | ! canDrainFluidType ( fluid ) ) 
 + if ( ! canDrainFluidType ( fluid ) ) 
 + { 
 + return null ; 
 + } 
 + return drainInternal ( maxDrain , doDrain ) ; 
 + } 
 + 
 + / * * 
 + * Use this method to bypass the restrictions from { @ link # canDrainFluidType ( FluidStack ) } 
 + * Meant for use by the owner of the tank when they have { @ link # canDrain ( ) } set to false } . 
 + * / 
 + public FluidStack drainInternal ( FluidStack resource , boolean doDrain ) 
 + { 
 + if ( resource = = null | | ! resource . isFluidEqual ( getFluid ( ) ) ) 
 + { 
 + return null ; 
 + } 
 + return drainInternal ( resource . amount , doDrain ) ; 
 + } 
 + 
 + / * * 
 + * Use this method to bypass the restrictions from { @ link # canDrainFluidType ( FluidStack ) } 
 + * Meant for use by the owner of the tank when they have { @ link # canDrain ( ) } set to false } . 
 + * / 
 + public FluidStack drainInternal ( int maxDrain , boolean doDrain ) 
 + { 
 + if ( fluid = = null | | maxDrain < = 0 ) 
 { 
 return null ; 
 }

NEAREST DIFF:
diff - - git a / common / net / minecraftforge / common / ForgeDirection . java b / common / net / minecraftforge / common / ForgeDirection . java 
 index 8f07d6b . . 948e7b6 100644 
 - - - a / common / net / minecraftforge / common / ForgeDirection . java 
 + + + b / common / net / minecraftforge / common / ForgeDirection . java 
 @ @ - 30 , 8 + 30 , 8 @ @ public enum ForgeDirection 
 public final int offsetZ ; 
 public final int flag ; 
 public static final ForgeDirection [ ] VALID _ DIRECTIONS = { DOWN , UP , NORTH , SOUTH , WEST , EAST } ; 
 - public static final int [ ] opposite = { 1 , 0 , 3 , 2 , 5 , 4 , 6 } ; 
 - public static final int [ ] toLeft = { 0 , 1 , 5 , 4 , 3 , 2 , 6 } ; 
 + public static final int [ ] OPPOSITES = { 1 , 0 , 3 , 2 , 5 , 4 , 6 } ; 
 + public static final int [ ] TO _ LEFT = { 0 , 1 , 5 , 4 , 3 , 2 , 6 } ; 
 
 private ForgeDirection ( int x , int y , int z ) 
 { 
 @ @ - 52 , 11 + 52 , 11 @ @ public enum ForgeDirection 
 
 public ForgeDirection getOpposite ( ) 
 { 
 - return getOrientation ( opposite [ ordinal ( ) ] ) ; 
 + return getOrientation ( OPPOSITES [ ordinal ( ) ] ) ; 
 } 
 
 public ForgeDirection getLeftRotation ( ) 
 { 
 - 	 return getOrientation ( toLeft [ ordinal ( ) ] ) ; 
 + 	 return getOrientation ( TO _ LEFT [ ordinal ( ) ] ) ; 
 } 
 } 
 diff - - git a / common / net / minecraftforge / liquids / ILiquid . java b / common / net / minecraftforge / liquids / ILiquid . java 
 new file mode 100644 
 index 0000000 . . 3d33f3d 
 - - - / dev / null 
 + + + b / common / net / minecraftforge / liquids / ILiquid . java 
 @ @ - 0 , 0 + 1 , 20 @ @ 
 + / * * 
 + * Copyright ( c ) SpaceToad , 2011 
 + * http : / / www . mod - buildcraft . com 
 + * 
 + * BuildCraft is distributed under the terms of the Minecraft Mod Public 
 + * License 1 . 0 , or MMPL . Please check the contents of the license located in 
 + * http : / / www . mod - buildcraft . com / MMPL - 1 . 0 . txt 
 + * / 
 + 
 + package net . minecraftforge . liquids ; 
 + 
 + public interface ILiquid { 
 + 
 + 	 public int stillLiquidId ( ) ; 
 + 
 + 	 public boolean isMetaSensitive ( ) ; 
 + 
 + 	 public int stillLiquidMeta ( ) ; 
 + 
 + } 
 diff - - git a / common / net / minecraftforge / liquids / ILiquidTank . java b / common / net / minecraftforge / liquids / ILiquidTank . java 
 new file mode 100644 
 index 0000000 . . 562874c 
 - - - / dev / null 
 + + + b / common / net / minecraftforge / liquids / ILiquidTank . java 
 @ @ - 0 , 0 + 1 , 27 @ @ 
 + package net . minecraftforge . liquids ; 
 + 
 + public interface ILiquidTank { 
 + 
 + 	 / * * 
 + 	 * @ return LiquidStack representing the liquid contained in the tank , null if empty . 
 + 	 * / 
 + 	 LiquidStack getLiquid ( ) ; 
 + 	 void setLiquid ( LiquidStack liquid ) ; 
 + 	 void setCapacity ( int capacity ) ; 
 + 	 int getCapacity ( ) ; 
 + 
 + 	 / * * 
 + 	 * 
 + 	 * @ param resource 
 + 	 * @ param doFill 
 + 	 * @ return Amount of liquid used for filling . 
 + 	 * / 
 + 	 int fill ( LiquidStack resource , boolean doFill ) ; 
 + 	 / * * 
 + 	 * 
 + 	 * @ param maxDrain 
 + 	 * @ param doDrain 
 + 	 * @ return Null if nothing was drained , otherwise a LiquidStack containing the drained . 
 + 	 * / 
 + 	 LiquidStack drain ( int maxDrain , boolean doDrain ) ; 
 + } 
 diff - - git a / common / net / minecraftforge / liquids / ITankContainer . java b / common / net / minecraftforge / liquids / ITankContainer . java 
 new file mode 100644 
 index 0000000 . . 0f0d5b8 
 - - - / dev / null 
 + + + b / common / net / minecraftforge / liquids / ITankContainer . java 
 @ @ - 0 , 0 + 1 , 46 @ @ 
 + package net . minecraftforge . liquids ; 
 + 
 + import net . minecraftforge . common . ForgeDirection ; 
 + 
 + public interface ITankContainer { 
 + 	 
 + 	 / * * 
 + 	 * Fills liquid into internal tanks , distribution is left to the ITankContainer . 
 + 	 * @ param from Orientation the liquid is pumped in from . 
 + 	 * @ param resource LiquidStack representing the maximum amount of liquid filled into the ITankContainer 
 + 	 * @ param doFill If false filling will only be simulated . 
 + 	 * @ return Amount of resource that was filled into internal tanks . 
 + 	 * / 
 + 	 int fill ( ForgeDirection from , LiquidStack resource , boolean doFill ) ; 
 + 	 / * * 
 + 	 * Fills liquid into the specified internal tank . 
 + 	 * @ param from Orientation the liquid is pumped in from . 
 + 	 * @ param resource LiquidStack representing the maximum amount of liquid filled into the ITankContainer 
 + 	 * @ param doFill If false filling will only be simulated . 
 + 	 * @ return Amount of resource that was filled into internal tanks . 
 + 	 * / 
 + 	 int fill ( int tankIndex , LiquidStack resource , boolean doFill ) ; 
 + 
 + 	 / * * 
 + 	 * Drains liquid out of internal tanks , distribution is left to the ITankContainer . 
 + 	 * @ param from Orientation the liquid is drained to . 
 + 	 * @ param maxDrain Maximum amount of liquid to drain . 
 + 	 * @ param doDrain If false draining will only be simulated . 
 + 	 * @ return LiquidStack representing the liquid and amount actually drained from the ITankContainer 
 + 	 * / 
 + 	 LiquidStack drain ( ForgeDirection from , int maxDrain , boolean doDrain ) ; 
 + 	 / * * 
 + 	 * Drains liquid out of the specified internal tank . 
 + 	 * @ param from Orientation the liquid is drained to . 
 + 	 * @ param maxDrain Maximum amount of liquid to drain . 
 + 	 * @ param doDrain If false draining will only be simulated . 
 + 	 * @ return LiquidStack representing the liquid and amount actually drained from the ITankContainer 
 + 	 * / 
 + 	 LiquidStack drain ( int tankIndex , int maxDrain , boolean doDrain ) ; 
 + 	 
 + 	 / * * 
 + 	 * @ return Array of { @ link LiquidTank } s contained in this ITankContainer 
 + 	 * / 
 + 	 ILiquidTank [ ] getTanks ( ) ; 
 + 	 
 + } 
 diff - - git a / common / net / minecraftforge / liquids / LiquidData . java b / common / net / minecraftforge / liquids / LiquidData . java 
 new file mode 100644 
 index 0000000 . . feff1ec 
 - - - / dev / null 
 + + + b / common / net / minecraftforge / liquids / LiquidData . java 
 @ @ - 0 , 0 + 1 , 45 @ @ 
 + / * * 
 + * Copyright ( c ) SpaceToad , 2011 
 + * http : / / www . mod - buildcraft . com 
 + * 
 + * BuildCraft is distributed under the terms of the Minecraft Mod Public 
 + * License 1 . 0 , or MMPL . Please check the contents of the license located in 
 + * http : / / www . mod - buildcraft . com / MMPL - 1 . 0 . txt 
 + * / 
 + 
 + package net . minecraftforge . liquids ; 
 + 
 + import net . minecraft . src . Item ; 
 + import net . minecraft . src . ItemStack ; 
 + 
 + public class LiquidData { 
 + 
 + 	 public final LiquidStack stillLiquid ; 
 + 	 public final LiquidStack movingLiquid ; 
 + 
 + 	 public final ItemStack filled ; 
 + 	 public final ItemStack container ; 
 + 
 + 	 public LiquidData ( int stillLiquidId , int movingLiquidId , Item filled ) { 
 + 	 	 this ( new LiquidStack ( stillLiquidId , LiquidManager . BUCKET _ VOLUME ) , new LiquidStack ( movingLiquidId , LiquidManager . BUCKET _ VOLUME ) , new ItemStack ( filled , 1 ) , new ItemStack ( Item . bucketEmpty ) ) ; 
 + 	 } 
 + 
 + 	 public LiquidData ( int stillLiquidId , int movingLiquidId , ItemStack filled ) { 
 + 	 	 this ( new LiquidStack ( stillLiquidId , LiquidManager . BUCKET _ VOLUME ) , new LiquidStack ( movingLiquidId , LiquidManager . BUCKET _ VOLUME ) , filled , new ItemStack ( Item . bucketEmpty ) ) ; 
 + 	 } 
 + 
 + 	 public LiquidData ( LiquidStack stillLiquid , ItemStack filled , ItemStack container ) { 
 + 	 	 this ( stillLiquid , stillLiquid , filled , container ) ; 
 + 	 } 
 + 	 
 + 	 public LiquidData ( LiquidStack stillLiquid , LiquidStack movingLiquid , ItemStack filled , ItemStack container ) { 
 + 	 	 this . stillLiquid = stillLiquid ; 
 + 	 	 this . movingLiquid = movingLiquid ; 
 + 	 	 this . filled = filled ; 
 + 	 	 this . container = container ; 
 + 	 	 
 + 	 	 if ( stillLiquid = = null | | filled = = null | | container = = null ) 
 + 	 	 	 throw new RuntimeException ( " stillLiquid , filled , or container is null , this is an error " ) ; 
 + 	 } 
 + 
 + } 
 diff - - git a / common / net / minecraftforge / liquids / LiquidDictionary . java b / common / net / minecraftforge / liquids / LiquidDictionary . java 
 new file mode 100644 
 index 0000000 . . cac8e90 
 - - - / dev / null 
 + + + b / common / net / minecraftforge / liquids / LiquidDictionary . java 
 @ @ - 0 , 0 + 1 , 57 @ @ 
 + package net . minecraftforge . liquids ; 
 + 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + 
 + / * * 
 + * When creating liquids you should register them with this class . 
 + * 
 + * @ author CovertJaguar < railcraft . wikispaces . com > 
 + * / 
 + public abstract class LiquidDictionary 
 + { 
 + 
 + private static Map < String , LiquidStack > liquids = new HashMap < String , LiquidStack > ( ) ; 
 + 
 + / * * 
 + * When creating liquids you should call this function . 
 + * 
 + * Upon passing it a name and liquid item it will return either 
 + * a preexisting implementation of that liquid or the liquid passed in . 
 + * 
 + * 
 + * @ param name the name of the liquid 
 + * @ param liquid the liquid to use if one doesn ' t exist 
 + * @ return 
 + * / 
 + public static LiquidStack getOrCreateLiquid ( String name , LiquidStack liquid ) 
 + { 
 + LiquidStack existing = liquids . get ( name ) ; 
 + if ( existing ! = null ) { 
 + return existing . copy ( ) ; 
 + } 
 + liquids . put ( name , liquid . copy ( ) ) ; 
 + return liquid ; 
 + } 
 + 
 + / * * 
 + * Returns the liquid matching the name , 
 + * if such a liquid exists . 
 + * 
 + * Can return null . 
 + * 
 + * @ param name the name of the liquid 
 + * @ param amount the amout of liquid 
 + * @ return 
 + * / 
 + public static LiquidStack getLiquid ( String name , int amount ) 
 + { 
 + LiquidStack liquid = liquids . get ( name ) ; 
 + if ( liquid = = null ) 
 + return null ; 
 + 
 + liquid = liquid . copy ( ) ; 
 + liquid . amount = amount ; 
 + return liquid ; 
 + } 
 + } 
 diff - - git a / common / net / minecraftforge / liquids / LiquidManager . java b / common / net / minecraftforge / liquids / LiquidManager . java 
 new file mode 100644 
 index 0000000 . . 1805a50 
 - - - / dev / null 
 + + + b / common / net / minecraftforge / liquids / LiquidManager . java 
 @ @ - 0 , 0 + 1 , 64 @ @ 
 + package net . minecraftforge . liquids ; 
 + 
 + import java . util . LinkedList ; 
 + 
 + import net . minecraft . src . ItemStack ; 
 + 
 + public class LiquidManager { 
 + 	 
 + 	 public static final int BUCKET _ VOLUME = 1000 ; 
 + 	 public static LinkedList < LiquidData > liquids = new LinkedList < LiquidData > ( ) ; 
 + 	 
 + 	 public static LiquidStack getLiquidForFilledItem ( ItemStack filledItem ) { 
 + 	 	 if ( filledItem = = null ) 
 + 	 	 	 return null ; 
 + 
 + 	 	 for ( LiquidData liquid : liquids ) 
 + 	 	 	 if ( liquid . filled . isItemEqual ( filledItem ) ) 
 + 	 	 	 	 return liquid . stillLiquid ; 
 + 
 + 	 	 return null ; 
 + 	 } 
 + 	 
 + 	 public static int getLiquidIDForFilledItem ( ItemStack filledItem ) { 
 + 	 	 LiquidStack liquidForFilledItem = getLiquidForFilledItem ( filledItem ) ; 
 + 	 	 
 + 	 	 if ( liquidForFilledItem = = null ) 
 + 	 	 	 return 0 ; 
 + 	 	 
 + 	 	 return liquidForFilledItem . itemID ; 
 + 	 } 
 + 
 + 	 public static ItemStack getFilledItemForLiquid ( LiquidStack liquid ) { 
 + 	 	 for ( LiquidData data : liquids ) 
 + 	 	 	 if ( data . stillLiquid . isLiquidEqual ( liquid ) ) 
 + 	 	 	 	 return data . filled . copy ( ) ; 
 + 
 + 	 	 return null ; 
 + 	 } 
 + 	 
 + 	 public static ItemStack fillLiquidContainer ( int liquidId , int quantity , ItemStack emptyContainer ) { 
 + 	 	 return fillLiquidContainer ( new LiquidStack ( liquidId , quantity , 0 ) , emptyContainer ) ; 
 + 	 } 
 + 	 
 + 	 public static ItemStack fillLiquidContainer ( LiquidStack liquid , ItemStack emptyContainer ) { 
 + 	 	 for ( LiquidData data : liquids ) 
 + 	 	 	 if ( liquid . containsLiquid ( data . stillLiquid ) 
 + 	 	 	 	 	 & & data . container . isItemEqual ( emptyContainer ) ) 
 + 	 	 	 	 return data . filled . copy ( ) ; 
 + return null ; 
 + 	 } 
 + 
 + 	 public static boolean isLiquid ( ItemStack block ) { 
 + 	 	 if ( block . itemID = = 0 ) 
 + 	 	 	 return false ; 
 + 
 + 	 	 for ( LiquidData liquid : liquids ) 
 + 	 	 	 if ( liquid . stillLiquid . isLiquidEqual ( block ) | | liquid . movingLiquid . isLiquidEqual ( block ) ) 
 + 	 	 	 	 return true ; 
 + 
 + 	 	 return false ; 
 + 	 } 
 + 
 + 
 + } 
 diff - - git a / common / net / minecraftforge / liquids / LiquidStack . java b / common / net / minecraftforge / liquids / LiquidStack . java 
 new file mode 100644 
 index 0000000 . . 08a02c4 
 - - - / dev / null 
 + + + b / common / net / minecraftforge / liquids / LiquidStack . java 
 @ @ - 0 , 0 + 1 , 109 @ @ 
 + package net . minecraftforge . liquids ; 
 + 
 + import net . minecraft . src . Block ; 
 + import net . minecraft . src . Item ; 
 + import net . minecraft . src . ItemStack ; 
 + import net . minecraft . src . NBTTagCompound ; 
 + 
 + / * * 
 + * ItemStack substitute for liquids 
 + * @ author SirSengir 
 + * / 
 + public class LiquidStack { 
 + 	 public int itemID ; 
 + 	 public int amount ; 
 + 	 public int itemMeta ; 
 + 
 + 	 private LiquidStack ( ) { 
 + 	 } 
 + 
 + 	 public LiquidStack ( int itemID , int amount ) { 
 + 	 	 this ( itemID , amount , 0 ) ; 
 + 	 } 
 + 
 + 	 public LiquidStack ( Item item , int amount ) { 
 + 	 	 this ( item . shiftedIndex , amount , 0 ) ; 
 + 	 } 
 + 
 + 	 public LiquidStack ( Block block , int amount ) { 
 + 	 	 this ( block . blockID , amount , 0 ) ; 
 + 	 } 
 + 
 + 	 public LiquidStack ( int itemID , int amount , int itemDamage ) { 
 + 	 	 this . itemID = itemID ; 
 + 	 	 this . amount = amount ; 
 + 	 	 this . itemMeta = itemDamage ; 
 + 	 } 
 + 
 + 	 public NBTTagCompound writeToNBT ( NBTTagCompound nbttagcompound ) { 
 + 	 	 nbttagcompound . setShort ( " Id " , ( short ) itemID ) ; 
 + 	 	 nbttagcompound . setInteger ( " Amount " , amount ) ; 
 + 	 	 nbttagcompound . setShort ( " Meta " , ( short ) itemMeta ) ; 
 + 	 	 return nbttagcompound ; 
 + 	 } 
 + 
 + 	 public void readFromNBT ( NBTTagCompound nbttagcompound ) { 
 + 	 	 itemID = nbttagcompound . getShort ( " Id " ) ; 
 + 	 	 amount = nbttagcompound . getInteger ( " Amount " ) ; 
 + 	 	 itemMeta = nbttagcompound . getShort ( " Meta " ) ; 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * @ return A copy of this LiquidStack 
 + 	 * / 
 + 	 public LiquidStack copy ( ) { 
 + 	 	 return new LiquidStack ( itemID , amount , itemMeta ) ; 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * @ param other 
 + 	 * @ return true if this LiquidStack contains the same liquid as the one passed in . 
 + 	 * / 
 + 	 public boolean isLiquidEqual ( LiquidStack other ) { 
 + 	 	 if ( other = = null ) 
 + 	 	 	 return false ; 
 + 	 	 
 + 	 	 return itemID = = other . itemID & & itemMeta = = other . itemMeta ; 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * @ param other 
 + 	 * @ return true if this LiquidStack contains the other liquid ( liquids are equal and amount > = other . amount ) . 
 + 	 * / 
 + 	 public boolean containsLiquid ( LiquidStack other ) { 
 + 	 	 if ( ! isLiquidEqual ( other ) ) 
 + 	 	 	 return false ; 
 + 	 	 
 + 	 	 return amount > = other . amount ; 
 + 	 } 
 + 	 
 + 	 / * * 
 + 	 * @ param other ItemStack containing liquids . 
 + 	 * @ return true if this LiquidStack contains the same liquid as the one passed in . 
 + 	 * / 
 + 	 public boolean isLiquidEqual ( ItemStack other ) { 
 + 	 	 if ( other = = null ) 
 + 	 	 	 return false ; 
 + 	 	 
 + 	 	 return itemID = = other . itemID & & itemMeta = = other . getItemDamage ( ) ; 
 + 	 } 
 + 	 
 + 	 / * * 
 + 	 * @ return ItemStack representation of this LiquidStack 
 + 	 * / 
 + 	 public ItemStack asItemStack ( ) { 
 + 	 	 return new ItemStack ( itemID , 1 , itemMeta ) ; 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * Reads a liquid stack from the passed nbttagcompound and returns it . 
 + 	 * 
 + 	 * @ param nbttagcompound 
 + 	 * @ return 
 + 	 * / 
 + 	 public static LiquidStack loadLiquidStackFromNBT ( NBTTagCompound nbttagcompound ) { 
 + 	 	 LiquidStack liquidstack = new LiquidStack ( ) ; 
 + 	 	 liquidstack . readFromNBT ( nbttagcompound ) ; 
 + 	 	 return liquidstack . itemID = = 0 ? null : liquidstack ; 
 + 	 } 
 + } 
 diff - - git a / common / net / minecraftforge / liquids / LiquidTank . java b / common / net / minecraftforge / liquids / LiquidTank . java 
 new file mode 100644 
 index 0000000 . . 97e9c4e 
 - - - / dev / null 
 + + + b / common / net / minecraftforge / liquids / LiquidTank . java 
 @ @ - 0 , 0 + 1 , 100 @ @ 
 + package net . minecraftforge . liquids ; 
 + 
 + / * * 
 + * Reference implementation of ILiquidTank . Use this or implement your own . 
 + * / 
 + public class LiquidTank implements ILiquidTank { 
 + 	 private LiquidStack liquid ; 
 + 	 private int capacity ; 
 + 	 
 + 	 public LiquidTank ( int capacity ) { 
 + 	 	 this ( null , capacity ) ; 
 + 	 } 
 + 	 
 + 	 public LiquidTank ( int liquidId , int quantity , int capacity ) { 
 + 	 	 this ( new LiquidStack ( liquidId , quantity ) , capacity ) ; 
 + 	 } 
 + 	 public LiquidTank ( LiquidStack liquid , int capacity ) { 
 + 	 	 this . liquid = liquid ; 
 + 	 	 this . capacity = capacity ; 
 + 	 } 
 + 	 
 + 	 @ Override 
 + 	 public LiquidStack getLiquid ( ) { 
 + 	 	 return this . liquid ; 
 + 	 } 
 + 	 
 + 	 @ Override 
 + 	 public void setLiquid ( LiquidStack liquid ) { 
 + 	 	 this . liquid = liquid ; 
 + 	 } 
 + 	 
 + 	 @ Override 
 + 	 public void setCapacity ( int capacity ) { 
 + 	 	 this . capacity = capacity ; 
 + 	 } 
 + 	 
 + 	 @ Override 
 + 	 public int getCapacity ( ) { 
 + 	 	 return this . capacity ; 
 + 	 } 
 + 	 
 + 	 @ Override 
 + 	 public int fill ( LiquidStack resource , boolean doFill ) { 
 + 	 	 if ( resource = = null | | resource . itemID < = 0 ) 
 + 	 	 	 return 0 ; 
 + 	 	 
 + 	 	 if ( liquid = = null | | liquid . itemID < = 0 ) { 
 + 	 	 	 if ( resource . amount < = capacity ) { 
 + 	 	 	 	 if ( doFill ) 
 + 	 	 	 	 	 this . liquid = resource . copy ( ) ; 
 + 	 	 	 	 return resource . amount ; 
 + 	 	 	 } else { 
 + 	 	 	 	 if ( doFill ) { 
 + 	 	 	 	 	 this . liquid = resource . copy ( ) ; 
 + 	 	 	 	 	 this . liquid . amount = capacity ; 
 + 	 	 	 	 } 
 + 	 	 	 	 return capacity ; 
 + 	 	 	 } 
 + 	 	 } 
 + 	 	 
 + 	 	 if ( ! liquid . isLiquidEqual ( resource ) ) 
 + 	 	 	 return 0 ; 
 + 	 	 
 + 	 	 int space = capacity - liquid . amount ; 
 + 	 	 if ( resource . amount < = space ) { 
 + 	 	 	 if ( doFill ) 
 + 	 	 	 	 this . liquid . amount + = resource . amount ; 
 + 	 	 	 return resource . amount ; 
 + 	 	 } else { 
 + 
 + 	 	 	 if ( doFill ) 
 + 	 	 	 	 this . liquid . amount = capacity ; 
 + 	 	 	 return space ; 
 + 	 	 } 
 + 
 + 	 } 
 + 	 @ Override 
 + 	 public LiquidStack drain ( int maxDrain , boolean doDrain ) { 
 + 	 	 if ( liquid = = null | | liquid . itemID < = 0 ) 
 + 	 	 	 return null ; 
 + 	 	 if ( liquid . amount < = 0 ) 
 + 	 	 	 return null ; 
 + 	 	 
 + 	 	 int used = maxDrain ; 
 + 	 	 if ( liquid . amount < used ) 
 + 	 	 	 used = liquid . amount ; 
 + 	 	 
 + 	 	 if ( doDrain ) { 
 + 	 	 	 liquid . amount - = used ; 
 + 	 	 } 
 + 	 	 
 + 	 	 LiquidStack drained = new LiquidStack ( liquid . itemID , used , liquid . itemMeta ) ; 
 + 	 	 
 + 	 	 / / Reset liquid if emptied 
 + 	 	 if ( liquid . amount < = 0 ) 
 + 	 	 	 liquid = null ; 
 + 	 	 
 + 	 	 return drained ; 
 + 	 } 
 + } 
 diff - - git a / eclipse / Forge - Client / . project b / eclipse / Forge - Client / . project 
 index c182e8a . . a499d09 100644 
 - - - a / eclipse / Forge - Client / . project 
 + + + b / eclipse / Forge - Client / . project 
 @ @ - 78 , 7 + 78 , 7 @ @ 
 	 < variableList > 
 	 	 < variable > 
 	 	 	 < name > MCP _ LOC < / name > 
 - 	 	 	 < value > $ % 7BPARENT - 2 - WORKSPACE _ LOC % 7D < / value > 
 + 	 	 	 < value > $ % 7BPARENT - 3 - PROJECT _ LOC % 7D < / value > 
 	 	 < / variable > 
 	 < / variableList > 
 < / projectDescription >
