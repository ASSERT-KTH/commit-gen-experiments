BLEU SCORE: 0.026549256363457792

TEST MSG: Add class to wrap IItemHandler as IInventory for easier recipe interaction .
GENERATED MSG: Create custom shapeless recipe matching system . Should solve # 4516 damageable items in shapeless recipes .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / extensions / ForgeRecipeManager . java b / src / main / java / net / minecraftforge / common / extensions / ForgeRecipeManager . java <nl> index b4b474a . . 959eace 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / extensions / ForgeRecipeManager . java <nl> + + + b / src / main / java / net / minecraftforge / common / extensions / ForgeRecipeManager . java <nl> @ @ - 28 , 6 + 28 , 7 @ @ import javax . annotation . Nullable ; <nl> import com . google . common . collect . Maps ; <nl> <nl> import net . minecraft . inventory . IInventory ; <nl> + import net . minecraft . inventory . InventoryCrafting ; <nl> import net . minecraft . item . ItemStack ; <nl> import net . minecraft . item . crafting . IRecipe ; <nl> import net . minecraft . resources . IResourceManager ; <nl> @ @ - 36 , 24 + 37 , 42 @ @ import net . minecraft . util . NonNullList ; <nl> import net . minecraft . world . World ; <nl> import net . minecraftforge . common . crafting . CraftingHelper ; <nl> import net . minecraftforge . common . crafting . RecipeType ; <nl> + import net . minecraftforge . items . wrapper . RecipeWrapper ; <nl> <nl> @ SuppressWarnings ( " deprecation " ) <nl> public abstract class ForgeRecipeManager implements IResourceManagerReloadListener <nl> { <nl> + / * * <nl> + * Master list of sorted recipes . <nl> + * / <nl> protected final Map < RecipeType < ? extends IRecipe > , List < ? extends IRecipe > > sortedRecipes = Maps . newHashMap ( ) ; <nl> <nl> @ Override <nl> - public void onResourceManagerReload ( IResourceManager resourceManager ) { <nl> + public void onResourceManagerReload ( IResourceManager resourceManager ) <nl> + { <nl> this . sortedRecipes . clear ( ) ; <nl> CraftingHelper . reloadConstants ( resourceManager ) ; <nl> } <nl> <nl> + / * * <nl> + * Returns all the recipes that match this type . <nl> + * @ param type A recipe type . <nl> + * @ return All recipes that are of the passed type . This list may be empty . <nl> + * / <nl> @ SuppressWarnings ( " unchecked " ) <nl> public < T extends IRecipe > List < T > getRecipes ( RecipeType < T > type ) <nl> { <nl> return ( List < T > ) this . sortedRecipes . computeIfAbsent ( type , t - > new ArrayList < > ( ) ) ; <nl> } <nl> <nl> + / * * <nl> + * Automatically returns a result from the first recipe that matches this inv and type . <nl> + * Modders should probably not use this , and instead use { @ link # getRecipe ( IInventory , World , RecipeType ) } since you get the recipe object itself . <nl> + * @ param input An inventory . <nl> + * @ param world The world . <nl> + * @ param type The type of recipe to match against . <nl> + * @ return The output of the first matching recipe , or { @ link ItemStack # EMPTY } if no recipes match . <nl> + * / <nl> public ItemStack getResult ( IInventory input , World world , RecipeType < ? > type ) <nl> { <nl> for ( IRecipe irecipe : getRecipes ( type ) ) <nl> @ @ - 61 , 7 + 80 , 16 @ @ public abstract class ForgeRecipeManager implements IResourceManagerReloadListen <nl> return ItemStack . EMPTY ; <nl> } <nl> <nl> - 	 @ Nullable <nl> + / * * <nl> + * Used to find a matching recipe for the given inv , world , and type . <nl> + * Since this requires an IInventory , modders can use { @ link RecipeWrapper } to avoid direct implementation . <nl> + * For crafting recipes , it is advised to still use { @ link InventoryCrafting } . The dynamic vanilla recipes require they be crafted in one . <nl> + * @ param input An inventory . <nl> + * @ param world The world . <nl> + * @ param type The type of recipe to match against . <nl> + * @ return The first matching recipe . <nl> + * / <nl> + @ Nullable <nl> public < T extends IRecipe > T getRecipe ( IInventory input , World world , RecipeType < T > type ) <nl> { <nl> for ( T irecipe : getRecipes ( type ) ) <nl> @ @ - 71 , 7 + 99 , 9 @ @ public abstract class ForgeRecipeManager implements IResourceManagerReloadListen <nl> <nl> / * * <nl> * Modders should not use this if possible . In the context that this is used , you should already have the recipe . Do not run extra lookups using this method . <nl> + * Use { @ link IRecipe # getRemainingItems ( IInventory ) } . <nl> * / <nl> + @ Deprecated <nl> public NonNullList < ItemStack > getRemainingItems ( IInventory input , World world , RecipeType < ? > type ) <nl> { <nl> for ( IRecipe irecipe : getRecipes ( type ) ) <nl> diff - - git a / src / main / java / net / minecraftforge / common / extensions / IForgeRecipe . java b / src / main / java / net / minecraftforge / common / extensions / IForgeRecipe . java <nl> index b36aed2 . . 7bcdbdf 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / extensions / IForgeRecipe . java <nl> + + + b / src / main / java / net / minecraftforge / common / extensions / IForgeRecipe . java <nl> @ @ - 19 , 8 + 19 , 6 @ @ <nl> <nl> package net . minecraftforge . common . extensions ; <nl> <nl> - import java . util . Collection ; <nl> - <nl> import net . minecraft . item . crafting . IRecipe ; <nl> import net . minecraftforge . common . crafting . RecipeType ; <nl> import net . minecraftforge . common . crafting . VanillaRecipeTypes ; <nl> @ @ - 28 , 7 + 26 , 7 @ @ import net . minecraftforge . common . crafting . VanillaRecipeTypes ; <nl> public interface IForgeRecipe { <nl> <nl> / * * <nl> - * Used when sorting this recipe into it ' s category during load , and in the default type matcher below . <nl> + * Used when sorting this recipe into it ' s category during load . This type determines what class the recipe must subclass . <nl> * @ return The type of this recipe . <nl> * / <nl> default RecipeType < ? extends IRecipe > getType ( ) <nl> diff - - git a / src / main / java / net / minecraftforge / items / wrapper / RecipeWrapper . java b / src / main / java / net / minecraftforge / items / wrapper / RecipeWrapper . java <nl> new file mode 100644 <nl> index 0000000 . . 64f60ea <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / items / wrapper / RecipeWrapper . java <nl> @ @ - 0 , 0 + 1 , 157 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 - 2019 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + <nl> + package net . minecraftforge . items . wrapper ; <nl> + <nl> + import net . minecraft . entity . player . EntityPlayer ; <nl> + import net . minecraft . inventory . IInventory ; <nl> + import net . minecraft . item . ItemStack ; <nl> + import net . minecraft . util . text . ITextComponent ; <nl> + import net . minecraftforge . items . IItemHandlerModifiable ; <nl> + <nl> + public class RecipeWrapper implements IInventory { <nl> + <nl> + protected final IItemHandlerModifiable inv ; <nl> + protected final int width ; <nl> + protected final int height ; <nl> + <nl> + public RecipeWrapper ( IItemHandlerModifiable inv , int width , int height ) <nl> + { <nl> + this . inv = inv ; <nl> + this . width = width ; <nl> + this . height = height ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the size of this inventory . Must be equivalent to { @ link # getHeight ( ) } * { @ link # getWidth ( ) } . <nl> + * / <nl> + @ Override <nl> + public int getSizeInventory ( ) <nl> + { <nl> + return getHeight ( ) * getWidth ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the stack in this slot . This stack should be a modifiable reference , not a copy of a stack in your inventory . <nl> + * / <nl> + @ Override <nl> + public ItemStack getStackInSlot ( int slot ) <nl> + { <nl> + return inv . getStackInSlot ( slot ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Attempts to remove n items from the specified slot . Returns the split stack that was removed . Modifies the inventory . <nl> + * / <nl> + @ Override <nl> + public ItemStack decrStackSize ( int slot , int count ) <nl> + { <nl> + ItemStack stack = inv . getStackInSlot ( slot ) ; <nl> + return stack . isEmpty ( ) ? ItemStack . EMPTY : stack . split ( count ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Sets the contents of this slot to the provided stack . <nl> + * / <nl> + @ Override <nl> + public void setInventorySlotContents ( int slot , ItemStack stack ) <nl> + { <nl> + inv . setStackInSlot ( slot , stack ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the height of this inventory . <nl> + * / <nl> + @ Override <nl> + public int getHeight ( ) <nl> + { <nl> + return height ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the width of this inventory . <nl> + * / <nl> + @ Override <nl> + public int getWidth ( ) <nl> + { <nl> + return width ; <nl> + } <nl> + <nl> + / * * <nl> + * Removes the stack contained in this slot from the underlying handler , and returns it . <nl> + * / <nl> + @ Override <nl> + public ItemStack removeStackFromSlot ( int index ) <nl> + { <nl> + ItemStack s = getStackInSlot ( index ) ; <nl> + if ( s . isEmpty ( ) ) return ItemStack . EMPTY ; <nl> + setInventorySlotContents ( index , ItemStack . EMPTY ) ; <nl> + return s ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isEmpty ( ) <nl> + { <nl> + for ( int i = 0 ; i < inv . getSlots ( ) ; i + + ) <nl> + { <nl> + if ( ! inv . getStackInSlot ( i ) . isEmpty ( ) ) return false ; <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isItemValidForSlot ( int slot , ItemStack stack ) <nl> + { <nl> + return inv . isItemValid ( slot , stack ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void clear ( ) <nl> + { <nl> + for ( int i = 0 ; i < inv . getSlots ( ) ; i + + ) <nl> + { <nl> + inv . setStackInSlot ( i , ItemStack . EMPTY ) ; <nl> + } <nl> + } <nl> + <nl> + / / The following methods are never used by vanilla in crafting . They are defunct as mods need not override them . <nl> + @ Override <nl> + public int getInventoryStackLimit ( ) { return 0 ; } <nl> + @ Override <nl> + public void markDirty ( ) { } <nl> + @ Override <nl> + public boolean isUsableByPlayer ( EntityPlayer player ) { return false ; } <nl> + @ Override <nl> + public void openInventory ( EntityPlayer player ) { } <nl> + @ Override <nl> + public void closeInventory ( EntityPlayer player ) { } <nl> + @ Override <nl> + public int getField ( int id ) { return 0 ; } <nl> + @ Override <nl> + public void setField ( int id , int value ) { } <nl> + @ Override <nl> + public int getFieldCount ( ) { return 0 ; } <nl> + @ Override <nl> + public ITextComponent getName ( ) { return null ; } <nl> + @ Override <nl> + public boolean hasCustomName ( ) { return false ; } <nl> + @ Override <nl> + public ITextComponent getCustomName ( ) { return null ; } <nl> + <nl> + }
NEAREST DIFF (one line): diff - - git a / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch b / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch <nl> index 697a870 . . f9d344f 100644 <nl> - - - a / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch <nl> + + + b / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch <nl> @ @ - 1 , 6 + 1 , 11 @ @ <nl> - - - . . / src - base / minecraft / net / minecraft / item / crafting / Ingredient . java <nl> + + + . . / src - work / minecraft / net / minecraft / item / crafting / Ingredient . java <nl> - @ @ - 13 , 6 + 13 , 8 @ @ <nl> + @ @ - 8 , 11 + 8 , 11 @ @ <nl> + import net . minecraft . client . util . RecipeItemHelper ; <nl> + import net . minecraft . item . Item ; <nl> + import net . minecraft . item . ItemStack ; <nl> + - import net . minecraftforge . fml . relauncher . Side ; <nl> + - import net . minecraftforge . fml . relauncher . SideOnly ; <nl> <nl> public class Ingredient implements Predicate < ItemStack > <nl> { <nl> @ @ - 9 , 12 + 14 , 13 @ @ <nl> public static final Ingredient field _ 193370 _ a = new Ingredient ( new ItemStack [ 0 ] ) <nl> { <nl> public boolean apply ( @ Nullable ItemStack p _ apply _ 1 _ ) <nl> - @ @ - 21 , 17 + 23 , 34 @ @ <nl> + @ @ - 21 , 17 + 21 , 41 @ @ <nl> } <nl> } ; <nl> private final ItemStack [ ] field _ 193371 _ b ; <nl> + private final ItemStack [ ] matchingStacksExploded ; <nl> private IntList field _ 194140 _ c ; <nl> + + private final boolean isSimple ; <nl> <nl> + protected Ingredient ( int size ) <nl> + { <nl> @ @ - 23 , 6 + 29 , 7 @ @ <nl> + <nl> protected Ingredient ( ItemStack . . . p _ i47503 _ 1 _ ) <nl> { <nl> + + boolean simple = true ; <nl> this . field _ 193371 _ b = p _ i47503 _ 1 _ ; <nl> + net . minecraft . util . NonNullList < ItemStack > lst = net . minecraft . util . NonNullList . func _ 191196 _ a ( ) ; <nl> + for ( ItemStack s : p _ i47503 _ 1 _ ) <nl> @ @ - 30 , 11 + 37 , 16 @ @ <nl> + if ( s . func _ 190926 _ b ( ) ) <nl> + continue ; <nl> + if ( s . func _ 77960 _ j ( ) = = net . minecraftforge . oredict . OreDictionary . WILDCARD _ VALUE ) <nl> + + { <nl> + + if ( s . func _ 77973 _ b ( ) . func _ 77645 _ m ( ) ) <nl> + + simple = false ; <nl> + s . func _ 77973 _ b ( ) . func _ 150895 _ a ( net . minecraft . creativetab . CreativeTabs . field _ 78027 _ g , lst ) ; <nl> + + } <nl> + else <nl> + lst . add ( s ) ; <nl> + } <nl> + this . matchingStacksExploded = lst . toArray ( new ItemStack [ lst . size ( ) ] ) ; <nl> + + this . isSimple = simple & & this . matchingStacksExploded . length > 0 ; <nl> + Ingredient . INSTANCES . add ( this ) ; <nl> } <nl> <nl> @ @ - 46 , 7 + 58 , 7 @ @ <nl> } <nl> <nl> public boolean apply ( @ Nullable ItemStack p _ apply _ 1 _ ) <nl> - @ @ - 63 , 9 + 82 , 9 @ @ <nl> + @ @ - 63 , 9 + 87 , 9 @ @ <nl> { <nl> if ( this . field _ 194140 _ c = = null ) <nl> { <nl> @ @ - 58 , 7 + 70 , 7 @ @ <nl> { <nl> this . field _ 194140 _ c . add ( RecipeItemHelper . func _ 194113 _ b ( itemstack ) ) ; <nl> } <nl> - @ @ - 76 , 6 + 95 , 18 @ @ <nl> + @ @ - 76 , 6 + 100 , 18 @ @ <nl> return this . field _ 194140 _ c ; <nl> } <nl> <nl> @ @ - 77 , 7 + 89 , 7 @ @ <nl> public static Ingredient func _ 193367 _ a ( Item p _ 193367 _ 0 _ ) <nl> { <nl> return func _ 193369 _ a ( new ItemStack ( p _ 193367 _ 0 _ , 1 , 32767 ) ) ; <nl> - @ @ - 108 , 4 + 139 , 17 @ @ <nl> + @ @ - 108 , 4 + 144 , 22 @ @ <nl> <nl> return field _ 193370 _ a ; <nl> } <nl> @ @ - 94 , 4 + 106 , 9 @ @ <nl> + } <nl> + return new Ingredient ( lst . toArray ( new ItemStack [ lst . size ( ) ] ) ) ; <nl> + } <nl> + + <nl> + + public boolean isSimple ( ) <nl> + + { <nl> + + return isSimple | | this = = field _ 193370 _ a ; <nl> + + } <nl> } <nl> diff - - git a / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch b / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch <nl> index df082d0 . . 34e6831 100644 <nl> - - - a / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch <nl> + + + b / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch <nl> @ @ - 1 , 6 + 1 , 6 @ @ <nl> - - - . . / src - base / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java <nl> + + + . . / src - work / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java <nl> - @ @ - 10 , 10 + 10 , 8 @ @ <nl> + @ @ - 10 , 23 + 10 , 25 @ @ <nl> import net . minecraft . util . JsonUtils ; <nl> import net . minecraft . util . NonNullList ; <nl> import net . minecraft . world . World ; <nl> @ @ - 12 , 15 + 12 , 25 @ @ <nl> { <nl> private final ItemStack field _ 77580 _ a ; <nl> public final NonNullList < Ingredient > field _ 77579 _ b ; <nl> - @ @ - 26 , 7 + 24 , 6 @ @ <nl> + private final String field _ 194138 _ c ; <nl> + + private final boolean isSimple ; <nl> + <nl> + public ShapelessRecipes ( String p _ i47500 _ 1 _ , ItemStack p _ i47500 _ 2 _ , NonNullList < Ingredient > p _ i47500 _ 3 _ ) <nl> + { <nl> + this . field _ 194138 _ c = p _ i47500 _ 1 _ ; <nl> + this . field _ 77580 _ a = p _ i47500 _ 2 _ ; <nl> this . field _ 77579 _ b = p _ i47500 _ 3 _ ; <nl> + + boolean simple = true ; <nl> + + for ( Ingredient i : p _ i47500 _ 3 _ ) <nl> + + simple & = i . isSimple ( ) ; <nl> + + this . isSimple = simple ; <nl> } <nl> <nl> - @ SideOnly ( Side . CLIENT ) <nl> public String func _ 193358 _ e ( ) <nl> { <nl> return this . field _ 194138 _ c ; <nl> - @ @ - 50 , 10 + 47 , 7 @ @ <nl> + @ @ - 50 , 10 + 52 , 7 @ @ <nl> { <nl> ItemStack itemstack = p _ 179532 _ 1 _ . func _ 70301 _ a ( i ) ; <nl> <nl> @ @ - 32 , 17 + 42 , 18 @ @ <nl> } <nl> <nl> return nonnulllist ; <nl> - @ @ - 61 , 7 + 55 , 8 @ @ <nl> + @ @ - 61 , 7 + 60 , 9 @ @ <nl> <nl> public boolean func _ 77569 _ a ( InventoryCrafting p _ 77569 _ 1 _ , World p _ 77569 _ 2 _ ) <nl> { <nl> - List < Ingredient > list = Lists . newArrayList ( this . field _ 77579 _ b ) ; <nl> + int ingredientCount = 0 ; <nl> + net . minecraft . client . util . RecipeItemHelper recipeItemHelper = new net . minecraft . client . util . RecipeItemHelper ( ) ; <nl> + + List < ItemStack > inputs = Lists . newArrayList ( ) ; <nl> <nl> for ( int i = 0 ; i < p _ 77569 _ 1 _ . func _ 174923 _ h ( ) ; + + i ) <nl> { <nl> - @ @ - 71 , 27 + 66 , 13 @ @ <nl> + @ @ - 71 , 27 + 72 , 22 @ @ <nl> <nl> if ( ! itemstack . func _ 190926 _ b ( ) ) <nl> { <nl> @ @ - 63 , 17 + 74 , 26 @ @ <nl> - return false ; <nl> - } <nl> + + + ingredientCount ; <nl> - + recipeItemHelper . func _ 194112 _ a ( itemstack ) ; <nl> + + if ( this . isSimple ) <nl> + + recipeItemHelper . func _ 194112 _ a ( itemstack ) ; <nl> + + else <nl> + + inputs . add ( itemstack ) ; <nl> } <nl> } <nl> } <nl> <nl> - return list . isEmpty ( ) ; <nl> - + return ingredientCount = = this . field _ 77579 _ b . size ( ) & & recipeItemHelper . func _ 194116 _ a ( this , null ) ; <nl> + + if ( ingredientCount ! = this . field _ 77579 _ b . size ( ) ) <nl> + + return false ; <nl> + + <nl> + + if ( this . isSimple ) <nl> + + return recipeItemHelper . func _ 194116 _ a ( this , null ) ; <nl> + + <nl> + + return net . minecraftforge . common . util . RecipeMatcher . findMatches ( inputs , this . field _ 77579 _ b ) ! = null ; <nl> } <nl> <nl> public ItemStack func _ 77572 _ b ( InventoryCrafting p _ 77572 _ 1 _ ) <nl> - @ @ - 136 , 7 + 117 , 6 @ @ <nl> + @ @ - 136 , 7 + 132 , 6 @ @ <nl> return nonnulllist ; <nl> } <nl> <nl> diff - - git a / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java b / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java <nl> index 32a2c02 . . 60909dd 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java <nl> + + + b / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java <nl> @ @ - 20 , 11 + 20 , 17 @ @ public class CompoundIngredient extends Ingredient <nl> private Collection < Ingredient > children ; <nl> private ItemStack [ ] stacks ; <nl> private IntList itemIds ; <nl> + private final boolean isSimple ; <nl> <nl> protected CompoundIngredient ( Collection < Ingredient > children ) <nl> { <nl> super ( 0 ) ; <nl> this . children = children ; <nl> + <nl> + boolean simple = true ; <nl> + for ( Ingredient child : children ) <nl> + simple & = child . isSimple ( ) ; <nl> + this . isSimple = simple ; <nl> } <nl> <nl> @ Override <nl> @ @ - 78 , 4 + 84 , 10 @ @ public class CompoundIngredient extends Ingredient <nl> this . stacks = null ; <nl> / / Shouldn ' t need to invalidate children as this is only called form invalidateAll . . <nl> } <nl> + <nl> + @ Override <nl> + public boolean isSimple ( ) <nl> + { <nl> + return isSimple ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java b / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java <nl> index 3f7c31e . . 9a85682 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java <nl> + + + b / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java <nl> @ @ - 40 , 4 + 40 , 10 @ @ public class IngredientNBT extends Ingredient <nl> / / Can ' t use areItemStacksEqualUsingNBTShareTag because it compares stack size as well <nl> return this . stack . getItem ( ) = = input . getItem ( ) & & this . stack . getItemDamage ( ) = = input . getItemDamage ( ) & & ItemStack . areItemStackShareTagsEqual ( this . stack , input ) ; <nl> } <nl> + <nl> + @ Override <nl> + public boolean isSimple ( ) <nl> + { <nl> + return false ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java b / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java <nl> new file mode 100644 <nl> index 0000000 . . c8549ff <nl> - - - / dev / null <nl> + + + b / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java <nl> @ @ - 0 , 0 + 1 , 162 @ @ <nl> + / * <nl> + * Minecraft Forge <nl> + * Copyright ( c ) 2016 . <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation version 2 . 1 <nl> + * of the License . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * <nl> + * You should have received a copy of the GNU Lesser General Public <nl> + * License along with this library ; if not , write to the Free Software <nl> + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA <nl> + * / <nl> + package net . minecraftforge . common . util ; <nl> + <nl> + import java . util . BitSet ; <nl> + import java . util . LinkedList ; <nl> + import java . util . List ; <nl> + import java . util . Queue ; <nl> + <nl> + import com . google . common . base . Predicate ; <nl> + <nl> + public class RecipeMatcher <nl> + { <nl> + / * * <nl> + * Attempts to match inputs to the specified tests . In the best way that all inputs are used by one test . <nl> + * Will return null in any of these cases : <nl> + * input / test lengths don ' t match . This is only for matching paired outputs . <nl> + * any input doesn ' t match a test <nl> + * any test doesn ' t match a input <nl> + * If we are unable to determine a proper pair <nl> + * <nl> + * @ return An array mapping inputs to tests . ret [ x ] = y means input [ x ] = test [ y ] <nl> + * / <nl> + public static < T > int [ ] findMatches ( List < T > inputs , List < ? extends Predicate < T > > tests ) <nl> + { <nl> + int elements = inputs . size ( ) ; <nl> + if ( elements ! = tests . size ( ) ) <nl> + return null ; / / There will not be a 1 : 1 mapping of inputs - > tests <nl> + <nl> + int [ ] ret = new int [ elements ] ; <nl> + for ( int x = 0 ; x < elements ; x + + ) <nl> + ret [ x ] = - 1 ; <nl> + <nl> + / / [ UnusedInputs ] [ UnusedIngredients ] [ IngredientMatchMask ] . . . <nl> + BitSet data = new BitSet ( ( elements + 2 ) * elements ) ; <nl> + for ( int x = 0 ; x < elements ; x + + ) <nl> + { <nl> + int matched = 0 ; <nl> + int offset = ( x + 2 ) * elements ; <nl> + Predicate < T > test = tests . get ( x ) ; <nl> + <nl> + for ( int y = 0 ; y < elements ; y + + ) <nl> + { <nl> + if ( data . get ( y ) ) <nl> + continue ; <nl> + <nl> + if ( test . apply ( inputs . get ( y ) ) ) <nl> + { <nl> + data . set ( offset + y ) ; <nl> + matched + + ; <nl> + } <nl> + } <nl> + <nl> + if ( matched = = 0 ) <nl> + return null ; / / We have an test that matched non of the inputs <nl> + <nl> + if ( matched = = 1 ) <nl> + { <nl> + if ( ! claim ( ret , data , x , elements ) ) <nl> + return null ; / / We failed to claim this index , which means it caused something else to go to 0 matches , which makes the whole thing fail <nl> + } <nl> + } <nl> + <nl> + if ( data . nextClearBit ( 0 ) > = elements ) / / All items have been used , which means all tests have a match ! <nl> + return ret ; <nl> + <nl> + / / We should be in a state where multiple tests are satified by multiple inputs . So we need to try a branching recursive test . <nl> + / / However for performance reasons , we should probably make that check a sub - set of the entire graph . <nl> + if ( backtrack ( data , ret , 0 , elements ) ) <nl> + return ret ; <nl> + <nl> + return null ; / / Backtrack failed , no matches , we cry and go home now : ( <nl> + } <nl> + <nl> + / / This is bad . . . need to think of a better cascade , recursion instead of stack ? <nl> + private static boolean claim ( int [ ] ret , BitSet data , int claimed , int elements ) <nl> + { <nl> + Queue < Integer > pending = new LinkedList < Integer > ( ) ; <nl> + pending . add ( claimed ) ; <nl> + <nl> + while ( pending . peek ( ) ! = null ) <nl> + { <nl> + int test = pending . poll ( ) ; <nl> + int offset = ( test + 2 ) * elements ; <nl> + int used = data . nextSetBit ( offset ) - offset ; <nl> + <nl> + if ( used > = elements | | used < 0 ) <nl> + throw new IllegalStateException ( " What ? We matched something , but it wasn ' t set in the range of this test ! Test : " + test + " Used : " + used ) ; <nl> + <nl> + data . set ( used ) ; <nl> + data . set ( elements + test ) ; <nl> + ret [ used ] = test ; <nl> + <nl> + for ( int x = 0 ; x < elements ; x + + ) <nl> + { <nl> + offset = ( x + 2 ) * elements ; <nl> + if ( data . get ( offset + used ) & & ! data . get ( elements + x ) ) <nl> + { <nl> + data . clear ( offset + used ) ; <nl> + int count = 0 ; <nl> + for ( int y = offset ; y < offset + elements ; y + + ) <nl> + if ( data . get ( y ) ) <nl> + count + + ; <nl> + <nl> + if ( count = = 0 ) <nl> + return false ; / / Claiming this caused another test to lose its last match . . <nl> + <nl> + if ( count = = 1 ) <nl> + pending . add ( x ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + / / We use recursion here , why ? Because I feel like it . Also because we should only ever be working in data sets < 9 <nl> + private static boolean backtrack ( BitSet data , int [ ] ret , int start , int elements ) <nl> + { <nl> + int test = data . nextClearBit ( elements + start ) - elements ; <nl> + if ( test > = elements ) <nl> + return true ; / / Could not find the next unused test . <nl> + <nl> + if ( test < 0 ) <nl> + throw new IllegalStateException ( " This should never happen , negative test in backtrack ! " ) ; <nl> + <nl> + int offset = ( test + 2 ) * elements ; <nl> + for ( int x = 0 ; x < elements ; x + + ) <nl> + { <nl> + if ( ! data . get ( offset + x ) | | data . get ( x ) ) <nl> + continue ; <nl> + <nl> + data . set ( x ) ; <nl> + <nl> + if ( backtrack ( data , ret , test + 1 , elements ) ) <nl> + { <nl> + ret [ x ] = test ; <nl> + return true ; <nl> + } <nl> + <nl> + data . clear ( x ) ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + } <nl> diff - - git a / src / main / java / net / minecraftforge / oredict / OreIngredient . java b / src / main / java / net / minecraftforge / oredict / OreIngredient . java <nl> index 11ae517 . . 9a017b9 100644 <nl> - - - a / src / main / java / net / minecraftforge / oredict / OreIngredient . java <nl> + + + b / src / main / java / net / minecraftforge / oredict / OreIngredient . java <nl> @ @ - 114 , 4 + 114 , 10 @ @ public class OreIngredient extends Ingredient <nl> this . itemIds = null ; <nl> this . array = null ; <nl> } <nl> + <nl> + @ Override <nl> + public boolean isSimple ( ) <nl> + { <nl> + return true ; <nl> + } <nl> } <nl> diff - - git a / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java b / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java <nl> index 56d9485 . . db07357 100644 <nl> - - - a / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java <nl> + + + b / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java <nl> @ @ - 33 , 6 + 33 , 7 @ @ import net . minecraft . util . ResourceLocation ; <nl> import net . minecraft . world . World ; <nl> import net . minecraftforge . common . crafting . CraftingHelper ; <nl> import net . minecraftforge . common . crafting . JsonContext ; <nl> + import net . minecraftforge . common . util . RecipeMatcher ; <nl> import net . minecraftforge . registries . IForgeRegistryEntry ; <nl> <nl> import javax . annotation . Nonnull ; <nl> @ @ - 48 , 6 + 49 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> protected ItemStack output = ItemStack . EMPTY ; <nl> protected NonNullList < Ingredient > input = NonNullList . create ( ) ; <nl> protected ResourceLocation group ; <nl> + protected boolean isSimple = true ; <nl> <nl> public ShapelessOreRecipe ( ResourceLocation group , Block result , Object . . . recipe ) { this ( group , new ItemStack ( result ) , recipe ) ; } <nl> public ShapelessOreRecipe ( ResourceLocation group , Item result , Object . . . recipe ) { this ( group , new ItemStack ( result ) , recipe ) ; } <nl> @ @ - 56 , 6 + 58 , 8 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> this . group = group ; <nl> output = result . copy ( ) ; <nl> this . input = input ; <nl> + for ( Ingredient i : input ) <nl> + this . isSimple & = i . isSimple ( ) ; <nl> } <nl> public ShapelessOreRecipe ( ResourceLocation group , @ Nonnull ItemStack result , Object . . . recipe ) <nl> { <nl> @ @ - 67 , 6 + 71 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> if ( ing ! = null ) <nl> { <nl> input . add ( ing ) ; <nl> + this . isSimple & = ing . isSimple ( ) ; <nl> } <nl> else <nl> { <nl> @ @ - 94 , 6 + 99 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> { <nl> int ingredientCount = 0 ; <nl> RecipeItemHelper recipeItemHelper = new RecipeItemHelper ( ) ; <nl> + List < ItemStack > items = Lists . newArrayList ( ) ; <nl> <nl> for ( int i = 0 ; i < inv . getSizeInventory ( ) ; + + i ) <nl> { <nl> @ @ - 101 , 11 + 107 , 20 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem <nl> if ( ! itemstack . isEmpty ( ) ) <nl> { <nl> + + ingredientCount ; <nl> - recipeItemHelper . accountStack ( itemstack ) ; <nl> + if ( this . isSimple ) <nl> + recipeItemHelper . accountStack ( itemstack ) ; <nl> + else <nl> + items . add ( itemstack ) ; <nl> } <nl> } <nl> <nl> - return ingredientCount = = this . input . size ( ) & & recipeItemHelper . canCraft ( this , null ) ; <nl> + if ( ingredientCount ! = this . input . size ( ) ) <nl> + return false ; <nl> + <nl> + if ( this . isSimple ) <nl> + return recipeItemHelper . canCraft ( this , null ) ; <nl> + <nl> + return RecipeMatcher . findMatches ( items , this . input ) ! = null ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / test / java / net / minecraftforge / debug / RecipeTestMod . java b / src / test / java / net / minecraftforge / debug / RecipeTestMod . java <nl> index cc9c48c . . df3e1b8 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / RecipeTestMod . java <nl> + + + b / src / test / java / net / minecraftforge / debug / RecipeTestMod . java <nl> @ @ - 1 , 44 + 1 , 108 @ @ <nl> package net . minecraftforge . debug ; <nl> <nl> + import java . util . Random ; <nl> + <nl> + import net . minecraft . client . renderer . block . model . ModelResourceLocation ; <nl> + import net . minecraft . creativetab . CreativeTabs ; <nl> import net . minecraft . init . Blocks ; <nl> + import net . minecraft . item . Item ; <nl> import net . minecraft . item . ItemStack ; <nl> import net . minecraft . item . crafting . IRecipe ; <nl> import net . minecraft . item . crafting . ShapedRecipes ; <nl> + import net . minecraft . util . EnumActionResult ; <nl> import net . minecraft . util . ResourceLocation ; <nl> + import net . minecraftforge . client . model . ModelLoader ; <nl> import net . minecraftforge . common . MinecraftForge ; <nl> import net . minecraftforge . common . crafting . CraftingHelper ; <nl> + import net . minecraftforge . debug . OnItemUseFirstTest . CommonProxy ; <nl> + import net . minecraftforge . debug . OnItemUseFirstTest . ItemTest ; <nl> import net . minecraftforge . event . RegistryEvent ; <nl> import net . minecraftforge . fml . common . Mod ; <nl> + import net . minecraftforge . fml . common . SidedProxy ; <nl> import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; <nl> import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; <nl> + import net . minecraftforge . fml . common . registry . GameRegistry . ObjectHolder ; <nl> import net . minecraftforge . fml . relauncher . FMLLaunchHandler ; <nl> import net . minecraftforge . fml . relauncher . Side ; <nl> import net . minecraftforge . oredict . ShapedOreRecipe ; <nl> <nl> - @ Mod ( modid = " recipetest " , name = " Recipe test mod " , version = " 1 . 0 " , acceptableRemoteVersions = " * " ) <nl> + @ Mod ( modid = RecipeTestMod . MODID , name = " Recipe test mod " , version = " 1 . 0 " , acceptableRemoteVersions = " * " ) <nl> public class RecipeTestMod <nl> { <nl> + public static final String MODID = " recipetest " ; <nl> + private static final boolean ENABLED = true ; <nl> + @ SidedProxy <nl> + public static CommonProxy proxy = null ; <nl> + <nl> + <nl> @ Mod . EventHandler <nl> public void preinit ( FMLPreInitializationEvent event ) <nl> { <nl> - MinecraftForge . EVENT _ BUS . register ( this ) ; <nl> + if ( ENABLED ) <nl> + MinecraftForge . EVENT _ BUS . register ( this ) ; <nl> } <nl> <nl> @ SubscribeEvent <nl> public void registerRecipes ( RegistryEvent . Register < IRecipe > event ) <nl> { <nl> - ResourceLocation location1 = new ResourceLocation ( " recipetest " , " dirt " ) ; <nl> + ResourceLocation location1 = new ResourceLocation ( MODID , " dirt " ) ; <nl> ShapedOreRecipe recipe1 = new ShapedOreRecipe ( location1 , new ItemStack ( Blocks . DIAMOND _ BLOCK ) , " DDD " , ' D ' , new ItemStack ( Blocks . DIRT ) ) ; <nl> recipe1 . setRegistryName ( location1 ) ; <nl> event . getRegistry ( ) . register ( recipe1 ) ; <nl> <nl> if ( FMLLaunchHandler . side ( ) = = Side . SERVER ) <nl> { <nl> - ResourceLocation location2 = new ResourceLocation ( " recipetest " , " stone " ) ; <nl> + ResourceLocation location2 = new ResourceLocation ( MODID , " stone " ) ; <nl> CraftingHelper . ShapedPrimer primer1 = CraftingHelper . parseShaped ( " SSS " , ' S ' , new ItemStack ( Blocks . IRON _ BLOCK ) ) ; <nl> ShapedRecipes recipe2 = new ShapedRecipes ( location2 . getResourcePath ( ) , primer1 . width , primer1 . height , primer1 . input , new ItemStack ( Blocks . GOLD _ BLOCK ) ) ; <nl> recipe2 . setRegistryName ( location2 ) ; <nl> event . getRegistry ( ) . register ( recipe2 ) ; <nl> } <nl> } <nl> + <nl> + @ SubscribeEvent <nl> + public void registerItems ( RegistryEvent . Register < Item > event ) <nl> + { <nl> + proxy . registerItem ( event ) ; <nl> + } <nl> + <nl> + public static abstract class CommonProxy <nl> + { <nl> + protected Item TOOL ; <nl> + public void registerItem ( RegistryEvent . Register < Item > event ) <nl> + { <nl> + TOOL = new Item ( ) <nl> + { <nl> + Random RAND = new Random ( ) ; <nl> + @ Override <nl> + public ItemStack getContainerItem ( ItemStack in ) <nl> + { <nl> + ItemStack ret = in . copy ( ) ; <nl> + ret . attemptDamageItem ( 1 , RAND , null ) ; <nl> + return ret ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasContainerItem ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + } . setRegistryName ( MODID , " tool " ) . setMaxDamage ( 10 ) . setCreativeTab ( CreativeTabs . MISC ) . setUnlocalizedName ( " recipetest . tool " ) . setMaxStackSize ( 1 ) ; <nl> + event . getRegistry ( ) . register ( TOOL ) ; <nl> + } <nl> + } <nl> + <nl> + public static final class ServerProxy extends CommonProxy <nl> + { <nl> + } <nl> + <nl> + public static final class ClientProxy extends CommonProxy <nl> + { <nl> + @ Override <nl> + public void registerItem ( RegistryEvent . Register < Item > event ) <nl> + { <nl> + super . registerItem ( event ) ; <nl> + ModelLoader . setCustomModelResourceLocation ( TOOL , 0 , new ModelResourceLocation ( " minecraft : stick # inventory " ) ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / test / resources / assets / forge / recipes / shapeless _ damageable . json b / src / test / resources / assets / forge / recipes / shapeless _ damageable . json <nl> new file mode 100644 <nl> index 0000000 . . b345903 <nl> - - - / dev / null <nl> + + + b / src / test / resources / assets / forge / recipes / shapeless _ damageable . json <nl> @ @ - 0 , 0 + 1 , 13 @ @ <nl> + { <nl> + " type " : " minecraft : crafting _ shapeless " , <nl> + " ingredients " : [ <nl> + { <nl> + " item " : " minecraft : bow " , <nl> + " data " : 32767 <nl> + } <nl> + ] , <nl> + " result " : { <nl> + " item " : " minecraft : wool " , <nl> + " data " : 9 <nl> + } <nl> + } <nl> \ No newline at end of file <nl> diff - - git a / src / test / resources / assets / recipetest / recipes / tool _ complex . json b / src / test / resources / assets / recipetest / recipes / tool _ complex . json <nl> new file mode 100644 <nl> index 0000000 . . f2d6c81 <nl> - - - / dev / null <nl> + + + b / src / test / resources / assets / recipetest / recipes / tool _ complex . json <nl> @ @ - 0 , 0 + 1 , 21 @ @ <nl> + { <nl> + " type " : " minecraft : crafting _ shapeless " , <nl> + " ingredients " : [ <nl> + { <nl> + " item " : " tool " , <nl> + " data " : 32767 <nl> + } , <nl> + { <nl> + " item " : " minecraft : stone " , <nl> + " data " : 32767 <nl> + } , <nl> + { <nl> + " item " : " minecraft : stone " , <nl> + " data " : 0 <nl> + } <nl> + ] , <nl> + " result " : { <nl> + " item " : " minecraft : wool " , <nl> + " data " : 0 <nl> + } <nl> + } <nl> diff - - git a / src / test / resources / assets / recipetest / recipes / tool _ simple . json b / src / test / resources / assets / recipetest / recipes / tool _ simple . json <nl> new file mode 100644 <nl> index 0000000 . . 192c2fa <nl> - - - / dev / null <nl> + + + b / src / test / resources / assets / recipetest / recipes / tool _ simple . json <nl> @ @ - 0 , 0 + 1 , 13 @ @ <nl> + { <nl> + " type " : " minecraft : crafting _ shapeless " , <nl> + " ingredients " : [ <nl> + { <nl> + " item " : " tool " , <nl> + " data " : 32767 <nl> + } <nl> + ] , <nl> + " result " : { <nl> + " item " : " minecraft : wool " , <nl> + " data " : 9 <nl> + } <nl> + }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / extensions / ForgeRecipeManager . java b / src / main / java / net / minecraftforge / common / extensions / ForgeRecipeManager . java 
 index b4b474a . . 959eace 100644 
 - - - a / src / main / java / net / minecraftforge / common / extensions / ForgeRecipeManager . java 
 + + + b / src / main / java / net / minecraftforge / common / extensions / ForgeRecipeManager . java 
 @ @ - 28 , 6 + 28 , 7 @ @ import javax . annotation . Nullable ; 
 import com . google . common . collect . Maps ; 
 
 import net . minecraft . inventory . IInventory ; 
 + import net . minecraft . inventory . InventoryCrafting ; 
 import net . minecraft . item . ItemStack ; 
 import net . minecraft . item . crafting . IRecipe ; 
 import net . minecraft . resources . IResourceManager ; 
 @ @ - 36 , 24 + 37 , 42 @ @ import net . minecraft . util . NonNullList ; 
 import net . minecraft . world . World ; 
 import net . minecraftforge . common . crafting . CraftingHelper ; 
 import net . minecraftforge . common . crafting . RecipeType ; 
 + import net . minecraftforge . items . wrapper . RecipeWrapper ; 
 
 @ SuppressWarnings ( " deprecation " ) 
 public abstract class ForgeRecipeManager implements IResourceManagerReloadListener 
 { 
 + / * * 
 + * Master list of sorted recipes . 
 + * / 
 protected final Map < RecipeType < ? extends IRecipe > , List < ? extends IRecipe > > sortedRecipes = Maps . newHashMap ( ) ; 
 
 @ Override 
 - public void onResourceManagerReload ( IResourceManager resourceManager ) { 
 + public void onResourceManagerReload ( IResourceManager resourceManager ) 
 + { 
 this . sortedRecipes . clear ( ) ; 
 CraftingHelper . reloadConstants ( resourceManager ) ; 
 } 
 
 + / * * 
 + * Returns all the recipes that match this type . 
 + * @ param type A recipe type . 
 + * @ return All recipes that are of the passed type . This list may be empty . 
 + * / 
 @ SuppressWarnings ( " unchecked " ) 
 public < T extends IRecipe > List < T > getRecipes ( RecipeType < T > type ) 
 { 
 return ( List < T > ) this . sortedRecipes . computeIfAbsent ( type , t - > new ArrayList < > ( ) ) ; 
 } 
 
 + / * * 
 + * Automatically returns a result from the first recipe that matches this inv and type . 
 + * Modders should probably not use this , and instead use { @ link # getRecipe ( IInventory , World , RecipeType ) } since you get the recipe object itself . 
 + * @ param input An inventory . 
 + * @ param world The world . 
 + * @ param type The type of recipe to match against . 
 + * @ return The output of the first matching recipe , or { @ link ItemStack # EMPTY } if no recipes match . 
 + * / 
 public ItemStack getResult ( IInventory input , World world , RecipeType < ? > type ) 
 { 
 for ( IRecipe irecipe : getRecipes ( type ) ) 
 @ @ - 61 , 7 + 80 , 16 @ @ public abstract class ForgeRecipeManager implements IResourceManagerReloadListen 
 return ItemStack . EMPTY ; 
 } 
 
 - 	 @ Nullable 
 + / * * 
 + * Used to find a matching recipe for the given inv , world , and type . 
 + * Since this requires an IInventory , modders can use { @ link RecipeWrapper } to avoid direct implementation . 
 + * For crafting recipes , it is advised to still use { @ link InventoryCrafting } . The dynamic vanilla recipes require they be crafted in one . 
 + * @ param input An inventory . 
 + * @ param world The world . 
 + * @ param type The type of recipe to match against . 
 + * @ return The first matching recipe . 
 + * / 
 + @ Nullable 
 public < T extends IRecipe > T getRecipe ( IInventory input , World world , RecipeType < T > type ) 
 { 
 for ( T irecipe : getRecipes ( type ) ) 
 @ @ - 71 , 7 + 99 , 9 @ @ public abstract class ForgeRecipeManager implements IResourceManagerReloadListen 
 
 / * * 
 * Modders should not use this if possible . In the context that this is used , you should already have the recipe . Do not run extra lookups using this method . 
 + * Use { @ link IRecipe # getRemainingItems ( IInventory ) } . 
 * / 
 + @ Deprecated 
 public NonNullList < ItemStack > getRemainingItems ( IInventory input , World world , RecipeType < ? > type ) 
 { 
 for ( IRecipe irecipe : getRecipes ( type ) ) 
 diff - - git a / src / main / java / net / minecraftforge / common / extensions / IForgeRecipe . java b / src / main / java / net / minecraftforge / common / extensions / IForgeRecipe . java 
 index b36aed2 . . 7bcdbdf 100644 
 - - - a / src / main / java / net / minecraftforge / common / extensions / IForgeRecipe . java 
 + + + b / src / main / java / net / minecraftforge / common / extensions / IForgeRecipe . java 
 @ @ - 19 , 8 + 19 , 6 @ @ 
 
 package net . minecraftforge . common . extensions ; 
 
 - import java . util . Collection ; 
 - 
 import net . minecraft . item . crafting . IRecipe ; 
 import net . minecraftforge . common . crafting . RecipeType ; 
 import net . minecraftforge . common . crafting . VanillaRecipeTypes ; 
 @ @ - 28 , 7 + 26 , 7 @ @ import net . minecraftforge . common . crafting . VanillaRecipeTypes ; 
 public interface IForgeRecipe { 
 
 / * * 
 - * Used when sorting this recipe into it ' s category during load , and in the default type matcher below . 
 + * Used when sorting this recipe into it ' s category during load . This type determines what class the recipe must subclass . 
 * @ return The type of this recipe . 
 * / 
 default RecipeType < ? extends IRecipe > getType ( ) 
 diff - - git a / src / main / java / net / minecraftforge / items / wrapper / RecipeWrapper . java b / src / main / java / net / minecraftforge / items / wrapper / RecipeWrapper . java 
 new file mode 100644 
 index 0000000 . . 64f60ea 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / items / wrapper / RecipeWrapper . java 
 @ @ - 0 , 0 + 1 , 157 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 - 2019 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + 
 + package net . minecraftforge . items . wrapper ; 
 + 
 + import net . minecraft . entity . player . EntityPlayer ; 
 + import net . minecraft . inventory . IInventory ; 
 + import net . minecraft . item . ItemStack ; 
 + import net . minecraft . util . text . ITextComponent ; 
 + import net . minecraftforge . items . IItemHandlerModifiable ; 
 + 
 + public class RecipeWrapper implements IInventory { 
 + 
 + protected final IItemHandlerModifiable inv ; 
 + protected final int width ; 
 + protected final int height ; 
 + 
 + public RecipeWrapper ( IItemHandlerModifiable inv , int width , int height ) 
 + { 
 + this . inv = inv ; 
 + this . width = width ; 
 + this . height = height ; 
 + } 
 + 
 + / * * 
 + * Returns the size of this inventory . Must be equivalent to { @ link # getHeight ( ) } * { @ link # getWidth ( ) } . 
 + * / 
 + @ Override 
 + public int getSizeInventory ( ) 
 + { 
 + return getHeight ( ) * getWidth ( ) ; 
 + } 
 + 
 + / * * 
 + * Returns the stack in this slot . This stack should be a modifiable reference , not a copy of a stack in your inventory . 
 + * / 
 + @ Override 
 + public ItemStack getStackInSlot ( int slot ) 
 + { 
 + return inv . getStackInSlot ( slot ) ; 
 + } 
 + 
 + / * * 
 + * Attempts to remove n items from the specified slot . Returns the split stack that was removed . Modifies the inventory . 
 + * / 
 + @ Override 
 + public ItemStack decrStackSize ( int slot , int count ) 
 + { 
 + ItemStack stack = inv . getStackInSlot ( slot ) ; 
 + return stack . isEmpty ( ) ? ItemStack . EMPTY : stack . split ( count ) ; 
 + } 
 + 
 + / * * 
 + * Sets the contents of this slot to the provided stack . 
 + * / 
 + @ Override 
 + public void setInventorySlotContents ( int slot , ItemStack stack ) 
 + { 
 + inv . setStackInSlot ( slot , stack ) ; 
 + } 
 + 
 + / * * 
 + * Returns the height of this inventory . 
 + * / 
 + @ Override 
 + public int getHeight ( ) 
 + { 
 + return height ; 
 + } 
 + 
 + / * * 
 + * Returns the width of this inventory . 
 + * / 
 + @ Override 
 + public int getWidth ( ) 
 + { 
 + return width ; 
 + } 
 + 
 + / * * 
 + * Removes the stack contained in this slot from the underlying handler , and returns it . 
 + * / 
 + @ Override 
 + public ItemStack removeStackFromSlot ( int index ) 
 + { 
 + ItemStack s = getStackInSlot ( index ) ; 
 + if ( s . isEmpty ( ) ) return ItemStack . EMPTY ; 
 + setInventorySlotContents ( index , ItemStack . EMPTY ) ; 
 + return s ; 
 + } 
 + 
 + @ Override 
 + public boolean isEmpty ( ) 
 + { 
 + for ( int i = 0 ; i < inv . getSlots ( ) ; i + + ) 
 + { 
 + if ( ! inv . getStackInSlot ( i ) . isEmpty ( ) ) return false ; 
 + } 
 + return true ; 
 + } 
 + 
 + @ Override 
 + public boolean isItemValidForSlot ( int slot , ItemStack stack ) 
 + { 
 + return inv . isItemValid ( slot , stack ) ; 
 + } 
 + 
 + @ Override 
 + public void clear ( ) 
 + { 
 + for ( int i = 0 ; i < inv . getSlots ( ) ; i + + ) 
 + { 
 + inv . setStackInSlot ( i , ItemStack . EMPTY ) ; 
 + } 
 + } 
 + 
 + / / The following methods are never used by vanilla in crafting . They are defunct as mods need not override them . 
 + @ Override 
 + public int getInventoryStackLimit ( ) { return 0 ; } 
 + @ Override 
 + public void markDirty ( ) { } 
 + @ Override 
 + public boolean isUsableByPlayer ( EntityPlayer player ) { return false ; } 
 + @ Override 
 + public void openInventory ( EntityPlayer player ) { } 
 + @ Override 
 + public void closeInventory ( EntityPlayer player ) { } 
 + @ Override 
 + public int getField ( int id ) { return 0 ; } 
 + @ Override 
 + public void setField ( int id , int value ) { } 
 + @ Override 
 + public int getFieldCount ( ) { return 0 ; } 
 + @ Override 
 + public ITextComponent getName ( ) { return null ; } 
 + @ Override 
 + public boolean hasCustomName ( ) { return false ; } 
 + @ Override 
 + public ITextComponent getCustomName ( ) { return null ; } 
 + 
 + }

NEAREST DIFF:
diff - - git a / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch b / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch 
 index 697a870 . . f9d344f 100644 
 - - - a / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch 
 + + + b / patches / minecraft / net / minecraft / item / crafting / Ingredient . java . patch 
 @ @ - 1 , 6 + 1 , 11 @ @ 
 - - - . . / src - base / minecraft / net / minecraft / item / crafting / Ingredient . java 
 + + + . . / src - work / minecraft / net / minecraft / item / crafting / Ingredient . java 
 - @ @ - 13 , 6 + 13 , 8 @ @ 
 + @ @ - 8 , 11 + 8 , 11 @ @ 
 + import net . minecraft . client . util . RecipeItemHelper ; 
 + import net . minecraft . item . Item ; 
 + import net . minecraft . item . ItemStack ; 
 + - import net . minecraftforge . fml . relauncher . Side ; 
 + - import net . minecraftforge . fml . relauncher . SideOnly ; 
 
 public class Ingredient implements Predicate < ItemStack > 
 { 
 @ @ - 9 , 12 + 14 , 13 @ @ 
 public static final Ingredient field _ 193370 _ a = new Ingredient ( new ItemStack [ 0 ] ) 
 { 
 public boolean apply ( @ Nullable ItemStack p _ apply _ 1 _ ) 
 - @ @ - 21 , 17 + 23 , 34 @ @ 
 + @ @ - 21 , 17 + 21 , 41 @ @ 
 } 
 } ; 
 private final ItemStack [ ] field _ 193371 _ b ; 
 + private final ItemStack [ ] matchingStacksExploded ; 
 private IntList field _ 194140 _ c ; 
 + + private final boolean isSimple ; 
 
 + protected Ingredient ( int size ) 
 + { 
 @ @ - 23 , 6 + 29 , 7 @ @ 
 + 
 protected Ingredient ( ItemStack . . . p _ i47503 _ 1 _ ) 
 { 
 + + boolean simple = true ; 
 this . field _ 193371 _ b = p _ i47503 _ 1 _ ; 
 + net . minecraft . util . NonNullList < ItemStack > lst = net . minecraft . util . NonNullList . func _ 191196 _ a ( ) ; 
 + for ( ItemStack s : p _ i47503 _ 1 _ ) 
 @ @ - 30 , 11 + 37 , 16 @ @ 
 + if ( s . func _ 190926 _ b ( ) ) 
 + continue ; 
 + if ( s . func _ 77960 _ j ( ) = = net . minecraftforge . oredict . OreDictionary . WILDCARD _ VALUE ) 
 + + { 
 + + if ( s . func _ 77973 _ b ( ) . func _ 77645 _ m ( ) ) 
 + + simple = false ; 
 + s . func _ 77973 _ b ( ) . func _ 150895 _ a ( net . minecraft . creativetab . CreativeTabs . field _ 78027 _ g , lst ) ; 
 + + } 
 + else 
 + lst . add ( s ) ; 
 + } 
 + this . matchingStacksExploded = lst . toArray ( new ItemStack [ lst . size ( ) ] ) ; 
 + + this . isSimple = simple & & this . matchingStacksExploded . length > 0 ; 
 + Ingredient . INSTANCES . add ( this ) ; 
 } 
 
 @ @ - 46 , 7 + 58 , 7 @ @ 
 } 
 
 public boolean apply ( @ Nullable ItemStack p _ apply _ 1 _ ) 
 - @ @ - 63 , 9 + 82 , 9 @ @ 
 + @ @ - 63 , 9 + 87 , 9 @ @ 
 { 
 if ( this . field _ 194140 _ c = = null ) 
 { 
 @ @ - 58 , 7 + 70 , 7 @ @ 
 { 
 this . field _ 194140 _ c . add ( RecipeItemHelper . func _ 194113 _ b ( itemstack ) ) ; 
 } 
 - @ @ - 76 , 6 + 95 , 18 @ @ 
 + @ @ - 76 , 6 + 100 , 18 @ @ 
 return this . field _ 194140 _ c ; 
 } 
 
 @ @ - 77 , 7 + 89 , 7 @ @ 
 public static Ingredient func _ 193367 _ a ( Item p _ 193367 _ 0 _ ) 
 { 
 return func _ 193369 _ a ( new ItemStack ( p _ 193367 _ 0 _ , 1 , 32767 ) ) ; 
 - @ @ - 108 , 4 + 139 , 17 @ @ 
 + @ @ - 108 , 4 + 144 , 22 @ @ 
 
 return field _ 193370 _ a ; 
 } 
 @ @ - 94 , 4 + 106 , 9 @ @ 
 + } 
 + return new Ingredient ( lst . toArray ( new ItemStack [ lst . size ( ) ] ) ) ; 
 + } 
 + + 
 + + public boolean isSimple ( ) 
 + + { 
 + + return isSimple | | this = = field _ 193370 _ a ; 
 + + } 
 } 
 diff - - git a / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch b / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch 
 index df082d0 . . 34e6831 100644 
 - - - a / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch 
 + + + b / patches / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java . patch 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 - - - . . / src - base / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java 
 + + + . . / src - work / minecraft / net / minecraft / item / crafting / ShapelessRecipes . java 
 - @ @ - 10 , 10 + 10 , 8 @ @ 
 + @ @ - 10 , 23 + 10 , 25 @ @ 
 import net . minecraft . util . JsonUtils ; 
 import net . minecraft . util . NonNullList ; 
 import net . minecraft . world . World ; 
 @ @ - 12 , 15 + 12 , 25 @ @ 
 { 
 private final ItemStack field _ 77580 _ a ; 
 public final NonNullList < Ingredient > field _ 77579 _ b ; 
 - @ @ - 26 , 7 + 24 , 6 @ @ 
 + private final String field _ 194138 _ c ; 
 + + private final boolean isSimple ; 
 + 
 + public ShapelessRecipes ( String p _ i47500 _ 1 _ , ItemStack p _ i47500 _ 2 _ , NonNullList < Ingredient > p _ i47500 _ 3 _ ) 
 + { 
 + this . field _ 194138 _ c = p _ i47500 _ 1 _ ; 
 + this . field _ 77580 _ a = p _ i47500 _ 2 _ ; 
 this . field _ 77579 _ b = p _ i47500 _ 3 _ ; 
 + + boolean simple = true ; 
 + + for ( Ingredient i : p _ i47500 _ 3 _ ) 
 + + simple & = i . isSimple ( ) ; 
 + + this . isSimple = simple ; 
 } 
 
 - @ SideOnly ( Side . CLIENT ) 
 public String func _ 193358 _ e ( ) 
 { 
 return this . field _ 194138 _ c ; 
 - @ @ - 50 , 10 + 47 , 7 @ @ 
 + @ @ - 50 , 10 + 52 , 7 @ @ 
 { 
 ItemStack itemstack = p _ 179532 _ 1 _ . func _ 70301 _ a ( i ) ; 
 
 @ @ - 32 , 17 + 42 , 18 @ @ 
 } 
 
 return nonnulllist ; 
 - @ @ - 61 , 7 + 55 , 8 @ @ 
 + @ @ - 61 , 7 + 60 , 9 @ @ 
 
 public boolean func _ 77569 _ a ( InventoryCrafting p _ 77569 _ 1 _ , World p _ 77569 _ 2 _ ) 
 { 
 - List < Ingredient > list = Lists . newArrayList ( this . field _ 77579 _ b ) ; 
 + int ingredientCount = 0 ; 
 + net . minecraft . client . util . RecipeItemHelper recipeItemHelper = new net . minecraft . client . util . RecipeItemHelper ( ) ; 
 + + List < ItemStack > inputs = Lists . newArrayList ( ) ; 
 
 for ( int i = 0 ; i < p _ 77569 _ 1 _ . func _ 174923 _ h ( ) ; + + i ) 
 { 
 - @ @ - 71 , 27 + 66 , 13 @ @ 
 + @ @ - 71 , 27 + 72 , 22 @ @ 
 
 if ( ! itemstack . func _ 190926 _ b ( ) ) 
 { 
 @ @ - 63 , 17 + 74 , 26 @ @ 
 - return false ; 
 - } 
 + + + ingredientCount ; 
 - + recipeItemHelper . func _ 194112 _ a ( itemstack ) ; 
 + + if ( this . isSimple ) 
 + + recipeItemHelper . func _ 194112 _ a ( itemstack ) ; 
 + + else 
 + + inputs . add ( itemstack ) ; 
 } 
 } 
 } 
 
 - return list . isEmpty ( ) ; 
 - + return ingredientCount = = this . field _ 77579 _ b . size ( ) & & recipeItemHelper . func _ 194116 _ a ( this , null ) ; 
 + + if ( ingredientCount ! = this . field _ 77579 _ b . size ( ) ) 
 + + return false ; 
 + + 
 + + if ( this . isSimple ) 
 + + return recipeItemHelper . func _ 194116 _ a ( this , null ) ; 
 + + 
 + + return net . minecraftforge . common . util . RecipeMatcher . findMatches ( inputs , this . field _ 77579 _ b ) ! = null ; 
 } 
 
 public ItemStack func _ 77572 _ b ( InventoryCrafting p _ 77572 _ 1 _ ) 
 - @ @ - 136 , 7 + 117 , 6 @ @ 
 + @ @ - 136 , 7 + 132 , 6 @ @ 
 return nonnulllist ; 
 } 
 
 diff - - git a / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java b / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java 
 index 32a2c02 . . 60909dd 100644 
 - - - a / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java 
 + + + b / src / main / java / net / minecraftforge / common / crafting / CompoundIngredient . java 
 @ @ - 20 , 11 + 20 , 17 @ @ public class CompoundIngredient extends Ingredient 
 private Collection < Ingredient > children ; 
 private ItemStack [ ] stacks ; 
 private IntList itemIds ; 
 + private final boolean isSimple ; 
 
 protected CompoundIngredient ( Collection < Ingredient > children ) 
 { 
 super ( 0 ) ; 
 this . children = children ; 
 + 
 + boolean simple = true ; 
 + for ( Ingredient child : children ) 
 + simple & = child . isSimple ( ) ; 
 + this . isSimple = simple ; 
 } 
 
 @ Override 
 @ @ - 78 , 4 + 84 , 10 @ @ public class CompoundIngredient extends Ingredient 
 this . stacks = null ; 
 / / Shouldn ' t need to invalidate children as this is only called form invalidateAll . . 
 } 
 + 
 + @ Override 
 + public boolean isSimple ( ) 
 + { 
 + return isSimple ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java b / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java 
 index 3f7c31e . . 9a85682 100644 
 - - - a / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java 
 + + + b / src / main / java / net / minecraftforge / common / crafting / IngredientNBT . java 
 @ @ - 40 , 4 + 40 , 10 @ @ public class IngredientNBT extends Ingredient 
 / / Can ' t use areItemStacksEqualUsingNBTShareTag because it compares stack size as well 
 return this . stack . getItem ( ) = = input . getItem ( ) & & this . stack . getItemDamage ( ) = = input . getItemDamage ( ) & & ItemStack . areItemStackShareTagsEqual ( this . stack , input ) ; 
 } 
 + 
 + @ Override 
 + public boolean isSimple ( ) 
 + { 
 + return false ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java b / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java 
 new file mode 100644 
 index 0000000 . . c8549ff 
 - - - / dev / null 
 + + + b / src / main / java / net / minecraftforge / common / util / RecipeMatcher . java 
 @ @ - 0 , 0 + 1 , 162 @ @ 
 + / * 
 + * Minecraft Forge 
 + * Copyright ( c ) 2016 . 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation version 2 . 1 
 + * of the License . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * 
 + * You should have received a copy of the GNU Lesser General Public 
 + * License along with this library ; if not , write to the Free Software 
 + * Foundation , Inc . , 51 Franklin Street , Fifth Floor , Boston , MA 02110 - 1301 USA 
 + * / 
 + package net . minecraftforge . common . util ; 
 + 
 + import java . util . BitSet ; 
 + import java . util . LinkedList ; 
 + import java . util . List ; 
 + import java . util . Queue ; 
 + 
 + import com . google . common . base . Predicate ; 
 + 
 + public class RecipeMatcher 
 + { 
 + / * * 
 + * Attempts to match inputs to the specified tests . In the best way that all inputs are used by one test . 
 + * Will return null in any of these cases : 
 + * input / test lengths don ' t match . This is only for matching paired outputs . 
 + * any input doesn ' t match a test 
 + * any test doesn ' t match a input 
 + * If we are unable to determine a proper pair 
 + * 
 + * @ return An array mapping inputs to tests . ret [ x ] = y means input [ x ] = test [ y ] 
 + * / 
 + public static < T > int [ ] findMatches ( List < T > inputs , List < ? extends Predicate < T > > tests ) 
 + { 
 + int elements = inputs . size ( ) ; 
 + if ( elements ! = tests . size ( ) ) 
 + return null ; / / There will not be a 1 : 1 mapping of inputs - > tests 
 + 
 + int [ ] ret = new int [ elements ] ; 
 + for ( int x = 0 ; x < elements ; x + + ) 
 + ret [ x ] = - 1 ; 
 + 
 + / / [ UnusedInputs ] [ UnusedIngredients ] [ IngredientMatchMask ] . . . 
 + BitSet data = new BitSet ( ( elements + 2 ) * elements ) ; 
 + for ( int x = 0 ; x < elements ; x + + ) 
 + { 
 + int matched = 0 ; 
 + int offset = ( x + 2 ) * elements ; 
 + Predicate < T > test = tests . get ( x ) ; 
 + 
 + for ( int y = 0 ; y < elements ; y + + ) 
 + { 
 + if ( data . get ( y ) ) 
 + continue ; 
 + 
 + if ( test . apply ( inputs . get ( y ) ) ) 
 + { 
 + data . set ( offset + y ) ; 
 + matched + + ; 
 + } 
 + } 
 + 
 + if ( matched = = 0 ) 
 + return null ; / / We have an test that matched non of the inputs 
 + 
 + if ( matched = = 1 ) 
 + { 
 + if ( ! claim ( ret , data , x , elements ) ) 
 + return null ; / / We failed to claim this index , which means it caused something else to go to 0 matches , which makes the whole thing fail 
 + } 
 + } 
 + 
 + if ( data . nextClearBit ( 0 ) > = elements ) / / All items have been used , which means all tests have a match ! 
 + return ret ; 
 + 
 + / / We should be in a state where multiple tests are satified by multiple inputs . So we need to try a branching recursive test . 
 + / / However for performance reasons , we should probably make that check a sub - set of the entire graph . 
 + if ( backtrack ( data , ret , 0 , elements ) ) 
 + return ret ; 
 + 
 + return null ; / / Backtrack failed , no matches , we cry and go home now : ( 
 + } 
 + 
 + / / This is bad . . . need to think of a better cascade , recursion instead of stack ? 
 + private static boolean claim ( int [ ] ret , BitSet data , int claimed , int elements ) 
 + { 
 + Queue < Integer > pending = new LinkedList < Integer > ( ) ; 
 + pending . add ( claimed ) ; 
 + 
 + while ( pending . peek ( ) ! = null ) 
 + { 
 + int test = pending . poll ( ) ; 
 + int offset = ( test + 2 ) * elements ; 
 + int used = data . nextSetBit ( offset ) - offset ; 
 + 
 + if ( used > = elements | | used < 0 ) 
 + throw new IllegalStateException ( " What ? We matched something , but it wasn ' t set in the range of this test ! Test : " + test + " Used : " + used ) ; 
 + 
 + data . set ( used ) ; 
 + data . set ( elements + test ) ; 
 + ret [ used ] = test ; 
 + 
 + for ( int x = 0 ; x < elements ; x + + ) 
 + { 
 + offset = ( x + 2 ) * elements ; 
 + if ( data . get ( offset + used ) & & ! data . get ( elements + x ) ) 
 + { 
 + data . clear ( offset + used ) ; 
 + int count = 0 ; 
 + for ( int y = offset ; y < offset + elements ; y + + ) 
 + if ( data . get ( y ) ) 
 + count + + ; 
 + 
 + if ( count = = 0 ) 
 + return false ; / / Claiming this caused another test to lose its last match . . 
 + 
 + if ( count = = 1 ) 
 + pending . add ( x ) ; 
 + } 
 + } 
 + } 
 + 
 + return true ; 
 + } 
 + 
 + / / We use recursion here , why ? Because I feel like it . Also because we should only ever be working in data sets < 9 
 + private static boolean backtrack ( BitSet data , int [ ] ret , int start , int elements ) 
 + { 
 + int test = data . nextClearBit ( elements + start ) - elements ; 
 + if ( test > = elements ) 
 + return true ; / / Could not find the next unused test . 
 + 
 + if ( test < 0 ) 
 + throw new IllegalStateException ( " This should never happen , negative test in backtrack ! " ) ; 
 + 
 + int offset = ( test + 2 ) * elements ; 
 + for ( int x = 0 ; x < elements ; x + + ) 
 + { 
 + if ( ! data . get ( offset + x ) | | data . get ( x ) ) 
 + continue ; 
 + 
 + data . set ( x ) ; 
 + 
 + if ( backtrack ( data , ret , test + 1 , elements ) ) 
 + { 
 + ret [ x ] = test ; 
 + return true ; 
 + } 
 + 
 + data . clear ( x ) ; 
 + } 
 + 
 + return false ; 
 + } 
 + } 
 diff - - git a / src / main / java / net / minecraftforge / oredict / OreIngredient . java b / src / main / java / net / minecraftforge / oredict / OreIngredient . java 
 index 11ae517 . . 9a017b9 100644 
 - - - a / src / main / java / net / minecraftforge / oredict / OreIngredient . java 
 + + + b / src / main / java / net / minecraftforge / oredict / OreIngredient . java 
 @ @ - 114 , 4 + 114 , 10 @ @ public class OreIngredient extends Ingredient 
 this . itemIds = null ; 
 this . array = null ; 
 } 
 + 
 + @ Override 
 + public boolean isSimple ( ) 
 + { 
 + return true ; 
 + } 
 } 
 diff - - git a / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java b / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java 
 index 56d9485 . . db07357 100644 
 - - - a / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java 
 + + + b / src / main / java / net / minecraftforge / oredict / ShapelessOreRecipe . java 
 @ @ - 33 , 6 + 33 , 7 @ @ import net . minecraft . util . ResourceLocation ; 
 import net . minecraft . world . World ; 
 import net . minecraftforge . common . crafting . CraftingHelper ; 
 import net . minecraftforge . common . crafting . JsonContext ; 
 + import net . minecraftforge . common . util . RecipeMatcher ; 
 import net . minecraftforge . registries . IForgeRegistryEntry ; 
 
 import javax . annotation . Nonnull ; 
 @ @ - 48 , 6 + 49 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 protected ItemStack output = ItemStack . EMPTY ; 
 protected NonNullList < Ingredient > input = NonNullList . create ( ) ; 
 protected ResourceLocation group ; 
 + protected boolean isSimple = true ; 
 
 public ShapelessOreRecipe ( ResourceLocation group , Block result , Object . . . recipe ) { this ( group , new ItemStack ( result ) , recipe ) ; } 
 public ShapelessOreRecipe ( ResourceLocation group , Item result , Object . . . recipe ) { this ( group , new ItemStack ( result ) , recipe ) ; } 
 @ @ - 56 , 6 + 58 , 8 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 this . group = group ; 
 output = result . copy ( ) ; 
 this . input = input ; 
 + for ( Ingredient i : input ) 
 + this . isSimple & = i . isSimple ( ) ; 
 } 
 public ShapelessOreRecipe ( ResourceLocation group , @ Nonnull ItemStack result , Object . . . recipe ) 
 { 
 @ @ - 67 , 6 + 71 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 if ( ing ! = null ) 
 { 
 input . add ( ing ) ; 
 + this . isSimple & = ing . isSimple ( ) ; 
 } 
 else 
 { 
 @ @ - 94 , 6 + 99 , 7 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 { 
 int ingredientCount = 0 ; 
 RecipeItemHelper recipeItemHelper = new RecipeItemHelper ( ) ; 
 + List < ItemStack > items = Lists . newArrayList ( ) ; 
 
 for ( int i = 0 ; i < inv . getSizeInventory ( ) ; + + i ) 
 { 
 @ @ - 101 , 11 + 107 , 20 @ @ public class ShapelessOreRecipe extends IForgeRegistryEntry . Impl < IRecipe > implem 
 if ( ! itemstack . isEmpty ( ) ) 
 { 
 + + ingredientCount ; 
 - recipeItemHelper . accountStack ( itemstack ) ; 
 + if ( this . isSimple ) 
 + recipeItemHelper . accountStack ( itemstack ) ; 
 + else 
 + items . add ( itemstack ) ; 
 } 
 } 
 
 - return ingredientCount = = this . input . size ( ) & & recipeItemHelper . canCraft ( this , null ) ; 
 + if ( ingredientCount ! = this . input . size ( ) ) 
 + return false ; 
 + 
 + if ( this . isSimple ) 
 + return recipeItemHelper . canCraft ( this , null ) ; 
 + 
 + return RecipeMatcher . findMatches ( items , this . input ) ! = null ; 
 } 
 
 @ Override 
 diff - - git a / src / test / java / net / minecraftforge / debug / RecipeTestMod . java b / src / test / java / net / minecraftforge / debug / RecipeTestMod . java 
 index cc9c48c . . df3e1b8 100644 
 - - - a / src / test / java / net / minecraftforge / debug / RecipeTestMod . java 
 + + + b / src / test / java / net / minecraftforge / debug / RecipeTestMod . java 
 @ @ - 1 , 44 + 1 , 108 @ @ 
 package net . minecraftforge . debug ; 
 
 + import java . util . Random ; 
 + 
 + import net . minecraft . client . renderer . block . model . ModelResourceLocation ; 
 + import net . minecraft . creativetab . CreativeTabs ; 
 import net . minecraft . init . Blocks ; 
 + import net . minecraft . item . Item ; 
 import net . minecraft . item . ItemStack ; 
 import net . minecraft . item . crafting . IRecipe ; 
 import net . minecraft . item . crafting . ShapedRecipes ; 
 + import net . minecraft . util . EnumActionResult ; 
 import net . minecraft . util . ResourceLocation ; 
 + import net . minecraftforge . client . model . ModelLoader ; 
 import net . minecraftforge . common . MinecraftForge ; 
 import net . minecraftforge . common . crafting . CraftingHelper ; 
 + import net . minecraftforge . debug . OnItemUseFirstTest . CommonProxy ; 
 + import net . minecraftforge . debug . OnItemUseFirstTest . ItemTest ; 
 import net . minecraftforge . event . RegistryEvent ; 
 import net . minecraftforge . fml . common . Mod ; 
 + import net . minecraftforge . fml . common . SidedProxy ; 
 import net . minecraftforge . fml . common . event . FMLPreInitializationEvent ; 
 import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; 
 + import net . minecraftforge . fml . common . registry . GameRegistry . ObjectHolder ; 
 import net . minecraftforge . fml . relauncher . FMLLaunchHandler ; 
 import net . minecraftforge . fml . relauncher . Side ; 
 import net . minecraftforge . oredict . ShapedOreRecipe ; 
 
 - @ Mod ( modid = " recipetest " , name = " Recipe test mod " , version = " 1 . 0 " , acceptableRemoteVersions = " * " ) 
 + @ Mod ( modid = RecipeTestMod . MODID , name = " Recipe test mod " , version = " 1 . 0 " , acceptableRemoteVersions = " * " ) 
 public class RecipeTestMod 
 { 
 + public static final String MODID = " recipetest " ; 
 + private static final boolean ENABLED = true ; 
 + @ SidedProxy 
 + public static CommonProxy proxy = null ; 
 + 
 + 
 @ Mod . EventHandler 
 public void preinit ( FMLPreInitializationEvent event ) 
 { 
 - MinecraftForge . EVENT _ BUS . register ( this ) ; 
 + if ( ENABLED ) 
 + MinecraftForge . EVENT _ BUS . register ( this ) ; 
 } 
 
 @ SubscribeEvent 
 public void registerRecipes ( RegistryEvent . Register < IRecipe > event ) 
 { 
 - ResourceLocation location1 = new ResourceLocation ( " recipetest " , " dirt " ) ; 
 + ResourceLocation location1 = new ResourceLocation ( MODID , " dirt " ) ; 
 ShapedOreRecipe recipe1 = new ShapedOreRecipe ( location1 , new ItemStack ( Blocks . DIAMOND _ BLOCK ) , " DDD " , ' D ' , new ItemStack ( Blocks . DIRT ) ) ; 
 recipe1 . setRegistryName ( location1 ) ; 
 event . getRegistry ( ) . register ( recipe1 ) ; 
 
 if ( FMLLaunchHandler . side ( ) = = Side . SERVER ) 
 { 
 - ResourceLocation location2 = new ResourceLocation ( " recipetest " , " stone " ) ; 
 + ResourceLocation location2 = new ResourceLocation ( MODID , " stone " ) ; 
 CraftingHelper . ShapedPrimer primer1 = CraftingHelper . parseShaped ( " SSS " , ' S ' , new ItemStack ( Blocks . IRON _ BLOCK ) ) ; 
 ShapedRecipes recipe2 = new ShapedRecipes ( location2 . getResourcePath ( ) , primer1 . width , primer1 . height , primer1 . input , new ItemStack ( Blocks . GOLD _ BLOCK ) ) ; 
 recipe2 . setRegistryName ( location2 ) ; 
 event . getRegistry ( ) . register ( recipe2 ) ; 
 } 
 } 
 + 
 + @ SubscribeEvent 
 + public void registerItems ( RegistryEvent . Register < Item > event ) 
 + { 
 + proxy . registerItem ( event ) ; 
 + } 
 + 
 + public static abstract class CommonProxy 
 + { 
 + protected Item TOOL ; 
 + public void registerItem ( RegistryEvent . Register < Item > event ) 
 + { 
 + TOOL = new Item ( ) 
 + { 
 + Random RAND = new Random ( ) ; 
 + @ Override 
 + public ItemStack getContainerItem ( ItemStack in ) 
 + { 
 + ItemStack ret = in . copy ( ) ; 
 + ret . attemptDamageItem ( 1 , RAND , null ) ; 
 + return ret ; 
 + } 
 + 
 + @ Override 
 + public boolean hasContainerItem ( ) 
 + { 
 + return true ; 
 + } 
 + } . setRegistryName ( MODID , " tool " ) . setMaxDamage ( 10 ) . setCreativeTab ( CreativeTabs . MISC ) . setUnlocalizedName ( " recipetest . tool " ) . setMaxStackSize ( 1 ) ; 
 + event . getRegistry ( ) . register ( TOOL ) ; 
 + } 
 + } 
 + 
 + public static final class ServerProxy extends CommonProxy 
 + { 
 + } 
 + 
 + public static final class ClientProxy extends CommonProxy 
 + { 
 + @ Override 
 + public void registerItem ( RegistryEvent . Register < Item > event ) 
 + { 
 + super . registerItem ( event ) ; 
 + ModelLoader . setCustomModelResourceLocation ( TOOL , 0 , new ModelResourceLocation ( " minecraft : stick # inventory " ) ) ; 
 + } 
 + } 
 } 
 diff - - git a / src / test / resources / assets / forge / recipes / shapeless _ damageable . json b / src / test / resources / assets / forge / recipes / shapeless _ damageable . json 
 new file mode 100644 
 index 0000000 . . b345903 
 - - - / dev / null 
 + + + b / src / test / resources / assets / forge / recipes / shapeless _ damageable . json 
 @ @ - 0 , 0 + 1 , 13 @ @ 
 + { 
 + " type " : " minecraft : crafting _ shapeless " , 
 + " ingredients " : [ 
 + { 
 + " item " : " minecraft : bow " , 
 + " data " : 32767 
 + } 
 + ] , 
 + " result " : { 
 + " item " : " minecraft : wool " , 
 + " data " : 9 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / src / test / resources / assets / recipetest / recipes / tool _ complex . json b / src / test / resources / assets / recipetest / recipes / tool _ complex . json 
 new file mode 100644 
 index 0000000 . . f2d6c81 
 - - - / dev / null 
 + + + b / src / test / resources / assets / recipetest / recipes / tool _ complex . json 
 @ @ - 0 , 0 + 1 , 21 @ @ 
 + { 
 + " type " : " minecraft : crafting _ shapeless " , 
 + " ingredients " : [ 
 + { 
 + " item " : " tool " , 
 + " data " : 32767 
 + } , 
 + { 
 + " item " : " minecraft : stone " , 
 + " data " : 32767 
 + } , 
 + { 
 + " item " : " minecraft : stone " , 
 + " data " : 0 
 + } 
 + ] , 
 + " result " : { 
 + " item " : " minecraft : wool " , 
 + " data " : 0 
 + } 
 + } 
 diff - - git a / src / test / resources / assets / recipetest / recipes / tool _ simple . json b / src / test / resources / assets / recipetest / recipes / tool _ simple . json 
 new file mode 100644 
 index 0000000 . . 192c2fa 
 - - - / dev / null 
 + + + b / src / test / resources / assets / recipetest / recipes / tool _ simple . json 
 @ @ - 0 , 0 + 1 , 13 @ @ 
 + { 
 + " type " : " minecraft : crafting _ shapeless " , 
 + " ingredients " : [ 
 + { 
 + " item " : " tool " , 
 + " data " : 32767 
 + } 
 + ] , 
 + " result " : { 
 + " item " : " minecraft : wool " , 
 + " data " : 9 
 + } 
 + }
