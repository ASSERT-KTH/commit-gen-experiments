BLEU SCORE: 0.0042728819679721305

TEST MSG: Cleanup OBJLoader parse function and fix issues related to JVM differences .
GENERATED MSG: Wavefront object importer . Imports Wavefront object and offers some simple render methods for rendering the models in game . Modders have complete access to all the data in the model to write their own rendering related code as well .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java b / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java <nl> index 4aba809 . . 88844c6 100644 <nl> - - - a / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java <nl> + + + b / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java <nl> @ @ - 45 , 6 + 45 , 7 @ @ import net . minecraftforge . common . property . IUnlistedProperty ; <nl> import net . minecraftforge . fml . common . FMLLog ; <nl> <nl> import org . apache . commons . lang3 . tuple . Pair ; <nl> + import org . apache . logging . log4j . core . helpers . Strings ; <nl> <nl> import com . google . common . base . Charsets ; <nl> import com . google . common . base . Function ; <nl> @ @ - 201 , 212 + 202 , 164 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData <nl> return this . groupList ; <nl> } <nl> <nl> + private float [ ] parseFloats ( String [ ] data ) / / Helper converting strings to floats <nl> + { <nl> + float [ ] ret = new float [ data . length ] ; <nl> + for ( int i = 0 ; i < data . length ; i + + ) <nl> + ret [ i ] = Float . parseFloat ( data [ i ] ) ; <nl> + return ret ; <nl> + } <nl> + <nl> + / / Partial reading of the OBJ format . Documentation taken from http : / / paulbourke . net / dataformats / obj / <nl> public OBJModel parse ( ) throws IOException <nl> { <nl> String currentLine = " " ; <nl> Material material = new Material ( ) ; <nl> material . setName ( Material . DEFAULT _ NAME ) ; <nl> int usemtlCounter = 0 ; <nl> - <nl> - / / float [ ] minUVBounds = new float [ ] { 0 . 0f , 0 . 0f } ; <nl> - / / float [ ] maxUVBounds = new float [ ] { 1 . 0f , 1 . 0f } ; <nl> + int lineNum = 0 ; <nl> <nl> for ( ; ; ) <nl> { <nl> + lineNum + + ; <nl> currentLine = objReader . readLine ( ) ; <nl> if ( currentLine = = null ) break ; <nl> currentLine . trim ( ) ; <nl> if ( currentLine . isEmpty ( ) | | currentLine . startsWith ( " # " ) ) continue ; <nl> <nl> - String [ ] fields = WHITE _ SPACE . split ( currentLine , 2 ) ; <nl> - String key = fields [ 0 ] ; <nl> - String data = fields [ 1 ] ; <nl> - String [ ] splitData = WHITE _ SPACE . split ( data ) ; <nl> - <nl> - if ( key . equalsIgnoreCase ( " mtllib " ) ) <nl> - this . materialLibrary . parseMaterials ( manager , data , objFrom ) ; <nl> - else if ( key . equalsIgnoreCase ( " usemtl " ) ) <nl> - { <nl> - material = this . materialLibrary . materials . get ( data ) ; <nl> - usemtlCounter + + ; <nl> - } <nl> - else if ( key . equalsIgnoreCase ( " v " ) ) <nl> - { <nl> - float [ ] floatSplitData = new float [ splitData . length ] ; <nl> - for ( int i = 0 ; i < splitData . length ; i + + ) <nl> - floatSplitData [ i ] = Float . parseFloat ( splitData [ i ] ) ; <nl> - Vector4f pos = new Vector4f ( floatSplitData [ 0 ] , floatSplitData [ 1 ] , floatSplitData [ 2 ] , floatSplitData . length = = 4 ? floatSplitData [ 3 ] : 1 ) ; <nl> - Vertex vertex = new Vertex ( pos , material ) ; <nl> - this . vertices . add ( vertex ) ; <nl> - } <nl> - else if ( key . equalsIgnoreCase ( " vn " ) ) <nl> - { <nl> - float [ ] floatSplitData = new float [ splitData . length ] ; <nl> - for ( int i = 0 ; i < splitData . length ; i + + ) <nl> - floatSplitData [ i ] = Float . parseFloat ( splitData [ i ] ) ; <nl> - Normal normal = new Normal ( floatSplitData ) ; <nl> - this . normals . add ( normal ) ; <nl> - } <nl> - else if ( key . equalsIgnoreCase ( " vt " ) ) <nl> + try <nl> { <nl> - float [ ] floatSplitData = new float [ splitData . length ] ; <nl> - for ( int i = 0 ; i < splitData . length ; i + + ) <nl> - floatSplitData [ i ] = Float . parseFloat ( splitData [ i ] ) ; <nl> - TextureCoordinate texCoord = new TextureCoordinate ( new Vector3f ( floatSplitData [ 0 ] , floatSplitData [ 1 ] , floatSplitData . length = = 3 ? floatSplitData [ 2 ] : 1 ) ) ; <nl> - if ( texCoord . u < 0 . 0f | | texCoord . u > 1 . 0f | | texCoord . v < 0 . 0f | | texCoord . v > 1 . 0f ) <nl> - throw new UVsOutOfBoundsException ( this . objFrom ) ; <nl> - / / this . UVsOutOfBounds = ( texCoord . u < 0 . 0f | | texCoord . u > 1 . 0f | | texCoord . v < 0 . 0f | | texCoord . v > 1 . 0f ) ; <nl> - <nl> - / / if ( texCoord . u < 0 . 0f | | texCoord . u > 1 . 0f | | texCoord . v < 0 . 0f | | texCoord . v > 1 . 0f ) <nl> - / / { <nl> - / / this . UVsOutOfBounds = true ; <nl> - / / texCoord . u - = Math . floor ( texCoord . u ) ; <nl> - / / texCoord . v - = Math . floor ( texCoord . v ) ; <nl> - / / } <nl> - <nl> - / / minUVBounds [ 0 ] = floatSplitData [ 0 ] < minUVBounds [ 0 ] ? floatSplitData [ 0 ] : minUVBounds [ 0 ] ; <nl> - / / minUVBounds [ 1 ] = floatSplitData [ 1 ] < minUVBounds [ 1 ] ? floatSplitData [ 1 ] : minUVBounds [ 1 ] ; <nl> - / / maxUVBounds [ 0 ] = floatSplitData [ 0 ] > maxUVBounds [ 0 ] ? floatSplitData [ 0 ] : maxUVBounds [ 0 ] ; <nl> - / / maxUVBounds [ 1 ] = floatSplitData [ 1 ] > maxUVBounds [ 1 ] ? floatSplitData [ 1 ] : maxUVBounds [ 1 ] ; <nl> - / / FMLLog . info ( " u : [ % f , % f ] v : [ % f , % f ] " , minUVBounds [ ] ) ; <nl> - this . texCoords . add ( texCoord ) ; <nl> - } <nl> - else if ( key . equalsIgnoreCase ( " f " ) ) <nl> - { <nl> - String [ ] [ ] splitSlash = new String [ splitData . length ] [ ] ; <nl> - if ( splitData . length > 4 ) FMLLog . warning ( " OBJModel . Parser : found a face ( ' f ' ) with more than 4 vertices , only the first 4 of these vertices will be rendered ! " ) ; <nl> + String [ ] fields = WHITE _ SPACE . split ( currentLine , 2 ) ; <nl> + String key = fields [ 0 ] ; <nl> + String data = fields [ 1 ] ; <nl> + String [ ] splitData = WHITE _ SPACE . split ( data ) ; <nl> <nl> - int vert = 0 ; <nl> - int texCoord = 0 ; <nl> - int norm = 0 ; <nl> + if ( key . equalsIgnoreCase ( " mtllib " ) ) <nl> + { <nl> + this . materialLibrary . parseMaterials ( manager , data , objFrom ) ; <nl> + } <nl> + else if ( key . equalsIgnoreCase ( " usemtl " ) ) <nl> + { <nl> + material = this . materialLibrary . materials . get ( data ) ; <nl> + usemtlCounter + + ; <nl> + } <nl> + else if ( key . equalsIgnoreCase ( " v " ) ) / / Vertices : x y z [ w ] - w Defaults to 1 . 0 <nl> + { <nl> + float [ ] coords = parseFloats ( splitData ) ; <nl> + Vector4f pos = new Vector4f ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords . length = = 4 ? coords [ 3 ] : 1 . 0F ) ; <nl> + this . vertices . add ( new Vertex ( pos , material ) ) ; <nl> + } <nl> + else if ( key . equalsIgnoreCase ( " vn " ) ) / / Vertex normals : x y z <nl> + { <nl> + this . normals . add ( new Normal ( parseFloats ( splitData ) ) ) ; <nl> + } <nl> + else if ( key . equalsIgnoreCase ( " vt " ) ) / / Vertex Textures : u [ v ] [ w ] - v / w Defaults to 0 <nl> + { <nl> + float [ ] coords = parseFloats ( splitData ) ; <nl> + TextureCoordinate texCoord = new TextureCoordinate ( coords [ 0 ] , <nl> + coords . length > = 2 ? coords [ 1 ] : 0 . 0F , <nl> + coords . length > = 3 ? coords [ 2 ] : 0 . 0F ) ; <nl> + if ( texCoord . u < 0 . 0f | | texCoord . u > 1 . 0f | | texCoord . v < 0 . 0f | | texCoord . v > 1 . 0f ) <nl> + throw new UVsOutOfBoundsException ( this . objFrom ) ; <nl> + this . texCoords . add ( texCoord ) ; <nl> + } <nl> + else if ( key . equalsIgnoreCase ( " f " ) ) / / Face Elements : f v1 [ / vt1 ] [ / vn1 ] . . . <nl> + { <nl> + if ( splitData . length > 4 ) <nl> + FMLLog . warning ( " OBJModel . Parser : found a face ( ' f ' ) with more than 4 vertices , only the first 4 of these vertices will be rendered ! " ) ; <nl> <nl> - List < Vertex > v = Lists . newArrayListWithCapacity ( splitData . length ) ; <nl> - / / List < TextureCoordinate > t = Lists . newArrayListWithCapacity ( splitData . length ) ; <nl> - / / List < Normal > n = Lists . newArrayListWithCapacity ( splitData . length ) ; <nl> + List < Vertex > v = Lists . newArrayListWithCapacity ( splitData . length ) ; <nl> <nl> - for ( int i = 0 ; i < splitData . length ; i + + ) <nl> - { <nl> - if ( splitData [ i ] . contains ( " / / " ) ) <nl> + for ( int i = 0 ; i < splitData . length ; i + + ) <nl> { <nl> - splitSlash [ i ] = splitData [ i ] . split ( " / / " ) ; <nl> + String [ ] pts = splitData [ i ] . split ( " / " ) ; <nl> <nl> - vert = Integer . parseInt ( splitSlash [ i ] [ 0 ] ) ; <nl> - vert = vert < 0 ? this . vertices . size ( ) - 1 : vert - 1 ; <nl> - norm = Integer . parseInt ( splitSlash [ i ] [ 1 ] ) ; <nl> - norm = norm < 0 ? this . normals . size ( ) - 1 : norm - 1 ; <nl> + int vert = Integer . parseInt ( pts [ 0 ] ) ; <nl> + Integer texture = pts . length < 2 | | Strings . isEmpty ( pts [ 1 ] ) ? null : Integer . parseInt ( pts [ 1 ] ) ; <nl> + Integer normal = pts . length < 3 | | Strings . isEmpty ( pts [ 2 ] ) ? null : Integer . parseInt ( pts [ 2 ] ) ; <nl> <nl> + vert = vert < 0 ? this . vertices . size ( ) - 1 : vert - 1 ; <nl> Vertex newV = new Vertex ( new Vector4f ( this . vertices . get ( vert ) . getPos ( ) ) , this . vertices . get ( vert ) . getMaterial ( ) ) ; <nl> - newV . setNormal ( this . normals . get ( norm ) ) ; <nl> + <nl> + if ( texture ! = null ) <nl> + newV . setTextureCoordinate ( this . texCoords . get ( texture < 0 ? this . texCoords . size ( ) - 1 : texture - 1 ) ) ; <nl> + if ( normal ! = null ) <nl> + newV . setNormal ( this . normals . get ( normal < 0 ? this . normals . size ( ) - 1 : normal - 1 ) ) ; <nl> <nl> v . add ( newV ) ; <nl> - / / n . add ( this . normals . get ( norm ) ) ; <nl> } <nl> - else if ( splitData [ i ] . contains ( " / " ) ) <nl> - { <nl> - splitSlash [ i ] = splitData [ i ] . split ( " / " ) ; <nl> <nl> - vert = Integer . parseInt ( splitSlash [ i ] [ 0 ] ) ; <nl> - vert = vert < 0 ? this . vertices . size ( ) - 1 : vert - 1 ; <nl> - texCoord = Integer . parseInt ( splitSlash [ i ] [ 1 ] ) ; <nl> - texCoord = texCoord < 0 ? this . texCoords . size ( ) - 1 : texCoord - 1 ; <nl> - if ( splitSlash [ i ] . length > 2 ) <nl> + Vertex [ ] va = v . toArray ( new Vertex [ v . size ( ) ] ) ; <nl> + <nl> + Face face = new Face ( va , material . name ) ; <nl> + if ( usemtlCounter < this . vertices . size ( ) ) <nl> + { <nl> + for ( Vertex ver : face . getVertices ( ) ) <nl> { <nl> - norm = Integer . parseInt ( splitSlash [ i ] [ 2 ] ) ; <nl> - norm = norm < 0 ? this . normals . size ( ) - 1 : norm - 1 ; <nl> + ver . setMaterial ( material ) ; <nl> } <nl> - <nl> - Vertex newV = new Vertex ( new Vector4f ( this . vertices . get ( vert ) . getPos ( ) ) , this . vertices . get ( vert ) . getMaterial ( ) ) ; <nl> - newV . setTextureCoordinate ( this . texCoords . get ( texCoord ) ) ; <nl> - newV . setNormal ( splitSlash [ i ] . length > 2 ? this . normals . get ( norm ) : null ) ; <nl> - <nl> - v . add ( newV ) ; <nl> - / / t . add ( this . texCoords . get ( texCoord ) ) ; <nl> - / / if ( splitSlash [ i ] . length > 2 ) n . add ( this . normals . get ( norm ) ) ; <nl> } <nl> - else <nl> - { <nl> - splitSlash [ i ] = splitData [ i ] . split ( " " ) ; <nl> - <nl> - vert = Integer . parseInt ( splitSlash [ i ] [ 0 ] ) ; <nl> - vert = vert < 0 ? this . vertices . size ( ) - 1 : vert - 1 ; <nl> <nl> - Vertex newV = new Vertex ( new Vector4f ( this . vertices . get ( vert ) . getPos ( ) ) , this . vertices . get ( vert ) . getMaterial ( ) ) ; <nl> - v . add ( newV ) ; <nl> + if ( groupList . isEmpty ( ) ) <nl> + { <nl> + if ( this . materialLibrary . getGroups ( ) . containsKey ( Group . DEFAULT _ NAME ) ) <nl> + { <nl> + this . materialLibrary . getGroups ( ) . get ( Group . DEFAULT _ NAME ) . addFace ( face ) ; <nl> + } <nl> + else <nl> + { <nl> + Group def = new Group ( Group . DEFAULT _ NAME , null ) ; <nl> + def . addFace ( face ) ; <nl> + this . materialLibrary . getGroups ( ) . put ( Group . DEFAULT _ NAME , def ) ; <nl> + } <nl> } <nl> - } <nl> - <nl> - Vertex [ ] va = new Vertex [ v . size ( ) ] ; <nl> - v . toArray ( va ) ; <nl> - / / TextureCoordinate [ ] ta = new TextureCoordinate [ t . size ( ) ] ; <nl> - / / t . toArray ( ta ) ; <nl> - / / Normal [ ] na = new Normal [ n . size ( ) ] ; <nl> - / / n . toArray ( na ) ; <nl> - Face face = new Face ( va , material . name ) ; <nl> - if ( usemtlCounter < this . vertices . size ( ) ) <nl> - { <nl> - for ( Vertex ver : face . getVertices ( ) ) <nl> + else <nl> { <nl> - ver . setMaterial ( material ) ; <nl> + for ( String s : groupList ) <nl> + { <nl> + if ( this . materialLibrary . getGroups ( ) . containsKey ( s ) ) <nl> + { <nl> + this . materialLibrary . getGroups ( ) . get ( s ) . addFace ( face ) ; <nl> + } <nl> + else <nl> + { <nl> + Group e = new Group ( s , null ) ; <nl> + e . addFace ( face ) ; <nl> + this . materialLibrary . getGroups ( ) . put ( s , e ) ; <nl> + } <nl> + } <nl> } <nl> } <nl> - <nl> - if ( groupList . isEmpty ( ) ) <nl> + else if ( key . equalsIgnoreCase ( " g " ) | | key . equalsIgnoreCase ( " o " ) ) <nl> { <nl> - if ( this . materialLibrary . getGroups ( ) . containsKey ( Group . DEFAULT _ NAME ) ) <nl> + groupList . clear ( ) ; <nl> + if ( key . equalsIgnoreCase ( " g " ) ) <nl> { <nl> - this . materialLibrary . getGroups ( ) . get ( Group . DEFAULT _ NAME ) . addFace ( face ) ; <nl> + String [ ] splitSpace = data . split ( " " ) ; <nl> + for ( String s : splitSpace ) <nl> + groupList . add ( s ) ; <nl> } <nl> else <nl> { <nl> - Group def = new Group ( Group . DEFAULT _ NAME , null ) ; <nl> - def . addFace ( face ) ; <nl> - this . materialLibrary . getGroups ( ) . put ( Group . DEFAULT _ NAME , def ) ; <nl> + groupList . add ( data ) ; <nl> } <nl> } <nl> else <nl> { <nl> - for ( String s : groupList ) <nl> + if ( ! unknownObjectCommands . contains ( key ) ) <nl> { <nl> - if ( this . materialLibrary . getGroups ( ) . containsKey ( s ) ) <nl> - { <nl> - this . materialLibrary . getGroups ( ) . get ( s ) . addFace ( face ) ; <nl> - } <nl> - else <nl> - { <nl> - Group e = new Group ( s , null ) ; <nl> - e . addFace ( face ) ; <nl> - this . materialLibrary . getGroups ( ) . put ( s , e ) ; <nl> - } <nl> + unknownObjectCommands . add ( key ) ; <nl> + FMLLog . info ( " OBJLoader . Parser : command ' % s ' ( model : ' % s ' ) is not currently supported , skipping . Line : % d ' % s ' " , key , objFrom , lineNum , currentLine ) ; <nl> } <nl> } <nl> } <nl> - else if ( key . equalsIgnoreCase ( " g " ) | | key . equalsIgnoreCase ( " o " ) ) <nl> - { <nl> - groupList . clear ( ) ; <nl> - if ( key . equalsIgnoreCase ( " g " ) ) <nl> - { <nl> - String [ ] splitSpace = data . split ( " " ) ; <nl> - for ( String s : splitSpace ) <nl> - groupList . add ( s ) ; <nl> - } <nl> - else <nl> - { <nl> - groupList . add ( data ) ; <nl> - } <nl> - } <nl> - else <nl> + catch ( RuntimeException e ) <nl> { <nl> - if ( ! unknownObjectCommands . contains ( key ) ) <nl> - { <nl> - unknownObjectCommands . add ( key ) ; <nl> - FMLLog . info ( " OBJLoader . Parser : command ' % s ' ( model : ' % s ' ) is not currently supported , skipping " , key , objFrom ) ; <nl> - } <nl> + throw new RuntimeException ( String . format ( " OBJLoader . Parser : Exception parsing line # % d : ` % s ` " , lineNum , currentLine ) , e ) ; <nl> } <nl> } <nl> <nl> - OBJModel model = new OBJModel ( this . materialLibrary , this . objFrom ) ; <nl> - / / model . getMatLib ( ) . setUVBounds ( minUVBounds [ 0 ] , maxUVBounds [ 0 ] , minUVBounds [ 1 ] , maxUVBounds [ 1 ] ) ; <nl> - return model ; <nl> + return new OBJModel ( this . materialLibrary , this . objFrom ) ; <nl> } <nl> } <nl> <nl> @ @ - 825 , 8 + 778 , 8 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData <nl> { <nl> return this . materialName ; <nl> } <nl> - <nl> - public boolean isTriangles ( ) <nl> + <nl> + public boolean isTriangles ( ) <nl> { <nl> return isTri ; <nl> }
NEAREST DIFF (one line): diff - - git a / client / net / minecraftforge / client / model / obj / Face . java b / client / net / minecraftforge / client / model / obj / Face . java <nl> new file mode 100644 <nl> index 0000000 . . f47951b <nl> - - - / dev / null <nl> + + + b / client / net / minecraftforge / client / model / obj / Face . java <nl> @ @ - 0 , 0 + 1 , 84 @ @ <nl> + package net . minecraftforge . client . model . obj ; <nl> + <nl> + import net . minecraft . client . renderer . Tessellator ; <nl> + import net . minecraft . util . Vec3 ; <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import cpw . mods . fml . relauncher . SideOnly ; <nl> + <nl> + @ SideOnly ( Side . CLIENT ) <nl> + public class Face <nl> + { <nl> + <nl> + public Vertex [ ] vertices ; <nl> + public Vertex [ ] vertexNormals ; <nl> + public Vertex faceNormal ; <nl> + public TextureCoordinate [ ] textureCoordinates ; <nl> + <nl> + public void addFaceForRender ( Tessellator tessellator ) <nl> + { <nl> + addFaceForRender ( tessellator , 0 . 0005F ) ; <nl> + } <nl> + <nl> + public void addFaceForRender ( Tessellator tessellator , float textureOffset ) <nl> + { <nl> + if ( faceNormal = = null ) <nl> + { <nl> + faceNormal = this . calculateFaceNormal ( ) ; <nl> + } <nl> + <nl> + tessellator . setNormal ( faceNormal . x , faceNormal . y , faceNormal . z ) ; <nl> + <nl> + float averageU = 0F ; <nl> + float averageV = 0F ; <nl> + <nl> + if ( textureCoordinates . length ! = 0 ) <nl> + { <nl> + for ( int i = 0 ; i < textureCoordinates . length ; + + i ) <nl> + { <nl> + averageU + = textureCoordinates [ i ] . u ; <nl> + averageV + = textureCoordinates [ i ] . v ; <nl> + } <nl> + <nl> + averageU = averageU / textureCoordinates . length ; <nl> + averageV = averageV / textureCoordinates . length ; <nl> + } <nl> + <nl> + float offsetU , offsetV ; <nl> + <nl> + for ( int i = 0 ; i < vertices . length ; + + i ) <nl> + { <nl> + <nl> + if ( textureCoordinates . length ! = 0 ) <nl> + { <nl> + offsetU = textureOffset ; <nl> + offsetV = textureOffset ; <nl> + <nl> + if ( textureCoordinates [ i ] . u > averageU ) <nl> + { <nl> + offsetU = - offsetU ; <nl> + } <nl> + if ( textureCoordinates [ i ] . v > averageV ) <nl> + { <nl> + offsetV = - offsetV ; <nl> + } <nl> + <nl> + tessellator . addVertexWithUV ( vertices [ i ] . x , vertices [ i ] . y , vertices [ i ] . z , textureCoordinates [ i ] . u + offsetU , textureCoordinates [ i ] . v + offsetV ) ; <nl> + } <nl> + else <nl> + { <nl> + tessellator . addVertex ( vertices [ i ] . x , vertices [ i ] . y , vertices [ i ] . z ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public Vertex calculateFaceNormal ( ) <nl> + { <nl> + Vec3 v1 = Vec3 . createVectorHelper ( vertices [ 1 ] . x - vertices [ 0 ] . x , vertices [ 1 ] . y - vertices [ 0 ] . y , vertices [ 1 ] . z - vertices [ 0 ] . z ) ; <nl> + Vec3 v2 = Vec3 . createVectorHelper ( vertices [ 2 ] . x - vertices [ 0 ] . x , vertices [ 2 ] . y - vertices [ 0 ] . y , vertices [ 2 ] . z - vertices [ 0 ] . z ) ; <nl> + Vec3 normalVector = null ; <nl> + <nl> + normalVector = v1 . crossProduct ( v2 ) . normalize ( ) ; <nl> + <nl> + return new Vertex ( ( float ) normalVector . xCoord , ( float ) normalVector . yCoord , ( float ) normalVector . zCoord ) ; <nl> + } <nl> + } <nl> diff - - git a / client / net / minecraftforge / client / model / obj / GroupObject . java b / client / net / minecraftforge / client / model / obj / GroupObject . java <nl> new file mode 100644 <nl> index 0000000 . . 0bf36af <nl> - - - / dev / null <nl> + + + b / client / net / minecraftforge / client / model / obj / GroupObject . java <nl> @ @ - 0 , 0 + 1 , 54 @ @ <nl> + package net . minecraftforge . client . model . obj ; <nl> + <nl> + import java . util . ArrayList ; <nl> + <nl> + import net . minecraft . client . renderer . Tessellator ; <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import cpw . mods . fml . relauncher . SideOnly ; <nl> + <nl> + @ SideOnly ( Side . CLIENT ) <nl> + public class GroupObject <nl> + { <nl> + <nl> + public String name ; <nl> + public ArrayList < Face > faces = new ArrayList < Face > ( ) ; <nl> + public int glDrawingMode ; <nl> + <nl> + public GroupObject ( ) <nl> + { <nl> + this ( " " ) ; <nl> + } <nl> + <nl> + public GroupObject ( String name ) <nl> + { <nl> + this ( name , - 1 ) ; <nl> + } <nl> + <nl> + public GroupObject ( String name , int glDrawingMode ) <nl> + { <nl> + this . name = name ; <nl> + this . glDrawingMode = glDrawingMode ; <nl> + } <nl> + <nl> + public void render ( ) <nl> + { <nl> + if ( faces . size ( ) > 0 ) <nl> + { <nl> + Tessellator tessellator = Tessellator . instance ; <nl> + tessellator . startDrawing ( glDrawingMode ) ; <nl> + render ( tessellator ) ; <nl> + tessellator . draw ( ) ; <nl> + } <nl> + } <nl> + <nl> + public void render ( Tessellator tessellator ) <nl> + { <nl> + if ( faces . size ( ) > 0 ) <nl> + { <nl> + for ( Face face : faces ) <nl> + { <nl> + face . addFaceForRender ( tessellator ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / client / net / minecraftforge / client / model / obj / TextureCoordinate . java b / client / net / minecraftforge / client / model / obj / TextureCoordinate . java <nl> new file mode 100644 <nl> index 0000000 . . 8583905 <nl> - - - / dev / null <nl> + + + b / client / net / minecraftforge / client / model / obj / TextureCoordinate . java <nl> @ @ - 0 , 0 + 1 , 23 @ @ <nl> + package net . minecraftforge . client . model . obj ; <nl> + <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import cpw . mods . fml . relauncher . SideOnly ; <nl> + <nl> + @ SideOnly ( Side . CLIENT ) <nl> + public class TextureCoordinate <nl> + { <nl> + <nl> + public float u , v , w ; <nl> + <nl> + public TextureCoordinate ( float u , float v ) <nl> + { <nl> + this ( u , v , 0F ) ; <nl> + } <nl> + <nl> + public TextureCoordinate ( float u , float v , float w ) <nl> + { <nl> + this . u = u ; <nl> + this . v = v ; <nl> + this . w = w ; <nl> + } <nl> + } <nl> diff - - git a / client / net / minecraftforge / client / model / obj / Vertex . java b / client / net / minecraftforge / client / model / obj / Vertex . java <nl> new file mode 100644 <nl> index 0000000 . . c4ecf35 <nl> - - - / dev / null <nl> + + + b / client / net / minecraftforge / client / model / obj / Vertex . java <nl> @ @ - 0 , 0 + 1 , 23 @ @ <nl> + package net . minecraftforge . client . model . obj ; <nl> + <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import cpw . mods . fml . relauncher . SideOnly ; <nl> + <nl> + @ SideOnly ( Side . CLIENT ) <nl> + public class Vertex <nl> + { <nl> + <nl> + public float x , y , z ; <nl> + <nl> + public Vertex ( float x , float y ) <nl> + { <nl> + this ( x , y , 0F ) ; <nl> + } <nl> + <nl> + public Vertex ( float x , float y , float z ) <nl> + { <nl> + this . x = x ; <nl> + this . y = y ; <nl> + this . z = z ; <nl> + } <nl> + } <nl> diff - - git a / client / net / minecraftforge / client / model / obj / WavefrontObject . java b / client / net / minecraftforge / client / model / obj / WavefrontObject . java <nl> new file mode 100644 <nl> index 0000000 . . 42934f8 <nl> - - - / dev / null <nl> + + + b / client / net / minecraftforge / client / model / obj / WavefrontObject . java <nl> @ @ - 0 , 0 + 1 , 447 @ @ <nl> + package net . minecraftforge . client . model . obj ; <nl> + <nl> + import java . io . BufferedReader ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStream ; <nl> + import java . io . InputStreamReader ; <nl> + import java . net . URL ; <nl> + import java . text . ParseException ; <nl> + import java . util . ArrayList ; <nl> + <nl> + import net . minecraft . client . renderer . Tessellator ; <nl> + <nl> + import org . lwjgl . opengl . GL11 ; <nl> + <nl> + import cpw . mods . fml . relauncher . Side ; <nl> + import cpw . mods . fml . relauncher . SideOnly ; <nl> + <nl> + @ SideOnly ( Side . CLIENT ) <nl> + public class WavefrontObject <nl> + { <nl> + <nl> + private static final String REGEX _ VERTEX = " ( v ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * \ \ n ) | ( v ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * $ ) " ; <nl> + private static final String REGEX _ VERTEX _ NORMAL = " ( vn ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * \ \ n ) | ( vn ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * $ ) " ; <nl> + private static final String REGEX _ TEXTURE _ COORDINATE = " ( vt ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * \ \ n ) | ( vt ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * $ ) " ; <nl> + private static final String REGEX _ FACE _ VERTEX _ TEXTURECOORD _ VERTEXNORMAL = " ( f ( \ \ d + / \ \ d + / \ \ d + ) { 3 , 4 } * \ \ n ) | ( f ( \ \ d + / \ \ d + / \ \ d + ) { 3 , 4 } * $ ) " ; <nl> + private static final String REGEX _ FACE _ VERTEX _ TEXTURECOORD = " ( f ( \ \ d + / \ \ d + ) { 3 , 4 } * \ \ n ) | ( f ( \ \ d + / \ \ d + ) { 3 , 4 } * $ ) " ; <nl> + private static final String REGEX _ FACE _ VERTEX _ VERTEXNORMAL = " ( f ( \ \ d + / / \ \ d + ) { 3 , 4 } * \ \ n ) | ( f ( \ \ d + / / \ \ d + ) { 3 , 4 } * $ ) " ; <nl> + private static final String REGEX _ FACE _ VERTEX = " ( f ( \ \ d + ) { 3 , 4 } * \ \ n ) | ( f ( \ \ d + ) { 3 , 4 } * $ ) " ; <nl> + private static final String REGEX _ GROUP _ OBJECT = " ( [ go ] ( [ \ \ w \ \ d ] + ) * \ \ n ) | ( [ go ] ( [ \ \ w \ \ d ] + ) * $ ) " ; <nl> + <nl> + public ArrayList < Vertex > vertices = new ArrayList < Vertex > ( ) ; <nl> + public ArrayList < Vertex > vertexNormals = new ArrayList < Vertex > ( ) ; <nl> + public ArrayList < TextureCoordinate > textureCoordinates = new ArrayList < TextureCoordinate > ( ) ; <nl> + public ArrayList < GroupObject > groupObjects = new ArrayList < GroupObject > ( ) ; <nl> + private GroupObject currentGroupObject ; <nl> + <nl> + public WavefrontObject ( String fileName ) <nl> + { <nl> + try <nl> + { <nl> + parseObjModel ( this . getClass ( ) . getResource ( fileName ) ) ; <nl> + } <nl> + catch ( ParseException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + public WavefrontObject ( URL fileURL ) <nl> + { <nl> + try <nl> + { <nl> + parseObjModel ( fileURL ) ; <nl> + } <nl> + catch ( ParseException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + private void parseObjModel ( URL fileURL ) throws ParseException <nl> + { <nl> + BufferedReader reader = null ; <nl> + InputStream inputStream = null ; <nl> + <nl> + String currentLine = null ; <nl> + int lineCount = 0 ; <nl> + <nl> + try <nl> + { <nl> + inputStream = fileURL . openStream ( ) ; <nl> + reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; <nl> + <nl> + while ( ( currentLine = reader . readLine ( ) ) ! = null ) <nl> + { <nl> + lineCount + + ; <nl> + currentLine = currentLine . replaceAll ( " \ \ s + " , " " ) . trim ( ) ; <nl> + <nl> + if ( currentLine . startsWith ( " # " ) | | currentLine . length ( ) = = 0 ) <nl> + { <nl> + continue ; <nl> + } <nl> + else if ( currentLine . startsWith ( " v " ) ) <nl> + { <nl> + Vertex vertex = parseVertex ( currentLine ) ; <nl> + if ( vertex ! = null ) <nl> + { <nl> + vertices . add ( vertex ) ; <nl> + } <nl> + else <nl> + { <nl> + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; <nl> + } <nl> + } <nl> + else if ( currentLine . startsWith ( " vn " ) ) <nl> + { <nl> + Vertex vertex = parseVertexNormal ( currentLine ) ; <nl> + if ( vertex ! = null ) <nl> + { <nl> + vertexNormals . add ( vertex ) ; <nl> + } <nl> + else <nl> + { <nl> + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; <nl> + } <nl> + } <nl> + else if ( currentLine . startsWith ( " vt " ) ) <nl> + { <nl> + TextureCoordinate textureCoordinate = parseTextureCoordinate ( currentLine ) ; <nl> + if ( textureCoordinate ! = null ) <nl> + { <nl> + textureCoordinates . add ( textureCoordinate ) ; <nl> + } <nl> + else <nl> + { <nl> + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; <nl> + } <nl> + } <nl> + else if ( currentLine . startsWith ( " f " ) ) <nl> + { <nl> + <nl> + if ( currentGroupObject = = null ) <nl> + { <nl> + currentGroupObject = new GroupObject ( " Default " ) ; <nl> + } <nl> + <nl> + Face face = parseFace ( currentLine ) ; <nl> + <nl> + if ( face ! = null ) <nl> + { <nl> + currentGroupObject . faces . add ( face ) ; <nl> + } <nl> + else <nl> + { <nl> + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; <nl> + } <nl> + } <nl> + else if ( currentLine . startsWith ( " g " ) | currentLine . startsWith ( " o " ) ) <nl> + { <nl> + GroupObject group = parseGroupObject ( currentLine ) ; <nl> + <nl> + if ( group ! = null ) <nl> + { <nl> + if ( currentGroupObject ! = null ) <nl> + { <nl> + groupObjects . add ( currentGroupObject ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; <nl> + } <nl> + <nl> + currentGroupObject = group ; <nl> + } <nl> + } <nl> + <nl> + groupObjects . add ( currentGroupObject ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + finally <nl> + { <nl> + try <nl> + { <nl> + reader . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + try <nl> + { <nl> + inputStream . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public void renderAll ( ) <nl> + { <nl> + Tessellator tessellator = Tessellator . instance ; <nl> + <nl> + if ( currentGroupObject ! = null ) <nl> + { <nl> + tessellator . startDrawing ( currentGroupObject . glDrawingMode ) ; <nl> + } <nl> + else <nl> + { <nl> + tessellator . startDrawing ( GL11 . GL _ TRIANGLES ) ; <nl> + } <nl> + <nl> + for ( GroupObject groupObject : groupObjects ) <nl> + { <nl> + groupObject . render ( tessellator ) ; <nl> + } <nl> + <nl> + tessellator . draw ( ) ; <nl> + } <nl> + <nl> + public void renderOnly ( String . . . groupNames ) <nl> + { <nl> + for ( GroupObject groupObject : groupObjects ) <nl> + { <nl> + for ( String groupName : groupNames ) <nl> + { <nl> + if ( groupName . equalsIgnoreCase ( groupObject . name ) ) <nl> + { <nl> + groupObject . render ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + public void renderAllExcept ( String . . . excludedGroupNames ) <nl> + { <nl> + for ( GroupObject groupObject : groupObjects ) <nl> + { <nl> + for ( String excludedGroupName : excludedGroupNames ) <nl> + { <nl> + if ( ! excludedGroupName . equalsIgnoreCase ( groupObject . name ) ) <nl> + { <nl> + groupObject . render ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + private Vertex parseVertex ( String line ) <nl> + { <nl> + Vertex vertex = null ; <nl> + <nl> + if ( isValidVertexLine ( line ) ) <nl> + { <nl> + line = line . substring ( line . indexOf ( " " ) + 1 ) ; <nl> + String [ ] tokens = line . split ( " " ) ; <nl> + <nl> + try <nl> + { <nl> + if ( tokens . length = = 3 ) <nl> + return new Vertex ( Float . parseFloat ( tokens [ 0 ] ) , Float . parseFloat ( tokens [ 1 ] ) , Float . parseFloat ( tokens [ 2 ] ) ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + return vertex ; <nl> + } <nl> + <nl> + private Vertex parseVertexNormal ( String line ) <nl> + { <nl> + Vertex vertexNormal = null ; <nl> + <nl> + if ( isValidVertexNormalLine ( line ) ) <nl> + { <nl> + line = line . substring ( line . indexOf ( " " ) + 1 ) ; <nl> + String [ ] tokens = line . split ( " " ) ; <nl> + <nl> + try <nl> + { <nl> + if ( tokens . length = = 3 ) <nl> + return new Vertex ( Float . parseFloat ( tokens [ 0 ] ) , Float . parseFloat ( tokens [ 1 ] ) , Float . parseFloat ( tokens [ 2 ] ) ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + return vertexNormal ; <nl> + } <nl> + <nl> + private TextureCoordinate parseTextureCoordinate ( String line ) <nl> + { <nl> + TextureCoordinate textureCoordinate = null ; <nl> + <nl> + if ( isValidTextureCoordinateLine ( line ) ) <nl> + { <nl> + line = line . substring ( line . indexOf ( " " ) + 1 ) ; <nl> + String [ ] tokens = line . split ( " " ) ; <nl> + <nl> + try <nl> + { <nl> + if ( tokens . length = = 2 ) <nl> + return new TextureCoordinate ( Float . parseFloat ( tokens [ 0 ] ) , 1 - Float . parseFloat ( tokens [ 1 ] ) ) ; <nl> + else if ( tokens . length = = 3 ) <nl> + return new TextureCoordinate ( Float . parseFloat ( tokens [ 0 ] ) , 1 - Float . parseFloat ( tokens [ 1 ] ) , Float . parseFloat ( tokens [ 2 ] ) ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + return textureCoordinate ; <nl> + } <nl> + <nl> + private Face parseFace ( String line ) <nl> + { <nl> + Face face = null ; <nl> + <nl> + if ( isValidFaceLine ( line ) ) <nl> + { <nl> + face = new Face ( ) ; <nl> + <nl> + String trimmedLine = line . substring ( line . indexOf ( " " ) + 1 ) ; <nl> + String [ ] tokens = trimmedLine . split ( " " ) ; <nl> + String [ ] subTokens = null ; <nl> + <nl> + if ( tokens . length = = 3 ) <nl> + { <nl> + if ( currentGroupObject . glDrawingMode = = - 1 ) <nl> + { <nl> + currentGroupObject . glDrawingMode = GL11 . GL _ TRIANGLES ; <nl> + } <nl> + else if ( currentGroupObject . glDrawingMode ! = GL11 . GL _ TRIANGLES ) <nl> + { <nl> + return null ; <nl> + } <nl> + } <nl> + else if ( tokens . length = = 4 ) <nl> + { <nl> + if ( currentGroupObject . glDrawingMode = = - 1 ) <nl> + { <nl> + currentGroupObject . glDrawingMode = GL11 . GL _ QUADS ; <nl> + } <nl> + else if ( currentGroupObject . glDrawingMode ! = GL11 . GL _ QUADS ) <nl> + { <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + face . vertices = new Vertex [ tokens . length ] ; <nl> + face . textureCoordinates = new TextureCoordinate [ tokens . length ] ; <nl> + face . vertexNormals = new Vertex [ tokens . length ] ; <nl> + <nl> + / / f v1 / vt1 / vn1 v2 / vt2 / vn2 v3 / vt3 / vn3 . . . <nl> + if ( line . matches ( REGEX _ FACE _ VERTEX _ TEXTURECOORD _ VERTEXNORMAL ) ) <nl> + { <nl> + for ( int i = 0 ; i < tokens . length ; + + i ) <nl> + { <nl> + subTokens = tokens [ i ] . split ( " / " ) ; <nl> + <nl> + face . vertices [ i ] = vertices . get ( Integer . parseInt ( subTokens [ 0 ] ) - 1 ) ; <nl> + face . textureCoordinates [ i ] = textureCoordinates . get ( Integer . parseInt ( subTokens [ 1 ] ) - 1 ) ; <nl> + face . vertexNormals [ i ] = vertexNormals . get ( Integer . parseInt ( subTokens [ 2 ] ) - 1 ) ; <nl> + } <nl> + <nl> + face . faceNormal = face . calculateFaceNormal ( ) ; <nl> + } <nl> + / / f v1 / vt1 v2 / vt2 v3 / vt3 . . . <nl> + else if ( line . matches ( REGEX _ FACE _ VERTEX _ TEXTURECOORD ) ) <nl> + { <nl> + for ( int i = 0 ; i < tokens . length ; + + i ) <nl> + { <nl> + subTokens = tokens [ i ] . split ( " / " ) ; <nl> + <nl> + face . vertices [ i ] = vertices . get ( Integer . parseInt ( subTokens [ 0 ] ) - 1 ) ; <nl> + face . textureCoordinates [ i ] = textureCoordinates . get ( Integer . parseInt ( subTokens [ 1 ] ) - 1 ) ; <nl> + } <nl> + <nl> + face . faceNormal = face . calculateFaceNormal ( ) ; <nl> + } <nl> + / / f v1 / / vn1 v2 / / vn2 v3 / / vn3 . . . <nl> + else if ( line . matches ( REGEX _ FACE _ VERTEX _ VERTEXNORMAL ) ) <nl> + { <nl> + for ( int i = 0 ; i < tokens . length ; + + i ) <nl> + { <nl> + subTokens = tokens [ i ] . split ( " / / " ) ; <nl> + <nl> + face . vertices [ i ] = vertices . get ( Integer . parseInt ( subTokens [ 0 ] ) - 1 ) ; <nl> + face . vertexNormals [ i ] = vertexNormals . get ( Integer . parseInt ( subTokens [ 1 ] ) - 1 ) ; <nl> + } <nl> + <nl> + face . faceNormal = face . calculateFaceNormal ( ) ; <nl> + } <nl> + / / f v1 v2 v3 . . . <nl> + else if ( line . matches ( REGEX _ FACE _ VERTEX ) ) <nl> + { <nl> + for ( int i = 0 ; i < tokens . length ; + + i ) <nl> + { <nl> + face . vertices [ i ] = vertices . get ( Integer . parseInt ( tokens [ i ] ) - 1 ) ; <nl> + } <nl> + <nl> + face . faceNormal = face . calculateFaceNormal ( ) ; <nl> + } <nl> + else <nl> + throw new IllegalArgumentException ( ) ; <nl> + } <nl> + <nl> + return face ; <nl> + } <nl> + <nl> + private GroupObject parseGroupObject ( String line ) <nl> + { <nl> + GroupObject group = null ; <nl> + <nl> + if ( isValidGroupObjectLine ( line ) ) <nl> + { <nl> + String trimmedLine = line . substring ( line . indexOf ( " " ) + 1 ) ; <nl> + <nl> + if ( trimmedLine . length ( ) > 0 ) <nl> + { <nl> + group = new GroupObject ( trimmedLine ) ; <nl> + } <nl> + } <nl> + <nl> + return group ; <nl> + } <nl> + <nl> + private static boolean isValidVertexLine ( String line ) <nl> + { <nl> + <nl> + return line . matches ( REGEX _ VERTEX ) ; <nl> + } <nl> + <nl> + private static boolean isValidVertexNormalLine ( String line ) <nl> + { <nl> + <nl> + return line . matches ( REGEX _ VERTEX _ NORMAL ) ; <nl> + } <nl> + <nl> + private static boolean isValidTextureCoordinateLine ( String line ) <nl> + { <nl> + <nl> + return line . matches ( REGEX _ TEXTURE _ COORDINATE ) ; <nl> + } <nl> + <nl> + private static boolean isValidFaceLine ( String line ) <nl> + { <nl> + <nl> + return line . matches ( REGEX _ FACE _ VERTEX _ TEXTURECOORD _ VERTEXNORMAL ) | | line . matches ( REGEX _ FACE _ VERTEX _ TEXTURECOORD ) | | line . matches ( REGEX _ FACE _ VERTEX _ VERTEXNORMAL ) | | line . matches ( REGEX _ FACE _ VERTEX ) ; <nl> + } <nl> + <nl> + private static boolean isValidGroupObjectLine ( String line ) <nl> + { <nl> + <nl> + return line . matches ( REGEX _ GROUP _ OBJECT ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java b / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java 
 index 4aba809 . . 88844c6 100644 
 - - - a / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java 
 + + + b / src / main / java / net / minecraftforge / client / model / obj / OBJModel . java 
 @ @ - 45 , 6 + 45 , 7 @ @ import net . minecraftforge . common . property . IUnlistedProperty ; 
 import net . minecraftforge . fml . common . FMLLog ; 
 
 import org . apache . commons . lang3 . tuple . Pair ; 
 + import org . apache . logging . log4j . core . helpers . Strings ; 
 
 import com . google . common . base . Charsets ; 
 import com . google . common . base . Function ; 
 @ @ - 201 , 212 + 202 , 164 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData 
 return this . groupList ; 
 } 
 
 + private float [ ] parseFloats ( String [ ] data ) / / Helper converting strings to floats 
 + { 
 + float [ ] ret = new float [ data . length ] ; 
 + for ( int i = 0 ; i < data . length ; i + + ) 
 + ret [ i ] = Float . parseFloat ( data [ i ] ) ; 
 + return ret ; 
 + } 
 + 
 + / / Partial reading of the OBJ format . Documentation taken from http : / / paulbourke . net / dataformats / obj / 
 public OBJModel parse ( ) throws IOException 
 { 
 String currentLine = " " ; 
 Material material = new Material ( ) ; 
 material . setName ( Material . DEFAULT _ NAME ) ; 
 int usemtlCounter = 0 ; 
 - 
 - / / float [ ] minUVBounds = new float [ ] { 0 . 0f , 0 . 0f } ; 
 - / / float [ ] maxUVBounds = new float [ ] { 1 . 0f , 1 . 0f } ; 
 + int lineNum = 0 ; 
 
 for ( ; ; ) 
 { 
 + lineNum + + ; 
 currentLine = objReader . readLine ( ) ; 
 if ( currentLine = = null ) break ; 
 currentLine . trim ( ) ; 
 if ( currentLine . isEmpty ( ) | | currentLine . startsWith ( " # " ) ) continue ; 
 
 - String [ ] fields = WHITE _ SPACE . split ( currentLine , 2 ) ; 
 - String key = fields [ 0 ] ; 
 - String data = fields [ 1 ] ; 
 - String [ ] splitData = WHITE _ SPACE . split ( data ) ; 
 - 
 - if ( key . equalsIgnoreCase ( " mtllib " ) ) 
 - this . materialLibrary . parseMaterials ( manager , data , objFrom ) ; 
 - else if ( key . equalsIgnoreCase ( " usemtl " ) ) 
 - { 
 - material = this . materialLibrary . materials . get ( data ) ; 
 - usemtlCounter + + ; 
 - } 
 - else if ( key . equalsIgnoreCase ( " v " ) ) 
 - { 
 - float [ ] floatSplitData = new float [ splitData . length ] ; 
 - for ( int i = 0 ; i < splitData . length ; i + + ) 
 - floatSplitData [ i ] = Float . parseFloat ( splitData [ i ] ) ; 
 - Vector4f pos = new Vector4f ( floatSplitData [ 0 ] , floatSplitData [ 1 ] , floatSplitData [ 2 ] , floatSplitData . length = = 4 ? floatSplitData [ 3 ] : 1 ) ; 
 - Vertex vertex = new Vertex ( pos , material ) ; 
 - this . vertices . add ( vertex ) ; 
 - } 
 - else if ( key . equalsIgnoreCase ( " vn " ) ) 
 - { 
 - float [ ] floatSplitData = new float [ splitData . length ] ; 
 - for ( int i = 0 ; i < splitData . length ; i + + ) 
 - floatSplitData [ i ] = Float . parseFloat ( splitData [ i ] ) ; 
 - Normal normal = new Normal ( floatSplitData ) ; 
 - this . normals . add ( normal ) ; 
 - } 
 - else if ( key . equalsIgnoreCase ( " vt " ) ) 
 + try 
 { 
 - float [ ] floatSplitData = new float [ splitData . length ] ; 
 - for ( int i = 0 ; i < splitData . length ; i + + ) 
 - floatSplitData [ i ] = Float . parseFloat ( splitData [ i ] ) ; 
 - TextureCoordinate texCoord = new TextureCoordinate ( new Vector3f ( floatSplitData [ 0 ] , floatSplitData [ 1 ] , floatSplitData . length = = 3 ? floatSplitData [ 2 ] : 1 ) ) ; 
 - if ( texCoord . u < 0 . 0f | | texCoord . u > 1 . 0f | | texCoord . v < 0 . 0f | | texCoord . v > 1 . 0f ) 
 - throw new UVsOutOfBoundsException ( this . objFrom ) ; 
 - / / this . UVsOutOfBounds = ( texCoord . u < 0 . 0f | | texCoord . u > 1 . 0f | | texCoord . v < 0 . 0f | | texCoord . v > 1 . 0f ) ; 
 - 
 - / / if ( texCoord . u < 0 . 0f | | texCoord . u > 1 . 0f | | texCoord . v < 0 . 0f | | texCoord . v > 1 . 0f ) 
 - / / { 
 - / / this . UVsOutOfBounds = true ; 
 - / / texCoord . u - = Math . floor ( texCoord . u ) ; 
 - / / texCoord . v - = Math . floor ( texCoord . v ) ; 
 - / / } 
 - 
 - / / minUVBounds [ 0 ] = floatSplitData [ 0 ] < minUVBounds [ 0 ] ? floatSplitData [ 0 ] : minUVBounds [ 0 ] ; 
 - / / minUVBounds [ 1 ] = floatSplitData [ 1 ] < minUVBounds [ 1 ] ? floatSplitData [ 1 ] : minUVBounds [ 1 ] ; 
 - / / maxUVBounds [ 0 ] = floatSplitData [ 0 ] > maxUVBounds [ 0 ] ? floatSplitData [ 0 ] : maxUVBounds [ 0 ] ; 
 - / / maxUVBounds [ 1 ] = floatSplitData [ 1 ] > maxUVBounds [ 1 ] ? floatSplitData [ 1 ] : maxUVBounds [ 1 ] ; 
 - / / FMLLog . info ( " u : [ % f , % f ] v : [ % f , % f ] " , minUVBounds [ ] ) ; 
 - this . texCoords . add ( texCoord ) ; 
 - } 
 - else if ( key . equalsIgnoreCase ( " f " ) ) 
 - { 
 - String [ ] [ ] splitSlash = new String [ splitData . length ] [ ] ; 
 - if ( splitData . length > 4 ) FMLLog . warning ( " OBJModel . Parser : found a face ( ' f ' ) with more than 4 vertices , only the first 4 of these vertices will be rendered ! " ) ; 
 + String [ ] fields = WHITE _ SPACE . split ( currentLine , 2 ) ; 
 + String key = fields [ 0 ] ; 
 + String data = fields [ 1 ] ; 
 + String [ ] splitData = WHITE _ SPACE . split ( data ) ; 
 
 - int vert = 0 ; 
 - int texCoord = 0 ; 
 - int norm = 0 ; 
 + if ( key . equalsIgnoreCase ( " mtllib " ) ) 
 + { 
 + this . materialLibrary . parseMaterials ( manager , data , objFrom ) ; 
 + } 
 + else if ( key . equalsIgnoreCase ( " usemtl " ) ) 
 + { 
 + material = this . materialLibrary . materials . get ( data ) ; 
 + usemtlCounter + + ; 
 + } 
 + else if ( key . equalsIgnoreCase ( " v " ) ) / / Vertices : x y z [ w ] - w Defaults to 1 . 0 
 + { 
 + float [ ] coords = parseFloats ( splitData ) ; 
 + Vector4f pos = new Vector4f ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords . length = = 4 ? coords [ 3 ] : 1 . 0F ) ; 
 + this . vertices . add ( new Vertex ( pos , material ) ) ; 
 + } 
 + else if ( key . equalsIgnoreCase ( " vn " ) ) / / Vertex normals : x y z 
 + { 
 + this . normals . add ( new Normal ( parseFloats ( splitData ) ) ) ; 
 + } 
 + else if ( key . equalsIgnoreCase ( " vt " ) ) / / Vertex Textures : u [ v ] [ w ] - v / w Defaults to 0 
 + { 
 + float [ ] coords = parseFloats ( splitData ) ; 
 + TextureCoordinate texCoord = new TextureCoordinate ( coords [ 0 ] , 
 + coords . length > = 2 ? coords [ 1 ] : 0 . 0F , 
 + coords . length > = 3 ? coords [ 2 ] : 0 . 0F ) ; 
 + if ( texCoord . u < 0 . 0f | | texCoord . u > 1 . 0f | | texCoord . v < 0 . 0f | | texCoord . v > 1 . 0f ) 
 + throw new UVsOutOfBoundsException ( this . objFrom ) ; 
 + this . texCoords . add ( texCoord ) ; 
 + } 
 + else if ( key . equalsIgnoreCase ( " f " ) ) / / Face Elements : f v1 [ / vt1 ] [ / vn1 ] . . . 
 + { 
 + if ( splitData . length > 4 ) 
 + FMLLog . warning ( " OBJModel . Parser : found a face ( ' f ' ) with more than 4 vertices , only the first 4 of these vertices will be rendered ! " ) ; 
 
 - List < Vertex > v = Lists . newArrayListWithCapacity ( splitData . length ) ; 
 - / / List < TextureCoordinate > t = Lists . newArrayListWithCapacity ( splitData . length ) ; 
 - / / List < Normal > n = Lists . newArrayListWithCapacity ( splitData . length ) ; 
 + List < Vertex > v = Lists . newArrayListWithCapacity ( splitData . length ) ; 
 
 - for ( int i = 0 ; i < splitData . length ; i + + ) 
 - { 
 - if ( splitData [ i ] . contains ( " / / " ) ) 
 + for ( int i = 0 ; i < splitData . length ; i + + ) 
 { 
 - splitSlash [ i ] = splitData [ i ] . split ( " / / " ) ; 
 + String [ ] pts = splitData [ i ] . split ( " / " ) ; 
 
 - vert = Integer . parseInt ( splitSlash [ i ] [ 0 ] ) ; 
 - vert = vert < 0 ? this . vertices . size ( ) - 1 : vert - 1 ; 
 - norm = Integer . parseInt ( splitSlash [ i ] [ 1 ] ) ; 
 - norm = norm < 0 ? this . normals . size ( ) - 1 : norm - 1 ; 
 + int vert = Integer . parseInt ( pts [ 0 ] ) ; 
 + Integer texture = pts . length < 2 | | Strings . isEmpty ( pts [ 1 ] ) ? null : Integer . parseInt ( pts [ 1 ] ) ; 
 + Integer normal = pts . length < 3 | | Strings . isEmpty ( pts [ 2 ] ) ? null : Integer . parseInt ( pts [ 2 ] ) ; 
 
 + vert = vert < 0 ? this . vertices . size ( ) - 1 : vert - 1 ; 
 Vertex newV = new Vertex ( new Vector4f ( this . vertices . get ( vert ) . getPos ( ) ) , this . vertices . get ( vert ) . getMaterial ( ) ) ; 
 - newV . setNormal ( this . normals . get ( norm ) ) ; 
 + 
 + if ( texture ! = null ) 
 + newV . setTextureCoordinate ( this . texCoords . get ( texture < 0 ? this . texCoords . size ( ) - 1 : texture - 1 ) ) ; 
 + if ( normal ! = null ) 
 + newV . setNormal ( this . normals . get ( normal < 0 ? this . normals . size ( ) - 1 : normal - 1 ) ) ; 
 
 v . add ( newV ) ; 
 - / / n . add ( this . normals . get ( norm ) ) ; 
 } 
 - else if ( splitData [ i ] . contains ( " / " ) ) 
 - { 
 - splitSlash [ i ] = splitData [ i ] . split ( " / " ) ; 
 
 - vert = Integer . parseInt ( splitSlash [ i ] [ 0 ] ) ; 
 - vert = vert < 0 ? this . vertices . size ( ) - 1 : vert - 1 ; 
 - texCoord = Integer . parseInt ( splitSlash [ i ] [ 1 ] ) ; 
 - texCoord = texCoord < 0 ? this . texCoords . size ( ) - 1 : texCoord - 1 ; 
 - if ( splitSlash [ i ] . length > 2 ) 
 + Vertex [ ] va = v . toArray ( new Vertex [ v . size ( ) ] ) ; 
 + 
 + Face face = new Face ( va , material . name ) ; 
 + if ( usemtlCounter < this . vertices . size ( ) ) 
 + { 
 + for ( Vertex ver : face . getVertices ( ) ) 
 { 
 - norm = Integer . parseInt ( splitSlash [ i ] [ 2 ] ) ; 
 - norm = norm < 0 ? this . normals . size ( ) - 1 : norm - 1 ; 
 + ver . setMaterial ( material ) ; 
 } 
 - 
 - Vertex newV = new Vertex ( new Vector4f ( this . vertices . get ( vert ) . getPos ( ) ) , this . vertices . get ( vert ) . getMaterial ( ) ) ; 
 - newV . setTextureCoordinate ( this . texCoords . get ( texCoord ) ) ; 
 - newV . setNormal ( splitSlash [ i ] . length > 2 ? this . normals . get ( norm ) : null ) ; 
 - 
 - v . add ( newV ) ; 
 - / / t . add ( this . texCoords . get ( texCoord ) ) ; 
 - / / if ( splitSlash [ i ] . length > 2 ) n . add ( this . normals . get ( norm ) ) ; 
 } 
 - else 
 - { 
 - splitSlash [ i ] = splitData [ i ] . split ( " " ) ; 
 - 
 - vert = Integer . parseInt ( splitSlash [ i ] [ 0 ] ) ; 
 - vert = vert < 0 ? this . vertices . size ( ) - 1 : vert - 1 ; 
 
 - Vertex newV = new Vertex ( new Vector4f ( this . vertices . get ( vert ) . getPos ( ) ) , this . vertices . get ( vert ) . getMaterial ( ) ) ; 
 - v . add ( newV ) ; 
 + if ( groupList . isEmpty ( ) ) 
 + { 
 + if ( this . materialLibrary . getGroups ( ) . containsKey ( Group . DEFAULT _ NAME ) ) 
 + { 
 + this . materialLibrary . getGroups ( ) . get ( Group . DEFAULT _ NAME ) . addFace ( face ) ; 
 + } 
 + else 
 + { 
 + Group def = new Group ( Group . DEFAULT _ NAME , null ) ; 
 + def . addFace ( face ) ; 
 + this . materialLibrary . getGroups ( ) . put ( Group . DEFAULT _ NAME , def ) ; 
 + } 
 } 
 - } 
 - 
 - Vertex [ ] va = new Vertex [ v . size ( ) ] ; 
 - v . toArray ( va ) ; 
 - / / TextureCoordinate [ ] ta = new TextureCoordinate [ t . size ( ) ] ; 
 - / / t . toArray ( ta ) ; 
 - / / Normal [ ] na = new Normal [ n . size ( ) ] ; 
 - / / n . toArray ( na ) ; 
 - Face face = new Face ( va , material . name ) ; 
 - if ( usemtlCounter < this . vertices . size ( ) ) 
 - { 
 - for ( Vertex ver : face . getVertices ( ) ) 
 + else 
 { 
 - ver . setMaterial ( material ) ; 
 + for ( String s : groupList ) 
 + { 
 + if ( this . materialLibrary . getGroups ( ) . containsKey ( s ) ) 
 + { 
 + this . materialLibrary . getGroups ( ) . get ( s ) . addFace ( face ) ; 
 + } 
 + else 
 + { 
 + Group e = new Group ( s , null ) ; 
 + e . addFace ( face ) ; 
 + this . materialLibrary . getGroups ( ) . put ( s , e ) ; 
 + } 
 + } 
 } 
 } 
 - 
 - if ( groupList . isEmpty ( ) ) 
 + else if ( key . equalsIgnoreCase ( " g " ) | | key . equalsIgnoreCase ( " o " ) ) 
 { 
 - if ( this . materialLibrary . getGroups ( ) . containsKey ( Group . DEFAULT _ NAME ) ) 
 + groupList . clear ( ) ; 
 + if ( key . equalsIgnoreCase ( " g " ) ) 
 { 
 - this . materialLibrary . getGroups ( ) . get ( Group . DEFAULT _ NAME ) . addFace ( face ) ; 
 + String [ ] splitSpace = data . split ( " " ) ; 
 + for ( String s : splitSpace ) 
 + groupList . add ( s ) ; 
 } 
 else 
 { 
 - Group def = new Group ( Group . DEFAULT _ NAME , null ) ; 
 - def . addFace ( face ) ; 
 - this . materialLibrary . getGroups ( ) . put ( Group . DEFAULT _ NAME , def ) ; 
 + groupList . add ( data ) ; 
 } 
 } 
 else 
 { 
 - for ( String s : groupList ) 
 + if ( ! unknownObjectCommands . contains ( key ) ) 
 { 
 - if ( this . materialLibrary . getGroups ( ) . containsKey ( s ) ) 
 - { 
 - this . materialLibrary . getGroups ( ) . get ( s ) . addFace ( face ) ; 
 - } 
 - else 
 - { 
 - Group e = new Group ( s , null ) ; 
 - e . addFace ( face ) ; 
 - this . materialLibrary . getGroups ( ) . put ( s , e ) ; 
 - } 
 + unknownObjectCommands . add ( key ) ; 
 + FMLLog . info ( " OBJLoader . Parser : command ' % s ' ( model : ' % s ' ) is not currently supported , skipping . Line : % d ' % s ' " , key , objFrom , lineNum , currentLine ) ; 
 } 
 } 
 } 
 - else if ( key . equalsIgnoreCase ( " g " ) | | key . equalsIgnoreCase ( " o " ) ) 
 - { 
 - groupList . clear ( ) ; 
 - if ( key . equalsIgnoreCase ( " g " ) ) 
 - { 
 - String [ ] splitSpace = data . split ( " " ) ; 
 - for ( String s : splitSpace ) 
 - groupList . add ( s ) ; 
 - } 
 - else 
 - { 
 - groupList . add ( data ) ; 
 - } 
 - } 
 - else 
 + catch ( RuntimeException e ) 
 { 
 - if ( ! unknownObjectCommands . contains ( key ) ) 
 - { 
 - unknownObjectCommands . add ( key ) ; 
 - FMLLog . info ( " OBJLoader . Parser : command ' % s ' ( model : ' % s ' ) is not currently supported , skipping " , key , objFrom ) ; 
 - } 
 + throw new RuntimeException ( String . format ( " OBJLoader . Parser : Exception parsing line # % d : ` % s ` " , lineNum , currentLine ) , e ) ; 
 } 
 } 
 
 - OBJModel model = new OBJModel ( this . materialLibrary , this . objFrom ) ; 
 - / / model . getMatLib ( ) . setUVBounds ( minUVBounds [ 0 ] , maxUVBounds [ 0 ] , minUVBounds [ 1 ] , maxUVBounds [ 1 ] ) ; 
 - return model ; 
 + return new OBJModel ( this . materialLibrary , this . objFrom ) ; 
 } 
 } 
 
 @ @ - 825 , 8 + 778 , 8 @ @ public class OBJModel implements IRetexturableModel , IModelCustomData 
 { 
 return this . materialName ; 
 } 
 - 
 - public boolean isTriangles ( ) 
 + 
 + public boolean isTriangles ( ) 
 { 
 return isTri ; 
 }

NEAREST DIFF:
diff - - git a / client / net / minecraftforge / client / model / obj / Face . java b / client / net / minecraftforge / client / model / obj / Face . java 
 new file mode 100644 
 index 0000000 . . f47951b 
 - - - / dev / null 
 + + + b / client / net / minecraftforge / client / model / obj / Face . java 
 @ @ - 0 , 0 + 1 , 84 @ @ 
 + package net . minecraftforge . client . model . obj ; 
 + 
 + import net . minecraft . client . renderer . Tessellator ; 
 + import net . minecraft . util . Vec3 ; 
 + import cpw . mods . fml . relauncher . Side ; 
 + import cpw . mods . fml . relauncher . SideOnly ; 
 + 
 + @ SideOnly ( Side . CLIENT ) 
 + public class Face 
 + { 
 + 
 + public Vertex [ ] vertices ; 
 + public Vertex [ ] vertexNormals ; 
 + public Vertex faceNormal ; 
 + public TextureCoordinate [ ] textureCoordinates ; 
 + 
 + public void addFaceForRender ( Tessellator tessellator ) 
 + { 
 + addFaceForRender ( tessellator , 0 . 0005F ) ; 
 + } 
 + 
 + public void addFaceForRender ( Tessellator tessellator , float textureOffset ) 
 + { 
 + if ( faceNormal = = null ) 
 + { 
 + faceNormal = this . calculateFaceNormal ( ) ; 
 + } 
 + 
 + tessellator . setNormal ( faceNormal . x , faceNormal . y , faceNormal . z ) ; 
 + 
 + float averageU = 0F ; 
 + float averageV = 0F ; 
 + 
 + if ( textureCoordinates . length ! = 0 ) 
 + { 
 + for ( int i = 0 ; i < textureCoordinates . length ; + + i ) 
 + { 
 + averageU + = textureCoordinates [ i ] . u ; 
 + averageV + = textureCoordinates [ i ] . v ; 
 + } 
 + 
 + averageU = averageU / textureCoordinates . length ; 
 + averageV = averageV / textureCoordinates . length ; 
 + } 
 + 
 + float offsetU , offsetV ; 
 + 
 + for ( int i = 0 ; i < vertices . length ; + + i ) 
 + { 
 + 
 + if ( textureCoordinates . length ! = 0 ) 
 + { 
 + offsetU = textureOffset ; 
 + offsetV = textureOffset ; 
 + 
 + if ( textureCoordinates [ i ] . u > averageU ) 
 + { 
 + offsetU = - offsetU ; 
 + } 
 + if ( textureCoordinates [ i ] . v > averageV ) 
 + { 
 + offsetV = - offsetV ; 
 + } 
 + 
 + tessellator . addVertexWithUV ( vertices [ i ] . x , vertices [ i ] . y , vertices [ i ] . z , textureCoordinates [ i ] . u + offsetU , textureCoordinates [ i ] . v + offsetV ) ; 
 + } 
 + else 
 + { 
 + tessellator . addVertex ( vertices [ i ] . x , vertices [ i ] . y , vertices [ i ] . z ) ; 
 + } 
 + } 
 + } 
 + 
 + public Vertex calculateFaceNormal ( ) 
 + { 
 + Vec3 v1 = Vec3 . createVectorHelper ( vertices [ 1 ] . x - vertices [ 0 ] . x , vertices [ 1 ] . y - vertices [ 0 ] . y , vertices [ 1 ] . z - vertices [ 0 ] . z ) ; 
 + Vec3 v2 = Vec3 . createVectorHelper ( vertices [ 2 ] . x - vertices [ 0 ] . x , vertices [ 2 ] . y - vertices [ 0 ] . y , vertices [ 2 ] . z - vertices [ 0 ] . z ) ; 
 + Vec3 normalVector = null ; 
 + 
 + normalVector = v1 . crossProduct ( v2 ) . normalize ( ) ; 
 + 
 + return new Vertex ( ( float ) normalVector . xCoord , ( float ) normalVector . yCoord , ( float ) normalVector . zCoord ) ; 
 + } 
 + } 
 diff - - git a / client / net / minecraftforge / client / model / obj / GroupObject . java b / client / net / minecraftforge / client / model / obj / GroupObject . java 
 new file mode 100644 
 index 0000000 . . 0bf36af 
 - - - / dev / null 
 + + + b / client / net / minecraftforge / client / model / obj / GroupObject . java 
 @ @ - 0 , 0 + 1 , 54 @ @ 
 + package net . minecraftforge . client . model . obj ; 
 + 
 + import java . util . ArrayList ; 
 + 
 + import net . minecraft . client . renderer . Tessellator ; 
 + import cpw . mods . fml . relauncher . Side ; 
 + import cpw . mods . fml . relauncher . SideOnly ; 
 + 
 + @ SideOnly ( Side . CLIENT ) 
 + public class GroupObject 
 + { 
 + 
 + public String name ; 
 + public ArrayList < Face > faces = new ArrayList < Face > ( ) ; 
 + public int glDrawingMode ; 
 + 
 + public GroupObject ( ) 
 + { 
 + this ( " " ) ; 
 + } 
 + 
 + public GroupObject ( String name ) 
 + { 
 + this ( name , - 1 ) ; 
 + } 
 + 
 + public GroupObject ( String name , int glDrawingMode ) 
 + { 
 + this . name = name ; 
 + this . glDrawingMode = glDrawingMode ; 
 + } 
 + 
 + public void render ( ) 
 + { 
 + if ( faces . size ( ) > 0 ) 
 + { 
 + Tessellator tessellator = Tessellator . instance ; 
 + tessellator . startDrawing ( glDrawingMode ) ; 
 + render ( tessellator ) ; 
 + tessellator . draw ( ) ; 
 + } 
 + } 
 + 
 + public void render ( Tessellator tessellator ) 
 + { 
 + if ( faces . size ( ) > 0 ) 
 + { 
 + for ( Face face : faces ) 
 + { 
 + face . addFaceForRender ( tessellator ) ; 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / client / net / minecraftforge / client / model / obj / TextureCoordinate . java b / client / net / minecraftforge / client / model / obj / TextureCoordinate . java 
 new file mode 100644 
 index 0000000 . . 8583905 
 - - - / dev / null 
 + + + b / client / net / minecraftforge / client / model / obj / TextureCoordinate . java 
 @ @ - 0 , 0 + 1 , 23 @ @ 
 + package net . minecraftforge . client . model . obj ; 
 + 
 + import cpw . mods . fml . relauncher . Side ; 
 + import cpw . mods . fml . relauncher . SideOnly ; 
 + 
 + @ SideOnly ( Side . CLIENT ) 
 + public class TextureCoordinate 
 + { 
 + 
 + public float u , v , w ; 
 + 
 + public TextureCoordinate ( float u , float v ) 
 + { 
 + this ( u , v , 0F ) ; 
 + } 
 + 
 + public TextureCoordinate ( float u , float v , float w ) 
 + { 
 + this . u = u ; 
 + this . v = v ; 
 + this . w = w ; 
 + } 
 + } 
 diff - - git a / client / net / minecraftforge / client / model / obj / Vertex . java b / client / net / minecraftforge / client / model / obj / Vertex . java 
 new file mode 100644 
 index 0000000 . . c4ecf35 
 - - - / dev / null 
 + + + b / client / net / minecraftforge / client / model / obj / Vertex . java 
 @ @ - 0 , 0 + 1 , 23 @ @ 
 + package net . minecraftforge . client . model . obj ; 
 + 
 + import cpw . mods . fml . relauncher . Side ; 
 + import cpw . mods . fml . relauncher . SideOnly ; 
 + 
 + @ SideOnly ( Side . CLIENT ) 
 + public class Vertex 
 + { 
 + 
 + public float x , y , z ; 
 + 
 + public Vertex ( float x , float y ) 
 + { 
 + this ( x , y , 0F ) ; 
 + } 
 + 
 + public Vertex ( float x , float y , float z ) 
 + { 
 + this . x = x ; 
 + this . y = y ; 
 + this . z = z ; 
 + } 
 + } 
 diff - - git a / client / net / minecraftforge / client / model / obj / WavefrontObject . java b / client / net / minecraftforge / client / model / obj / WavefrontObject . java 
 new file mode 100644 
 index 0000000 . . 42934f8 
 - - - / dev / null 
 + + + b / client / net / minecraftforge / client / model / obj / WavefrontObject . java 
 @ @ - 0 , 0 + 1 , 447 @ @ 
 + package net . minecraftforge . client . model . obj ; 
 + 
 + import java . io . BufferedReader ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . io . InputStreamReader ; 
 + import java . net . URL ; 
 + import java . text . ParseException ; 
 + import java . util . ArrayList ; 
 + 
 + import net . minecraft . client . renderer . Tessellator ; 
 + 
 + import org . lwjgl . opengl . GL11 ; 
 + 
 + import cpw . mods . fml . relauncher . Side ; 
 + import cpw . mods . fml . relauncher . SideOnly ; 
 + 
 + @ SideOnly ( Side . CLIENT ) 
 + public class WavefrontObject 
 + { 
 + 
 + private static final String REGEX _ VERTEX = " ( v ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * \ \ n ) | ( v ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * $ ) " ; 
 + private static final String REGEX _ VERTEX _ NORMAL = " ( vn ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * \ \ n ) | ( vn ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * $ ) " ; 
 + private static final String REGEX _ TEXTURE _ COORDINATE = " ( vt ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * \ \ n ) | ( vt ( ( \ \ - ) { 0 , 1 } \ \ d + \ \ . \ \ d + ) { 3 , 4 } * $ ) " ; 
 + private static final String REGEX _ FACE _ VERTEX _ TEXTURECOORD _ VERTEXNORMAL = " ( f ( \ \ d + / \ \ d + / \ \ d + ) { 3 , 4 } * \ \ n ) | ( f ( \ \ d + / \ \ d + / \ \ d + ) { 3 , 4 } * $ ) " ; 
 + private static final String REGEX _ FACE _ VERTEX _ TEXTURECOORD = " ( f ( \ \ d + / \ \ d + ) { 3 , 4 } * \ \ n ) | ( f ( \ \ d + / \ \ d + ) { 3 , 4 } * $ ) " ; 
 + private static final String REGEX _ FACE _ VERTEX _ VERTEXNORMAL = " ( f ( \ \ d + / / \ \ d + ) { 3 , 4 } * \ \ n ) | ( f ( \ \ d + / / \ \ d + ) { 3 , 4 } * $ ) " ; 
 + private static final String REGEX _ FACE _ VERTEX = " ( f ( \ \ d + ) { 3 , 4 } * \ \ n ) | ( f ( \ \ d + ) { 3 , 4 } * $ ) " ; 
 + private static final String REGEX _ GROUP _ OBJECT = " ( [ go ] ( [ \ \ w \ \ d ] + ) * \ \ n ) | ( [ go ] ( [ \ \ w \ \ d ] + ) * $ ) " ; 
 + 
 + public ArrayList < Vertex > vertices = new ArrayList < Vertex > ( ) ; 
 + public ArrayList < Vertex > vertexNormals = new ArrayList < Vertex > ( ) ; 
 + public ArrayList < TextureCoordinate > textureCoordinates = new ArrayList < TextureCoordinate > ( ) ; 
 + public ArrayList < GroupObject > groupObjects = new ArrayList < GroupObject > ( ) ; 
 + private GroupObject currentGroupObject ; 
 + 
 + public WavefrontObject ( String fileName ) 
 + { 
 + try 
 + { 
 + parseObjModel ( this . getClass ( ) . getResource ( fileName ) ) ; 
 + } 
 + catch ( ParseException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + public WavefrontObject ( URL fileURL ) 
 + { 
 + try 
 + { 
 + parseObjModel ( fileURL ) ; 
 + } 
 + catch ( ParseException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + private void parseObjModel ( URL fileURL ) throws ParseException 
 + { 
 + BufferedReader reader = null ; 
 + InputStream inputStream = null ; 
 + 
 + String currentLine = null ; 
 + int lineCount = 0 ; 
 + 
 + try 
 + { 
 + inputStream = fileURL . openStream ( ) ; 
 + reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; 
 + 
 + while ( ( currentLine = reader . readLine ( ) ) ! = null ) 
 + { 
 + lineCount + + ; 
 + currentLine = currentLine . replaceAll ( " \ \ s + " , " " ) . trim ( ) ; 
 + 
 + if ( currentLine . startsWith ( " # " ) | | currentLine . length ( ) = = 0 ) 
 + { 
 + continue ; 
 + } 
 + else if ( currentLine . startsWith ( " v " ) ) 
 + { 
 + Vertex vertex = parseVertex ( currentLine ) ; 
 + if ( vertex ! = null ) 
 + { 
 + vertices . add ( vertex ) ; 
 + } 
 + else 
 + { 
 + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; 
 + } 
 + } 
 + else if ( currentLine . startsWith ( " vn " ) ) 
 + { 
 + Vertex vertex = parseVertexNormal ( currentLine ) ; 
 + if ( vertex ! = null ) 
 + { 
 + vertexNormals . add ( vertex ) ; 
 + } 
 + else 
 + { 
 + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; 
 + } 
 + } 
 + else if ( currentLine . startsWith ( " vt " ) ) 
 + { 
 + TextureCoordinate textureCoordinate = parseTextureCoordinate ( currentLine ) ; 
 + if ( textureCoordinate ! = null ) 
 + { 
 + textureCoordinates . add ( textureCoordinate ) ; 
 + } 
 + else 
 + { 
 + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; 
 + } 
 + } 
 + else if ( currentLine . startsWith ( " f " ) ) 
 + { 
 + 
 + if ( currentGroupObject = = null ) 
 + { 
 + currentGroupObject = new GroupObject ( " Default " ) ; 
 + } 
 + 
 + Face face = parseFace ( currentLine ) ; 
 + 
 + if ( face ! = null ) 
 + { 
 + currentGroupObject . faces . add ( face ) ; 
 + } 
 + else 
 + { 
 + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; 
 + } 
 + } 
 + else if ( currentLine . startsWith ( " g " ) | currentLine . startsWith ( " o " ) ) 
 + { 
 + GroupObject group = parseGroupObject ( currentLine ) ; 
 + 
 + if ( group ! = null ) 
 + { 
 + if ( currentGroupObject ! = null ) 
 + { 
 + groupObjects . add ( currentGroupObject ) ; 
 + } 
 + } 
 + else 
 + { 
 + throw new ParseException ( " Error parsing entry ( ' " + currentLine + " ' " + " , line " + lineCount + " ) in file ' " + fileURL . getFile ( ) + " ' " , lineCount ) ; 
 + } 
 + 
 + currentGroupObject = group ; 
 + } 
 + } 
 + 
 + groupObjects . add ( currentGroupObject ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + finally 
 + { 
 + try 
 + { 
 + reader . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + try 
 + { 
 + inputStream . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + } 
 + 
 + public void renderAll ( ) 
 + { 
 + Tessellator tessellator = Tessellator . instance ; 
 + 
 + if ( currentGroupObject ! = null ) 
 + { 
 + tessellator . startDrawing ( currentGroupObject . glDrawingMode ) ; 
 + } 
 + else 
 + { 
 + tessellator . startDrawing ( GL11 . GL _ TRIANGLES ) ; 
 + } 
 + 
 + for ( GroupObject groupObject : groupObjects ) 
 + { 
 + groupObject . render ( tessellator ) ; 
 + } 
 + 
 + tessellator . draw ( ) ; 
 + } 
 + 
 + public void renderOnly ( String . . . groupNames ) 
 + { 
 + for ( GroupObject groupObject : groupObjects ) 
 + { 
 + for ( String groupName : groupNames ) 
 + { 
 + if ( groupName . equalsIgnoreCase ( groupObject . name ) ) 
 + { 
 + groupObject . render ( ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + public void renderAllExcept ( String . . . excludedGroupNames ) 
 + { 
 + for ( GroupObject groupObject : groupObjects ) 
 + { 
 + for ( String excludedGroupName : excludedGroupNames ) 
 + { 
 + if ( ! excludedGroupName . equalsIgnoreCase ( groupObject . name ) ) 
 + { 
 + groupObject . render ( ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + private Vertex parseVertex ( String line ) 
 + { 
 + Vertex vertex = null ; 
 + 
 + if ( isValidVertexLine ( line ) ) 
 + { 
 + line = line . substring ( line . indexOf ( " " ) + 1 ) ; 
 + String [ ] tokens = line . split ( " " ) ; 
 + 
 + try 
 + { 
 + if ( tokens . length = = 3 ) 
 + return new Vertex ( Float . parseFloat ( tokens [ 0 ] ) , Float . parseFloat ( tokens [ 1 ] ) , Float . parseFloat ( tokens [ 2 ] ) ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + return vertex ; 
 + } 
 + 
 + private Vertex parseVertexNormal ( String line ) 
 + { 
 + Vertex vertexNormal = null ; 
 + 
 + if ( isValidVertexNormalLine ( line ) ) 
 + { 
 + line = line . substring ( line . indexOf ( " " ) + 1 ) ; 
 + String [ ] tokens = line . split ( " " ) ; 
 + 
 + try 
 + { 
 + if ( tokens . length = = 3 ) 
 + return new Vertex ( Float . parseFloat ( tokens [ 0 ] ) , Float . parseFloat ( tokens [ 1 ] ) , Float . parseFloat ( tokens [ 2 ] ) ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + return vertexNormal ; 
 + } 
 + 
 + private TextureCoordinate parseTextureCoordinate ( String line ) 
 + { 
 + TextureCoordinate textureCoordinate = null ; 
 + 
 + if ( isValidTextureCoordinateLine ( line ) ) 
 + { 
 + line = line . substring ( line . indexOf ( " " ) + 1 ) ; 
 + String [ ] tokens = line . split ( " " ) ; 
 + 
 + try 
 + { 
 + if ( tokens . length = = 2 ) 
 + return new TextureCoordinate ( Float . parseFloat ( tokens [ 0 ] ) , 1 - Float . parseFloat ( tokens [ 1 ] ) ) ; 
 + else if ( tokens . length = = 3 ) 
 + return new TextureCoordinate ( Float . parseFloat ( tokens [ 0 ] ) , 1 - Float . parseFloat ( tokens [ 1 ] ) , Float . parseFloat ( tokens [ 2 ] ) ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + return textureCoordinate ; 
 + } 
 + 
 + private Face parseFace ( String line ) 
 + { 
 + Face face = null ; 
 + 
 + if ( isValidFaceLine ( line ) ) 
 + { 
 + face = new Face ( ) ; 
 + 
 + String trimmedLine = line . substring ( line . indexOf ( " " ) + 1 ) ; 
 + String [ ] tokens = trimmedLine . split ( " " ) ; 
 + String [ ] subTokens = null ; 
 + 
 + if ( tokens . length = = 3 ) 
 + { 
 + if ( currentGroupObject . glDrawingMode = = - 1 ) 
 + { 
 + currentGroupObject . glDrawingMode = GL11 . GL _ TRIANGLES ; 
 + } 
 + else if ( currentGroupObject . glDrawingMode ! = GL11 . GL _ TRIANGLES ) 
 + { 
 + return null ; 
 + } 
 + } 
 + else if ( tokens . length = = 4 ) 
 + { 
 + if ( currentGroupObject . glDrawingMode = = - 1 ) 
 + { 
 + currentGroupObject . glDrawingMode = GL11 . GL _ QUADS ; 
 + } 
 + else if ( currentGroupObject . glDrawingMode ! = GL11 . GL _ QUADS ) 
 + { 
 + return null ; 
 + } 
 + } 
 + 
 + face . vertices = new Vertex [ tokens . length ] ; 
 + face . textureCoordinates = new TextureCoordinate [ tokens . length ] ; 
 + face . vertexNormals = new Vertex [ tokens . length ] ; 
 + 
 + / / f v1 / vt1 / vn1 v2 / vt2 / vn2 v3 / vt3 / vn3 . . . 
 + if ( line . matches ( REGEX _ FACE _ VERTEX _ TEXTURECOORD _ VERTEXNORMAL ) ) 
 + { 
 + for ( int i = 0 ; i < tokens . length ; + + i ) 
 + { 
 + subTokens = tokens [ i ] . split ( " / " ) ; 
 + 
 + face . vertices [ i ] = vertices . get ( Integer . parseInt ( subTokens [ 0 ] ) - 1 ) ; 
 + face . textureCoordinates [ i ] = textureCoordinates . get ( Integer . parseInt ( subTokens [ 1 ] ) - 1 ) ; 
 + face . vertexNormals [ i ] = vertexNormals . get ( Integer . parseInt ( subTokens [ 2 ] ) - 1 ) ; 
 + } 
 + 
 + face . faceNormal = face . calculateFaceNormal ( ) ; 
 + } 
 + / / f v1 / vt1 v2 / vt2 v3 / vt3 . . . 
 + else if ( line . matches ( REGEX _ FACE _ VERTEX _ TEXTURECOORD ) ) 
 + { 
 + for ( int i = 0 ; i < tokens . length ; + + i ) 
 + { 
 + subTokens = tokens [ i ] . split ( " / " ) ; 
 + 
 + face . vertices [ i ] = vertices . get ( Integer . parseInt ( subTokens [ 0 ] ) - 1 ) ; 
 + face . textureCoordinates [ i ] = textureCoordinates . get ( Integer . parseInt ( subTokens [ 1 ] ) - 1 ) ; 
 + } 
 + 
 + face . faceNormal = face . calculateFaceNormal ( ) ; 
 + } 
 + / / f v1 / / vn1 v2 / / vn2 v3 / / vn3 . . . 
 + else if ( line . matches ( REGEX _ FACE _ VERTEX _ VERTEXNORMAL ) ) 
 + { 
 + for ( int i = 0 ; i < tokens . length ; + + i ) 
 + { 
 + subTokens = tokens [ i ] . split ( " / / " ) ; 
 + 
 + face . vertices [ i ] = vertices . get ( Integer . parseInt ( subTokens [ 0 ] ) - 1 ) ; 
 + face . vertexNormals [ i ] = vertexNormals . get ( Integer . parseInt ( subTokens [ 1 ] ) - 1 ) ; 
 + } 
 + 
 + face . faceNormal = face . calculateFaceNormal ( ) ; 
 + } 
 + / / f v1 v2 v3 . . . 
 + else if ( line . matches ( REGEX _ FACE _ VERTEX ) ) 
 + { 
 + for ( int i = 0 ; i < tokens . length ; + + i ) 
 + { 
 + face . vertices [ i ] = vertices . get ( Integer . parseInt ( tokens [ i ] ) - 1 ) ; 
 + } 
 + 
 + face . faceNormal = face . calculateFaceNormal ( ) ; 
 + } 
 + else 
 + throw new IllegalArgumentException ( ) ; 
 + } 
 + 
 + return face ; 
 + } 
 + 
 + private GroupObject parseGroupObject ( String line ) 
 + { 
 + GroupObject group = null ; 
 + 
 + if ( isValidGroupObjectLine ( line ) ) 
 + { 
 + String trimmedLine = line . substring ( line . indexOf ( " " ) + 1 ) ; 
 + 
 + if ( trimmedLine . length ( ) > 0 ) 
 + { 
 + group = new GroupObject ( trimmedLine ) ; 
 + } 
 + } 
 + 
 + return group ; 
 + } 
 + 
 + private static boolean isValidVertexLine ( String line ) 
 + { 
 + 
 + return line . matches ( REGEX _ VERTEX ) ; 
 + } 
 + 
 + private static boolean isValidVertexNormalLine ( String line ) 
 + { 
 + 
 + return line . matches ( REGEX _ VERTEX _ NORMAL ) ; 
 + } 
 + 
 + private static boolean isValidTextureCoordinateLine ( String line ) 
 + { 
 + 
 + return line . matches ( REGEX _ TEXTURE _ COORDINATE ) ; 
 + } 
 + 
 + private static boolean isValidFaceLine ( String line ) 
 + { 
 + 
 + return line . matches ( REGEX _ FACE _ VERTEX _ TEXTURECOORD _ VERTEXNORMAL ) | | line . matches ( REGEX _ FACE _ VERTEX _ TEXTURECOORD ) | | line . matches ( REGEX _ FACE _ VERTEX _ VERTEXNORMAL ) | | line . matches ( REGEX _ FACE _ VERTEX ) ; 
 + } 
 + 
 + private static boolean isValidGroupObjectLine ( String line ) 
 + { 
 + 
 + return line . matches ( REGEX _ GROUP _ OBJECT ) ; 
 + } 
 + }
