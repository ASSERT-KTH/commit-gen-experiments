BLEU SCORE: 0.028465126651392333

TEST MSG: Fixed property losing state after rename .
GENERATED MSG: Fix arrays in map values for config system

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / config / Configuration . java b / src / main / java / net / minecraftforge / common / config / Configuration . java <nl> index d131553 . . e80322d 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / Configuration . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / Configuration . java <nl> @ @ - 1412 , 10 + 1412 , 12 @ @ public class Configuration <nl> { <nl> if ( hasCategory ( category ) ) <nl> { <nl> - if ( getCategory ( category ) . containsKey ( oldPropName ) & & ! oldPropName . equalsIgnoreCase ( newPropName ) ) <nl> + ConfigCategory cat = getCategory ( category ) ; <nl> + if ( cat . containsKey ( oldPropName ) & & ! oldPropName . equalsIgnoreCase ( newPropName ) ) <nl> { <nl> - get ( category , newPropName , getCategory ( category ) . get ( oldPropName ) . getString ( ) , " " ) ; <nl> - getCategory ( category ) . remove ( oldPropName ) ; <nl> + Property prop = cat . remove ( oldPropName ) ; <nl> + prop . setName ( newPropName ) ; <nl> + cat . put ( newPropName , prop ) ; <nl> return true ; <nl> } <nl> } <nl> diff - - git a / src / test / java / net / minecraftforge / test / ConfigurationTest . java b / src / test / java / net / minecraftforge / test / ConfigurationTest . java <nl> new file mode 100644 <nl> index 0000000 . . e242a1a <nl> - - - / dev / null <nl> + + + b / src / test / java / net / minecraftforge / test / ConfigurationTest . java <nl> @ @ - 0 , 0 + 1 , 79 @ @ <nl> + package net . minecraftforge . test ; <nl> + <nl> + <nl> + import net . minecraft . init . Bootstrap ; <nl> + import net . minecraftforge . common . config . ConfigCategory ; <nl> + import net . minecraftforge . common . config . Configuration ; <nl> + import net . minecraftforge . common . config . Property ; <nl> + import net . minecraftforge . fml . common . Loader ; <nl> + import net . minecraftforge . fml . common . registry . ForgeTestRunner ; <nl> + import org . junit . Before ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import static junit . framework . TestCase . assertNull ; <nl> + import static org . junit . Assert . * ; <nl> + <nl> + @ RunWith ( ForgeTestRunner . class ) <nl> + public class ConfigurationTest { <nl> + <nl> + private Configuration config ; <nl> + private ConfigCategory category ; <nl> + <nl> + @ BeforeClass <nl> + public static void setupClass ( ) <nl> + { <nl> + Loader . instance ( ) ; <nl> + Bootstrap . register ( ) ; <nl> + } <nl> + <nl> + @ Before <nl> + public void setup ( ) <nl> + { <nl> + Property enabledProperty = new Property ( " enabled " , " true " , Property . Type . BOOLEAN ) ; <nl> + enabledProperty . setComment ( " enabled property comment " ) ; <nl> + <nl> + Property backgroundProperty = new Property ( " background " , " 0xFFFFFF " , Property . Type . COLOR ) ; <nl> + backgroundProperty . setComment ( " background property comment " ) ; <nl> + <nl> + config = new Configuration ( ) ; <nl> + category = config . getCategory ( " defaults " ) ; <nl> + category . put ( enabledProperty . getName ( ) , enabledProperty ) ; <nl> + category . put ( backgroundProperty . getName ( ) , backgroundProperty ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRenameProperty _ newNameNotInUse ( ) <nl> + { <nl> + boolean propertyRenamed = config . renameProperty ( " defaults " , " enabled " , " defaultEnabled " ) ; <nl> + <nl> + Property enabledProperty = category . get ( " enabled " ) ; <nl> + Property defaultEnabledProperty = category . get ( " defaultEnabled " ) ; <nl> + <nl> + assertTrue ( " Property was not renamed " , propertyRenamed ) ; <nl> + assertNull ( " Old property was not removed " , enabledProperty ) ; <nl> + assertNotNull ( " New property was not added " , defaultEnabledProperty ) ; <nl> + assertEquals ( " The property ' s name was not changed " , " defaultEnabled " , defaultEnabledProperty . getName ( ) ) ; <nl> + assertEquals ( " The property ' s value changed " , " true " , defaultEnabledProperty . getString ( ) ) ; <nl> + assertEquals ( " The property ' s type was changed " , Property . Type . BOOLEAN , defaultEnabledProperty . getType ( ) ) ; <nl> + assertEquals ( " The property ' s comment was changed " , " enabled property comment " , defaultEnabledProperty . getComment ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRenameProperty _ newNameInUse _ replaceExistingProperty ( ) <nl> + { <nl> + boolean propertyRenamed = config . renameProperty ( " defaults " , " enabled " , " background " ) ; <nl> + <nl> + Property enabledProperty = category . get ( " enabled " ) ; <nl> + Property backgroundProperty = category . get ( " background " ) ; <nl> + <nl> + assertTrue ( " Property was not renamed " , propertyRenamed ) ; <nl> + assertNull ( " Old property was not removed " , enabledProperty ) ; <nl> + assertNotNull ( " New property was not added " , backgroundProperty ) ; <nl> + assertEquals ( " The property ' s name was not changed " , " background " , backgroundProperty . getName ( ) ) ; <nl> + assertEquals ( " The property ' s value changed " , " true " , backgroundProperty . getString ( ) ) ; <nl> + assertEquals ( " The property ' s type was changed " , Property . Type . BOOLEAN , backgroundProperty . getType ( ) ) ; <nl> + assertEquals ( " The property ' s comment was changed " , " enabled property comment " , backgroundProperty . getComment ( ) ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / common / config / ConfigManager . java b / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> index fe2062e . . 34f2712 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / ConfigManager . java <nl> @ @ - 50 , 6 + 50 , 7 @ @ public class ConfigManager <nl> { <nl> private static Map < String , Multimap < Config . Type , ASMData > > asm _ data = Maps . newHashMap ( ) ; <nl> static Map < Class < ? > , ITypeAdapter > ADAPTERS = Maps . newHashMap ( ) ; <nl> + static Map < Class < ? > , Class < ? > > ARRAY _ REMAP = Maps . newHashMap ( ) ; <nl> private static Map < String , Configuration > CONFIGS = Maps . newHashMap ( ) ; <nl> private static Map < String , Set < Class < ? > > > MOD _ CONFIG _ CLASSES = Maps . newHashMap ( ) ; <nl> <nl> @ @ - 85 , 6 + 86 , 16 @ @ public class ConfigManager <nl> register ( Integer [ ] . class , TypeAdapters . IntA ) ; <nl> register ( String . class , TypeAdapters . Str ) ; <nl> register ( String [ ] . class , TypeAdapters . StrA ) ; <nl> + <nl> + <nl> + ARRAY _ REMAP . put ( Boolean . class , Boolean [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Float . class , Float [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Double . class , Double [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Byte . class , Byte [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Character . class , Character [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Short . class , Short [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( Integer . class , Integer [ ] . class ) ; <nl> + ARRAY _ REMAP . put ( String . class , String [ ] . class ) ; <nl> } <nl> private static void register ( Class < ? > cls , ITypeAdapter adpt ) <nl> { <nl> @ @ - 110 , 7 + 121 , 7 @ @ public class ConfigManager <nl> map . put ( type , target ) ; <nl> } <nl> } <nl> - <nl> + <nl> / * * <nl> * Bounces to sync ( ) . <nl> * TODO : remove <nl> @ @ - 123 , 13 + 134 , 13 @ @ public class ConfigManager <nl> / * * <nl> * Synchronizes configuration data between the file on disk , the { @ code Configuration } object and the annotated <nl> * mod classes containing the configuration variables . <nl> - * <nl> + * <nl> * When first called , this method will try to load the configuration from disk . If this fails , because the file <nl> * does not exist , it will be created with default values derived from the mods config classes variable default values <nl> * and comments and ranges , as well as configuration names based on the appropriate annotations found in { @ code @ Config } . <nl> - * <nl> + * <nl> * Note , that this method is being called by the { @ link FMLModContaier } , so the mod needn ' t call it in init ( ) . <nl> - * <nl> + * <nl> * If this method is called after the initial load , it will check whether the values in the Configuration object differ <nl> * from the values in the corresponding variables . If they differ , it will either overwrite the variables if the Configuration <nl> * object is marked as changed ( e . g . if it was changed with the ConfigGui ) or otherwise overwrite the Configuration object ' s values . <nl> @ @ - 152 , 11 + 163 , 11 @ @ public class ConfigManager <nl> try <nl> { <nl> Class < ? > cls = Class . forName ( targ . getClassName ( ) , true , mcl ) ; <nl> - <nl> + <nl> if ( MOD _ CONFIG _ CLASSES . get ( modid ) = = null ) <nl> MOD _ CONFIG _ CLASSES . put ( modid , Sets . < Class < ? > > newHashSet ( ) ) ; <nl> MOD _ CONFIG _ CLASSES . get ( modid ) . add ( cls ) ; <nl> - <nl> + <nl> String name = ( String ) targ . getAnnotationInfo ( ) . get ( " name " ) ; <nl> if ( name = = null ) <nl> name = modid ; <nl> @ @ - 188 , 7 + 199 , 7 @ @ public class ConfigManager <nl> } <nl> } <nl> } <nl> - <nl> + <nl> public static Class < ? > [ ] getModConfigClasses ( String modid ) <nl> { <nl> return MOD _ CONFIG _ CLASSES . get ( modid ) . toArray ( new Class < ? > [ 0 ] ) ; <nl> @ @ - 204 , 7 + 215 , 7 @ @ public class ConfigManager <nl> File configFile = new File ( configDir , name + " . cfg " ) ; <nl> return CONFIGS . get ( configFile . getAbsolutePath ( ) ) ; <nl> } <nl> - <nl> + <nl> private static void sync ( Configuration cfg , Class < ? > cls , String modid , String category , boolean loading , Object instance ) <nl> { <nl> for ( Field f : cls . getDeclaredFields ( ) ) <nl> @ @ - 213 , 7 + 224 , 7 @ @ public class ConfigManager <nl> continue ; <nl> if ( Modifier . isStatic ( f . getModifiers ( ) ) ! = ( instance = = null ) ) <nl> continue ; <nl> - <nl> + <nl> String comment = null ; <nl> Comment ca = f . getAnnotation ( Comment . class ) ; <nl> if ( ca ! = null ) <nl> @ @ - 223 , 7 + 234 , 7 @ @ public class ConfigManager <nl> LangKey la = f . getAnnotation ( LangKey . class ) ; <nl> if ( la ! = null ) <nl> langKey = la . value ( ) ; <nl> - <nl> + <nl> boolean requiresMcRestart = f . isAnnotationPresent ( Config . RequiresMcRestart . class ) ; <nl> boolean requiresWorldRestart = f . isAnnotationPresent ( Config . RequiresWorldRestart . class ) ; <nl> <nl> @ @ - 236 , 16 + 247 , 16 @ @ public class ConfigManager <nl> IFieldWrapper wrapper = FieldWrapper . get ( instance , f , category ) ; <nl> ITypeAdapter adapt = wrapper . getTypeAdapter ( ) ; <nl> Property . Type propType = adapt . getType ( ) ; <nl> - <nl> + <nl> for ( String key : wrapper . getKeys ( ) ) <nl> { <nl> String suffix = key . replaceFirst ( wrapper . getCategory ( ) + " . " , " " ) ; <nl> - <nl> + <nl> boolean existed = exists ( cfg , wrapper . getCategory ( ) , suffix ) ; <nl> if ( ! existed | | loading ) / / Creates keys in category specified by the wrapper if new ones are programaticaly added <nl> { <nl> Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; <nl> - <nl> + <nl> adapt . setDefaultValue ( property , wrapper . getValue ( key ) ) ; <nl> if ( ! existed ) <nl> adapt . setValue ( property , wrapper . getValue ( key ) ) ; <nl> @ @ - 253 , 7 + 264 , 7 @ @ public class ConfigManager <nl> wrapper . setValue ( key , adapt . getValue ( property ) ) ; <nl> } <nl> else / / If the key is not new , sync according to shoudlReadFromVar ( ) <nl> - { <nl> + { <nl> Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; <nl> Object propVal = adapt . getValue ( property ) ; <nl> Object mapVal = wrapper . getValue ( key ) ; <nl> @ @ - 263 , 25 + 274 , 25 @ @ public class ConfigManager <nl> wrapper . setValue ( key , propVal ) ; <nl> } <nl> } <nl> - <nl> + <nl> <nl> ConfigCategory confCat = cfg . getCategory ( wrapper . getCategory ( ) ) ; <nl> - <nl> + <nl> for ( Property property : confCat . getOrderedValues ( ) ) / / Are new keys in the Configuration object ? <nl> { <nl> if ( ! wrapper . handlesKey ( property . getName ( ) ) ) <nl> continue ; <nl> - <nl> + <nl> if ( loading | | ! wrapper . hasKey ( property . getName ( ) ) ) <nl> - { <nl> + { <nl> Object value = wrapper . getTypeAdapter ( ) . getValue ( property ) ; <nl> wrapper . setValue ( confCat . getName ( ) + " . " + property . getName ( ) , value ) ; <nl> } <nl> } <nl> - <nl> - if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . <nl> + <nl> + if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . <nl> wrapper . setupConfiguration ( cfg , comment , langKey , requiresMcRestart , requiresWorldRestart ) ; <nl> - <nl> + <nl> } <nl> catch ( Exception e ) / / If anything goes wrong , add the errored field and class . <nl> { <nl> @ @ - 289 , 9 + 300 , 9 @ @ public class ConfigManager <nl> String error = String . format ( format , f . getName ( ) , cls . getName ( ) ) ; <nl> throw new RuntimeException ( error , e ) ; <nl> } <nl> - } <nl> + } <nl> else if ( f . getType ( ) . getSuperclass ( ) ! = null & & f . getType ( ) . getSuperclass ( ) . equals ( Object . class ) ) / / Descend the object tree <nl> - { <nl> + { <nl> Object newInstance = null ; <nl> try <nl> { <nl> @ @ - 302 , 14 + 313 , 14 @ @ public class ConfigManager <nl> / / This should never happen . Previous checks should eliminate this . <nl> Throwables . propagate ( e ) ; <nl> } <nl> - <nl> + <nl> String sub = ( category . isEmpty ( ) ? " " : category + " . " ) + getName ( f ) . toLowerCase ( Locale . ENGLISH ) ; <nl> ConfigCategory confCat = cfg . getCategory ( sub ) ; <nl> confCat . setComment ( comment ) ; <nl> confCat . setLanguageKey ( langKey ) ; <nl> confCat . setRequiresMcRestart ( requiresMcRestart ) ; <nl> confCat . setRequiresWorldRestart ( requiresWorldRestart ) ; <nl> - <nl> + <nl> sync ( cfg , f . getType ( ) , modid , sub , loading , newInstance ) ; <nl> } <nl> else <nl> @ @ - 323 , 7 + 334 , 7 @ @ public class ConfigManager <nl> <nl> static final Joiner NEW _ LINE = Joiner . on ( ' \ n ' ) ; <nl> static final Joiner PIPE = Joiner . on ( ' | ' ) ; <nl> - <nl> + <nl> private static Property property ( Configuration cfg , String category , String property , Property . Type type , boolean isList ) <nl> { <nl> Property prop = cfg . getCategory ( category ) . get ( property ) ; <nl> @ @ - 337 , 12 + 348 , 12 @ @ public class ConfigManager <nl> } <nl> return prop ; <nl> } <nl> - <nl> + <nl> private static boolean exists ( Configuration cfg , String category , String property ) <nl> { <nl> return cfg . hasCategory ( category ) & & cfg . getCategory ( category ) . containsKey ( property ) ; <nl> } <nl> - <nl> + <nl> private static boolean shouldReadFromVar ( Property property , Object propValue , Object fieldValue ) <nl> { <nl> if ( ! propValue . equals ( fieldValue ) ) <nl> diff - - git a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> index 19272c5 . . 35fcfb4 100644 <nl> - - - a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> + + + b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java <nl> @ @ - 1 , 6 + 1 , 7 @ @ <nl> package net . minecraftforge . common . config ; <nl> <nl> import java . lang . reflect . Field ; <nl> + import java . lang . reflect . GenericArrayType ; <nl> import java . lang . reflect . ParameterizedType ; <nl> import java . lang . reflect . Type ; <nl> import java . util . Iterator ; <nl> @ @ - 67 , 6 + 68 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> { <nl> private Map < String , Object > theMap = null ; <nl> private Type mType ; <nl> + ITypeAdapter adapter ; <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> private MapWrapper ( String category , Field field , Object instance ) <nl> @ @ - 90 , 18 + 92 , 25 @ @ public abstract class FieldWrapper implements IFieldWrapper <nl> ParameterizedType type = ( ParameterizedType ) field . getGenericType ( ) ; <nl> mType = type . getActualTypeArguments ( ) [ 1 ] ; <nl> <nl> - if ( ADAPTERS . get ( mType ) = = null & & ! Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) <nl> + this . adapter = ADAPTERS . get ( mType ) ; <nl> + if ( this . adapter = = null & & mType instanceof GenericArrayType ) <nl> + { <nl> + this . adapter = ADAPTERS . get ( ARRAY _ REMAP . get ( ( ( GenericArrayType ) mType ) . getGenericComponentType ( ) ) ) ; / / J6 seems to have issues , Need to find a better way to translate this . We don ' t have access to array depth . <nl> + } <nl> + <nl> + if ( mType instanceof Class & & Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) <nl> + { <nl> + this . adapter = TypeAdapters . Str ; <nl> + } <nl> + <nl> + if ( this . adapter = = null ) <nl> throw new IllegalArgumentException ( String . format ( " The map ' % s ' of class ' % s ' has target values which are neither primitive nor an enum ! " , <nl> field . getName ( ) , field . getDeclaringClass ( ) . getCanonicalName ( ) ) ) ; <nl> - <nl> } <nl> <nl> @ Override <nl> public ITypeAdapter getTypeAdapter ( ) <nl> { <nl> - ITypeAdapter adapter = ADAPTERS . get ( mType ) ; <nl> - if ( adapter = = null & & Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) <nl> - adapter = TypeAdapters . Str ; <nl> return adapter ; <nl> } <nl> <nl> diff - - git a / src / test / java / net / minecraftforge / debug / ConfigTest . java b / src / test / java / net / minecraftforge / debug / ConfigTest . java <nl> index db6f5c1 . . fcd6c5a 100644 <nl> - - - a / src / test / java / net / minecraftforge / debug / ConfigTest . java <nl> + + + b / src / test / java / net / minecraftforge / debug / ConfigTest . java <nl> @ @ - 25 , 12 + 25 , 12 @ @ import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; <nl> public class ConfigTest <nl> { <nl> public static final String MODID = " config _ test " ; <nl> - <nl> + <nl> @ Mod . EventHandler <nl> public void preInit ( FMLPreInitializationEvent event ) { <nl> MinecraftForge . EVENT _ BUS . register ( this ) ; <nl> } <nl> - <nl> + <nl> @ Mod . EventHandler <nl> public void init ( FMLInitializationEvent event ) { <nl> System . out . println ( " Old : " + CONFIG _ TYPES . bool ) ; <nl> @ @ - 39 , 7 + 39 , 7 @ @ public class ConfigTest <nl> ConfigManager . sync ( MODID , Type . INSTANCE ) ; <nl> System . out . println ( " After sync : " + CONFIG _ TYPES . bool ) ; <nl> } <nl> - <nl> + <nl> @ SubscribeEvent <nl> public void onConfigChangedEvent ( OnConfigChangedEvent event ) { <nl> if ( event . getModID ( ) . equals ( MODID ) ) <nl> @ @ - 134 , 7 + 134 , 7 @ @ public class ConfigTest <nl> } <nl> } <nl> } <nl> - <nl> + <nl> @ LangKey ( " config _ test . config . maps " ) <nl> @ Config ( modid = MODID , name = MODID + " _ map " ) <nl> public static class CONFIG _ MAP <nl> @ @ - 142 , 8 + 142 , 8 @ @ public class ConfigTest <nl> @ Name ( " map " ) <nl> @ RequiresMcRestart <nl> public static Map < String , Integer [ ] > theMap ; <nl> - <nl> - static <nl> + <nl> + static <nl> { <nl> theMap = Maps . newHashMap ( ) ; <nl> for ( int i = 0 ; i < 7 ; i + + )

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / config / Configuration . java b / src / main / java / net / minecraftforge / common / config / Configuration . java 
 index d131553 . . e80322d 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / Configuration . java 
 + + + b / src / main / java / net / minecraftforge / common / config / Configuration . java 
 @ @ - 1412 , 10 + 1412 , 12 @ @ public class Configuration 
 { 
 if ( hasCategory ( category ) ) 
 { 
 - if ( getCategory ( category ) . containsKey ( oldPropName ) & & ! oldPropName . equalsIgnoreCase ( newPropName ) ) 
 + ConfigCategory cat = getCategory ( category ) ; 
 + if ( cat . containsKey ( oldPropName ) & & ! oldPropName . equalsIgnoreCase ( newPropName ) ) 
 { 
 - get ( category , newPropName , getCategory ( category ) . get ( oldPropName ) . getString ( ) , " " ) ; 
 - getCategory ( category ) . remove ( oldPropName ) ; 
 + Property prop = cat . remove ( oldPropName ) ; 
 + prop . setName ( newPropName ) ; 
 + cat . put ( newPropName , prop ) ; 
 return true ; 
 } 
 } 
 diff - - git a / src / test / java / net / minecraftforge / test / ConfigurationTest . java b / src / test / java / net / minecraftforge / test / ConfigurationTest . java 
 new file mode 100644 
 index 0000000 . . e242a1a 
 - - - / dev / null 
 + + + b / src / test / java / net / minecraftforge / test / ConfigurationTest . java 
 @ @ - 0 , 0 + 1 , 79 @ @ 
 + package net . minecraftforge . test ; 
 + 
 + 
 + import net . minecraft . init . Bootstrap ; 
 + import net . minecraftforge . common . config . ConfigCategory ; 
 + import net . minecraftforge . common . config . Configuration ; 
 + import net . minecraftforge . common . config . Property ; 
 + import net . minecraftforge . fml . common . Loader ; 
 + import net . minecraftforge . fml . common . registry . ForgeTestRunner ; 
 + import org . junit . Before ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import static junit . framework . TestCase . assertNull ; 
 + import static org . junit . Assert . * ; 
 + 
 + @ RunWith ( ForgeTestRunner . class ) 
 + public class ConfigurationTest { 
 + 
 + private Configuration config ; 
 + private ConfigCategory category ; 
 + 
 + @ BeforeClass 
 + public static void setupClass ( ) 
 + { 
 + Loader . instance ( ) ; 
 + Bootstrap . register ( ) ; 
 + } 
 + 
 + @ Before 
 + public void setup ( ) 
 + { 
 + Property enabledProperty = new Property ( " enabled " , " true " , Property . Type . BOOLEAN ) ; 
 + enabledProperty . setComment ( " enabled property comment " ) ; 
 + 
 + Property backgroundProperty = new Property ( " background " , " 0xFFFFFF " , Property . Type . COLOR ) ; 
 + backgroundProperty . setComment ( " background property comment " ) ; 
 + 
 + config = new Configuration ( ) ; 
 + category = config . getCategory ( " defaults " ) ; 
 + category . put ( enabledProperty . getName ( ) , enabledProperty ) ; 
 + category . put ( backgroundProperty . getName ( ) , backgroundProperty ) ; 
 + } 
 + 
 + @ Test 
 + public void testRenameProperty _ newNameNotInUse ( ) 
 + { 
 + boolean propertyRenamed = config . renameProperty ( " defaults " , " enabled " , " defaultEnabled " ) ; 
 + 
 + Property enabledProperty = category . get ( " enabled " ) ; 
 + Property defaultEnabledProperty = category . get ( " defaultEnabled " ) ; 
 + 
 + assertTrue ( " Property was not renamed " , propertyRenamed ) ; 
 + assertNull ( " Old property was not removed " , enabledProperty ) ; 
 + assertNotNull ( " New property was not added " , defaultEnabledProperty ) ; 
 + assertEquals ( " The property ' s name was not changed " , " defaultEnabled " , defaultEnabledProperty . getName ( ) ) ; 
 + assertEquals ( " The property ' s value changed " , " true " , defaultEnabledProperty . getString ( ) ) ; 
 + assertEquals ( " The property ' s type was changed " , Property . Type . BOOLEAN , defaultEnabledProperty . getType ( ) ) ; 
 + assertEquals ( " The property ' s comment was changed " , " enabled property comment " , defaultEnabledProperty . getComment ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testRenameProperty _ newNameInUse _ replaceExistingProperty ( ) 
 + { 
 + boolean propertyRenamed = config . renameProperty ( " defaults " , " enabled " , " background " ) ; 
 + 
 + Property enabledProperty = category . get ( " enabled " ) ; 
 + Property backgroundProperty = category . get ( " background " ) ; 
 + 
 + assertTrue ( " Property was not renamed " , propertyRenamed ) ; 
 + assertNull ( " Old property was not removed " , enabledProperty ) ; 
 + assertNotNull ( " New property was not added " , backgroundProperty ) ; 
 + assertEquals ( " The property ' s name was not changed " , " background " , backgroundProperty . getName ( ) ) ; 
 + assertEquals ( " The property ' s value changed " , " true " , backgroundProperty . getString ( ) ) ; 
 + assertEquals ( " The property ' s type was changed " , Property . Type . BOOLEAN , backgroundProperty . getType ( ) ) ; 
 + assertEquals ( " The property ' s comment was changed " , " enabled property comment " , backgroundProperty . getComment ( ) ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / src / main / java / net / minecraftforge / common / config / ConfigManager . java b / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 index fe2062e . . 34f2712 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 + + + b / src / main / java / net / minecraftforge / common / config / ConfigManager . java 
 @ @ - 50 , 6 + 50 , 7 @ @ public class ConfigManager 
 { 
 private static Map < String , Multimap < Config . Type , ASMData > > asm _ data = Maps . newHashMap ( ) ; 
 static Map < Class < ? > , ITypeAdapter > ADAPTERS = Maps . newHashMap ( ) ; 
 + static Map < Class < ? > , Class < ? > > ARRAY _ REMAP = Maps . newHashMap ( ) ; 
 private static Map < String , Configuration > CONFIGS = Maps . newHashMap ( ) ; 
 private static Map < String , Set < Class < ? > > > MOD _ CONFIG _ CLASSES = Maps . newHashMap ( ) ; 
 
 @ @ - 85 , 6 + 86 , 16 @ @ public class ConfigManager 
 register ( Integer [ ] . class , TypeAdapters . IntA ) ; 
 register ( String . class , TypeAdapters . Str ) ; 
 register ( String [ ] . class , TypeAdapters . StrA ) ; 
 + 
 + 
 + ARRAY _ REMAP . put ( Boolean . class , Boolean [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Float . class , Float [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Double . class , Double [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Byte . class , Byte [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Character . class , Character [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Short . class , Short [ ] . class ) ; 
 + ARRAY _ REMAP . put ( Integer . class , Integer [ ] . class ) ; 
 + ARRAY _ REMAP . put ( String . class , String [ ] . class ) ; 
 } 
 private static void register ( Class < ? > cls , ITypeAdapter adpt ) 
 { 
 @ @ - 110 , 7 + 121 , 7 @ @ public class ConfigManager 
 map . put ( type , target ) ; 
 } 
 } 
 - 
 + 
 / * * 
 * Bounces to sync ( ) . 
 * TODO : remove 
 @ @ - 123 , 13 + 134 , 13 @ @ public class ConfigManager 
 / * * 
 * Synchronizes configuration data between the file on disk , the { @ code Configuration } object and the annotated 
 * mod classes containing the configuration variables . 
 - * 
 + * 
 * When first called , this method will try to load the configuration from disk . If this fails , because the file 
 * does not exist , it will be created with default values derived from the mods config classes variable default values 
 * and comments and ranges , as well as configuration names based on the appropriate annotations found in { @ code @ Config } . 
 - * 
 + * 
 * Note , that this method is being called by the { @ link FMLModContaier } , so the mod needn ' t call it in init ( ) . 
 - * 
 + * 
 * If this method is called after the initial load , it will check whether the values in the Configuration object differ 
 * from the values in the corresponding variables . If they differ , it will either overwrite the variables if the Configuration 
 * object is marked as changed ( e . g . if it was changed with the ConfigGui ) or otherwise overwrite the Configuration object ' s values . 
 @ @ - 152 , 11 + 163 , 11 @ @ public class ConfigManager 
 try 
 { 
 Class < ? > cls = Class . forName ( targ . getClassName ( ) , true , mcl ) ; 
 - 
 + 
 if ( MOD _ CONFIG _ CLASSES . get ( modid ) = = null ) 
 MOD _ CONFIG _ CLASSES . put ( modid , Sets . < Class < ? > > newHashSet ( ) ) ; 
 MOD _ CONFIG _ CLASSES . get ( modid ) . add ( cls ) ; 
 - 
 + 
 String name = ( String ) targ . getAnnotationInfo ( ) . get ( " name " ) ; 
 if ( name = = null ) 
 name = modid ; 
 @ @ - 188 , 7 + 199 , 7 @ @ public class ConfigManager 
 } 
 } 
 } 
 - 
 + 
 public static Class < ? > [ ] getModConfigClasses ( String modid ) 
 { 
 return MOD _ CONFIG _ CLASSES . get ( modid ) . toArray ( new Class < ? > [ 0 ] ) ; 
 @ @ - 204 , 7 + 215 , 7 @ @ public class ConfigManager 
 File configFile = new File ( configDir , name + " . cfg " ) ; 
 return CONFIGS . get ( configFile . getAbsolutePath ( ) ) ; 
 } 
 - 
 + 
 private static void sync ( Configuration cfg , Class < ? > cls , String modid , String category , boolean loading , Object instance ) 
 { 
 for ( Field f : cls . getDeclaredFields ( ) ) 
 @ @ - 213 , 7 + 224 , 7 @ @ public class ConfigManager 
 continue ; 
 if ( Modifier . isStatic ( f . getModifiers ( ) ) ! = ( instance = = null ) ) 
 continue ; 
 - 
 + 
 String comment = null ; 
 Comment ca = f . getAnnotation ( Comment . class ) ; 
 if ( ca ! = null ) 
 @ @ - 223 , 7 + 234 , 7 @ @ public class ConfigManager 
 LangKey la = f . getAnnotation ( LangKey . class ) ; 
 if ( la ! = null ) 
 langKey = la . value ( ) ; 
 - 
 + 
 boolean requiresMcRestart = f . isAnnotationPresent ( Config . RequiresMcRestart . class ) ; 
 boolean requiresWorldRestart = f . isAnnotationPresent ( Config . RequiresWorldRestart . class ) ; 
 
 @ @ - 236 , 16 + 247 , 16 @ @ public class ConfigManager 
 IFieldWrapper wrapper = FieldWrapper . get ( instance , f , category ) ; 
 ITypeAdapter adapt = wrapper . getTypeAdapter ( ) ; 
 Property . Type propType = adapt . getType ( ) ; 
 - 
 + 
 for ( String key : wrapper . getKeys ( ) ) 
 { 
 String suffix = key . replaceFirst ( wrapper . getCategory ( ) + " . " , " " ) ; 
 - 
 + 
 boolean existed = exists ( cfg , wrapper . getCategory ( ) , suffix ) ; 
 if ( ! existed | | loading ) / / Creates keys in category specified by the wrapper if new ones are programaticaly added 
 { 
 Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; 
 - 
 + 
 adapt . setDefaultValue ( property , wrapper . getValue ( key ) ) ; 
 if ( ! existed ) 
 adapt . setValue ( property , wrapper . getValue ( key ) ) ; 
 @ @ - 253 , 7 + 264 , 7 @ @ public class ConfigManager 
 wrapper . setValue ( key , adapt . getValue ( property ) ) ; 
 } 
 else / / If the key is not new , sync according to shoudlReadFromVar ( ) 
 - { 
 + { 
 Property property = property ( cfg , wrapper . getCategory ( ) , suffix , propType , adapt . isArrayAdapter ( ) ) ; 
 Object propVal = adapt . getValue ( property ) ; 
 Object mapVal = wrapper . getValue ( key ) ; 
 @ @ - 263 , 25 + 274 , 25 @ @ public class ConfigManager 
 wrapper . setValue ( key , propVal ) ; 
 } 
 } 
 - 
 + 
 
 ConfigCategory confCat = cfg . getCategory ( wrapper . getCategory ( ) ) ; 
 - 
 + 
 for ( Property property : confCat . getOrderedValues ( ) ) / / Are new keys in the Configuration object ? 
 { 
 if ( ! wrapper . handlesKey ( property . getName ( ) ) ) 
 continue ; 
 - 
 + 
 if ( loading | | ! wrapper . hasKey ( property . getName ( ) ) ) 
 - { 
 + { 
 Object value = wrapper . getTypeAdapter ( ) . getValue ( property ) ; 
 wrapper . setValue ( confCat . getName ( ) + " . " + property . getName ( ) , value ) ; 
 } 
 } 
 - 
 - if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . 
 + 
 + if ( loading ) / / Doing this after the loops . The wrapper should set cosmetic stuff . 
 wrapper . setupConfiguration ( cfg , comment , langKey , requiresMcRestart , requiresWorldRestart ) ; 
 - 
 + 
 } 
 catch ( Exception e ) / / If anything goes wrong , add the errored field and class . 
 { 
 @ @ - 289 , 9 + 300 , 9 @ @ public class ConfigManager 
 String error = String . format ( format , f . getName ( ) , cls . getName ( ) ) ; 
 throw new RuntimeException ( error , e ) ; 
 } 
 - } 
 + } 
 else if ( f . getType ( ) . getSuperclass ( ) ! = null & & f . getType ( ) . getSuperclass ( ) . equals ( Object . class ) ) / / Descend the object tree 
 - { 
 + { 
 Object newInstance = null ; 
 try 
 { 
 @ @ - 302 , 14 + 313 , 14 @ @ public class ConfigManager 
 / / This should never happen . Previous checks should eliminate this . 
 Throwables . propagate ( e ) ; 
 } 
 - 
 + 
 String sub = ( category . isEmpty ( ) ? " " : category + " . " ) + getName ( f ) . toLowerCase ( Locale . ENGLISH ) ; 
 ConfigCategory confCat = cfg . getCategory ( sub ) ; 
 confCat . setComment ( comment ) ; 
 confCat . setLanguageKey ( langKey ) ; 
 confCat . setRequiresMcRestart ( requiresMcRestart ) ; 
 confCat . setRequiresWorldRestart ( requiresWorldRestart ) ; 
 - 
 + 
 sync ( cfg , f . getType ( ) , modid , sub , loading , newInstance ) ; 
 } 
 else 
 @ @ - 323 , 7 + 334 , 7 @ @ public class ConfigManager 
 
 static final Joiner NEW _ LINE = Joiner . on ( ' \ n ' ) ; 
 static final Joiner PIPE = Joiner . on ( ' | ' ) ; 
 - 
 + 
 private static Property property ( Configuration cfg , String category , String property , Property . Type type , boolean isList ) 
 { 
 Property prop = cfg . getCategory ( category ) . get ( property ) ; 
 @ @ - 337 , 12 + 348 , 12 @ @ public class ConfigManager 
 } 
 return prop ; 
 } 
 - 
 + 
 private static boolean exists ( Configuration cfg , String category , String property ) 
 { 
 return cfg . hasCategory ( category ) & & cfg . getCategory ( category ) . containsKey ( property ) ; 
 } 
 - 
 + 
 private static boolean shouldReadFromVar ( Property property , Object propValue , Object fieldValue ) 
 { 
 if ( ! propValue . equals ( fieldValue ) ) 
 diff - - git a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 index 19272c5 . . 35fcfb4 100644 
 - - - a / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 + + + b / src / main / java / net / minecraftforge / common / config / FieldWrapper . java 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package net . minecraftforge . common . config ; 
 
 import java . lang . reflect . Field ; 
 + import java . lang . reflect . GenericArrayType ; 
 import java . lang . reflect . ParameterizedType ; 
 import java . lang . reflect . Type ; 
 import java . util . Iterator ; 
 @ @ - 67 , 6 + 68 , 7 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 { 
 private Map < String , Object > theMap = null ; 
 private Type mType ; 
 + ITypeAdapter adapter ; 
 
 @ SuppressWarnings ( " unchecked " ) 
 private MapWrapper ( String category , Field field , Object instance ) 
 @ @ - 90 , 18 + 92 , 25 @ @ public abstract class FieldWrapper implements IFieldWrapper 
 ParameterizedType type = ( ParameterizedType ) field . getGenericType ( ) ; 
 mType = type . getActualTypeArguments ( ) [ 1 ] ; 
 
 - if ( ADAPTERS . get ( mType ) = = null & & ! Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) 
 + this . adapter = ADAPTERS . get ( mType ) ; 
 + if ( this . adapter = = null & & mType instanceof GenericArrayType ) 
 + { 
 + this . adapter = ADAPTERS . get ( ARRAY _ REMAP . get ( ( ( GenericArrayType ) mType ) . getGenericComponentType ( ) ) ) ; / / J6 seems to have issues , Need to find a better way to translate this . We don ' t have access to array depth . 
 + } 
 + 
 + if ( mType instanceof Class & & Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) 
 + { 
 + this . adapter = TypeAdapters . Str ; 
 + } 
 + 
 + if ( this . adapter = = null ) 
 throw new IllegalArgumentException ( String . format ( " The map ' % s ' of class ' % s ' has target values which are neither primitive nor an enum ! " , 
 field . getName ( ) , field . getDeclaringClass ( ) . getCanonicalName ( ) ) ) ; 
 - 
 } 
 
 @ Override 
 public ITypeAdapter getTypeAdapter ( ) 
 { 
 - ITypeAdapter adapter = ADAPTERS . get ( mType ) ; 
 - if ( adapter = = null & & Enum . class . isAssignableFrom ( ( Class < ? > ) mType ) ) 
 - adapter = TypeAdapters . Str ; 
 return adapter ; 
 } 
 
 diff - - git a / src / test / java / net / minecraftforge / debug / ConfigTest . java b / src / test / java / net / minecraftforge / debug / ConfigTest . java 
 index db6f5c1 . . fcd6c5a 100644 
 - - - a / src / test / java / net / minecraftforge / debug / ConfigTest . java 
 + + + b / src / test / java / net / minecraftforge / debug / ConfigTest . java 
 @ @ - 25 , 12 + 25 , 12 @ @ import net . minecraftforge . fml . common . eventhandler . SubscribeEvent ; 
 public class ConfigTest 
 { 
 public static final String MODID = " config _ test " ; 
 - 
 + 
 @ Mod . EventHandler 
 public void preInit ( FMLPreInitializationEvent event ) { 
 MinecraftForge . EVENT _ BUS . register ( this ) ; 
 } 
 - 
 + 
 @ Mod . EventHandler 
 public void init ( FMLInitializationEvent event ) { 
 System . out . println ( " Old : " + CONFIG _ TYPES . bool ) ; 
 @ @ - 39 , 7 + 39 , 7 @ @ public class ConfigTest 
 ConfigManager . sync ( MODID , Type . INSTANCE ) ; 
 System . out . println ( " After sync : " + CONFIG _ TYPES . bool ) ; 
 } 
 - 
 + 
 @ SubscribeEvent 
 public void onConfigChangedEvent ( OnConfigChangedEvent event ) { 
 if ( event . getModID ( ) . equals ( MODID ) ) 
 @ @ - 134 , 7 + 134 , 7 @ @ public class ConfigTest 
 } 
 } 
 } 
 - 
 + 
 @ LangKey ( " config _ test . config . maps " ) 
 @ Config ( modid = MODID , name = MODID + " _ map " ) 
 public static class CONFIG _ MAP 
 @ @ - 142 , 8 + 142 , 8 @ @ public class ConfigTest 
 @ Name ( " map " ) 
 @ RequiresMcRestart 
 public static Map < String , Integer [ ] > theMap ; 
 - 
 - static 
 + 
 + static 
 { 
 theMap = Maps . newHashMap ( ) ; 
 for ( int i = 0 ; i < 7 ; i + + )
