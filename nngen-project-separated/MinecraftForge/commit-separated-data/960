BLEU SCORE: 0.0114347838903095

TEST MSG: OreDictionary will warn if there ' s an invalid ore being registered now , rather than just
GENERATED MSG: Fix substitutions for recipes and oredict recipes . Should mean that substitutions start working properly .

TEST DIFF (one line): diff - - git a / src / main / java / net / minecraftforge / oredict / OreDictionary . java b / src / main / java / net / minecraftforge / oredict / OreDictionary . java <nl> index e18053e . . 2293518 100644 <nl> - - - a / src / main / java / net / minecraftforge / oredict / OreDictionary . java <nl> + + + b / src / main / java / net / minecraftforge / oredict / OreDictionary . java <nl> @ @ - 13 , 6 + 13 , 8 @ @ import java . util . RandomAccess ; <nl> import java . util . Map . Entry ; <nl> import java . util . Set ; <nl> <nl> + import org . apache . logging . log4j . Level ; <nl> + <nl> import net . minecraft . block . Block ; <nl> import net . minecraft . init . Blocks ; <nl> import net . minecraft . init . Items ; <nl> @ @ - 28 , 6 + 30 , 7 @ @ import com . google . common . collect . Lists ; <nl> import com . google . common . collect . Maps ; <nl> <nl> import cpw . mods . fml . common . FMLLog ; <nl> + import cpw . mods . fml . common . Loader ; <nl> import cpw . mods . fml . common . eventhandler . Event ; <nl> import cpw . mods . fml . common . registry . GameData ; <nl> <nl> @ @ - 494 , 8 + 497 , 22 @ @ public class OreDictionary <nl> } <nl> <nl> int oreID = getOreID ( name ) ; <nl> - 	 / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions <nl> - int hash = GameData . getItemRegistry ( ) . getId ( ore . getItem ( ) . delegate . name ( ) ) ; <nl> + / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions . Fallback to a - 1 value ( what Item . getIDForItem would have returned ) in the case where the registry is not aware of the item yet <nl> + / / IT should be noted that - 1 will fail the gate further down , if an entry already exists with value - 1 for this name . This is what is broken and being warned about . <nl> + / / APPARENTLY it ' s quite common to do this . OreDictionary should be considered alongside Recipes - you can ' t make them properly until you ' ve registered with the game . <nl> + String registryName = ore . getItem ( ) . delegate . name ( ) ; <nl> + int hash ; <nl> + if ( registryName = = null ) <nl> + { <nl> + FMLLog . bigWarning ( " A broken ore dictionary registration with name % s has occurred . It adds an item ( type : % s ) which is currently unknown to the game registry . This dictionary item can only support a single value when " <nl> + + " registered with ores like this , and NO I am not going to turn this spam off . Just register your ore dictionary entries after the GameRegistry . \ n " <nl> + + " TO USERS : YES this is a BUG in the mod " + Loader . instance ( ) . activeModContainer ( ) . getName ( ) + " report it to them ! " , name , ore . getItem ( ) . getClass ( ) ) ; <nl> + hash = - 1 ; <nl> + } <nl> + else <nl> + { <nl> + hash = GameData . getItemRegistry ( ) . getId ( registryName ) ; <nl> + } <nl> if ( ore . getItemDamage ( ) ! = WILDCARD _ VALUE ) <nl> { <nl> hash | = ( ( ore . getItemDamage ( ) + 1 ) < < 16 ) ; / / + 1 so 0 is significant <nl> @ @ - 539 , 8 + 556 , 18 @ @ public class OreDictionary <nl> if ( ores = = null ) continue ; <nl> for ( ItemStack ore : ores ) <nl> { <nl> - 	 	 / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions <nl> - int hash = GameData . getItemRegistry ( ) . getId ( ore . getItem ( ) . delegate . name ( ) ) ; <nl> + / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions <nl> + String name = ore . getItem ( ) . delegate . name ( ) ; <nl> + int hash ; <nl> + if ( name = = null ) <nl> + { <nl> + FMLLog . log ( Level . DEBUG , " Defaulting unregistered ore dictionary entry for ore dictionary % s : type % s to - 1 " , getOreName ( id ) , ore . getItem ( ) . getClass ( ) ) ; <nl> + hash = - 1 ; <nl> + } <nl> + else <nl> + { <nl> + hash = GameData . getItemRegistry ( ) . getId ( name ) ; <nl> + } <nl> if ( ore . getItemDamage ( ) ! = WILDCARD _ VALUE ) <nl> { <nl> hash | = ( ( ore . getItemDamage ( ) + 1 ) < < 16 ) ; / / + 1 so meta 0 is significant
NEAREST DIFF (one line): diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> index ef6a103 . . ab5e9a5 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java <nl> @ @ - 9 , 7 + 9 , 10 @ @ import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . Set ; <nl> <nl> + import org . apache . logging . log4j . Level ; <nl> + <nl> import net . minecraft . block . Block ; <nl> + import net . minecraft . item . Item ; <nl> import net . minecraft . item . ItemBlock ; <nl> import net . minecraft . util . ObjectIntIdentityMap ; <nl> import net . minecraft . util . RegistryNamespaced ; <nl> @ @ - 21 , 6 + 24 , 7 @ @ import com . google . common . collect . Iterators ; <nl> <nl> import cpw . mods . fml . common . FMLLog ; <nl> import cpw . mods . fml . common . functions . GenericIterableFactory ; <nl> + import cpw . mods . fml . common . registry . RegistryDelegate . Delegate ; <nl> <nl> public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> public static final boolean DEBUG = Boolean . parseBoolean ( System . getProperty ( " fml . debugRegistryEntries " , " false " ) ) ; <nl> @ @ - 51 , 9 + 55 , 10 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> { <nl> int id = getId ( obj ) ; <nl> String name = getNameForObject ( obj ) ; <nl> + boolean isSubstituted = activeSubstitutions . containsKey ( name ) ; <nl> <nl> / / id lookup failed - > obj is not in the obj < - > id map <nl> - if ( id < 0 ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , name % s , doesn ' t yield an id . " , type , obj , name ) ) ; <nl> + if ( ! isSubstituted & & id < 0 ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , name % s , doesn ' t yield an id . " , type , obj , name ) ) ; <nl> / / id is too high <nl> if ( id > maxId ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , name % s uses the too large id % d . " , type , obj , name ) ) ; <nl> / / name lookup failed - > obj is not in the obj < - > name map <nl> @ @ - 62 , 12 + 67 , 14 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> if ( name . isEmpty ( ) ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , id % d , yields an empty name . " , type , obj , id ) ) ; <nl> / / non - prefixed name <nl> if ( name . indexOf ( ' : ' ) = = - 1 ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , id % d , has the non - prefixed name % s . " , type , obj , id , name ) ) ; <nl> + / / the rest of the tests don ' t really work for substituted items or blocks <nl> + if ( isSubstituted ) continue ; <nl> / / id - > obj lookup is inconsistent <nl> if ( getRaw ( id ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for id % d , name % s , doesn ' t yield the expected % s % s . " , id , name , type , obj ) ) ; <nl> / / name - > obj lookup is inconsistent <nl> - if ( ! ( activeSubstitutions . containsKey ( name ) | | activeSubstitutions . containsValue ( name ) ) & & getRaw ( name ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for name % s , id % d , doesn ' t yield the expected % s % s . " , name , id , type , obj ) ) ; <nl> + if ( getRaw ( name ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for name % s , id % d , doesn ' t yield the expected % s % s . " , name , id , type , obj ) ) ; <nl> / / name - > id lookup is inconsistent <nl> - if ( ! ( activeSubstitutions . containsKey ( name ) | | activeSubstitutions . containsValue ( name ) ) & & getId ( name ) ! = id ) throw new IllegalStateException ( String . format ( " Registry entry for name % s doesn ' t yield the expected id % d . " , name , id ) ) ; <nl> + if ( getId ( name ) ! = id ) throw new IllegalStateException ( String . format ( " Registry entry for name % s doesn ' t yield the expected id % d . " , name , id ) ) ; <nl> / / id isn ' t marked as unavailable <nl> if ( ! availabilityMap . get ( id ) ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , id % d , name % s , marked as empty . " , type , obj , id , name ) ) ; <nl> / / entry is blocked , thus should be empty <nl> @ @ - 105 , 7 + 112 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> <nl> for ( I thing : registry . typeSafeIterable ( ) ) <nl> { <nl> - addObjectRaw ( registry . getId ( thing ) , registry . getNameForObject ( thing ) , thing ) ; <nl> + int id = registry . getId ( thing ) ; <nl> + addObjectRaw ( id , registry . getNameForObject ( thing ) , thing ) ; <nl> } <nl> this . activeSubstitutions . putAll ( registry . activeSubstitutions ) ; <nl> } <nl> @ @ - 239 , 9 + 247 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> * @ return <nl> * / <nl> @ SuppressWarnings ( " unchecked " ) <nl> - 	 private I cast ( Object obj ) <nl> + private I cast ( Object obj ) <nl> { <nl> - 	 return ( I ) ( obj ) ; <nl> + return ( I ) ( obj ) ; <nl> } <nl> / * * <nl> * Get the object identified by the specified name . <nl> @ @ - 475 , 6 + 483 , 19 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> { <nl> if ( getPersistentSubstitutions ( ) . containsKey ( nameToReplace ) ) <nl> { <nl> + I original = getRaw ( nameToReplace ) ; <nl> + if ( superType = = Item . class ) { <nl> + Item sub = ( Item ) getPersistentSubstitutions ( ) . get ( nameToReplace ) ; <nl> + if ( original = = null ) { <nl> + / / When we ' re activated from the server side , we need to set the delegate on the original instance to <nl> + / / point to us . Go to the " default state " registry to get it <nl> + original = ( I ) GameData . getItemRegistry ( ) . getRaw ( nameToReplace ) ; <nl> + } <nl> + FMLLog . log ( Level . DEBUG , " Replacing % s with % s ( name % s ) " , original , sub , nameToReplace ) ; <nl> + Delegate < Item > delegate = ( Delegate < Item > ) ( ( Item ) original ) . delegate ; <nl> + delegate . changeReference ( sub ) ; <nl> + ( ( Delegate < Item > ) sub . delegate ) . setName ( nameToReplace ) ; <nl> + } <nl> activeSubstitutions . put ( nameToReplace , getPersistentSubstitutions ( ) . get ( nameToReplace ) ) ; <nl> } <nl> } <nl> @ @ - 502 , 6 + 523 , 7 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> FMLLog . severe ( " The substitute % s for % s is registered into the game independently . This won ' t work " , replacement . getClass ( ) . getName ( ) , nameToReplace ) ; <nl> throw new IllegalArgumentException ( " The object substitution is already registered . This won ' t work " ) ; <nl> } <nl> + FMLLog . log ( Level . DEBUG , " Adding substitution % s with % s ( name % s ) " , original , replacement , nameToReplace ) ; <nl> getPersistentSubstitutions ( ) . put ( nameToReplace , replacement ) ; <nl> } <nl> <nl> @ @ - 529 , 4 + 551 , 13 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { <nl> { <nl> return Iterators . concat ( super . iterator ( ) , getPersistentSubstitutions ( ) . values ( ) . iterator ( ) ) ; <nl> } <nl> + <nl> + / / ONLY CALLED ON ITEM registry <nl> + void resetSubstitutionDelegates ( ) <nl> + { <nl> + for ( I item : typeSafeIterable ( ) ) { <nl> + Delegate < Item > delegate = ( Delegate < Item > ) ( ( Item ) item ) . delegate ; <nl> + delegate . changeReference ( ( Item ) item ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> index aa7ec6c . . 1369808 100644 <nl> - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java <nl> @ @ - 439 , 6 + 439 , 7 @ @ public class GameData { <nl> getMain ( ) . iBlockRegistry . dump ( ) ; <nl> getMain ( ) . iItemRegistry . dump ( ) ; <nl> <nl> + getMain ( ) . iItemRegistry . resetSubstitutionDelegates ( ) ; <nl> GameData newData = new GameData ( ) ; <nl> <nl> for ( int id : blockedIds ) <nl> diff - - git a / src / main / java / net / minecraftforge / oredict / OreDictionary . java b / src / main / java / net / minecraftforge / oredict / OreDictionary . java <nl> index 5b50060 . . e18053e 100644 <nl> - - - a / src / main / java / net / minecraftforge / oredict / OreDictionary . java <nl> + + + b / src / main / java / net / minecraftforge / oredict / OreDictionary . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import com . google . common . collect . Maps ; <nl> <nl> import cpw . mods . fml . common . FMLLog ; <nl> import cpw . mods . fml . common . eventhandler . Event ; <nl> + import cpw . mods . fml . common . registry . GameData ; <nl> <nl> public class OreDictionary <nl> { <nl> @ @ - 493 , 7 + 494 , 8 @ @ public class OreDictionary <nl> } <nl> <nl> int oreID = getOreID ( name ) ; <nl> - int hash = Item . getIdFromItem ( ore . getItem ( ) ) ; <nl> + 	 / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions <nl> + int hash = GameData . getItemRegistry ( ) . getId ( ore . getItem ( ) . delegate . name ( ) ) ; <nl> if ( ore . getItemDamage ( ) ! = WILDCARD _ VALUE ) <nl> { <nl> hash | = ( ( ore . getItemDamage ( ) + 1 ) < < 16 ) ; / / + 1 so 0 is significant <nl> @ @ - 537 , 7 + 539 , 8 @ @ public class OreDictionary <nl> if ( ores = = null ) continue ; <nl> for ( ItemStack ore : ores ) <nl> { <nl> - int hash = Item . getIdFromItem ( ore . getItem ( ) ) ; <nl> + 	 	 / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions <nl> + int hash = GameData . getItemRegistry ( ) . getId ( ore . getItem ( ) . delegate . name ( ) ) ; <nl> if ( ore . getItemDamage ( ) ! = WILDCARD _ VALUE ) <nl> { <nl> hash | = ( ( ore . getItemDamage ( ) + 1 ) < < 16 ) ; / / + 1 so meta 0 is significant

TEST DIFF:
diff - - git a / src / main / java / net / minecraftforge / oredict / OreDictionary . java b / src / main / java / net / minecraftforge / oredict / OreDictionary . java 
 index e18053e . . 2293518 100644 
 - - - a / src / main / java / net / minecraftforge / oredict / OreDictionary . java 
 + + + b / src / main / java / net / minecraftforge / oredict / OreDictionary . java 
 @ @ - 13 , 6 + 13 , 8 @ @ import java . util . RandomAccess ; 
 import java . util . Map . Entry ; 
 import java . util . Set ; 
 
 + import org . apache . logging . log4j . Level ; 
 + 
 import net . minecraft . block . Block ; 
 import net . minecraft . init . Blocks ; 
 import net . minecraft . init . Items ; 
 @ @ - 28 , 6 + 30 , 7 @ @ import com . google . common . collect . Lists ; 
 import com . google . common . collect . Maps ; 
 
 import cpw . mods . fml . common . FMLLog ; 
 + import cpw . mods . fml . common . Loader ; 
 import cpw . mods . fml . common . eventhandler . Event ; 
 import cpw . mods . fml . common . registry . GameData ; 
 
 @ @ - 494 , 8 + 497 , 22 @ @ public class OreDictionary 
 } 
 
 int oreID = getOreID ( name ) ; 
 - 	 / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions 
 - int hash = GameData . getItemRegistry ( ) . getId ( ore . getItem ( ) . delegate . name ( ) ) ; 
 + / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions . Fallback to a - 1 value ( what Item . getIDForItem would have returned ) in the case where the registry is not aware of the item yet 
 + / / IT should be noted that - 1 will fail the gate further down , if an entry already exists with value - 1 for this name . This is what is broken and being warned about . 
 + / / APPARENTLY it ' s quite common to do this . OreDictionary should be considered alongside Recipes - you can ' t make them properly until you ' ve registered with the game . 
 + String registryName = ore . getItem ( ) . delegate . name ( ) ; 
 + int hash ; 
 + if ( registryName = = null ) 
 + { 
 + FMLLog . bigWarning ( " A broken ore dictionary registration with name % s has occurred . It adds an item ( type : % s ) which is currently unknown to the game registry . This dictionary item can only support a single value when " 
 + + " registered with ores like this , and NO I am not going to turn this spam off . Just register your ore dictionary entries after the GameRegistry . \ n " 
 + + " TO USERS : YES this is a BUG in the mod " + Loader . instance ( ) . activeModContainer ( ) . getName ( ) + " report it to them ! " , name , ore . getItem ( ) . getClass ( ) ) ; 
 + hash = - 1 ; 
 + } 
 + else 
 + { 
 + hash = GameData . getItemRegistry ( ) . getId ( registryName ) ; 
 + } 
 if ( ore . getItemDamage ( ) ! = WILDCARD _ VALUE ) 
 { 
 hash | = ( ( ore . getItemDamage ( ) + 1 ) < < 16 ) ; / / + 1 so 0 is significant 
 @ @ - 539 , 8 + 556 , 18 @ @ public class OreDictionary 
 if ( ores = = null ) continue ; 
 for ( ItemStack ore : ores ) 
 { 
 - 	 	 / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions 
 - int hash = GameData . getItemRegistry ( ) . getId ( ore . getItem ( ) . delegate . name ( ) ) ; 
 + / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions 
 + String name = ore . getItem ( ) . delegate . name ( ) ; 
 + int hash ; 
 + if ( name = = null ) 
 + { 
 + FMLLog . log ( Level . DEBUG , " Defaulting unregistered ore dictionary entry for ore dictionary % s : type % s to - 1 " , getOreName ( id ) , ore . getItem ( ) . getClass ( ) ) ; 
 + hash = - 1 ; 
 + } 
 + else 
 + { 
 + hash = GameData . getItemRegistry ( ) . getId ( name ) ; 
 + } 
 if ( ore . getItemDamage ( ) ! = WILDCARD _ VALUE ) 
 { 
 hash | = ( ( ore . getItemDamage ( ) + 1 ) < < 16 ) ; / / + 1 so meta 0 is significant

NEAREST DIFF:
diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 index ef6a103 . . ab5e9a5 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / FMLControlledNamespacedRegistry . java 
 @ @ - 9 , 7 + 9 , 10 @ @ import java . util . List ; 
 import java . util . Map ; 
 import java . util . Set ; 
 
 + import org . apache . logging . log4j . Level ; 
 + 
 import net . minecraft . block . Block ; 
 + import net . minecraft . item . Item ; 
 import net . minecraft . item . ItemBlock ; 
 import net . minecraft . util . ObjectIntIdentityMap ; 
 import net . minecraft . util . RegistryNamespaced ; 
 @ @ - 21 , 6 + 24 , 7 @ @ import com . google . common . collect . Iterators ; 
 
 import cpw . mods . fml . common . FMLLog ; 
 import cpw . mods . fml . common . functions . GenericIterableFactory ; 
 + import cpw . mods . fml . common . registry . RegistryDelegate . Delegate ; 
 
 public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 public static final boolean DEBUG = Boolean . parseBoolean ( System . getProperty ( " fml . debugRegistryEntries " , " false " ) ) ; 
 @ @ - 51 , 9 + 55 , 10 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 { 
 int id = getId ( obj ) ; 
 String name = getNameForObject ( obj ) ; 
 + boolean isSubstituted = activeSubstitutions . containsKey ( name ) ; 
 
 / / id lookup failed - > obj is not in the obj < - > id map 
 - if ( id < 0 ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , name % s , doesn ' t yield an id . " , type , obj , name ) ) ; 
 + if ( ! isSubstituted & & id < 0 ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , name % s , doesn ' t yield an id . " , type , obj , name ) ) ; 
 / / id is too high 
 if ( id > maxId ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , name % s uses the too large id % d . " , type , obj , name ) ) ; 
 / / name lookup failed - > obj is not in the obj < - > name map 
 @ @ - 62 , 12 + 67 , 14 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 if ( name . isEmpty ( ) ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , id % d , yields an empty name . " , type , obj , id ) ) ; 
 / / non - prefixed name 
 if ( name . indexOf ( ' : ' ) = = - 1 ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , id % d , has the non - prefixed name % s . " , type , obj , id , name ) ) ; 
 + / / the rest of the tests don ' t really work for substituted items or blocks 
 + if ( isSubstituted ) continue ; 
 / / id - > obj lookup is inconsistent 
 if ( getRaw ( id ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for id % d , name % s , doesn ' t yield the expected % s % s . " , id , name , type , obj ) ) ; 
 / / name - > obj lookup is inconsistent 
 - if ( ! ( activeSubstitutions . containsKey ( name ) | | activeSubstitutions . containsValue ( name ) ) & & getRaw ( name ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for name % s , id % d , doesn ' t yield the expected % s % s . " , name , id , type , obj ) ) ; 
 + if ( getRaw ( name ) ! = obj ) throw new IllegalStateException ( String . format ( " Registry entry for name % s , id % d , doesn ' t yield the expected % s % s . " , name , id , type , obj ) ) ; 
 / / name - > id lookup is inconsistent 
 - if ( ! ( activeSubstitutions . containsKey ( name ) | | activeSubstitutions . containsValue ( name ) ) & & getId ( name ) ! = id ) throw new IllegalStateException ( String . format ( " Registry entry for name % s doesn ' t yield the expected id % d . " , name , id ) ) ; 
 + if ( getId ( name ) ! = id ) throw new IllegalStateException ( String . format ( " Registry entry for name % s doesn ' t yield the expected id % d . " , name , id ) ) ; 
 / / id isn ' t marked as unavailable 
 if ( ! availabilityMap . get ( id ) ) throw new IllegalStateException ( String . format ( " Registry entry for % s % s , id % d , name % s , marked as empty . " , type , obj , id , name ) ) ; 
 / / entry is blocked , thus should be empty 
 @ @ - 105 , 7 + 112 , 8 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 
 for ( I thing : registry . typeSafeIterable ( ) ) 
 { 
 - addObjectRaw ( registry . getId ( thing ) , registry . getNameForObject ( thing ) , thing ) ; 
 + int id = registry . getId ( thing ) ; 
 + addObjectRaw ( id , registry . getNameForObject ( thing ) , thing ) ; 
 } 
 this . activeSubstitutions . putAll ( registry . activeSubstitutions ) ; 
 } 
 @ @ - 239 , 9 + 247 , 9 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 * @ return 
 * / 
 @ SuppressWarnings ( " unchecked " ) 
 - 	 private I cast ( Object obj ) 
 + private I cast ( Object obj ) 
 { 
 - 	 return ( I ) ( obj ) ; 
 + return ( I ) ( obj ) ; 
 } 
 / * * 
 * Get the object identified by the specified name . 
 @ @ - 475 , 6 + 483 , 19 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 { 
 if ( getPersistentSubstitutions ( ) . containsKey ( nameToReplace ) ) 
 { 
 + I original = getRaw ( nameToReplace ) ; 
 + if ( superType = = Item . class ) { 
 + Item sub = ( Item ) getPersistentSubstitutions ( ) . get ( nameToReplace ) ; 
 + if ( original = = null ) { 
 + / / When we ' re activated from the server side , we need to set the delegate on the original instance to 
 + / / point to us . Go to the " default state " registry to get it 
 + original = ( I ) GameData . getItemRegistry ( ) . getRaw ( nameToReplace ) ; 
 + } 
 + FMLLog . log ( Level . DEBUG , " Replacing % s with % s ( name % s ) " , original , sub , nameToReplace ) ; 
 + Delegate < Item > delegate = ( Delegate < Item > ) ( ( Item ) original ) . delegate ; 
 + delegate . changeReference ( sub ) ; 
 + ( ( Delegate < Item > ) sub . delegate ) . setName ( nameToReplace ) ; 
 + } 
 activeSubstitutions . put ( nameToReplace , getPersistentSubstitutions ( ) . get ( nameToReplace ) ) ; 
 } 
 } 
 @ @ - 502 , 6 + 523 , 7 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 FMLLog . severe ( " The substitute % s for % s is registered into the game independently . This won ' t work " , replacement . getClass ( ) . getName ( ) , nameToReplace ) ; 
 throw new IllegalArgumentException ( " The object substitution is already registered . This won ' t work " ) ; 
 } 
 + FMLLog . log ( Level . DEBUG , " Adding substitution % s with % s ( name % s ) " , original , replacement , nameToReplace ) ; 
 getPersistentSubstitutions ( ) . put ( nameToReplace , replacement ) ; 
 } 
 
 @ @ - 529 , 4 + 551 , 13 @ @ public class FMLControlledNamespacedRegistry < I > extends RegistryNamespaced { 
 { 
 return Iterators . concat ( super . iterator ( ) , getPersistentSubstitutions ( ) . values ( ) . iterator ( ) ) ; 
 } 
 + 
 + / / ONLY CALLED ON ITEM registry 
 + void resetSubstitutionDelegates ( ) 
 + { 
 + for ( I item : typeSafeIterable ( ) ) { 
 + Delegate < Item > delegate = ( Delegate < Item > ) ( ( Item ) item ) . delegate ; 
 + delegate . changeReference ( ( Item ) item ) ; 
 + } 
 + } 
 } 
 diff - - git a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 index aa7ec6c . . 1369808 100644 
 - - - a / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 + + + b / fml / src / main / java / cpw / mods / fml / common / registry / GameData . java 
 @ @ - 439 , 6 + 439 , 7 @ @ public class GameData { 
 getMain ( ) . iBlockRegistry . dump ( ) ; 
 getMain ( ) . iItemRegistry . dump ( ) ; 
 
 + getMain ( ) . iItemRegistry . resetSubstitutionDelegates ( ) ; 
 GameData newData = new GameData ( ) ; 
 
 for ( int id : blockedIds ) 
 diff - - git a / src / main / java / net / minecraftforge / oredict / OreDictionary . java b / src / main / java / net / minecraftforge / oredict / OreDictionary . java 
 index 5b50060 . . e18053e 100644 
 - - - a / src / main / java / net / minecraftforge / oredict / OreDictionary . java 
 + + + b / src / main / java / net / minecraftforge / oredict / OreDictionary . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import com . google . common . collect . Maps ; 
 
 import cpw . mods . fml . common . FMLLog ; 
 import cpw . mods . fml . common . eventhandler . Event ; 
 + import cpw . mods . fml . common . registry . GameData ; 
 
 public class OreDictionary 
 { 
 @ @ - 493 , 7 + 494 , 8 @ @ public class OreDictionary 
 } 
 
 int oreID = getOreID ( name ) ; 
 - int hash = Item . getIdFromItem ( ore . getItem ( ) ) ; 
 + 	 / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions 
 + int hash = GameData . getItemRegistry ( ) . getId ( ore . getItem ( ) . delegate . name ( ) ) ; 
 if ( ore . getItemDamage ( ) ! = WILDCARD _ VALUE ) 
 { 
 hash | = ( ( ore . getItemDamage ( ) + 1 ) < < 16 ) ; / / + 1 so 0 is significant 
 @ @ - 537 , 7 + 539 , 8 @ @ public class OreDictionary 
 if ( ores = = null ) continue ; 
 for ( ItemStack ore : ores ) 
 { 
 - int hash = Item . getIdFromItem ( ore . getItem ( ) ) ; 
 + 	 	 / / HACK : use the registry name ' s ID . It is unique and it knows about substitutions 
 + int hash = GameData . getItemRegistry ( ) . getId ( ore . getItem ( ) . delegate . name ( ) ) ; 
 if ( ore . getItemDamage ( ) ! = WILDCARD _ VALUE ) 
 { 
 hash | = ( ( ore . getItemDamage ( ) + 1 ) < < 16 ) ; / / + 1 so meta 0 is significant
